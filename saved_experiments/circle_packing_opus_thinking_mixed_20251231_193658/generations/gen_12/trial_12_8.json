{
  "trial_id": "trial_12_8",
  "generation": 12,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial import Voronoi, distance_matrix\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Lloyd's algorithm\n    points = np.random.rand(n, 2)\n    \n    for iteration in range(100):\n        # Compute Voronoi diagram\n        vor = Voronoi(points)\n        \n        new_points = []\n        for i in range(n):\n            region_index = vor.point_region[i]\n            region = vor.regions[region_index]\n            \n            if -1 in region or len(region) == 0:\n                # Unbounded region, keep point as is\n                new_points.append(points[i])\n                continue\n            \n            # Get vertices of the Voronoi region\n            vertices = np.array([vor.vertices[j] for j in region])\n            \n            # Clip to unit square [0,1] x [0,1]\n            # Use Sutherland-Hodgeman algorithm for polygon clipping\n            clipped = clip_polygon_to_square(vertices)\n            \n            if len(clipped) > 0:\n                # Compute centroid\n                centroid = np.mean(clipped, axis=0)\n                # Ensure centroid is in [0,1] x [0,1]\n                centroid = np.clip(centroid, 0, 1)\n                new_points.append(centroid)\n            else:\n                new_points.append(points[i])\n        \n        points = np.array(new_points)\n    \n    # Compute radii as half the distance to nearest neighbor\n    dist_mat = distance_matrix(points, points)\n    np.fill_diagonal(dist_mat, np.inf)\n    min_distances = np.min(dist_mat, axis=1)\n    radii = min_distances / 2\n    \n    # Ensure circles are inside unit square\n    for i in range(n):\n        max_r = min(points[i, 0], points[i, 1], \n                   1 - points[i, 0], 1 - points[i, 1])\n        radii[i] = min(radii[i], max_r)\n    \n    # Polish with SLSQP\n    x0 = np.concatenate([points.flatten(), radii])\n    \n    def objective(x):\n        return -np.sum(x[2*n:])\n    \n    def constraints_func(x):\n        centers = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - r[i] - r[j])\n        \n        # Inside square constraints\n        for i in range(n):\n            constraints.append(centers[i, 0] - r[i])  # left\n            constraints.append(1 - centers[i, 0] - r[i])  # right\n            constraints.append(centers[i, 1] - r[i])  # bottom\n            constraints.append(1 - centers[i, 1] - r[i])  # top\n            constraints.append(r[i])  # non-negative radius\n        \n        return np.array(constraints)\n    \n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    cons = {'type': 'ineq', 'fun': constraints_func}\n    \n    result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                     constraints=cons, options={'maxiter': 1000})\n    \n    if result.success or True:  # Use result even if not fully converged\n        x_opt = result.x\n        centers = x_opt[:2*n].reshape(n, 2)\n        radii = x_opt[2*n:]\n    else:\n        centers = points\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef clip_polygon_to_square(vertices):\n    \"\"\"Clip polygon to unit square [0,1] x [0,1] using Sutherland-Hodgeman\"\"\"\n    def clip_edge(polygon, edge_normal, edge_point):\n        if len(polygon) == 0:\n            return polygon\n        \n        clipped = []\n        for i in range(len(polygon)):\n            p1 = polygon[i]\n            p2 = polygon[(i + 1) % len(polygon)]\n            \n            d1 = np.dot(p1 - edge_point, edge_normal)\n            d2 = np.dot(p2 - edge_point, edge_normal)\n            \n            if d1 >= 0:\n                clipped.append(p1)\n                if d2 < 0:\n                    # Intersection\n                    t = d1 / (d1 - d2)\n                    clipped.append(p1 + t * (p2 - p1))\n            elif d2 >= 0:\n                # Intersection\n                t = d1 / (d1 - d2)\n                clipped.append(p1 + t * (p2 - p1))\n        \n        return np.array(clipped) if len(clipped) > 0 else np.array([])\n    \n    polygon = vertices.copy()\n    \n    # Clip against left edge (x = 0)\n    polygon = clip_edge(polygon, np.array([1, 0]), np.array([0, 0]))\n    if len(polygon) == 0:\n        return polygon\n    \n    # Clip against right edge (x = 1)\n    polygon = clip_edge(polygon, np.array([-1, 0]), np.array([1, 0]))\n    if len(polygon) == 0:\n        return polygon\n    \n    # Clip against bottom edge (y = 0)\n    polygon = clip_edge(polygon, np.array([0, 1]), np.array([0, 0]))\n    if len(polygon) == 0:\n        return polygon\n    \n    # Clip against top edge (y = 1)\n    polygon = clip_edge(polygon, np.array([0, -1]), np.array([0, 1]))\n    \n    return polygon\n\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5910633827360257,
    "eval_time": 0.7808992862701416,
    "error": null
  },
  "prompt": "Create n=26 packing using LLOYD'S ALGORITHM:\n1. Start with 26 random points\n2. Compute Voronoi diagram (clipped to unit square)\n3. Move each point to its Voronoi cell centroid\n4. Repeat 100 times\n5. Place circles with radii = distance to nearest neighbor / 2\n6. Polish with SLSQP",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial import Voronoi, distance_matrix\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Lloyd's algorithm\n    points = np.random.rand(n, 2)\n    \n    for iteration in range(100):\n        # Compute Voronoi diagram\n        vor = Voronoi(points)\n        \n        new_points = []\n        for i in range(n):\n            region_index = vor.point_region[i]\n            region = vor.regions[region_index]\n            \n            if -1 in region or len(region) == 0:\n                # Unbounded region, keep point as is\n                new_points.append(points[i])\n                continue\n            \n            # Get vertices of the Voronoi region\n            vertices = np.array([vor.vertices[j] for j in region])\n            \n            # Clip to unit square [0,1] x [0,1]\n            # Use Sutherland-Hodgeman algorithm for polygon clipping\n            clipped = clip_polygon_to_square(vertices)\n            \n            if len(clipped) > 0:\n                # Compute centroid\n                centroid = np.mean(clipped, axis=0)\n                # Ensure centroid is in [0,1] x [0,1]\n                centroid = np.clip(centroid, 0, 1)\n                new_points.append(centroid)\n            else:\n                new_points.append(points[i])\n        \n        points = np.array(new_points)\n    \n    # Compute radii as half the distance to nearest neighbor\n    dist_mat = distance_matrix(points, points)\n    np.fill_diagonal(dist_mat, np.inf)\n    min_distances = np.min(dist_mat, axis=1)\n    radii = min_distances / 2\n    \n    # Ensure circles are inside unit square\n    for i in range(n):\n        max_r = min(points[i, 0], points[i, 1], \n                   1 - points[i, 0], 1 - points[i, 1])\n        radii[i] = min(radii[i], max_r)\n    \n    # Polish with SLSQP\n    x0 = np.concatenate([points.flatten(), radii])\n    \n    def objective(x):\n        return -np.sum(x[2*n:])\n    \n    def constraints_func(x):\n        centers = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        constraints = []\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - r[i] - r[j])\n        \n        # Inside square constraints\n        for i in range(n):\n            constraints.append(centers[i, 0] - r[i])  # left\n            constraints.append(1 - centers[i, 0] - r[i])  # right\n            constraints.append(centers[i, 1] - r[i])  # bottom\n            constraints.append(1 - centers[i, 1] - r[i])  # top\n            constraints.append(r[i])  # non-negative radius\n        \n        return np.array(constraints)\n    \n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    cons = {'type': 'ineq', 'fun': constraints_func}\n    \n    result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                     constraints=cons, options={'maxiter': 1000})\n    \n    if result.success or True:  # Use result even if not fully converged\n        x_opt = result.x\n        centers = x_opt[:2*n].reshape(n, 2)\n        radii = x_opt[2*n:]\n    else:\n        centers = points\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef clip_polygon_to_square(vertices):\n    \"\"\"Clip polygon to unit square [0,1] x [0,1] using Sutherland-Hodgeman\"\"\"\n    def clip_edge(polygon, edge_normal, edge_point):\n        if len(polygon) == 0:\n            return polygon\n        \n        clipped = []\n        for i in range(len(polygon)):\n            p1 = polygon[i]\n            p2 = polygon[(i + 1) % len(polygon)]\n            \n            d1 = np.dot(p1 - edge_point, edge_normal)\n            d2 = np.dot(p2 - edge_point, edge_normal)\n            \n            if d1 >= 0:\n                clipped.append(p1)\n                if d2 < 0:\n                    # Intersection\n                    t = d1 / (d1 - d2)\n                    clipped.append(p1 + t * (p2 - p1))\n            elif d2 >= 0:\n                # Intersection\n                t = d1 / (d1 - d2)\n                clipped.append(p1 + t * (p2 - p1))\n        \n        return np.array(clipped) if len(clipped) > 0 else np.array([])\n    \n    polygon = vertices.copy()\n    \n    # Clip against left edge (x = 0)\n    polygon = clip_edge(polygon, np.array([1, 0]), np.array([0, 0]))\n    if len(polygon) == 0:\n        return polygon\n    \n    # Clip against right edge (x = 1)\n    polygon = clip_edge(polygon, np.array([-1, 0]), np.array([1, 0]))\n    if len(polygon) == 0:\n        return polygon\n    \n    # Clip against bottom edge (y = 0)\n    polygon = clip_edge(polygon, np.array([0, 1]), np.array([0, 0]))\n    if len(polygon) == 0:\n        return polygon\n    \n    # Clip against top edge (y = 1)\n    polygon = clip_edge(polygon, np.array([0, -1]), np.array([0, 1]))\n    \n    return polygon\n\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T21:01:59.904729",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}