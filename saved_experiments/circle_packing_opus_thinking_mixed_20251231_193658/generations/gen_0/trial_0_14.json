{
  "trial_id": "trial_0_14",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef compute_max_radii(centers):\n    N = centers.shape[0]\n    if N == 0:\n        return np.array([]), 0.0\n    dists_to_bound = np.stack([centers[:, 0], 1 - centers[:, 0], centers[:, 1], 1 - centers[:, 1]])\n    b = np.min(dists_to_bound, axis=0)\n    A_rows = []\n    b_ub_list = []\n    # Boundary constraints: r_i <= b_i\n    for i in range(N):\n        row = np.zeros(N)\n        row[i] = 1.0\n        A_rows.append(row)\n        b_ub_list.append(b[i])\n    # Pairwise constraints: r_i + r_j <= d_ij\n    for i in range(N):\n        for j in range(i + 1, N):\n            row = np.zeros(N)\n            row[i] = 1.0\n            row[j] = 1.0\n            d = np.linalg.norm(centers[i] - centers[j])\n            A_rows.append(row)\n            b_ub_list.append(d)\n    A_ub = np.array(A_rows)\n    b_ub = np.array(b_ub_list)\n    c = -np.ones(N)\n    bounds = [(0, None) for _ in range(N)]\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    if res.success:\n        return res.x, np.sum(res.x)\n    else:\n        return np.zeros(N), 0.0\n\ndef construct_packing():\n    # Generate candidate centers on a grid, inset slightly\n    nx = 20\n    xs = np.linspace(0.05, 0.95, nx)\n    XX, YY = np.meshgrid(xs, xs)\n    candidates = np.column_stack([XX.ravel(), YY.ravel()])\n    Nc = candidates.shape[0]\n\n    # Greedy selection to maximize incremental sum of radii\n    selected_set = set()\n    current_centers = np.empty((0, 2))\n    for _ in range(26):\n        best_sum = -np.inf\n        best_k = -1\n        for k in range(Nc):\n            if k in selected_set:\n                continue\n            test_centers = np.vstack([current_centers, candidates[k]])\n            _, test_sum = compute_max_radii(test_centers)\n            if test_sum > best_sum:\n                best_sum = test_sum\n                best_k = k\n        if best_k == -1:\n            break\n        selected_set.add(best_k)\n        current_centers = np.vstack([current_centers, candidates[best_k]])\n\n    # Final computation\n    radii, sum_radii = compute_max_radii(current_centers)\n    centers = current_centers\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.7967447201291908,
    "eval_time": 6.808945894241333,
    "error": null
  },
  "prompt": "Circle packing: 26 circles in unit square.\n\nBOUNDARY-FOCUSED strategy:\n1. First place circles that touch the boundary (tangent to edges)\n2. Large circles touch one corner and two edges\n3. Medium circles touch one edge\n4. Interior circles fill the remaining space\n5. Optimize all positions/radii jointly at the end\n\n```python\nimport numpy as np\n\ndef construct_packing():\n    pass\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef compute_max_radii(centers):\n    N = centers.shape[0]\n    if N == 0:\n        return np.array([]), 0.0\n    dists_to_bound = np.stack([centers[:, 0], 1 - centers[:, 0], centers[:, 1], 1 - centers[:, 1]])\n    b = np.min(dists_to_bound, axis=0)\n    A_rows = []\n    b_ub_list = []\n    # Boundary constraints: r_i <= b_i\n    for i in range(N):\n        row = np.zeros(N)\n        row[i] = 1.0\n        A_rows.append(row)\n        b_ub_list.append(b[i])\n    # Pairwise constraints: r_i + r_j <= d_ij\n    for i in range(N):\n        for j in range(i + 1, N):\n            row = np.zeros(N)\n            row[i] = 1.0\n            row[j] = 1.0\n            d = np.linalg.norm(centers[i] - centers[j])\n            A_rows.append(row)\n            b_ub_list.append(d)\n    A_ub = np.array(A_rows)\n    b_ub = np.array(b_ub_list)\n    c = -np.ones(N)\n    bounds = [(0, None) for _ in range(N)]\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    if res.success:\n        return res.x, np.sum(res.x)\n    else:\n        return np.zeros(N), 0.0\n\ndef construct_packing():\n    # Generate candidate centers on a grid, inset slightly\n    nx = 20\n    xs = np.linspace(0.05, 0.95, nx)\n    XX, YY = np.meshgrid(xs, xs)\n    candidates = np.column_stack([XX.ravel(), YY.ravel()])\n    Nc = candidates.shape[0]\n\n    # Greedy selection to maximize incremental sum of radii\n    selected_set = set()\n    current_centers = np.empty((0, 2))\n    for _ in range(26):\n        best_sum = -np.inf\n        best_k = -1\n        for k in range(Nc):\n            if k in selected_set:\n                continue\n            test_centers = np.vstack([current_centers, candidates[k]])\n            _, test_sum = compute_max_radii(test_centers)\n            if test_sum > best_sum:\n                best_sum = test_sum\n                best_k = k\n        if best_k == -1:\n            break\n        selected_set.add(best_k)\n        current_centers = np.vstack([current_centers, candidates[best_k]])\n\n    # Final computation\n    radii, sum_radii = compute_max_radii(current_centers)\n    centers = current_centers\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T19:44:21.645660",
  "cost_data": null,
  "model_config": {
    "model": "x-ai/grok-4.1-fast",
    "temperature": 0.7
  }
}