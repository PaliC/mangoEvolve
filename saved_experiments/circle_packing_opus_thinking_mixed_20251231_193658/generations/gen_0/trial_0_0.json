{
  "trial_id": "trial_0_0",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    centers_list = []\n    radii_list = []\n    for k in range(26):\n        existing_centers = np.array(centers_list) if centers_list else np.empty((0, 2))\n        existing_radii = np.array(radii_list) if radii_list else np.empty((0,))\n        n_exist = len(existing_radii)\n\n        def objective(p):\n            return -p[2]\n\n        # Overlap constraints\n        cons = [\n            {'type': 'ineq', 'fun': lambda p, c=existing_centers[j], r=existing_radii[j]: np.linalg.norm(p[:2] - c) - p[2] - r}\n            for j in range(n_exist)\n        ]\n        # Boundary constraints\n        cons += [\n            {'type': 'ineq', 'fun': lambda p: p[0] - p[2]},\n            {'type': 'ineq', 'fun': lambda p: p[1] - p[2]},\n            {'type': 'ineq', 'fun': lambda p: 1.0 - p[0] - p[2]},\n            {'type': 'ineq', 'fun': lambda p: 1.0 - p[1] - p[2]}\n        ]\n\n        bounds = [(0, 1), (0, 1), (0, 0.5)]\n\n        best_r = 0.0\n        best_p = np.array([0.5, 0.5, 0.0])\n\n        # Grid starts, adaptive grid size\n        n_grid = 12 if k < 5 else 10 if k < 15 else 8\n        xstarts = np.linspace(0.05, 0.95, n_grid)\n        ystarts = np.linspace(0.05, 0.95, n_grid)\n        rstarts = np.linspace(0.001, 0.2, 5)\n\n        for xs in xstarts:\n            for ys in ystarts:\n                for rs in rstarts:\n                    p0 = np.array([xs, ys, rs])\n                    res = minimize(\n                        objective, p0, method='SLSQP',\n                        bounds=bounds, constraints=cons,\n                        options={'ftol': 1e-9, 'maxiter': 200}\n                    )\n                    if res.success and -res.fun > best_r + 1e-10:\n                        best_r = -res.fun\n                        best_p = res.x.copy()\n\n        # Random starts\n        n_random = 50\n        for _ in range(n_random):\n            rs = np.random.uniform(1e-4, 0.15)\n            xs = np.random.uniform(rs, 1 - rs)\n            ys = np.random.uniform(rs, 1 - rs)\n            p0 = np.array([xs, ys, rs])\n            res = minimize(\n                objective, p0, method='SLSQP',\n                bounds=bounds, constraints=cons,\n                options={'ftol': 1e-9, 'maxiter': 200}\n            )\n            if res.success and -res.fun > best_r + 1e-10:\n                best_r = -res.fun\n                best_p = res.x.copy()\n\n        # Fallback if no success (unlikely)\n        if best_r < 1e-6:\n            best_p = np.array([0.5, 0.5, 1e-6])\n            best_r = 1e-6\n\n        centers_list.append(best_p[:2])\n        radii_list.append(best_p[2])\n\n    centers = np.array(centers_list)\n    radii = np.array(radii_list)\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.4768589841816349,
    "eval_time": 52.53552579879761,
    "error": null
  },
  "prompt": "Create a circle packing algorithm for 26 circles in a unit square [0,1]x[0,1].\n\nUse a GREEDY SEQUENTIAL approach:\n1. Place circles one at a time\n2. For each new circle, find the position and radius that maximizes the radius\n3. The circle must not overlap existing circles and must stay inside the square\n4. Use scipy optimization to find optimal (x, y, r) for each circle\n\nReturn format:\n```python\nimport numpy as np\n\ndef construct_packing():\n    # Your implementation\n    pass\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    centers_list = []\n    radii_list = []\n    for k in range(26):\n        existing_centers = np.array(centers_list) if centers_list else np.empty((0, 2))\n        existing_radii = np.array(radii_list) if radii_list else np.empty((0,))\n        n_exist = len(existing_radii)\n\n        def objective(p):\n            return -p[2]\n\n        # Overlap constraints\n        cons = [\n            {'type': 'ineq', 'fun': lambda p, c=existing_centers[j], r=existing_radii[j]: np.linalg.norm(p[:2] - c) - p[2] - r}\n            for j in range(n_exist)\n        ]\n        # Boundary constraints\n        cons += [\n            {'type': 'ineq', 'fun': lambda p: p[0] - p[2]},\n            {'type': 'ineq', 'fun': lambda p: p[1] - p[2]},\n            {'type': 'ineq', 'fun': lambda p: 1.0 - p[0] - p[2]},\n            {'type': 'ineq', 'fun': lambda p: 1.0 - p[1] - p[2]}\n        ]\n\n        bounds = [(0, 1), (0, 1), (0, 0.5)]\n\n        best_r = 0.0\n        best_p = np.array([0.5, 0.5, 0.0])\n\n        # Grid starts, adaptive grid size\n        n_grid = 12 if k < 5 else 10 if k < 15 else 8\n        xstarts = np.linspace(0.05, 0.95, n_grid)\n        ystarts = np.linspace(0.05, 0.95, n_grid)\n        rstarts = np.linspace(0.001, 0.2, 5)\n\n        for xs in xstarts:\n            for ys in ystarts:\n                for rs in rstarts:\n                    p0 = np.array([xs, ys, rs])\n                    res = minimize(\n                        objective, p0, method='SLSQP',\n                        bounds=bounds, constraints=cons,\n                        options={'ftol': 1e-9, 'maxiter': 200}\n                    )\n                    if res.success and -res.fun > best_r + 1e-10:\n                        best_r = -res.fun\n                        best_p = res.x.copy()\n\n        # Random starts\n        n_random = 50\n        for _ in range(n_random):\n            rs = np.random.uniform(1e-4, 0.15)\n            xs = np.random.uniform(rs, 1 - rs)\n            ys = np.random.uniform(rs, 1 - rs)\n            p0 = np.array([xs, ys, rs])\n            res = minimize(\n                objective, p0, method='SLSQP',\n                bounds=bounds, constraints=cons,\n                options={'ftol': 1e-9, 'maxiter': 200}\n            )\n            if res.success and -res.fun > best_r + 1e-10:\n                best_r = -res.fun\n                best_p = res.x.copy()\n\n        # Fallback if no success (unlikely)\n        if best_r < 1e-6:\n            best_p = np.array([0.5, 0.5, 1e-6])\n            best_r = 1e-6\n\n        centers_list.append(best_p[:2])\n        radii_list.append(best_p[2])\n\n    centers = np.array(centers_list)\n    radii = np.array(radii_list)\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T19:43:07.895616",
  "cost_data": null,
  "model_config": {
    "model": "x-ai/grok-4.1-fast",
    "temperature": 0.7
  }
}