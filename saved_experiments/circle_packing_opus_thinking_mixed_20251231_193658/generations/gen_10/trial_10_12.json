{
  "trial_id": "trial_10_12",
  "generation": 10,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Phase 1: Force-directed initialization\n    centers = np.random.uniform(0.1, 0.9, (n, 2))\n    radii = np.full(n, 0.01)\n    \n    # Force-directed simulation\n    for iteration in range(500):\n        forces = np.zeros((n, 2))\n        \n        # Repulsive forces between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist + 0.05:  # Repel if too close\n                    if dist > 1e-6:\n                        force_mag = (min_dist + 0.05 - dist) / dist\n                        force = diff * force_mag\n                        forces[i] += force * 0.5\n                        forces[j] -= force * 0.5\n        \n        # Attractive force toward center (for compactness)\n        center_point = np.array([0.5, 0.5])\n        for i in range(n):\n            diff = center_point - centers[i]\n            forces[i] += diff * 0.1\n        \n        # Boundary repulsion\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                forces[i, 0] += (radii[i] - centers[i, 0]) * 2\n            if centers[i, 0] + radii[i] > 1:\n                forces[i, 0] -= (centers[i, 0] + radii[i] - 1) * 2\n            if centers[i, 1] - radii[i] < 0:\n                forces[i, 1] += (radii[i] - centers[i, 1]) * 2\n            if centers[i, 1] + radii[i] > 1:\n                forces[i, 1] -= (centers[i, 1] + radii[i] - 1) * 2\n        \n        # Update positions\n        centers += forces * 0.01\n        centers = np.clip(centers, 0.02, 0.98)\n    \n    # Phase 2: Gradual radius growth\n    for growth_iter in range(100):\n        # Try to grow all radii\n        growth_rate = 0.001 * (1 - growth_iter / 100)\n        \n        for i in range(n):\n            # Try to grow this radius\n            new_radius = radii[i] + growth_rate\n            \n            # Check constraints\n            valid = True\n            \n            # Boundary check\n            if (centers[i, 0] - new_radius < 0 or centers[i, 0] + new_radius > 1 or\n                centers[i, 1] - new_radius < 0 or centers[i, 1] + new_radius > 1):\n                valid = False\n            \n            # Overlap check\n            if valid:\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < new_radius + radii[j] - 1e-6:\n                            valid = False\n                            break\n            \n            if valid:\n                radii[i] = new_radius\n    \n    # Phase 3: Optimization with SLSQP\n    def objective(x):\n        r = x[2*n:]\n        return -np.sum(r)\n    \n    def constraints_func(x):\n        c = x[:n]\n        r = x[2*n:]\n        constraints_vals = []\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints_vals.append(c[i] - r[i])  # left\n            constraints_vals.append(1 - c[i] - r[i])  # right\n            constraints_vals.append(c[n+i] - r[i])  # bottom\n            constraints_vals.append(1 - c[n+i] - r[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((c[i] - c[j])**2 + (c[n+i] - c[n+j])**2)\n                constraints_vals.append(dist - r[i] - r[j])\n        \n        return np.array(constraints_vals)\n    \n    x0 = np.concatenate([centers[:, 0], centers[:, 1], radii])\n    bounds = [(0, 1)] * (2*n) + [(0, 1)] * n\n    \n    constraint = {'type': 'ineq', 'fun': constraints_func}\n    \n    result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                     constraints=constraint, options={'maxiter': 1000, 'ftol': 1e-9})\n    \n    if result.success:\n        x_opt = result.x\n        centers_opt = np.column_stack([x_opt[:n], x_opt[n:2*n]])\n        radii_opt = x_opt[2*n:]\n    else:\n        centers_opt = centers\n        radii_opt = radii\n    \n    sum_radii = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.4847393035888672,
    "error": "IndexError: index 26 is out of bounds for axis 0 with size 26"
  },
  "prompt": "Create circle packing using FORCE-DIRECTED placement:\n\n1. Start with 26 random circles\n2. Apply repulsive forces between overlapping circles\n3. Apply attractive forces to pack them tightly\n4. Grow radii gradually while maintaining separation\n5. Polish with SLSQP\n\nPhysics-based approach may find different optima.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Phase 1: Force-directed initialization\n    centers = np.random.uniform(0.1, 0.9, (n, 2))\n    radii = np.full(n, 0.01)\n    \n    # Force-directed simulation\n    for iteration in range(500):\n        forces = np.zeros((n, 2))\n        \n        # Repulsive forces between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist + 0.05:  # Repel if too close\n                    if dist > 1e-6:\n                        force_mag = (min_dist + 0.05 - dist) / dist\n                        force = diff * force_mag\n                        forces[i] += force * 0.5\n                        forces[j] -= force * 0.5\n        \n        # Attractive force toward center (for compactness)\n        center_point = np.array([0.5, 0.5])\n        for i in range(n):\n            diff = center_point - centers[i]\n            forces[i] += diff * 0.1\n        \n        # Boundary repulsion\n        for i in range(n):\n            if centers[i, 0] - radii[i] < 0:\n                forces[i, 0] += (radii[i] - centers[i, 0]) * 2\n            if centers[i, 0] + radii[i] > 1:\n                forces[i, 0] -= (centers[i, 0] + radii[i] - 1) * 2\n            if centers[i, 1] - radii[i] < 0:\n                forces[i, 1] += (radii[i] - centers[i, 1]) * 2\n            if centers[i, 1] + radii[i] > 1:\n                forces[i, 1] -= (centers[i, 1] + radii[i] - 1) * 2\n        \n        # Update positions\n        centers += forces * 0.01\n        centers = np.clip(centers, 0.02, 0.98)\n    \n    # Phase 2: Gradual radius growth\n    for growth_iter in range(100):\n        # Try to grow all radii\n        growth_rate = 0.001 * (1 - growth_iter / 100)\n        \n        for i in range(n):\n            # Try to grow this radius\n            new_radius = radii[i] + growth_rate\n            \n            # Check constraints\n            valid = True\n            \n            # Boundary check\n            if (centers[i, 0] - new_radius < 0 or centers[i, 0] + new_radius > 1 or\n                centers[i, 1] - new_radius < 0 or centers[i, 1] + new_radius > 1):\n                valid = False\n            \n            # Overlap check\n            if valid:\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < new_radius + radii[j] - 1e-6:\n                            valid = False\n                            break\n            \n            if valid:\n                radii[i] = new_radius\n    \n    # Phase 3: Optimization with SLSQP\n    def objective(x):\n        r = x[2*n:]\n        return -np.sum(r)\n    \n    def constraints_func(x):\n        c = x[:n]\n        r = x[2*n:]\n        constraints_vals = []\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints_vals.append(c[i] - r[i])  # left\n            constraints_vals.append(1 - c[i] - r[i])  # right\n            constraints_vals.append(c[n+i] - r[i])  # bottom\n            constraints_vals.append(1 - c[n+i] - r[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((c[i] - c[j])**2 + (c[n+i] - c[n+j])**2)\n                constraints_vals.append(dist - r[i] - r[j])\n        \n        return np.array(constraints_vals)\n    \n    x0 = np.concatenate([centers[:, 0], centers[:, 1], radii])\n    bounds = [(0, 1)] * (2*n) + [(0, 1)] * n\n    \n    constraint = {'type': 'ineq', 'fun': constraints_func}\n    \n    result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                     constraints=constraint, options={'maxiter': 1000, 'ftol': 1e-9})\n    \n    if result.success:\n        x_opt = result.x\n        centers_opt = np.column_stack([x_opt[:n], x_opt[n:2*n]])\n        radii_opt = x_opt[2*n:]\n    else:\n        centers_opt = centers\n        radii_opt = radii\n    \n    sum_radii = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T20:48:51.146506",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}