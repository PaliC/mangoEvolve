{
  "trial_id": "trial_6_7",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef construct_packing():\n    n = 26\n    best_result = None\n    best_sum = 0\n    \n    # Try multiple random restarts\n    for restart in range(10):\n        if restart == 0:\n            # Start with hexagonal grid\n            centers = []\n            radii = []\n            \n            # Hexagonal packing pattern\n            rows = 5\n            for row in range(rows):\n                y = 0.15 + row * 0.18\n                if row % 2 == 0:\n                    x_start = 0.15\n                    n_in_row = 6\n                else:\n                    x_start = 0.24\n                    n_in_row = 5\n                \n                for col in range(n_in_row):\n                    if len(centers) < n:\n                        x = x_start + col * 0.18\n                        centers.append([x, y])\n                        radii.append(0.08)\n            \n            # Fill remaining with random positions\n            while len(centers) < n:\n                centers.append([np.random.uniform(0.1, 0.9), \n                               np.random.uniform(0.1, 0.9)])\n                radii.append(0.05)\n            \n            x0 = np.concatenate([np.array(centers).flatten(), np.array(radii)])\n        else:\n            # Random initialization with smaller radii\n            centers = np.random.uniform(0.15, 0.85, (n, 2))\n            radii = np.random.uniform(0.03, 0.07, n)\n            x0 = np.concatenate([centers.flatten(), radii])\n        \n        # Objective: maximize sum of radii = minimize negative sum\n        def objective(x):\n            r = x[2*n:]\n            return -np.sum(r)\n        \n        def objective_grad(x):\n            grad = np.zeros(3*n)\n            grad[2*n:] = -1\n            return grad\n        \n        # Constraint: circles inside [0,1]^2\n        def bounds_constraint(x):\n            centers = x[:2*n].reshape(n, 2)\n            r = x[2*n:]\n            \n            constraints = np.zeros(4*n)\n            # x - r >= 0\n            constraints[0:n] = centers[:, 0] - r\n            # x + r <= 1\n            constraints[n:2*n] = 1 - centers[:, 0] - r\n            # y - r >= 0\n            constraints[2*n:3*n] = centers[:, 1] - r\n            # y + r <= 1\n            constraints[3*n:4*n] = 1 - centers[:, 1] - r\n            \n            return constraints\n        \n        def bounds_constraint_jac(x):\n            jac = np.zeros((4*n, 3*n))\n            \n            for i in range(n):\n                # x - r >= 0\n                jac[i, 2*i] = 1\n                jac[i, 2*n + i] = -1\n                \n                # 1 - x - r >= 0\n                jac[n + i, 2*i] = -1\n                jac[n + i, 2*n + i] = -1\n                \n                # y - r >= 0\n                jac[2*n + i, 2*i + 1] = 1\n                jac[2*n + i, 2*n + i] = -1\n                \n                # 1 - y - r >= 0\n                jac[3*n + i, 2*i + 1] = -1\n                jac[3*n + i, 2*n + i] = -1\n            \n            return jac\n        \n        # Constraint: no overlaps\n        def overlap_constraint(x):\n            centers = x[:2*n].reshape(n, 2)\n            r = x[2*n:]\n            \n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    constraints.append(dist - r[i] - r[j])\n            \n            return np.array(constraints)\n        \n        def overlap_constraint_jac(x):\n            centers = x[:2*n].reshape(n, 2)\n            r = x[2*n:]\n            \n            n_constraints = n * (n - 1) // 2\n            jac = np.zeros((n_constraints, 3*n))\n            \n            idx = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    \n                    if dist > 1e-10:\n                        # Gradient w.r.t. center i\n                        jac[idx, 2*i:2*i+2] = diff / dist\n                        # Gradient w.r.t. center j\n                        jac[idx, 2*j:2*j+2] = -diff / dist\n                    \n                    # Gradient w.r.t. radii\n                    jac[idx, 2*n + i] = -1\n                    jac[idx, 2*n + j] = -1\n                    \n                    idx += 1\n            \n            return jac\n        \n        # Set up constraints\n        bounds_constr = NonlinearConstraint(\n            bounds_constraint, 0, np.inf,\n            jac=bounds_constraint_jac\n        )\n        \n        overlap_constr = NonlinearConstraint(\n            overlap_constraint, 0, np.inf,\n            jac=overlap_constraint_jac\n        )\n        \n        # Variable bounds\n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        # Optimize\n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            jac=objective_grad,\n            constraints=[bounds_constr, overlap_constr],\n            bounds=bounds,\n            options={'maxiter': 2000, 'verbose': 0}\n        )\n        \n        if result.success or True:  # Accept even if not fully converged\n            sum_radii = -result.fun\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = result\n    \n    # Extract best solution\n    x = best_result.x\n    centers = x[:2*n].reshape(n, 2)\n    radii = x[2*n:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.594727580994364,
    "eval_time": 7.65582799911499,
    "error": null
  },
  "prompt": "Pack 26 circles using scipy.optimize.minimize with method='trust-constr'.\n\ntrust-constr is a modern interior-point optimizer that may work better than SLSQP.\n\nSetup:\n1. Use NonlinearConstraint for circle constraints\n2. Initialize with hex grid\n3. Multiple restarts (5-10) with different initializations\n\nTarget: 2.636",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef construct_packing():\n    n = 26\n    best_result = None\n    best_sum = 0\n    \n    # Try multiple random restarts\n    for restart in range(10):\n        if restart == 0:\n            # Start with hexagonal grid\n            centers = []\n            radii = []\n            \n            # Hexagonal packing pattern\n            rows = 5\n            for row in range(rows):\n                y = 0.15 + row * 0.18\n                if row % 2 == 0:\n                    x_start = 0.15\n                    n_in_row = 6\n                else:\n                    x_start = 0.24\n                    n_in_row = 5\n                \n                for col in range(n_in_row):\n                    if len(centers) < n:\n                        x = x_start + col * 0.18\n                        centers.append([x, y])\n                        radii.append(0.08)\n            \n            # Fill remaining with random positions\n            while len(centers) < n:\n                centers.append([np.random.uniform(0.1, 0.9), \n                               np.random.uniform(0.1, 0.9)])\n                radii.append(0.05)\n            \n            x0 = np.concatenate([np.array(centers).flatten(), np.array(radii)])\n        else:\n            # Random initialization with smaller radii\n            centers = np.random.uniform(0.15, 0.85, (n, 2))\n            radii = np.random.uniform(0.03, 0.07, n)\n            x0 = np.concatenate([centers.flatten(), radii])\n        \n        # Objective: maximize sum of radii = minimize negative sum\n        def objective(x):\n            r = x[2*n:]\n            return -np.sum(r)\n        \n        def objective_grad(x):\n            grad = np.zeros(3*n)\n            grad[2*n:] = -1\n            return grad\n        \n        # Constraint: circles inside [0,1]^2\n        def bounds_constraint(x):\n            centers = x[:2*n].reshape(n, 2)\n            r = x[2*n:]\n            \n            constraints = np.zeros(4*n)\n            # x - r >= 0\n            constraints[0:n] = centers[:, 0] - r\n            # x + r <= 1\n            constraints[n:2*n] = 1 - centers[:, 0] - r\n            # y - r >= 0\n            constraints[2*n:3*n] = centers[:, 1] - r\n            # y + r <= 1\n            constraints[3*n:4*n] = 1 - centers[:, 1] - r\n            \n            return constraints\n        \n        def bounds_constraint_jac(x):\n            jac = np.zeros((4*n, 3*n))\n            \n            for i in range(n):\n                # x - r >= 0\n                jac[i, 2*i] = 1\n                jac[i, 2*n + i] = -1\n                \n                # 1 - x - r >= 0\n                jac[n + i, 2*i] = -1\n                jac[n + i, 2*n + i] = -1\n                \n                # y - r >= 0\n                jac[2*n + i, 2*i + 1] = 1\n                jac[2*n + i, 2*n + i] = -1\n                \n                # 1 - y - r >= 0\n                jac[3*n + i, 2*i + 1] = -1\n                jac[3*n + i, 2*n + i] = -1\n            \n            return jac\n        \n        # Constraint: no overlaps\n        def overlap_constraint(x):\n            centers = x[:2*n].reshape(n, 2)\n            r = x[2*n:]\n            \n            constraints = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    constraints.append(dist - r[i] - r[j])\n            \n            return np.array(constraints)\n        \n        def overlap_constraint_jac(x):\n            centers = x[:2*n].reshape(n, 2)\n            r = x[2*n:]\n            \n            n_constraints = n * (n - 1) // 2\n            jac = np.zeros((n_constraints, 3*n))\n            \n            idx = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    \n                    if dist > 1e-10:\n                        # Gradient w.r.t. center i\n                        jac[idx, 2*i:2*i+2] = diff / dist\n                        # Gradient w.r.t. center j\n                        jac[idx, 2*j:2*j+2] = -diff / dist\n                    \n                    # Gradient w.r.t. radii\n                    jac[idx, 2*n + i] = -1\n                    jac[idx, 2*n + j] = -1\n                    \n                    idx += 1\n            \n            return jac\n        \n        # Set up constraints\n        bounds_constr = NonlinearConstraint(\n            bounds_constraint, 0, np.inf,\n            jac=bounds_constraint_jac\n        )\n        \n        overlap_constr = NonlinearConstraint(\n            overlap_constraint, 0, np.inf,\n            jac=overlap_constraint_jac\n        )\n        \n        # Variable bounds\n        bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n        \n        # Optimize\n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            jac=objective_grad,\n            constraints=[bounds_constr, overlap_constr],\n            bounds=bounds,\n            options={'maxiter': 2000, 'verbose': 0}\n        )\n        \n        if result.success or True:  # Accept even if not fully converged\n            sum_radii = -result.fun\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_result = result\n    \n    # Extract best solution\n    x = best_result.x\n    centers = x[:2*n].reshape(n, 2)\n    radii = x[2*n:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T20:22:39.768942",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}