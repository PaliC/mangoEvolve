{
  "trial_id": "trial_8_5",
  "generation": 8,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport itertools\nimport time\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn Triangle problem for N=11 points in an equilateral triangle.\n    The goal is to maximize the minimum area formed by any three points.\n    The triangle domain is defined by vertices (0,0), (1,0), and (0.5, sqrt(3)/2).\n    \"\"\"\n    N = 11\n    # Precompute all 165 triplets of indices for 11 points\n    TRIPLETS = np.array(list(itertools.combinations(range(N), 3)))\n    SQRT3 = np.sqrt(3.0)\n\n    def get_obj_grad(points_flat, alpha):\n        \"\"\"\n        Objective function and its gradient using the Log-Sum-Exp approximation\n        of the minimum area. We maximize the minimum area by minimizing -LSE(-alpha * areas).\n        \"\"\"\n        pts = points_flat.reshape(N, 2)\n        # Extract coordinates for each triplet\n        A = pts[TRIPLETS[:, 0]]\n        B = pts[TRIPLETS[:, 1]]\n        C = pts[TRIPLETS[:, 2]]\n        \n        # Calculate 2 * signed area: f = x1(y2-y3) + x2(y3-y1) + x3(y1-y2)\n        # Area = 0.5 * |f|\n        f = (A[:, 0] * (B[:, 1] - C[:, 1]) +\n             B[:, 0] * (C[:, 1] - A[:, 1]) +\n             C[:, 0] * (A[:, 1] - B[:, 1]))\n        \n        areas = 0.5 * np.abs(f)\n        \n        # Log-Sum-Exp trick for numerical stability to approximate -min(areas)\n        # Obj = -1/alpha * log(sum(exp(-alpha * areas)))\n        max_neg_alpha_area = np.max(-alpha * areas)\n        weights = np.exp(-alpha * areas - max_neg_alpha_area)\n        sum_w = np.sum(weights)\n        obj = -(max_neg_alpha_area + np.log(sum_w)) / alpha\n        \n        # Gradient of objective with respect to areas: d_obj/d_area_k = weights[k] / sum_w\n        d_obj_d_areas = weights / sum_w\n        \n        # Gradient of areas with respect to point coordinates\n        # d(area)/df = 0.5 * sign(f)\n        signs = np.sign(f)[:, np.newaxis, np.newaxis]\n        \n        # grad_f shape is (165, 3, 2), representing (triplets, points_in_triplet, coordinates)\n        grad_f = np.zeros((len(TRIPLETS), 3, 2))\n        # d_f/d_x1 = y2-y3, d_f/d_y1 = x3-x2\n        grad_f[:, 0, 0] = B[:, 1] - C[:, 1]\n        grad_f[:, 0, 1] = C[:, 0] - B[:, 0]\n        # d_f/d_x2 = y3-y1, d_f/d_y2 = x1-x3\n        grad_f[:, 1, 0] = C[:, 1] - A[:, 1]\n        grad_f[:, 1, 1] = A[:, 0] - C[:, 0]\n        # d_f/d_x3 = y1-y2, d_f/d_y3 = x2-x1\n        grad_f[:, 2, 0] = A[:, 1] - B[:, 1]\n        grad_f[:, 2, 1] = B[:, 0] - A[:, 0]\n        \n        grad_areas = 0.5 * signs * grad_f\n        \n        # Accumulate gradients for each of the N points\n        total_grad = np.zeros((N, 2))\n        weighted_grad_areas = d_obj_d_areas[:, np.newaxis, np.newaxis] * grad_areas\n        np.add.at(total_grad, TRIPLETS[:, 0], weighted_grad_areas[:, 0])\n        np.add.at(total_grad, TRIPLETS[:, 1], weighted_grad_areas[:, 1])\n        np.add.at(total_grad, TRIPLETS[:, 2], weighted_grad_areas[:, 2])\n        \n        return obj, total_grad.flatten()\n\n    # Define linear constraints for the equilateral triangle boundary:\n    # 1. y >= 0\n    # 2. sqrt(3)x - y >= 0\n    # 3. sqrt(3)(1-x) - y >= 0\n    A_cons = np.zeros((3*N, 2*N))\n    b_cons = np.zeros(3*N)\n    for i in range(N):\n        A_cons[3*i, 2*i+1] = 1.0\n        A_cons[3*i+1, 2*i] = SQRT3\n        A_cons[3*i+1, 2*i+1] = -1.0\n        A_cons[3*i+2, 2*i] = -SQRT3\n        A_cons[3*i+2, 2*i+1] = -1.0\n        b_cons[3*i+2] = -SQRT3\n    \n    cons = {'type': 'ineq', 'fun': lambda p: A_cons @ p - b_cons, 'jac': lambda p: A_cons}\n\n    best_min_area = -1\n    best_pts = None\n    \n    start_time = time.time()\n    # Successive refinement with increasing alpha values to sharpen the minimum\n    alpha_seq = [1e3, 1e4, 1e5]\n    \n    # Perform multi-start optimization until time is nearly exhausted\n    while time.time() - start_time < 26:\n        # Uniform random sampling in the triangle using the square root method\n        r1 = np.random.rand(N)\n        r2 = np.random.rand(N)\n        pts = np.zeros((N, 2))\n        pts[:, 0] = np.sqrt(r1) * (1.0 - 0.5 * r2)\n        pts[:, 1] = np.sqrt(r1) * r2 * (SQRT3 / 2.0)\n        pts_flat = pts.flatten()\n        \n        # Optimize using SLSQP with the Jacobian provided\n        for alpha in alpha_seq:\n            res = minimize(get_obj_grad, pts_flat, args=(alpha,), method='SLSQP', \n                           jac=True, constraints=cons, options={'maxiter': 50})\n            pts_flat = res.x\n        \n        # Re-evaluate the exact minimum area for the optimized set of points\n        pts = pts_flat.reshape(N, 2)\n        A = pts[TRIPLETS[:, 0]]\n        B = pts[TRIPLETS[:, 1]]\n        C = pts[TRIPLETS[:, 2]]\n        cur_areas = 0.5 * np.abs(A[:, 0] * (B[:, 1] - C[:, 1]) +\n                                 B[:, 0] * (C[:, 1] - A[:, 1]) +\n                                 C[:, 0] * (A[:, 1] - B[:, 1]))\n        min_area = np.min(cur_areas)\n        \n        if min_area > best_min_area:\n            best_min_area = min_area\n            best_pts = pts.copy()\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.0010879067859518924,
    "min_area_normalized": 3.974111509056017e-05,
    "min_triangle_area": 1.7208407621573107e-05,
    "eval_time": 26.420082807540894,
    "error": null
  },
  "prompt": "Implement a high-precision multi-start SLSQP using the Log-Sum-Exp objective. Use 50 random starts, but for each start, use a sequence of increasing alpha values (1e4, 1e6, 1e8, 1e10). Map the unit square to the triangle using the square root method to ensure uniform sampling.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport itertools\nimport time\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn Triangle problem for N=11 points in an equilateral triangle.\n    The goal is to maximize the minimum area formed by any three points.\n    The triangle domain is defined by vertices (0,0), (1,0), and (0.5, sqrt(3)/2).\n    \"\"\"\n    N = 11\n    # Precompute all 165 triplets of indices for 11 points\n    TRIPLETS = np.array(list(itertools.combinations(range(N), 3)))\n    SQRT3 = np.sqrt(3.0)\n\n    def get_obj_grad(points_flat, alpha):\n        \"\"\"\n        Objective function and its gradient using the Log-Sum-Exp approximation\n        of the minimum area. We maximize the minimum area by minimizing -LSE(-alpha * areas).\n        \"\"\"\n        pts = points_flat.reshape(N, 2)\n        # Extract coordinates for each triplet\n        A = pts[TRIPLETS[:, 0]]\n        B = pts[TRIPLETS[:, 1]]\n        C = pts[TRIPLETS[:, 2]]\n        \n        # Calculate 2 * signed area: f = x1(y2-y3) + x2(y3-y1) + x3(y1-y2)\n        # Area = 0.5 * |f|\n        f = (A[:, 0] * (B[:, 1] - C[:, 1]) +\n             B[:, 0] * (C[:, 1] - A[:, 1]) +\n             C[:, 0] * (A[:, 1] - B[:, 1]))\n        \n        areas = 0.5 * np.abs(f)\n        \n        # Log-Sum-Exp trick for numerical stability to approximate -min(areas)\n        # Obj = -1/alpha * log(sum(exp(-alpha * areas)))\n        max_neg_alpha_area = np.max(-alpha * areas)\n        weights = np.exp(-alpha * areas - max_neg_alpha_area)\n        sum_w = np.sum(weights)\n        obj = -(max_neg_alpha_area + np.log(sum_w)) / alpha\n        \n        # Gradient of objective with respect to areas: d_obj/d_area_k = weights[k] / sum_w\n        d_obj_d_areas = weights / sum_w\n        \n        # Gradient of areas with respect to point coordinates\n        # d(area)/df = 0.5 * sign(f)\n        signs = np.sign(f)[:, np.newaxis, np.newaxis]\n        \n        # grad_f shape is (165, 3, 2), representing (triplets, points_in_triplet, coordinates)\n        grad_f = np.zeros((len(TRIPLETS), 3, 2))\n        # d_f/d_x1 = y2-y3, d_f/d_y1 = x3-x2\n        grad_f[:, 0, 0] = B[:, 1] - C[:, 1]\n        grad_f[:, 0, 1] = C[:, 0] - B[:, 0]\n        # d_f/d_x2 = y3-y1, d_f/d_y2 = x1-x3\n        grad_f[:, 1, 0] = C[:, 1] - A[:, 1]\n        grad_f[:, 1, 1] = A[:, 0] - C[:, 0]\n        # d_f/d_x3 = y1-y2, d_f/d_y3 = x2-x1\n        grad_f[:, 2, 0] = A[:, 1] - B[:, 1]\n        grad_f[:, 2, 1] = B[:, 0] - A[:, 0]\n        \n        grad_areas = 0.5 * signs * grad_f\n        \n        # Accumulate gradients for each of the N points\n        total_grad = np.zeros((N, 2))\n        weighted_grad_areas = d_obj_d_areas[:, np.newaxis, np.newaxis] * grad_areas\n        np.add.at(total_grad, TRIPLETS[:, 0], weighted_grad_areas[:, 0])\n        np.add.at(total_grad, TRIPLETS[:, 1], weighted_grad_areas[:, 1])\n        np.add.at(total_grad, TRIPLETS[:, 2], weighted_grad_areas[:, 2])\n        \n        return obj, total_grad.flatten()\n\n    # Define linear constraints for the equilateral triangle boundary:\n    # 1. y >= 0\n    # 2. sqrt(3)x - y >= 0\n    # 3. sqrt(3)(1-x) - y >= 0\n    A_cons = np.zeros((3*N, 2*N))\n    b_cons = np.zeros(3*N)\n    for i in range(N):\n        A_cons[3*i, 2*i+1] = 1.0\n        A_cons[3*i+1, 2*i] = SQRT3\n        A_cons[3*i+1, 2*i+1] = -1.0\n        A_cons[3*i+2, 2*i] = -SQRT3\n        A_cons[3*i+2, 2*i+1] = -1.0\n        b_cons[3*i+2] = -SQRT3\n    \n    cons = {'type': 'ineq', 'fun': lambda p: A_cons @ p - b_cons, 'jac': lambda p: A_cons}\n\n    best_min_area = -1\n    best_pts = None\n    \n    start_time = time.time()\n    # Successive refinement with increasing alpha values to sharpen the minimum\n    alpha_seq = [1e3, 1e4, 1e5]\n    \n    # Perform multi-start optimization until time is nearly exhausted\n    while time.time() - start_time < 26:\n        # Uniform random sampling in the triangle using the square root method\n        r1 = np.random.rand(N)\n        r2 = np.random.rand(N)\n        pts = np.zeros((N, 2))\n        pts[:, 0] = np.sqrt(r1) * (1.0 - 0.5 * r2)\n        pts[:, 1] = np.sqrt(r1) * r2 * (SQRT3 / 2.0)\n        pts_flat = pts.flatten()\n        \n        # Optimize using SLSQP with the Jacobian provided\n        for alpha in alpha_seq:\n            res = minimize(get_obj_grad, pts_flat, args=(alpha,), method='SLSQP', \n                           jac=True, constraints=cons, options={'maxiter': 50})\n            pts_flat = res.x\n        \n        # Re-evaluate the exact minimum area for the optimized set of points\n        pts = pts_flat.reshape(N, 2)\n        A = pts[TRIPLETS[:, 0]]\n        B = pts[TRIPLETS[:, 1]]\n        C = pts[TRIPLETS[:, 2]]\n        cur_areas = 0.5 * np.abs(A[:, 0] * (B[:, 1] - C[:, 1]) +\n                                 B[:, 0] * (C[:, 1] - A[:, 1]) +\n                                 C[:, 0] * (A[:, 1] - B[:, 1]))\n        min_area = np.min(cur_areas)\n        \n        if min_area > best_min_area:\n            best_min_area = min_area\n            best_pts = pts.copy()\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T11:40:41.013294",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 274,
        "candidates_token_count": 1877,
        "thoughts_token_count": 19299
      },
      "response_text_len": 5008
    }
  }
}