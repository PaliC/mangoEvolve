{
  "trial_id": "trial_5_5",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nimport time\nimport itertools\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Optimizes the placement of 11 points in an equilateral triangle to maximize the minimum area\n    of any triangle formed by a triplet of points.\n    \n    Algorithm: (mu/mu_w, lambda)-CMA-ES (Covariance Matrix Adaptation Evolution Strategy).\n    \n    Constraints:\n    Triangle vertices: (0,0), (1,0), (0.5, sqrt(3)/2).\n    Points must be inside or on the boundary (tolerance 1e-06).\n    \"\"\"\n    \n    # --- Problem Constants ---\n    N_POINTS = 11\n    DIM = 2 * N_POINTS\n    SQRT3 = np.sqrt(3)\n    TRI_HEIGHT = SQRT3 / 2\n    \n    # Precompute triangle indices for area calculation (nCr = 165 triplets)\n    tri_indices = np.array(list(itertools.combinations(range(N_POINTS), 3)))\n\n    def check_constraints_vec(x, y):\n        \"\"\"\n        Returns boolean mask for valid points.\n        Triangle boundaries:\n        1. y >= 0\n        2. y <= sqrt(3) * x\n        3. y <= sqrt(3) * (1 - x)\n        \"\"\"\n        tol = 1e-6\n        c1 = y >= -tol\n        c2 = (SQRT3 * x - y) >= -tol\n        c3 = (-SQRT3 * x - y + SQRT3) >= -tol\n        return c1 & c2 & c3\n\n    def get_fitness(flat_coords):\n        \"\"\"\n        Objective function: Maximize the minimum triangle area.\n        Returns a large negative value if constraints are violated.\n        \"\"\"\n        # Reshape to (N, 2)\n        points = flat_coords.reshape((N_POINTS, 2))\n        x = points[:, 0]\n        y = points[:, 1]\n        \n        # Check constraints\n        if not np.all(check_constraints_vec(x, y)):\n            return -1e9 # Penalty for constraint violation\n            \n        # Compute areas for all combinations\n        # Gather points: shape (165, 3, 2)\n        p = points[tri_indices]\n        \n        # Extract coordinates: (165, 3)\n        x_tri = p[:, :, 0]\n        y_tri = p[:, :, 1]\n        \n        # Shoelace formula: 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|\n        term1 = x_tri[:, 0] * (y_tri[:, 1] - y_tri[:, 2])\n        term2 = x_tri[:, 1] * (y_tri[:, 2] - y_tri[:, 0])\n        term3 = x_tri[:, 2] * (y_tri[:, 0] - y_tri[:, 1])\n        \n        areas = 0.5 * np.abs(term1 + term2 + term3)\n        \n        # We want to maximize the minimum area\n        return np.min(areas)\n\n    def sample_valid_point():\n        # Rejection sampling for a valid point in the triangle\n        while True:\n            rx = np.random.rand()\n            ry = np.random.rand() * TRI_HEIGHT\n            if ry <= SQRT3 * rx and ry <= SQRT3 * (1 - rx):\n                return rx, ry\n\n    def sample_initial_solution():\n        pts = np.zeros((N_POINTS, 2))\n        for i in range(N_POINTS):\n            pts[i] = sample_valid_point()\n        return pts.flatten()\n\n    # --- CMA-ES Configuration ---\n    # Strategy parameters for N=22\n    n = DIM\n    lam = 4 + int(3 * np.log(n)) # Population size ~13\n    mu = lam // 2\n    \n    # Selection weights (logarithmic)\n    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n    weights /= np.sum(weights)\n    mueff = 1 / np.sum(weights**2)\n    \n    # Adaptation parameters\n    cc = (4 + mueff/n) / (n + 4 + 2*mueff/n)\n    cs = (mueff + 2) / (n + mueff + 5)\n    c1 = 2 / ((n + 1.3)**2 + mueff)\n    cmu = min(1 - c1, 2 * (mueff - 2 + 1/mueff) / ((n + 2)**2 + mueff))\n    damps = 1 + 2 * max(0, np.sqrt((mueff - 1)/(n + 1)) - 1) + cs\n    chiN = n**0.5 * (1 - 1/(4*n) + 1/(21*n**2))\n\n    # --- Optimization Loop ---\n    start_time = time.time()\n    time_budget = 28.0 # Leave buffer for overhead\n    \n    # Initialize best solution found so far\n    best_flat = sample_initial_solution()\n    best_fit = get_fitness(best_flat)\n    \n    # Restart loop to avoid local optima\n    while time.time() - start_time < time_budget:\n        \n        # Initialize CMA-ES internal state\n        xmean = sample_initial_solution()\n        sigma = 0.05 # Initial step size (small enough to stay roughly valid)\n        \n        pc = np.zeros(n)\n        ps = np.zeros(n)\n        B = np.eye(n)\n        D = np.ones(n)\n        C = np.eye(n)\n        \n        eigeneval = 0\n        \n        # Generation loop\n        for gen in range(2000): # Max generations per restart\n            if time.time() - start_time > time_budget:\n                break\n            \n            # 1. Sample offspring\n            z = np.random.randn(lam, n)\n            # x = m + sigma * B * (D * z)\n            # Efficient computation:\n            T = (z * D) @ B.T\n            arx = xmean + sigma * T\n            \n            # 2. Evaluate fitness\n            fitnesses = np.array([get_fitness(ind) for ind in arx])\n            \n            # 3. Handle constraints (if all invalid, contract sigma and skip update)\n            if np.all(fitnesses == -1e9):\n                sigma *= 0.5\n                continue\n            \n            # 4. Selection\n            arindex = np.argsort(fitnesses)[::-1] # Maximization\n            best_curr_fit = fitnesses[arindex[0]]\n            \n            # Update global best\n            if best_curr_fit > best_fit:\n                best_fit = best_curr_fit\n                best_flat = arx[arindex[0]].copy()\n            \n            # 5. Update Mean\n            xold = xmean.copy()\n            xmean = weights @ arx[arindex[:mu]]\n            \n            # 6. Update Evolution Paths\n            z_diff = (xmean - xold) / sigma\n            \n            # Calculate invsqrtC * z_diff = B * D^-1 * B.T * z_diff\n            inv_z = B @ ((B.T @ z_diff) / D)\n            \n            ps = (1 - cs) * ps + np.sqrt(cs * (2 - cs) * mueff) * inv_z\n            \n            hsig = np.linalg.norm(ps) / np.sqrt(1 - (1 - cs)**(2 * (gen + 1))) / chiN < 1.4 + 2 / (n + 1)\n            pc = (1 - cc) * pc + hsig * np.sqrt(cc * (2 - cc) * mueff) * z_diff\n            \n            # 7. Update Covariance Matrix\n            artmp = (arx[arindex[:mu]] - xold) / sigma\n            rank_one = np.outer(pc, pc)\n            rank_mu = (artmp.T * weights) @ artmp\n            \n            C = (1 - c1 - cmu) * C \n            C += c1 * (rank_one + (1 - hsig) * cc * (2 - cc) * C)\n            C += cmu * rank_mu\n            \n            # 8. Update Step Size\n            sigma = sigma * np.exp((cs / damps) * (np.linalg.norm(ps) / chiN - 1))\n            \n            # 9. Decomposition (periodically)\n            if gen - eigeneval > lam / (c1 + cmu) / n / 10:\n                eigeneval = gen\n                C = np.triu(C) + np.triu(C, 1).T\n                try:\n                    vals, vecs = np.linalg.eigh(C)\n                    vals = np.maximum(vals, 1e-16)\n                    D = np.sqrt(vals)\n                    B = vecs\n                except np.linalg.LinAlgError:\n                    break # Numerical instability, restart\n            \n            # Convergence criteria\n            if sigma < 1e-5:\n                break\n            if fitnesses[arindex[0]] - fitnesses[arindex[mu-1]] < 1e-9:\n                if sigma < 1e-3: break\n                \n    return best_flat.reshape((N_POINTS, 2))",
  "metrics": {
    "valid": true,
    "score": 0.8290131383823931,
    "min_area_normalized": 0.030283758654207023,
    "min_triangle_area": 0.013113252158310062,
    "eval_time": 28.06312394142151,
    "error": null
  },
  "prompt": "Use CMA-ES (Covariance Matrix Adaptation Evolution Strategy) to optimize the 22 coordinates of the 11 points.\n        Objective: Maximize the minimum area of any triangle formed by 3 points.\n        Handle the triangle constraints by returning a very large negative value if any point is outside.\n        Equilateral triangle: (0,0), (1,0), (0.5, sqrt(3)/2).\n        ",
  "response": "Here is the solution using a custom implementation of the CMA-ES algorithm to optimize the point coordinates.\n\n```python\nimport numpy as np\nimport time\nimport itertools\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Optimizes the placement of 11 points in an equilateral triangle to maximize the minimum area\n    of any triangle formed by a triplet of points.\n    \n    Algorithm: (mu/mu_w, lambda)-CMA-ES (Covariance Matrix Adaptation Evolution Strategy).\n    \n    Constraints:\n    Triangle vertices: (0,0), (1,0), (0.5, sqrt(3)/2).\n    Points must be inside or on the boundary (tolerance 1e-06).\n    \"\"\"\n    \n    # --- Problem Constants ---\n    N_POINTS = 11\n    DIM = 2 * N_POINTS\n    SQRT3 = np.sqrt(3)\n    TRI_HEIGHT = SQRT3 / 2\n    \n    # Precompute triangle indices for area calculation (nCr = 165 triplets)\n    tri_indices = np.array(list(itertools.combinations(range(N_POINTS), 3)))\n\n    def check_constraints_vec(x, y):\n        \"\"\"\n        Returns boolean mask for valid points.\n        Triangle boundaries:\n        1. y >= 0\n        2. y <= sqrt(3) * x\n        3. y <= sqrt(3) * (1 - x)\n        \"\"\"\n        tol = 1e-6\n        c1 = y >= -tol\n        c2 = (SQRT3 * x - y) >= -tol\n        c3 = (-SQRT3 * x - y + SQRT3) >= -tol\n        return c1 & c2 & c3\n\n    def get_fitness(flat_coords):\n        \"\"\"\n        Objective function: Maximize the minimum triangle area.\n        Returns a large negative value if constraints are violated.\n        \"\"\"\n        # Reshape to (N, 2)\n        points = flat_coords.reshape((N_POINTS, 2))\n        x = points[:, 0]\n        y = points[:, 1]\n        \n        # Check constraints\n        if not np.all(check_constraints_vec(x, y)):\n            return -1e9 # Penalty for constraint violation\n            \n        # Compute areas for all combinations\n        # Gather points: shape (165, 3, 2)\n        p = points[tri_indices]\n        \n        # Extract coordinates: (165, 3)\n        x_tri = p[:, :, 0]\n        y_tri = p[:, :, 1]\n        \n        # Shoelace formula: 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|\n        term1 = x_tri[:, 0] * (y_tri[:, 1] - y_tri[:, 2])\n        term2 = x_tri[:, 1] * (y_tri[:, 2] - y_tri[:, 0])\n        term3 = x_tri[:, 2] * (y_tri[:, 0] - y_tri[:, 1])\n        \n        areas = 0.5 * np.abs(term1 + term2 + term3)\n        \n        # We want to maximize the minimum area\n        return np.min(areas)\n\n    def sample_valid_point():\n        # Rejection sampling for a valid point in the triangle\n        while True:\n            rx = np.random.rand()\n            ry = np.random.rand() * TRI_HEIGHT\n            if ry <= SQRT3 * rx and ry <= SQRT3 * (1 - rx):\n                return rx, ry\n\n    def sample_initial_solution():\n        pts = np.zeros((N_POINTS, 2))\n        for i in range(N_POINTS):\n            pts[i] = sample_valid_point()\n        return pts.flatten()\n\n    # --- CMA-ES Configuration ---\n    # Strategy parameters for N=22\n    n = DIM\n    lam = 4 + int(3 * np.log(n)) # Population size ~13\n    mu = lam // 2\n    \n    # Selection weights (logarithmic)\n    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n    weights /= np.sum(weights)\n    mueff = 1 / np.sum(weights**2)\n    \n    # Adaptation parameters\n    cc = (4 + mueff/n) / (n + 4 + 2*mueff/n)\n    cs = (mueff + 2) / (n + mueff + 5)\n    c1 = 2 / ((n + 1.3)**2 + mueff)\n    cmu = min(1 - c1, 2 * (mueff - 2 + 1/mueff) / ((n + 2)**2 + mueff))\n    damps = 1 + 2 * max(0, np.sqrt((mueff - 1)/(n + 1)) - 1) + cs\n    chiN = n**0.5 * (1 - 1/(4*n) + 1/(21*n**2))\n\n    # --- Optimization Loop ---\n    start_time = time.time()\n    time_budget = 28.0 # Leave buffer for overhead\n    \n    # Initialize best solution found so far\n    best_flat = sample_initial_solution()\n    best_fit = get_fitness(best_flat)\n    \n    # Restart loop to avoid local optima\n    while time.time() - start_time < time_budget:\n        \n        # Initialize CMA-ES internal state\n        xmean = sample_initial_solution()\n        sigma = 0.05 # Initial step size (small enough to stay roughly valid)\n        \n        pc = np.zeros(n)\n        ps = np.zeros(n)\n        B = np.eye(n)\n        D = np.ones(n)\n        C = np.eye(n)\n        \n        eigeneval = 0\n        \n        # Generation loop\n        for gen in range(2000): # Max generations per restart\n            if time.time() - start_time > time_budget:\n                break\n            \n            # 1. Sample offspring\n            z = np.random.randn(lam, n)\n            # x = m + sigma * B * (D * z)\n            # Efficient computation:\n            T = (z * D) @ B.T\n            arx = xmean + sigma * T\n            \n            # 2. Evaluate fitness\n            fitnesses = np.array([get_fitness(ind) for ind in arx])\n            \n            # 3. Handle constraints (if all invalid, contract sigma and skip update)\n            if np.all(fitnesses == -1e9):\n                sigma *= 0.5\n                continue\n            \n            # 4. Selection\n            arindex = np.argsort(fitnesses)[::-1] # Maximization\n            best_curr_fit = fitnesses[arindex[0]]\n            \n            # Update global best\n            if best_curr_fit > best_fit:\n                best_fit = best_curr_fit\n                best_flat = arx[arindex[0]].copy()\n            \n            # 5. Update Mean\n            xold = xmean.copy()\n            xmean = weights @ arx[arindex[:mu]]\n            \n            # 6. Update Evolution Paths\n            z_diff = (xmean - xold) / sigma\n            \n            # Calculate invsqrtC * z_diff = B * D^-1 * B.T * z_diff\n            inv_z = B @ ((B.T @ z_diff) / D)\n            \n            ps = (1 - cs) * ps + np.sqrt(cs * (2 - cs) * mueff) * inv_z\n            \n            hsig = np.linalg.norm(ps) / np.sqrt(1 - (1 - cs)**(2 * (gen + 1))) / chiN < 1.4 + 2 / (n + 1)\n            pc = (1 - cc) * pc + hsig * np.sqrt(cc * (2 - cc) * mueff) * z_diff\n            \n            # 7. Update Covariance Matrix\n            artmp = (arx[arindex[:mu]] - xold) / sigma\n            rank_one = np.outer(pc, pc)\n            rank_mu = (artmp.T * weights) @ artmp\n            \n            C = (1 - c1 - cmu) * C \n            C += c1 * (rank_one + (1 - hsig) * cc * (2 - cc) * C)\n            C += cmu * rank_mu\n            \n            # 8. Update Step Size\n            sigma = sigma * np.exp((cs / damps) * (np.linalg.norm(ps) / chiN - 1))\n            \n            # 9. Decomposition (periodically)\n            if gen - eigeneval > lam / (c1 + cmu) / n / 10:\n                eigeneval = gen\n                C = np.triu(C) + np.triu(C, 1).T\n                try:\n                    vals, vecs = np.linalg.eigh(C)\n                    vals = np.maximum(vals, 1e-16)\n                    D = np.sqrt(vals)\n                    B = vecs\n                except np.linalg.LinAlgError:\n                    break # Numerical instability, restart\n            \n            # Convergence criteria\n            if sigma < 1e-5:\n                break\n            if fitnesses[arindex[0]] - fitnesses[arindex[mu-1]] < 1e-9:\n                if sigma < 1e-3: break\n                \n    return best_flat.reshape((N_POINTS, 2))\n```",
  "reasoning": "Here is the solution using a custom implementation of the CMA-ES algorithm to optimize the point coordinates.",
  "timestamp": "2026-01-20T11:22:42.643437",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 290,
        "candidates_token_count": 2319,
        "thoughts_token_count": 15225
      },
      "response_text_len": 7086
    }
  }
}