{
  "trial_id": "trial_14_8",
  "generation": 14,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport itertools\nimport time\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Finds a configuration of 11 points in an equilateral triangle maximizing the minimum area\n    of any triangle formed by three of these points.\n    \n    The triangle vertices are (0,0), (1,0), (0.5, sqrt(3)/2).\n    Uses a slack-variable optimization with SLSQP and analytical gradients,\n    enforcing bilateral symmetry (1 point on altitude, 5 symmetric pairs).\n    \"\"\"\n    \n    # Constants\n    sqrt3 = np.sqrt(3)\n    \n    # Precompute triplets for area calculation\n    triplets = np.array(list(itertools.combinations(range(11), 3)))\n    n_triplets = len(triplets)\n    \n    # --- Precompute indices for efficient Jacobian calculation ---\n    # We map the 11 points to the parameter vector u.\n    # u = [S, yc, x1, y1, x2, y2, ..., x5, y5]\n    # P0: (0.5, yc) -> depends on u[1]\n    # P(2k-1): (xk, yk) -> depends on u[2+2k], u[3+2k]\n    # P(2k): (1-xk, yk) -> depends on u[2+2k], u[3+2k] (reflected)\n    \n    # Flatten triplets to handle all points in all constraints at once\n    flat_p_idx = triplets.flatten()\n    jac_rows = np.repeat(np.arange(n_triplets), 3)\n    \n    # Arrays to store mapping info for each point in the flattened list\n    u_idx_x = np.zeros(len(flat_p_idx), dtype=int)\n    u_idx_y = np.zeros(len(flat_p_idx), dtype=int)\n    is_refl = np.zeros(len(flat_p_idx), dtype=bool)\n    is_p0 = (flat_p_idx == 0)\n    \n    # Fill mapping for generator points (indices 1..10)\n    not_p0 = ~is_p0\n    p_indices = flat_p_idx[not_p0]\n    # Map point index to generator index k (0..4)\n    # Point indices: 1,2 -> k=0; 3,4 -> k=1; ...\n    k = (p_indices - 1) // 2\n    u_idx_x[not_p0] = 2 + 2*k\n    u_idx_y[not_p0] = 3 + 2*k\n    # Even indices (2, 4...) are reflected\n    is_refl[not_p0] = (p_indices % 2 == 0)\n    \n    # P0 depends only on y (u[1])\n    u_idx_y[is_p0] = 1\n    \n    def get_points(u):\n        \"\"\"Constructs (11, 2) points array from parameters u.\"\"\"\n        pts = np.zeros((11, 2))\n        # P0 on altitude\n        pts[0] = [0.5, u[1]]\n        # Generator coordinates\n        x = u[2::2]\n        y = u[3::2]\n        # Odd points (left side)\n        pts[1::2, 0] = x\n        pts[1::2, 1] = y\n        # Even points (right side, reflected)\n        pts[2::2, 0] = 1.0 - x\n        pts[2::2, 1] = y\n        return pts\n\n    def constraints(u):\n        \"\"\"Returns vector of constraint values (>= 0).\"\"\"\n        S = u[0]\n        pts = get_points(u)\n        \n        # 1. Area constraints: Area(i,j,k) - S >= 0\n        p1 = pts[triplets[:, 0]]\n        p2 = pts[triplets[:, 1]]\n        p3 = pts[triplets[:, 2]]\n        \n        # Signed area * 2\n        det = p1[:,0]*(p2[:,1]-p3[:,1]) + p2[:,0]*(p3[:,1]-p1[:,1]) + p3[:,0]*(p1[:,1]-p2[:,1])\n        areas = 0.5 * np.abs(det)\n        \n        # 2. Geometric constraints: Points must be inside triangle\n        # For generator points (x, y), we enforce x <= 0.5 (bound) and y <= sqrt(3)*x\n        # So sqrt(3)*x - y >= 0\n        x_gen = u[2::2]\n        y_gen = u[3::2]\n        geo = sqrt3 * x_gen - y_gen\n        \n        return np.concatenate([areas - S, geo])\n\n    def jacobian(u):\n        \"\"\"Analytical Jacobian of constraints.\"\"\"\n        pts = get_points(u)\n        jac = np.zeros((n_triplets + 5, len(u)))\n        \n        # d(Area - S)/dS = -1\n        jac[:n_triplets, 0] = -1\n        \n        # --- Gradient of Area constraints ---\n        p1 = pts[triplets[:, 0]]\n        p2 = pts[triplets[:, 1]]\n        p3 = pts[triplets[:, 2]]\n        \n        x1, y1 = p1[:,0], p1[:,1]\n        x2, y2 = p2[:,0], p2[:,1]\n        x3, y3 = p3[:,0], p3[:,1]\n        \n        det = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)\n        # Gradient factor: 0.5 * sign(det)\n        factor = 0.5 * np.sign(det)\n        \n        # Partial derivatives of Det w.r.t coordinates\n        # dDet/dx1 = y2 - y3, etc.\n        dx1 = y2 - y3\n        dx2 = y3 - y1\n        dx3 = y1 - y2\n        dy1 = x3 - x2\n        dy2 = x1 - x3\n        dy3 = x2 - x1\n        \n        # Stack and flatten to align with flat_p_idx\n        # Order: p1, p2, p3 for each triplet\n        gx = np.stack([dx1, dx2, dx3], axis=1).flatten() * np.repeat(factor, 3)\n        gy = np.stack([dy1, dy2, dy3], axis=1).flatten() * np.repeat(factor, 3)\n        \n        # Accumulate gradients into Jacobian matrix using precomputed indices\n        \n        # 1. Update y-derivatives (all points depend on a y-param)\n        np.add.at(jac, (jac_rows, u_idx_y), gy)\n        \n        # 2. Update x-derivatives (P0 has constant x, others variable)\n        mask = ~is_p0\n        if np.any(mask):\n            rows = jac_rows[mask]\n            cols = u_idx_x[mask]\n            vals = gx[mask]\n            \n            # If point is reflected (x' = 1-x), dx'/dx = -1\n            refl = is_refl[mask]\n            vals = np.where(refl, -vals, vals)\n            \n            np.add.at(jac, (rows, cols), vals)\n            \n        # --- Gradient of Geometric constraints ---\n        # sqrt(3)*x - y >= 0\n        # deriv w.r.t x is sqrt(3), w.r.t y is -1\n        r_geo = np.arange(n_triplets, n_triplets + 5)\n        c_x = np.arange(2, 12, 2)\n        c_y = np.arange(3, 12, 2)\n        \n        jac[r_geo, c_x] = sqrt3\n        jac[r_geo, c_y] = -1\n        \n        return jac\n\n    # --- Optimization Loop ---\n    \n    best_min_area = -1.0\n    best_pts = np.zeros((11, 2))\n    \n    # Parameter bounds\n    # S > 0, small\n    # yc in [0, sqrt3/2]\n    # xk in [0, 0.5], yk in [0, sqrt3/2]\n    bounds = [(0, 0.2), (0, sqrt3/2)] + [(0, 0.5), (0, sqrt3/2)] * 5\n    \n    t_end = time.time() + 28 # 30s budget\n    \n    while time.time() < t_end:\n        # Random initialization\n        u0 = np.zeros(12)\n        u0[0] = 0.01 # Initial slack\n        u0[1] = np.random.uniform(0, sqrt3/2) # P0 y\n        for k in range(5):\n            xk = np.random.uniform(0.01, 0.5)\n            yk = np.random.uniform(0, sqrt3 * xk)\n            u0[2 + 2*k] = xk\n            u0[3 + 2*k] = yk\n            \n        try:\n            res = minimize(\n                lambda u: -u[0], # Maximize S\n                u0,\n                method='SLSQP',\n                jac=jacobian,\n                constraints={'type': 'ineq', 'fun': constraints},\n                bounds=bounds,\n                options={'maxiter': 300, 'ftol': 1e-8}\n            )\n            \n            pts = get_points(res.x)\n            \n            # Verify actual minimum area\n            p1 = pts[triplets[:, 0]]\n            p2 = pts[triplets[:, 1]]\n            p3 = pts[triplets[:, 2]]\n            det = p1[:,0]*(p2[:,1]-p3[:,1]) + p2[:,0]*(p3[:,1]-p1[:,1]) + p3[:,0]*(p1[:,1]-p2[:,1])\n            min_area = 0.5 * np.min(np.abs(det))\n            \n            if min_area > best_min_area:\n                best_min_area = min_area\n                best_pts = pts\n                \n        except Exception:\n            continue\n\n    # Ensure strict adherence to bounds (clamp due to floating point tolerance)\n    # P0\n    best_pts[0, 0] = 0.5\n    best_pts[0, 1] = np.clip(best_pts[0, 1], 0, sqrt3/2)\n    \n    # Generators (odd indices)\n    # y <= sqrt3 * x\n    best_pts[1::2, 0] = np.clip(best_pts[1::2, 0], 0, 0.5)\n    best_pts[1::2, 1] = np.clip(best_pts[1::2, 1], 0, sqrt3 * best_pts[1::2, 0])\n    \n    # Reflections (even indices)\n    # x' = 1 - x_gen. y' = y_gen.\n    # y' <= sqrt3 * (1 - x')\n    best_pts[2::2, 0] = np.clip(best_pts[2::2, 0], 0.5, 1.0)\n    best_pts[2::2, 1] = np.clip(best_pts[2::2, 1], 0, sqrt3 * (1 - best_pts[2::2, 0]))\n\n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.0,
    "min_area_normalized": 0.0,
    "min_triangle_area": 0.0,
    "eval_time": 28.211597204208374,
    "error": null
  },
  "prompt": "For n=11, the optimal configuration often has bilateral (reflective) symmetry. Implement a slack-variable optimization where 5 points are mirrored across the altitude, and 1 point lies on the altitude. Use SLSQP with analytical gradients.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport itertools\nimport time\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Finds a configuration of 11 points in an equilateral triangle maximizing the minimum area\n    of any triangle formed by three of these points.\n    \n    The triangle vertices are (0,0), (1,0), (0.5, sqrt(3)/2).\n    Uses a slack-variable optimization with SLSQP and analytical gradients,\n    enforcing bilateral symmetry (1 point on altitude, 5 symmetric pairs).\n    \"\"\"\n    \n    # Constants\n    sqrt3 = np.sqrt(3)\n    \n    # Precompute triplets for area calculation\n    triplets = np.array(list(itertools.combinations(range(11), 3)))\n    n_triplets = len(triplets)\n    \n    # --- Precompute indices for efficient Jacobian calculation ---\n    # We map the 11 points to the parameter vector u.\n    # u = [S, yc, x1, y1, x2, y2, ..., x5, y5]\n    # P0: (0.5, yc) -> depends on u[1]\n    # P(2k-1): (xk, yk) -> depends on u[2+2k], u[3+2k]\n    # P(2k): (1-xk, yk) -> depends on u[2+2k], u[3+2k] (reflected)\n    \n    # Flatten triplets to handle all points in all constraints at once\n    flat_p_idx = triplets.flatten()\n    jac_rows = np.repeat(np.arange(n_triplets), 3)\n    \n    # Arrays to store mapping info for each point in the flattened list\n    u_idx_x = np.zeros(len(flat_p_idx), dtype=int)\n    u_idx_y = np.zeros(len(flat_p_idx), dtype=int)\n    is_refl = np.zeros(len(flat_p_idx), dtype=bool)\n    is_p0 = (flat_p_idx == 0)\n    \n    # Fill mapping for generator points (indices 1..10)\n    not_p0 = ~is_p0\n    p_indices = flat_p_idx[not_p0]\n    # Map point index to generator index k (0..4)\n    # Point indices: 1,2 -> k=0; 3,4 -> k=1; ...\n    k = (p_indices - 1) // 2\n    u_idx_x[not_p0] = 2 + 2*k\n    u_idx_y[not_p0] = 3 + 2*k\n    # Even indices (2, 4...) are reflected\n    is_refl[not_p0] = (p_indices % 2 == 0)\n    \n    # P0 depends only on y (u[1])\n    u_idx_y[is_p0] = 1\n    \n    def get_points(u):\n        \"\"\"Constructs (11, 2) points array from parameters u.\"\"\"\n        pts = np.zeros((11, 2))\n        # P0 on altitude\n        pts[0] = [0.5, u[1]]\n        # Generator coordinates\n        x = u[2::2]\n        y = u[3::2]\n        # Odd points (left side)\n        pts[1::2, 0] = x\n        pts[1::2, 1] = y\n        # Even points (right side, reflected)\n        pts[2::2, 0] = 1.0 - x\n        pts[2::2, 1] = y\n        return pts\n\n    def constraints(u):\n        \"\"\"Returns vector of constraint values (>= 0).\"\"\"\n        S = u[0]\n        pts = get_points(u)\n        \n        # 1. Area constraints: Area(i,j,k) - S >= 0\n        p1 = pts[triplets[:, 0]]\n        p2 = pts[triplets[:, 1]]\n        p3 = pts[triplets[:, 2]]\n        \n        # Signed area * 2\n        det = p1[:,0]*(p2[:,1]-p3[:,1]) + p2[:,0]*(p3[:,1]-p1[:,1]) + p3[:,0]*(p1[:,1]-p2[:,1])\n        areas = 0.5 * np.abs(det)\n        \n        # 2. Geometric constraints: Points must be inside triangle\n        # For generator points (x, y), we enforce x <= 0.5 (bound) and y <= sqrt(3)*x\n        # So sqrt(3)*x - y >= 0\n        x_gen = u[2::2]\n        y_gen = u[3::2]\n        geo = sqrt3 * x_gen - y_gen\n        \n        return np.concatenate([areas - S, geo])\n\n    def jacobian(u):\n        \"\"\"Analytical Jacobian of constraints.\"\"\"\n        pts = get_points(u)\n        jac = np.zeros((n_triplets + 5, len(u)))\n        \n        # d(Area - S)/dS = -1\n        jac[:n_triplets, 0] = -1\n        \n        # --- Gradient of Area constraints ---\n        p1 = pts[triplets[:, 0]]\n        p2 = pts[triplets[:, 1]]\n        p3 = pts[triplets[:, 2]]\n        \n        x1, y1 = p1[:,0], p1[:,1]\n        x2, y2 = p2[:,0], p2[:,1]\n        x3, y3 = p3[:,0], p3[:,1]\n        \n        det = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)\n        # Gradient factor: 0.5 * sign(det)\n        factor = 0.5 * np.sign(det)\n        \n        # Partial derivatives of Det w.r.t coordinates\n        # dDet/dx1 = y2 - y3, etc.\n        dx1 = y2 - y3\n        dx2 = y3 - y1\n        dx3 = y1 - y2\n        dy1 = x3 - x2\n        dy2 = x1 - x3\n        dy3 = x2 - x1\n        \n        # Stack and flatten to align with flat_p_idx\n        # Order: p1, p2, p3 for each triplet\n        gx = np.stack([dx1, dx2, dx3], axis=1).flatten() * np.repeat(factor, 3)\n        gy = np.stack([dy1, dy2, dy3], axis=1).flatten() * np.repeat(factor, 3)\n        \n        # Accumulate gradients into Jacobian matrix using precomputed indices\n        \n        # 1. Update y-derivatives (all points depend on a y-param)\n        np.add.at(jac, (jac_rows, u_idx_y), gy)\n        \n        # 2. Update x-derivatives (P0 has constant x, others variable)\n        mask = ~is_p0\n        if np.any(mask):\n            rows = jac_rows[mask]\n            cols = u_idx_x[mask]\n            vals = gx[mask]\n            \n            # If point is reflected (x' = 1-x), dx'/dx = -1\n            refl = is_refl[mask]\n            vals = np.where(refl, -vals, vals)\n            \n            np.add.at(jac, (rows, cols), vals)\n            \n        # --- Gradient of Geometric constraints ---\n        # sqrt(3)*x - y >= 0\n        # deriv w.r.t x is sqrt(3), w.r.t y is -1\n        r_geo = np.arange(n_triplets, n_triplets + 5)\n        c_x = np.arange(2, 12, 2)\n        c_y = np.arange(3, 12, 2)\n        \n        jac[r_geo, c_x] = sqrt3\n        jac[r_geo, c_y] = -1\n        \n        return jac\n\n    # --- Optimization Loop ---\n    \n    best_min_area = -1.0\n    best_pts = np.zeros((11, 2))\n    \n    # Parameter bounds\n    # S > 0, small\n    # yc in [0, sqrt3/2]\n    # xk in [0, 0.5], yk in [0, sqrt3/2]\n    bounds = [(0, 0.2), (0, sqrt3/2)] + [(0, 0.5), (0, sqrt3/2)] * 5\n    \n    t_end = time.time() + 28 # 30s budget\n    \n    while time.time() < t_end:\n        # Random initialization\n        u0 = np.zeros(12)\n        u0[0] = 0.01 # Initial slack\n        u0[1] = np.random.uniform(0, sqrt3/2) # P0 y\n        for k in range(5):\n            xk = np.random.uniform(0.01, 0.5)\n            yk = np.random.uniform(0, sqrt3 * xk)\n            u0[2 + 2*k] = xk\n            u0[3 + 2*k] = yk\n            \n        try:\n            res = minimize(\n                lambda u: -u[0], # Maximize S\n                u0,\n                method='SLSQP',\n                jac=jacobian,\n                constraints={'type': 'ineq', 'fun': constraints},\n                bounds=bounds,\n                options={'maxiter': 300, 'ftol': 1e-8}\n            )\n            \n            pts = get_points(res.x)\n            \n            # Verify actual minimum area\n            p1 = pts[triplets[:, 0]]\n            p2 = pts[triplets[:, 1]]\n            p3 = pts[triplets[:, 2]]\n            det = p1[:,0]*(p2[:,1]-p3[:,1]) + p2[:,0]*(p3[:,1]-p1[:,1]) + p3[:,0]*(p1[:,1]-p2[:,1])\n            min_area = 0.5 * np.min(np.abs(det))\n            \n            if min_area > best_min_area:\n                best_min_area = min_area\n                best_pts = pts\n                \n        except Exception:\n            continue\n\n    # Ensure strict adherence to bounds (clamp due to floating point tolerance)\n    # P0\n    best_pts[0, 0] = 0.5\n    best_pts[0, 1] = np.clip(best_pts[0, 1], 0, sqrt3/2)\n    \n    # Generators (odd indices)\n    # y <= sqrt3 * x\n    best_pts[1::2, 0] = np.clip(best_pts[1::2, 0], 0, 0.5)\n    best_pts[1::2, 1] = np.clip(best_pts[1::2, 1], 0, sqrt3 * best_pts[1::2, 0])\n    \n    # Reflections (even indices)\n    # x' = 1 - x_gen. y' = y_gen.\n    # y' <= sqrt3 * (1 - x')\n    best_pts[2::2, 0] = np.clip(best_pts[2::2, 0], 0.5, 1.0)\n    best_pts[2::2, 1] = np.clip(best_pts[2::2, 1], 0, sqrt3 * (1 - best_pts[2::2, 0]))\n\n    return best_pts\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T12:19:52.857788",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 247,
        "candidates_token_count": 2840,
        "thoughts_token_count": 17011
      },
      "response_text_len": 7526
    }
  }
}