{
  "trial_id": "trial_6_3",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import combinations\nimport time\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn triangle problem for 11 points in an equilateral triangle.\n    Uses an inverse-power smoothing function to maximize the minimum triangle area.\n    \"\"\"\n    n = 11\n    # Equilateral triangle vertices and geometry\n    sqrt3 = np.sqrt(3)\n    sqrt3_half = sqrt3 / 2.0\n    \n    # Precompute triangle indices for vectorized area calculation\n    # There are binom(11, 3) = 165 possible triangles.\n    tri_indices = np.array(list(combinations(range(n), 3)))\n    \n    def get_areas(pts):\n        \"\"\"Vectorized calculation of areas for all 165 triangles.\"\"\"\n        x = pts[:, 0]\n        y = pts[:, 1]\n        i, j, k = tri_indices[:, 0], tri_indices[:, 1], tri_indices[:, 2]\n        # Standard area formula: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|\n        areas = 0.5 * np.abs(x[i]*(y[j]-y[k]) + x[j]*(y[k]-y[i]) + x[k]*(y[i]-y[j]))\n        return areas\n\n    def objective(x_flat, p):\n        \"\"\"\n        Objective function: Minimize Sum(1 / (Area_i^p)).\n        p is a large even integer to strongly penalize small areas.\n        A scale factor is used to keep the numerical values in a stable range.\n        \"\"\"\n        pts = x_flat.reshape((-1, 2))\n        areas = get_areas(pts)\n        # Scaling factor: based on a typical area for 11 points in this triangle.\n        # This keeps the objective value manageable for the optimizer.\n        scale = (0.01)**p\n        # Inverse-power smoothing: epsilon is added to avoid division by zero.\n        return np.sum(scale / (areas**p + 1e-60))\n\n    def constraint_func(x_flat):\n        \"\"\"Boundary constraints: Points must stay inside the equilateral triangle.\"\"\"\n        pts = x_flat.reshape((-1, 2))\n        # Line from (0,0) to (1,0): y >= 0\n        c1 = pts[:, 1] \n        # Line from (0,0) to (0.5, sqrt(3)/2): y <= sqrt(3)x  =>  sqrt(3)x - y >= 0\n        c2 = sqrt3 * pts[:, 0] - pts[:, 1] \n        # Line from (1,0) to (0.5, sqrt(3)/2): y <= sqrt(3)(1-x)  =>  sqrt(3)(1-x) - y >= 0\n        c3 = sqrt3 * (1.0 - pts[:, 0]) - pts[:, 1]\n        return np.concatenate([c1, c2, c3])\n\n    # Optimization setup\n    cons = {'type': 'ineq', 'fun': constraint_func}\n    bounds = [(0, 1), (0, sqrt3_half)] * n\n\n    best_pts = None\n    best_min_area = -1\n    start_time = time.time()\n    \n    # Generate initial configurations (seeds)\n    seeds = []\n    \n    # Seed 1: Structured configuration (vertices, midpoints, and interior)\n    v = [[0.0, 0.0], [1.0, 0.0], [0.5, sqrt3_half]]\n    m = [[0.5, 0.0], [0.25, sqrt3_half/2], [0.75, sqrt3_half/2]]\n    i = [[0.5, 0.2], [0.4, 0.3], [0.6, 0.3], [0.3, 0.1], [0.7, 0.1]]\n    seeds.append(np.array(v + m + i).flatten())\n    \n    # Seed 2: Symmetric configuration\n    pts_sym = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.5, sqrt3_half],\n        [0.2, 0.0], [0.8, 0.0], [0.5, 0.0],\n        [0.1, 0.1*sqrt3], [0.9, 0.1*sqrt3],\n        [0.3, 0.1], [0.7, 0.1], [0.5, 0.2]\n    ])\n    seeds.append(pts_sym.flatten())\n    \n    # Random seeds: uniform points inside the triangle\n    np.random.seed(42)\n    for _ in range(12):\n        r1 = np.sqrt(np.random.rand(n))\n        r2 = np.random.rand(n)\n        pts = np.zeros((n, 2))\n        A = np.array([0, 0])\n        B = np.array([1, 0])\n        C = np.array([0.5, sqrt3_half])\n        for j in range(n):\n            pts[j] = (1 - r1[j]) * A + (r1[j] * (1 - r2[j])) * B + (r1[j] * r2[j]) * C\n        seeds.append(pts.flatten())\n\n    # Run optimizations on all seeds within the time limit\n    for x0 in seeds:\n        if time.time() - start_time > 26:\n            break\n        try:\n            # Use two stages of p for numerical stability and convergence\n            # Stage 1: Moderate penalty\n            res = minimize(objective, x0, args=(8,), method='SLSQP', constraints=cons, \n                           bounds=bounds, options={'maxiter': 80, 'ftol': 1e-6})\n            # Stage 2: Stronger penalty to focus on the absolute minimum area\n            res = minimize(objective, res.x, args=(16,), method='SLSQP', constraints=cons, \n                           bounds=bounds, options={'maxiter': 80, 'ftol': 1e-6})\n            \n            pts = res.x.reshape((n, 2))\n            m_area = np.min(get_areas(pts))\n            \n            if m_area > best_min_area:\n                best_min_area = m_area\n                best_pts = pts\n        except Exception:\n            continue\n            \n    # Fallback in case no optimization succeeded\n    if best_pts is None:\n        best_pts = seeds[0].reshape((n, 2))\n        \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.07373247965616538,
    "min_area_normalized": 0.002693439362421285,
    "min_triangle_area": 0.001166293455704897,
    "eval_time": 0.25158190727233887,
    "error": null
  },
  "prompt": "Instead of Log-Sum-Exp, use an inverse-power smoothing function for the Heilbronn problem.\n        Minimize Sum(1 / (Area_i^p)) for all possible triangles i, where p is a large even integer (e.g., p=8 or p=16).\n        This objective strongly penalizes small areas.\n        \n        Apply this to 11 points in the equilateral triangle (0,0), (1,0), (0.5, sqrt(3)/2).\n        Use SLSQP to handle the boundary constraints.\n        Try both symmetric and asymmetric initializations.\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import combinations\nimport time\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn triangle problem for 11 points in an equilateral triangle.\n    Uses an inverse-power smoothing function to maximize the minimum triangle area.\n    \"\"\"\n    n = 11\n    # Equilateral triangle vertices and geometry\n    sqrt3 = np.sqrt(3)\n    sqrt3_half = sqrt3 / 2.0\n    \n    # Precompute triangle indices for vectorized area calculation\n    # There are binom(11, 3) = 165 possible triangles.\n    tri_indices = np.array(list(combinations(range(n), 3)))\n    \n    def get_areas(pts):\n        \"\"\"Vectorized calculation of areas for all 165 triangles.\"\"\"\n        x = pts[:, 0]\n        y = pts[:, 1]\n        i, j, k = tri_indices[:, 0], tri_indices[:, 1], tri_indices[:, 2]\n        # Standard area formula: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|\n        areas = 0.5 * np.abs(x[i]*(y[j]-y[k]) + x[j]*(y[k]-y[i]) + x[k]*(y[i]-y[j]))\n        return areas\n\n    def objective(x_flat, p):\n        \"\"\"\n        Objective function: Minimize Sum(1 / (Area_i^p)).\n        p is a large even integer to strongly penalize small areas.\n        A scale factor is used to keep the numerical values in a stable range.\n        \"\"\"\n        pts = x_flat.reshape((-1, 2))\n        areas = get_areas(pts)\n        # Scaling factor: based on a typical area for 11 points in this triangle.\n        # This keeps the objective value manageable for the optimizer.\n        scale = (0.01)**p\n        # Inverse-power smoothing: epsilon is added to avoid division by zero.\n        return np.sum(scale / (areas**p + 1e-60))\n\n    def constraint_func(x_flat):\n        \"\"\"Boundary constraints: Points must stay inside the equilateral triangle.\"\"\"\n        pts = x_flat.reshape((-1, 2))\n        # Line from (0,0) to (1,0): y >= 0\n        c1 = pts[:, 1] \n        # Line from (0,0) to (0.5, sqrt(3)/2): y <= sqrt(3)x  =>  sqrt(3)x - y >= 0\n        c2 = sqrt3 * pts[:, 0] - pts[:, 1] \n        # Line from (1,0) to (0.5, sqrt(3)/2): y <= sqrt(3)(1-x)  =>  sqrt(3)(1-x) - y >= 0\n        c3 = sqrt3 * (1.0 - pts[:, 0]) - pts[:, 1]\n        return np.concatenate([c1, c2, c3])\n\n    # Optimization setup\n    cons = {'type': 'ineq', 'fun': constraint_func}\n    bounds = [(0, 1), (0, sqrt3_half)] * n\n\n    best_pts = None\n    best_min_area = -1\n    start_time = time.time()\n    \n    # Generate initial configurations (seeds)\n    seeds = []\n    \n    # Seed 1: Structured configuration (vertices, midpoints, and interior)\n    v = [[0.0, 0.0], [1.0, 0.0], [0.5, sqrt3_half]]\n    m = [[0.5, 0.0], [0.25, sqrt3_half/2], [0.75, sqrt3_half/2]]\n    i = [[0.5, 0.2], [0.4, 0.3], [0.6, 0.3], [0.3, 0.1], [0.7, 0.1]]\n    seeds.append(np.array(v + m + i).flatten())\n    \n    # Seed 2: Symmetric configuration\n    pts_sym = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.5, sqrt3_half],\n        [0.2, 0.0], [0.8, 0.0], [0.5, 0.0],\n        [0.1, 0.1*sqrt3], [0.9, 0.1*sqrt3],\n        [0.3, 0.1], [0.7, 0.1], [0.5, 0.2]\n    ])\n    seeds.append(pts_sym.flatten())\n    \n    # Random seeds: uniform points inside the triangle\n    np.random.seed(42)\n    for _ in range(12):\n        r1 = np.sqrt(np.random.rand(n))\n        r2 = np.random.rand(n)\n        pts = np.zeros((n, 2))\n        A = np.array([0, 0])\n        B = np.array([1, 0])\n        C = np.array([0.5, sqrt3_half])\n        for j in range(n):\n            pts[j] = (1 - r1[j]) * A + (r1[j] * (1 - r2[j])) * B + (r1[j] * r2[j]) * C\n        seeds.append(pts.flatten())\n\n    # Run optimizations on all seeds within the time limit\n    for x0 in seeds:\n        if time.time() - start_time > 26:\n            break\n        try:\n            # Use two stages of p for numerical stability and convergence\n            # Stage 1: Moderate penalty\n            res = minimize(objective, x0, args=(8,), method='SLSQP', constraints=cons, \n                           bounds=bounds, options={'maxiter': 80, 'ftol': 1e-6})\n            # Stage 2: Stronger penalty to focus on the absolute minimum area\n            res = minimize(objective, res.x, args=(16,), method='SLSQP', constraints=cons, \n                           bounds=bounds, options={'maxiter': 80, 'ftol': 1e-6})\n            \n            pts = res.x.reshape((n, 2))\n            m_area = np.min(get_areas(pts))\n            \n            if m_area > best_min_area:\n                best_min_area = m_area\n                best_pts = pts\n        except Exception:\n            continue\n            \n    # Fallback in case no optimization succeeded\n    if best_pts is None:\n        best_pts = seeds[0].reshape((n, 2))\n        \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T11:28:02.599916",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 330,
        "candidates_token_count": 1645,
        "thoughts_token_count": 21903
      },
      "response_text_len": 4639
    }
  }
}