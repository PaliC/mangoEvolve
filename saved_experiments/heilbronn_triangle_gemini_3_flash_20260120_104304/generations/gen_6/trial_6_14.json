{
  "trial_id": "trial_6_14",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport itertools\nimport time\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn triangle problem for 11 points in an equilateral triangle of unit area.\n    The goal is to maximize the minimum area among all triangles formed by any three points.\n    \"\"\"\n    \n    # To achieve unit area for an equilateral triangle:\n    # Area = (sqrt(3)/4) * side^2 = 1.0\n    # side^2 = 4 / sqrt(3)\n    # side = 2 / 3**0.25\n    s = 2.0 / (3.0**0.25)\n    h = 3.0**0.25\n    sqrt3 = np.sqrt(3.0)\n    \n    # Precompute all combinations of 3 points out of 11\n    n_points = 11\n    combos = np.array(list(itertools.combinations(range(n_points), 3)))\n\n    def get_min_area(points):\n        \"\"\"Calculates the minimum area among all triangles formed by 3 points.\"\"\"\n        p1 = points[combos[:, 0]]\n        p2 = points[combos[:, 1]]\n        p3 = points[combos[:, 2]]\n        # Area formula: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|\n        areas = 0.5 * np.abs(p1[:, 0]*(p2[:, 1] - p3[:, 1]) + \n                             p2[:, 0]*(p3[:, 1] - p1[:, 1]) + \n                             p3[:, 0]*(p1[:, 1] - p2[:, 1]))\n        return np.min(areas)\n\n    def objective_lse(x_flat, beta):\n        \"\"\"Log-Sum-Exp objective function to approximate the max-min area.\"\"\"\n        points = x_flat.reshape(n_points, 2)\n        p1 = points[combos[:, 0]]\n        p2 = points[combos[:, 1]]\n        p3 = points[combos[:, 2]]\n        # Differentiable approximation of the triangle area\n        d = (p1[:, 0]*(p2[:, 1] - p3[:, 1]) + \n             p2[:, 0]*(p3[:, 1] - p1[:, 1]) + \n             p3[:, 0]*(p1[:, 1] - p2[:, 1]))\n        areas = 0.5 * np.sqrt(d**2 + 1e-10)\n        \n        # Log-Sum-Exp trick: maximize min(areas) <=> minimize 1/beta * log(sum(exp(-beta * areas)))\n        x_i = -beta * areas\n        max_xi = np.max(x_i)\n        lse = max_xi + np.log(np.sum(np.exp(x_i - max_xi)))\n        return lse / beta\n\n    def constraints(x_flat):\n        \"\"\"Linear constraints to keep points inside the equilateral triangle (0,0), (s,0), (s/2, h).\"\"\"\n        pts = x_flat.reshape(n_points, 2)\n        c1 = pts[:, 1] # y >= 0\n        c2 = sqrt3 * pts[:, 0] - pts[:, 1] # y <= sqrt(3)*x  => sqrt(3)*x - y >= 0\n        c3 = sqrt3 * s - sqrt3 * pts[:, 0] - pts[:, 1] # y <= sqrt(3)*(s-x) => sqrt(3)*s - sqrt(3)*x - y >= 0\n        return np.concatenate([c1, c2, c3])\n\n    def project_to_triangle(pts, side, height):\n        \"\"\"Robustly maps points back inside the triangle using barycentric coordinates.\"\"\"\n        for i in range(len(pts)):\n            x, y = pts[i]\n            # Barycentric coordinates for the triangle (0,0), (side,0), (side/2, height)\n            w = y / height\n            v = x / side - y / (2.0 * height)\n            u = 1.0 - v - w\n            if u < -1e-9 or v < -1e-9 or w < -1e-9:\n                u, v, w = np.maximum([u, v, w], 0)\n                sum_uvw = u + v + w\n                if sum_uvw > 0:\n                    u, v, w = u / sum_uvw, v / sum_uvw, w / sum_uvw\n                else:\n                    u, v, w = 1.0, 0.0, 0.0\n                pts[i, 0] = v * side + w * side / 2.0\n                pts[i, 1] = w * height\n        return pts\n\n    # Initialize best points with a random uniform configuration\n    r1, r2 = np.random.rand(n_points), np.random.rand(n_points)\n    best_points = np.stack([s * np.sqrt(r1) * (1 - r2 / 2), h * np.sqrt(r1) * r2], axis=1)\n    best_min_area = get_min_area(best_points)\n    \n    start_time = time.time()\n    # Multi-start optimization loop\n    for iteration in range(100):\n        # Time limit check\n        if time.time() - start_time > 26:\n            break\n        \n        # Alternate between bilateral symmetry priors and random starts\n        if iteration % 2 == 0:\n            # Symmetry across the altitude (x = s/2)\n            # 5 pairs of mirrored points + 1 point on the altitude\n            r1_sym, r2_sym = np.random.rand(6), np.random.rand(6)\n            x_half = s * np.sqrt(r1_sym) * (1 - r2_sym / 2)\n            y_half = h * np.sqrt(r1_sym) * r2_sym\n            x_half[:5] = np.where(x_half[:5] > s/2, s - x_half[:5], x_half[:5])\n            x_half[5] = s/2\n            pts_init = np.zeros((n_points, 2))\n            for i in range(5):\n                pts_init[2*i] = [x_half[i], y_half[i]]\n                pts_init[2*i+1] = [s - x_half[i], y_half[i]]\n            pts_init[10] = [x_half[5], y_half[5]]\n        else:\n            # Random uniform initialization\n            r1_rand, r2_rand = np.random.rand(n_points), np.random.rand(n_points)\n            pts_init = np.stack([s * np.sqrt(r1_rand) * (1 - r2_rand / 2), h * np.sqrt(r1_rand) * r2_rand], axis=1)\n\n        # Optimize using SLSQP\n        res = minimize(objective_lse, pts_init.flatten(), args=(200,), \n                       method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options={'maxiter': 100, 'disp': False})\n        \n        if res.success or iteration == 0:\n            pts_res = res.x.reshape(n_points, 2)\n            # Ensure points are strictly within boundaries\n            pts_res = project_to_triangle(pts_res, s, h)\n            current_min_area = get_min_area(pts_res)\n            \n            # Update best solution found so far\n            if current_min_area > best_min_area:\n                best_min_area = current_min_area\n                best_points = pts_res\n                \n    return best_points",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 2.2179689407348633,
    "error": "Point (0.6554780680974819, 0.6833743082747347) is outside the triangle (tolerance: 1e-06)."
  },
  "prompt": "Improve the Heilbronn triangle 11-point solution using a multi-start SLSQP approach with a Log-Sum-Exp objective. Focus on robust coordinate mapping to keep points inside the triangle. Experiment with different symmetry priors (bilateral vs none).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport itertools\nimport time\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn triangle problem for 11 points in an equilateral triangle of unit area.\n    The goal is to maximize the minimum area among all triangles formed by any three points.\n    \"\"\"\n    \n    # To achieve unit area for an equilateral triangle:\n    # Area = (sqrt(3)/4) * side^2 = 1.0\n    # side^2 = 4 / sqrt(3)\n    # side = 2 / 3**0.25\n    s = 2.0 / (3.0**0.25)\n    h = 3.0**0.25\n    sqrt3 = np.sqrt(3.0)\n    \n    # Precompute all combinations of 3 points out of 11\n    n_points = 11\n    combos = np.array(list(itertools.combinations(range(n_points), 3)))\n\n    def get_min_area(points):\n        \"\"\"Calculates the minimum area among all triangles formed by 3 points.\"\"\"\n        p1 = points[combos[:, 0]]\n        p2 = points[combos[:, 1]]\n        p3 = points[combos[:, 2]]\n        # Area formula: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|\n        areas = 0.5 * np.abs(p1[:, 0]*(p2[:, 1] - p3[:, 1]) + \n                             p2[:, 0]*(p3[:, 1] - p1[:, 1]) + \n                             p3[:, 0]*(p1[:, 1] - p2[:, 1]))\n        return np.min(areas)\n\n    def objective_lse(x_flat, beta):\n        \"\"\"Log-Sum-Exp objective function to approximate the max-min area.\"\"\"\n        points = x_flat.reshape(n_points, 2)\n        p1 = points[combos[:, 0]]\n        p2 = points[combos[:, 1]]\n        p3 = points[combos[:, 2]]\n        # Differentiable approximation of the triangle area\n        d = (p1[:, 0]*(p2[:, 1] - p3[:, 1]) + \n             p2[:, 0]*(p3[:, 1] - p1[:, 1]) + \n             p3[:, 0]*(p1[:, 1] - p2[:, 1]))\n        areas = 0.5 * np.sqrt(d**2 + 1e-10)\n        \n        # Log-Sum-Exp trick: maximize min(areas) <=> minimize 1/beta * log(sum(exp(-beta * areas)))\n        x_i = -beta * areas\n        max_xi = np.max(x_i)\n        lse = max_xi + np.log(np.sum(np.exp(x_i - max_xi)))\n        return lse / beta\n\n    def constraints(x_flat):\n        \"\"\"Linear constraints to keep points inside the equilateral triangle (0,0), (s,0), (s/2, h).\"\"\"\n        pts = x_flat.reshape(n_points, 2)\n        c1 = pts[:, 1] # y >= 0\n        c2 = sqrt3 * pts[:, 0] - pts[:, 1] # y <= sqrt(3)*x  => sqrt(3)*x - y >= 0\n        c3 = sqrt3 * s - sqrt3 * pts[:, 0] - pts[:, 1] # y <= sqrt(3)*(s-x) => sqrt(3)*s - sqrt(3)*x - y >= 0\n        return np.concatenate([c1, c2, c3])\n\n    def project_to_triangle(pts, side, height):\n        \"\"\"Robustly maps points back inside the triangle using barycentric coordinates.\"\"\"\n        for i in range(len(pts)):\n            x, y = pts[i]\n            # Barycentric coordinates for the triangle (0,0), (side,0), (side/2, height)\n            w = y / height\n            v = x / side - y / (2.0 * height)\n            u = 1.0 - v - w\n            if u < -1e-9 or v < -1e-9 or w < -1e-9:\n                u, v, w = np.maximum([u, v, w], 0)\n                sum_uvw = u + v + w\n                if sum_uvw > 0:\n                    u, v, w = u / sum_uvw, v / sum_uvw, w / sum_uvw\n                else:\n                    u, v, w = 1.0, 0.0, 0.0\n                pts[i, 0] = v * side + w * side / 2.0\n                pts[i, 1] = w * height\n        return pts\n\n    # Initialize best points with a random uniform configuration\n    r1, r2 = np.random.rand(n_points), np.random.rand(n_points)\n    best_points = np.stack([s * np.sqrt(r1) * (1 - r2 / 2), h * np.sqrt(r1) * r2], axis=1)\n    best_min_area = get_min_area(best_points)\n    \n    start_time = time.time()\n    # Multi-start optimization loop\n    for iteration in range(100):\n        # Time limit check\n        if time.time() - start_time > 26:\n            break\n        \n        # Alternate between bilateral symmetry priors and random starts\n        if iteration % 2 == 0:\n            # Symmetry across the altitude (x = s/2)\n            # 5 pairs of mirrored points + 1 point on the altitude\n            r1_sym, r2_sym = np.random.rand(6), np.random.rand(6)\n            x_half = s * np.sqrt(r1_sym) * (1 - r2_sym / 2)\n            y_half = h * np.sqrt(r1_sym) * r2_sym\n            x_half[:5] = np.where(x_half[:5] > s/2, s - x_half[:5], x_half[:5])\n            x_half[5] = s/2\n            pts_init = np.zeros((n_points, 2))\n            for i in range(5):\n                pts_init[2*i] = [x_half[i], y_half[i]]\n                pts_init[2*i+1] = [s - x_half[i], y_half[i]]\n            pts_init[10] = [x_half[5], y_half[5]]\n        else:\n            # Random uniform initialization\n            r1_rand, r2_rand = np.random.rand(n_points), np.random.rand(n_points)\n            pts_init = np.stack([s * np.sqrt(r1_rand) * (1 - r2_rand / 2), h * np.sqrt(r1_rand) * r2_rand], axis=1)\n\n        # Optimize using SLSQP\n        res = minimize(objective_lse, pts_init.flatten(), args=(200,), \n                       method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options={'maxiter': 100, 'disp': False})\n        \n        if res.success or iteration == 0:\n            pts_res = res.x.reshape(n_points, 2)\n            # Ensure points are strictly within boundaries\n            pts_res = project_to_triangle(pts_res, s, h)\n            current_min_area = get_min_area(pts_res)\n            \n            # Update best solution found so far\n            if current_min_area > best_min_area:\n                best_min_area = current_min_area\n                best_points = pts_res\n                \n    return best_points\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T11:30:47.746690",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 250,
        "candidates_token_count": 1926,
        "thoughts_token_count": 27008
      },
      "response_text_len": 5473
    }
  }
}