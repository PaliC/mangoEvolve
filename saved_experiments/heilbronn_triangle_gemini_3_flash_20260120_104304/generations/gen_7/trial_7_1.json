{
  "trial_id": "trial_7_1",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport itertools\nimport random\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Finds an optimal configuration of 11 points in an equilateral triangle\n    to maximize the minimum area of any triangle formed by the points.\n    \n    Strategy:\n    1. Start with a symmetric configuration (5 pairs + 1 center point).\n    2. Optimize using SLSQP with a Softmin objective.\n    3. Relax the symmetry constraint and refine all 22 coordinates.\n    \"\"\"\n    \n    # Constants\n    SQRT3 = np.sqrt(3.0)\n    N = 11\n    \n    # Time limit\n    MAX_TIME = 28.0 \n    start_time = time.time()\n\n    # Softmin parameters\n    # alpha controls the approximation of min function. \n    # Higher alpha -> closer to min, but harder gradients.\n    ALPHA_SYM = 2000.0\n    ALPHA_FULL = 5000.0\n\n    # Precompute triplet indices for area calculation\n    combs = np.array(list(itertools.combinations(range(N), 3)), dtype=np.int32)\n    c0, c1, c2 = combs[:, 0], combs[:, 1], combs[:, 2]\n\n    # --- Helper Functions ---\n\n    def get_areas(pts):\n        \"\"\"Calculates areas of all triangles formed by pts.\"\"\"\n        x = pts[:, 0]\n        y = pts[:, 1]\n        \n        # Vectorized coordinate gathering\n        x_A, y_A = x[c0], y[c0]\n        x_B, y_B = x[c1], y[c1]\n        x_C, y_C = x[c2], y[c2]\n        \n        # Shoelace formula: 0.5 * |xA(yB - yC) + xB(yC - yA) + xC(yA - yB)|\n        val = x_A * (y_B - y_C) + x_B * (y_C - y_A) + x_C * (y_A - y_B)\n        return 0.5 * np.abs(val)\n\n    def get_min_area(pts):\n        return np.min(get_areas(pts))\n        \n    def project_to_triangle(pts):\n        \"\"\"Projects points strictly inside the triangle constraints.\"\"\"\n        # Triangle: (0,0), (1,0), (0.5, sqrt3/2)\n        # Constraints: y >= 0, y <= sqrt3*x, y <= sqrt3*(1-x)\n        \n        new_pts = np.copy(pts)\n        for i in range(len(new_pts)):\n            px, py = new_pts[i]\n            # Clamp x to [0,1]\n            px = max(0.0, min(1.0, px))\n            # Clamp y >= 0\n            py = max(0.0, py)\n            \n            # Constraint: y <= sqrt3 * x\n            limit1 = SQRT3 * px\n            py = min(py, limit1)\n            \n            # Constraint: y <= sqrt3 * (1 - px)\n            limit2 = SQRT3 * (1.0 - px)\n            py = min(py, limit2)\n            \n            new_pts[i] = [px, py]\n        return new_pts\n\n    # --- Objective Functions ---\n\n    def obj_sym(params):\n        \"\"\"\n        Objective for Symmetric Phase.\n        params: [x0, y0, ..., x4, y4, yc] (11 floats)\n        Constructs 11 points: 5 pairs (x,y) & (1-x,y), 1 center (0.5, yc)\n        \"\"\"\n        lx = params[0:10:2]\n        ly = params[1:10:2]\n        yc = params[10]\n        \n        # Left points\n        p_l = np.column_stack((lx, ly))\n        # Right points (reflected)\n        p_r = np.column_stack((1.0 - lx, ly))\n        # Center point\n        p_c = np.array([[0.5, yc]])\n        \n        pts = np.vstack((p_l, p_r, p_c))\n        \n        areas = get_areas(pts)\n        # Softmin: minimize sum(exp(-alpha * A)) -> approximates maximizing min(A)\n        return np.sum(np.exp(-ALPHA_SYM * areas))\n\n    def obj_full(params):\n        \"\"\"\n        Objective for Full Phase.\n        params: [x0, y0, ..., x10, y10] (22 floats)\n        \"\"\"\n        pts = params.reshape((N, 2))\n        areas = get_areas(pts)\n        return np.sum(np.exp(-ALPHA_FULL * areas))\n\n    # --- Constraints Setup ---\n    \n    # 1. Symmetric Constraints\n    # x in [0, 0.5], y in [0, sqrt3/2], y <= sqrt3 * x\n    cons_sym = []\n    for i in range(5):\n        # sqrt3*x - y >= 0\n        cons_sym.append({'type': 'ineq', 'fun': lambda p, i=i: SQRT3 * p[2*i] - p[2*i+1]})\n    \n    bounds_sym = [(0, 0.5), (0, SQRT3/2)] * 5 + [(0, SQRT3/2)]\n\n    # 2. Full Constraints\n    # y <= sqrt3*x, y <= sqrt3*(1-x)\n    cons_full = []\n    for i in range(N):\n        # Left edge: sqrt3*x - y >= 0\n        cons_full.append({'type': 'ineq', 'fun': lambda p, i=i: SQRT3 * p[2*i] - p[2*i+1]})\n        # Right edge: sqrt3*(1-x) - y >= 0\n        cons_full.append({'type': 'ineq', 'fun': lambda p, i=i: SQRT3 * (1.0 - p[2*i]) - p[2*i+1]})\n    \n    bounds_full = [(0, 1), (0, SQRT3/2)] * N\n\n    # --- Main Optimization Loop ---\n    \n    best_pts = np.zeros((N, 2))\n    best_min_area = -1.0\n    \n    iteration = 0\n    \n    # Run multiple restarts within the time limit\n    while time.time() - start_time < MAX_TIME - 1.0:\n        iteration += 1\n        \n        # --- Initialization ---\n        p0_sym = []\n        \n        # Heuristic: Often optimal solutions include the vertices.\n        # Bias initialization to put points near corners in 50% of runs.\n        bias_corners = (iteration % 2 == 0) \n        \n        start_k = 0\n        if bias_corners:\n            # Pair 0: near (0,0) -> generates (0,0) and (1,0)\n            p0_sym.extend([0.001 * random.random(), 0.001 * random.random()])\n            start_k = 1\n            \n        # Random fill remaining pairs in the fundamental domain (left half)\n        for _ in range(start_k, 5):\n            while True:\n                rx = random.uniform(0, 0.5)\n                ry = random.uniform(0, SQRT3/2)\n                # Ensure inside left triangle\n                if ry <= SQRT3 * rx:\n                    p0_sym.extend([rx, ry])\n                    break\n        \n        # Center point y-coordinate\n        if bias_corners:\n            # Near top vertex\n            p0_sym.append(SQRT3/2 - 0.001 * random.random())\n        else:\n            p0_sym.append(random.uniform(0, SQRT3/2))\n            \n        p0_sym = np.array(p0_sym)\n        \n        # --- Phase 1: Symmetric Optimization ---\n        try:\n            res_sym = minimize(obj_sym, p0_sym, method='SLSQP', \n                               bounds=bounds_sym, constraints=cons_sym, \n                               tol=1e-4, options={'maxiter': 100})\n            \n            # Expand symmetric params to full coordinates\n            lx = res_sym.x[0:10:2]\n            ly = res_sym.x[1:10:2]\n            yc = res_sym.x[10]\n            pts_sym = np.vstack((np.column_stack((lx, ly)), \n                                 np.column_stack((1.0 - lx, ly)), \n                                 np.array([[0.5, yc]])))\n                                 \n            # --- Phase 2: Full Optimization (Relaxation) ---\n            p0_full = pts_sym.flatten()\n            # Add slight noise to allow breaking symmetry if gradient dictates\n            p0_full += np.random.normal(0, 1e-6, size=p0_full.shape)\n            \n            res_full = minimize(obj_full, p0_full, method='SLSQP', \n                                bounds=bounds_full, constraints=cons_full, \n                                tol=1e-6, options={'maxiter': 200})\n            \n            # --- Record Result ---\n            cand_pts = res_full.x.reshape((N, 2))\n            cand_pts = project_to_triangle(cand_pts) # Ensure strict validity\n            \n            min_area = get_min_area(cand_pts)\n            \n            if min_area > best_min_area:\n                best_min_area = min_area\n                best_pts = cand_pts\n                \n        except Exception:\n            continue\n\n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.47901471150420794,
    "min_area_normalized": 0.01749835466216313,
    "min_triangle_area": 0.007577009830931569,
    "eval_time": 27.248288869857788,
    "error": null
  },
  "prompt": "For n=11, bilateral symmetry (reflection) is a strong candidate for the optimal configuration. Implement an optimizer that starts by enforcing reflection symmetry (x -> 1-x) for 5 pairs of points and places 1 point on the axis of symmetry (x=0.5). Optimize this 11-parameter system first, then relax all 22 coordinates for a final refinement. Use SLSQP and a Softmin objective.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport itertools\nimport random\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Finds an optimal configuration of 11 points in an equilateral triangle\n    to maximize the minimum area of any triangle formed by the points.\n    \n    Strategy:\n    1. Start with a symmetric configuration (5 pairs + 1 center point).\n    2. Optimize using SLSQP with a Softmin objective.\n    3. Relax the symmetry constraint and refine all 22 coordinates.\n    \"\"\"\n    \n    # Constants\n    SQRT3 = np.sqrt(3.0)\n    N = 11\n    \n    # Time limit\n    MAX_TIME = 28.0 \n    start_time = time.time()\n\n    # Softmin parameters\n    # alpha controls the approximation of min function. \n    # Higher alpha -> closer to min, but harder gradients.\n    ALPHA_SYM = 2000.0\n    ALPHA_FULL = 5000.0\n\n    # Precompute triplet indices for area calculation\n    combs = np.array(list(itertools.combinations(range(N), 3)), dtype=np.int32)\n    c0, c1, c2 = combs[:, 0], combs[:, 1], combs[:, 2]\n\n    # --- Helper Functions ---\n\n    def get_areas(pts):\n        \"\"\"Calculates areas of all triangles formed by pts.\"\"\"\n        x = pts[:, 0]\n        y = pts[:, 1]\n        \n        # Vectorized coordinate gathering\n        x_A, y_A = x[c0], y[c0]\n        x_B, y_B = x[c1], y[c1]\n        x_C, y_C = x[c2], y[c2]\n        \n        # Shoelace formula: 0.5 * |xA(yB - yC) + xB(yC - yA) + xC(yA - yB)|\n        val = x_A * (y_B - y_C) + x_B * (y_C - y_A) + x_C * (y_A - y_B)\n        return 0.5 * np.abs(val)\n\n    def get_min_area(pts):\n        return np.min(get_areas(pts))\n        \n    def project_to_triangle(pts):\n        \"\"\"Projects points strictly inside the triangle constraints.\"\"\"\n        # Triangle: (0,0), (1,0), (0.5, sqrt3/2)\n        # Constraints: y >= 0, y <= sqrt3*x, y <= sqrt3*(1-x)\n        \n        new_pts = np.copy(pts)\n        for i in range(len(new_pts)):\n            px, py = new_pts[i]\n            # Clamp x to [0,1]\n            px = max(0.0, min(1.0, px))\n            # Clamp y >= 0\n            py = max(0.0, py)\n            \n            # Constraint: y <= sqrt3 * x\n            limit1 = SQRT3 * px\n            py = min(py, limit1)\n            \n            # Constraint: y <= sqrt3 * (1 - px)\n            limit2 = SQRT3 * (1.0 - px)\n            py = min(py, limit2)\n            \n            new_pts[i] = [px, py]\n        return new_pts\n\n    # --- Objective Functions ---\n\n    def obj_sym(params):\n        \"\"\"\n        Objective for Symmetric Phase.\n        params: [x0, y0, ..., x4, y4, yc] (11 floats)\n        Constructs 11 points: 5 pairs (x,y) & (1-x,y), 1 center (0.5, yc)\n        \"\"\"\n        lx = params[0:10:2]\n        ly = params[1:10:2]\n        yc = params[10]\n        \n        # Left points\n        p_l = np.column_stack((lx, ly))\n        # Right points (reflected)\n        p_r = np.column_stack((1.0 - lx, ly))\n        # Center point\n        p_c = np.array([[0.5, yc]])\n        \n        pts = np.vstack((p_l, p_r, p_c))\n        \n        areas = get_areas(pts)\n        # Softmin: minimize sum(exp(-alpha * A)) -> approximates maximizing min(A)\n        return np.sum(np.exp(-ALPHA_SYM * areas))\n\n    def obj_full(params):\n        \"\"\"\n        Objective for Full Phase.\n        params: [x0, y0, ..., x10, y10] (22 floats)\n        \"\"\"\n        pts = params.reshape((N, 2))\n        areas = get_areas(pts)\n        return np.sum(np.exp(-ALPHA_FULL * areas))\n\n    # --- Constraints Setup ---\n    \n    # 1. Symmetric Constraints\n    # x in [0, 0.5], y in [0, sqrt3/2], y <= sqrt3 * x\n    cons_sym = []\n    for i in range(5):\n        # sqrt3*x - y >= 0\n        cons_sym.append({'type': 'ineq', 'fun': lambda p, i=i: SQRT3 * p[2*i] - p[2*i+1]})\n    \n    bounds_sym = [(0, 0.5), (0, SQRT3/2)] * 5 + [(0, SQRT3/2)]\n\n    # 2. Full Constraints\n    # y <= sqrt3*x, y <= sqrt3*(1-x)\n    cons_full = []\n    for i in range(N):\n        # Left edge: sqrt3*x - y >= 0\n        cons_full.append({'type': 'ineq', 'fun': lambda p, i=i: SQRT3 * p[2*i] - p[2*i+1]})\n        # Right edge: sqrt3*(1-x) - y >= 0\n        cons_full.append({'type': 'ineq', 'fun': lambda p, i=i: SQRT3 * (1.0 - p[2*i]) - p[2*i+1]})\n    \n    bounds_full = [(0, 1), (0, SQRT3/2)] * N\n\n    # --- Main Optimization Loop ---\n    \n    best_pts = np.zeros((N, 2))\n    best_min_area = -1.0\n    \n    iteration = 0\n    \n    # Run multiple restarts within the time limit\n    while time.time() - start_time < MAX_TIME - 1.0:\n        iteration += 1\n        \n        # --- Initialization ---\n        p0_sym = []\n        \n        # Heuristic: Often optimal solutions include the vertices.\n        # Bias initialization to put points near corners in 50% of runs.\n        bias_corners = (iteration % 2 == 0) \n        \n        start_k = 0\n        if bias_corners:\n            # Pair 0: near (0,0) -> generates (0,0) and (1,0)\n            p0_sym.extend([0.001 * random.random(), 0.001 * random.random()])\n            start_k = 1\n            \n        # Random fill remaining pairs in the fundamental domain (left half)\n        for _ in range(start_k, 5):\n            while True:\n                rx = random.uniform(0, 0.5)\n                ry = random.uniform(0, SQRT3/2)\n                # Ensure inside left triangle\n                if ry <= SQRT3 * rx:\n                    p0_sym.extend([rx, ry])\n                    break\n        \n        # Center point y-coordinate\n        if bias_corners:\n            # Near top vertex\n            p0_sym.append(SQRT3/2 - 0.001 * random.random())\n        else:\n            p0_sym.append(random.uniform(0, SQRT3/2))\n            \n        p0_sym = np.array(p0_sym)\n        \n        # --- Phase 1: Symmetric Optimization ---\n        try:\n            res_sym = minimize(obj_sym, p0_sym, method='SLSQP', \n                               bounds=bounds_sym, constraints=cons_sym, \n                               tol=1e-4, options={'maxiter': 100})\n            \n            # Expand symmetric params to full coordinates\n            lx = res_sym.x[0:10:2]\n            ly = res_sym.x[1:10:2]\n            yc = res_sym.x[10]\n            pts_sym = np.vstack((np.column_stack((lx, ly)), \n                                 np.column_stack((1.0 - lx, ly)), \n                                 np.array([[0.5, yc]])))\n                                 \n            # --- Phase 2: Full Optimization (Relaxation) ---\n            p0_full = pts_sym.flatten()\n            # Add slight noise to allow breaking symmetry if gradient dictates\n            p0_full += np.random.normal(0, 1e-6, size=p0_full.shape)\n            \n            res_full = minimize(obj_full, p0_full, method='SLSQP', \n                                bounds=bounds_full, constraints=cons_full, \n                                tol=1e-6, options={'maxiter': 200})\n            \n            # --- Record Result ---\n            cand_pts = res_full.x.reshape((N, 2))\n            cand_pts = project_to_triangle(cand_pts) # Ensure strict validity\n            \n            min_area = get_min_area(cand_pts)\n            \n            if min_area > best_min_area:\n                best_min_area = min_area\n                best_pts = cand_pts\n                \n        except Exception:\n            continue\n\n    return best_pts\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T11:36:47.499463",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 289,
        "candidates_token_count": 2375,
        "thoughts_token_count": 14794
      },
      "response_text_len": 7172
    }
  }
}