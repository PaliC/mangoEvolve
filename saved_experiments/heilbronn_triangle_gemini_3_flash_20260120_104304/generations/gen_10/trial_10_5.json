{
  "trial_id": "trial_10_5",
  "generation": 10,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport itertools\nimport math\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn Triangle problem for 11 points in an equilateral triangle.\n    Uses a Smart Mutation evolutionary strategy with SLSQP refinement.\n    \n    The triangle vertices are (0,0), (1,0), and (0.5, sqrt(3)/2).\n    The goal is to maximize the minimum area of any triangle formed by three points.\n    \"\"\"\n    # Precision constant for sqrt(3)\n    SQRT3 = 1.7320508075688772\n    h = SQRT3 / 2.0\n    k = 1.0\n    V = np.array([[0, 0], [1, 0], [0.5, h]])\n    \n    # Precompute all possible triplets of indices for 11 points\n    triplets = np.array(list(itertools.combinations(range(11), 3)))\n    \n    def get_min_area(pts):\n        \"\"\"Calculates the minimum area among all triangles formed by the points.\"\"\"\n        p1 = pts[triplets[:, 0]]\n        p2 = pts[triplets[:, 1]]\n        p3 = pts[triplets[:, 2]]\n        # Vectorized triangle area calculation: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|\n        areas = 0.5 * np.abs((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                             (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n        return np.min(areas)\n\n    def get_signs(pts):\n        \"\"\"Determines the orientation sign of each triplet for the linear constraints.\"\"\"\n        p1 = pts[triplets[:, 0]]\n        p2 = pts[triplets[:, 1]]\n        p3 = pts[triplets[:, 2]]\n        signed_areas = 0.5 * ((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                              (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n        return np.where(signed_areas >= 0, 1, -1)\n\n    def objective(x):\n        \"\"\"Objective function for SLSQP: maximize the slack variable t.\"\"\"\n        return -x[-1]\n\n    def constraints(x, current_signs):\n        \"\"\"Defines boundary and area constraints for the SLSQP optimizer.\"\"\"\n        pts_curr = x[:-1].reshape((11, 2))\n        t = x[-1]\n        \n        # Boundary constraints for an equilateral triangle (0,0), (1,0), (0.5, h)\n        # y >= 0\n        # sqrt(3)x - y >= 0\n        # sqrt(3)(1-x) - y >= 0\n        c_b = np.empty(33)\n        c_b[0::3] = pts_curr[:, 1]\n        c_b[1::3] = SQRT3 * pts_curr[:, 0] - pts_curr[:, 1]\n        c_b[2::3] = SQRT3 * (1.0 - pts_curr[:, 0]) - pts_curr[:, 1]\n        \n        # Area constraints: sign * signed_area >= t\n        p1 = pts_curr[triplets[:, 0]]\n        p2 = pts_curr[triplets[:, 1]]\n        p3 = pts_curr[triplets[:, 2]]\n        signed_areas = 0.5 * ((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                              (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n        c_a = current_signs * signed_areas - t\n        \n        return np.concatenate([c_b, c_a])\n\n    # Initial systematic point distribution\n    best_pts = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.5, h],\n        [0.33, 0.0], [0.67, 0.0],\n        [0.16, h/3], [0.33, 2*h/3],\n        [0.84, h/3], [0.67, 2*h/3],\n        [0.5, h/3], [0.5, h/6]\n    ])\n    best_area = get_min_area(best_pts)\n    \n    # Run evolutionary strategy with multiple random starts\n    num_starts = 6\n    num_mutations = 8\n    \n    for i_start in range(num_starts):\n        if i_start == 0:\n            pts = best_pts.copy()\n        else:\n            # Sample random points within the triangle boundary\n            r1 = np.random.rand(11, 1)\n            r2 = np.random.rand(11, 1)\n            sqrt_r1 = np.sqrt(r1)\n            pts = (1 - sqrt_r1) * V[0] + (sqrt_r1 * (1 - r2)) * V[1] + (sqrt_r1 * r2) * V[2]\n            \n        for _ in range(num_mutations):\n            # Calculate signs based on current orientation to linearize area constraints\n            current_signs = get_signs(pts)\n            # Initial guess: coordinates + current minimum area as slack variable t\n            x0 = np.concatenate([pts.flatten(), [get_min_area(pts)]])\n            \n            # Local refinement using SLSQP\n            res = minimize(\n                objective, x0, method='SLSQP',\n                constraints={'type': 'ineq', 'fun': constraints, 'args': (current_signs,)},\n                options={'maxiter': 80, 'disp': False}\n            )\n            \n            if res.success or res.x[-1] > best_area:\n                pts_refined = res.x[:-1].reshape((11, 2))\n                current_area = get_min_area(pts_refined)\n                if current_area > best_area:\n                    best_area = current_area\n                    best_pts = pts_refined.copy()\n                pts = pts_refined.copy()\n            \n            # Smart Mutation: Identify the triplet forming the smallest area and perturb it\n            p1 = pts[triplets[:, 0]]\n            p2 = pts[triplets[:, 1]]\n            p3 = pts[triplets[:, 2]]\n            areas = 0.5 * np.abs((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                                 (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n            worst_idx = np.argmin(areas)\n            worst_triplet = triplets[worst_idx]\n            \n            # Perturb the points of the worst triangle slightly\n            pts[worst_triplet] += np.random.normal(0, 0.015, size=(3, 2))\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.5417938851546683,
    "min_area_normalized": 0.019791670962373737,
    "min_triangle_area": 0.008570044918379233,
    "eval_time": 0.6473338603973389,
    "error": null
  },
  "prompt": "Use a 'Smart Mutation' evolutionary strategy. Start with the configuration from trial_8_0. In each generation, identify the three points forming the smallest triangle and perturb them slightly while keeping others fixed. Then run a local SLSQP refinement. Repeat for 100 iterations.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport itertools\nimport math\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn Triangle problem for 11 points in an equilateral triangle.\n    Uses a Smart Mutation evolutionary strategy with SLSQP refinement.\n    \n    The triangle vertices are (0,0), (1,0), and (0.5, sqrt(3)/2).\n    The goal is to maximize the minimum area of any triangle formed by three points.\n    \"\"\"\n    # Precision constant for sqrt(3)\n    SQRT3 = 1.7320508075688772\n    h = SQRT3 / 2.0\n    k = 1.0\n    V = np.array([[0, 0], [1, 0], [0.5, h]])\n    \n    # Precompute all possible triplets of indices for 11 points\n    triplets = np.array(list(itertools.combinations(range(11), 3)))\n    \n    def get_min_area(pts):\n        \"\"\"Calculates the minimum area among all triangles formed by the points.\"\"\"\n        p1 = pts[triplets[:, 0]]\n        p2 = pts[triplets[:, 1]]\n        p3 = pts[triplets[:, 2]]\n        # Vectorized triangle area calculation: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|\n        areas = 0.5 * np.abs((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                             (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n        return np.min(areas)\n\n    def get_signs(pts):\n        \"\"\"Determines the orientation sign of each triplet for the linear constraints.\"\"\"\n        p1 = pts[triplets[:, 0]]\n        p2 = pts[triplets[:, 1]]\n        p3 = pts[triplets[:, 2]]\n        signed_areas = 0.5 * ((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                              (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n        return np.where(signed_areas >= 0, 1, -1)\n\n    def objective(x):\n        \"\"\"Objective function for SLSQP: maximize the slack variable t.\"\"\"\n        return -x[-1]\n\n    def constraints(x, current_signs):\n        \"\"\"Defines boundary and area constraints for the SLSQP optimizer.\"\"\"\n        pts_curr = x[:-1].reshape((11, 2))\n        t = x[-1]\n        \n        # Boundary constraints for an equilateral triangle (0,0), (1,0), (0.5, h)\n        # y >= 0\n        # sqrt(3)x - y >= 0\n        # sqrt(3)(1-x) - y >= 0\n        c_b = np.empty(33)\n        c_b[0::3] = pts_curr[:, 1]\n        c_b[1::3] = SQRT3 * pts_curr[:, 0] - pts_curr[:, 1]\n        c_b[2::3] = SQRT3 * (1.0 - pts_curr[:, 0]) - pts_curr[:, 1]\n        \n        # Area constraints: sign * signed_area >= t\n        p1 = pts_curr[triplets[:, 0]]\n        p2 = pts_curr[triplets[:, 1]]\n        p3 = pts_curr[triplets[:, 2]]\n        signed_areas = 0.5 * ((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                              (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n        c_a = current_signs * signed_areas - t\n        \n        return np.concatenate([c_b, c_a])\n\n    # Initial systematic point distribution\n    best_pts = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.5, h],\n        [0.33, 0.0], [0.67, 0.0],\n        [0.16, h/3], [0.33, 2*h/3],\n        [0.84, h/3], [0.67, 2*h/3],\n        [0.5, h/3], [0.5, h/6]\n    ])\n    best_area = get_min_area(best_pts)\n    \n    # Run evolutionary strategy with multiple random starts\n    num_starts = 6\n    num_mutations = 8\n    \n    for i_start in range(num_starts):\n        if i_start == 0:\n            pts = best_pts.copy()\n        else:\n            # Sample random points within the triangle boundary\n            r1 = np.random.rand(11, 1)\n            r2 = np.random.rand(11, 1)\n            sqrt_r1 = np.sqrt(r1)\n            pts = (1 - sqrt_r1) * V[0] + (sqrt_r1 * (1 - r2)) * V[1] + (sqrt_r1 * r2) * V[2]\n            \n        for _ in range(num_mutations):\n            # Calculate signs based on current orientation to linearize area constraints\n            current_signs = get_signs(pts)\n            # Initial guess: coordinates + current minimum area as slack variable t\n            x0 = np.concatenate([pts.flatten(), [get_min_area(pts)]])\n            \n            # Local refinement using SLSQP\n            res = minimize(\n                objective, x0, method='SLSQP',\n                constraints={'type': 'ineq', 'fun': constraints, 'args': (current_signs,)},\n                options={'maxiter': 80, 'disp': False}\n            )\n            \n            if res.success or res.x[-1] > best_area:\n                pts_refined = res.x[:-1].reshape((11, 2))\n                current_area = get_min_area(pts_refined)\n                if current_area > best_area:\n                    best_area = current_area\n                    best_pts = pts_refined.copy()\n                pts = pts_refined.copy()\n            \n            # Smart Mutation: Identify the triplet forming the smallest area and perturb it\n            p1 = pts[triplets[:, 0]]\n            p2 = pts[triplets[:, 1]]\n            p3 = pts[triplets[:, 2]]\n            areas = 0.5 * np.abs((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                                 (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n            worst_idx = np.argmin(areas)\n            worst_triplet = triplets[worst_idx]\n            \n            # Perturb the points of the worst triangle slightly\n            pts[worst_triplet] += np.random.normal(0, 0.015, size=(3, 2))\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T11:50:49.685926",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 255,
        "candidates_token_count": 1794,
        "thoughts_token_count": 22495
      },
      "response_text_len": 5159
    }
  }
}