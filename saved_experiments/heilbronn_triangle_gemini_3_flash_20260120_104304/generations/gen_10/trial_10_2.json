{
  "trial_id": "trial_10_2",
  "generation": 10,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport itertools\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn triangle problem for 11 points in an equilateral triangle.\n    The method uses bilateral symmetry to initialize the optimization and then \n    relaxes the symmetry constraint to maximize the minimum triangle area.\n    \n    Vertices: (0,0), (1,0), (0.5, sqrt(3)/2)\n    Area of the equilateral triangle: sqrt(3)/4\n    \"\"\"\n\n    # Helper function to reconstruct 11 points from 11 symmetry parameters\n    def get_11pts_from_params(params):\n        # params: x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, y6\n        # Point pairs (x, y) and (1-x, y) are mirrored across x=0.5\n        pts = np.zeros((11, 2))\n        for i in range(5):\n            x, y = params[2*i], params[2*i+1]\n            pts[2*i] = [x, y]\n            pts[2*i+1] = [1-x, y]\n        # The 11th point lies on the line of symmetry x=0.5\n        pts[10] = [0.5, params[10]]\n        return pts\n\n    # Precompute combinations of 3 points out of 11 (165 combinations)\n    combo_indices = np.array(list(itertools.combinations(range(11), 3)))\n\n    def get_areas_fast(pts):\n        \"\"\"Vectorized calculation of the areas of all 165 possible triangles.\"\"\"\n        idx1, idx2, idx3 = combo_indices.T\n        p1, p2, p3 = pts[idx1], pts[idx2], pts[idx3]\n        areas = 0.5 * np.abs(p1[:, 0] * (p2[:, 1] - p3[:, 1]) + \n                             p2[:, 0] * (p3[:, 1] - p1[:, 1]) + \n                             p3[:, 0] * (p1[:, 1] - p2[:, 1]))\n        return areas\n\n    def get_signed_areas(pts):\n        \"\"\"Vectorized calculation of signed areas for the slack variable optimization.\"\"\"\n        idx1, idx2, idx3 = combo_indices.T\n        p1, p2, p3 = pts[idx1], pts[idx2], pts[idx3]\n        return 0.5 * (p1[:, 0] * (p2[:, 1] - p3[:, 1]) + \n                      p2[:, 0] * (p3[:, 1] - p1[:, 1]) + \n                      p3[:, 0] * (p1[:, 1] - p2[:, 1]))\n\n    def softmin_obj(params, k=2000):\n        \"\"\"Differentiable approximation of the negative minimum area.\"\"\"\n        pts = get_11pts_from_params(params)\n        areas = get_areas_fast(pts)\n        m = np.min(areas)\n        if m < 1e-9: return 1e10\n        # Softmin using the log-sum-exp trick for numerical stability\n        return -(m - (1.0/k) * np.log(np.sum(np.exp(-k * (areas - m)))))\n\n    def triangle_constraints_11(params):\n        \"\"\"Ensures the symmetric point pairs and the central point stay inside the triangle.\"\"\"\n        # We only need to check the unique 6 points (5 pairs + 1 central)\n        pts_to_check = np.zeros((6, 2))\n        pts_to_check[:5, 0] = params[0:10:2]\n        pts_to_check[:5, 1] = params[1:10:2]\n        pts_to_check[5] = [0.5, params[10]]\n        px, py = pts_to_check[:, 0], pts_to_check[:, 1]\n        \n        # Constraints: y >= 0, y <= sqrt(3)x, y <= sqrt(3)(1-x)\n        c1 = py\n        c2 = np.sqrt(3) * px - py\n        c3 = np.sqrt(3) * (1 - px) - py\n        return np.concatenate([c1, c2, c3])\n\n    # Step 1: Symmetry-constrained 11D optimization using SLSQP and Softmin\n    np.random.seed(42)\n    best_val = 1e10\n    best_params = np.zeros(11)\n    for _ in range(5):\n        initial_params = np.zeros(11)\n        for i in range(5):\n            # Sample random points in the left half of the triangle\n            x = np.random.uniform(0.01, 0.49)\n            y = np.random.uniform(0.01, min(np.sqrt(3) * x, np.sqrt(3) * (1 - x)) * 0.99)\n            initial_params[2*i], initial_params[2*i+1] = x, y\n        initial_params[10] = np.random.uniform(0.01, (np.sqrt(3)/2) * 0.99)\n        \n        res = minimize(softmin_obj, initial_params, \n                       constraints={'type': 'ineq', 'fun': triangle_constraints_11},\n                       method='SLSQP', options={'maxiter': 100})\n        if res.fun < best_val:\n            best_val = res.fun\n            best_params = res.x\n\n    # Step 2: Relaxation to full 22D space and optimization with a slack variable\n    initial_pts_22 = get_11pts_from_params(best_params)\n    sa = get_signed_areas(initial_pts_22)\n    \n    # Jittering to ensure no three points are collinear initially\n    while np.any(np.abs(sa) < 1e-8):\n        initial_pts_22 += np.random.normal(0, 1e-5, initial_pts_22.shape)\n        sa = get_signed_areas(initial_pts_22)\n    \n    # Store initial signs to linearize the absolute value in area constraints\n    initial_signs = np.sign(sa)\n    \n    # State vector: [x1, y1, ..., x11, y11, s] where s is the minimum area slack\n    x0_22 = np.zeros(23)\n    x0_22[:22] = initial_pts_22.flatten()\n    x0_22[22] = np.min(np.abs(sa))\n\n    def objective_22(x):\n        return -x[22]  # Maximize the slack variable s\n\n    def constraints_22(x):\n        pts = x[:22].reshape((11, 2))\n        s = x[22]\n        px, py = pts[:, 0], pts[:, 1]\n        \n        # Triangle boundary constraints for all 11 points (33 constraints)\n        c_tri = np.concatenate([py, np.sqrt(3) * px - py, np.sqrt(3) * (1 - px) - py])\n        \n        # Area constraints: sign(initial_area) * current_area >= s (165 constraints)\n        sa_curr = get_signed_areas(pts)\n        c_area = initial_signs * sa_curr - s\n        \n        return np.concatenate([c_tri, c_area])\n\n    # Final SLSQP optimization to refine point placement\n    res22 = minimize(objective_22, x0_22,\n                     constraints={'type': 'ineq', 'fun': constraints_22},\n                     method='SLSQP', options={'maxiter': 200})\n    \n    # Reshape resulting vector back into (11, 2) array of coordinates\n    final_pts = res22.x[:22].reshape((11, 2))\n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.8299916073447517,
    "min_area_normalized": 0.03031950201765301,
    "min_triangle_area": 0.013128729488690524,
    "eval_time": 0.26789402961730957,
    "error": null
  },
  "prompt": "Apply a 'Bilateral Symmetry' constraint to the 11-point Heilbronn problem. 5 pairs of points (x, y) and (1-x, y) mirrored across x=0.5, plus 1 point on the line x=0.5. Optimize this 11-dimensional space first using SLSQP and a softmin objective, then relax to 22D and maximize the minimum area using a slack variable. Vertices: (0,0), (1,0), (0.5, sqrt(3)/2).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport itertools\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn triangle problem for 11 points in an equilateral triangle.\n    The method uses bilateral symmetry to initialize the optimization and then \n    relaxes the symmetry constraint to maximize the minimum triangle area.\n    \n    Vertices: (0,0), (1,0), (0.5, sqrt(3)/2)\n    Area of the equilateral triangle: sqrt(3)/4\n    \"\"\"\n\n    # Helper function to reconstruct 11 points from 11 symmetry parameters\n    def get_11pts_from_params(params):\n        # params: x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, y6\n        # Point pairs (x, y) and (1-x, y) are mirrored across x=0.5\n        pts = np.zeros((11, 2))\n        for i in range(5):\n            x, y = params[2*i], params[2*i+1]\n            pts[2*i] = [x, y]\n            pts[2*i+1] = [1-x, y]\n        # The 11th point lies on the line of symmetry x=0.5\n        pts[10] = [0.5, params[10]]\n        return pts\n\n    # Precompute combinations of 3 points out of 11 (165 combinations)\n    combo_indices = np.array(list(itertools.combinations(range(11), 3)))\n\n    def get_areas_fast(pts):\n        \"\"\"Vectorized calculation of the areas of all 165 possible triangles.\"\"\"\n        idx1, idx2, idx3 = combo_indices.T\n        p1, p2, p3 = pts[idx1], pts[idx2], pts[idx3]\n        areas = 0.5 * np.abs(p1[:, 0] * (p2[:, 1] - p3[:, 1]) + \n                             p2[:, 0] * (p3[:, 1] - p1[:, 1]) + \n                             p3[:, 0] * (p1[:, 1] - p2[:, 1]))\n        return areas\n\n    def get_signed_areas(pts):\n        \"\"\"Vectorized calculation of signed areas for the slack variable optimization.\"\"\"\n        idx1, idx2, idx3 = combo_indices.T\n        p1, p2, p3 = pts[idx1], pts[idx2], pts[idx3]\n        return 0.5 * (p1[:, 0] * (p2[:, 1] - p3[:, 1]) + \n                      p2[:, 0] * (p3[:, 1] - p1[:, 1]) + \n                      p3[:, 0] * (p1[:, 1] - p2[:, 1]))\n\n    def softmin_obj(params, k=2000):\n        \"\"\"Differentiable approximation of the negative minimum area.\"\"\"\n        pts = get_11pts_from_params(params)\n        areas = get_areas_fast(pts)\n        m = np.min(areas)\n        if m < 1e-9: return 1e10\n        # Softmin using the log-sum-exp trick for numerical stability\n        return -(m - (1.0/k) * np.log(np.sum(np.exp(-k * (areas - m)))))\n\n    def triangle_constraints_11(params):\n        \"\"\"Ensures the symmetric point pairs and the central point stay inside the triangle.\"\"\"\n        # We only need to check the unique 6 points (5 pairs + 1 central)\n        pts_to_check = np.zeros((6, 2))\n        pts_to_check[:5, 0] = params[0:10:2]\n        pts_to_check[:5, 1] = params[1:10:2]\n        pts_to_check[5] = [0.5, params[10]]\n        px, py = pts_to_check[:, 0], pts_to_check[:, 1]\n        \n        # Constraints: y >= 0, y <= sqrt(3)x, y <= sqrt(3)(1-x)\n        c1 = py\n        c2 = np.sqrt(3) * px - py\n        c3 = np.sqrt(3) * (1 - px) - py\n        return np.concatenate([c1, c2, c3])\n\n    # Step 1: Symmetry-constrained 11D optimization using SLSQP and Softmin\n    np.random.seed(42)\n    best_val = 1e10\n    best_params = np.zeros(11)\n    for _ in range(5):\n        initial_params = np.zeros(11)\n        for i in range(5):\n            # Sample random points in the left half of the triangle\n            x = np.random.uniform(0.01, 0.49)\n            y = np.random.uniform(0.01, min(np.sqrt(3) * x, np.sqrt(3) * (1 - x)) * 0.99)\n            initial_params[2*i], initial_params[2*i+1] = x, y\n        initial_params[10] = np.random.uniform(0.01, (np.sqrt(3)/2) * 0.99)\n        \n        res = minimize(softmin_obj, initial_params, \n                       constraints={'type': 'ineq', 'fun': triangle_constraints_11},\n                       method='SLSQP', options={'maxiter': 100})\n        if res.fun < best_val:\n            best_val = res.fun\n            best_params = res.x\n\n    # Step 2: Relaxation to full 22D space and optimization with a slack variable\n    initial_pts_22 = get_11pts_from_params(best_params)\n    sa = get_signed_areas(initial_pts_22)\n    \n    # Jittering to ensure no three points are collinear initially\n    while np.any(np.abs(sa) < 1e-8):\n        initial_pts_22 += np.random.normal(0, 1e-5, initial_pts_22.shape)\n        sa = get_signed_areas(initial_pts_22)\n    \n    # Store initial signs to linearize the absolute value in area constraints\n    initial_signs = np.sign(sa)\n    \n    # State vector: [x1, y1, ..., x11, y11, s] where s is the minimum area slack\n    x0_22 = np.zeros(23)\n    x0_22[:22] = initial_pts_22.flatten()\n    x0_22[22] = np.min(np.abs(sa))\n\n    def objective_22(x):\n        return -x[22]  # Maximize the slack variable s\n\n    def constraints_22(x):\n        pts = x[:22].reshape((11, 2))\n        s = x[22]\n        px, py = pts[:, 0], pts[:, 1]\n        \n        # Triangle boundary constraints for all 11 points (33 constraints)\n        c_tri = np.concatenate([py, np.sqrt(3) * px - py, np.sqrt(3) * (1 - px) - py])\n        \n        # Area constraints: sign(initial_area) * current_area >= s (165 constraints)\n        sa_curr = get_signed_areas(pts)\n        c_area = initial_signs * sa_curr - s\n        \n        return np.concatenate([c_tri, c_area])\n\n    # Final SLSQP optimization to refine point placement\n    res22 = minimize(objective_22, x0_22,\n                     constraints={'type': 'ineq', 'fun': constraints_22},\n                     method='SLSQP', options={'maxiter': 200})\n    \n    # Reshape resulting vector back into (11, 2) array of coordinates\n    final_pts = res22.x[:22].reshape((11, 2))\n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T11:51:27.390224",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 316,
        "candidates_token_count": 1969,
        "thoughts_token_count": 29055
      },
      "response_text_len": 5581
    }
  }
}