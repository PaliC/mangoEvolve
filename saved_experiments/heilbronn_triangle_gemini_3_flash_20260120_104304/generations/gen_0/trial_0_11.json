{
  "trial_id": "trial_0_11",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nimport time\nimport itertools\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Finds 11 points in an equilateral triangle (vertices (0,0), (1,0), (0.5, sqrt(3)/2))\n    to maximize the minimum area of any triangle formed by the points.\n    Uses a CMA-ES style optimization approach.\n    \"\"\"\n    \n    # -------------------------------------------------------------------------\n    # Problem Definitions\n    # -------------------------------------------------------------------------\n    N_POINTS = 11\n    DIM = 2 * N_POINTS\n    SQRT3 = np.sqrt(3)\n    \n    # Vertices of the triangle\n    V1 = np.array([0.0, 0.0])\n    V2 = np.array([1.0, 0.0])\n    V3 = np.array([0.5, SQRT3/2])\n    \n    # Precompute indices for all possible triangles formed by N points\n    # Shape: (165, 3)\n    tri_indices = np.array(list(itertools.combinations(range(N_POINTS), 3)))\n    \n    # -------------------------------------------------------------------------\n    # Helper Functions\n    # -------------------------------------------------------------------------\n    \n    def get_min_areas_batch(points):\n        \"\"\"\n        Vectorized calculation of the minimum triangle area for a batch of configurations.\n        points: (Batch, N_POINTS, 2)\n        Returns: (Batch,) array of minimum areas.\n        \"\"\"\n        # Gather triangle vertices: (Batch, 165, 3, 2)\n        tris = points[:, tri_indices, :]\n        \n        x = tris[..., 0]\n        y = tris[..., 1]\n        \n        # Shoelace formula: 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|\n        term = x[..., 0] * (y[..., 1] - y[..., 2]) + \\\n               x[..., 1] * (y[..., 2] - y[..., 0]) + \\\n               x[..., 2] * (y[..., 0] - y[..., 1])\n               \n        areas = 0.5 * np.abs(term)\n        return np.min(areas, axis=1)\n\n    def project_and_penalty_batch(flat_pop):\n        \"\"\"\n        Projects points onto the triangle and calculates penalty for constraint violation.\n        flat_pop: (Batch, 22)\n        Returns: \n            clipped_points: (Batch, 11, 2) - valid coordinates inside/on triangle\n            penalties: (Batch,) - sum of squared distances moved (used for soft constraints)\n        \"\"\"\n        batch_size = flat_pop.shape[0]\n        pts = flat_pop.reshape(batch_size, N_POINTS, 2)\n        \n        # Triangle Constraints:\n        # 1. y >= 0\n        # 2. y <= sqrt(3)x  => sqrt(3)x - y >= 0\n        # 3. y <= sqrt(3)(1-x) => sqrt(3)(1-x) - y >= 0\n        \n        x = pts[..., 0]\n        y = pts[..., 1]\n        \n        c1 = y >= -1e-9\n        c2 = (SQRT3 * x - y) >= -1e-9\n        c3 = (SQRT3 * (1 - x) - y) >= -1e-9\n        inside = c1 & c2 & c3\n        \n        # If all points are inside, return immediately\n        if np.all(inside):\n            return pts, np.zeros(batch_size)\n        \n        # Flatten to handle points individually\n        pts_flat = pts.reshape(-1, 2)\n        inside_flat = inside.flatten()\n        \n        out_pts = pts_flat.copy()\n        dists = np.zeros(pts_flat.shape[0])\n        \n        # Identify outside points\n        idx_out = np.where(~inside_flat)[0]\n        \n        if len(idx_out) > 0:\n            p = pts_flat[idx_out]\n            \n            # --- Projection to Segment AB (y=0, x in [0,1]) ---\n            # Closest point is (clamp(x,0,1), 0)\n            t1 = np.clip(p[:, 0], 0, 1)\n            proj1 = np.stack([t1, np.zeros_like(t1)], axis=1)\n            d1_sq = np.sum((p - proj1)**2, axis=1)\n            \n            # --- Projection to Segment AC (Line through origin and V3) ---\n            # Vector AC = (0.5, sqrt(3)/2). Unit length is 1.\n            # Projection t = p . AC\n            ac_vec = np.array([0.5, SQRT3/2])\n            t2 = np.clip(np.dot(p, ac_vec), 0, 1)\n            proj2 = t2[:, None] * ac_vec\n            d2_sq = np.sum((p - proj2)**2, axis=1)\n            \n            # --- Projection to Segment BC (Line through V2 and V3) ---\n            # Vector from V2 to V3 = (-0.5, sqrt(3)/2). Length 1.\n            # p = V2 + t * v\n            v_bc = np.array([-0.5, SQRT3/2])\n            vec_p_v2 = p - V2\n            t3 = np.clip(np.dot(vec_p_v2, v_bc), 0, 1)\n            proj3 = V2 + t3[:, None] * v_bc\n            d3_sq = np.sum((p - proj3)**2, axis=1)\n            \n            # --- Select Closest ---\n            min_sq = np.minimum(d1_sq, np.minimum(d2_sq, d3_sq))\n            dists[idx_out] = min_sq\n            \n            mask1 = (d1_sq == min_sq)\n            mask2 = (d2_sq == min_sq) & (~mask1)\n            mask3 = (d3_sq == min_sq) & (~mask1) & (~mask2)\n            \n            out_pts[idx_out[mask1]] = proj1[mask1]\n            out_pts[idx_out[mask2]] = proj2[mask2]\n            out_pts[idx_out[mask3]] = proj3[mask3]\n            \n        return out_pts.reshape(batch_size, N_POINTS, 2), np.sum(dists.reshape(batch_size, N_POINTS), axis=1)\n\n    # -------------------------------------------------------------------------\n    # CMA-ES Algorithm Implementation\n    # -------------------------------------------------------------------------\n    \n    # Parameters\n    pop_size = 24  # Population size\n    mu = pop_size // 2\n    \n    # Recombination weights\n    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n    weights /= np.sum(weights)\n    mueff = 1 / np.sum(weights**2)\n    \n    # Adaptation time constants\n    cc = (4 + mueff/DIM) / (DIM + 4 + 2*mueff/DIM)\n    cs = (mueff + 2) / (DIM + mueff + 5)\n    c1 = 2 / ((DIM + 1.3)**2 + mueff)\n    cmu = min(1 - c1, 2 * (mueff - 2 + 1/mueff) / ((DIM + 2)**2 + mueff))\n    damps = 1 + 2 * max(0, np.sqrt((mueff - 1)/(DIM + 1)) - 1) + cs\n    \n    # Initialization\n    rng = np.random.default_rng(int(time.time()))\n    \n    # Initialize mean randomly inside the triangle\n    init_pts = []\n    while len(init_pts) < N_POINTS:\n        pt = rng.random(2)\n        pt[0] *= 1.0; pt[1] *= SQRT3/2 * 1.2 # slightly larger box\n        # Simple rejection sampling\n        if pt[1] >= 0 and pt[1] <= SQRT3*pt[0] and pt[1] <= SQRT3*(1-pt[0]):\n            init_pts.append(pt)\n    \n    xmean = np.array(init_pts).flatten()\n    # Fallback if rejection sampling fails (unlikely)\n    if len(xmean) != DIM: xmean = np.random.rand(DIM) * 0.1\n    \n    sigma = 0.15          # Step size\n    pc = np.zeros(DIM)    # Evolution path for C\n    ps = np.zeros(DIM)    # Evolution path for sigma\n    B = np.eye(DIM)       # Coordinate system\n    D_diag = np.ones(DIM) # Diagonal variances\n    C = np.eye(DIM)       # Covariance matrix\n    \n    chiN = DIM**0.5 * (1 - 1/(4*DIM) + 1/(21*DIM**2)) # Expectation of ||N(0,I)||\n    \n    best_solution = xmean.reshape(N_POINTS, 2)\n    best_fitness = -np.inf\n    \n    start_time = time.time()\n    generation = 0\n    \n    # Run for roughly 28 seconds to leave buffer\n    while time.time() - start_time < 28.0:\n        generation += 1\n        \n        # 1. Sample offspring\n        # z ~ N(0, I)\n        z = rng.standard_normal((pop_size, DIM))\n        # y ~ N(0, C) => y = B * D * z\n        y = z @ np.diag(D_diag) @ B.T\n        # x = m + sigma * y\n        offspring = xmean + sigma * y\n        \n        # 2. Evaluate fitness\n        # Clip points to valid region for evaluation\n        clipped_pop, penalties = project_and_penalty_batch(offspring)\n        min_areas = get_min_areas_batch(clipped_pop)\n        \n        # Objective: Maximize min_area, Minimize penalty\n        # Fitness = min_area - weight * penalty\n        fitness = min_areas - 1000.0 * penalties\n        \n        # 3. Selection\n        sorted_idx = np.argsort(fitness)[::-1] # Descending order\n        \n        # Update best solution found so far\n        current_best_idx = sorted_idx[0]\n        if fitness[current_best_idx] > best_fitness:\n            best_fitness = fitness[current_best_idx]\n            best_solution = clipped_pop[current_best_idx]\n        \n        # 4. Update CMA-ES parameters\n        y_selected = y[sorted_idx[:mu]]\n        z_selected = z[sorted_idx[:mu]]\n        \n        # Weighted mean of selected steps\n        y_w = np.dot(weights, y_selected)\n        z_w = np.dot(weights, z_selected)\n        \n        # Update mean\n        xmean = xmean + sigma * y_w\n        \n        # Update evolution paths\n        # ps\n        ps = (1 - cs) * ps + np.sqrt(cs * (2 - cs) * mueff) * (B @ z_w)\n        hsig = np.linalg.norm(ps) / np.sqrt(1 - (1 - cs)**(2 * generation)) / chiN < 1.4 + 2/(DIM+1)\n        \n        # pc\n        pc = (1 - cc) * pc + hsig * np.sqrt(cc * (2 - cc) * mueff) * y_w\n        \n        # Update Covariance Matrix C\n        rank_mu = (y_selected.T * weights) @ y_selected\n        pc_pair = np.outer(pc, pc)\n        dh = (1 - hsig) * cc * (2 - cc)\n        \n        C = (1 - c1 - cmu) * C + c1 * (pc_pair + dh * C) + cmu * rank_mu\n        \n        # Update sigma\n        sigma *= np.exp((cs / damps) * (np.linalg.norm(ps) / chiN - 1))\n        \n        # Decompose C into B and D (diagonalization)\n        # O(N^3), do periodically\n        if generation % 10 == 0:\n            C = np.triu(C) + np.triu(C, 1).T # Enforce symmetry\n            vals, vecs = np.linalg.eigh(C)\n            D_diag = np.sqrt(np.maximum(vals, 1e-20))\n            B = vecs\n            \n        # Restart mechanism if converged\n        if sigma < 1e-4:\n            sigma = 0.2\n            # Soft restart: perturb current best mean, reset covariance\n            xmean = best_solution.flatten() + rng.standard_normal(DIM) * 0.05\n            pc = np.zeros(DIM)\n            ps = np.zeros(DIM)\n            B = np.eye(DIM)\n            D_diag = np.ones(DIM)\n            C = np.eye(DIM)\n            \n    return best_solution",
  "metrics": {
    "valid": true,
    "score": 0.89290772931985,
    "min_area_normalized": 0.03261782102508189,
    "min_triangle_area": 0.014123930811907548,
    "eval_time": 28.12014102935791,
    "error": null
  },
  "prompt": "Use a 'CMA-ES' (Covariance Matrix Adaptation Evolution Strategy) style approach to optimize the 11 point positions. This is effective for non-convex continuous optimization. Ensure points are clipped to the triangle boundary.",
  "response": "```python\nimport numpy as np\nimport time\nimport itertools\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Finds 11 points in an equilateral triangle (vertices (0,0), (1,0), (0.5, sqrt(3)/2))\n    to maximize the minimum area of any triangle formed by the points.\n    Uses a CMA-ES style optimization approach.\n    \"\"\"\n    \n    # -------------------------------------------------------------------------\n    # Problem Definitions\n    # -------------------------------------------------------------------------\n    N_POINTS = 11\n    DIM = 2 * N_POINTS\n    SQRT3 = np.sqrt(3)\n    \n    # Vertices of the triangle\n    V1 = np.array([0.0, 0.0])\n    V2 = np.array([1.0, 0.0])\n    V3 = np.array([0.5, SQRT3/2])\n    \n    # Precompute indices for all possible triangles formed by N points\n    # Shape: (165, 3)\n    tri_indices = np.array(list(itertools.combinations(range(N_POINTS), 3)))\n    \n    # -------------------------------------------------------------------------\n    # Helper Functions\n    # -------------------------------------------------------------------------\n    \n    def get_min_areas_batch(points):\n        \"\"\"\n        Vectorized calculation of the minimum triangle area for a batch of configurations.\n        points: (Batch, N_POINTS, 2)\n        Returns: (Batch,) array of minimum areas.\n        \"\"\"\n        # Gather triangle vertices: (Batch, 165, 3, 2)\n        tris = points[:, tri_indices, :]\n        \n        x = tris[..., 0]\n        y = tris[..., 1]\n        \n        # Shoelace formula: 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|\n        term = x[..., 0] * (y[..., 1] - y[..., 2]) + \\\n               x[..., 1] * (y[..., 2] - y[..., 0]) + \\\n               x[..., 2] * (y[..., 0] - y[..., 1])\n               \n        areas = 0.5 * np.abs(term)\n        return np.min(areas, axis=1)\n\n    def project_and_penalty_batch(flat_pop):\n        \"\"\"\n        Projects points onto the triangle and calculates penalty for constraint violation.\n        flat_pop: (Batch, 22)\n        Returns: \n            clipped_points: (Batch, 11, 2) - valid coordinates inside/on triangle\n            penalties: (Batch,) - sum of squared distances moved (used for soft constraints)\n        \"\"\"\n        batch_size = flat_pop.shape[0]\n        pts = flat_pop.reshape(batch_size, N_POINTS, 2)\n        \n        # Triangle Constraints:\n        # 1. y >= 0\n        # 2. y <= sqrt(3)x  => sqrt(3)x - y >= 0\n        # 3. y <= sqrt(3)(1-x) => sqrt(3)(1-x) - y >= 0\n        \n        x = pts[..., 0]\n        y = pts[..., 1]\n        \n        c1 = y >= -1e-9\n        c2 = (SQRT3 * x - y) >= -1e-9\n        c3 = (SQRT3 * (1 - x) - y) >= -1e-9\n        inside = c1 & c2 & c3\n        \n        # If all points are inside, return immediately\n        if np.all(inside):\n            return pts, np.zeros(batch_size)\n        \n        # Flatten to handle points individually\n        pts_flat = pts.reshape(-1, 2)\n        inside_flat = inside.flatten()\n        \n        out_pts = pts_flat.copy()\n        dists = np.zeros(pts_flat.shape[0])\n        \n        # Identify outside points\n        idx_out = np.where(~inside_flat)[0]\n        \n        if len(idx_out) > 0:\n            p = pts_flat[idx_out]\n            \n            # --- Projection to Segment AB (y=0, x in [0,1]) ---\n            # Closest point is (clamp(x,0,1), 0)\n            t1 = np.clip(p[:, 0], 0, 1)\n            proj1 = np.stack([t1, np.zeros_like(t1)], axis=1)\n            d1_sq = np.sum((p - proj1)**2, axis=1)\n            \n            # --- Projection to Segment AC (Line through origin and V3) ---\n            # Vector AC = (0.5, sqrt(3)/2). Unit length is 1.\n            # Projection t = p . AC\n            ac_vec = np.array([0.5, SQRT3/2])\n            t2 = np.clip(np.dot(p, ac_vec), 0, 1)\n            proj2 = t2[:, None] * ac_vec\n            d2_sq = np.sum((p - proj2)**2, axis=1)\n            \n            # --- Projection to Segment BC (Line through V2 and V3) ---\n            # Vector from V2 to V3 = (-0.5, sqrt(3)/2). Length 1.\n            # p = V2 + t * v\n            v_bc = np.array([-0.5, SQRT3/2])\n            vec_p_v2 = p - V2\n            t3 = np.clip(np.dot(vec_p_v2, v_bc), 0, 1)\n            proj3 = V2 + t3[:, None] * v_bc\n            d3_sq = np.sum((p - proj3)**2, axis=1)\n            \n            # --- Select Closest ---\n            min_sq = np.minimum(d1_sq, np.minimum(d2_sq, d3_sq))\n            dists[idx_out] = min_sq\n            \n            mask1 = (d1_sq == min_sq)\n            mask2 = (d2_sq == min_sq) & (~mask1)\n            mask3 = (d3_sq == min_sq) & (~mask1) & (~mask2)\n            \n            out_pts[idx_out[mask1]] = proj1[mask1]\n            out_pts[idx_out[mask2]] = proj2[mask2]\n            out_pts[idx_out[mask3]] = proj3[mask3]\n            \n        return out_pts.reshape(batch_size, N_POINTS, 2), np.sum(dists.reshape(batch_size, N_POINTS), axis=1)\n\n    # -------------------------------------------------------------------------\n    # CMA-ES Algorithm Implementation\n    # -------------------------------------------------------------------------\n    \n    # Parameters\n    pop_size = 24  # Population size\n    mu = pop_size // 2\n    \n    # Recombination weights\n    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n    weights /= np.sum(weights)\n    mueff = 1 / np.sum(weights**2)\n    \n    # Adaptation time constants\n    cc = (4 + mueff/DIM) / (DIM + 4 + 2*mueff/DIM)\n    cs = (mueff + 2) / (DIM + mueff + 5)\n    c1 = 2 / ((DIM + 1.3)**2 + mueff)\n    cmu = min(1 - c1, 2 * (mueff - 2 + 1/mueff) / ((DIM + 2)**2 + mueff))\n    damps = 1 + 2 * max(0, np.sqrt((mueff - 1)/(DIM + 1)) - 1) + cs\n    \n    # Initialization\n    rng = np.random.default_rng(int(time.time()))\n    \n    # Initialize mean randomly inside the triangle\n    init_pts = []\n    while len(init_pts) < N_POINTS:\n        pt = rng.random(2)\n        pt[0] *= 1.0; pt[1] *= SQRT3/2 * 1.2 # slightly larger box\n        # Simple rejection sampling\n        if pt[1] >= 0 and pt[1] <= SQRT3*pt[0] and pt[1] <= SQRT3*(1-pt[0]):\n            init_pts.append(pt)\n    \n    xmean = np.array(init_pts).flatten()\n    # Fallback if rejection sampling fails (unlikely)\n    if len(xmean) != DIM: xmean = np.random.rand(DIM) * 0.1\n    \n    sigma = 0.15          # Step size\n    pc = np.zeros(DIM)    # Evolution path for C\n    ps = np.zeros(DIM)    # Evolution path for sigma\n    B = np.eye(DIM)       # Coordinate system\n    D_diag = np.ones(DIM) # Diagonal variances\n    C = np.eye(DIM)       # Covariance matrix\n    \n    chiN = DIM**0.5 * (1 - 1/(4*DIM) + 1/(21*DIM**2)) # Expectation of ||N(0,I)||\n    \n    best_solution = xmean.reshape(N_POINTS, 2)\n    best_fitness = -np.inf\n    \n    start_time = time.time()\n    generation = 0\n    \n    # Run for roughly 28 seconds to leave buffer\n    while time.time() - start_time < 28.0:\n        generation += 1\n        \n        # 1. Sample offspring\n        # z ~ N(0, I)\n        z = rng.standard_normal((pop_size, DIM))\n        # y ~ N(0, C) => y = B * D * z\n        y = z @ np.diag(D_diag) @ B.T\n        # x = m + sigma * y\n        offspring = xmean + sigma * y\n        \n        # 2. Evaluate fitness\n        # Clip points to valid region for evaluation\n        clipped_pop, penalties = project_and_penalty_batch(offspring)\n        min_areas = get_min_areas_batch(clipped_pop)\n        \n        # Objective: Maximize min_area, Minimize penalty\n        # Fitness = min_area - weight * penalty\n        fitness = min_areas - 1000.0 * penalties\n        \n        # 3. Selection\n        sorted_idx = np.argsort(fitness)[::-1] # Descending order\n        \n        # Update best solution found so far\n        current_best_idx = sorted_idx[0]\n        if fitness[current_best_idx] > best_fitness:\n            best_fitness = fitness[current_best_idx]\n            best_solution = clipped_pop[current_best_idx]\n        \n        # 4. Update CMA-ES parameters\n        y_selected = y[sorted_idx[:mu]]\n        z_selected = z[sorted_idx[:mu]]\n        \n        # Weighted mean of selected steps\n        y_w = np.dot(weights, y_selected)\n        z_w = np.dot(weights, z_selected)\n        \n        # Update mean\n        xmean = xmean + sigma * y_w\n        \n        # Update evolution paths\n        # ps\n        ps = (1 - cs) * ps + np.sqrt(cs * (2 - cs) * mueff) * (B @ z_w)\n        hsig = np.linalg.norm(ps) / np.sqrt(1 - (1 - cs)**(2 * generation)) / chiN < 1.4 + 2/(DIM+1)\n        \n        # pc\n        pc = (1 - cc) * pc + hsig * np.sqrt(cc * (2 - cc) * mueff) * y_w\n        \n        # Update Covariance Matrix C\n        rank_mu = (y_selected.T * weights) @ y_selected\n        pc_pair = np.outer(pc, pc)\n        dh = (1 - hsig) * cc * (2 - cc)\n        \n        C = (1 - c1 - cmu) * C + c1 * (pc_pair + dh * C) + cmu * rank_mu\n        \n        # Update sigma\n        sigma *= np.exp((cs / damps) * (np.linalg.norm(ps) / chiN - 1))\n        \n        # Decompose C into B and D (diagonalization)\n        # O(N^3), do periodically\n        if generation % 10 == 0:\n            C = np.triu(C) + np.triu(C, 1).T # Enforce symmetry\n            vals, vecs = np.linalg.eigh(C)\n            D_diag = np.sqrt(np.maximum(vals, 1e-20))\n            B = vecs\n            \n        # Restart mechanism if converged\n        if sigma < 1e-4:\n            sigma = 0.2\n            # Soft restart: perturb current best mean, reset covariance\n            xmean = best_solution.flatten() + rng.standard_normal(DIM) * 0.05\n            pc = np.zeros(DIM)\n            ps = np.zeros(DIM)\n            B = np.eye(DIM)\n            D_diag = np.ones(DIM)\n            C = np.eye(DIM)\n            \n    return best_solution\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T10:51:02.020202",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 244,
        "candidates_token_count": 3243,
        "thoughts_token_count": 18205
      },
      "response_text_len": 9532
    }
  }
}