{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nimport math\nimport time\nfrom itertools import combinations\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn Triangle problem for 11 points in an equilateral triangle.\n    The goal is to maximize the minimum area of any triangle formed by 3 points.\n    The equilateral triangle has vertices at (0,0), (1,0), and (0.5, sqrt(3)/2).\n    \"\"\"\n    # Height of the equilateral triangle with side length 1.\n    h = math.sqrt(3) / 2\n    n_points = 11\n    \n    # Pre-calculate all combinations of 3 points out of 11 to form all possible triangles.\n    # There are 165 such combinations for n=11.\n    tri_indices = np.array(list(combinations(range(n_points), 3)))\n\n    def project_to_triangle(p):\n        \"\"\"Projects a point p back into the equilateral triangle if it's outside using barycentric coordinates.\"\"\"\n        x, y = p\n        # Barycentric coordinates w.r.t. V0=(0,0), V1=(1,0), V2=(0.5, h)\n        # P = w0*V0 + w1*V1 + w2*V2\n        # System: x = w1 + 0.5*w2, y = w2*h, w0+w1+w2=1\n        w2 = y / h\n        w1 = x - y / (2 * h)\n        w0 = 1 - x - y / (2 * h)\n        \n        # If all barycentric coordinates are non-negative, the point is inside.\n        if w0 >= -1e-10 and w1 >= -1e-10 and w2 >= -1e-10:\n            return p\n        \n        # Project back by clamping the coordinates and re-normalizing.\n        w0_clamped = max(0.0, w0)\n        w1_clamped = max(0.0, w1)\n        w2_clamped = max(0.0, w2)\n        s = w0_clamped + w1_clamped + w2_clamped\n        if s < 1e-12:\n            return np.array([0.5, h / 3])  # Fallback to centroid if point is at a singularity\n        return np.array([(w1_clamped + 0.5 * w2_clamped) / s, (w2_clamped * h) / s])\n\n    def get_min_area_info(pts):\n        \"\"\"Calculates the minimum area among all triangles formed by the points.\"\"\"\n        p1 = pts[tri_indices[:, 0]]\n        p2 = pts[tri_indices[:, 1]]\n        p3 = pts[tri_indices[:, 2]]\n        # Area formula: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|\n        areas = 0.5 * np.abs(p1[:, 0] * (p2[:, 1] - p3[:, 1]) + \n                             p2[:, 0] * (p3[:, 1] - p1[:, 1]) + \n                             p3[:, 0] * (p1[:, 1] - p2[:, 1]))\n        min_idx = np.argmin(areas)\n        return areas[min_idx], tri_indices[min_idx], areas\n\n    # Initialize best points found so far.\n    best_overall_pts = np.zeros((n_points, 2))\n    best_overall_min_area = -1.0\n    start_time = time.time()\n\n    # Optimization loop using hill-climbing with random restarts.\n    while time.time() - start_time < 28:\n        # 1. Random initialization of points inside the triangle using barycentric sampling.\n        pts = []\n        for _ in range(n_points):\n            r1, r2 = np.random.rand(), np.random.rand()\n            if r1 + r2 > 1:\n                r1, r2 = 1 - r1, 1 - r2\n            pts.append([r1 + 0.5 * r2, r2 * h])\n        pts = np.array(pts)\n        \n        current_min_area, _, areas = get_min_area_info(pts)\n        step_size = 0.05\n        \n        # 2. Iterative local search (Hill Climbing).\n        for _ in range(1500):\n            improved = False\n            # Triangles sorted by area to identify those limiting the minimum area.\n            sorted_tri_indices = np.argsort(areas)\n            \n            # Smart Mutation: Focus on the worst 5 triangles to improve the minimum area.\n            for t_idx in range(min(5, len(sorted_tri_indices))):\n                tri_idx = sorted_tri_indices[t_idx]\n                indices = tri_indices[tri_idx]\n                \n                # Move each of the 3 points of the triangle along the area gradient.\n                for p_idx in indices:\n                    others = [idx for idx in indices if idx != p_idx]\n                    p_j, p_k = pts[others[0]], pts[others[1]]\n                    \n                    # f is the signed area determinant.\n                    f = pts[p_idx, 0] * (p_j[1] - p_k[1]) + p_j[0] * (p_k[1] - pts[p_idx, 1]) + p_k[0] * (pts[p_idx, 1] - p_j[1])\n                    \n                    if abs(f) < 1e-12:\n                        # Random direction if points are collinear.\n                        angle = np.random.rand() * 2 * np.pi\n                        direction = np.array([np.cos(angle), np.sin(angle)])\n                    else:\n                        # Gradient of Area = 0.5 * |f| w.r.t. pts[p_idx].\n                        # This vector is perpendicular to the base formed by p_j and p_k.\n                        grad_x = 0.5 * np.sign(f) * (p_j[1] - p_k[1])\n                        grad_y = 0.5 * np.sign(f) * (p_k[0] - p_j[0])\n                        direction = np.array([grad_x, grad_y])\n                        norm = np.linalg.norm(direction)\n                        if norm > 1e-10:\n                            direction /= norm\n                    \n                    # Tentatively update the point and check if the minimum area across ALL triangles increases.\n                    old_p = pts[p_idx].copy()\n                    pts[p_idx] = project_to_triangle(pts[p_idx] + direction * step_size)\n                    \n                    new_min_area, _, new_areas = get_min_area_info(pts)\n                    if new_min_area > current_min_area + 1e-13:\n                        current_min_area = new_min_area\n                        areas = new_areas\n                        improved = True\n                        break\n                    else:\n                        pts[p_idx] = old_p # Revert if no improvement.\n                \n                if improved:\n                    break\n            \n            if improved:\n                # Reset step size upon finding a better configuration to allow more movement.\n                step_size = 0.05\n            else:\n                # Decay step size if stuck in a local optimum.\n                step_size *= 0.85\n                if step_size < 1e-7:\n                    break\n        \n        # Global best update.\n        if current_min_area > best_overall_min_area:\n            best_overall_min_area = current_min_area\n            best_overall_pts = pts.copy()\n            \n    return best_overall_pts",
  "metrics": {
    "valid": true,
    "score": 0.6442715177520373,
    "min_area_normalized": 0.023535167596321814,
    "min_triangle_area": 0.010191026510369516,
    "eval_time": 28.426074981689453,
    "error": null
  },
  "prompt": "Implement an evolutionary strategy for n=11 points in the equilateral triangle. Use a 'Smart Mutation' operator: identify the triplet of points forming the smallest area, and move one of those points in a direction that increases that specific triangle's area (e.g., perpendicular to the opposite side).",
  "response": "```python\nimport numpy as np\nimport math\nimport time\nfrom itertools import combinations\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn Triangle problem for 11 points in an equilateral triangle.\n    The goal is to maximize the minimum area of any triangle formed by 3 points.\n    The equilateral triangle has vertices at (0,0), (1,0), and (0.5, sqrt(3)/2).\n    \"\"\"\n    # Height of the equilateral triangle with side length 1.\n    h = math.sqrt(3) / 2\n    n_points = 11\n    \n    # Pre-calculate all combinations of 3 points out of 11 to form all possible triangles.\n    # There are 165 such combinations for n=11.\n    tri_indices = np.array(list(combinations(range(n_points), 3)))\n\n    def project_to_triangle(p):\n        \"\"\"Projects a point p back into the equilateral triangle if it's outside using barycentric coordinates.\"\"\"\n        x, y = p\n        # Barycentric coordinates w.r.t. V0=(0,0), V1=(1,0), V2=(0.5, h)\n        # P = w0*V0 + w1*V1 + w2*V2\n        # System: x = w1 + 0.5*w2, y = w2*h, w0+w1+w2=1\n        w2 = y / h\n        w1 = x - y / (2 * h)\n        w0 = 1 - x - y / (2 * h)\n        \n        # If all barycentric coordinates are non-negative, the point is inside.\n        if w0 >= -1e-10 and w1 >= -1e-10 and w2 >= -1e-10:\n            return p\n        \n        # Project back by clamping the coordinates and re-normalizing.\n        w0_clamped = max(0.0, w0)\n        w1_clamped = max(0.0, w1)\n        w2_clamped = max(0.0, w2)\n        s = w0_clamped + w1_clamped + w2_clamped\n        if s < 1e-12:\n            return np.array([0.5, h / 3])  # Fallback to centroid if point is at a singularity\n        return np.array([(w1_clamped + 0.5 * w2_clamped) / s, (w2_clamped * h) / s])\n\n    def get_min_area_info(pts):\n        \"\"\"Calculates the minimum area among all triangles formed by the points.\"\"\"\n        p1 = pts[tri_indices[:, 0]]\n        p2 = pts[tri_indices[:, 1]]\n        p3 = pts[tri_indices[:, 2]]\n        # Area formula: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|\n        areas = 0.5 * np.abs(p1[:, 0] * (p2[:, 1] - p3[:, 1]) + \n                             p2[:, 0] * (p3[:, 1] - p1[:, 1]) + \n                             p3[:, 0] * (p1[:, 1] - p2[:, 1]))\n        min_idx = np.argmin(areas)\n        return areas[min_idx], tri_indices[min_idx], areas\n\n    # Initialize best points found so far.\n    best_overall_pts = np.zeros((n_points, 2))\n    best_overall_min_area = -1.0\n    start_time = time.time()\n\n    # Optimization loop using hill-climbing with random restarts.\n    while time.time() - start_time < 28:\n        # 1. Random initialization of points inside the triangle using barycentric sampling.\n        pts = []\n        for _ in range(n_points):\n            r1, r2 = np.random.rand(), np.random.rand()\n            if r1 + r2 > 1:\n                r1, r2 = 1 - r1, 1 - r2\n            pts.append([r1 + 0.5 * r2, r2 * h])\n        pts = np.array(pts)\n        \n        current_min_area, _, areas = get_min_area_info(pts)\n        step_size = 0.05\n        \n        # 2. Iterative local search (Hill Climbing).\n        for _ in range(1500):\n            improved = False\n            # Triangles sorted by area to identify those limiting the minimum area.\n            sorted_tri_indices = np.argsort(areas)\n            \n            # Smart Mutation: Focus on the worst 5 triangles to improve the minimum area.\n            for t_idx in range(min(5, len(sorted_tri_indices))):\n                tri_idx = sorted_tri_indices[t_idx]\n                indices = tri_indices[tri_idx]\n                \n                # Move each of the 3 points of the triangle along the area gradient.\n                for p_idx in indices:\n                    others = [idx for idx in indices if idx != p_idx]\n                    p_j, p_k = pts[others[0]], pts[others[1]]\n                    \n                    # f is the signed area determinant.\n                    f = pts[p_idx, 0] * (p_j[1] - p_k[1]) + p_j[0] * (p_k[1] - pts[p_idx, 1]) + p_k[0] * (pts[p_idx, 1] - p_j[1])\n                    \n                    if abs(f) < 1e-12:\n                        # Random direction if points are collinear.\n                        angle = np.random.rand() * 2 * np.pi\n                        direction = np.array([np.cos(angle), np.sin(angle)])\n                    else:\n                        # Gradient of Area = 0.5 * |f| w.r.t. pts[p_idx].\n                        # This vector is perpendicular to the base formed by p_j and p_k.\n                        grad_x = 0.5 * np.sign(f) * (p_j[1] - p_k[1])\n                        grad_y = 0.5 * np.sign(f) * (p_k[0] - p_j[0])\n                        direction = np.array([grad_x, grad_y])\n                        norm = np.linalg.norm(direction)\n                        if norm > 1e-10:\n                            direction /= norm\n                    \n                    # Tentatively update the point and check if the minimum area across ALL triangles increases.\n                    old_p = pts[p_idx].copy()\n                    pts[p_idx] = project_to_triangle(pts[p_idx] + direction * step_size)\n                    \n                    new_min_area, _, new_areas = get_min_area_info(pts)\n                    if new_min_area > current_min_area + 1e-13:\n                        current_min_area = new_min_area\n                        areas = new_areas\n                        improved = True\n                        break\n                    else:\n                        pts[p_idx] = old_p # Revert if no improvement.\n                \n                if improved:\n                    break\n            \n            if improved:\n                # Reset step size upon finding a better configuration to allow more movement.\n                step_size = 0.05\n            else:\n                # Decay step size if stuck in a local optimum.\n                step_size *= 0.85\n                if step_size < 1e-7:\n                    break\n        \n        # Global best update.\n        if current_min_area > best_overall_min_area:\n            best_overall_min_area = current_min_area\n            best_overall_pts = pts.copy()\n            \n    return best_overall_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T10:47:19.982020",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 259,
        "candidates_token_count": 1890,
        "thoughts_token_count": 20128
      },
      "response_text_len": 6127
    }
  }
}