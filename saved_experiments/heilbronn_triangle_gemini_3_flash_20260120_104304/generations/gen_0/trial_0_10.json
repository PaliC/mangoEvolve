{
  "trial_id": "trial_0_10",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nimport time\nfrom itertools import combinations\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Optimizes the positions of 11 points within an equilateral triangle to maximize \n    the minimum area of any triangle formed by three points.\n    \n    The equilateral triangle is defined by vertices (0,0), (1,0), and (0.5, sqrt(3)/2).\n    The algorithm uses Particle Swarm Optimization (PSO) to find an optimal configuration.\n    \"\"\"\n    \n    n_points = 11\n    num_particles = 150\n    \n    # Precompute the indices for all possible triangles (11 choose 3 = 165)\n    triangle_indices = np.array(list(combinations(range(n_points), 3)))\n    \n    # Precompute the constant sqrt(3)/2 for triangle height\n    SQRT3_OVER_2 = 0.8660254037844386\n    \n    # Triangle vertices are (0,0), (1,0), and (0.5, sqrt(3)/2).\n    # We use barycentric-like coordinates (u, v) such that points are \n    # mapped to Cartesian (x, y) coordinates as:\n    # x = u + 0.5 * v\n    # y = SQRT3_OVER_2 * v\n    # Constraints for (u, v) to be inside the triangle: u >= 0, v >= 0, u + v <= 1.\n    \n    # Initialize particles with a uniform distribution in the triangle\n    # u = 1 - sqrt(r1), v = r2 * sqrt(r1) provides a uniform sample in a triangle.\n    r1 = np.random.rand(num_particles, n_points)\n    r2 = np.random.rand(num_particles, n_points)\n    u_init = 1.0 - np.sqrt(r1)\n    v_init = r2 * np.sqrt(r1)\n    \n    particles = np.stack([u_init, v_init], axis=2) # Shape: (num_particles, 11, 2)\n    velocities = (np.random.rand(num_particles, n_points, 2) - 0.5) * 0.05\n    \n    def get_fitness_batch(p_batch):\n        \"\"\"\n        Calculates the minimum triangle area for each particle in the batch.\n        \"\"\"\n        # Convert barycentric (u, v) to Cartesian (x, y)\n        pts_x = p_batch[:, :, 0] + 0.5 * p_batch[:, :, 1]\n        pts_y = SQRT3_OVER_2 * p_batch[:, :, 1]\n        \n        # Extract coordinates for each combination of three points\n        p1x = pts_x[:, triangle_indices[:, 0]]\n        p1y = pts_y[:, triangle_indices[:, 0]]\n        p2x = pts_x[:, triangle_indices[:, 1]]\n        p2y = pts_y[:, triangle_indices[:, 1]]\n        p3x = pts_x[:, triangle_indices[:, 2]]\n        p3y = pts_y[:, triangle_indices[:, 2]]\n        \n        # Calculate areas using the shoelace formula: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|\n        areas = 0.5 * np.abs(\n            p1x * (p2y - p3y) +\n            p2x * (p3y - p1y) +\n            p3x * (p1y - p2y)\n        )\n        # We want to maximize the minimum area among all triangles in each configuration\n        return np.min(areas, axis=1)\n\n    # Personal best positions for each particle\n    p_best = particles.copy()\n    p_best_fitness = get_fitness_batch(particles)\n    \n    # Global best position found across all particles\n    g_best_idx = np.argmax(p_best_fitness)\n    g_best = p_best[g_best_idx].copy()\n    g_best_fitness = p_best_fitness[g_best_idx]\n    \n    # PSO parameters\n    c1, c2 = 1.5, 1.5\n    start_time = time.time()\n    iteration = 0\n    \n    # Run PSO iterations for approximately 28 seconds\n    while time.time() - start_time < 28.0:\n        # Inertia weight decay helps balance exploration and exploitation\n        w = 0.9 - 0.6 * min(1.0, iteration / 10000.0)\n        \n        r1_rand = np.random.rand(num_particles, n_points, 2)\n        r2_rand = np.random.rand(num_particles, n_points, 2)\n        \n        # Update velocities and positions\n        velocities = (w * velocities + \n                      c1 * r1_rand * (p_best - particles) + \n                      c2 * r2_rand * (g_best - particles))\n        particles += velocities\n        \n        # Project points to ensure they stay inside the triangle: u >= 0, v >= 0, u + v <= 1\n        u_p = particles[:, :, 0]\n        v_p = particles[:, :, 1]\n        \n        # Enforce u, v >= 0\n        u_p[u_p < 0] = 0\n        v_p[v_p < 0] = 0\n        # Enforce u + v <= 1 by projecting points outside onto the line u + v = 1\n        mask = (u_p + v_p) > 1.0\n        if np.any(mask):\n            over = (u_p[mask] + v_p[mask] - 1.0) / 2.0\n            u_p[mask] -= over\n            v_p[mask] -= over\n            # Re-ensure non-negativity after adjustment\n            u_p[u_p < 0] = 0\n            v_p[v_p < 0] = 0\n        \n        # Evaluate current configurations\n        fitness = get_fitness_batch(particles)\n        \n        # Update personal bests\n        better_mask = fitness > p_best_fitness\n        p_best[better_mask] = particles[better_mask]\n        p_best_fitness[better_mask] = fitness[better_mask]\n        \n        # Update global best\n        max_fitness = np.max(fitness)\n        if max_fitness > g_best_fitness:\n            g_best_fitness = max_fitness\n            g_best = particles[np.argmax(fitness)].copy()\n        \n        iteration += 1\n        \n    # Final coordinate conversion from (u, v) to (x, y)\n    x_final = g_best[:, 0] + 0.5 * g_best[:, 1]\n    y_final = SQRT3_OVER_2 * g_best[:, 1]\n    \n    return np.stack([x_final, y_final], axis=1)",
  "metrics": {
    "valid": true,
    "score": 0.6382183432008108,
    "min_area_normalized": 0.02331404579654091,
    "min_triangle_area": 0.010095277962399118,
    "eval_time": 28.07259511947632,
    "error": null
  },
  "prompt": "Solve for n=11 by optimizing the positions using a particle swarm optimization (PSO) algorithm. Define the fitness as the minimum triangle area. Ensure the particles (sets of 11 points) stay within the equilateral triangle boundary.",
  "response": "```python\nimport numpy as np\nimport time\nfrom itertools import combinations\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Optimizes the positions of 11 points within an equilateral triangle to maximize \n    the minimum area of any triangle formed by three points.\n    \n    The equilateral triangle is defined by vertices (0,0), (1,0), and (0.5, sqrt(3)/2).\n    The algorithm uses Particle Swarm Optimization (PSO) to find an optimal configuration.\n    \"\"\"\n    \n    n_points = 11\n    num_particles = 150\n    \n    # Precompute the indices for all possible triangles (11 choose 3 = 165)\n    triangle_indices = np.array(list(combinations(range(n_points), 3)))\n    \n    # Precompute the constant sqrt(3)/2 for triangle height\n    SQRT3_OVER_2 = 0.8660254037844386\n    \n    # Triangle vertices are (0,0), (1,0), and (0.5, sqrt(3)/2).\n    # We use barycentric-like coordinates (u, v) such that points are \n    # mapped to Cartesian (x, y) coordinates as:\n    # x = u + 0.5 * v\n    # y = SQRT3_OVER_2 * v\n    # Constraints for (u, v) to be inside the triangle: u >= 0, v >= 0, u + v <= 1.\n    \n    # Initialize particles with a uniform distribution in the triangle\n    # u = 1 - sqrt(r1), v = r2 * sqrt(r1) provides a uniform sample in a triangle.\n    r1 = np.random.rand(num_particles, n_points)\n    r2 = np.random.rand(num_particles, n_points)\n    u_init = 1.0 - np.sqrt(r1)\n    v_init = r2 * np.sqrt(r1)\n    \n    particles = np.stack([u_init, v_init], axis=2) # Shape: (num_particles, 11, 2)\n    velocities = (np.random.rand(num_particles, n_points, 2) - 0.5) * 0.05\n    \n    def get_fitness_batch(p_batch):\n        \"\"\"\n        Calculates the minimum triangle area for each particle in the batch.\n        \"\"\"\n        # Convert barycentric (u, v) to Cartesian (x, y)\n        pts_x = p_batch[:, :, 0] + 0.5 * p_batch[:, :, 1]\n        pts_y = SQRT3_OVER_2 * p_batch[:, :, 1]\n        \n        # Extract coordinates for each combination of three points\n        p1x = pts_x[:, triangle_indices[:, 0]]\n        p1y = pts_y[:, triangle_indices[:, 0]]\n        p2x = pts_x[:, triangle_indices[:, 1]]\n        p2y = pts_y[:, triangle_indices[:, 1]]\n        p3x = pts_x[:, triangle_indices[:, 2]]\n        p3y = pts_y[:, triangle_indices[:, 2]]\n        \n        # Calculate areas using the shoelace formula: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|\n        areas = 0.5 * np.abs(\n            p1x * (p2y - p3y) +\n            p2x * (p3y - p1y) +\n            p3x * (p1y - p2y)\n        )\n        # We want to maximize the minimum area among all triangles in each configuration\n        return np.min(areas, axis=1)\n\n    # Personal best positions for each particle\n    p_best = particles.copy()\n    p_best_fitness = get_fitness_batch(particles)\n    \n    # Global best position found across all particles\n    g_best_idx = np.argmax(p_best_fitness)\n    g_best = p_best[g_best_idx].copy()\n    g_best_fitness = p_best_fitness[g_best_idx]\n    \n    # PSO parameters\n    c1, c2 = 1.5, 1.5\n    start_time = time.time()\n    iteration = 0\n    \n    # Run PSO iterations for approximately 28 seconds\n    while time.time() - start_time < 28.0:\n        # Inertia weight decay helps balance exploration and exploitation\n        w = 0.9 - 0.6 * min(1.0, iteration / 10000.0)\n        \n        r1_rand = np.random.rand(num_particles, n_points, 2)\n        r2_rand = np.random.rand(num_particles, n_points, 2)\n        \n        # Update velocities and positions\n        velocities = (w * velocities + \n                      c1 * r1_rand * (p_best - particles) + \n                      c2 * r2_rand * (g_best - particles))\n        particles += velocities\n        \n        # Project points to ensure they stay inside the triangle: u >= 0, v >= 0, u + v <= 1\n        u_p = particles[:, :, 0]\n        v_p = particles[:, :, 1]\n        \n        # Enforce u, v >= 0\n        u_p[u_p < 0] = 0\n        v_p[v_p < 0] = 0\n        # Enforce u + v <= 1 by projecting points outside onto the line u + v = 1\n        mask = (u_p + v_p) > 1.0\n        if np.any(mask):\n            over = (u_p[mask] + v_p[mask] - 1.0) / 2.0\n            u_p[mask] -= over\n            v_p[mask] -= over\n            # Re-ensure non-negativity after adjustment\n            u_p[u_p < 0] = 0\n            v_p[v_p < 0] = 0\n        \n        # Evaluate current configurations\n        fitness = get_fitness_batch(particles)\n        \n        # Update personal bests\n        better_mask = fitness > p_best_fitness\n        p_best[better_mask] = particles[better_mask]\n        p_best_fitness[better_mask] = fitness[better_mask]\n        \n        # Update global best\n        max_fitness = np.max(fitness)\n        if max_fitness > g_best_fitness:\n            g_best_fitness = max_fitness\n            g_best = particles[np.argmax(fitness)].copy()\n        \n        iteration += 1\n        \n    # Final coordinate conversion from (u, v) to (x, y)\n    x_final = g_best[:, 0] + 0.5 * g_best[:, 1]\n    y_final = SQRT3_OVER_2 * g_best[:, 1]\n    \n    return np.stack([x_final, y_final], axis=1)\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T10:47:20.404237",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 245,
        "candidates_token_count": 1708,
        "thoughts_token_count": 20512
      },
      "response_text_len": 4984
    }
  }
}