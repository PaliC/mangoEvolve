{
  "trial_id": "trial_0_0",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nimport math\nimport random\nfrom scipy.optimize import minimize, LinearConstraint\nfrom itertools import combinations\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Finds a configuration of 11 points inside an equilateral triangle (vertices (0,0), (1,0), (0.5, sqrt(3)/2))\n    that maximizes the minimum area of any triangle formed by three of the points.\n    Uses Simulated Annealing followed by a gradient-based polish.\n    \"\"\"\n    N = 11\n    SQRT3 = np.sqrt(3)\n    \n    # Precompute triplet indices for vectorized area calculation\n    tri_idx = np.array(list(combinations(range(N), 3)))\n    \n    # Function to calculate areas of all triangles formed by the points\n    def get_areas(pts):\n        # pts shape (N, 2)\n        p1 = pts[tri_idx[:, 0]]\n        p2 = pts[tri_idx[:, 1]]\n        p3 = pts[tri_idx[:, 2]]\n        # Area = 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|\n        return 0.5 * np.abs(\n            p1[:,0]*(p2[:,1]-p3[:,1]) + \n            p2[:,0]*(p3[:,1]-p1[:,1]) + \n            p3[:,0]*(p1[:,1]-p2[:,1])\n        )\n\n    # Soft Energy function: sum of inverse squared areas\n    # Minimizing this maximizes the smallest areas and pushes points apart\n    def energy_func(flat_pts):\n        pts = flat_pts.reshape((N, 2))\n        areas = get_areas(pts)\n        # Add epsilon to prevent division by zero\n        return np.sum(1.0 / (areas**2 + 1e-12))\n\n    # Helper to clip a point to be inside the equilateral triangle\n    def clip_to_triangle(p):\n        x, y = p\n        \n        # Check if inside constraints: y >= 0, y <= sqrt(3)x, y <= sqrt(3)(1-x)\n        if y >= -1e-9 and y <= SQRT3 * x + 1e-9 and y <= SQRT3 * (1 - x) + 1e-9:\n            return p\n            \n        # If outside, project to the closest boundary segment\n        \n        # Segment 1: y=0, x in [0,1]\n        p1 = np.array([np.clip(x, 0, 1), 0])\n        d1 = np.sum((p - p1)**2)\n        \n        # Segment 2: y = sqrt(3)x. Line direction vector (0.5, sqrt(3)/2)\n        v2 = np.array([0.5, SQRT3/2])\n        t2 = np.dot(p, v2)\n        t2 = np.clip(t2, 0, 1)\n        p2 = t2 * v2\n        d2 = np.sum((p - p2)**2)\n        \n        # Segment 3: y = sqrt(3)(1-x). Line from (1,0) to (0.5, sqrt(3)/2)\n        origin3 = np.array([1.0, 0.0])\n        v3 = np.array([-0.5, SQRT3/2])\n        t3 = np.dot(p - origin3, v3)\n        t3 = np.clip(t3, 0, 1)\n        p3 = origin3 + t3 * v3\n        d3 = np.sum((p - p3)**2)\n        \n        # Return the point on the boundary with minimum distance\n        if d1 <= d2 and d1 <= d3: return p1\n        if d2 <= d3: return p2\n        return p3\n\n    # Initialize points randomly within the triangle\n    points = np.zeros((N, 2))\n    for i in range(N):\n        while True:\n            rx = random.random()\n            ry = random.random() * SQRT3/2\n            if ry <= SQRT3 * rx and ry <= SQRT3 * (1 - rx):\n                points[i] = [rx, ry]\n                break\n    \n    current_pts = points.copy()\n    current_E = energy_func(current_pts.flatten())\n    \n    best_pts = current_pts.copy()\n    best_min_area = np.min(get_areas(current_pts))\n    \n    # Simulated Annealing Parameters\n    iterations = 60000\n    \n    # Auto-calibrate initial temperature based on random perturbations\n    deltas = []\n    test_pts = current_pts.copy()\n    for _ in range(50):\n        idx = random.randint(0, N-1)\n        pert = np.random.randn(2) * 0.05\n        old = test_pts[idx].copy()\n        test_pts[idx] = clip_to_triangle(old + pert)\n        e_new = energy_func(test_pts.flatten())\n        deltas.append(abs(e_new - current_E))\n        test_pts[idx] = old\n    \n    avg_delta = np.mean(deltas) if deltas else 1000.0\n    if avg_delta == 0: avg_delta = 1000.0\n    \n    T_start = avg_delta * 1.0\n    T_end = T_start * 1e-6\n    alpha = (T_end / T_start) ** (1 / iterations)\n    \n    # Dynamic step size for perturbation\n    step_start = 0.15\n    step_end = 0.0005\n    step_decay = (step_end / step_start) ** (1 / iterations)\n    \n    T = T_start\n    step = step_start\n    \n    # SA Loop\n    for k in range(iterations):\n        # Select a random point\n        idx = random.randint(0, N-1)\n        old_pt = current_pts[idx].copy()\n        \n        # Perturb using Gaussian noise and clip to bounds\n        pert = np.random.randn(2) * step\n        new_pt = clip_to_triangle(old_pt + pert)\n        \n        current_pts[idx] = new_pt\n        new_E = energy_func(current_pts.flatten())\n        \n        delta = new_E - current_E\n        \n        # Metropolis criterion\n        if delta < 0 or random.random() < math.exp(-delta / T):\n            # Accept\n            # Check if this state is the best found so far (based on actual min area)\n            if delta < 0 or k % 100 == 0:\n                current_min = np.min(get_areas(current_pts))\n                if current_min > best_min_area:\n                    best_min_area = current_min\n                    best_pts = current_pts.copy()\n        else:\n            # Reject\n            current_pts[idx] = old_pt\n            \n        # Cool down\n        T *= alpha\n        step *= step_decay\n        \n    # Final Polish using Scipy's SLSQP optimizer\n    # This helps descend into the local minimum of the soft energy function\n    \n    # Define Linear Constraints for the triangle\n    A_mat = []\n    lb_vec = []\n    ub_vec = []\n    \n    for i in range(N):\n        # Constraint 1: y >= 0\n        row = np.zeros(2*N)\n        row[2*i+1] = 1\n        A_mat.append(row)\n        lb_vec.append(0)\n        ub_vec.append(np.inf)\n        \n        # Constraint 2: sqrt(3)x - y >= 0\n        row = np.zeros(2*N)\n        row[2*i] = SQRT3\n        row[2*i+1] = -1\n        A_mat.append(row)\n        lb_vec.append(0)\n        ub_vec.append(np.inf)\n        \n        # Constraint 3: -sqrt(3)x - y >= -sqrt(3)  (equivalent to y <= sqrt(3)(1-x))\n        row = np.zeros(2*N)\n        row[2*i] = -SQRT3\n        row[2*i+1] = -1\n        A_mat.append(row)\n        lb_vec.append(-SQRT3)\n        ub_vec.append(np.inf)\n        \n    constraints = LinearConstraint(np.array(A_mat), np.array(lb_vec), np.array(ub_vec))\n    \n    # Run optimizer starting from the best SA result\n    try:\n        res = minimize(energy_func, best_pts.flatten(), method='SLSQP', \n                       constraints=constraints, \n                       options={'maxiter': 1000, 'ftol': 1e-9})\n        polished_pts = res.x.reshape((N, 2))\n        \n        # Compare polished result with best SA result\n        polished_min = np.min(get_areas(polished_pts))\n        if polished_min > best_min_area:\n            return polished_pts\n    except:\n        pass\n        \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.25480157148589583,
    "min_area_normalized": 0.009307873347638407,
    "min_triangle_area": 0.004030427387131483,
    "eval_time": 1.9283652305603027,
    "error": null
  },
  "prompt": "Implement a Simulated Annealing algorithm to solve the Heilbronn triangle problem for n=11. Use the equilateral triangle vertices (0,0), (1,0), (0.5, sqrt(3)/2). Ensure points stay within bounds using the constraints: y >= 0, y <= sqrt(3)*x, and y <= sqrt(3)*(1-x). Focus on a cooling schedule that allows for fine-tuning in the final stages.",
  "response": "```python\nimport numpy as np\nimport math\nimport random\nfrom scipy.optimize import minimize, LinearConstraint\nfrom itertools import combinations\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Finds a configuration of 11 points inside an equilateral triangle (vertices (0,0), (1,0), (0.5, sqrt(3)/2))\n    that maximizes the minimum area of any triangle formed by three of the points.\n    Uses Simulated Annealing followed by a gradient-based polish.\n    \"\"\"\n    N = 11\n    SQRT3 = np.sqrt(3)\n    \n    # Precompute triplet indices for vectorized area calculation\n    tri_idx = np.array(list(combinations(range(N), 3)))\n    \n    # Function to calculate areas of all triangles formed by the points\n    def get_areas(pts):\n        # pts shape (N, 2)\n        p1 = pts[tri_idx[:, 0]]\n        p2 = pts[tri_idx[:, 1]]\n        p3 = pts[tri_idx[:, 2]]\n        # Area = 0.5 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|\n        return 0.5 * np.abs(\n            p1[:,0]*(p2[:,1]-p3[:,1]) + \n            p2[:,0]*(p3[:,1]-p1[:,1]) + \n            p3[:,0]*(p1[:,1]-p2[:,1])\n        )\n\n    # Soft Energy function: sum of inverse squared areas\n    # Minimizing this maximizes the smallest areas and pushes points apart\n    def energy_func(flat_pts):\n        pts = flat_pts.reshape((N, 2))\n        areas = get_areas(pts)\n        # Add epsilon to prevent division by zero\n        return np.sum(1.0 / (areas**2 + 1e-12))\n\n    # Helper to clip a point to be inside the equilateral triangle\n    def clip_to_triangle(p):\n        x, y = p\n        \n        # Check if inside constraints: y >= 0, y <= sqrt(3)x, y <= sqrt(3)(1-x)\n        if y >= -1e-9 and y <= SQRT3 * x + 1e-9 and y <= SQRT3 * (1 - x) + 1e-9:\n            return p\n            \n        # If outside, project to the closest boundary segment\n        \n        # Segment 1: y=0, x in [0,1]\n        p1 = np.array([np.clip(x, 0, 1), 0])\n        d1 = np.sum((p - p1)**2)\n        \n        # Segment 2: y = sqrt(3)x. Line direction vector (0.5, sqrt(3)/2)\n        v2 = np.array([0.5, SQRT3/2])\n        t2 = np.dot(p, v2)\n        t2 = np.clip(t2, 0, 1)\n        p2 = t2 * v2\n        d2 = np.sum((p - p2)**2)\n        \n        # Segment 3: y = sqrt(3)(1-x). Line from (1,0) to (0.5, sqrt(3)/2)\n        origin3 = np.array([1.0, 0.0])\n        v3 = np.array([-0.5, SQRT3/2])\n        t3 = np.dot(p - origin3, v3)\n        t3 = np.clip(t3, 0, 1)\n        p3 = origin3 + t3 * v3\n        d3 = np.sum((p - p3)**2)\n        \n        # Return the point on the boundary with minimum distance\n        if d1 <= d2 and d1 <= d3: return p1\n        if d2 <= d3: return p2\n        return p3\n\n    # Initialize points randomly within the triangle\n    points = np.zeros((N, 2))\n    for i in range(N):\n        while True:\n            rx = random.random()\n            ry = random.random() * SQRT3/2\n            if ry <= SQRT3 * rx and ry <= SQRT3 * (1 - rx):\n                points[i] = [rx, ry]\n                break\n    \n    current_pts = points.copy()\n    current_E = energy_func(current_pts.flatten())\n    \n    best_pts = current_pts.copy()\n    best_min_area = np.min(get_areas(current_pts))\n    \n    # Simulated Annealing Parameters\n    iterations = 60000\n    \n    # Auto-calibrate initial temperature based on random perturbations\n    deltas = []\n    test_pts = current_pts.copy()\n    for _ in range(50):\n        idx = random.randint(0, N-1)\n        pert = np.random.randn(2) * 0.05\n        old = test_pts[idx].copy()\n        test_pts[idx] = clip_to_triangle(old + pert)\n        e_new = energy_func(test_pts.flatten())\n        deltas.append(abs(e_new - current_E))\n        test_pts[idx] = old\n    \n    avg_delta = np.mean(deltas) if deltas else 1000.0\n    if avg_delta == 0: avg_delta = 1000.0\n    \n    T_start = avg_delta * 1.0\n    T_end = T_start * 1e-6\n    alpha = (T_end / T_start) ** (1 / iterations)\n    \n    # Dynamic step size for perturbation\n    step_start = 0.15\n    step_end = 0.0005\n    step_decay = (step_end / step_start) ** (1 / iterations)\n    \n    T = T_start\n    step = step_start\n    \n    # SA Loop\n    for k in range(iterations):\n        # Select a random point\n        idx = random.randint(0, N-1)\n        old_pt = current_pts[idx].copy()\n        \n        # Perturb using Gaussian noise and clip to bounds\n        pert = np.random.randn(2) * step\n        new_pt = clip_to_triangle(old_pt + pert)\n        \n        current_pts[idx] = new_pt\n        new_E = energy_func(current_pts.flatten())\n        \n        delta = new_E - current_E\n        \n        # Metropolis criterion\n        if delta < 0 or random.random() < math.exp(-delta / T):\n            # Accept\n            # Check if this state is the best found so far (based on actual min area)\n            if delta < 0 or k % 100 == 0:\n                current_min = np.min(get_areas(current_pts))\n                if current_min > best_min_area:\n                    best_min_area = current_min\n                    best_pts = current_pts.copy()\n        else:\n            # Reject\n            current_pts[idx] = old_pt\n            \n        # Cool down\n        T *= alpha\n        step *= step_decay\n        \n    # Final Polish using Scipy's SLSQP optimizer\n    # This helps descend into the local minimum of the soft energy function\n    \n    # Define Linear Constraints for the triangle\n    A_mat = []\n    lb_vec = []\n    ub_vec = []\n    \n    for i in range(N):\n        # Constraint 1: y >= 0\n        row = np.zeros(2*N)\n        row[2*i+1] = 1\n        A_mat.append(row)\n        lb_vec.append(0)\n        ub_vec.append(np.inf)\n        \n        # Constraint 2: sqrt(3)x - y >= 0\n        row = np.zeros(2*N)\n        row[2*i] = SQRT3\n        row[2*i+1] = -1\n        A_mat.append(row)\n        lb_vec.append(0)\n        ub_vec.append(np.inf)\n        \n        # Constraint 3: -sqrt(3)x - y >= -sqrt(3)  (equivalent to y <= sqrt(3)(1-x))\n        row = np.zeros(2*N)\n        row[2*i] = -SQRT3\n        row[2*i+1] = -1\n        A_mat.append(row)\n        lb_vec.append(-SQRT3)\n        ub_vec.append(np.inf)\n        \n    constraints = LinearConstraint(np.array(A_mat), np.array(lb_vec), np.array(ub_vec))\n    \n    # Run optimizer starting from the best SA result\n    try:\n        res = minimize(energy_func, best_pts.flatten(), method='SLSQP', \n                       constraints=constraints, \n                       options={'maxiter': 1000, 'ftol': 1e-9})\n        polished_pts = res.x.reshape((N, 2))\n        \n        # Compare polished result with best SA result\n        polished_min = np.min(get_areas(polished_pts))\n        if polished_min > best_min_area:\n            return polished_pts\n    except:\n        pass\n        \n    return best_pts\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T10:48:00.944598",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 293,
        "candidates_token_count": 2250,
        "thoughts_token_count": 15116
      },
      "response_text_len": 6601
    }
  }
}