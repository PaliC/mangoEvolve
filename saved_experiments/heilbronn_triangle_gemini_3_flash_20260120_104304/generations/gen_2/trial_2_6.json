{
  "trial_id": "trial_2_6",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport itertools\nimport time\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn triangle problem for 11 points in an equilateral triangle.\n    Uses sequential least squares programming (SLSQP) to maximize the minimum area\n    formed by any three points, with multiple random initializations.\n    \"\"\"\n    n = 11\n    # Height of an equilateral triangle with side length 1\n    h = np.sqrt(3) / 2\n    # Pre-calculate all possible triples of points\n    triples = np.array(list(itertools.combinations(range(n), 3)))\n    \n    def get_initial_points():\n        \"\"\"Generates a random initial configuration of points inside the triangle.\"\"\"\n        # Include the three vertices of the triangle as they are likely part of the optimal solution\n        pts = [[0.0, 0.0], [1.0, 0.0], [0.5, h]]\n        while len(pts) < n:\n            r1, r2 = np.random.rand(), np.random.rand()\n            if r1 + r2 > 1:\n                r1, r2 = 1 - r1, 1 - r2\n            # Map unit square random points to the equilateral triangle\n            x = r1 + 0.5 * r2\n            y = h * r2\n            pts.append([x, y])\n        return np.array(pts)\n\n    def area_constraints(vars, signs, triples, n):\n        \"\"\"Calculates the area of each triple, adjusted by its initial orientation sign.\"\"\"\n        pts = vars[:2*n].reshape((n, 2))\n        t = vars[2*n]\n        p1, p2, p3 = pts[triples[:, 0]], pts[triples[:, 1]], pts[triples[:, 2]]\n        # Vectorized signed area calculation\n        s_areas = 0.5 * ((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                         (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n        return signs * s_areas - t\n\n    def area_constraints_jac(vars, signs, triples, n):\n        \"\"\"Calculates the Jacobian of the area constraints.\"\"\"\n        pts = vars[:2*n].reshape((n, 2))\n        jac = np.zeros((len(triples), 2*n + 1))\n        p1, p2, p3 = pts[triples[:, 0]], pts[triples[:, 1]], pts[triples[:, 2]]\n        common = 0.5 * signs\n        \n        # Partial derivatives of the signed area formula\n        jac[np.arange(len(triples)), 2*triples[:, 0]] = common * (p2[:, 1] - p3[:, 1])\n        jac[np.arange(len(triples)), 2*triples[:, 0] + 1] = common * (p3[:, 0] - p2[:, 0])\n        jac[np.arange(len(triples)), 2*triples[:, 1]] = common * (p3[:, 1] - p1[:, 1])\n        jac[np.arange(len(triples)), 2*triples[:, 1] + 1] = common * (p1[:, 0] - p3[:, 0])\n        jac[np.arange(len(triples)), 2*triples[:, 2]] = common * (p1[:, 1] - p2[:, 1])\n        jac[np.arange(len(triples)), 2*triples[:, 2] + 1] = common * (p2[:, 0] - p1[:, 0])\n        jac[:, 2*n] = -1\n        return jac\n\n    def boundary_constraints(vars, n):\n        \"\"\"Ensures all points stay inside the triangle boundaries.\"\"\"\n        pts = vars[:2*n].reshape((n, 2))\n        x, y = pts[:, 0], pts[:, 1]\n        c1 = y  # y >= 0\n        c2 = np.sqrt(3) * x - y  # y <= sqrt(3)x\n        c3 = np.sqrt(3) * (1 - x) - y  # y <= sqrt(3)(1-x)\n        return np.concatenate([c1, c2, c3])\n\n    def boundary_constraints_jac(vars, n):\n        \"\"\"Calculates the Jacobian of the boundary constraints.\"\"\"\n        jac = np.zeros((3*n, 2*n + 1))\n        sq3 = np.sqrt(3)\n        for i in range(n):\n            jac[i, 2*i + 1] = 1\n            jac[n + i, 2*i] = sq3\n            jac[n + i, 2*i + 1] = -1\n            jac[2*n + i, 2*i] = -sq3\n            jac[2*n + i, 2*i + 1] = -1\n        return jac\n\n    start_time = time.time()\n    # Initial best configuration\n    best_pts = get_initial_points()\n    best_min_area = -1\n    \n    # Run optimization with random restarts until time limit is reached\n    while time.time() - start_time < 26:\n        initial_pts = get_initial_points()\n        p1, p2, p3 = initial_pts[triples[:, 0]], initial_pts[triples[:, 1]], initial_pts[triples[:, 2]]\n        s_areas = 0.5 * ((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                         (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n        # Determine the orientation of each triple for signed area constraint\n        signs = np.sign(s_areas)\n        signs[signs == 0] = 1\n        min_a = np.min(signs * s_areas)\n        \n        # Variables: [x0, y0, x1, y1, ..., x10, y10, t] where t is the minimum area\n        x0 = np.append(initial_pts.flatten(), min_a)\n        \n        res = minimize(\n            lambda x: -x[2*n], # Maximize t\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.append(np.zeros(2*n), -1.0),\n            constraints=[\n                {'type': 'ineq', 'fun': area_constraints, 'jac': area_constraints_jac, 'args': (signs, triples, n)},\n                {'type': 'ineq', 'fun': boundary_constraints, 'jac': boundary_constraints_jac, 'args': (n,)}\n            ],\n            bounds=[(0, 1)] * (2*n) + [(0, 1)],\n            options={'maxiter': 200}\n        )\n        \n        # Evaluate current result\n        current_pts = res.x[:2*n].reshape((n, 2))\n        p1, p2, p3 = current_pts[triples[:, 0]], current_pts[triples[:, 1]], current_pts[triples[:, 2]]\n        current_min_a = np.min(0.5 * np.abs((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                                           (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1])))\n        if current_min_a > best_min_area:\n            best_min_area = current_min_a\n            best_pts = current_pts\n                \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.7833332170022829,
    "min_area_normalized": 0.028615076156463158,
    "min_triangle_area": 0.012390691441361734,
    "eval_time": 26.278950214385986,
    "error": null
  },
  "prompt": "Heuristic 'Smart Mutation' optimization: Start with a random configuration. In each step, identify the triangle with the minimum area. Move one of its three vertices in a direction that increases the area (e.g., away from the opposite edge). Combine this with local optimization (SLSQP).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport itertools\nimport time\n\ndef heilbronn_triangle11():\n    \"\"\"\n    Solves the Heilbronn triangle problem for 11 points in an equilateral triangle.\n    Uses sequential least squares programming (SLSQP) to maximize the minimum area\n    formed by any three points, with multiple random initializations.\n    \"\"\"\n    n = 11\n    # Height of an equilateral triangle with side length 1\n    h = np.sqrt(3) / 2\n    # Pre-calculate all possible triples of points\n    triples = np.array(list(itertools.combinations(range(n), 3)))\n    \n    def get_initial_points():\n        \"\"\"Generates a random initial configuration of points inside the triangle.\"\"\"\n        # Include the three vertices of the triangle as they are likely part of the optimal solution\n        pts = [[0.0, 0.0], [1.0, 0.0], [0.5, h]]\n        while len(pts) < n:\n            r1, r2 = np.random.rand(), np.random.rand()\n            if r1 + r2 > 1:\n                r1, r2 = 1 - r1, 1 - r2\n            # Map unit square random points to the equilateral triangle\n            x = r1 + 0.5 * r2\n            y = h * r2\n            pts.append([x, y])\n        return np.array(pts)\n\n    def area_constraints(vars, signs, triples, n):\n        \"\"\"Calculates the area of each triple, adjusted by its initial orientation sign.\"\"\"\n        pts = vars[:2*n].reshape((n, 2))\n        t = vars[2*n]\n        p1, p2, p3 = pts[triples[:, 0]], pts[triples[:, 1]], pts[triples[:, 2]]\n        # Vectorized signed area calculation\n        s_areas = 0.5 * ((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                         (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n        return signs * s_areas - t\n\n    def area_constraints_jac(vars, signs, triples, n):\n        \"\"\"Calculates the Jacobian of the area constraints.\"\"\"\n        pts = vars[:2*n].reshape((n, 2))\n        jac = np.zeros((len(triples), 2*n + 1))\n        p1, p2, p3 = pts[triples[:, 0]], pts[triples[:, 1]], pts[triples[:, 2]]\n        common = 0.5 * signs\n        \n        # Partial derivatives of the signed area formula\n        jac[np.arange(len(triples)), 2*triples[:, 0]] = common * (p2[:, 1] - p3[:, 1])\n        jac[np.arange(len(triples)), 2*triples[:, 0] + 1] = common * (p3[:, 0] - p2[:, 0])\n        jac[np.arange(len(triples)), 2*triples[:, 1]] = common * (p3[:, 1] - p1[:, 1])\n        jac[np.arange(len(triples)), 2*triples[:, 1] + 1] = common * (p1[:, 0] - p3[:, 0])\n        jac[np.arange(len(triples)), 2*triples[:, 2]] = common * (p1[:, 1] - p2[:, 1])\n        jac[np.arange(len(triples)), 2*triples[:, 2] + 1] = common * (p2[:, 0] - p1[:, 0])\n        jac[:, 2*n] = -1\n        return jac\n\n    def boundary_constraints(vars, n):\n        \"\"\"Ensures all points stay inside the triangle boundaries.\"\"\"\n        pts = vars[:2*n].reshape((n, 2))\n        x, y = pts[:, 0], pts[:, 1]\n        c1 = y  # y >= 0\n        c2 = np.sqrt(3) * x - y  # y <= sqrt(3)x\n        c3 = np.sqrt(3) * (1 - x) - y  # y <= sqrt(3)(1-x)\n        return np.concatenate([c1, c2, c3])\n\n    def boundary_constraints_jac(vars, n):\n        \"\"\"Calculates the Jacobian of the boundary constraints.\"\"\"\n        jac = np.zeros((3*n, 2*n + 1))\n        sq3 = np.sqrt(3)\n        for i in range(n):\n            jac[i, 2*i + 1] = 1\n            jac[n + i, 2*i] = sq3\n            jac[n + i, 2*i + 1] = -1\n            jac[2*n + i, 2*i] = -sq3\n            jac[2*n + i, 2*i + 1] = -1\n        return jac\n\n    start_time = time.time()\n    # Initial best configuration\n    best_pts = get_initial_points()\n    best_min_area = -1\n    \n    # Run optimization with random restarts until time limit is reached\n    while time.time() - start_time < 26:\n        initial_pts = get_initial_points()\n        p1, p2, p3 = initial_pts[triples[:, 0]], initial_pts[triples[:, 1]], initial_pts[triples[:, 2]]\n        s_areas = 0.5 * ((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                         (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1]))\n        # Determine the orientation of each triple for signed area constraint\n        signs = np.sign(s_areas)\n        signs[signs == 0] = 1\n        min_a = np.min(signs * s_areas)\n        \n        # Variables: [x0, y0, x1, y1, ..., x10, y10, t] where t is the minimum area\n        x0 = np.append(initial_pts.flatten(), min_a)\n        \n        res = minimize(\n            lambda x: -x[2*n], # Maximize t\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.append(np.zeros(2*n), -1.0),\n            constraints=[\n                {'type': 'ineq', 'fun': area_constraints, 'jac': area_constraints_jac, 'args': (signs, triples, n)},\n                {'type': 'ineq', 'fun': boundary_constraints, 'jac': boundary_constraints_jac, 'args': (n,)}\n            ],\n            bounds=[(0, 1)] * (2*n) + [(0, 1)],\n            options={'maxiter': 200}\n        )\n        \n        # Evaluate current result\n        current_pts = res.x[:2*n].reshape((n, 2))\n        p1, p2, p3 = current_pts[triples[:, 0]], current_pts[triples[:, 1]], current_pts[triples[:, 2]]\n        current_min_a = np.min(0.5 * np.abs((p2[:, 0] - p1[:, 0]) * (p3[:, 1] - p1[:, 1]) - \n                                           (p3[:, 0] - p1[:, 0]) * (p2[:, 1] - p1[:, 1])))\n        if current_min_a > best_min_area:\n            best_min_area = current_min_a\n            best_pts = current_pts\n                \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-20T11:03:05.151584",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 258,
        "candidates_token_count": 1893,
        "thoughts_token_count": 23549
      },
      "response_text_len": 5374
    }
  }
}