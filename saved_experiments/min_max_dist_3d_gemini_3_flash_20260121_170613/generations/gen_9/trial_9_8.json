{
  "trial_id": "trial_9_8",
  "generation": 9,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the squared ratio\n    (min pairwise distance / max pairwise distance)^2.\n    \"\"\"\n    n = 14\n    iu = np.triu_indices(n, k=1)\n\n    def get_seeds():\n        seeds = []\n        # 1. Bicapped Hexagonal Antiprism\n        # This is a very strong candidate for the optimal configuration.\n        p1 = []\n        h, H = 0.4278, 1.0\n        for i in range(6):\n            a1 = i * np.pi / 3\n            p1.append([np.cos(a1), np.sin(a1), h])\n            a2 = i * np.pi / 3 + np.pi / 6\n            p1.append([np.cos(a2), np.sin(a2), -h])\n        p1.append([0, 0, H])\n        p1.append([0, 0, -H])\n        seeds.append(np.array(p1))\n\n        # 2. Rhombic Dodecahedron (Cube + Octahedron)\n        p2 = []\n        for x in [-1, 1]:\n            for y in [-1, 1]:\n                for z in [-1, 1]:\n                    p2.append([x, y, z])\n        p2.extend([[1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]])\n        seeds.append(np.array(p2))\n\n        # 3. Icosahedron + 2 points\n        # Start from a high-symmetry 12-point configuration and add two points.\n        phi = (1 + np.sqrt(5)) / 2\n        p3 = [[-1, phi, 0], [1, phi, 0], [-1, -phi, 0], [1, -phi, 0],\n              [0, -1, phi], [0, 1, phi], [0, -1, -phi], [0, 1, -phi],\n              [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]]\n        p3.extend([[0, 0, 0], [0, 0, 2]])\n        seeds.append(np.array(p3))\n\n        # 4. Random seeds\n        # Provides variety to ensure the optimizer doesn't get stuck in poor local optima.\n        np.random.seed(42)\n        for _ in range(3):\n            seeds.append(np.random.uniform(-1, 1, (n, 3)))\n        return seeds\n\n    def obj(x):\n        # Maximize z by minimizing -z\n        return -x[42]\n\n    def cons(x):\n        # Constraints:\n        # d_ij^2 >= z (min distance squared bound)\n        # d_ij^2 <= 1.0 (normalization of max distance squared)\n        p = x[:42].reshape((n, 3))\n        z = x[42]\n        # Efficient pairwise distance calculation\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)[iu]\n        return np.concatenate([d2 - z, 1.0 - d2])\n\n    def repulsion_obj(p_flat):\n        # Smooth repulsion objective to spread points before SLSQP refinement.\n        p = p_flat.reshape((n, 3))\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)[iu]\n        return np.sum(1.0 / (d2 + 1e-8)**3)\n\n    best_p = None\n    best_r_sq = -1\n\n    for s in get_seeds():\n        # Pre-optimization with repulsion for random seeds\n        if np.any(np.abs(s) < 2.0): # Simple check for non-structured seeds\n            res_rep = minimize(repulsion_obj, s.flatten(), method='L-BFGS-B', options={'maxiter': 30})\n            s = res_rep.x.reshape((n, 3))\n\n        # Initial normalization: set max distance squared to 1.0\n        diff_s = s[:, np.newaxis, :] - s[np.newaxis, :, :]\n        d2_s = np.sum(diff_s**2, axis=-1)[iu]\n        s = s / np.sqrt(np.max(d2_s))\n        \n        # Prepare initial vector for SLSQP: [points_flattened, initial_z]\n        x0 = np.zeros(43)\n        x0[:42] = s.flatten()\n        d2_s_norm = np.sum((s[:, np.newaxis, :] - s[np.newaxis, :, :])**2, axis=-1)[iu]\n        x0[42] = np.min(d2_s_norm)\n        \n        # Refine using SLSQP\n        res = minimize(obj, x0, constraints={'type': 'ineq', 'fun': cons}, method='SLSQP', options={'maxiter': 60})\n        \n        # Extract best configuration from this seed\n        p_opt = res.x[:42].reshape((n, 3))\n        diff_opt = p_opt[:, np.newaxis, :] - p_opt[np.newaxis, :, :]\n        d2_opt = np.sum(diff_opt**2, axis=-1)[iu]\n        r_sq = np.min(d2_opt) / np.max(d2_opt)\n        \n        if r_sq > best_r_sq:\n            best_r_sq = r_sq\n            best_p = p_opt\n            \n    return best_p",
  "metrics": {
    "valid": true,
    "score": 0.9970225396540391,
    "min_max_ratio": 0.23933233203751275,
    "min_distance": 0.4892160467587944,
    "max_distance": 1.0000000174836179,
    "eval_time": 0.3941507339477539,
    "error": null
  },
  "prompt": "Explore the possibility that the optimal 14-point configuration is NOT the Bicapped Hexagonal Antiprism. Try starting from: 1. An Icosahedron (12) + 2 points. 2. A Cube (8) + 6 points on faces. 3. A Pentagonal Prism (10) + 4 points. Optimize each using SLSQP.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the squared ratio\n    (min pairwise distance / max pairwise distance)^2.\n    \"\"\"\n    n = 14\n    iu = np.triu_indices(n, k=1)\n\n    def get_seeds():\n        seeds = []\n        # 1. Bicapped Hexagonal Antiprism\n        # This is a very strong candidate for the optimal configuration.\n        p1 = []\n        h, H = 0.4278, 1.0\n        for i in range(6):\n            a1 = i * np.pi / 3\n            p1.append([np.cos(a1), np.sin(a1), h])\n            a2 = i * np.pi / 3 + np.pi / 6\n            p1.append([np.cos(a2), np.sin(a2), -h])\n        p1.append([0, 0, H])\n        p1.append([0, 0, -H])\n        seeds.append(np.array(p1))\n\n        # 2. Rhombic Dodecahedron (Cube + Octahedron)\n        p2 = []\n        for x in [-1, 1]:\n            for y in [-1, 1]:\n                for z in [-1, 1]:\n                    p2.append([x, y, z])\n        p2.extend([[1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]])\n        seeds.append(np.array(p2))\n\n        # 3. Icosahedron + 2 points\n        # Start from a high-symmetry 12-point configuration and add two points.\n        phi = (1 + np.sqrt(5)) / 2\n        p3 = [[-1, phi, 0], [1, phi, 0], [-1, -phi, 0], [1, -phi, 0],\n              [0, -1, phi], [0, 1, phi], [0, -1, -phi], [0, 1, -phi],\n              [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]]\n        p3.extend([[0, 0, 0], [0, 0, 2]])\n        seeds.append(np.array(p3))\n\n        # 4. Random seeds\n        # Provides variety to ensure the optimizer doesn't get stuck in poor local optima.\n        np.random.seed(42)\n        for _ in range(3):\n            seeds.append(np.random.uniform(-1, 1, (n, 3)))\n        return seeds\n\n    def obj(x):\n        # Maximize z by minimizing -z\n        return -x[42]\n\n    def cons(x):\n        # Constraints:\n        # d_ij^2 >= z (min distance squared bound)\n        # d_ij^2 <= 1.0 (normalization of max distance squared)\n        p = x[:42].reshape((n, 3))\n        z = x[42]\n        # Efficient pairwise distance calculation\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)[iu]\n        return np.concatenate([d2 - z, 1.0 - d2])\n\n    def repulsion_obj(p_flat):\n        # Smooth repulsion objective to spread points before SLSQP refinement.\n        p = p_flat.reshape((n, 3))\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)[iu]\n        return np.sum(1.0 / (d2 + 1e-8)**3)\n\n    best_p = None\n    best_r_sq = -1\n\n    for s in get_seeds():\n        # Pre-optimization with repulsion for random seeds\n        if np.any(np.abs(s) < 2.0): # Simple check for non-structured seeds\n            res_rep = minimize(repulsion_obj, s.flatten(), method='L-BFGS-B', options={'maxiter': 30})\n            s = res_rep.x.reshape((n, 3))\n\n        # Initial normalization: set max distance squared to 1.0\n        diff_s = s[:, np.newaxis, :] - s[np.newaxis, :, :]\n        d2_s = np.sum(diff_s**2, axis=-1)[iu]\n        s = s / np.sqrt(np.max(d2_s))\n        \n        # Prepare initial vector for SLSQP: [points_flattened, initial_z]\n        x0 = np.zeros(43)\n        x0[:42] = s.flatten()\n        d2_s_norm = np.sum((s[:, np.newaxis, :] - s[np.newaxis, :, :])**2, axis=-1)[iu]\n        x0[42] = np.min(d2_s_norm)\n        \n        # Refine using SLSQP\n        res = minimize(obj, x0, constraints={'type': 'ineq', 'fun': cons}, method='SLSQP', options={'maxiter': 60})\n        \n        # Extract best configuration from this seed\n        p_opt = res.x[:42].reshape((n, 3))\n        diff_opt = p_opt[:, np.newaxis, :] - p_opt[np.newaxis, :, :]\n        d2_opt = np.sum(diff_opt**2, axis=-1)[iu]\n        r_sq = np.min(d2_opt) / np.max(d2_opt)\n        \n        if r_sq > best_r_sq:\n            best_r_sq = r_sq\n            best_p = p_opt\n            \n    return best_p\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:00:07.102087",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 252,
        "candidates_token_count": 1493,
        "thoughts_token_count": 21720
      },
      "response_text_len": 3962
    }
  }
}