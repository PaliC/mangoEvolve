{
  "trial_id": "trial_9_9",
  "generation": 9,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The method uses Basin-hopping with a smooth soft-min-max objective and its analytical Jacobian.\n    \"\"\"\n    \n    def get_dist_sqs(pts):\n        \"\"\"Calculates all pairwise squared distances for a set of points.\"\"\"\n        n = pts.shape[0]\n        dists = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = pts[i] - pts[j]\n                dists.append(np.dot(diff, diff))\n        return np.array(dists)\n\n    def objective(x, p):\n        \"\"\"Smooth approximation of (max_dist_sq / min_dist_sq) using generalized means.\"\"\"\n        pts = x.reshape((14, 3))\n        dists = get_dist_sqs(pts)\n        # s_max = (sum dist_sq^p)^(1/p)\n        # s_min = (sum dist_sq^-p)^(-1/p)\n        # These approximate the max and min of the squared distances respectively.\n        s_max = (np.sum(dists**p))**(1/p)\n        s_min = (np.sum(dists**(-p)))**(-1/p)\n        return s_max / s_min\n\n    def jacobian(x, p):\n        \"\"\"Analytical Jacobian of the soft-min-max ratio objective.\"\"\"\n        pts = x.reshape((14, 3))\n        n = 14\n        dists = []\n        diffs = []\n        pairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = pts[i] - pts[j]\n                diffs.append(diff)\n                dists.append(np.dot(diff, diff))\n                pairs.append((i, j))\n        \n        dists = np.array(dists)\n        s_max = (np.sum(dists**p))**(1/p)\n        s_min = (np.sum(dists**(-p)))**(-1/p)\n        \n        # Derivatives of s_max and s_min with respect to the squared distances\n        common_max = s_max**(1 - p)\n        common_min = s_min**(1 + p)\n        \n        grad = np.zeros((14, 3))\n        for k in range(len(dists)):\n            i, j = pairs[k]\n            d_sq = dists[k]\n            diff = diffs[k]\n            \n            # Chain rule: d(ratio)/d(pts) = d(ratio)/d(dists) * d(dists)/d(pts)\n            g_max = common_max * (d_sq**(p-1))\n            g_min = common_min * (d_sq**(-p-1))\n            \n            # d(f)/d(d_sq) = (s_min * g_max - s_max * g_min) / s_min^2\n            term = (s_min * g_max - s_max * g_min) / (s_min**2)\n            \n            # d(d_sq)/d(pts[i]) = 2 * (pts[i] - pts[j])\n            grad[i] += 2 * term * diff\n            grad[j] -= 2 * term * diff\n            \n        return grad.flatten()\n\n    # Reproducibility\n    np.random.seed(0)\n    \n    # Initialize several promising seeds\n    seeds = []\n    \n    # Seed 1: Cube vertices and face centers\n    a = 1.4\n    cube_pts = np.array([\n        [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1],\n        [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1],\n        [a,0,0], [-a,0,0], [0,a,0], [0,-a,0], [0,0,a], [0,0,-a]\n    ], dtype=float)\n    seeds.append(cube_pts.flatten())\n    \n    # Seed 2: Hexagonal antiprism with two caps\n    h, H, R = 0.5, 1.2, 1.0\n    hex_pts = []\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        hex_pts.append([R*np.cos(angle), R*np.sin(angle), h])\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi / 6\n        hex_pts.append([R*np.cos(angle), R*np.sin(angle), -h])\n    hex_pts.append([0, 0, H])\n    hex_pts.append([0, 0, -H])\n    seeds.append(np.array(hex_pts).flatten())\n    \n    # Seed 3: Regular icosahedron vertices plus two axial points\n    phi = (1 + 5**0.5) / 2\n    ico_pts = []\n    for s1 in [-1, 1]:\n        for s2 in [-1/phi, 1/phi]:\n            ico_pts.append([0, s1, s2])\n            ico_pts.append([s2, 0, s1])\n            ico_pts.append([s1, s2, 0])\n    ico_pts = np.array(ico_pts)\n    c = 1.2 # Slightly offset from the center\n    ico_pts = np.vstack([ico_pts, [0, 0, c], [0, 0, -c]])\n    seeds.append(ico_pts.flatten())\n    \n    # Seed 4: Random initial points\n    seeds.append(np.random.uniform(-1, 1, 42))\n\n    best_pts = None\n    best_ratio_sq = -1\n\n    # Optimization loop\n    for x0 in seeds:\n        # Initial local refinement\n        res = minimize(objective, x0, jac=jacobian, method='L-BFGS-B', args=(15,))\n        # Global refinement using Basin-hopping\n        res = basinhopping(\n            objective, res.x, \n            minimizer_kwargs={\"jac\": jacobian, \"method\": \"L-BFGS-B\", \"args\": (20,)},\n            niter=30, T=0.0001, stepsize=0.001\n        )\n        \n        pts = res.x.reshape((14, 3))\n        dists = get_dist_sqs(pts)\n        ratio_sq = np.min(dists) / np.max(dists)\n        \n        if ratio_sq > best_ratio_sq:\n            best_ratio_sq = ratio_sq\n            best_pts = pts\n\n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9643503161017822,
    "min_max_ratio": 0.23148946074362414,
    "min_distance": 1.0845412075176957,
    "max_distance": 2.2541377189936393,
    "eval_time": 1.0225791931152344,
    "error": null
  },
  "prompt": "Refine the best known solution trial_8_0 using Basin-hopping with a very low temperature and tiny step size. Focus on the analytical Jacobian. Variation 0",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The method uses Basin-hopping with a smooth soft-min-max objective and its analytical Jacobian.\n    \"\"\"\n    \n    def get_dist_sqs(pts):\n        \"\"\"Calculates all pairwise squared distances for a set of points.\"\"\"\n        n = pts.shape[0]\n        dists = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = pts[i] - pts[j]\n                dists.append(np.dot(diff, diff))\n        return np.array(dists)\n\n    def objective(x, p):\n        \"\"\"Smooth approximation of (max_dist_sq / min_dist_sq) using generalized means.\"\"\"\n        pts = x.reshape((14, 3))\n        dists = get_dist_sqs(pts)\n        # s_max = (sum dist_sq^p)^(1/p)\n        # s_min = (sum dist_sq^-p)^(-1/p)\n        # These approximate the max and min of the squared distances respectively.\n        s_max = (np.sum(dists**p))**(1/p)\n        s_min = (np.sum(dists**(-p)))**(-1/p)\n        return s_max / s_min\n\n    def jacobian(x, p):\n        \"\"\"Analytical Jacobian of the soft-min-max ratio objective.\"\"\"\n        pts = x.reshape((14, 3))\n        n = 14\n        dists = []\n        diffs = []\n        pairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = pts[i] - pts[j]\n                diffs.append(diff)\n                dists.append(np.dot(diff, diff))\n                pairs.append((i, j))\n        \n        dists = np.array(dists)\n        s_max = (np.sum(dists**p))**(1/p)\n        s_min = (np.sum(dists**(-p)))**(-1/p)\n        \n        # Derivatives of s_max and s_min with respect to the squared distances\n        common_max = s_max**(1 - p)\n        common_min = s_min**(1 + p)\n        \n        grad = np.zeros((14, 3))\n        for k in range(len(dists)):\n            i, j = pairs[k]\n            d_sq = dists[k]\n            diff = diffs[k]\n            \n            # Chain rule: d(ratio)/d(pts) = d(ratio)/d(dists) * d(dists)/d(pts)\n            g_max = common_max * (d_sq**(p-1))\n            g_min = common_min * (d_sq**(-p-1))\n            \n            # d(f)/d(d_sq) = (s_min * g_max - s_max * g_min) / s_min^2\n            term = (s_min * g_max - s_max * g_min) / (s_min**2)\n            \n            # d(d_sq)/d(pts[i]) = 2 * (pts[i] - pts[j])\n            grad[i] += 2 * term * diff\n            grad[j] -= 2 * term * diff\n            \n        return grad.flatten()\n\n    # Reproducibility\n    np.random.seed(0)\n    \n    # Initialize several promising seeds\n    seeds = []\n    \n    # Seed 1: Cube vertices and face centers\n    a = 1.4\n    cube_pts = np.array([\n        [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1],\n        [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1],\n        [a,0,0], [-a,0,0], [0,a,0], [0,-a,0], [0,0,a], [0,0,-a]\n    ], dtype=float)\n    seeds.append(cube_pts.flatten())\n    \n    # Seed 2: Hexagonal antiprism with two caps\n    h, H, R = 0.5, 1.2, 1.0\n    hex_pts = []\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        hex_pts.append([R*np.cos(angle), R*np.sin(angle), h])\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi / 6\n        hex_pts.append([R*np.cos(angle), R*np.sin(angle), -h])\n    hex_pts.append([0, 0, H])\n    hex_pts.append([0, 0, -H])\n    seeds.append(np.array(hex_pts).flatten())\n    \n    # Seed 3: Regular icosahedron vertices plus two axial points\n    phi = (1 + 5**0.5) / 2\n    ico_pts = []\n    for s1 in [-1, 1]:\n        for s2 in [-1/phi, 1/phi]:\n            ico_pts.append([0, s1, s2])\n            ico_pts.append([s2, 0, s1])\n            ico_pts.append([s1, s2, 0])\n    ico_pts = np.array(ico_pts)\n    c = 1.2 # Slightly offset from the center\n    ico_pts = np.vstack([ico_pts, [0, 0, c], [0, 0, -c]])\n    seeds.append(ico_pts.flatten())\n    \n    # Seed 4: Random initial points\n    seeds.append(np.random.uniform(-1, 1, 42))\n\n    best_pts = None\n    best_ratio_sq = -1\n\n    # Optimization loop\n    for x0 in seeds:\n        # Initial local refinement\n        res = minimize(objective, x0, jac=jacobian, method='L-BFGS-B', args=(15,))\n        # Global refinement using Basin-hopping\n        res = basinhopping(\n            objective, res.x, \n            minimizer_kwargs={\"jac\": jacobian, \"method\": \"L-BFGS-B\", \"args\": (20,)},\n            niter=30, T=0.0001, stepsize=0.001\n        )\n        \n        pts = res.x.reshape((14, 3))\n        dists = get_dist_sqs(pts)\n        ratio_sq = np.min(dists) / np.max(dists)\n        \n        if ratio_sq > best_ratio_sq:\n            best_ratio_sq = ratio_sq\n            best_pts = pts\n\n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:00:51.276241",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 206,
        "candidates_token_count": 1722,
        "thoughts_token_count": 28283
      },
      "response_text_len": 4688
    }
  }
}