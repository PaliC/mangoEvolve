{
  "trial_id": "trial_9_2",
  "generation": 9,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the ratio \n    (min pairwise distance / max pairwise distance)^2.\n    The approach uses a smooth approximation of the max and min distances \n    with a log-sum-exp formulation and optimizes the ratio using L-BFGS-B.\n    \"\"\"\n    N = 14\n    \n    def get_objective_and_grad(x, k, penalty_weight):\n        p = x.reshape((N, 3))\n        # Vectorized distance calculation\n        dists = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        dist_sq = np.sum(dists**2, axis=-1)\n        idx = np.triu_indices(N, k=1)\n        d2 = dist_sq[idx]\n        \n        # Smooth max using log-sum-exp trick for numerical stability\n        max_d2 = np.max(d2)\n        exp_max = np.exp(k * (d2 - max_d2))\n        sum_exp_max = np.sum(exp_max)\n        s_max = max_d2 + np.log(sum_exp_max) / k\n        w_max = exp_max / sum_exp_max\n        \n        # Smooth min using log-sum-exp trick\n        min_d2 = np.min(d2)\n        exp_min = np.exp(-k * (d2 - min_d2))\n        sum_exp_min = np.sum(exp_min)\n        s_min = min_d2 - np.log(sum_exp_min) / k\n        w_min = exp_min / sum_exp_min\n        \n        # Reconstruct full symmetric weight matrices for vectorized gradient\n        w_max_full = np.zeros((N, N))\n        w_max_full[idx] = w_max\n        w_max_full = w_max_full + w_max_full.T\n        \n        w_min_full = np.zeros((N, N))\n        w_min_full[idx] = w_min\n        w_min_full = w_min_full + w_min_full.T\n        \n        # Compute gradients of s_max and s_min w.r.t. points p\n        # grad_s_i = 2 * sum_j w_ij * (p_i - p_j)\n        grad_s_max_p = 2 * (p * np.sum(w_max_full, axis=1)[:, np.newaxis] - w_max_full @ p)\n        grad_s_min_p = 2 * (p * np.sum(w_min_full, axis=1)[:, np.newaxis] - w_min_full @ p)\n        \n        # Objective: minimize s_max / s_min (equivalent to maximizing s_min / s_max)\n        ratio = s_max / s_min\n        grad_ratio = (s_min * grad_s_max_p - s_max * grad_s_min_p) / (s_min**2)\n        \n        # Small penalty to keep points centered and avoid scale drift\n        obj = ratio + penalty_weight * np.sum(p**2)\n        grad = grad_ratio + 2 * penalty_weight * p\n        \n        return obj, grad.flatten()\n\n    best_pts = None\n    best_ratio_sq = -1\n\n    # Generate a set of starting configurations\n    seeds = []\n    \n    # 1. Fibonacci spiral on a sphere\n    phi_const = np.pi * (3. - np.sqrt(5.))\n    fib = []\n    for i in range(N):\n        y = 1 - (i / float(N - 1)) * 2\n        r = np.sqrt(max(0, 1 - y * y))\n        fib.append([r * np.cos(phi_const * i), y, r * np.sin(phi_const * i)])\n    seeds.append(np.array(fib))\n    \n    # 2. Rhombic dodecahedron (8 cube vertices + 6 octahedron vertices)\n    rd = [[1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1], [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1],\n          [1.7,0,0], [-1.7,0,0], [0,1.7,0], [0,-1.7,0], [0,0,1.7], [0,0,-1.7]]\n    seeds.append(np.array(rd))\n    \n    # 3. FCC-like cluster (cuboctahedron + center + one extra point)\n    fcc = [[0,0,0], [1,1,0], [1,-1,0], [-1,1,0], [-1,-1,0], [1,0,1], [1,0,-1], \n           [-1,0,1], [-1,0,-1], [0,1,1], [0,1,-1], [0,-1,1], [0,-1,-1], [2,0,0]]\n    seeds.append(np.array(fcc))\n    \n    # 4. Random starts\n    np.random.seed(42)\n    for _ in range(35):\n        seeds.append(np.random.normal(0, 1, (N, 3)))\n\n    # Optimization loop\n    for x0 in seeds:\n        # Initial optimization with moderate smoothness k\n        res = minimize(get_objective_and_grad, x0.flatten(), args=(25, 0.005), \n                       jac=True, method='L-BFGS-B', options={'maxiter': 80})\n        \n        curr_pts = res.x.reshape((N, 3))\n        dists = curr_pts[:, np.newaxis, :] - curr_pts[np.newaxis, :, :]\n        d2 = np.sum(dists**2, axis=-1)[np.triu_indices(N, k=1)]\n        curr_ratio_sq = np.min(d2) / np.max(d2)\n        \n        if curr_ratio_sq > best_ratio_sq:\n            best_ratio_sq = curr_ratio_sq\n            best_pts = curr_pts\n\n    # Final polish of the best configuration with high smoothness k and minimal penalty\n    res = minimize(get_objective_and_grad, best_pts.flatten(), args=(60, 1e-7), \n                   jac=True, method='L-BFGS-B', options={'maxiter': 200})\n    best_pts = res.x.reshape((N, 3))\n    \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9868045512719344,
    "min_max_ratio": 0.2368795339402201,
    "min_distance": 20.67292358574665,
    "max_distance": 42.47546376535959,
    "eval_time": 0.4597141742706299,
    "error": null
  },
  "prompt": "For 14 points in 3D, the optimal max-min distance ratio might come from a configuration related to the snub cube or other Archimedean solids, but slightly distorted. Try an optimization starting from a snub cube (24 vertices, pick a subset of 14) or a hexagonal prism with caps. Use SLSQP with analytical Jacobians.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the ratio \n    (min pairwise distance / max pairwise distance)^2.\n    The approach uses a smooth approximation of the max and min distances \n    with a log-sum-exp formulation and optimizes the ratio using L-BFGS-B.\n    \"\"\"\n    N = 14\n    \n    def get_objective_and_grad(x, k, penalty_weight):\n        p = x.reshape((N, 3))\n        # Vectorized distance calculation\n        dists = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        dist_sq = np.sum(dists**2, axis=-1)\n        idx = np.triu_indices(N, k=1)\n        d2 = dist_sq[idx]\n        \n        # Smooth max using log-sum-exp trick for numerical stability\n        max_d2 = np.max(d2)\n        exp_max = np.exp(k * (d2 - max_d2))\n        sum_exp_max = np.sum(exp_max)\n        s_max = max_d2 + np.log(sum_exp_max) / k\n        w_max = exp_max / sum_exp_max\n        \n        # Smooth min using log-sum-exp trick\n        min_d2 = np.min(d2)\n        exp_min = np.exp(-k * (d2 - min_d2))\n        sum_exp_min = np.sum(exp_min)\n        s_min = min_d2 - np.log(sum_exp_min) / k\n        w_min = exp_min / sum_exp_min\n        \n        # Reconstruct full symmetric weight matrices for vectorized gradient\n        w_max_full = np.zeros((N, N))\n        w_max_full[idx] = w_max\n        w_max_full = w_max_full + w_max_full.T\n        \n        w_min_full = np.zeros((N, N))\n        w_min_full[idx] = w_min\n        w_min_full = w_min_full + w_min_full.T\n        \n        # Compute gradients of s_max and s_min w.r.t. points p\n        # grad_s_i = 2 * sum_j w_ij * (p_i - p_j)\n        grad_s_max_p = 2 * (p * np.sum(w_max_full, axis=1)[:, np.newaxis] - w_max_full @ p)\n        grad_s_min_p = 2 * (p * np.sum(w_min_full, axis=1)[:, np.newaxis] - w_min_full @ p)\n        \n        # Objective: minimize s_max / s_min (equivalent to maximizing s_min / s_max)\n        ratio = s_max / s_min\n        grad_ratio = (s_min * grad_s_max_p - s_max * grad_s_min_p) / (s_min**2)\n        \n        # Small penalty to keep points centered and avoid scale drift\n        obj = ratio + penalty_weight * np.sum(p**2)\n        grad = grad_ratio + 2 * penalty_weight * p\n        \n        return obj, grad.flatten()\n\n    best_pts = None\n    best_ratio_sq = -1\n\n    # Generate a set of starting configurations\n    seeds = []\n    \n    # 1. Fibonacci spiral on a sphere\n    phi_const = np.pi * (3. - np.sqrt(5.))\n    fib = []\n    for i in range(N):\n        y = 1 - (i / float(N - 1)) * 2\n        r = np.sqrt(max(0, 1 - y * y))\n        fib.append([r * np.cos(phi_const * i), y, r * np.sin(phi_const * i)])\n    seeds.append(np.array(fib))\n    \n    # 2. Rhombic dodecahedron (8 cube vertices + 6 octahedron vertices)\n    rd = [[1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1], [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1],\n          [1.7,0,0], [-1.7,0,0], [0,1.7,0], [0,-1.7,0], [0,0,1.7], [0,0,-1.7]]\n    seeds.append(np.array(rd))\n    \n    # 3. FCC-like cluster (cuboctahedron + center + one extra point)\n    fcc = [[0,0,0], [1,1,0], [1,-1,0], [-1,1,0], [-1,-1,0], [1,0,1], [1,0,-1], \n           [-1,0,1], [-1,0,-1], [0,1,1], [0,1,-1], [0,-1,1], [0,-1,-1], [2,0,0]]\n    seeds.append(np.array(fcc))\n    \n    # 4. Random starts\n    np.random.seed(42)\n    for _ in range(35):\n        seeds.append(np.random.normal(0, 1, (N, 3)))\n\n    # Optimization loop\n    for x0 in seeds:\n        # Initial optimization with moderate smoothness k\n        res = minimize(get_objective_and_grad, x0.flatten(), args=(25, 0.005), \n                       jac=True, method='L-BFGS-B', options={'maxiter': 80})\n        \n        curr_pts = res.x.reshape((N, 3))\n        dists = curr_pts[:, np.newaxis, :] - curr_pts[np.newaxis, :, :]\n        d2 = np.sum(dists**2, axis=-1)[np.triu_indices(N, k=1)]\n        curr_ratio_sq = np.min(d2) / np.max(d2)\n        \n        if curr_ratio_sq > best_ratio_sq:\n            best_ratio_sq = curr_ratio_sq\n            best_pts = curr_pts\n\n    # Final polish of the best configuration with high smoothness k and minimal penalty\n    res = minimize(get_objective_and_grad, best_pts.flatten(), args=(60, 1e-7), \n                   jac=True, method='L-BFGS-B', options={'maxiter': 200})\n    best_pts = res.x.reshape((N, 3))\n    \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:57:30.847314",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 246,
        "candidates_token_count": 1654,
        "thoughts_token_count": 23973
      },
      "response_text_len": 4315
    }
  }
}