{
  "trial_id": "trial_9_0",
  "generation": 9,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Calculates the 14 points in 3D space that maximize the squared ratio \n    (min_dist / max_dist)^2, enforcing D6d symmetry (Bicapped Hexagonal Antiprism).\n    \n    The shape consists of:\n    - A top hexagonal ring of 6 points at height h_ring.\n    - A bottom hexagonal ring of 6 points at height -h_ring, twisted by 30 degrees.\n    - Two cap points on the symmetry axis at heights +/- h_cap.\n    \n    We fix the ring radius r=1.0 (scale invariance) and optimize h_ring and h_cap.\n    \"\"\"\n    \n    def get_points(params):\n        # params: [h_ring, h_cap]\n        h_ring, h_cap = params\n        r = 1.0\n        \n        points = np.zeros((14, 3))\n        \n        # Top Ring (6 points) at z = h_ring\n        # Angles: 0, 60, 120, 180, 240, 300\n        theta_top = np.linspace(0, 2*np.pi, 6, endpoint=False)\n        points[0:6, 0] = r * np.cos(theta_top)\n        points[0:6, 1] = r * np.sin(theta_top)\n        points[0:6, 2] = h_ring\n        \n        # Bottom Ring (6 points) at z = -h_ring\n        # Angles shifted by 30 deg (pi/6) for Antiprism symmetry\n        theta_bot = theta_top + np.pi/6\n        points[6:12, 0] = r * np.cos(theta_bot)\n        points[6:12, 1] = r * np.sin(theta_bot)\n        points[6:12, 2] = -h_ring\n        \n        # Caps (2 points) at z = +/- h_cap\n        points[12] = [0, 0, h_cap]\n        points[13] = [0, 0, -h_cap]\n        \n        return points\n\n    def objective(params):\n        # We want to maximize score = (d_min / d_max)^2\n        # Optimizer minimizes negative score\n        h_ring, h_cap = params\n        \n        # Basic geometric constraints (positive heights)\n        if h_ring < 1e-4 or h_cap < 1e-4:\n            return 1e9\n        \n        pts = get_points(params)\n        dists = pdist(pts)\n        \n        if dists.size == 0: return 1e9\n        \n        d_min = np.min(dists)\n        d_max = np.max(dists)\n        \n        if d_max < 1e-9: return 1e9\n        \n        # Calculate squared ratio\n        ratio_sq = (d_min / d_max)**2\n        return -ratio_sq\n\n    # Optimization Strategy:\n    # 1. Coarse Grid Search to locate the basin of attraction (avoid local optima)\n    # 2. Nelder-Mead optimization for high precision\n    \n    best_params = [0.4, 1.0] # Initial guess\n    best_score = 0\n    \n    # Grid search ranges based on typical packing geometries\n    h_ring_range = np.linspace(0.2, 0.8, 15)\n    h_cap_range = np.linspace(0.5, 1.5, 15)\n    \n    for hr in h_ring_range:\n        for hc in h_cap_range:\n            val = objective([hr, hc])\n            if val < best_score: # val is negative\n                best_score = val\n                best_params = [hr, hc]\n                \n    # Fine-tuning with Nelder-Mead\n    res = minimize(\n        objective, \n        best_params, \n        method='Nelder-Mead', \n        tol=1e-9,\n        options={'maxiter': 5000, 'xatol': 1e-9, 'fatol': 1e-9}\n    )\n    \n    final_points = get_points(res.x)\n    return final_points",
  "metrics": {
    "valid": true,
    "score": 0.933188830844175,
    "min_max_ratio": 0.22400923773979559,
    "min_distance": 0.9999999999999996,
    "max_distance": 2.1128420705622455,
    "eval_time": 0.23862290382385254,
    "error": null
  },
  "prompt": "The current best solution is trial_8_0. It achieves a score of 1.000016. This configuration likely has D6d or D6h symmetry. Implement a solver that enforces D6d symmetry (Bicapped Hexagonal Antiprism) to reduce the number of variables and find the theoretical maximum precision for this shape. Optimize the heights and radii of the hexagonal layers.",
  "response": "Here is the Python solution to find the optimal configuration for 14 points in 3D space, enforcing $D_{6d}$ symmetry (Bicapped Hexagonal Antiprism).\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Calculates the 14 points in 3D space that maximize the squared ratio \n    (min_dist / max_dist)^2, enforcing D6d symmetry (Bicapped Hexagonal Antiprism).\n    \n    The shape consists of:\n    - A top hexagonal ring of 6 points at height h_ring.\n    - A bottom hexagonal ring of 6 points at height -h_ring, twisted by 30 degrees.\n    - Two cap points on the symmetry axis at heights +/- h_cap.\n    \n    We fix the ring radius r=1.0 (scale invariance) and optimize h_ring and h_cap.\n    \"\"\"\n    \n    def get_points(params):\n        # params: [h_ring, h_cap]\n        h_ring, h_cap = params\n        r = 1.0\n        \n        points = np.zeros((14, 3))\n        \n        # Top Ring (6 points) at z = h_ring\n        # Angles: 0, 60, 120, 180, 240, 300\n        theta_top = np.linspace(0, 2*np.pi, 6, endpoint=False)\n        points[0:6, 0] = r * np.cos(theta_top)\n        points[0:6, 1] = r * np.sin(theta_top)\n        points[0:6, 2] = h_ring\n        \n        # Bottom Ring (6 points) at z = -h_ring\n        # Angles shifted by 30 deg (pi/6) for Antiprism symmetry\n        theta_bot = theta_top + np.pi/6\n        points[6:12, 0] = r * np.cos(theta_bot)\n        points[6:12, 1] = r * np.sin(theta_bot)\n        points[6:12, 2] = -h_ring\n        \n        # Caps (2 points) at z = +/- h_cap\n        points[12] = [0, 0, h_cap]\n        points[13] = [0, 0, -h_cap]\n        \n        return points\n\n    def objective(params):\n        # We want to maximize score = (d_min / d_max)^2\n        # Optimizer minimizes negative score\n        h_ring, h_cap = params\n        \n        # Basic geometric constraints (positive heights)\n        if h_ring < 1e-4 or h_cap < 1e-4:\n            return 1e9\n        \n        pts = get_points(params)\n        dists = pdist(pts)\n        \n        if dists.size == 0: return 1e9\n        \n        d_min = np.min(dists)\n        d_max = np.max(dists)\n        \n        if d_max < 1e-9: return 1e9\n        \n        # Calculate squared ratio\n        ratio_sq = (d_min / d_max)**2\n        return -ratio_sq\n\n    # Optimization Strategy:\n    # 1. Coarse Grid Search to locate the basin of attraction (avoid local optima)\n    # 2. Nelder-Mead optimization for high precision\n    \n    best_params = [0.4, 1.0] # Initial guess\n    best_score = 0\n    \n    # Grid search ranges based on typical packing geometries\n    h_ring_range = np.linspace(0.2, 0.8, 15)\n    h_cap_range = np.linspace(0.5, 1.5, 15)\n    \n    for hr in h_ring_range:\n        for hc in h_cap_range:\n            val = objective([hr, hc])\n            if val < best_score: # val is negative\n                best_score = val\n                best_params = [hr, hc]\n                \n    # Fine-tuning with Nelder-Mead\n    res = minimize(\n        objective, \n        best_params, \n        method='Nelder-Mead', \n        tol=1e-9,\n        options={'maxiter': 5000, 'xatol': 1e-9, 'fatol': 1e-9}\n    )\n    \n    final_points = get_points(res.x)\n    return final_points\n```",
  "reasoning": "Here is the Python solution to find the optimal configuration for 14 points in 3D space, enforcing $D_{6d}$ symmetry (Bicapped Hexagonal Antiprism).",
  "timestamp": "2026-01-21T17:57:12.665521",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 256,
        "candidates_token_count": 1110,
        "thoughts_token_count": 12240
      },
      "response_text_len": 3219
    }
  }
}