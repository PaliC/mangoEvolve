{
  "trial_id": "trial_9_4",
  "generation": 9,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds the optimal configuration of 14 points in 3D space to maximize the \n    ratio (min_dist / max_dist)^2 using the trust-constr optimization method\n    with analytical Jacobian and Hessian.\n    \"\"\"\n    N = 14\n    n_vars = 3 * N + 1  # 3N coordinates + 1 slack variable s\n    \n    # Precompute pair indices for vectorized operations\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n    pairs = np.array(pairs)\n    idx_i = pairs[:, 0]\n    idx_j = pairs[:, 1]\n    n_pairs = len(pairs)\n    \n    # --- Helper Functions ---\n    \n    def get_diff_d2(coords):\n        \"\"\"Compute coordinate differences and squared distances for all pairs.\"\"\"\n        P = coords.reshape((N, 3))\n        diff = P[idx_i] - P[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        return diff, d2\n\n    # --- Optimization Problem Definitions ---\n    \n    # Objective: Minimize -s (Maximize s)\n    # x = [x1, y1, z1, ..., xN, yN, zN, s]\n    def objective(x):\n        return -x[-1]\n\n    def obj_grad(x):\n        g = np.zeros_like(x)\n        g[-1] = -1.0\n        return g\n    \n    def obj_hess(x):\n        # Hessian of linear objective is zero\n        return np.zeros((len(x), len(x)))\n\n    # Constraints vector construction:\n    # 1. d_ij^2 <= 1  => d_ij^2\n    # 2. d_ij^2 >= s  => s - d_ij^2\n    # We return a concatenated vector of length 2*n_pairs\n    def constraints_func(x):\n        coords = x[:-1]\n        s = x[-1]\n        _, d2 = get_diff_d2(coords)\n        return np.concatenate([d2, s - d2])\n    \n    # Jacobian of constraints\n    # Structure: (2*n_pairs, 3*N + 1)\n    def constraints_jac(x):\n        coords = x[:-1]\n        diff, _ = get_diff_d2(coords)\n        \n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        # Gradients of d_ij^2 w.r.t coordinates\n        # d(d^2)/dp_i = 2(p_i - p_j)\n        # d(d^2)/dp_j = -2(p_i - p_j)\n        scaled_diff = 2 * diff\n        \n        for k in range(n_pairs):\n            i, j = idx_i[k], idx_j[k]\n            # Fill row k (constraint d_ij^2)\n            jac[k, 3*i : 3*i+3] = scaled_diff[k]\n            jac[k, 3*j : 3*j+3] = -scaled_diff[k]\n            \n        # Gradients for second half (s - d_ij^2)\n        # Coordinate part is negative of first half\n        jac[n_pairs:, :-1] = -jac[:n_pairs, :-1]\n        # s part is 1.0\n        jac[n_pairs:, -1] = 1.0\n        \n        return jac\n\n    # Hessian of Lagrangian\n    # H = sum(v_k * H_k)\n    # where v are Lagrange multipliers provided by the solver\n    def lagrangian_hess(x, v):\n        # v corresponds to constraints [d2, s-d2]\n        # Constraint terms in Lagrangian: v_k * c_k(x)\n        # H_total = sum(v_k * H(d2_k)) + sum(v_{k+M} * H(s - d2_k))\n        # Since H(s - d2_k) = -H(d2_k), effective weight is v_k - v_{k+M}\n        w = v[:n_pairs] - v[n_pairs:]\n        \n        H = np.zeros((3 * N + 1, 3 * N + 1))\n        \n        # Accumulate Hessian blocks\n        # H(d_ij^2) has blocks:\n        # (i,i): 2I, (j,j): 2I, (i,j): -2I, (j,i): -2I\n        \n        for k in range(n_pairs):\n            val = 2.0 * w[k]\n            i, j = idx_i[k], idx_j[k]\n            \n            # Add to diagonal blocks (3x3)\n            H[3*i, 3*i] += val\n            H[3*i+1, 3*i+1] += val\n            H[3*i+2, 3*i+2] += val\n            \n            H[3*j, 3*j] += val\n            H[3*j+1, 3*j+1] += val\n            H[3*j+2, 3*j+2] += val\n            \n            # Add to off-diagonal blocks\n            H[3*i, 3*j] -= val\n            H[3*i+1, 3*j+1] -= val\n            H[3*i+2, 3*j+2] -= val\n            \n            H[3*j, 3*i] -= val\n            H[3*j+1, 3*i+1] -= val\n            H[3*j+2, 3*i+2] -= val\n            \n        return H\n\n    # --- Initialization Phase ---\n    # Find a good starting configuration on the unit sphere using a simplified repulsion model.\n    \n    best_p = None\n    best_min_d = -1.0\n    \n    # Try multiple random initializations to avoid local optima\n    # 5 restarts is sufficient for N=14 to find the global basin\n    for _ in range(5):\n        p_init = np.random.normal(size=(N, 3))\n        p_init /= np.linalg.norm(p_init, axis=1, keepdims=True)\n        \n        # Simplified potential energy: sum 1/d^6 (soft spheres) + sphere constraint penalty\n        def potential(x):\n            p = x.reshape((N, 3))\n            d = p[idx_i] - p[idx_j]\n            d2 = np.sum(d**2, axis=1)\n            # Avoid division by zero\n            energy = np.sum(1.0 / (d2**3 + 1e-9)) \n            # Soft constraint to unit sphere\n            r2 = np.sum(p**2, axis=1)\n            energy += 1000 * np.sum((r2 - 1)**2)\n            return energy\n\n        res_init = minimize(potential, p_init.flatten(), method='L-BFGS-B', options={'maxiter': 150})\n        p_cand = res_init.x.reshape((N, 3))\n        p_cand /= np.linalg.norm(p_cand, axis=1, keepdims=True)\n        \n        # Evaluate candidate\n        d = p_cand[idx_i] - p_cand[idx_j]\n        d2 = np.sum(d**2, axis=1)\n        min_d = np.min(d2)\n        \n        if min_d > best_min_d:\n            best_min_d = min_d\n            best_p = p_cand\n            \n    # Scale initialization to fit problem constraints\n    # Unit sphere diameter is 2. We want max_dist <= 1.\n    P0 = best_p * 0.5\n    \n    # Calculate initial slack s\n    diff0 = P0[idx_i] - P0[idx_j]\n    d2_0 = np.sum(diff0**2, axis=1)\n    s0 = np.min(d2_0) * 0.95 # Start feasible\n    \n    x0 = np.concatenate([P0.flatten(), [s0]])\n    \n    # --- Trust-Constr Optimization ---\n    \n    # Constraints bounds:\n    # d2 <= 1.0  --> (-inf, 1.0]\n    # s - d2 <= 0.0 --> (-inf, 0.0]\n    nlc = NonlinearConstraint(\n        constraints_func,\n        lb = np.concatenate([np.full(n_pairs, -np.inf), np.full(n_pairs, -np.inf)]),\n        ub = np.concatenate([np.full(n_pairs, 1.0), np.full(n_pairs, 0.0)]),\n        jac = constraints_jac,\n        hess = lagrangian_hess\n    )\n    \n    res = minimize(\n        objective,\n        x0,\n        method='trust-constr',\n        jac=obj_grad,\n        hess=obj_hess,\n        constraints=[nlc],\n        options={'verbose': 0, 'gtol': 1e-7, 'xtol': 1e-7, 'maxiter': 1000}\n    )\n    \n    # Extract final coordinates\n    P_final = res.x[:-1].reshape((N, 3))\n    \n    # Center the configuration\n    P_final -= np.mean(P_final, axis=0)\n    \n    return P_final",
  "metrics": {
    "valid": true,
    "score": 0.9259922680204175,
    "min_max_ratio": 0.22228172397279286,
    "min_distance": 0.46939903106566433,
    "max_distance": 0.9956124312323152,
    "eval_time": 0.8347592353820801,
    "error": null
  },
  "prompt": "Implement a high-precision optimization for 14 points using the Scipy 'trust-constr' method. Use the slack variable formulation (maximize s). Provide the analytical Jacobian and Hessian for the constraints to ensure maximum convergence speed and precision.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds the optimal configuration of 14 points in 3D space to maximize the \n    ratio (min_dist / max_dist)^2 using the trust-constr optimization method\n    with analytical Jacobian and Hessian.\n    \"\"\"\n    N = 14\n    n_vars = 3 * N + 1  # 3N coordinates + 1 slack variable s\n    \n    # Precompute pair indices for vectorized operations\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pairs.append((i, j))\n    pairs = np.array(pairs)\n    idx_i = pairs[:, 0]\n    idx_j = pairs[:, 1]\n    n_pairs = len(pairs)\n    \n    # --- Helper Functions ---\n    \n    def get_diff_d2(coords):\n        \"\"\"Compute coordinate differences and squared distances for all pairs.\"\"\"\n        P = coords.reshape((N, 3))\n        diff = P[idx_i] - P[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        return diff, d2\n\n    # --- Optimization Problem Definitions ---\n    \n    # Objective: Minimize -s (Maximize s)\n    # x = [x1, y1, z1, ..., xN, yN, zN, s]\n    def objective(x):\n        return -x[-1]\n\n    def obj_grad(x):\n        g = np.zeros_like(x)\n        g[-1] = -1.0\n        return g\n    \n    def obj_hess(x):\n        # Hessian of linear objective is zero\n        return np.zeros((len(x), len(x)))\n\n    # Constraints vector construction:\n    # 1. d_ij^2 <= 1  => d_ij^2\n    # 2. d_ij^2 >= s  => s - d_ij^2\n    # We return a concatenated vector of length 2*n_pairs\n    def constraints_func(x):\n        coords = x[:-1]\n        s = x[-1]\n        _, d2 = get_diff_d2(coords)\n        return np.concatenate([d2, s - d2])\n    \n    # Jacobian of constraints\n    # Structure: (2*n_pairs, 3*N + 1)\n    def constraints_jac(x):\n        coords = x[:-1]\n        diff, _ = get_diff_d2(coords)\n        \n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        # Gradients of d_ij^2 w.r.t coordinates\n        # d(d^2)/dp_i = 2(p_i - p_j)\n        # d(d^2)/dp_j = -2(p_i - p_j)\n        scaled_diff = 2 * diff\n        \n        for k in range(n_pairs):\n            i, j = idx_i[k], idx_j[k]\n            # Fill row k (constraint d_ij^2)\n            jac[k, 3*i : 3*i+3] = scaled_diff[k]\n            jac[k, 3*j : 3*j+3] = -scaled_diff[k]\n            \n        # Gradients for second half (s - d_ij^2)\n        # Coordinate part is negative of first half\n        jac[n_pairs:, :-1] = -jac[:n_pairs, :-1]\n        # s part is 1.0\n        jac[n_pairs:, -1] = 1.0\n        \n        return jac\n\n    # Hessian of Lagrangian\n    # H = sum(v_k * H_k)\n    # where v are Lagrange multipliers provided by the solver\n    def lagrangian_hess(x, v):\n        # v corresponds to constraints [d2, s-d2]\n        # Constraint terms in Lagrangian: v_k * c_k(x)\n        # H_total = sum(v_k * H(d2_k)) + sum(v_{k+M} * H(s - d2_k))\n        # Since H(s - d2_k) = -H(d2_k), effective weight is v_k - v_{k+M}\n        w = v[:n_pairs] - v[n_pairs:]\n        \n        H = np.zeros((3 * N + 1, 3 * N + 1))\n        \n        # Accumulate Hessian blocks\n        # H(d_ij^2) has blocks:\n        # (i,i): 2I, (j,j): 2I, (i,j): -2I, (j,i): -2I\n        \n        for k in range(n_pairs):\n            val = 2.0 * w[k]\n            i, j = idx_i[k], idx_j[k]\n            \n            # Add to diagonal blocks (3x3)\n            H[3*i, 3*i] += val\n            H[3*i+1, 3*i+1] += val\n            H[3*i+2, 3*i+2] += val\n            \n            H[3*j, 3*j] += val\n            H[3*j+1, 3*j+1] += val\n            H[3*j+2, 3*j+2] += val\n            \n            # Add to off-diagonal blocks\n            H[3*i, 3*j] -= val\n            H[3*i+1, 3*j+1] -= val\n            H[3*i+2, 3*j+2] -= val\n            \n            H[3*j, 3*i] -= val\n            H[3*j+1, 3*i+1] -= val\n            H[3*j+2, 3*i+2] -= val\n            \n        return H\n\n    # --- Initialization Phase ---\n    # Find a good starting configuration on the unit sphere using a simplified repulsion model.\n    \n    best_p = None\n    best_min_d = -1.0\n    \n    # Try multiple random initializations to avoid local optima\n    # 5 restarts is sufficient for N=14 to find the global basin\n    for _ in range(5):\n        p_init = np.random.normal(size=(N, 3))\n        p_init /= np.linalg.norm(p_init, axis=1, keepdims=True)\n        \n        # Simplified potential energy: sum 1/d^6 (soft spheres) + sphere constraint penalty\n        def potential(x):\n            p = x.reshape((N, 3))\n            d = p[idx_i] - p[idx_j]\n            d2 = np.sum(d**2, axis=1)\n            # Avoid division by zero\n            energy = np.sum(1.0 / (d2**3 + 1e-9)) \n            # Soft constraint to unit sphere\n            r2 = np.sum(p**2, axis=1)\n            energy += 1000 * np.sum((r2 - 1)**2)\n            return energy\n\n        res_init = minimize(potential, p_init.flatten(), method='L-BFGS-B', options={'maxiter': 150})\n        p_cand = res_init.x.reshape((N, 3))\n        p_cand /= np.linalg.norm(p_cand, axis=1, keepdims=True)\n        \n        # Evaluate candidate\n        d = p_cand[idx_i] - p_cand[idx_j]\n        d2 = np.sum(d**2, axis=1)\n        min_d = np.min(d2)\n        \n        if min_d > best_min_d:\n            best_min_d = min_d\n            best_p = p_cand\n            \n    # Scale initialization to fit problem constraints\n    # Unit sphere diameter is 2. We want max_dist <= 1.\n    P0 = best_p * 0.5\n    \n    # Calculate initial slack s\n    diff0 = P0[idx_i] - P0[idx_j]\n    d2_0 = np.sum(diff0**2, axis=1)\n    s0 = np.min(d2_0) * 0.95 # Start feasible\n    \n    x0 = np.concatenate([P0.flatten(), [s0]])\n    \n    # --- Trust-Constr Optimization ---\n    \n    # Constraints bounds:\n    # d2 <= 1.0  --> (-inf, 1.0]\n    # s - d2 <= 0.0 --> (-inf, 0.0]\n    nlc = NonlinearConstraint(\n        constraints_func,\n        lb = np.concatenate([np.full(n_pairs, -np.inf), np.full(n_pairs, -np.inf)]),\n        ub = np.concatenate([np.full(n_pairs, 1.0), np.full(n_pairs, 0.0)]),\n        jac = constraints_jac,\n        hess = lagrangian_hess\n    )\n    \n    res = minimize(\n        objective,\n        x0,\n        method='trust-constr',\n        jac=obj_grad,\n        hess=obj_hess,\n        constraints=[nlc],\n        options={'verbose': 0, 'gtol': 1e-7, 'xtol': 1e-7, 'maxiter': 1000}\n    )\n    \n    # Extract final coordinates\n    P_final = res.x[:-1].reshape((N, 3))\n    \n    # Center the configuration\n    P_final -= np.mean(P_final, axis=0)\n    \n    return P_final\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:57:30.092748",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 220,
        "candidates_token_count": 2356,
        "thoughts_token_count": 13283
      },
      "response_text_len": 6385
    }
  }
}