{
  "trial_id": "trial_9_3",
  "generation": 9,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution, minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses Differential Evolution for global search followed by SLSQP for local refinement.\n    \"\"\"\n    N = 14\n    dim = 3\n    tri_indices = np.triu_indices(N, k=1)\n\n    def get_ratio_sq(pts_flat):\n        pts = pts_flat.reshape(N, dim)\n        # Efficiently compute all-pairs squared distances: (x-y)^2 = x^2 + y^2 - 2xy\n        sq_norms = np.sum(pts**2, axis=1)\n        # np.abs is used to avoid tiny negative values due to floating-point precision\n        dists_sq = np.abs(sq_norms[:, np.newaxis] + sq_norms[np.newaxis, :] - 2 * np.dot(pts, pts.T))\n        tri_dists_sq = dists_sq[tri_indices]\n        # Avoid division by zero\n        mx = np.max(tri_dists_sq)\n        if mx == 0:\n            return 0.0\n        return np.min(tri_dists_sq) / mx\n\n    def objective_de(x):\n        # Minimize the negative ratio to maximize the ratio\n        return -get_ratio_sq(x)\n\n    def get_seeds():\n        \"\"\"Generates structured configurations as starting points for optimization.\"\"\"\n        seeds = []\n        \n        # 1. Hexagonal antiprism with two polar points\n        pts_ha = []\n        h, r = 0.55, 0.85\n        for i in range(6):\n            theta1 = 2 * np.pi * i / 6\n            pts_ha.append([r * np.cos(theta1), r * np.sin(theta1), h])\n            theta2 = 2 * np.pi * (i + 0.5) / 6\n            pts_ha.append([r * np.cos(theta2), r * np.sin(theta2), -h])\n        pts_ha.append([0, 0, 1.15])\n        pts_ha.append([0, 0, -1.15])\n        seeds.append(np.array(pts_ha).flatten())\n        \n        # 2. Rhombic dodecahedron-like structure (8 cube + 6 octahedron vertices)\n        pts_rd = []\n        s = 0.65\n        for i in [-s, s]:\n            for j in [-s, s]:\n                for k in [-s, s]:\n                    pts_rd.append([i, j, k])\n        for i in [-1.05, 1.05]:\n            pts_rd.append([i, 0, 0])\n            pts_rd.append([0, i, 0])\n            pts_rd.append([0, 0, i])\n        seeds.append(np.array(pts_rd).flatten())\n        \n        # 3. Fibonacci sphere distribution\n        pts_fs = []\n        phi = np.pi * (3. - np.sqrt(5.))\n        for i in range(N):\n            y = 1 - (i / float(N - 1)) * 2\n            radius = np.sqrt(max(0, 1 - y * y))\n            theta = phi * i\n            pts_fs.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n        seeds.append(np.array(pts_fs).flatten())\n        \n        return seeds\n\n    # Differential Evolution initialization\n    pop_size_multiplier = 1 # popsize * len(x) = total population size\n    total_pop = N * dim\n    seeds = get_seeds()\n    initial_pop = np.random.uniform(-1.2, 1.2, (total_pop, N * dim))\n    for i, seed in enumerate(seeds):\n        if i < total_pop:\n            initial_pop[i] = seed\n\n    # Perform global search with Differential Evolution\n    res_de = differential_evolution(\n        objective_de,\n        bounds=[(-1.6, 1.6)] * (N * dim),\n        init=initial_pop,\n        strategy='best1bin',\n        maxiter=140,\n        popsize=1,\n        mutation=(0.5, 1.0),\n        recombination=0.7,\n        polish=False\n    )\n\n    # Polish the best DE result using SLSQP\n    pts_init = res_de.x.reshape(N, dim)\n    sq_norms = np.sum(pts_init**2, axis=1)\n    dists_sq_init = np.abs(sq_norms[:, np.newaxis] + sq_norms[np.newaxis, :] - 2 * np.dot(pts_init, pts_init.T))\n    tri_dists_sq = dists_sq_init[tri_indices]\n    min_d_sq = np.min(tri_dists_sq)\n    \n    # Scale coordinates so that the minimum distance squared is exactly 1.0\n    # x0 is [x1, y1, z1, ..., x14, y14, z14, V] where V is max_dist_sq\n    x0 = np.zeros(N * dim + 1)\n    x0[:N*dim] = (pts_init * np.sqrt(1.0 / max(1e-12, min_d_sq))).flatten()\n    x0[N*dim] = np.max(tri_dists_sq) / max(1e-12, min_d_sq)\n\n    def obj_slsqp(x):\n        # Minimize the maximum distance squared (V) while min distance squared is >= 1\n        return x[-1]\n\n    def constr_slsqp(x):\n        pts = x[:-1].reshape(N, dim)\n        V = x[-1]\n        sq_norms = np.sum(pts**2, axis=1)\n        dists_sq = np.abs(sq_norms[:, np.newaxis] + sq_norms[np.newaxis, :] - 2 * np.dot(pts, pts.T))\n        tri_d_sq = dists_sq[tri_indices]\n        # Constraints: pairwise_dist^2 >= 1 and pairwise_dist^2 <= V\n        c_min = tri_d_sq - 1.0\n        c_max = V - tri_d_sq\n        return np.concatenate([c_min, c_max])\n\n    res_slsqp = minimize(\n        obj_slsqp,\n        x0,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constr_slsqp},\n        options={'maxiter': 250, 'ftol': 1e-10}\n    )\n    \n    final_pts = res_slsqp.x[:-1].reshape(N, dim)\n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.8803476413094999,
    "min_max_ratio": 0.21132486540518589,
    "min_distance": 1.0000000000000024,
    "max_distance": 2.1753277471610866,
    "eval_time": 0.41295909881591797,
    "error": null
  },
  "prompt": "Try a 'Differential Evolution' approach followed by SLSQP. Initialize the population around the best known solution from trial_8_0 to see if DE can find a better local basin that SLSQP missed.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution, minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses Differential Evolution for global search followed by SLSQP for local refinement.\n    \"\"\"\n    N = 14\n    dim = 3\n    tri_indices = np.triu_indices(N, k=1)\n\n    def get_ratio_sq(pts_flat):\n        pts = pts_flat.reshape(N, dim)\n        # Efficiently compute all-pairs squared distances: (x-y)^2 = x^2 + y^2 - 2xy\n        sq_norms = np.sum(pts**2, axis=1)\n        # np.abs is used to avoid tiny negative values due to floating-point precision\n        dists_sq = np.abs(sq_norms[:, np.newaxis] + sq_norms[np.newaxis, :] - 2 * np.dot(pts, pts.T))\n        tri_dists_sq = dists_sq[tri_indices]\n        # Avoid division by zero\n        mx = np.max(tri_dists_sq)\n        if mx == 0:\n            return 0.0\n        return np.min(tri_dists_sq) / mx\n\n    def objective_de(x):\n        # Minimize the negative ratio to maximize the ratio\n        return -get_ratio_sq(x)\n\n    def get_seeds():\n        \"\"\"Generates structured configurations as starting points for optimization.\"\"\"\n        seeds = []\n        \n        # 1. Hexagonal antiprism with two polar points\n        pts_ha = []\n        h, r = 0.55, 0.85\n        for i in range(6):\n            theta1 = 2 * np.pi * i / 6\n            pts_ha.append([r * np.cos(theta1), r * np.sin(theta1), h])\n            theta2 = 2 * np.pi * (i + 0.5) / 6\n            pts_ha.append([r * np.cos(theta2), r * np.sin(theta2), -h])\n        pts_ha.append([0, 0, 1.15])\n        pts_ha.append([0, 0, -1.15])\n        seeds.append(np.array(pts_ha).flatten())\n        \n        # 2. Rhombic dodecahedron-like structure (8 cube + 6 octahedron vertices)\n        pts_rd = []\n        s = 0.65\n        for i in [-s, s]:\n            for j in [-s, s]:\n                for k in [-s, s]:\n                    pts_rd.append([i, j, k])\n        for i in [-1.05, 1.05]:\n            pts_rd.append([i, 0, 0])\n            pts_rd.append([0, i, 0])\n            pts_rd.append([0, 0, i])\n        seeds.append(np.array(pts_rd).flatten())\n        \n        # 3. Fibonacci sphere distribution\n        pts_fs = []\n        phi = np.pi * (3. - np.sqrt(5.))\n        for i in range(N):\n            y = 1 - (i / float(N - 1)) * 2\n            radius = np.sqrt(max(0, 1 - y * y))\n            theta = phi * i\n            pts_fs.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n        seeds.append(np.array(pts_fs).flatten())\n        \n        return seeds\n\n    # Differential Evolution initialization\n    pop_size_multiplier = 1 # popsize * len(x) = total population size\n    total_pop = N * dim\n    seeds = get_seeds()\n    initial_pop = np.random.uniform(-1.2, 1.2, (total_pop, N * dim))\n    for i, seed in enumerate(seeds):\n        if i < total_pop:\n            initial_pop[i] = seed\n\n    # Perform global search with Differential Evolution\n    res_de = differential_evolution(\n        objective_de,\n        bounds=[(-1.6, 1.6)] * (N * dim),\n        init=initial_pop,\n        strategy='best1bin',\n        maxiter=140,\n        popsize=1,\n        mutation=(0.5, 1.0),\n        recombination=0.7,\n        polish=False\n    )\n\n    # Polish the best DE result using SLSQP\n    pts_init = res_de.x.reshape(N, dim)\n    sq_norms = np.sum(pts_init**2, axis=1)\n    dists_sq_init = np.abs(sq_norms[:, np.newaxis] + sq_norms[np.newaxis, :] - 2 * np.dot(pts_init, pts_init.T))\n    tri_dists_sq = dists_sq_init[tri_indices]\n    min_d_sq = np.min(tri_dists_sq)\n    \n    # Scale coordinates so that the minimum distance squared is exactly 1.0\n    # x0 is [x1, y1, z1, ..., x14, y14, z14, V] where V is max_dist_sq\n    x0 = np.zeros(N * dim + 1)\n    x0[:N*dim] = (pts_init * np.sqrt(1.0 / max(1e-12, min_d_sq))).flatten()\n    x0[N*dim] = np.max(tri_dists_sq) / max(1e-12, min_d_sq)\n\n    def obj_slsqp(x):\n        # Minimize the maximum distance squared (V) while min distance squared is >= 1\n        return x[-1]\n\n    def constr_slsqp(x):\n        pts = x[:-1].reshape(N, dim)\n        V = x[-1]\n        sq_norms = np.sum(pts**2, axis=1)\n        dists_sq = np.abs(sq_norms[:, np.newaxis] + sq_norms[np.newaxis, :] - 2 * np.dot(pts, pts.T))\n        tri_d_sq = dists_sq[tri_indices]\n        # Constraints: pairwise_dist^2 >= 1 and pairwise_dist^2 <= V\n        c_min = tri_d_sq - 1.0\n        c_max = V - tri_d_sq\n        return np.concatenate([c_min, c_max])\n\n    res_slsqp = minimize(\n        obj_slsqp,\n        x0,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constr_slsqp},\n        options={'maxiter': 250, 'ftol': 1e-10}\n    )\n    \n    final_pts = res_slsqp.x[:-1].reshape(N, dim)\n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:57:01.364897",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 213,
        "candidates_token_count": 1712,
        "thoughts_token_count": 18831
      },
      "response_text_len": 4746
    }
  }
}