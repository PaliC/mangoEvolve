{
  "trial_id": "trial_9_5",
  "generation": 9,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Returns 14 points in 3D maximizing the squared ratio (min_dist / max_dist)^2.\n    Enforces D6d symmetry (Bi-capped Hexagonal Antiprism).\n    \n    Variables optimized:\n      - Pole height (zp)\n      - Ring height (zr)\n      - Ring radius (r)\n    The twist angle is fixed at pi/6 (30 degrees) for the antiprism structure.\n    \"\"\"\n    \n    # 1. Define the point generator for D6d symmetry\n    def get_d6d_points(params):\n        zp, zr, r = params\n        points = np.zeros((14, 3))\n        \n        # Poles at +/- zp on z-axis\n        points[0] = [0, 0, zp]\n        points[13] = [0, 0, -zp]\n        \n        # Ring 1 at z = zr\n        # 6 points at angles 0, 60, 120...\n        theta1 = np.arange(6) * (np.pi / 3)\n        points[1:7, 0] = r * np.cos(theta1)\n        points[1:7, 1] = r * np.sin(theta1)\n        points[1:7, 2] = zr\n        \n        # Ring 2 at z = -zr\n        # 6 points at angles 30, 90, 150... (Antiprism twist)\n        theta2 = theta1 + (np.pi / 6)\n        points[7:13, 0] = r * np.cos(theta2)\n        points[7:13, 1] = r * np.sin(theta2)\n        points[7:13, 2] = -zr\n        \n        return points\n\n    # 2. Define the optimization problem\n    # We introduce an auxiliary variable 't' representing the squared minimum distance.\n    # We fix the squared maximum distance to be <= 1 to handle scaling.\n    # Objective: Maximize t.\n    \n    # Precompute indices for pairwise distance calculations\n    idx_i, idx_j = np.triu_indices(14, k=1)\n    \n    def objective(x):\n        # x = [zp, zr, r, t]\n        # Minimize negative t to maximize t\n        return -x[3]\n    \n    def constraints(x):\n        zp, zr, r, t = x\n        pts = get_d6d_points([zp, zr, r])\n        \n        # Calculate squared pairwise distances\n        diffs = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        \n        # Constraints:\n        # 1. min_dist^2 >= t  =>  d2 - t >= 0\n        # 2. max_dist^2 <= 1  =>  1 - d2 >= 0\n        return np.concatenate([\n            d2 - t,\n            1.0 - d2\n        ])\n    \n    # 3. Setup and run optimization\n    # Initial guess: A rough bi-capped hexagonal antiprism scaled to fit unit diameter\n    # zp ~ 0.45, zr ~ 0.15, r ~ 0.35, t ~ 0.05\n    x0 = np.array([0.45, 0.15, 0.35, 0.05])\n    \n    # Bounds: Dimensions must be positive, t in [0, 1]\n    bnds = [\n        (1e-6, None), # zp\n        (0.0, None),  # zr\n        (1e-6, None), # r\n        (0.0, 1.0)    # t\n    ]\n    \n    # Use SLSQP as requested for constrained optimization\n    res = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bnds,\n        options={'ftol': 1e-12, 'maxiter': 1000}\n    )\n    \n    # 4. Generate final points\n    best_params = res.x[:3]\n    final_points = get_d6d_points(best_params)\n    \n    return final_points",
  "metrics": {
    "valid": true,
    "score": 0.9331888308441724,
    "min_max_ratio": 0.22400923773979495,
    "min_distance": 0.47329614169122364,
    "max_distance": 1.0000000000000087,
    "eval_time": 0.22147417068481445,
    "error": null
  },
  "prompt": "Improve the score (currently 1.0000159135539168) by enforcing D6d symmetry. For 14 points, this means: 2 points on the z-axis (poles), and two rings of 6 points each. The rings are staggered (antiprism). Variables: z1, z2, r1, r2, theta_offset. Use SLSQP to find the optimal parameters. Start near the configuration in trial_8_0.",
  "response": "An expert algorithm to find the optimal 14-point configuration in 3D space, enforcing $D_{6d}$ symmetry (bi-capped hexagonal antiprism) to maximize the min/max distance ratio.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Returns 14 points in 3D maximizing the squared ratio (min_dist / max_dist)^2.\n    Enforces D6d symmetry (Bi-capped Hexagonal Antiprism).\n    \n    Variables optimized:\n      - Pole height (zp)\n      - Ring height (zr)\n      - Ring radius (r)\n    The twist angle is fixed at pi/6 (30 degrees) for the antiprism structure.\n    \"\"\"\n    \n    # 1. Define the point generator for D6d symmetry\n    def get_d6d_points(params):\n        zp, zr, r = params\n        points = np.zeros((14, 3))\n        \n        # Poles at +/- zp on z-axis\n        points[0] = [0, 0, zp]\n        points[13] = [0, 0, -zp]\n        \n        # Ring 1 at z = zr\n        # 6 points at angles 0, 60, 120...\n        theta1 = np.arange(6) * (np.pi / 3)\n        points[1:7, 0] = r * np.cos(theta1)\n        points[1:7, 1] = r * np.sin(theta1)\n        points[1:7, 2] = zr\n        \n        # Ring 2 at z = -zr\n        # 6 points at angles 30, 90, 150... (Antiprism twist)\n        theta2 = theta1 + (np.pi / 6)\n        points[7:13, 0] = r * np.cos(theta2)\n        points[7:13, 1] = r * np.sin(theta2)\n        points[7:13, 2] = -zr\n        \n        return points\n\n    # 2. Define the optimization problem\n    # We introduce an auxiliary variable 't' representing the squared minimum distance.\n    # We fix the squared maximum distance to be <= 1 to handle scaling.\n    # Objective: Maximize t.\n    \n    # Precompute indices for pairwise distance calculations\n    idx_i, idx_j = np.triu_indices(14, k=1)\n    \n    def objective(x):\n        # x = [zp, zr, r, t]\n        # Minimize negative t to maximize t\n        return -x[3]\n    \n    def constraints(x):\n        zp, zr, r, t = x\n        pts = get_d6d_points([zp, zr, r])\n        \n        # Calculate squared pairwise distances\n        diffs = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        \n        # Constraints:\n        # 1. min_dist^2 >= t  =>  d2 - t >= 0\n        # 2. max_dist^2 <= 1  =>  1 - d2 >= 0\n        return np.concatenate([\n            d2 - t,\n            1.0 - d2\n        ])\n    \n    # 3. Setup and run optimization\n    # Initial guess: A rough bi-capped hexagonal antiprism scaled to fit unit diameter\n    # zp ~ 0.45, zr ~ 0.15, r ~ 0.35, t ~ 0.05\n    x0 = np.array([0.45, 0.15, 0.35, 0.05])\n    \n    # Bounds: Dimensions must be positive, t in [0, 1]\n    bnds = [\n        (1e-6, None), # zp\n        (0.0, None),  # zr\n        (1e-6, None), # r\n        (0.0, 1.0)    # t\n    ]\n    \n    # Use SLSQP as requested for constrained optimization\n    res = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bnds,\n        options={'ftol': 1e-12, 'maxiter': 1000}\n    )\n    \n    # 4. Generate final points\n    best_params = res.x[:3]\n    final_points = get_d6d_points(best_params)\n    \n    return final_points\n```",
  "reasoning": "An expert algorithm to find the optimal 14-point configuration in 3D space, enforcing $D_{6d}$ symmetry (bi-capped hexagonal antiprism) to maximize the min/max distance ratio.",
  "timestamp": "2026-01-21T18:00:11.597892",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 280,
        "candidates_token_count": 1119,
        "thoughts_token_count": 15569
      },
      "response_text_len": 3117
    }
  }
}