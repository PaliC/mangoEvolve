{
  "trial_id": "trial_9_6",
  "generation": 9,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Generates 14 points in 3D space to maximize the squared ratio \n    (min_dist / max_dist)^2 using a multi-start SLSQP polishing strategy.\n    \"\"\"\n    N = 14\n    dim = 3\n    n_pairs = N * (N - 1) // 2\n    \n    # Precompute pair indices for vectorized distance calculations\n    idx_i = np.zeros(n_pairs, dtype=int)\n    idx_j = np.zeros(n_pairs, dtype=int)\n    k = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i[k] = i\n            idx_j[k] = j\n            k += 1\n            \n    # Helper: Calculate squared pairwise distances\n    def get_dists_sq(flat_x):\n        x = flat_x.reshape((N, dim))\n        diff = x[idx_i] - x[idx_j]\n        return np.sum(diff**2, axis=1)\n\n    # ---------------------------------------------------------\n    # Phase 1: Generate a high-quality starting point (\"trial_8_0\")\n    # ---------------------------------------------------------\n    # We use a Riesz energy minimization (soft potential) to find a good topology.\n    # We test both random spherical and center-point topologies.\n    \n    def spread_energy(flat_x):\n        d2 = get_dists_sq(flat_x)\n        d2 = np.maximum(d2, 1e-9)\n        # Riesz energy with s=12 (1/r^12 = 1/(d^2)^6) simulates hard spheres\n        return np.sum(d2**(-6))\n\n    def spread_grad(flat_x):\n        x = flat_x.reshape((N, dim))\n        d2 = get_dists_sq(flat_x)\n        d2 = np.maximum(d2, 1e-9)\n        \n        # Gradient of sum(d2^-6)\n        factors = -12.0 * (d2**(-7)) # scalar factors for each pair\n        diff = x[idx_i] - x[idx_j]\n        \n        grad = np.zeros((N, dim))\n        wd = diff * factors[:, None]\n        np.add.at(grad, idx_i, wd)\n        np.add.at(grad, idx_j, -wd)\n        return grad.flatten()\n\n    best_seed_coords = None\n    best_seed_score = -1.0\n    \n    # Initialization seeds: 3 random, 3 with a centered point\n    seeds = []\n    for _ in range(3):\n        seeds.append(np.random.randn(N, dim))\n    for _ in range(3):\n        s = np.random.randn(N, dim)\n        s[0] = [0, 0, 0] # Pin one to center\n        seeds.append(s)\n        \n    t_start_global = time.time()\n    \n    # Quick pre-optimization to find best topology\n    for seed in seeds:\n        if time.time() - t_start_global > 15: break\n        \n        try:\n            res = minimize(spread_energy, seed.flatten(), jac=spread_grad, \n                           method='L-BFGS-B', options={'maxiter': 200})\n            pts = res.x.reshape((N, dim))\n            \n            # Normalize max distance to 1.0\n            d2 = get_dists_sq(pts.flatten())\n            max_d2 = np.max(d2)\n            if max_d2 > 1e-9:\n                pts /= np.sqrt(max_d2)\n            \n            # Score = (min/max)^2 = min_d2 (since max_d2 normalized to 1)\n            score = np.min(get_dists_sq(pts.flatten()))\n            \n            if score > best_seed_score:\n                best_seed_score = score\n                best_seed_coords = pts.flatten()\n        except:\n            continue\n            \n    # This represents the best configuration found before polishing\n    trial_8_0 = best_seed_coords if best_seed_coords is not None else np.random.randn(N*dim)\n\n    # ---------------------------------------------------------\n    # Phase 2: Polishing (SLSQP with Slack Variable)\n    # ---------------------------------------------------------\n    # Formulation:\n    # Maximize t\n    # Subject to: \n    #   ||x_i - x_j||^2 >= t\n    #   ||x_i - x_j||^2 <= 1.0\n    \n    def objective(vars):\n        # vars = [coords..., t]\n        return -vars[-1] # Maximize t\n        \n    def obj_jac(vars):\n        grad = np.zeros(len(vars))\n        grad[-1] = -1.0\n        return grad\n        \n    def constraints(vars):\n        x = vars[:-1]\n        t = vars[-1]\n        d2 = get_dists_sq(x)\n        # Constraints must be >= 0\n        return np.concatenate([d2 - t, 1.0 - d2])\n        \n    def constraints_jac(vars):\n        x = vars[:-1].reshape((N, dim))\n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        diff = x[idx_i] - x[idx_j]\n        \n        # We fill the Jacobian matrix. \n        # Rows 0 to n_pairs-1: d2 - t >= 0\n        # Rows n_pairs to end: 1 - d2 >= 0\n        \n        for k in range(n_pairs):\n            i_idx = idx_i[k]\n            j_idx = idx_j[k]\n            \n            # Derivatives of d^2_ij w.r.t x_i and x_j\n            grad_i = 2 * diff[k]\n            grad_j = -2 * diff[k]\n            \n            # Constraint 1: d^2 - t\n            jac[k, 3*i_idx:3*i_idx+3] = grad_i\n            jac[k, 3*j_idx:3*j_idx+3] = grad_j\n            jac[k, -1] = -1.0\n            \n            # Constraint 2: 1 - d^2\n            jac[k + n_pairs, 3*i_idx:3*i_idx+3] = -grad_i\n            jac[k + n_pairs, 3*j_idx:3*j_idx+3] = -grad_j\n            \n        return jac\n        \n    cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n    \n    best_polished_coords = trial_8_0.copy()\n    \n    # Calculate initial score\n    d2_init = get_dists_sq(trial_8_0)\n    best_score = np.min(d2_init) / np.max(d2_init)\n    \n    # Generate starts: 1 clean + 4 perturbed\n    starts = [trial_8_0]\n    for _ in range(4):\n        pert = np.random.randn(3*N) * 1e-8\n        starts.append(trial_8_0 + pert)\n        \n    for x_start_coords in starts:\n        if time.time() - t_start_global > 58: break\n        \n        # Normalize start configuration to be strictly feasible with constraints\n        d2_s = get_dists_sq(x_start_coords)\n        max_d2_s = np.max(d2_s)\n        x_start_coords /= np.sqrt(max_d2_s)\n        \n        # Initial slack variable t slightly below current min distance\n        d2_s = get_dists_sq(x_start_coords)\n        t_start = np.min(d2_s) * 0.99 \n        \n        x0 = np.concatenate([x_start_coords, [t_start]])\n        \n        try:\n            res = minimize(\n                objective, \n                x0, \n                jac=obj_jac, \n                constraints=cons, \n                method='SLSQP',\n                options={'ftol': 1e-15, 'eps': 1e-15, 'maxiter': 500}\n            )\n            \n            p_coords = res.x[:-1]\n            \n            # Evaluate result\n            d2_p = get_dists_sq(p_coords)\n            min_p = np.min(d2_p)\n            max_p = np.max(d2_p)\n            \n            # Enforce strict normalization for scoring\n            if max_p > 1.0:\n                scale = np.sqrt(max_p)\n                p_coords /= scale\n                min_p /= (scale**2)\n                max_p = 1.0\n                \n            current_score = min_p / max_p\n            \n            if current_score > best_score:\n                best_score = current_score\n                best_polished_coords = p_coords\n                \n        except Exception:\n            continue\n\n    return best_polished_coords.reshape((N, 3))",
  "metrics": {
    "valid": true,
    "score": 0.9889612566135042,
    "min_max_ratio": 0.23739724472246054,
    "min_distance": 0.4872342811445645,
    "max_distance": 1.0,
    "eval_time": 0.4634249210357666,
    "error": null
  },
  "prompt": "Take the coordinates from trial_8_0, and perform a 'polishing' search. Use a multi-start SLSQP where each start is a tiny perturbation (1e-8) of the best coordinates. Use the slack variable formulation and maximize the minimum distance while keeping max distance <= 1.0. Set ftol and eps to 1e-15.",
  "response": "An algorithm to maximize the squared ratio of minimum to maximum pairwise distance for 14 points in 3D space.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Generates 14 points in 3D space to maximize the squared ratio \n    (min_dist / max_dist)^2 using a multi-start SLSQP polishing strategy.\n    \"\"\"\n    N = 14\n    dim = 3\n    n_pairs = N * (N - 1) // 2\n    \n    # Precompute pair indices for vectorized distance calculations\n    idx_i = np.zeros(n_pairs, dtype=int)\n    idx_j = np.zeros(n_pairs, dtype=int)\n    k = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i[k] = i\n            idx_j[k] = j\n            k += 1\n            \n    # Helper: Calculate squared pairwise distances\n    def get_dists_sq(flat_x):\n        x = flat_x.reshape((N, dim))\n        diff = x[idx_i] - x[idx_j]\n        return np.sum(diff**2, axis=1)\n\n    # ---------------------------------------------------------\n    # Phase 1: Generate a high-quality starting point (\"trial_8_0\")\n    # ---------------------------------------------------------\n    # We use a Riesz energy minimization (soft potential) to find a good topology.\n    # We test both random spherical and center-point topologies.\n    \n    def spread_energy(flat_x):\n        d2 = get_dists_sq(flat_x)\n        d2 = np.maximum(d2, 1e-9)\n        # Riesz energy with s=12 (1/r^12 = 1/(d^2)^6) simulates hard spheres\n        return np.sum(d2**(-6))\n\n    def spread_grad(flat_x):\n        x = flat_x.reshape((N, dim))\n        d2 = get_dists_sq(flat_x)\n        d2 = np.maximum(d2, 1e-9)\n        \n        # Gradient of sum(d2^-6)\n        factors = -12.0 * (d2**(-7)) # scalar factors for each pair\n        diff = x[idx_i] - x[idx_j]\n        \n        grad = np.zeros((N, dim))\n        wd = diff * factors[:, None]\n        np.add.at(grad, idx_i, wd)\n        np.add.at(grad, idx_j, -wd)\n        return grad.flatten()\n\n    best_seed_coords = None\n    best_seed_score = -1.0\n    \n    # Initialization seeds: 3 random, 3 with a centered point\n    seeds = []\n    for _ in range(3):\n        seeds.append(np.random.randn(N, dim))\n    for _ in range(3):\n        s = np.random.randn(N, dim)\n        s[0] = [0, 0, 0] # Pin one to center\n        seeds.append(s)\n        \n    t_start_global = time.time()\n    \n    # Quick pre-optimization to find best topology\n    for seed in seeds:\n        if time.time() - t_start_global > 15: break\n        \n        try:\n            res = minimize(spread_energy, seed.flatten(), jac=spread_grad, \n                           method='L-BFGS-B', options={'maxiter': 200})\n            pts = res.x.reshape((N, dim))\n            \n            # Normalize max distance to 1.0\n            d2 = get_dists_sq(pts.flatten())\n            max_d2 = np.max(d2)\n            if max_d2 > 1e-9:\n                pts /= np.sqrt(max_d2)\n            \n            # Score = (min/max)^2 = min_d2 (since max_d2 normalized to 1)\n            score = np.min(get_dists_sq(pts.flatten()))\n            \n            if score > best_seed_score:\n                best_seed_score = score\n                best_seed_coords = pts.flatten()\n        except:\n            continue\n            \n    # This represents the best configuration found before polishing\n    trial_8_0 = best_seed_coords if best_seed_coords is not None else np.random.randn(N*dim)\n\n    # ---------------------------------------------------------\n    # Phase 2: Polishing (SLSQP with Slack Variable)\n    # ---------------------------------------------------------\n    # Formulation:\n    # Maximize t\n    # Subject to: \n    #   ||x_i - x_j||^2 >= t\n    #   ||x_i - x_j||^2 <= 1.0\n    \n    def objective(vars):\n        # vars = [coords..., t]\n        return -vars[-1] # Maximize t\n        \n    def obj_jac(vars):\n        grad = np.zeros(len(vars))\n        grad[-1] = -1.0\n        return grad\n        \n    def constraints(vars):\n        x = vars[:-1]\n        t = vars[-1]\n        d2 = get_dists_sq(x)\n        # Constraints must be >= 0\n        return np.concatenate([d2 - t, 1.0 - d2])\n        \n    def constraints_jac(vars):\n        x = vars[:-1].reshape((N, dim))\n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        diff = x[idx_i] - x[idx_j]\n        \n        # We fill the Jacobian matrix. \n        # Rows 0 to n_pairs-1: d2 - t >= 0\n        # Rows n_pairs to end: 1 - d2 >= 0\n        \n        for k in range(n_pairs):\n            i_idx = idx_i[k]\n            j_idx = idx_j[k]\n            \n            # Derivatives of d^2_ij w.r.t x_i and x_j\n            grad_i = 2 * diff[k]\n            grad_j = -2 * diff[k]\n            \n            # Constraint 1: d^2 - t\n            jac[k, 3*i_idx:3*i_idx+3] = grad_i\n            jac[k, 3*j_idx:3*j_idx+3] = grad_j\n            jac[k, -1] = -1.0\n            \n            # Constraint 2: 1 - d^2\n            jac[k + n_pairs, 3*i_idx:3*i_idx+3] = -grad_i\n            jac[k + n_pairs, 3*j_idx:3*j_idx+3] = -grad_j\n            \n        return jac\n        \n    cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n    \n    best_polished_coords = trial_8_0.copy()\n    \n    # Calculate initial score\n    d2_init = get_dists_sq(trial_8_0)\n    best_score = np.min(d2_init) / np.max(d2_init)\n    \n    # Generate starts: 1 clean + 4 perturbed\n    starts = [trial_8_0]\n    for _ in range(4):\n        pert = np.random.randn(3*N) * 1e-8\n        starts.append(trial_8_0 + pert)\n        \n    for x_start_coords in starts:\n        if time.time() - t_start_global > 58: break\n        \n        # Normalize start configuration to be strictly feasible with constraints\n        d2_s = get_dists_sq(x_start_coords)\n        max_d2_s = np.max(d2_s)\n        x_start_coords /= np.sqrt(max_d2_s)\n        \n        # Initial slack variable t slightly below current min distance\n        d2_s = get_dists_sq(x_start_coords)\n        t_start = np.min(d2_s) * 0.99 \n        \n        x0 = np.concatenate([x_start_coords, [t_start]])\n        \n        try:\n            res = minimize(\n                objective, \n                x0, \n                jac=obj_jac, \n                constraints=cons, \n                method='SLSQP',\n                options={'ftol': 1e-15, 'eps': 1e-15, 'maxiter': 500}\n            )\n            \n            p_coords = res.x[:-1]\n            \n            # Evaluate result\n            d2_p = get_dists_sq(p_coords)\n            min_p = np.min(d2_p)\n            max_p = np.max(d2_p)\n            \n            # Enforce strict normalization for scoring\n            if max_p > 1.0:\n                scale = np.sqrt(max_p)\n                p_coords /= scale\n                min_p /= (scale**2)\n                max_p = 1.0\n                \n            current_score = min_p / max_p\n            \n            if current_score > best_score:\n                best_score = current_score\n                best_polished_coords = p_coords\n                \n        except Exception:\n            continue\n\n    return best_polished_coords.reshape((N, 3))\n```",
  "reasoning": "An algorithm to maximize the squared ratio of minimum to maximum pairwise distance for 14 points in 3D space.",
  "timestamp": "2026-01-21T17:59:31.953858",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 249,
        "candidates_token_count": 2312,
        "thoughts_token_count": 9500
      },
      "response_text_len": 6976
    }
  }
}