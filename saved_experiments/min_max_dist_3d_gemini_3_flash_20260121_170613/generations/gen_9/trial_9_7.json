{
  "trial_id": "trial_9_7",
  "generation": 9,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The approach uses a SoftMin/SoftMax ratio (LogSumExp) optimized with L-BFGS-B across multiple\n    initializations, followed by a final refinement using SLSQP to maximize the true minimum distance\n    subject to a maximum diameter constraint.\n    \"\"\"\n    n = 14\n    start_time = time.time()\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the exact squared ratio (min dist / max dist)^2.\"\"\"\n        pts = pts.reshape((n, 3))\n        dists_sq = np.sum((pts[:, None] - pts[None, :])**2, axis=-1)\n        dists_sq = dists_sq[np.triu_indices(n, k=1)]\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def objective(pts, k):\n        \"\"\"Differentiable approximation of -(min_dist^2 / max_dist^2) using LogSumExp.\"\"\"\n        pts = pts.reshape((n, 3))\n        # Compute all pairwise squared distances\n        dists_sq = np.sum((pts[:, None] - pts[None, :])**2, axis=-1)[np.triu_indices(n, k=1)]\n        \n        # SoftMin using LogSumExp trick for numerical stability\n        m_min = np.min(dists_sq)\n        s_min = m_min - np.log(np.sum(np.exp(-k * (dists_sq - m_min)))) / k\n        \n        # SoftMax using LogSumExp trick for numerical stability\n        m_max = np.max(dists_sq)\n        s_max = m_max + np.log(np.sum(np.exp(k * (dists_sq - m_max)))) / k\n        \n        # Minimize the negative ratio\n        return -s_min / s_max\n\n    def slsqp_obj(x):\n        \"\"\"Objective for SLSQP: maximize the minimum squared distance variable t.\"\"\"\n        return -x[-1]\n        \n    def slsqp_constr(x):\n        \"\"\"Constraints for SLSQP: all pairwise squared distances must be within [t, 1.0].\"\"\"\n        pts = x[:n*3].reshape((n, 3))\n        t = x[-1]\n        dists_sq = np.sum((pts[:, None] - pts[None, :])**2, axis=-1)[np.triu_indices(n, k=1)]\n        # c1: dists_sq >= t (91 constraints)\n        # c2: 1.0 >= dists_sq (91 constraints)\n        return np.concatenate([dists_sq - t, 1.0 - dists_sq])\n\n    best_X = None\n    best_val = -1\n    \n    # Generate initial configurations to avoid local optima\n    initial_configs = []\n    \n    # 1. Fibonacci spiral on a sphere of radius 0.5 (13 points) + 1 point at the origin\n    phi = np.pi * (3.0 - np.sqrt(5.0))\n    y = np.linspace(1 - 1/13, 1/13 - 1, 13)\n    radius = np.sqrt(np.maximum(0, 1 - y**2))\n    theta = phi * np.arange(13)\n    X_13 = np.stack([radius * np.cos(theta), y, radius * np.sin(theta)], axis=1) * 0.5\n    initial_configs.append(np.vstack([X_13, [[0, 0, 0]]]))\n    \n    # 2. Fibonacci spiral on a sphere of radius 0.5 (14 points)\n    y2 = np.linspace(1 - 1/14, 1/14 - 1, 14)\n    radius2 = np.sqrt(np.maximum(0, 1 - y2**2))\n    theta2 = phi * np.arange(14)\n    initial_configs.append(np.stack([radius2 * np.cos(theta2), y2, radius2 * np.sin(theta2)], axis=1) * 0.5)\n    \n    # 3. Random uniform points\n    for _ in range(4):\n        initial_configs.append(np.random.uniform(-0.5, 0.5, (n, 3)))\n        \n    # Phase 1: Global search with SoftMin optimization\n    for X_init in initial_configs:\n        # Check time to ensure completion within 60s\n        if time.time() - start_time > 45:\n            break\n            \n        X = X_init.copy()\n        # Use two levels of sharpness k to refine the configuration\n        for k in [20, 60]:\n            res = minimize(objective, X.flatten(), args=(k,), method='L-BFGS-B', options={'maxiter': 100})\n            if res.success:\n                X = res.x.reshape((n, 3))\n        \n        val = get_ratio_sq(X)\n        if val > best_val:\n            best_val = val\n            best_X = X\n            \n    # Phase 2: Local refinement with SLSQP\n    # Normalize the best candidate so its maximum pairwise distance is exactly 1.0\n    dists_sq = np.sum((best_X[:, None] - best_X[None, :])**2, axis=-1)[np.triu_indices(n, k=1)]\n    max_d_sq = np.max(dists_sq)\n    best_X_scaled = best_X / np.sqrt(max_d_sq)\n    \n    # Pack points and the min-dist variable t into a single vector for SLSQP\n    x0 = np.zeros(n * 3 + 1)\n    x0[:n*3] = best_X_scaled.flatten()\n    dists_sq_scaled = np.sum((best_X_scaled[:, None] - best_X_scaled[None, :])**2, axis=-1)[np.triu_indices(n, k=1)]\n    x0[n*3] = np.min(dists_sq_scaled)\n    \n    # Refine the point positions to maximize the minimum distance\n    res = minimize(slsqp_obj, x0, method='SLSQP', constraints={'type': 'ineq', 'fun': slsqp_constr}, options={'maxiter': 200})\n    \n    if res.success:\n        final_X = res.x[:n*3].reshape((n, 3))\n    else:\n        final_X = best_X_scaled\n            \n    return final_X",
  "metrics": {
    "valid": true,
    "score": 0.9910642095771751,
    "min_max_ratio": 0.23790205240427603,
    "min_distance": 0.487752039878264,
    "max_distance": 1.0000000000023783,
    "eval_time": 2.02616810798645,
    "error": null
  },
  "prompt": "Maximize the minimum pairwise distance for 14 points in 3D. Use the 'LogSumExp' (SoftMin) approach as a differentiable approximation of the minimum distance, but gradually increase the sharpness parameter (k) to approach the true minimum. Finish with an SLSQP polish.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The approach uses a SoftMin/SoftMax ratio (LogSumExp) optimized with L-BFGS-B across multiple\n    initializations, followed by a final refinement using SLSQP to maximize the true minimum distance\n    subject to a maximum diameter constraint.\n    \"\"\"\n    n = 14\n    start_time = time.time()\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the exact squared ratio (min dist / max dist)^2.\"\"\"\n        pts = pts.reshape((n, 3))\n        dists_sq = np.sum((pts[:, None] - pts[None, :])**2, axis=-1)\n        dists_sq = dists_sq[np.triu_indices(n, k=1)]\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def objective(pts, k):\n        \"\"\"Differentiable approximation of -(min_dist^2 / max_dist^2) using LogSumExp.\"\"\"\n        pts = pts.reshape((n, 3))\n        # Compute all pairwise squared distances\n        dists_sq = np.sum((pts[:, None] - pts[None, :])**2, axis=-1)[np.triu_indices(n, k=1)]\n        \n        # SoftMin using LogSumExp trick for numerical stability\n        m_min = np.min(dists_sq)\n        s_min = m_min - np.log(np.sum(np.exp(-k * (dists_sq - m_min)))) / k\n        \n        # SoftMax using LogSumExp trick for numerical stability\n        m_max = np.max(dists_sq)\n        s_max = m_max + np.log(np.sum(np.exp(k * (dists_sq - m_max)))) / k\n        \n        # Minimize the negative ratio\n        return -s_min / s_max\n\n    def slsqp_obj(x):\n        \"\"\"Objective for SLSQP: maximize the minimum squared distance variable t.\"\"\"\n        return -x[-1]\n        \n    def slsqp_constr(x):\n        \"\"\"Constraints for SLSQP: all pairwise squared distances must be within [t, 1.0].\"\"\"\n        pts = x[:n*3].reshape((n, 3))\n        t = x[-1]\n        dists_sq = np.sum((pts[:, None] - pts[None, :])**2, axis=-1)[np.triu_indices(n, k=1)]\n        # c1: dists_sq >= t (91 constraints)\n        # c2: 1.0 >= dists_sq (91 constraints)\n        return np.concatenate([dists_sq - t, 1.0 - dists_sq])\n\n    best_X = None\n    best_val = -1\n    \n    # Generate initial configurations to avoid local optima\n    initial_configs = []\n    \n    # 1. Fibonacci spiral on a sphere of radius 0.5 (13 points) + 1 point at the origin\n    phi = np.pi * (3.0 - np.sqrt(5.0))\n    y = np.linspace(1 - 1/13, 1/13 - 1, 13)\n    radius = np.sqrt(np.maximum(0, 1 - y**2))\n    theta = phi * np.arange(13)\n    X_13 = np.stack([radius * np.cos(theta), y, radius * np.sin(theta)], axis=1) * 0.5\n    initial_configs.append(np.vstack([X_13, [[0, 0, 0]]]))\n    \n    # 2. Fibonacci spiral on a sphere of radius 0.5 (14 points)\n    y2 = np.linspace(1 - 1/14, 1/14 - 1, 14)\n    radius2 = np.sqrt(np.maximum(0, 1 - y2**2))\n    theta2 = phi * np.arange(14)\n    initial_configs.append(np.stack([radius2 * np.cos(theta2), y2, radius2 * np.sin(theta2)], axis=1) * 0.5)\n    \n    # 3. Random uniform points\n    for _ in range(4):\n        initial_configs.append(np.random.uniform(-0.5, 0.5, (n, 3)))\n        \n    # Phase 1: Global search with SoftMin optimization\n    for X_init in initial_configs:\n        # Check time to ensure completion within 60s\n        if time.time() - start_time > 45:\n            break\n            \n        X = X_init.copy()\n        # Use two levels of sharpness k to refine the configuration\n        for k in [20, 60]:\n            res = minimize(objective, X.flatten(), args=(k,), method='L-BFGS-B', options={'maxiter': 100})\n            if res.success:\n                X = res.x.reshape((n, 3))\n        \n        val = get_ratio_sq(X)\n        if val > best_val:\n            best_val = val\n            best_X = X\n            \n    # Phase 2: Local refinement with SLSQP\n    # Normalize the best candidate so its maximum pairwise distance is exactly 1.0\n    dists_sq = np.sum((best_X[:, None] - best_X[None, :])**2, axis=-1)[np.triu_indices(n, k=1)]\n    max_d_sq = np.max(dists_sq)\n    best_X_scaled = best_X / np.sqrt(max_d_sq)\n    \n    # Pack points and the min-dist variable t into a single vector for SLSQP\n    x0 = np.zeros(n * 3 + 1)\n    x0[:n*3] = best_X_scaled.flatten()\n    dists_sq_scaled = np.sum((best_X_scaled[:, None] - best_X_scaled[None, :])**2, axis=-1)[np.triu_indices(n, k=1)]\n    x0[n*3] = np.min(dists_sq_scaled)\n    \n    # Refine the point positions to maximize the minimum distance\n    res = minimize(slsqp_obj, x0, method='SLSQP', constraints={'type': 'ineq', 'fun': slsqp_constr}, options={'maxiter': 200})\n    \n    if res.success:\n        final_X = res.x[:n*3].reshape((n, 3))\n    else:\n        final_X = best_X_scaled\n            \n    return final_X\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:59:59.897120",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 230,
        "candidates_token_count": 1660,
        "thoughts_token_count": 19267
      },
      "response_text_len": 4694
    }
  }
}