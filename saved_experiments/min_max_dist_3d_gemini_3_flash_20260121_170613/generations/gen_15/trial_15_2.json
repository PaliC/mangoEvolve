{
  "trial_id": "trial_15_2",
  "generation": 15,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Returns a numpy array of shape (14, 3) representing 14 points in 3D space\n    that maximize the squared ratio (min_dist / max_dist)^2.\n    \n    The configuration is based on a Bicapped Hexagonal Antiprism (D6d symmetry),\n    optimized using SLSQP.\n    \"\"\"\n    \n    # We parametrize the Bicapped Hexagonal Antiprism with 3 variables + 1 objective variable:\n    # x = [R, h, H, S]\n    # R: Radius of the two hexagonal rings\n    # h: Half-height of the antiprism (rings are at z = +h and z = -h)\n    # H: Height of the two poles (poles are at z = +H and z = -H)\n    # S: The target squared minimum distance (we maximize this)\n    \n    # To handle the ratio (min/max), we fix the scale by constraining the\n    # maximum squared distance to be <= 1.0, and then maximize the minimum squared distance S.\n    \n    def objective(x):\n        # Minimize negative S -> Maximize S\n        return -x[3]\n    \n    # Constraints dictionary for SLSQP\n    # 'fun' must be >= 0\n    cons = [\n        # --- Constraints ensuring Max Distance^2 <= 1 ---\n        \n        # 1. Pole to Pole distance: (2H)^2\n        {'type': 'ineq', 'fun': lambda x: 1.0 - 4 * x[2]**2},\n        \n        # 2. Pole to Farthest Ring Point: R^2 + (H + h)^2\n        {'type': 'ineq', 'fun': lambda x: 1.0 - (x[0]**2 + (x[2] + x[1])**2)},\n        \n        # 3. Ring Point to Farthest Point on Other Ring:\n        #    Angle diff 150 deg (5pi/6). d^2 = (2 + sqrt(3))R^2 + (2h)^2\n        {'type': 'ineq', 'fun': lambda x: 1.0 - ((2 + np.sqrt(3)) * x[0]**2 + 4 * x[1]**2)},\n        \n        # 4. Ring Diameter (Max intra-ring): (2R)^2\n        {'type': 'ineq', 'fun': lambda x: 1.0 - 4 * x[0]**2},\n        \n        \n        # --- Constraints ensuring Min Distance^2 >= S ---\n        \n        # 5. Ring Edge Length (intra-ring neighbor): R^2\n        {'type': 'ineq', 'fun': lambda x: x[0]**2 - x[3]},\n        \n        # 6. Ring to Ring Closest Point:\n        #    Angle diff 30 deg (pi/6). d^2 = (2 - sqrt(3))R^2 + (2h)^2\n        {'type': 'ineq', 'fun': lambda x: ((2 - np.sqrt(3)) * x[0]**2 + 4 * x[1]**2) - x[3]},\n        \n        # 7. Pole to Ring Closest Point: R^2 + (H - h)^2\n        {'type': 'ineq', 'fun': lambda x: (x[0]**2 + (x[2] - x[1])**2) - x[3]},\n        \n        # 8. Pole to Pole (prevent collapse if H is small): (2H)^2\n        {'type': 'ineq', 'fun': lambda x: 4 * x[2]**2 - x[3]}\n    ]\n    \n    # Initial guess:\n    # R ~ 0.4 (since 4R^2 <= 1)\n    # h ~ 0.2 (rings relatively close)\n    # H ~ 0.45 (poles further out)\n    # S ~ 0.15 (expected squared ratio)\n    x0 = [0.4, 0.2, 0.45, 0.15]\n    \n    # Bounds: R, h, H > 0. S between 0 and 1.\n    bounds = [\n        (1e-4, None), # R\n        (0.0, None),  # h\n        (1e-4, None), # H\n        (0.0, 1.0)    # S\n    ]\n    \n    # Optimize using SLSQP\n    res = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=cons, tol=1e-10, options={'maxiter': 1000})\n    \n    R_opt, h_opt, H_opt, _ = res.x\n    \n    # Generate the points based on optimal parameters\n    points = []\n    \n    # Top Ring (z = h)\n    for k in range(6):\n        theta = k * np.pi / 3\n        points.append([R_opt * np.cos(theta), R_opt * np.sin(theta), h_opt])\n        \n    # Bottom Ring (z = -h), twisted by pi/6 (30 degrees)\n    for k in range(6):\n        theta = k * np.pi / 3 + np.pi / 6\n        points.append([R_opt * np.cos(theta), R_opt * np.sin(theta), -h_opt])\n        \n    # Two Poles (z = H, z = -H)\n    points.append([0.0, 0.0, H_opt])\n    points.append([0.0, 0.0, -H_opt])\n    \n    return np.array(points)",
  "metrics": {
    "valid": true,
    "score": 0.9331888308441697,
    "min_max_ratio": 0.2240092377397943,
    "min_distance": 0.4732961416912109,
    "max_distance": 0.9999999999999832,
    "eval_time": 0.620887041091919,
    "error": null
  },
  "prompt": "Explore the Bicapped Hexagonal Antiprism (D6d symmetry) for 14 points. Parameterize the points using height z and radii R for the two hexagonal rings and the two poles. Optimize these parameters carefully using SLSQP to find the maximum possible ratio.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Returns a numpy array of shape (14, 3) representing 14 points in 3D space\n    that maximize the squared ratio (min_dist / max_dist)^2.\n    \n    The configuration is based on a Bicapped Hexagonal Antiprism (D6d symmetry),\n    optimized using SLSQP.\n    \"\"\"\n    \n    # We parametrize the Bicapped Hexagonal Antiprism with 3 variables + 1 objective variable:\n    # x = [R, h, H, S]\n    # R: Radius of the two hexagonal rings\n    # h: Half-height of the antiprism (rings are at z = +h and z = -h)\n    # H: Height of the two poles (poles are at z = +H and z = -H)\n    # S: The target squared minimum distance (we maximize this)\n    \n    # To handle the ratio (min/max), we fix the scale by constraining the\n    # maximum squared distance to be <= 1.0, and then maximize the minimum squared distance S.\n    \n    def objective(x):\n        # Minimize negative S -> Maximize S\n        return -x[3]\n    \n    # Constraints dictionary for SLSQP\n    # 'fun' must be >= 0\n    cons = [\n        # --- Constraints ensuring Max Distance^2 <= 1 ---\n        \n        # 1. Pole to Pole distance: (2H)^2\n        {'type': 'ineq', 'fun': lambda x: 1.0 - 4 * x[2]**2},\n        \n        # 2. Pole to Farthest Ring Point: R^2 + (H + h)^2\n        {'type': 'ineq', 'fun': lambda x: 1.0 - (x[0]**2 + (x[2] + x[1])**2)},\n        \n        # 3. Ring Point to Farthest Point on Other Ring:\n        #    Angle diff 150 deg (5pi/6). d^2 = (2 + sqrt(3))R^2 + (2h)^2\n        {'type': 'ineq', 'fun': lambda x: 1.0 - ((2 + np.sqrt(3)) * x[0]**2 + 4 * x[1]**2)},\n        \n        # 4. Ring Diameter (Max intra-ring): (2R)^2\n        {'type': 'ineq', 'fun': lambda x: 1.0 - 4 * x[0]**2},\n        \n        \n        # --- Constraints ensuring Min Distance^2 >= S ---\n        \n        # 5. Ring Edge Length (intra-ring neighbor): R^2\n        {'type': 'ineq', 'fun': lambda x: x[0]**2 - x[3]},\n        \n        # 6. Ring to Ring Closest Point:\n        #    Angle diff 30 deg (pi/6). d^2 = (2 - sqrt(3))R^2 + (2h)^2\n        {'type': 'ineq', 'fun': lambda x: ((2 - np.sqrt(3)) * x[0]**2 + 4 * x[1]**2) - x[3]},\n        \n        # 7. Pole to Ring Closest Point: R^2 + (H - h)^2\n        {'type': 'ineq', 'fun': lambda x: (x[0]**2 + (x[2] - x[1])**2) - x[3]},\n        \n        # 8. Pole to Pole (prevent collapse if H is small): (2H)^2\n        {'type': 'ineq', 'fun': lambda x: 4 * x[2]**2 - x[3]}\n    ]\n    \n    # Initial guess:\n    # R ~ 0.4 (since 4R^2 <= 1)\n    # h ~ 0.2 (rings relatively close)\n    # H ~ 0.45 (poles further out)\n    # S ~ 0.15 (expected squared ratio)\n    x0 = [0.4, 0.2, 0.45, 0.15]\n    \n    # Bounds: R, h, H > 0. S between 0 and 1.\n    bounds = [\n        (1e-4, None), # R\n        (0.0, None),  # h\n        (1e-4, None), # H\n        (0.0, 1.0)    # S\n    ]\n    \n    # Optimize using SLSQP\n    res = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=cons, tol=1e-10, options={'maxiter': 1000})\n    \n    R_opt, h_opt, H_opt, _ = res.x\n    \n    # Generate the points based on optimal parameters\n    points = []\n    \n    # Top Ring (z = h)\n    for k in range(6):\n        theta = k * np.pi / 3\n        points.append([R_opt * np.cos(theta), R_opt * np.sin(theta), h_opt])\n        \n    # Bottom Ring (z = -h), twisted by pi/6 (30 degrees)\n    for k in range(6):\n        theta = k * np.pi / 3 + np.pi / 6\n        points.append([R_opt * np.cos(theta), R_opt * np.sin(theta), -h_opt])\n        \n    # Two Poles (z = H, z = -H)\n    points.append([0.0, 0.0, H_opt])\n    points.append([0.0, 0.0, -H_opt])\n    \n    return np.array(points)\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:35:10.023529",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 227,
        "candidates_token_count": 1373,
        "thoughts_token_count": 14630
      },
      "response_text_len": 3625
    }
  }
}