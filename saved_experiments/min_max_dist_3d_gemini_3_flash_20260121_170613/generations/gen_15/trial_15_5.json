{
  "trial_id": "trial_15_5",
  "generation": 15,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds an arrangement of 14 points in 3D space that maximizes the squared \n    ratio (min pairwise distance / max pairwise distance)^2.\n    \n    The search uses Differential Evolution with a tight population initialized \n    around key geometric configurations like the Fibonacci sphere, \n    the Rhombic Dodecahedron, and a Bicapped Hexagonal Antiprism.\n    \"\"\"\n    \n    def objective(coords):\n        # Reshape flat array back into (14, 3) points\n        pts = coords.reshape((14, 3))\n        # Calculate all pairwise distances\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        m = np.min(dists)\n        M = np.max(dists)\n        if M < 1e-9:\n            return 0\n        # Minimize the negative squared ratio to maximize the ratio\n        return -(m / M)**2\n\n    def get_fibonacci_sphere(n):\n        \"\"\"Generates n points roughly evenly distributed on a unit sphere.\"\"\"\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))  # Golden angle in radians\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            r = np.sqrt(max(0, 1 - y * y))\n            theta = phi * i\n            pts.append([r * np.cos(theta), y, r * np.sin(theta)])\n        return np.array(pts).flatten()\n\n    def get_rhombic_dodecahedron():\n        \"\"\"Generates the 14 vertices of a rhombic dodecahedron.\"\"\"\n        pts = []\n        # 8 vertices of a cube\n        for i in [-0.5, 0.5]:\n            for j in [-0.5, 0.5]:\n                for k in [-0.5, 0.5]:\n                    pts.append([i, j, k])\n        # 6 vertices of an octahedron (scaled to match)\n        pts.extend([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]])\n        return np.array(pts).flatten()\n            \n    def get_hex_antiprism():\n        \"\"\"Generates 14 points in a bicapped hexagonal antiprism configuration.\"\"\"\n        pts = []\n        h, r, cap = 0.4, 1.0, 1.1\n        for i in range(6):\n            # Top ring\n            a1 = i * np.pi / 3\n            pts.append([r * np.cos(a1), r * np.sin(a1), h])\n            # Bottom ring (rotated)\n            a2 = i * np.pi / 3 + np.pi / 6\n            pts.append([r * np.cos(a2), r * np.sin(a2), -h])\n        # Two polar caps\n        pts.append([0, 0, cap])\n        pts.append([0, 0, -cap])\n        return np.array(pts).flatten()\n\n    dim = 42 # 14 points * 3 dimensions\n    # Define a small population as requested\n    pop_size = 15\n    pop = np.zeros((pop_size, dim))\n    \n    # Initialize the population with heuristic guesses\n    pop[0] = get_fibonacci_sphere(14)\n    pop[1] = get_rhombic_dodecahedron()\n    pop[2] = get_hex_antiprism()\n    \n    # Fill the rest of the population with slightly perturbed versions\n    np.random.seed(42)\n    for i in range(3, pop_size):\n        base = pop[i % 3]\n        pop[i] = base + np.random.normal(0, 0.05, dim)\n\n    # Differential Evolution search\n    # strategy='best1bin' focuses on exploiting the best individual found\n    res = differential_evolution(\n        objective,\n        bounds=[(-1.5, 1.5)] * dim,\n        strategy='best1bin',\n        init=pop,\n        popsize=pop_size,\n        maxiter=1000,\n        tol=1e-8,\n        mutation=(0.5, 1.0),\n        recombination=0.7,\n        polish=True # Refines the result using L-BFGS-B\n    )\n    \n    # Return exactly 14 points in 3 dimensions\n    return res.x.reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 0.9147835147874995,
    "min_max_ratio": 0.21959109568328788,
    "min_distance": 1.0053807912605224,
    "max_distance": 2.1454738252839953,
    "eval_time": 0.7426092624664307,
    "error": null
  },
  "prompt": "Use Differential Evolution (scipy.optimize.differential_evolution) to explore the 14-point configuration. Use a very tight population and the 'best1bin' strategy. Initialize the population around the Fibonacci sphere and the Rhombic Dodecahedron to focus the search.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds an arrangement of 14 points in 3D space that maximizes the squared \n    ratio (min pairwise distance / max pairwise distance)^2.\n    \n    The search uses Differential Evolution with a tight population initialized \n    around key geometric configurations like the Fibonacci sphere, \n    the Rhombic Dodecahedron, and a Bicapped Hexagonal Antiprism.\n    \"\"\"\n    \n    def objective(coords):\n        # Reshape flat array back into (14, 3) points\n        pts = coords.reshape((14, 3))\n        # Calculate all pairwise distances\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        m = np.min(dists)\n        M = np.max(dists)\n        if M < 1e-9:\n            return 0\n        # Minimize the negative squared ratio to maximize the ratio\n        return -(m / M)**2\n\n    def get_fibonacci_sphere(n):\n        \"\"\"Generates n points roughly evenly distributed on a unit sphere.\"\"\"\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))  # Golden angle in radians\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            r = np.sqrt(max(0, 1 - y * y))\n            theta = phi * i\n            pts.append([r * np.cos(theta), y, r * np.sin(theta)])\n        return np.array(pts).flatten()\n\n    def get_rhombic_dodecahedron():\n        \"\"\"Generates the 14 vertices of a rhombic dodecahedron.\"\"\"\n        pts = []\n        # 8 vertices of a cube\n        for i in [-0.5, 0.5]:\n            for j in [-0.5, 0.5]:\n                for k in [-0.5, 0.5]:\n                    pts.append([i, j, k])\n        # 6 vertices of an octahedron (scaled to match)\n        pts.extend([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]])\n        return np.array(pts).flatten()\n            \n    def get_hex_antiprism():\n        \"\"\"Generates 14 points in a bicapped hexagonal antiprism configuration.\"\"\"\n        pts = []\n        h, r, cap = 0.4, 1.0, 1.1\n        for i in range(6):\n            # Top ring\n            a1 = i * np.pi / 3\n            pts.append([r * np.cos(a1), r * np.sin(a1), h])\n            # Bottom ring (rotated)\n            a2 = i * np.pi / 3 + np.pi / 6\n            pts.append([r * np.cos(a2), r * np.sin(a2), -h])\n        # Two polar caps\n        pts.append([0, 0, cap])\n        pts.append([0, 0, -cap])\n        return np.array(pts).flatten()\n\n    dim = 42 # 14 points * 3 dimensions\n    # Define a small population as requested\n    pop_size = 15\n    pop = np.zeros((pop_size, dim))\n    \n    # Initialize the population with heuristic guesses\n    pop[0] = get_fibonacci_sphere(14)\n    pop[1] = get_rhombic_dodecahedron()\n    pop[2] = get_hex_antiprism()\n    \n    # Fill the rest of the population with slightly perturbed versions\n    np.random.seed(42)\n    for i in range(3, pop_size):\n        base = pop[i % 3]\n        pop[i] = base + np.random.normal(0, 0.05, dim)\n\n    # Differential Evolution search\n    # strategy='best1bin' focuses on exploiting the best individual found\n    res = differential_evolution(\n        objective,\n        bounds=[(-1.5, 1.5)] * dim,\n        strategy='best1bin',\n        init=pop,\n        popsize=pop_size,\n        maxiter=1000,\n        tol=1e-8,\n        mutation=(0.5, 1.0),\n        recombination=0.7,\n        polish=True # Refines the result using L-BFGS-B\n    )\n    \n    # Return exactly 14 points in 3 dimensions\n    return res.x.reshape((14, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:34:33.547308",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 229,
        "candidates_token_count": 1156,
        "thoughts_token_count": 16092
      },
      "response_text_len": 3510
    }
  }
}