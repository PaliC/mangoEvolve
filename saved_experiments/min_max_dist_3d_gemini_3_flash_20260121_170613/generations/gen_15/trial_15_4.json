{
  "trial_id": "trial_15_4",
  "generation": 15,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses SLSQP with a slack variable across multiple initializations, followed by a Powell refinement \n    to handle the non-smooth nature of the objective function near the optimum.\n    \"\"\"\n    N = 14\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the squared ratio of min distance to max distance.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0:\n            return 0.0\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def solve_slsqp(pts_init, maxiter=200):\n        \"\"\"\n        Local optimization using SLSQP with a slack variable.\n        Maximizes s subject to d_ij^2 >= s and d_ij^2 <= 1.\n        \"\"\"\n        try:\n            # Normalize the initial points so that the maximum distance is 1.0\n            dists_sq_init = pdist(pts_init, 'sqeuclidean')\n            d_max_sq_init = np.max(dists_sq_init)\n            if d_max_sq_init == 0:\n                d_max_sq_init = 1.0\n            pts_init_norm = pts_init / np.sqrt(d_max_sq_init)\n            \n            # Initial slack variable is the minimum squared distance of the normalized set\n            s_init = np.min(pdist(pts_init_norm, 'sqeuclidean'))\n            \n            # Flattened points + slack variable s\n            vars_init = np.concatenate([pts_init_norm.flatten(), [s_init]])\n            \n            def objective(vars):\n                # Maximize the slack variable s\n                return -vars[-1]\n\n            def constraints(vars):\n                pts = vars[:-1].reshape((N, 3))\n                s = vars[-1]\n                d_sq = pdist(pts, 'sqeuclidean')\n                # Constraints: d_ij^2 - s >= 0 (min distance) and 1.0 - d_ij^2 >= 0 (max distance)\n                return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n            # Run SLSQP\n            res = minimize(objective, vars_init, method='SLSQP',\n                           constraints={'type': 'ineq', 'fun': constraints},\n                           options={'maxiter': maxiter, 'ftol': 1e-9})\n            return res.x[:-1].reshape((N, 3))\n        except Exception:\n            return pts_init\n\n    # 1. Fibonacci Sphere Initializations\n    initials = []\n    phi = (1.0 + 5.0**0.5) / 2.0\n    for offset in [0, 0.05, 0.1]:\n        indices = np.arange(N) + 0.5\n        z = 1.0 - 2.0 * indices / N\n        radius = np.sqrt(np.maximum(0, 1.0 - z * z))\n        theta = 2.0 * np.pi * indices / (phi + offset)\n        initials.append(np.stack([radius * np.cos(theta), radius * np.sin(theta), z], axis=1))\n\n    # 2. Geometric Ring Initializations\n    # 1-6-6-1 Ring configuration\n    z_ring1 = np.array([1.0] + [0.5]*6 + [-0.5]*6 + [-1.0])\n    theta_ring1 = np.array([0.0] + [2*np.pi*i/6 for i in range(6)] + [2*np.pi*(i+0.5)/6 for i in range(6)] + [0.0])\n    r_ring1 = np.sqrt(np.maximum(0, 1.0 - z_ring1**2))\n    initials.append(np.stack([r_ring1*np.cos(theta_ring1), r_ring1*np.sin(theta_ring1), z_ring1], axis=1))\n    \n    # 1-4-4-4-1 Ring configuration\n    z_ring2 = np.array([1.0] + [0.6]*4 + [0.0]*4 + [-0.6]*4 + [-1.0])\n    theta_ring2 = np.array([0.0] + [2*np.pi*i/4 for i in range(4)] + [2*np.pi*(i+0.5)/4 for i in range(4)] + [2*np.pi*i/4 for i in range(4)] + [0.0])\n    r_ring2 = np.sqrt(np.maximum(0, 1.0 - z_ring2**2))\n    initials.append(np.stack([r_ring2*np.cos(theta_ring2), r_ring2*np.sin(theta_ring2), z_ring2], axis=1))\n\n    start_time = time.time()\n    best_pts = initials[0]\n    best_ratio = get_ratio_sq(best_pts)\n    \n    # Search through predefined initial configurations\n    for pts_init in initials:\n        if time.time() - start_time > 55:\n            break\n        pts_opt = solve_slsqp(pts_init, maxiter=200)\n        ratio = get_ratio_sq(pts_opt)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_opt\n            \n    # Random perturbations and restarts (Basin-hopping approach)\n    while time.time() - start_time < 48:\n        if np.random.rand() < 0.2:\n            pts_init = np.random.uniform(-1, 1, (N, 3))\n        else:\n            scale = np.random.choice([0.02, 0.05, 0.1])\n            pts_init = best_pts + np.random.normal(0, scale, best_pts.shape)\n            \n        pts_opt = solve_slsqp(pts_init, maxiter=100)\n        ratio = get_ratio_sq(pts_opt)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_opt\n            \n    # Final polishing with SLSQP\n    best_pts = solve_slsqp(best_pts, maxiter=500)\n    \n    # Derivative-free refinement with Powell to polish the non-smooth 'min' boundary\n    try:\n        def neg_ratio(vars):\n            pts = vars.reshape((N, 3))\n            dists_sq = pdist(pts, 'sqeuclidean')\n            if len(dists_sq) == 0:\n                return 0.0\n            return -np.min(dists_sq) / np.max(dists_sq)\n        \n        res_powell = minimize(neg_ratio, best_pts.flatten(), method='Powell', \n                              options={'maxiter': 100, 'xtol': 1e-8})\n        if -res_powell.fun > best_ratio:\n            best_pts = res_powell.x.reshape((N, 3))\n    except Exception:\n        pass\n        \n    return best_pts.reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539164,
    "min_max_ratio": 0.2400508826495846,
    "min_distance": 0.489949877691162,
    "max_distance": 1.0,
    "eval_time": 48.31495189666748,
    "error": null
  },
  "prompt": "Starting from the coordinates in trial_7_5, implement a derivative-free refinement like Nelder-Mead or a custom coordinate descent. Sometimes gradient-based methods like SLSQP struggle with the very last bits of precision due to the non-smooth nature of the 'min' function at the optimum.\n\nCode:\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a high-restart Basin-hopping search with SLSQP local optimization and a slack variable.\n    Initializes with a Fibonacci sphere using the specified golden ratio.\n    \"\"\"\n    N = 14\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the squared ratio of min distance to max distance.\"\"\"\n        if pts.shape[0] < 2:\n            return 0.0\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0:\n            return 0.0\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def solve_with_init(pts_init):\n        \"\"\"\n        Local optimization using SLSQP with a slack variable.\n        Maximizes s subject to d_min^2 >= s and d_max^2 <= 1.\n        \"\"\"\n        def objective(vars):\n            # Maximize the slack variable s\n            return -vars[-1]\n\n        def constraints(vars):\n            pts = vars[:-1].reshape((N, 3))\n            s = vars[-1]\n            d_sq = pdist(pts, 'sqeuclidean')\n            # Constraints: d_ij^2 - s >= 0 (min distance) and 1.0 - d_ij^2 >= 0 (max distance)\n            return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n        # Normalize the initial points so that the maximum distance is 1.0\n        dists_sq_init = pdist(pts_init, 'sqeuclidean')\n        d_max_sq_init = np.max(dists_sq_init)\n        pts_init_norm = pts_init / np.sqrt(d_max_sq_init)\n        \n        # Initial slack variable is the minimum squared distance of the normalized set\n        s_init = np.min(pdist(pts_init_norm, 'sqeuclidean'))\n        \n        # Flattened points + slack variable s\n        vars_init = np.concatenate([pts_init_norm.flatten(), [s_init]])\n        \n        # Run SLSQP\n        res = minimize(objective, vars_init, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options={'maxiter': 400, 'ftol': 1e-8})\n        return res\n\n    # 1. Fibonacci Sphere Initialization\n    # Use the golden ratio specified: (1 + sqrt(5)) / 2 + 0.0\n    phi = (1.0 + 5.0**0.5) / 2.0 + 0.0\n    indices = np.arange(N) + 0.5\n    z = 1.0 - 2.0 * indices / N\n    radius = np.sqrt(np.maximum(0, 1.0 - z * z))\n    theta = 2.0 * np.pi * indices / phi\n    pts_fib = np.stack([radius * np.cos(theta), radius * np.sin(theta), z], axis=1)\n    \n    # Polish the Fibonacci initialization\n    best_pts = pts_fib\n    best_ratio = get_ratio_sq(pts_fib)\n    \n    res = solve_with_init(pts_fib)\n    pts_out = res.x[:-1].reshape((N, 3))\n    ratio = get_ratio_sq(pts_out)\n    if ratio > best_ratio:\n        best_ratio = ratio\n        best_pts = pts_out\n    \n    # 2. High-Restart Basin-Hopping Search\n    start_time = time.time()\n    # Search for up to 50 seconds to ensure completion within the 60s limit\n    while time.time() - start_time < 50:\n        # Strategy A: Perturb the current best solution (Basin-hopping step)\n        scale = np.random.choice([0.02, 0.05, 0.1, 0.15])\n        pts_perturbed = best_pts + np.random.normal(0, scale, best_pts.shape)\n        res = solve_with_init(pts_perturbed)\n        pts_out = res.x[:-1].reshape((N, 3))\n        ratio = get_ratio_sq(pts_out)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_out\n        \n        # Strategy B: Random restart from a uniform distribution occasionally\n        if np.random.rand() < 0.25:\n            pts_rand = np.random.uniform(-0.5, 0.5, (N, 3))\n            res = solve_with_init(pts_rand)\n            pts_out = res.x[:-1].reshape((N, 3))\n            ratio = get_ratio_sq(pts_out)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_pts = pts_out\n                \n    # Return the best point configuration found\n    return best_pts.reshape((14, 3))",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses SLSQP with a slack variable across multiple initializations, followed by a Powell refinement \n    to handle the non-smooth nature of the objective function near the optimum.\n    \"\"\"\n    N = 14\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the squared ratio of min distance to max distance.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0:\n            return 0.0\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def solve_slsqp(pts_init, maxiter=200):\n        \"\"\"\n        Local optimization using SLSQP with a slack variable.\n        Maximizes s subject to d_ij^2 >= s and d_ij^2 <= 1.\n        \"\"\"\n        try:\n            # Normalize the initial points so that the maximum distance is 1.0\n            dists_sq_init = pdist(pts_init, 'sqeuclidean')\n            d_max_sq_init = np.max(dists_sq_init)\n            if d_max_sq_init == 0:\n                d_max_sq_init = 1.0\n            pts_init_norm = pts_init / np.sqrt(d_max_sq_init)\n            \n            # Initial slack variable is the minimum squared distance of the normalized set\n            s_init = np.min(pdist(pts_init_norm, 'sqeuclidean'))\n            \n            # Flattened points + slack variable s\n            vars_init = np.concatenate([pts_init_norm.flatten(), [s_init]])\n            \n            def objective(vars):\n                # Maximize the slack variable s\n                return -vars[-1]\n\n            def constraints(vars):\n                pts = vars[:-1].reshape((N, 3))\n                s = vars[-1]\n                d_sq = pdist(pts, 'sqeuclidean')\n                # Constraints: d_ij^2 - s >= 0 (min distance) and 1.0 - d_ij^2 >= 0 (max distance)\n                return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n            # Run SLSQP\n            res = minimize(objective, vars_init, method='SLSQP',\n                           constraints={'type': 'ineq', 'fun': constraints},\n                           options={'maxiter': maxiter, 'ftol': 1e-9})\n            return res.x[:-1].reshape((N, 3))\n        except Exception:\n            return pts_init\n\n    # 1. Fibonacci Sphere Initializations\n    initials = []\n    phi = (1.0 + 5.0**0.5) / 2.0\n    for offset in [0, 0.05, 0.1]:\n        indices = np.arange(N) + 0.5\n        z = 1.0 - 2.0 * indices / N\n        radius = np.sqrt(np.maximum(0, 1.0 - z * z))\n        theta = 2.0 * np.pi * indices / (phi + offset)\n        initials.append(np.stack([radius * np.cos(theta), radius * np.sin(theta), z], axis=1))\n\n    # 2. Geometric Ring Initializations\n    # 1-6-6-1 Ring configuration\n    z_ring1 = np.array([1.0] + [0.5]*6 + [-0.5]*6 + [-1.0])\n    theta_ring1 = np.array([0.0] + [2*np.pi*i/6 for i in range(6)] + [2*np.pi*(i+0.5)/6 for i in range(6)] + [0.0])\n    r_ring1 = np.sqrt(np.maximum(0, 1.0 - z_ring1**2))\n    initials.append(np.stack([r_ring1*np.cos(theta_ring1), r_ring1*np.sin(theta_ring1), z_ring1], axis=1))\n    \n    # 1-4-4-4-1 Ring configuration\n    z_ring2 = np.array([1.0] + [0.6]*4 + [0.0]*4 + [-0.6]*4 + [-1.0])\n    theta_ring2 = np.array([0.0] + [2*np.pi*i/4 for i in range(4)] + [2*np.pi*(i+0.5)/4 for i in range(4)] + [2*np.pi*i/4 for i in range(4)] + [0.0])\n    r_ring2 = np.sqrt(np.maximum(0, 1.0 - z_ring2**2))\n    initials.append(np.stack([r_ring2*np.cos(theta_ring2), r_ring2*np.sin(theta_ring2), z_ring2], axis=1))\n\n    start_time = time.time()\n    best_pts = initials[0]\n    best_ratio = get_ratio_sq(best_pts)\n    \n    # Search through predefined initial configurations\n    for pts_init in initials:\n        if time.time() - start_time > 55:\n            break\n        pts_opt = solve_slsqp(pts_init, maxiter=200)\n        ratio = get_ratio_sq(pts_opt)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_opt\n            \n    # Random perturbations and restarts (Basin-hopping approach)\n    while time.time() - start_time < 48:\n        if np.random.rand() < 0.2:\n            pts_init = np.random.uniform(-1, 1, (N, 3))\n        else:\n            scale = np.random.choice([0.02, 0.05, 0.1])\n            pts_init = best_pts + np.random.normal(0, scale, best_pts.shape)\n            \n        pts_opt = solve_slsqp(pts_init, maxiter=100)\n        ratio = get_ratio_sq(pts_opt)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_opt\n            \n    # Final polishing with SLSQP\n    best_pts = solve_slsqp(best_pts, maxiter=500)\n    \n    # Derivative-free refinement with Powell to polish the non-smooth 'min' boundary\n    try:\n        def neg_ratio(vars):\n            pts = vars.reshape((N, 3))\n            dists_sq = pdist(pts, 'sqeuclidean')\n            if len(dists_sq) == 0:\n                return 0.0\n            return -np.min(dists_sq) / np.max(dists_sq)\n        \n        res_powell = minimize(neg_ratio, best_pts.flatten(), method='Powell', \n                              options={'maxiter': 100, 'xtol': 1e-8})\n        if -res_powell.fun > best_ratio:\n            best_pts = res_powell.x.reshape((N, 3))\n    except Exception:\n        pass\n        \n    return best_pts.reshape((14, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:35:10.716538",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 1509,
        "candidates_token_count": 1831,
        "thoughts_token_count": 14162
      },
      "response_text_len": 5339
    }
  }
}