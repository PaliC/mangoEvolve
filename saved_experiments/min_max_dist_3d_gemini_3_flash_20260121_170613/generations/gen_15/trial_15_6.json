{
  "trial_id": "trial_15_6",
  "generation": 15,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the ratio\n    (min pairwise distance / max pairwise distance)^2.\n    The strategy uses a LogSumExp approximation for initial smoothing and\n    refines the configuration with SLSQP.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    def get_ratio_sq(pts):\n        d_sq = pdist(pts, 'sqeuclidean')\n        return np.min(d_sq) / np.max(d_sq)\n\n    best_pts = np.random.normal(0, 1, (N, dim))\n    best_val = get_ratio_sq(best_pts)\n    \n    # We try 3 random starts to ensure we find a high-quality local optimum\n    # within the time limit (60 seconds).\n    for start in range(3):\n        if start == 0:\n            # Start with a rhombic dodecahedron-like configuration\n            # 8 corners of a cube and 6 face centers extended outward\n            pts = np.array([\n                [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1],\n                [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1],\n                [1.5,0,0], [-1.5,0,0], [0,1.5,0], [0,-1.5,0], [0,0,1.5], [0,0,-1.5]\n            ], dtype=float)\n        elif start == 1:\n            # Start with points distributed on a sphere using a Fibonacci spiral\n            phi = np.pi * (3. - np.sqrt(5.))\n            pts = np.zeros((N, 3))\n            for i in range(N):\n                y = 1 - (i / float(N - 1)) * 2\n                radius = np.sqrt(1 - y * y)\n                theta = phi * i\n                pts[i] = [np.cos(theta) * radius, y, np.sin(theta) * radius]\n        else:\n            # Random normal initialization\n            np.random.seed(start)\n            pts = np.random.normal(0, 1, (N, dim))\n        \n        # 1. LogSumExp pre-optimization\n        # This stage uses a smooth objective to find a good basin of attraction.\n        def lse_obj(x):\n            p = x.reshape((N, dim))\n            d_sq = pdist(p, 'sqeuclidean')\n            d_sq = np.maximum(d_sq, 1e-10)\n            k = 100 # Sharpness parameter as requested\n            \n            # Efficient and stable LogSumExp for max and min\n            m_max = np.max(d_sq)\n            lse_max = m_max + (1/k) * np.log(np.sum(np.exp(k * (d_sq - m_max))))\n            m_min = np.min(d_sq)\n            lse_min = m_min - (1/k) * np.log(np.sum(np.exp(-k * (d_sq - m_min))))\n            \n            # Minimize max/min ratio (equivalent to maximizing min/max)\n            return lse_max / lse_min\n\n        try:\n            # Initial smoothing with L-BFGS-B\n            res_lse = minimize(lse_obj, pts.flatten(), method='L-BFGS-B', options={'maxiter': 50})\n            pts = res_lse.x.reshape((N, dim))\n            \n            # 2. SLSQP refinement\n            # We fix the maximum pairwise distance to 1.0 and maximize the minimum distance.\n            d_sq_current = pdist(pts, 'sqeuclidean')\n            pts = pts / np.sqrt(np.max(d_sq_current))\n            \n            z_init = np.min(pdist(pts, 'sqeuclidean'))\n            # x0 contains coordinates and the variable z representing min distance squared\n            x0 = np.concatenate([pts.flatten(), [z_init]])\n            \n            def obj(x):\n                return -x[-1] # Maximize z\n            \n            def cons(x):\n                p = x[:-1].reshape((N, dim))\n                z = x[-1]\n                d_sq = pdist(p, 'sqeuclidean')\n                # Constraints: d_ij^2 >= z (min dist) and d_ij^2 <= 1 (max dist)\n                return np.concatenate([d_sq - z, 1.0 - d_sq])\n            \n            res_slsqp = minimize(obj, x0, method='SLSQP', \n                                 constraints={'type': 'ineq', 'fun': cons},\n                                 options={'maxiter': 100})\n            \n            if res_slsqp.success or True:\n                pts_final = res_slsqp.x[:-1].reshape((N, dim))\n                val = get_ratio_sq(pts_final)\n                if val > best_val:\n                    best_val = val\n                    best_pts = pts_final\n        except:\n            # Fallback if an optimization run fails\n            continue\n            \n    # Normalize the output to the standard (14, 3) shape\n    return best_pts.reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 0.9974689467634389,
    "min_max_ratio": 0.23943949075286922,
    "min_distance": 0.48932554683868057,
    "max_distance": 1.000000000075394,
    "eval_time": 0.46865105628967285,
    "error": null
  },
  "prompt": "Optimize the 14-point configuration using the LogSumExp approximation for the minimum distance. Use a very high 'sharpness' parameter (k=100 or higher) and refine the result with a standard SLSQP polish.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the ratio\n    (min pairwise distance / max pairwise distance)^2.\n    The strategy uses a LogSumExp approximation for initial smoothing and\n    refines the configuration with SLSQP.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    def get_ratio_sq(pts):\n        d_sq = pdist(pts, 'sqeuclidean')\n        return np.min(d_sq) / np.max(d_sq)\n\n    best_pts = np.random.normal(0, 1, (N, dim))\n    best_val = get_ratio_sq(best_pts)\n    \n    # We try 3 random starts to ensure we find a high-quality local optimum\n    # within the time limit (60 seconds).\n    for start in range(3):\n        if start == 0:\n            # Start with a rhombic dodecahedron-like configuration\n            # 8 corners of a cube and 6 face centers extended outward\n            pts = np.array([\n                [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1],\n                [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1],\n                [1.5,0,0], [-1.5,0,0], [0,1.5,0], [0,-1.5,0], [0,0,1.5], [0,0,-1.5]\n            ], dtype=float)\n        elif start == 1:\n            # Start with points distributed on a sphere using a Fibonacci spiral\n            phi = np.pi * (3. - np.sqrt(5.))\n            pts = np.zeros((N, 3))\n            for i in range(N):\n                y = 1 - (i / float(N - 1)) * 2\n                radius = np.sqrt(1 - y * y)\n                theta = phi * i\n                pts[i] = [np.cos(theta) * radius, y, np.sin(theta) * radius]\n        else:\n            # Random normal initialization\n            np.random.seed(start)\n            pts = np.random.normal(0, 1, (N, dim))\n        \n        # 1. LogSumExp pre-optimization\n        # This stage uses a smooth objective to find a good basin of attraction.\n        def lse_obj(x):\n            p = x.reshape((N, dim))\n            d_sq = pdist(p, 'sqeuclidean')\n            d_sq = np.maximum(d_sq, 1e-10)\n            k = 100 # Sharpness parameter as requested\n            \n            # Efficient and stable LogSumExp for max and min\n            m_max = np.max(d_sq)\n            lse_max = m_max + (1/k) * np.log(np.sum(np.exp(k * (d_sq - m_max))))\n            m_min = np.min(d_sq)\n            lse_min = m_min - (1/k) * np.log(np.sum(np.exp(-k * (d_sq - m_min))))\n            \n            # Minimize max/min ratio (equivalent to maximizing min/max)\n            return lse_max / lse_min\n\n        try:\n            # Initial smoothing with L-BFGS-B\n            res_lse = minimize(lse_obj, pts.flatten(), method='L-BFGS-B', options={'maxiter': 50})\n            pts = res_lse.x.reshape((N, dim))\n            \n            # 2. SLSQP refinement\n            # We fix the maximum pairwise distance to 1.0 and maximize the minimum distance.\n            d_sq_current = pdist(pts, 'sqeuclidean')\n            pts = pts / np.sqrt(np.max(d_sq_current))\n            \n            z_init = np.min(pdist(pts, 'sqeuclidean'))\n            # x0 contains coordinates and the variable z representing min distance squared\n            x0 = np.concatenate([pts.flatten(), [z_init]])\n            \n            def obj(x):\n                return -x[-1] # Maximize z\n            \n            def cons(x):\n                p = x[:-1].reshape((N, dim))\n                z = x[-1]\n                d_sq = pdist(p, 'sqeuclidean')\n                # Constraints: d_ij^2 >= z (min dist) and d_ij^2 <= 1 (max dist)\n                return np.concatenate([d_sq - z, 1.0 - d_sq])\n            \n            res_slsqp = minimize(obj, x0, method='SLSQP', \n                                 constraints={'type': 'ineq', 'fun': cons},\n                                 options={'maxiter': 100})\n            \n            if res_slsqp.success or True:\n                pts_final = res_slsqp.x[:-1].reshape((N, dim))\n                val = get_ratio_sq(pts_final)\n                if val > best_val:\n                    best_val = val\n                    best_pts = pts_final\n        except:\n            # Fallback if an optimization run fails\n            continue\n            \n    # Normalize the output to the standard (14, 3) shape\n    return best_pts.reshape((14, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:34:37.387674",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 220,
        "candidates_token_count": 1335,
        "thoughts_token_count": 19019
      },
      "response_text_len": 4236
    }
  }
}