{
  "trial_id": "trial_15_0",
  "generation": 15,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses Multi-start SLSQP with analytical Jacobian and high-precision polish.\n    \"\"\"\n    N = 14\n    DIM = 3\n    \n    # --- Precomputations for Vectorization and Jacobian ---\n    # idx_i, idx_j map the output of pdist (which is condensed) to the point indices (u, v)\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_pairs = len(idx_i)\n    \n    # Jacobian structure indices\n    # We have 2 constraints per pair:\n    # 1. d_ij^2 - s >= 0  (rows 0 to num_pairs-1)\n    # 2. 1 - d_ij^2 >= 0  (rows num_pairs to 2*num_pairs-1)\n    \n    rows_c1 = np.arange(num_pairs)\n    rows_c2 = rows_c1 + num_pairs\n    \n    # Flattened row indices for the 3 coordinates (x, y, z) per constraint\n    rows_c1_flat = np.repeat(rows_c1, 3)\n    rows_c2_flat = np.repeat(rows_c2, 3)\n    \n    # Column indices for the variables x_i and x_j in the Jacobian matrix\n    # Variable vector structure: [x0, y0, z0, x1, ..., z(N-1), s]\n    cols_u = (3 * idx_i[:, None] + np.arange(3)).flatten()\n    cols_v = (3 * idx_j[:, None] + np.arange(3)).flatten()\n    \n    def get_ratio_sq(pts):\n        if pts.shape[0] < 2: return 0.0\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0: return 0.0\n        mn = np.min(dists_sq)\n        mx = np.max(dists_sq)\n        if mx <= 1e-16: return 0.0\n        return mn / mx\n\n    # --- Optimization Functions ---\n\n    def objective(vars):\n        # Maximize s => Minimize -s\n        return -vars[-1]\n\n    def obj_jac(vars):\n        # Gradient of -s is [0, ..., 0, -1]\n        jac = np.zeros_like(vars)\n        jac[-1] = -1.0\n        return jac\n\n    def constraints_func(vars):\n        pts = vars[:-1].reshape((N, DIM))\n        s = vars[-1]\n        \n        # Calculate pairwise vectors: pts[u] - pts[v]\n        diffs = pts[idx_i] - pts[idx_j]\n        # Squared Euclidean distances\n        d_sq = np.sum(diffs**2, axis=1)\n        \n        # Constraints vector\n        # 1. min_dist^2 >= s  => d^2 - s >= 0\n        # 2. max_dist^2 <= 1  => 1 - d^2 >= 0\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def constraints_jac(vars):\n        pts = vars[:-1].reshape((N, DIM))\n        \n        # Recompute differences for gradients\n        diffs = pts[idx_i] - pts[idx_j]\n        \n        # Gradient of d_{uv}^2 w.r.t x_u is 2(x_u - x_v)\n        # Gradient of d_{uv}^2 w.r.t x_v is -2(x_u - x_v)\n        grad_d_sq = 2.0 * diffs\n        vals = grad_d_sq.flatten()\n        \n        # Initialize Jacobian matrix (Constraints x Variables)\n        jac = np.zeros((2 * num_pairs, 3 * N + 1))\n        \n        # --- Constraint 1: d^2 - s >= 0 ---\n        # d(C1)/dx_u = 2(x_u - x_v)\n        jac[rows_c1_flat, cols_u] = vals\n        # d(C1)/dx_v = -2(x_u - x_v)\n        jac[rows_c1_flat, cols_v] = -vals\n        # d(C1)/ds = -1\n        jac[rows_c1, -1] = -1.0\n        \n        # --- Constraint 2: 1 - d^2 >= 0 ---\n        # d(C2)/dx_u = -2(x_u - x_v)\n        jac[rows_c2_flat, cols_u] = -vals\n        # d(C2)/dx_v = 2(x_u - x_v)\n        jac[rows_c2_flat, cols_v] = vals\n        # d(C2)/ds = 0 (already initialized)\n        \n        return jac\n\n    def solve(pts_init, ftol=1e-6, maxiter=500):\n        # Normalize initialization points to satisfy max_dist=1 initially\n        d_sq = pdist(pts_init, 'sqeuclidean')\n        if len(d_sq) > 0:\n            max_d_sq = np.max(d_sq)\n            if max_d_sq > 1e-16:\n                pts_norm = pts_init / np.sqrt(max_d_sq)\n            else:\n                pts_norm = pts_init\n            # Initialize slack variable s\n            s_init = np.min(d_sq) / max_d_sq if max_d_sq > 1e-16 else 0.0\n        else:\n            pts_norm = pts_init\n            s_init = 0.0\n\n        vars_init = np.concatenate([pts_norm.flatten(), [s_init]])\n        \n        cons = {'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac}\n        \n        # SLSQP with analytical Jacobian\n        res = minimize(objective, vars_init, method='SLSQP', jac=obj_jac,\n                       constraints=cons,\n                       options={'maxiter': maxiter, 'ftol': ftol})\n        \n        return res.x[:-1].reshape((N, DIM))\n\n    # --- Main Search Logic ---\n    \n    start_time = time.time()\n    \n    # 1. Initialization: Fibonacci Sphere\n    # A good heuristic for distributing points on a sphere\n    phi_golden = (1.0 + 5.0**0.5) / 2.0\n    indices = np.arange(N) + 0.5\n    z = 1.0 - 2.0 * indices / N\n    radius = np.sqrt(np.maximum(0, 1.0 - z * z))\n    theta = 2.0 * np.pi * indices / phi_golden\n    pts_fib = np.stack([radius * np.cos(theta), radius * np.sin(theta), z], axis=1)\n    \n    # Initial optimization\n    best_pts = solve(pts_fib, ftol=1e-6)\n    best_score = get_ratio_sq(best_pts)\n    \n    # 2. Basin-hopping loop\n    # Run for up to 55 seconds to leave time for final polish\n    while time.time() - start_time < 55:\n        \n        # Perturbation Strategy\n        r = np.random.rand()\n        if r < 0.25:\n            # Random restart (global exploration)\n            pts_cand = np.random.uniform(-0.5, 0.5, (N, DIM))\n        else:\n            # Perturb current best (local exploration)\n            scale = np.random.choice([0.02, 0.05, 0.1, 0.15])\n            pts_cand = best_pts + np.random.normal(0, scale, (N, DIM))\n            \n        try:\n            # Fast solve with moderate tolerance\n            pts_out = solve(pts_cand, ftol=1e-6)\n            score = get_ratio_sq(pts_out)\n            \n            # Update if better\n            if score > best_score + 1e-9:\n                best_score = score\n                best_pts = pts_out\n        except Exception:\n            continue\n            \n    # 3. Final High-Precision Polish\n    # Using strict tolerance as requested to remove numerical noise\n    try:\n        best_pts = solve(best_pts, ftol=1e-15, maxiter=1000)\n    except Exception:\n        pass\n        \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 1.000015913553916,
    "min_max_ratio": 0.2400508826495845,
    "min_distance": 0.489949877691162,
    "max_distance": 1.0000000000000002,
    "eval_time": 55.24473309516907,
    "error": null
  },
  "prompt": "Improve the numerical precision of this solution. Use the existing coordinates as a starting point and apply a multi-start SLSQP polish with an extremely small tolerance (1e-15). Ensure the analytical Jacobian is perfectly implemented to avoid numerical noise.\n\nCode:\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a high-restart Basin-hopping search with SLSQP local optimization and a slack variable.\n    Initializes with a Fibonacci sphere using the specified golden ratio.\n    \"\"\"\n    N = 14\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the squared ratio of min distance to max distance.\"\"\"\n        if pts.shape[0] < 2:\n            return 0.0\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0:\n            return 0.0\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def solve_with_init(pts_init):\n        \"\"\"\n        Local optimization using SLSQP with a slack variable.\n        Maximizes s subject to d_min^2 >= s and d_max^2 <= 1.\n        \"\"\"\n        def objective(vars):\n            # Maximize the slack variable s\n            return -vars[-1]\n\n        def constraints(vars):\n            pts = vars[:-1].reshape((N, 3))\n            s = vars[-1]\n            d_sq = pdist(pts, 'sqeuclidean')\n            # Constraints: d_ij^2 - s >= 0 (min distance) and 1.0 - d_ij^2 >= 0 (max distance)\n            return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n        # Normalize the initial points so that the maximum distance is 1.0\n        dists_sq_init = pdist(pts_init, 'sqeuclidean')\n        d_max_sq_init = np.max(dists_sq_init)\n        pts_init_norm = pts_init / np.sqrt(d_max_sq_init)\n        \n        # Initial slack variable is the minimum squared distance of the normalized set\n        s_init = np.min(pdist(pts_init_norm, 'sqeuclidean'))\n        \n        # Flattened points + slack variable s\n        vars_init = np.concatenate([pts_init_norm.flatten(), [s_init]])\n        \n        # Run SLSQP\n        res = minimize(objective, vars_init, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options={'maxiter': 400, 'ftol': 1e-8})\n        return res\n\n    # 1. Fibonacci Sphere Initialization\n    # Use the golden ratio specified: (1 + sqrt(5)) / 2 + 0.0\n    phi = (1.0 + 5.0**0.5) / 2.0 + 0.0\n    indices = np.arange(N) + 0.5\n    z = 1.0 - 2.0 * indices / N\n    radius = np.sqrt(np.maximum(0, 1.0 - z * z))\n    theta = 2.0 * np.pi * indices / phi\n    pts_fib = np.stack([radius * np.cos(theta), radius * np.sin(theta), z], axis=1)\n    \n    # Polish the Fibonacci initialization\n    best_pts = pts_fib\n    best_ratio = get_ratio_sq(pts_fib)\n    \n    res = solve_with_init(pts_fib)\n    pts_out = res.x[:-1].reshape((N, 3))\n    ratio = get_ratio_sq(pts_out)\n    if ratio > best_ratio:\n        best_ratio = ratio\n        best_pts = pts_out\n    \n    # 2. High-Restart Basin-Hopping Search\n    start_time = time.time()\n    # Search for up to 50 seconds to ensure completion within the 60s limit\n    while time.time() - start_time < 50:\n        # Strategy A: Perturb the current best solution (Basin-hopping step)\n        scale = np.random.choice([0.02, 0.05, 0.1, 0.15])\n        pts_perturbed = best_pts + np.random.normal(0, scale, best_pts.shape)\n        res = solve_with_init(pts_perturbed)\n        pts_out = res.x[:-1].reshape((N, 3))\n        ratio = get_ratio_sq(pts_out)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_out\n        \n        # Strategy B: Random restart from a uniform distribution occasionally\n        if np.random.rand() < 0.25:\n            pts_rand = np.random.uniform(-0.5, 0.5, (N, 3))\n            res = solve_with_init(pts_rand)\n            pts_out = res.x[:-1].reshape((N, 3))\n            ratio = get_ratio_sq(pts_out)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_pts = pts_out\n                \n    # Return the best point configuration found\n    return best_pts.reshape((14, 3))",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses Multi-start SLSQP with analytical Jacobian and high-precision polish.\n    \"\"\"\n    N = 14\n    DIM = 3\n    \n    # --- Precomputations for Vectorization and Jacobian ---\n    # idx_i, idx_j map the output of pdist (which is condensed) to the point indices (u, v)\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_pairs = len(idx_i)\n    \n    # Jacobian structure indices\n    # We have 2 constraints per pair:\n    # 1. d_ij^2 - s >= 0  (rows 0 to num_pairs-1)\n    # 2. 1 - d_ij^2 >= 0  (rows num_pairs to 2*num_pairs-1)\n    \n    rows_c1 = np.arange(num_pairs)\n    rows_c2 = rows_c1 + num_pairs\n    \n    # Flattened row indices for the 3 coordinates (x, y, z) per constraint\n    rows_c1_flat = np.repeat(rows_c1, 3)\n    rows_c2_flat = np.repeat(rows_c2, 3)\n    \n    # Column indices for the variables x_i and x_j in the Jacobian matrix\n    # Variable vector structure: [x0, y0, z0, x1, ..., z(N-1), s]\n    cols_u = (3 * idx_i[:, None] + np.arange(3)).flatten()\n    cols_v = (3 * idx_j[:, None] + np.arange(3)).flatten()\n    \n    def get_ratio_sq(pts):\n        if pts.shape[0] < 2: return 0.0\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0: return 0.0\n        mn = np.min(dists_sq)\n        mx = np.max(dists_sq)\n        if mx <= 1e-16: return 0.0\n        return mn / mx\n\n    # --- Optimization Functions ---\n\n    def objective(vars):\n        # Maximize s => Minimize -s\n        return -vars[-1]\n\n    def obj_jac(vars):\n        # Gradient of -s is [0, ..., 0, -1]\n        jac = np.zeros_like(vars)\n        jac[-1] = -1.0\n        return jac\n\n    def constraints_func(vars):\n        pts = vars[:-1].reshape((N, DIM))\n        s = vars[-1]\n        \n        # Calculate pairwise vectors: pts[u] - pts[v]\n        diffs = pts[idx_i] - pts[idx_j]\n        # Squared Euclidean distances\n        d_sq = np.sum(diffs**2, axis=1)\n        \n        # Constraints vector\n        # 1. min_dist^2 >= s  => d^2 - s >= 0\n        # 2. max_dist^2 <= 1  => 1 - d^2 >= 0\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def constraints_jac(vars):\n        pts = vars[:-1].reshape((N, DIM))\n        \n        # Recompute differences for gradients\n        diffs = pts[idx_i] - pts[idx_j]\n        \n        # Gradient of d_{uv}^2 w.r.t x_u is 2(x_u - x_v)\n        # Gradient of d_{uv}^2 w.r.t x_v is -2(x_u - x_v)\n        grad_d_sq = 2.0 * diffs\n        vals = grad_d_sq.flatten()\n        \n        # Initialize Jacobian matrix (Constraints x Variables)\n        jac = np.zeros((2 * num_pairs, 3 * N + 1))\n        \n        # --- Constraint 1: d^2 - s >= 0 ---\n        # d(C1)/dx_u = 2(x_u - x_v)\n        jac[rows_c1_flat, cols_u] = vals\n        # d(C1)/dx_v = -2(x_u - x_v)\n        jac[rows_c1_flat, cols_v] = -vals\n        # d(C1)/ds = -1\n        jac[rows_c1, -1] = -1.0\n        \n        # --- Constraint 2: 1 - d^2 >= 0 ---\n        # d(C2)/dx_u = -2(x_u - x_v)\n        jac[rows_c2_flat, cols_u] = -vals\n        # d(C2)/dx_v = 2(x_u - x_v)\n        jac[rows_c2_flat, cols_v] = vals\n        # d(C2)/ds = 0 (already initialized)\n        \n        return jac\n\n    def solve(pts_init, ftol=1e-6, maxiter=500):\n        # Normalize initialization points to satisfy max_dist=1 initially\n        d_sq = pdist(pts_init, 'sqeuclidean')\n        if len(d_sq) > 0:\n            max_d_sq = np.max(d_sq)\n            if max_d_sq > 1e-16:\n                pts_norm = pts_init / np.sqrt(max_d_sq)\n            else:\n                pts_norm = pts_init\n            # Initialize slack variable s\n            s_init = np.min(d_sq) / max_d_sq if max_d_sq > 1e-16 else 0.0\n        else:\n            pts_norm = pts_init\n            s_init = 0.0\n\n        vars_init = np.concatenate([pts_norm.flatten(), [s_init]])\n        \n        cons = {'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac}\n        \n        # SLSQP with analytical Jacobian\n        res = minimize(objective, vars_init, method='SLSQP', jac=obj_jac,\n                       constraints=cons,\n                       options={'maxiter': maxiter, 'ftol': ftol})\n        \n        return res.x[:-1].reshape((N, DIM))\n\n    # --- Main Search Logic ---\n    \n    start_time = time.time()\n    \n    # 1. Initialization: Fibonacci Sphere\n    # A good heuristic for distributing points on a sphere\n    phi_golden = (1.0 + 5.0**0.5) / 2.0\n    indices = np.arange(N) + 0.5\n    z = 1.0 - 2.0 * indices / N\n    radius = np.sqrt(np.maximum(0, 1.0 - z * z))\n    theta = 2.0 * np.pi * indices / phi_golden\n    pts_fib = np.stack([radius * np.cos(theta), radius * np.sin(theta), z], axis=1)\n    \n    # Initial optimization\n    best_pts = solve(pts_fib, ftol=1e-6)\n    best_score = get_ratio_sq(best_pts)\n    \n    # 2. Basin-hopping loop\n    # Run for up to 55 seconds to leave time for final polish\n    while time.time() - start_time < 55:\n        \n        # Perturbation Strategy\n        r = np.random.rand()\n        if r < 0.25:\n            # Random restart (global exploration)\n            pts_cand = np.random.uniform(-0.5, 0.5, (N, DIM))\n        else:\n            # Perturb current best (local exploration)\n            scale = np.random.choice([0.02, 0.05, 0.1, 0.15])\n            pts_cand = best_pts + np.random.normal(0, scale, (N, DIM))\n            \n        try:\n            # Fast solve with moderate tolerance\n            pts_out = solve(pts_cand, ftol=1e-6)\n            score = get_ratio_sq(pts_out)\n            \n            # Update if better\n            if score > best_score + 1e-9:\n                best_score = score\n                best_pts = pts_out\n        except Exception:\n            continue\n            \n    # 3. Final High-Precision Polish\n    # Using strict tolerance as requested to remove numerical noise\n    try:\n        best_pts = solve(best_pts, ftol=1e-15, maxiter=1000)\n    except Exception:\n        pass\n        \n    return best_pts\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:35:37.801220",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 1497,
        "candidates_token_count": 2151,
        "thoughts_token_count": 12177
      },
      "response_text_len": 6072
    }
  }
}