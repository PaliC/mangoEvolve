{
  "trial_id": "trial_1_2",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the \n    squared ratio (min pairwise distance / max pairwise distance)^2.\n    \n    This implementation uses a force-directed layout where points repel each \n    other with a 1/r^12 force. An annealing schedule is used to cool the \n    system and reach a stable, high-quality configuration.\n    \"\"\"\n    n_points = 14\n    dim = 3\n    best_pts = None\n    best_score = -1\n    \n    # We use multiple restarts to increase the probability of finding the global optimum\n    num_restarts = 15\n    iterations_per_restart = 2500\n    \n    for restart in range(num_restarts):\n        # Initialize points randomly following a normal distribution\n        pts = np.random.normal(0, 1.0, (n_points, dim))\n        pts -= np.mean(pts, axis=0) # Center initially\n        \n        # Initial step size for the force-directed layout\n        step_size = 0.02\n        \n        for i in range(iterations_per_restart):\n            # Compute pairwise differences and distances between all points\n            # diff shape: (14, 14, 3), dists shape: (14, 14)\n            diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            dists = np.linalg.norm(diff, axis=-1)\n            \n            # The force magnitude is requested to be 1/r^12.\n            # The vector force is F_vec = (unit_vector) * magnitude = (diff/r) * (1/r^12) = diff / r^13.\n            # Use a small epsilon to avoid division by zero on the diagonal and for stability.\n            eps = 1e-12\n            inv_dist_13 = 1.0 / (np.power(dists + eps, 13))\n            \n            # Ensure points do not repel themselves\n            np.fill_diagonal(inv_dist_13, 0)\n            \n            # Sum forces from all other points for each point i\n            # forces shape: (14, 3)\n            forces = np.sum(diff * inv_dist_13[:, :, np.newaxis], axis=1)\n            \n            # Stability: Cap the force magnitude so that no point moves too far in one step.\n            # This prevents the system from exploding when points are very close.\n            f_mags = np.linalg.norm(forces, axis=1, keepdims=True)\n            max_allowed_move = 0.05\n            cap = max_allowed_move / (step_size + 1e-15)\n            forces = np.where(f_mags > cap, forces / (f_mags + 1e-15) * cap, forces)\n            \n            # Update positions based on the calculated forces\n            pts += step_size * forces\n            \n            # Re-center the points to keep the configuration stable around the origin\n            pts -= np.mean(pts, axis=0)\n            \n            # Calculate updated distances for normalization and scoring\n            dist_matrix = np.linalg.norm(pts[:, np.newaxis, :] - pts[np.newaxis, :, :], axis=-1)\n            max_d = np.max(dist_matrix)\n            min_d = np.min(dist_matrix + np.eye(n_points) * 1e9)\n            \n            if max_d > 0:\n                # Calculate the squared ratio (min_dist / max_dist)^2\n                score = (min_d / max_d)**2\n                \n                # Keep track of the best configuration found across all steps and restarts\n                if score > best_score:\n                    best_score = score\n                    best_pts = (pts / max_d).copy()\n                \n                # Normalize the points at each step to keep the max distance equal to 1.0.\n                # This keeps the system in a consistent scale, helping the force model.\n                pts /= max_d\n            \n            # Annealing: Gradually reduce the step size to let the system settle into a local optimum.\n            if i > iterations_per_restart // 2:\n                step_size *= 0.995\n                \n    # Return the best configuration found as a 14x3 numpy array\n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9242320997012057,
    "min_max_ratio": 0.22185920073800053,
    "min_distance": 0.471019320981635,
    "max_distance": 1.0,
    "eval_time": 1.2122888565063477,
    "error": null
  },
  "prompt": "Implement a force-directed layout (repulsion model) where 14 points repel each other with a 1/r^12 force. Use an annealing schedule to cool the system and find a stable configuration.",
  "response": "```python\nimport numpy as np\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the \n    squared ratio (min pairwise distance / max pairwise distance)^2.\n    \n    This implementation uses a force-directed layout where points repel each \n    other with a 1/r^12 force. An annealing schedule is used to cool the \n    system and reach a stable, high-quality configuration.\n    \"\"\"\n    n_points = 14\n    dim = 3\n    best_pts = None\n    best_score = -1\n    \n    # We use multiple restarts to increase the probability of finding the global optimum\n    num_restarts = 15\n    iterations_per_restart = 2500\n    \n    for restart in range(num_restarts):\n        # Initialize points randomly following a normal distribution\n        pts = np.random.normal(0, 1.0, (n_points, dim))\n        pts -= np.mean(pts, axis=0) # Center initially\n        \n        # Initial step size for the force-directed layout\n        step_size = 0.02\n        \n        for i in range(iterations_per_restart):\n            # Compute pairwise differences and distances between all points\n            # diff shape: (14, 14, 3), dists shape: (14, 14)\n            diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            dists = np.linalg.norm(diff, axis=-1)\n            \n            # The force magnitude is requested to be 1/r^12.\n            # The vector force is F_vec = (unit_vector) * magnitude = (diff/r) * (1/r^12) = diff / r^13.\n            # Use a small epsilon to avoid division by zero on the diagonal and for stability.\n            eps = 1e-12\n            inv_dist_13 = 1.0 / (np.power(dists + eps, 13))\n            \n            # Ensure points do not repel themselves\n            np.fill_diagonal(inv_dist_13, 0)\n            \n            # Sum forces from all other points for each point i\n            # forces shape: (14, 3)\n            forces = np.sum(diff * inv_dist_13[:, :, np.newaxis], axis=1)\n            \n            # Stability: Cap the force magnitude so that no point moves too far in one step.\n            # This prevents the system from exploding when points are very close.\n            f_mags = np.linalg.norm(forces, axis=1, keepdims=True)\n            max_allowed_move = 0.05\n            cap = max_allowed_move / (step_size + 1e-15)\n            forces = np.where(f_mags > cap, forces / (f_mags + 1e-15) * cap, forces)\n            \n            # Update positions based on the calculated forces\n            pts += step_size * forces\n            \n            # Re-center the points to keep the configuration stable around the origin\n            pts -= np.mean(pts, axis=0)\n            \n            # Calculate updated distances for normalization and scoring\n            dist_matrix = np.linalg.norm(pts[:, np.newaxis, :] - pts[np.newaxis, :, :], axis=-1)\n            max_d = np.max(dist_matrix)\n            min_d = np.min(dist_matrix + np.eye(n_points) * 1e9)\n            \n            if max_d > 0:\n                # Calculate the squared ratio (min_dist / max_dist)^2\n                score = (min_d / max_d)**2\n                \n                # Keep track of the best configuration found across all steps and restarts\n                if score > best_score:\n                    best_score = score\n                    best_pts = (pts / max_d).copy()\n                \n                # Normalize the points at each step to keep the max distance equal to 1.0.\n                # This keeps the system in a consistent scale, helping the force model.\n                pts /= max_d\n            \n            # Annealing: Gradually reduce the step size to let the system settle into a local optimum.\n            if i > iterations_per_restart // 2:\n                step_size *= 0.995\n                \n    # Return the best configuration found as a 14x3 numpy array\n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:15:12.856759",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 216,
        "candidates_token_count": 1059,
        "thoughts_token_count": 17942
      },
      "response_text_len": 3822
    }
  }
}