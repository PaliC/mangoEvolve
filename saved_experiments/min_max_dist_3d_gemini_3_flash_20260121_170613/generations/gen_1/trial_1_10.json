{
  "trial_id": "trial_1_10",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses the L-BFGS-B optimizer with multiple random initializations and symmetric configurations.\n    The objective function is a smooth-min version of the pairwise distances, normalized by the maximum distance.\n    \"\"\"\n    N = 14\n    best_pts = None\n    best_ratio_sq = -1\n    start_time = time.time()\n    \n    # Pre-calculate indices for the upper triangle of the distance matrix\n    idx = np.triu_indices(N, k=1)\n    \n    # Try different initializations to explore the configuration space\n    for run in range(100):\n        # Time limit check\n        if time.time() - start_time > 55:\n            break\n            \n        if run == 0:\n            # Initialization 1: 12 points on a sphere (icosahedron) + 2 points near center\n            phi = (1 + 5**0.5) / 2\n            pts = np.array([\n                [1, phi, 0], [-1, phi, 0], [1, -phi, 0], [-1, -phi, 0],\n                [0, 1, phi], [0, -1, phi], [0, 1, -phi], [0, -1, -phi],\n                [phi, 0, 1], [phi, 0, -1], [-phi, 0, 1], [-phi, 0, -1],\n                [0.1, 0.1, 0.1], [-0.1, -0.1, -0.1]\n            ])\n        elif run == 1:\n            # Initialization 2: 2-6-6 Lord of the Rings structure (2 poles, 2 rings of 6)\n            pts = []\n            pts.append([0, 0, 1.2])\n            pts.append([0, 0, -1.2])\n            for i in range(6):\n                pts.append([np.cos(i*np.pi/3), np.sin(i*np.pi/3), 0.4])\n                pts.append([np.cos(i*np.pi/3 + np.pi/6), np.sin(i*np.pi/3 + np.pi/6), -0.4])\n            pts = np.array(pts)\n        elif run == 2:\n            # Initialization 3: Cube vertices plus face centers\n            pts = []\n            for i in [-1, 1]:\n                for j in [-1, 1]:\n                    for k in [-1, 1]:\n                        pts.append([i, j, k])\n            pts.extend([\n                [1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]\n            ])\n            pts = np.array(pts)\n        elif run < 10:\n            # Initialization 4: Random points on a sphere\n            pts = np.random.normal(0, 1, (N, 3))\n            pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        else:\n            # Initialization 5: Random points in a cube\n            pts = np.random.uniform(-1, 1, (N, 3))\n            \n        def objective(coords):\n            p = coords.reshape((N, 3))\n            # Efficiently compute all pairwise squared distances\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            d2_triu = d2[idx]\n            \n            # Use max_d2 to make the objective scale-invariant\n            max_d2 = np.max(d2_triu)\n            if max_d2 == 0:\n                return 1e10\n            \n            # Smooth-min objective using an exponential sum\n            # Minimizing this sum pushes the minimum distance to increase relative to the maximum distance\n            k = 60.0\n            return np.sum(np.exp(-k * d2_triu / max_d2))\n\n        # Run the L-BFGS-B optimizer\n        res = minimize(objective, pts.flatten(), method='L-BFGS-B', \n                       options={'maxiter': 500, 'ftol': 1e-8})\n        \n        # Evaluate the optimized point set\n        final_pts = res.x.reshape((N, 3))\n        diff = final_pts[:, np.newaxis, :] - final_pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        d2_triu = d2[idx]\n        \n        min_d2 = np.min(d2_triu)\n        max_d2 = np.max(d2_triu)\n        ratio_sq = min_d2 / max_d2\n        \n        # Update best configuration found so far\n        if ratio_sq > best_ratio_sq:\n            best_ratio_sq = ratio_sq\n            best_pts = final_pts\n            \n    return best_pts.reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 0.9321116912653278,
    "min_max_ratio": 0.2237506735478317,
    "min_distance": 1.0025154142646069,
    "max_distance": 2.1193802513699125,
    "eval_time": 5.441536903381348,
    "error": null
  },
  "prompt": "Use the L-BFGS-B optimizer to maximize the minimum distance between 14 points. For the objective, use the sum of exp(-k * dist_ij) for a large k.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses the L-BFGS-B optimizer with multiple random initializations and symmetric configurations.\n    The objective function is a smooth-min version of the pairwise distances, normalized by the maximum distance.\n    \"\"\"\n    N = 14\n    best_pts = None\n    best_ratio_sq = -1\n    start_time = time.time()\n    \n    # Pre-calculate indices for the upper triangle of the distance matrix\n    idx = np.triu_indices(N, k=1)\n    \n    # Try different initializations to explore the configuration space\n    for run in range(100):\n        # Time limit check\n        if time.time() - start_time > 55:\n            break\n            \n        if run == 0:\n            # Initialization 1: 12 points on a sphere (icosahedron) + 2 points near center\n            phi = (1 + 5**0.5) / 2\n            pts = np.array([\n                [1, phi, 0], [-1, phi, 0], [1, -phi, 0], [-1, -phi, 0],\n                [0, 1, phi], [0, -1, phi], [0, 1, -phi], [0, -1, -phi],\n                [phi, 0, 1], [phi, 0, -1], [-phi, 0, 1], [-phi, 0, -1],\n                [0.1, 0.1, 0.1], [-0.1, -0.1, -0.1]\n            ])\n        elif run == 1:\n            # Initialization 2: 2-6-6 Lord of the Rings structure (2 poles, 2 rings of 6)\n            pts = []\n            pts.append([0, 0, 1.2])\n            pts.append([0, 0, -1.2])\n            for i in range(6):\n                pts.append([np.cos(i*np.pi/3), np.sin(i*np.pi/3), 0.4])\n                pts.append([np.cos(i*np.pi/3 + np.pi/6), np.sin(i*np.pi/3 + np.pi/6), -0.4])\n            pts = np.array(pts)\n        elif run == 2:\n            # Initialization 3: Cube vertices plus face centers\n            pts = []\n            for i in [-1, 1]:\n                for j in [-1, 1]:\n                    for k in [-1, 1]:\n                        pts.append([i, j, k])\n            pts.extend([\n                [1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]\n            ])\n            pts = np.array(pts)\n        elif run < 10:\n            # Initialization 4: Random points on a sphere\n            pts = np.random.normal(0, 1, (N, 3))\n            pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        else:\n            # Initialization 5: Random points in a cube\n            pts = np.random.uniform(-1, 1, (N, 3))\n            \n        def objective(coords):\n            p = coords.reshape((N, 3))\n            # Efficiently compute all pairwise squared distances\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            d2_triu = d2[idx]\n            \n            # Use max_d2 to make the objective scale-invariant\n            max_d2 = np.max(d2_triu)\n            if max_d2 == 0:\n                return 1e10\n            \n            # Smooth-min objective using an exponential sum\n            # Minimizing this sum pushes the minimum distance to increase relative to the maximum distance\n            k = 60.0\n            return np.sum(np.exp(-k * d2_triu / max_d2))\n\n        # Run the L-BFGS-B optimizer\n        res = minimize(objective, pts.flatten(), method='L-BFGS-B', \n                       options={'maxiter': 500, 'ftol': 1e-8})\n        \n        # Evaluate the optimized point set\n        final_pts = res.x.reshape((N, 3))\n        diff = final_pts[:, np.newaxis, :] - final_pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        d2_triu = d2[idx]\n        \n        min_d2 = np.min(d2_triu)\n        max_d2 = np.max(d2_triu)\n        ratio_sq = min_d2 / max_d2\n        \n        # Update best configuration found so far\n        if ratio_sq > best_ratio_sq:\n            best_ratio_sq = ratio_sq\n            best_pts = final_pts\n            \n    return best_pts.reshape((14, 3))\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:15:38.932887",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 213,
        "candidates_token_count": 1315,
        "thoughts_token_count": 22708
      },
      "response_text_len": 3916
    }
  }
}