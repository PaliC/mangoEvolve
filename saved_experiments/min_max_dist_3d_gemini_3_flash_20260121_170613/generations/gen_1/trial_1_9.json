{
  "trial_id": "trial_1_9",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds the optimal configuration of 14 points in 3D space to maximize \n    the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The approach uses several structured starting points (FCC, HCP, FCC unit cell) \n    and refines them using the SLSQP optimizer.\n    \"\"\"\n    N = 14\n    dim = 3\n\n    def get_ratio_sq(pts):\n        dists_sq = pdist(pts)**2\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def objective(vars):\n        # We want to maximize the minimum squared distance\n        # vars[-1] is the slack variable representing min_dist_sq\n        return -vars[-1]\n\n    def constraint_min(vars):\n        pts = vars[:-1].reshape(N, dim)\n        dmin_sq = vars[-1]\n        # All pairwise squared distances must be >= dmin_sq\n        return pdist(pts)**2 - dmin_sq\n\n    def constraint_max(vars):\n        pts = vars[:-1].reshape(N, dim)\n        # All pairwise squared distances must be <= 1.0\n        return 1.0 - pdist(pts)**2\n\n    # Collection of starting configurations\n    starts = []\n\n    # 1. Face-Centered Cubic (FCC) subset\n    pts_fcc = []\n    for i in range(-2, 3):\n        for j in range(-2, 3):\n            for k in range(-2, 3):\n                if (i + j + k) % 2 == 0:\n                    pts_fcc.append([float(i), float(j), float(k)])\n    pts_fcc = np.array(pts_fcc)\n    dists_fcc = np.sum((pts_fcc - np.mean(pts_fcc, axis=0))**2, axis=1)\n    starts.append(pts_fcc[np.argsort(dists_fcc)[:N]])\n\n    # 2. Hexagonal Close-Packed (HCP) subset\n    pts_hcp = []\n    for z in range(-2, 3):\n        for y in range(-2, 3):\n            for x in range(-2, 3):\n                pts_hcp.append([\n                    float(2*x + (y + z) % 2),\n                    float(np.sqrt(3) * (y + (z % 2) / 3.0)),\n                    float((2.0 * np.sqrt(6.0) / 3.0) * z)\n                ])\n    pts_hcp = np.array(pts_hcp)\n    dists_hcp = np.sum((pts_hcp - np.mean(pts_hcp, axis=0))**2, axis=1)\n    starts.append(pts_hcp[np.argsort(dists_hcp)[:N]])\n\n    # 3. FCC unit cell (8 corners + 6 face centers)\n    pts_fcc_unit = np.array([\n        [0,0,0], [2,0,0], [0,2,0], [0,0,2], [2,2,0], [2,0,2], [0,2,2], [2,2,2], # 8 corners\n        [1,1,0], [1,1,2], [1,0,1], [1,2,1], [0,1,1], [2,1,1]                    # 6 face centers\n    ], dtype=float)\n    starts.append(pts_fcc_unit)\n\n    # 4. Random points on a sphere\n    np.random.seed(42)\n    pts_rand = np.random.normal(0, 1, (N, dim))\n    pts_rand /= np.linalg.norm(pts_rand, axis=1)[:, np.newaxis]\n    starts.append(pts_rand)\n\n    best_pts = None\n    best_ratio = -1.0\n\n    # Optimization loop\n    for pts_init in starts:\n        # Pre-process: center and normalize the starting point\n        pts_init = pts_init - np.mean(pts_init, axis=0)\n        max_d_sq = np.max(pdist(pts_init)**2)\n        pts_init = pts_init / np.sqrt(max_d_sq)\n        \n        # Initial value for the slack variable\n        dmin_sq_init = np.min(pdist(pts_init)**2)\n        \n        # Variables: [x1, y1, z1, ..., x14, y14, z14, dmin_sq]\n        vars_init = np.concatenate([pts_init.flatten(), [dmin_sq_init]])\n        \n        # Use SLSQP to maximize the minimum distance subject to max_dist_sq <= 1\n        res = minimize(\n            objective, \n            vars_init, \n            method='SLSQP', \n            constraints=[\n                {'type': 'ineq', 'fun': constraint_min},\n                {'type': 'ineq', 'fun': constraint_max}\n            ],\n            options={'maxiter': 150}\n        )\n        \n        if res.success or True:\n            pts_res = res.x[:-1].reshape(N, dim)\n            ratio = get_ratio_sq(pts_res)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_pts = pts_res\n\n    # Final normalization to ensure max_dist_sq is exactly 1.0\n    if best_pts is not None:\n        best_pts = best_pts / np.sqrt(np.max(pdist(best_pts)**2))\n    else:\n        # Fallback to a simple starting point if optimization failed\n        best_pts = starts[0] / np.sqrt(np.max(pdist(starts[0])**2))\n        \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9982386545725288,
    "min_max_ratio": 0.23962425685153826,
    "min_distance": 0.48951430709585825,
    "max_distance": 0.9999999999999999,
    "eval_time": 0.3487098217010498,
    "error": null
  },
  "prompt": "Search for the optimal configuration of 14 points by considering subsets of a Face-Centered Cubic (FCC) or Hexagonal Close-Packed (HCP) lattice, then refine with a local optimizer.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds the optimal configuration of 14 points in 3D space to maximize \n    the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The approach uses several structured starting points (FCC, HCP, FCC unit cell) \n    and refines them using the SLSQP optimizer.\n    \"\"\"\n    N = 14\n    dim = 3\n\n    def get_ratio_sq(pts):\n        dists_sq = pdist(pts)**2\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def objective(vars):\n        # We want to maximize the minimum squared distance\n        # vars[-1] is the slack variable representing min_dist_sq\n        return -vars[-1]\n\n    def constraint_min(vars):\n        pts = vars[:-1].reshape(N, dim)\n        dmin_sq = vars[-1]\n        # All pairwise squared distances must be >= dmin_sq\n        return pdist(pts)**2 - dmin_sq\n\n    def constraint_max(vars):\n        pts = vars[:-1].reshape(N, dim)\n        # All pairwise squared distances must be <= 1.0\n        return 1.0 - pdist(pts)**2\n\n    # Collection of starting configurations\n    starts = []\n\n    # 1. Face-Centered Cubic (FCC) subset\n    pts_fcc = []\n    for i in range(-2, 3):\n        for j in range(-2, 3):\n            for k in range(-2, 3):\n                if (i + j + k) % 2 == 0:\n                    pts_fcc.append([float(i), float(j), float(k)])\n    pts_fcc = np.array(pts_fcc)\n    dists_fcc = np.sum((pts_fcc - np.mean(pts_fcc, axis=0))**2, axis=1)\n    starts.append(pts_fcc[np.argsort(dists_fcc)[:N]])\n\n    # 2. Hexagonal Close-Packed (HCP) subset\n    pts_hcp = []\n    for z in range(-2, 3):\n        for y in range(-2, 3):\n            for x in range(-2, 3):\n                pts_hcp.append([\n                    float(2*x + (y + z) % 2),\n                    float(np.sqrt(3) * (y + (z % 2) / 3.0)),\n                    float((2.0 * np.sqrt(6.0) / 3.0) * z)\n                ])\n    pts_hcp = np.array(pts_hcp)\n    dists_hcp = np.sum((pts_hcp - np.mean(pts_hcp, axis=0))**2, axis=1)\n    starts.append(pts_hcp[np.argsort(dists_hcp)[:N]])\n\n    # 3. FCC unit cell (8 corners + 6 face centers)\n    pts_fcc_unit = np.array([\n        [0,0,0], [2,0,0], [0,2,0], [0,0,2], [2,2,0], [2,0,2], [0,2,2], [2,2,2], # 8 corners\n        [1,1,0], [1,1,2], [1,0,1], [1,2,1], [0,1,1], [2,1,1]                    # 6 face centers\n    ], dtype=float)\n    starts.append(pts_fcc_unit)\n\n    # 4. Random points on a sphere\n    np.random.seed(42)\n    pts_rand = np.random.normal(0, 1, (N, dim))\n    pts_rand /= np.linalg.norm(pts_rand, axis=1)[:, np.newaxis]\n    starts.append(pts_rand)\n\n    best_pts = None\n    best_ratio = -1.0\n\n    # Optimization loop\n    for pts_init in starts:\n        # Pre-process: center and normalize the starting point\n        pts_init = pts_init - np.mean(pts_init, axis=0)\n        max_d_sq = np.max(pdist(pts_init)**2)\n        pts_init = pts_init / np.sqrt(max_d_sq)\n        \n        # Initial value for the slack variable\n        dmin_sq_init = np.min(pdist(pts_init)**2)\n        \n        # Variables: [x1, y1, z1, ..., x14, y14, z14, dmin_sq]\n        vars_init = np.concatenate([pts_init.flatten(), [dmin_sq_init]])\n        \n        # Use SLSQP to maximize the minimum distance subject to max_dist_sq <= 1\n        res = minimize(\n            objective, \n            vars_init, \n            method='SLSQP', \n            constraints=[\n                {'type': 'ineq', 'fun': constraint_min},\n                {'type': 'ineq', 'fun': constraint_max}\n            ],\n            options={'maxiter': 150}\n        )\n        \n        if res.success or True:\n            pts_res = res.x[:-1].reshape(N, dim)\n            ratio = get_ratio_sq(pts_res)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_pts = pts_res\n\n    # Final normalization to ensure max_dist_sq is exactly 1.0\n    if best_pts is not None:\n        best_pts = best_pts / np.sqrt(np.max(pdist(best_pts)**2))\n    else:\n        # Fallback to a simple starting point if optimization failed\n        best_pts = starts[0] / np.sqrt(np.max(pdist(starts[0])**2))\n        \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:15:32.066913",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 213,
        "candidates_token_count": 1450,
        "thoughts_token_count": 22450
      },
      "response_text_len": 4162
    }
  }
}