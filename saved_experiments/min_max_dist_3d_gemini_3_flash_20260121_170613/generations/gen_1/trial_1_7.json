{
  "trial_id": "trial_1_7",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D that maximize the squared ratio (min_dist / max_dist)^2.\n    Uses constrained optimization (SLSQP) to maximize the minimum distance 'd'\n    subject to the diameter being at most 1.\n    \"\"\"\n    N = 14\n    # Precompute indices for all unique pairs (i, j) with i < j\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    n_pairs = len(idx_i)\n    \n    # We formulate the problem as:\n    # Maximize s (where s = d_min^2)\n    # Subject to:\n    #   1. ||p_i - p_j||^2 >= s   (for all pairs)\n    #   2. ||p_i - p_j||^2 <= 1   (for all pairs, implicitly setting d_max <= 1)\n    \n    # The optimization variable x contains flattened coordinates and s:\n    # x = [p1_x, p1_y, p1_z, ..., p14_z, s]\n    # Size: 3*14 + 1 = 43\n    \n    def unpack(x):\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        return pts, s\n    \n    # Objective: Minimize -s (to maximize s)\n    def objective(x):\n        return -x[-1]\n    \n    # Gradient of objective\n    def jac_obj(x):\n        g = np.zeros_like(x)\n        g[-1] = -1.0\n        return g\n    \n    # Constraints function for SLSQP\n    # Returns vector of values that must be >= 0\n    def constraints(x):\n        pts, s = unpack(x)\n        # Vectorized pairwise differences\n        vecs = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(vecs**2, axis=1)\n        \n        # Constraint 1: d2 - s >= 0\n        c1 = d2 - s\n        # Constraint 2: 1 - d2 >= 0\n        c2 = 1.0 - d2\n        \n        return np.concatenate([c1, c2])\n    \n    # Jacobian of constraints\n    # Matrix shape: (2 * n_pairs, 3 * N + 1)\n    def jac_con(x):\n        pts, s = unpack(x)\n        vecs = pts[idx_i] - pts[idx_j]\n        \n        # Gradient of d^2 w.r.t coordinates is 2*(diff)\n        grad_d2 = 2 * vecs # Shape (n_pairs, 3)\n        \n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        # Fill Jacobian efficiently\n        # Rows 0..n_pairs-1 are for (d2 >= s)\n        # Rows n_pairs..2*n_pairs-1 are for (d2 <= 1)\n        \n        for k in range(n_pairs):\n            u = idx_i[k]\n            v = idx_j[k]\n            \n            iu, iv = 3*u, 3*v\n            \n            # Gradients for c1[k]: d2_k - s >= 0\n            jac[k, iu:iu+3] = grad_d2[k]\n            jac[k, iv:iv+3] = -grad_d2[k]\n            jac[k, -1] = -1.0\n            \n            # Gradients for c2[k]: 1 - d2_k >= 0\n            jac[n_pairs+k, iu:iu+3] = -grad_d2[k]\n            jac[n_pairs+k, iv:iv+3] = grad_d2[k]\n            # w.r.t s is 0\n            \n        return jac\n\n    # Generate diverse initial seeds\n    seeds = []\n    \n    # 1. Bicapped Hexagonal Antiprism (Approximate optimal topology for N=14 on sphere)\n    r = 0.5\n    h = 0.25\n    pts_hex = []\n    for i in range(6):\n        theta = 2 * np.pi * i / 6\n        # Ring 1\n        pts_hex.append([r*np.cos(theta), r*np.sin(theta), h])\n        # Ring 2 (twisted)\n        pts_hex.append([r*np.cos(theta + np.pi/6), r*np.sin(theta + np.pi/6), -h])\n    # Caps\n    pts_hex.append([0, 0, 0.5])\n    pts_hex.append([0, 0, -0.5])\n    seeds.append(np.array(pts_hex))\n    \n    # 2. Random points on sphere\n    for _ in range(15):\n        pts = np.random.randn(N, 3)\n        pts /= np.linalg.norm(pts, axis=1, keepdims=True)\n        pts *= 0.5\n        seeds.append(pts)\n        \n    # 3. Random points in box\n    for _ in range(5):\n        pts = np.random.uniform(-0.5, 0.5, (N, 3))\n        seeds.append(pts)\n\n    best_score = -1.0\n    best_pts = seeds[0] # Fallback\n    \n    start_time = time.time()\n    \n    # Run optimization with restarts\n    for seed in seeds:\n        # Check time limit\n        if time.time() - start_time > 55:\n            break\n            \n        # Normalize seed diameter to 1.0 to start in feasible region wrt upper bound\n        diffs = seed[idx_i] - seed[idx_j]\n        dists = np.linalg.norm(diffs, axis=1)\n        d_max = np.max(dists)\n        if d_max > 1e-9:\n            seed = seed / d_max\n        \n        # Initial guess for s (min distance squared)\n        d2 = dists**2 / (d_max**2 if d_max > 0 else 1.0)\n        s0 = np.min(d2) * 0.95 # Start slightly conservative\n        \n        x0 = np.concatenate([seed.flatten(), [s0]])\n        \n        try:\n            res = minimize(\n                objective, \n                x0, \n                method='SLSQP', \n                jac=jac_obj,\n                constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_con},\n                options={'maxiter': 300, 'ftol': 1e-5}\n            )\n            \n            # Process result\n            pts_out, s_out = unpack(res.x)\n            \n            # Calculate actual score\n            diffs = pts_out[idx_i] - pts_out[idx_j]\n            dists = np.linalg.norm(diffs, axis=1)\n            \n            d_min_val = np.min(dists)\n            d_max_val = np.max(dists)\n            \n            if d_max_val > 1e-9:\n                score = (d_min_val / d_max_val)**2\n                if score > best_score:\n                    best_score = score\n                    best_pts = pts_out\n                    \n        except Exception:\n            continue\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9960282131789477,
    "min_max_ratio": 0.2390936468878542,
    "min_distance": 0.4889725938012825,
    "max_distance": 1.0000011514329008,
    "eval_time": 0.5204849243164062,
    "error": null
  },
  "prompt": "Use a constrained optimization approach. Maximize a variable 'd' subject to the constraint that all pairwise distances are greater than or equal to 'd', and the maximum distance between any two points is 1.",
  "response": "Here is the Python solution using a constrained optimization approach with `scipy.optimize`.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D that maximize the squared ratio (min_dist / max_dist)^2.\n    Uses constrained optimization (SLSQP) to maximize the minimum distance 'd'\n    subject to the diameter being at most 1.\n    \"\"\"\n    N = 14\n    # Precompute indices for all unique pairs (i, j) with i < j\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    n_pairs = len(idx_i)\n    \n    # We formulate the problem as:\n    # Maximize s (where s = d_min^2)\n    # Subject to:\n    #   1. ||p_i - p_j||^2 >= s   (for all pairs)\n    #   2. ||p_i - p_j||^2 <= 1   (for all pairs, implicitly setting d_max <= 1)\n    \n    # The optimization variable x contains flattened coordinates and s:\n    # x = [p1_x, p1_y, p1_z, ..., p14_z, s]\n    # Size: 3*14 + 1 = 43\n    \n    def unpack(x):\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        return pts, s\n    \n    # Objective: Minimize -s (to maximize s)\n    def objective(x):\n        return -x[-1]\n    \n    # Gradient of objective\n    def jac_obj(x):\n        g = np.zeros_like(x)\n        g[-1] = -1.0\n        return g\n    \n    # Constraints function for SLSQP\n    # Returns vector of values that must be >= 0\n    def constraints(x):\n        pts, s = unpack(x)\n        # Vectorized pairwise differences\n        vecs = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(vecs**2, axis=1)\n        \n        # Constraint 1: d2 - s >= 0\n        c1 = d2 - s\n        # Constraint 2: 1 - d2 >= 0\n        c2 = 1.0 - d2\n        \n        return np.concatenate([c1, c2])\n    \n    # Jacobian of constraints\n    # Matrix shape: (2 * n_pairs, 3 * N + 1)\n    def jac_con(x):\n        pts, s = unpack(x)\n        vecs = pts[idx_i] - pts[idx_j]\n        \n        # Gradient of d^2 w.r.t coordinates is 2*(diff)\n        grad_d2 = 2 * vecs # Shape (n_pairs, 3)\n        \n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        # Fill Jacobian efficiently\n        # Rows 0..n_pairs-1 are for (d2 >= s)\n        # Rows n_pairs..2*n_pairs-1 are for (d2 <= 1)\n        \n        for k in range(n_pairs):\n            u = idx_i[k]\n            v = idx_j[k]\n            \n            iu, iv = 3*u, 3*v\n            \n            # Gradients for c1[k]: d2_k - s >= 0\n            jac[k, iu:iu+3] = grad_d2[k]\n            jac[k, iv:iv+3] = -grad_d2[k]\n            jac[k, -1] = -1.0\n            \n            # Gradients for c2[k]: 1 - d2_k >= 0\n            jac[n_pairs+k, iu:iu+3] = -grad_d2[k]\n            jac[n_pairs+k, iv:iv+3] = grad_d2[k]\n            # w.r.t s is 0\n            \n        return jac\n\n    # Generate diverse initial seeds\n    seeds = []\n    \n    # 1. Bicapped Hexagonal Antiprism (Approximate optimal topology for N=14 on sphere)\n    r = 0.5\n    h = 0.25\n    pts_hex = []\n    for i in range(6):\n        theta = 2 * np.pi * i / 6\n        # Ring 1\n        pts_hex.append([r*np.cos(theta), r*np.sin(theta), h])\n        # Ring 2 (twisted)\n        pts_hex.append([r*np.cos(theta + np.pi/6), r*np.sin(theta + np.pi/6), -h])\n    # Caps\n    pts_hex.append([0, 0, 0.5])\n    pts_hex.append([0, 0, -0.5])\n    seeds.append(np.array(pts_hex))\n    \n    # 2. Random points on sphere\n    for _ in range(15):\n        pts = np.random.randn(N, 3)\n        pts /= np.linalg.norm(pts, axis=1, keepdims=True)\n        pts *= 0.5\n        seeds.append(pts)\n        \n    # 3. Random points in box\n    for _ in range(5):\n        pts = np.random.uniform(-0.5, 0.5, (N, 3))\n        seeds.append(pts)\n\n    best_score = -1.0\n    best_pts = seeds[0] # Fallback\n    \n    start_time = time.time()\n    \n    # Run optimization with restarts\n    for seed in seeds:\n        # Check time limit\n        if time.time() - start_time > 55:\n            break\n            \n        # Normalize seed diameter to 1.0 to start in feasible region wrt upper bound\n        diffs = seed[idx_i] - seed[idx_j]\n        dists = np.linalg.norm(diffs, axis=1)\n        d_max = np.max(dists)\n        if d_max > 1e-9:\n            seed = seed / d_max\n        \n        # Initial guess for s (min distance squared)\n        d2 = dists**2 / (d_max**2 if d_max > 0 else 1.0)\n        s0 = np.min(d2) * 0.95 # Start slightly conservative\n        \n        x0 = np.concatenate([seed.flatten(), [s0]])\n        \n        try:\n            res = minimize(\n                objective, \n                x0, \n                method='SLSQP', \n                jac=jac_obj,\n                constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_con},\n                options={'maxiter': 300, 'ftol': 1e-5}\n            )\n            \n            # Process result\n            pts_out, s_out = unpack(res.x)\n            \n            # Calculate actual score\n            diffs = pts_out[idx_i] - pts_out[idx_j]\n            dists = np.linalg.norm(diffs, axis=1)\n            \n            d_min_val = np.min(dists)\n            d_max_val = np.max(dists)\n            \n            if d_max_val > 1e-9:\n                score = (d_min_val / d_max_val)**2\n                if score > best_score:\n                    best_score = score\n                    best_pts = pts_out\n                    \n        except Exception:\n            continue\n            \n    return best_pts\n```",
  "reasoning": "Here is the Python solution using a constrained optimization approach with `scipy.optimize`.",
  "timestamp": "2026-01-21T17:15:14.566009",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 214,
        "candidates_token_count": 1867,
        "thoughts_token_count": 12441
      },
      "response_text_len": 5298
    }
  }
}