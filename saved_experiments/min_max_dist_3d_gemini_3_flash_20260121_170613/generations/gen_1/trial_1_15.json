{
  "trial_id": "trial_1_15",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds the arrangement of 14 points in 3D that maximizes the squared ratio\n    (min pairwise distance / max pairwise distance)^2.\n    Uses a Particle Swarm Optimization (PSO) approach combined with local\n    refinement (memetic algorithm).\n    \"\"\"\n    n_points = 14\n    n_particles = 12\n    \n    def get_ratio_sq(pts_flat):\n        \"\"\"Calculates the squared ratio for a given flat coordinate array.\"\"\"\n        p = pts_flat.reshape(n_points, 3)\n        # Pairwise squared distances\n        d2 = np.sum((p[:, None, :] - p[None, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n_points, k=1)\n        d2_tri = d2[i, j]\n        max_d2 = np.max(d2_tri)\n        if max_d2 < 1e-12:\n            return 0\n        return np.min(d2_tri) / max_d2\n\n    # Initialize particles (coordinates)\n    particles = []\n    for i in range(n_particles):\n        if i % 2 == 0:\n            # Random points on a unit sphere\n            p = np.random.randn(n_points, 3)\n            p /= (np.linalg.norm(p, axis=1, keepdims=True) + 1e-12)\n        else:\n            # Random points within a unit cube\n            p = np.random.uniform(-1, 1, (n_points, 3))\n        particles.append(p.flatten())\n    \n    particles = np.array(particles)\n    velocities = np.zeros_like(particles)\n    pbest = np.copy(particles)\n    pbest_scores = np.array([get_ratio_sq(p) for p in particles])\n    \n    gbest_idx = np.argmax(pbest_scores)\n    gbest = np.copy(pbest[gbest_idx])\n    gbest_score = pbest_scores[gbest_idx]\n    \n    # PSO loop\n    for iteration in range(20):\n        for i in range(n_particles):\n            # Update velocity and position using standard PSO rules\n            r1, r2 = np.random.rand(n_points * 3), np.random.rand(n_points * 3)\n            # w=0.5, c1=1.5, c2=1.5\n            velocities[i] = 0.5 * velocities[i] + 1.5 * r1 * (pbest[i] - particles[i]) + 1.5 * r2 * (gbest - particles[i])\n            particles[i] += velocities[i]\n            \n            # Memetic refinement: Occasional local search to push points apart\n            if iteration % 5 == 0:\n                def repulsion(coords):\n                    p = coords.reshape((n_points, 3))\n                    d2 = np.sum((p[:, None, :] - p[None, :, :])**2, axis=-1)\n                    i, j = np.triu_indices(n_points, k=1)\n                    # Use a penalty for points being near each other and for drifting from the origin\n                    r2 = np.sum(p**2, axis=1)\n                    return np.sum(1.0 / (d2[i, j]**2 + 1e-8)) + 0.1 * np.sum((r2 - 1)**2)\n                \n                res = minimize(repulsion, particles[i], method='L-BFGS-B', options={'maxiter': 30})\n                particles[i] = res.x\n\n            # Update personal and global bests\n            score = get_ratio_sq(particles[i])\n            if score > pbest_scores[i]:\n                pbest_scores[i] = score\n                pbest[i] = np.copy(particles[i])\n                if score > gbest_score:\n                    gbest_score = score\n                    gbest = np.copy(particles[i])\n    \n    # Final refinement: Direct optimization of the ratio objective\n    def objective(coords):\n        p = coords.reshape((n_points, 3))\n        # Center points to keep the problem well-conditioned\n        p = p - np.mean(p, axis=0)\n        d2 = np.sum((p[:, None, :] - p[None, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n_points, k=1)\n        d2_tri = d2[i, j]\n        min_d2 = np.min(d2_tri)\n        max_d2 = np.max(d2_tri)\n        if max_d2 < 1e-12:\n            return 0\n        # Minimize negative ratio to maximize the actual ratio\n        return -min_d2 / max_d2\n    \n    # Ensure starting point for final search is normalized\n    gbest_pts = gbest.reshape(n_points, 3)\n    gbest_pts /= (np.linalg.norm(gbest_pts, axis=1, keepdims=True) + 1e-12)\n    gbest = gbest_pts.flatten()\n    \n    # SLSQP is effective for non-smooth objectives like min/max\n    res = minimize(objective, gbest, method='SLSQP', options={'maxiter': 250})\n    \n    # Reshape and return the final coordinates\n    final_pts = res.x.reshape(n_points, 3)\n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.9290791083117687,
    "min_max_ratio": 0.22302271091759432,
    "min_distance": 0.9264029329873851,
    "max_distance": 1.9616674058360493,
    "eval_time": 2.072981119155884,
    "error": null
  },
  "prompt": "Implement a particle swarm optimization (PSO) to find the best arrangement of 14 points in 3D for the max-min distance problem.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds the arrangement of 14 points in 3D that maximizes the squared ratio\n    (min pairwise distance / max pairwise distance)^2.\n    Uses a Particle Swarm Optimization (PSO) approach combined with local\n    refinement (memetic algorithm).\n    \"\"\"\n    n_points = 14\n    n_particles = 12\n    \n    def get_ratio_sq(pts_flat):\n        \"\"\"Calculates the squared ratio for a given flat coordinate array.\"\"\"\n        p = pts_flat.reshape(n_points, 3)\n        # Pairwise squared distances\n        d2 = np.sum((p[:, None, :] - p[None, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n_points, k=1)\n        d2_tri = d2[i, j]\n        max_d2 = np.max(d2_tri)\n        if max_d2 < 1e-12:\n            return 0\n        return np.min(d2_tri) / max_d2\n\n    # Initialize particles (coordinates)\n    particles = []\n    for i in range(n_particles):\n        if i % 2 == 0:\n            # Random points on a unit sphere\n            p = np.random.randn(n_points, 3)\n            p /= (np.linalg.norm(p, axis=1, keepdims=True) + 1e-12)\n        else:\n            # Random points within a unit cube\n            p = np.random.uniform(-1, 1, (n_points, 3))\n        particles.append(p.flatten())\n    \n    particles = np.array(particles)\n    velocities = np.zeros_like(particles)\n    pbest = np.copy(particles)\n    pbest_scores = np.array([get_ratio_sq(p) for p in particles])\n    \n    gbest_idx = np.argmax(pbest_scores)\n    gbest = np.copy(pbest[gbest_idx])\n    gbest_score = pbest_scores[gbest_idx]\n    \n    # PSO loop\n    for iteration in range(20):\n        for i in range(n_particles):\n            # Update velocity and position using standard PSO rules\n            r1, r2 = np.random.rand(n_points * 3), np.random.rand(n_points * 3)\n            # w=0.5, c1=1.5, c2=1.5\n            velocities[i] = 0.5 * velocities[i] + 1.5 * r1 * (pbest[i] - particles[i]) + 1.5 * r2 * (gbest - particles[i])\n            particles[i] += velocities[i]\n            \n            # Memetic refinement: Occasional local search to push points apart\n            if iteration % 5 == 0:\n                def repulsion(coords):\n                    p = coords.reshape((n_points, 3))\n                    d2 = np.sum((p[:, None, :] - p[None, :, :])**2, axis=-1)\n                    i, j = np.triu_indices(n_points, k=1)\n                    # Use a penalty for points being near each other and for drifting from the origin\n                    r2 = np.sum(p**2, axis=1)\n                    return np.sum(1.0 / (d2[i, j]**2 + 1e-8)) + 0.1 * np.sum((r2 - 1)**2)\n                \n                res = minimize(repulsion, particles[i], method='L-BFGS-B', options={'maxiter': 30})\n                particles[i] = res.x\n\n            # Update personal and global bests\n            score = get_ratio_sq(particles[i])\n            if score > pbest_scores[i]:\n                pbest_scores[i] = score\n                pbest[i] = np.copy(particles[i])\n                if score > gbest_score:\n                    gbest_score = score\n                    gbest = np.copy(particles[i])\n    \n    # Final refinement: Direct optimization of the ratio objective\n    def objective(coords):\n        p = coords.reshape((n_points, 3))\n        # Center points to keep the problem well-conditioned\n        p = p - np.mean(p, axis=0)\n        d2 = np.sum((p[:, None, :] - p[None, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n_points, k=1)\n        d2_tri = d2[i, j]\n        min_d2 = np.min(d2_tri)\n        max_d2 = np.max(d2_tri)\n        if max_d2 < 1e-12:\n            return 0\n        # Minimize negative ratio to maximize the actual ratio\n        return -min_d2 / max_d2\n    \n    # Ensure starting point for final search is normalized\n    gbest_pts = gbest.reshape(n_points, 3)\n    gbest_pts /= (np.linalg.norm(gbest_pts, axis=1, keepdims=True) + 1e-12)\n    gbest = gbest_pts.flatten()\n    \n    # SLSQP is effective for non-smooth objectives like min/max\n    res = minimize(objective, gbest, method='SLSQP', options={'maxiter': 250})\n    \n    # Reshape and return the final coordinates\n    final_pts = res.x.reshape(n_points, 3)\n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:17:36.230313",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 202,
        "candidates_token_count": 1374,
        "thoughts_token_count": 18309
      },
      "response_text_len": 4180
    }
  }
}