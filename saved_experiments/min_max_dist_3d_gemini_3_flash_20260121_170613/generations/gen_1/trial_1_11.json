{
  "trial_id": "trial_1_11",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min_dist / max_dist)^2.\n    Uses a multi-start local optimization approach with a smooth Log-Sum-Exp objective.\n    \"\"\"\n    \n    def get_score(pts):\n        \"\"\"Calculates the squared ratio of (min pairwise distance / max pairwise distance).\"\"\"\n        pts = pts.reshape((14, 3))\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        min_d = np.min(dists)\n        max_d = np.max(dists)\n        return (min_d / max_d)**2\n\n    def smooth_obj(coords, k):\n        \"\"\"\n        Differentiable approximation of log(max_dist / min_dist).\n        Minimizing this is equivalent to maximizing (min_dist / max_dist).\n        Using the Log-Sum-Exp trick for numerical stability.\n        \"\"\"\n        pts = coords.reshape((14, 3))\n        dists = pdist(pts)\n        d_max = np.max(dists)\n        d_min = np.min(dists)\n        \n        # log(sum(exp(k * dists))) / k\n        # We use k*(dists - d_max) to keep the exponent values within a safe range.\n        max_term = d_max + np.log(np.sum(np.exp(np.clip(k * (dists - d_max), -500, 500)))) / k\n        \n        # -log(sum(exp(-k * dists))) / k\n        # Similarly, we use -k*(dists - d_min) for stability.\n        min_term = d_min - np.log(np.sum(np.exp(np.clip(-k * (dists - d_min), -500, 500)))) / k\n        \n        return max_term - min_term\n\n    # Collection of starting points for local optimization\n    starts = []\n    \n    # 1. Cube + Octahedron structure (8 + 6 = 14 points)\n    cube = np.array([[x, y, z] for x in [-1, 1] for y in [-1, 1] for z in [-1, 1]])\n    octa = np.array([[1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]])\n    starts.append(np.vstack([cube, octa]).flatten())\n    \n    # 2. Bicapped hexagonal antiprism (2 poles + 2 rings of 6)\n    h = 0.55\n    cap = np.array([[0, 0, 1.2], [0, 0, -1.2]])\n    ring1 = np.array([[np.cos(i * np.pi / 3), np.sin(i * np.pi / 3), h] for i in range(6)])\n    ring2 = np.array([[np.cos(i * np.pi / 3 + np.pi / 6), np.sin(i * np.pi / 3 + np.pi / 6), -h] for i in range(6)])\n    starts.append(np.vstack([cap, ring1, ring2]).flatten())\n    \n    # 3. Fibonacci sphere distribution\n    phi = np.pi * (3. - np.sqrt(5.))\n    fib = []\n    for i in range(14):\n        y = 1 - (i / 13.0) * 2\n        radius = np.sqrt(max(0, 1 - y * y))\n        theta = phi * i\n        fib.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    starts.append(np.array(fib).flatten())\n\n    # 4. Random starts to cover the search space\n    np.random.seed(42)\n    for _ in range(25):\n        starts.append(np.random.uniform(-1.0, 1.0, (14, 3)).flatten())\n\n    best_pts = None\n    best_score = -1\n    start_time = time.time()\n    \n    # Multi-start optimization loop\n    for x0 in starts:\n        # Check time limit (60 seconds)\n        if time.time() - start_time > 55:\n            break\n            \n        res = x0\n        # Refine the point configuration using L-BFGS-B with increasing precision\n        for k_val in [30, 120]:\n            res_opt = minimize(\n                smooth_obj, \n                res, \n                args=(k_val,), \n                method='L-BFGS-B', \n                bounds=[(-2.0, 2.0)] * 42, \n                options={'maxiter': 100}\n            )\n            res = res_opt.x\n            \n        # Calculate final fitness for this local optimum\n        pts_final = res.reshape((14, 3))\n        score = get_score(pts_final)\n        \n        if score > best_score:\n            best_score = score\n            best_pts = pts_final\n            \n    # Return the best configuration found as a 14x3 numpy array\n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.4894693924267075,
    "min_max_ratio": 0.11749568990799075,
    "min_distance": 6.737402866035856e-06,
    "max_distance": 1.9655384734565838e-05,
    "eval_time": 1.6623380184173584,
    "error": null
  },
  "prompt": "Use a genetic algorithm approach to evolve the coordinates of 14 points. The fitness function should be the squared ratio of min_dist to max_dist.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min_dist / max_dist)^2.\n    Uses a multi-start local optimization approach with a smooth Log-Sum-Exp objective.\n    \"\"\"\n    \n    def get_score(pts):\n        \"\"\"Calculates the squared ratio of (min pairwise distance / max pairwise distance).\"\"\"\n        pts = pts.reshape((14, 3))\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        min_d = np.min(dists)\n        max_d = np.max(dists)\n        return (min_d / max_d)**2\n\n    def smooth_obj(coords, k):\n        \"\"\"\n        Differentiable approximation of log(max_dist / min_dist).\n        Minimizing this is equivalent to maximizing (min_dist / max_dist).\n        Using the Log-Sum-Exp trick for numerical stability.\n        \"\"\"\n        pts = coords.reshape((14, 3))\n        dists = pdist(pts)\n        d_max = np.max(dists)\n        d_min = np.min(dists)\n        \n        # log(sum(exp(k * dists))) / k\n        # We use k*(dists - d_max) to keep the exponent values within a safe range.\n        max_term = d_max + np.log(np.sum(np.exp(np.clip(k * (dists - d_max), -500, 500)))) / k\n        \n        # -log(sum(exp(-k * dists))) / k\n        # Similarly, we use -k*(dists - d_min) for stability.\n        min_term = d_min - np.log(np.sum(np.exp(np.clip(-k * (dists - d_min), -500, 500)))) / k\n        \n        return max_term - min_term\n\n    # Collection of starting points for local optimization\n    starts = []\n    \n    # 1. Cube + Octahedron structure (8 + 6 = 14 points)\n    cube = np.array([[x, y, z] for x in [-1, 1] for y in [-1, 1] for z in [-1, 1]])\n    octa = np.array([[1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]])\n    starts.append(np.vstack([cube, octa]).flatten())\n    \n    # 2. Bicapped hexagonal antiprism (2 poles + 2 rings of 6)\n    h = 0.55\n    cap = np.array([[0, 0, 1.2], [0, 0, -1.2]])\n    ring1 = np.array([[np.cos(i * np.pi / 3), np.sin(i * np.pi / 3), h] for i in range(6)])\n    ring2 = np.array([[np.cos(i * np.pi / 3 + np.pi / 6), np.sin(i * np.pi / 3 + np.pi / 6), -h] for i in range(6)])\n    starts.append(np.vstack([cap, ring1, ring2]).flatten())\n    \n    # 3. Fibonacci sphere distribution\n    phi = np.pi * (3. - np.sqrt(5.))\n    fib = []\n    for i in range(14):\n        y = 1 - (i / 13.0) * 2\n        radius = np.sqrt(max(0, 1 - y * y))\n        theta = phi * i\n        fib.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    starts.append(np.array(fib).flatten())\n\n    # 4. Random starts to cover the search space\n    np.random.seed(42)\n    for _ in range(25):\n        starts.append(np.random.uniform(-1.0, 1.0, (14, 3)).flatten())\n\n    best_pts = None\n    best_score = -1\n    start_time = time.time()\n    \n    # Multi-start optimization loop\n    for x0 in starts:\n        # Check time limit (60 seconds)\n        if time.time() - start_time > 55:\n            break\n            \n        res = x0\n        # Refine the point configuration using L-BFGS-B with increasing precision\n        for k_val in [30, 120]:\n            res_opt = minimize(\n                smooth_obj, \n                res, \n                args=(k_val,), \n                method='L-BFGS-B', \n                bounds=[(-2.0, 2.0)] * 42, \n                options={'maxiter': 100}\n            )\n            res = res_opt.x\n            \n        # Calculate final fitness for this local optimum\n        pts_final = res.reshape((14, 3))\n        score = get_score(pts_final)\n        \n        if score > best_score:\n            best_score = score\n            best_pts = pts_final\n            \n    # Return the best configuration found as a 14x3 numpy array\n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:16:53.014728",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 204,
        "candidates_token_count": 1357,
        "thoughts_token_count": 16248
      },
      "response_text_len": 3813
    }
  }
}