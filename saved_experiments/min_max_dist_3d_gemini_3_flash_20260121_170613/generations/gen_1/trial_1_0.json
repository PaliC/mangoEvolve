{
  "trial_id": "trial_1_0",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance).\n    The approach uses a SoftMin/SoftMax objective (Log-Sum-Exp) to approximate the ratio \n    and optimizes it using scipy.optimize.minimize with multiple random initializations.\n    \"\"\"\n    n_points = 14\n    dim = 3\n    \n    def get_score(pts):\n        \"\"\"Calculates the squared ratio (min distance / max distance)^2.\"\"\"\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        return (np.min(dists) / np.max(dists))**2\n\n    def objective(coords, k):\n        \"\"\"\n        Scale-invariant objective function to maximize the ratio d_min / d_max.\n        We minimize ln(d_max / d_min) = ln(d_max) - ln(d_min).\n        Using Log-Sum-Exp for smooth approximations of max and min.\n        \"\"\"\n        pts = coords.reshape((n_points, dim))\n        dists = pdist(pts)\n        # Avoid log(0) and potential stability issues\n        dists = np.maximum(dists, 1e-10)\n        log_dists = np.log(dists)\n        \n        # Smooth approximation of ln(d_max):\n        # SoftMax(log_dists) = (1/k) * ln(sum(exp(k * log_dists)))\n        x_max = k * log_dists\n        max_x_max = np.max(x_max)\n        lse_max = max_x_max + np.log(np.sum(np.exp(x_max - max_x_max)))\n        \n        # Smooth approximation of -ln(d_min):\n        # -SoftMin(log_dists) = (1/k) * ln(sum(exp(-k * log_dists)))\n        x_min = -k * log_dists\n        max_x_min = np.max(x_min)\n        lse_min = max_x_min + np.log(np.sum(np.exp(x_min - max_x_min)))\n        \n        # The sum (lse_max + lse_min) / k approximates ln(d_max) - ln(d_min)\n        return (lse_max + lse_min) / k\n\n    best_pts = None\n    best_score = -1\n    start_time = time.time()\n    \n    # 1. Start with random points in a unit cube as requested\n    inits = [np.random.uniform(-0.5, 0.5, (n_points, dim)).flatten()]\n    \n    # 2. Add Fibonacci sphere initialization for better coverage\n    phi = np.pi * (3. - np.sqrt(5.))  # golden angle\n    pts_fib = []\n    for i in range(n_points):\n        y = 1 - (i / float(n_points - 1)) * 2\n        radius = np.sqrt(1 - y * y)\n        theta = phi * i\n        pts_fib.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    inits.append(np.array(pts_fib).flatten())\n    \n    # 3. Add random points on a sphere\n    for _ in range(3):\n        pts_sphere = np.random.normal(0, 1, (n_points, 3))\n        pts_sphere /= np.linalg.norm(pts_sphere, axis=1)[:, np.newaxis]\n        inits.append(pts_sphere.flatten())\n\n    idx = 0\n    # Optimization loop\n    while time.time() - start_time < 55:\n        if idx < len(inits):\n            x0 = inits[idx]\n            idx += 1\n        else:\n            # Continue with random starts in a unit cube\n            x0 = np.random.uniform(-0.5, 0.5, (n_points, dim)).flatten()\n        \n        # Use two stages of optimization with increasing k for better convergence\n        try:\n            res = minimize(objective, x0, args=(20,), method='L-BFGS-B', options={'maxiter': 100})\n            res = minimize(objective, res.x, args=(60,), method='L-BFGS-B', options={'maxiter': 200})\n            \n            pts_opt = res.x.reshape((n_points, dim))\n            score = get_score(pts_opt)\n            \n            if score > best_score:\n                best_score = score\n                best_pts = pts_opt\n        except Exception:\n            # In case of numerical issues with specific random starts\n            continue\n                \n    # Return the best configuration found as a (14, 3) numpy array\n    return best_pts.reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 0.9776173062646258,
    "min_max_ratio": 0.2346741627623908,
    "min_distance": 0.6241451953973637,
    "max_distance": 1.2884067550775784,
    "eval_time": 55.26427102088928,
    "error": null
  },
  "prompt": "Maximize the minimum pairwise distance between 14 points in 3D space. Use scipy.optimize.minimize with a 'SoftMin' objective (Log-Sum-Exp) to approximate the minimum distance. Start with random points in a unit cube.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance).\n    The approach uses a SoftMin/SoftMax objective (Log-Sum-Exp) to approximate the ratio \n    and optimizes it using scipy.optimize.minimize with multiple random initializations.\n    \"\"\"\n    n_points = 14\n    dim = 3\n    \n    def get_score(pts):\n        \"\"\"Calculates the squared ratio (min distance / max distance)^2.\"\"\"\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        return (np.min(dists) / np.max(dists))**2\n\n    def objective(coords, k):\n        \"\"\"\n        Scale-invariant objective function to maximize the ratio d_min / d_max.\n        We minimize ln(d_max / d_min) = ln(d_max) - ln(d_min).\n        Using Log-Sum-Exp for smooth approximations of max and min.\n        \"\"\"\n        pts = coords.reshape((n_points, dim))\n        dists = pdist(pts)\n        # Avoid log(0) and potential stability issues\n        dists = np.maximum(dists, 1e-10)\n        log_dists = np.log(dists)\n        \n        # Smooth approximation of ln(d_max):\n        # SoftMax(log_dists) = (1/k) * ln(sum(exp(k * log_dists)))\n        x_max = k * log_dists\n        max_x_max = np.max(x_max)\n        lse_max = max_x_max + np.log(np.sum(np.exp(x_max - max_x_max)))\n        \n        # Smooth approximation of -ln(d_min):\n        # -SoftMin(log_dists) = (1/k) * ln(sum(exp(-k * log_dists)))\n        x_min = -k * log_dists\n        max_x_min = np.max(x_min)\n        lse_min = max_x_min + np.log(np.sum(np.exp(x_min - max_x_min)))\n        \n        # The sum (lse_max + lse_min) / k approximates ln(d_max) - ln(d_min)\n        return (lse_max + lse_min) / k\n\n    best_pts = None\n    best_score = -1\n    start_time = time.time()\n    \n    # 1. Start with random points in a unit cube as requested\n    inits = [np.random.uniform(-0.5, 0.5, (n_points, dim)).flatten()]\n    \n    # 2. Add Fibonacci sphere initialization for better coverage\n    phi = np.pi * (3. - np.sqrt(5.))  # golden angle\n    pts_fib = []\n    for i in range(n_points):\n        y = 1 - (i / float(n_points - 1)) * 2\n        radius = np.sqrt(1 - y * y)\n        theta = phi * i\n        pts_fib.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    inits.append(np.array(pts_fib).flatten())\n    \n    # 3. Add random points on a sphere\n    for _ in range(3):\n        pts_sphere = np.random.normal(0, 1, (n_points, 3))\n        pts_sphere /= np.linalg.norm(pts_sphere, axis=1)[:, np.newaxis]\n        inits.append(pts_sphere.flatten())\n\n    idx = 0\n    # Optimization loop\n    while time.time() - start_time < 55:\n        if idx < len(inits):\n            x0 = inits[idx]\n            idx += 1\n        else:\n            # Continue with random starts in a unit cube\n            x0 = np.random.uniform(-0.5, 0.5, (n_points, dim)).flatten()\n        \n        # Use two stages of optimization with increasing k for better convergence\n        try:\n            res = minimize(objective, x0, args=(20,), method='L-BFGS-B', options={'maxiter': 100})\n            res = minimize(objective, res.x, args=(60,), method='L-BFGS-B', options={'maxiter': 200})\n            \n            pts_opt = res.x.reshape((n_points, dim))\n            score = get_score(pts_opt)\n            \n            if score > best_score:\n                best_score = score\n                best_pts = pts_opt\n        except Exception:\n            # In case of numerical issues with specific random starts\n            continue\n                \n    # Return the best configuration found as a (14, 3) numpy array\n    return best_pts.reshape((14, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:16:00.641946",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 223,
        "candidates_token_count": 1228,
        "thoughts_token_count": 19134
      },
      "response_text_len": 3734
    }
  }
}