{
  "trial_id": "trial_1_13",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes 14 points in 3D to maximize (min_dist / max_dist)^2.\n    Uses Riesz energy minimization on a sphere with increasing p (annealing).\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    # Precompute indices for vectorized operations\n    triu_indices = np.triu_indices(N, k=1)\n\n    def get_energy_and_grad(x_flat, p):\n        x = x_flat.reshape((N, dim))\n        \n        # Calculate pairwise difference vectors\n        # diff_tensor[i, j] = x[i] - x[j]\n        diff_tensor = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n        \n        # Squared distances\n        dists_sq = np.sum(diff_tensor**2, axis=-1)\n        \n        # Extract upper triangle (i < j)\n        r2 = dists_sq[triu_indices]\n        \n        # Avoid division by zero\n        r2 = np.maximum(r2, 1e-12)\n        \n        # Energy E = sum(1 / r^p) = sum((r^2)^(-p/2))\n        inv_r2 = 1.0 / r2\n        term = inv_r2 ** (p / 2.0)\n        E = np.sum(term)\n        \n        # Gradient calculation\n        # dE/dx_i = sum_j -p * (r_ij^2)^(-p/2 - 1) * (x_i - x_j)\n        coeffs = -p * term * inv_r2\n        \n        # Build coefficient matrix for efficient summation\n        C = np.zeros((N, N))\n        C[triu_indices] = coeffs\n        C = C + C.T  # Symmetric\n        \n        # grad_i = sum_j C_ij (x_i - x_j) = x_i * sum_j C_ij - sum_j C_ij x_j\n        sum_C = np.sum(C, axis=1).reshape(-1, 1)\n        grad = x * sum_C - C @ x\n        \n        return E, grad.flatten()\n\n    # Constraint: Points must lie on the unit sphere\n    def constraint_fun(x_flat):\n        x = x_flat.reshape((N, dim))\n        return np.sum(x**2, axis=1) - 1.0\n        \n    def constraint_jac(x_flat):\n        x = x_flat.reshape((N, dim))\n        # Jacobian is block diagonal with 1x3 blocks of 2*x_i\n        jac = np.zeros((N, N * dim))\n        for i in range(N):\n            jac[i, i*3 : i*3+3] = 2 * x[i]\n        return jac\n\n    cons = {'type': 'eq', 'fun': constraint_fun, 'jac': constraint_jac}\n    \n    # Schedule for p: annealing from soft repulsive to hard sphere\n    p_schedule = [2, 4, 8, 16, 32, 64] \n    \n    best_score = -1.0\n    best_points = None\n    \n    start_time = time.time()\n    \n    # Perform restarts to find global optimum\n    while time.time() - start_time < 50:  # 10s buffer\n        # Random initialization on sphere\n        x = np.random.randn(N, dim)\n        x /= np.linalg.norm(x, axis=1, keepdims=True)\n        x_flat = x.flatten()\n        \n        success_run = True\n        \n        for p in p_schedule:\n            try:\n                # Tighter tolerance for higher p\n                tol = 1e-6 if p >= 16 else 1e-4\n                \n                res = minimize(get_energy_and_grad, x_flat, args=(p,),\n                               method='SLSQP', jac=True, constraints=cons,\n                               options={'maxiter': 500, 'ftol': tol})\n                x_flat = res.x\n                \n                # Manual projection to correct numerical drift\n                x_tmp = x_flat.reshape((N, dim))\n                norm = np.linalg.norm(x_tmp, axis=1, keepdims=True)\n                x_tmp /= np.maximum(norm, 1e-9)\n                x_flat = x_tmp.flatten()\n            except Exception:\n                success_run = False\n                break\n        \n        if success_run:\n            points = x_flat.reshape((N, dim))\n            \n            # Calculate score: (min_dist / max_dist)^2\n            diff = points[:, np.newaxis, :] - points[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            \n            # Mask diagonal\n            mask = np.ones((N, N), dtype=bool)\n            np.fill_diagonal(mask, False)\n            valid_d2 = d2[mask]\n            \n            min_d2 = np.min(valid_d2)\n            max_d2 = np.max(valid_d2)\n            \n            if max_d2 > 1e-9:\n                score = min_d2 / max_d2\n            else:\n                score = 0.0\n            \n            if score > best_score:\n                best_score = score\n                best_points = points\n\n    # Fallback if optimization fails (unlikely)\n    if best_points is None:\n        best_points = np.random.randn(N, dim)\n        \n    return best_points",
  "metrics": {
    "valid": true,
    "score": 0.872837816159529,
    "min_max_ratio": 0.20952215393693746,
    "min_distance": 0.9154717990802697,
    "max_distance": 1.9999999990019144,
    "eval_time": 50.26229977607727,
    "error": null
  },
  "prompt": "Optimize 14 points by minimizing the energy function E = sum(1/dist_ij^p) where p starts at 2 and increases to 32. This is a common technique for finding spherical codes.",
  "response": "To solve the problem of placing 14 points in 3D space to maximize the squared ratio of the minimum pairwise distance to the maximum pairwise distance, we use the strategy of minimizing the Riesz energy $E = \\sum_{i \\neq j} \\frac{1}{d_{ij}^p}$ on a unit sphere. This is a known heuristic for generating spherical codes (Tammes problem). By progressively increasing the exponent $p$ (annealing), we approximate the \"hard sphere\" packing limit, which maximizes the minimum distance $d_{\\min}$. Since the points are on a sphere, the maximum distance $d_{\\max}$ is bounded by the diameter (2.0), and optimal configurations for $N=14$ typically span the sphere (antipodal or near-antipodal), making $d_{\\max} \\approx 2$. Thus, maximizing $d_{\\min}$ maximizes the ratio.\n\nThe algorithm:\n1. Initialize 14 points randomly on the unit sphere.\n2. Use `scipy.optimize.minimize` with the `SLSQP` method to handle the spherical constraint ($||x_i||^2 = 1$).\n3. Iterate $p$ through values $[2, 4, 8, 16, 32, 64]$. We start with a \"soft\" potential ($p=2$) to find a global arrangement and harden it to refine the packing.\n4. Perform multiple restarts within the time limit (60s) to avoid local minima.\n5. Select the configuration with the best squared ratio.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes 14 points in 3D to maximize (min_dist / max_dist)^2.\n    Uses Riesz energy minimization on a sphere with increasing p (annealing).\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    # Precompute indices for vectorized operations\n    triu_indices = np.triu_indices(N, k=1)\n\n    def get_energy_and_grad(x_flat, p):\n        x = x_flat.reshape((N, dim))\n        \n        # Calculate pairwise difference vectors\n        # diff_tensor[i, j] = x[i] - x[j]\n        diff_tensor = x[:, np.newaxis, :] - x[np.newaxis, :, :]\n        \n        # Squared distances\n        dists_sq = np.sum(diff_tensor**2, axis=-1)\n        \n        # Extract upper triangle (i < j)\n        r2 = dists_sq[triu_indices]\n        \n        # Avoid division by zero\n        r2 = np.maximum(r2, 1e-12)\n        \n        # Energy E = sum(1 / r^p) = sum((r^2)^(-p/2))\n        inv_r2 = 1.0 / r2\n        term = inv_r2 ** (p / 2.0)\n        E = np.sum(term)\n        \n        # Gradient calculation\n        # dE/dx_i = sum_j -p * (r_ij^2)^(-p/2 - 1) * (x_i - x_j)\n        coeffs = -p * term * inv_r2\n        \n        # Build coefficient matrix for efficient summation\n        C = np.zeros((N, N))\n        C[triu_indices] = coeffs\n        C = C + C.T  # Symmetric\n        \n        # grad_i = sum_j C_ij (x_i - x_j) = x_i * sum_j C_ij - sum_j C_ij x_j\n        sum_C = np.sum(C, axis=1).reshape(-1, 1)\n        grad = x * sum_C - C @ x\n        \n        return E, grad.flatten()\n\n    # Constraint: Points must lie on the unit sphere\n    def constraint_fun(x_flat):\n        x = x_flat.reshape((N, dim))\n        return np.sum(x**2, axis=1) - 1.0\n        \n    def constraint_jac(x_flat):\n        x = x_flat.reshape((N, dim))\n        # Jacobian is block diagonal with 1x3 blocks of 2*x_i\n        jac = np.zeros((N, N * dim))\n        for i in range(N):\n            jac[i, i*3 : i*3+3] = 2 * x[i]\n        return jac\n\n    cons = {'type': 'eq', 'fun': constraint_fun, 'jac': constraint_jac}\n    \n    # Schedule for p: annealing from soft repulsive to hard sphere\n    p_schedule = [2, 4, 8, 16, 32, 64] \n    \n    best_score = -1.0\n    best_points = None\n    \n    start_time = time.time()\n    \n    # Perform restarts to find global optimum\n    while time.time() - start_time < 50:  # 10s buffer\n        # Random initialization on sphere\n        x = np.random.randn(N, dim)\n        x /= np.linalg.norm(x, axis=1, keepdims=True)\n        x_flat = x.flatten()\n        \n        success_run = True\n        \n        for p in p_schedule:\n            try:\n                # Tighter tolerance for higher p\n                tol = 1e-6 if p >= 16 else 1e-4\n                \n                res = minimize(get_energy_and_grad, x_flat, args=(p,),\n                               method='SLSQP', jac=True, constraints=cons,\n                               options={'maxiter': 500, 'ftol': tol})\n                x_flat = res.x\n                \n                # Manual projection to correct numerical drift\n                x_tmp = x_flat.reshape((N, dim))\n                norm = np.linalg.norm(x_tmp, axis=1, keepdims=True)\n                x_tmp /= np.maximum(norm, 1e-9)\n                x_flat = x_tmp.flatten()\n            except Exception:\n                success_run = False\n                break\n        \n        if success_run:\n            points = x_flat.reshape((N, dim))\n            \n            # Calculate score: (min_dist / max_dist)^2\n            diff = points[:, np.newaxis, :] - points[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            \n            # Mask diagonal\n            mask = np.ones((N, N), dtype=bool)\n            np.fill_diagonal(mask, False)\n            valid_d2 = d2[mask]\n            \n            min_d2 = np.min(valid_d2)\n            max_d2 = np.max(valid_d2)\n            \n            if max_d2 > 1e-9:\n                score = min_d2 / max_d2\n            else:\n                score = 0.0\n            \n            if score > best_score:\n                best_score = score\n                best_points = points\n\n    # Fallback if optimization fails (unlikely)\n    if best_points is None:\n        best_points = np.random.randn(N, dim)\n        \n    return best_points\n```",
  "reasoning": "To solve the problem of placing 14 points in 3D space to maximize the squared ratio of the minimum pairwise distance to the maximum pairwise distance, we use the strategy of minimizing the Riesz energy $E = \\sum_{i \\neq j} \\frac{1}{d_{ij}^p}$ on a unit sphere. This is a known heuristic for generating spherical codes (Tammes problem). By progressively increasing the exponent $p$ (annealing), we approximate the \"hard sphere\" packing limit, which maximizes the minimum distance $d_{\\min}$. Since the points are on a sphere, the maximum distance $d_{\\max}$ is bounded by the diameter (2.0), and optimal configurations for $N=14$ typically span the sphere (antipodal or near-antipodal), making $d_{\\max} \\approx 2$. Thus, maximizing $d_{\\min}$ maximizes the ratio.\n\nThe algorithm:\n1. Initialize 14 points randomly on the unit sphere.\n2. Use `scipy.optimize.minimize` with the `SLSQP` method to handle the spherical constraint ($||x_i||^2 = 1$).\n3. Iterate $p$ through values $[2, 4, 8, 16, 32, 64]$. We start with a \"soft\" potential ($p=2$) to find a global arrangement and harden it to refine the packing.\n4. Perform multiple restarts within the time limit (60s) to avoid local minima.\n5. Select the configuration with the best squared ratio.",
  "timestamp": "2026-01-21T17:18:02.999430",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 217,
        "candidates_token_count": 1720,
        "thoughts_token_count": 10495
      },
      "response_text_len": 5500
    }
  }
}