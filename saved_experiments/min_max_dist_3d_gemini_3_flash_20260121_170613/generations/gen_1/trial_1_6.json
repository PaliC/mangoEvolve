{
  "trial_id": "trial_1_6",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The approach uses multi-start optimization with a smooth approximation of the min and max distances.\n    \"\"\"\n    N = 14\n    D = 3\n    triu_idx = np.triu_indices(N, k=1)\n\n    def get_score(pts):\n        # Calculate all pairwise squared distances\n        sum_sq = np.sum(pts**2, axis=1)\n        d2 = sum_sq[:, None] + sum_sq[None, :] - 2 * (pts @ pts.T)\n        d2 = d2[triu_idx]\n        return np.min(d2) / np.max(d2)\n\n    def objective(coords, k):\n        # Coordinates to points\n        pts = coords.reshape((N, D))\n        # Compute pairwise squared distances\n        sum_sq = np.sum(pts**2, axis=1)\n        d2 = sum_sq[:, None] + sum_sq[None, :] - 2 * (pts @ pts.T)\n        # Extract upper triangle and avoid small negative numbers\n        d2_vals = np.maximum(d2[triu_idx], 0)\n        \n        # LogSumExp trick for a smooth approximation of max(d2)\n        m_max = np.max(d2_vals)\n        lse_max = m_max + np.log(np.sum(np.exp(k * (d2_vals - m_max)))) / k\n        \n        # LogSumExp trick for a smooth approximation of min(d2)\n        m_min = np.min(d2_vals)\n        lse_min = m_min - np.log(np.sum(np.exp(-k * (d2_vals - m_min)))) / k\n        \n        # Minimize max_dist^2 / min_dist^2 to maximize min_dist^2 / max_dist^2\n        return lse_max / lse_min\n\n    def center_and_normalize(pts):\n        pts = pts - np.mean(pts, axis=0)\n        norms = np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        pts = pts / np.maximum(norms, 1e-9)\n        return pts\n\n    def get_capped_hexagonal_prism():\n        pts = []\n        for i in range(6):\n            phi = 2 * np.pi * i / 6\n            pts.append([np.cos(phi), np.sin(phi), 0.5])\n            pts.append([np.cos(phi), np.sin(phi), -0.5])\n        pts.append([0, 0, 1.1])\n        pts.append([0, 0, -1.1])\n        return np.array(pts)\n\n    def get_capped_hexagonal_antiprism():\n        pts = []\n        for i in range(6):\n            phi1 = 2 * np.pi * i / 6\n            pts.append([np.cos(phi1), np.sin(phi1), 0.4])\n            phi2 = 2 * np.pi * (i + 0.5) / 6\n            pts.append([np.cos(phi2), np.sin(phi2), -0.4])\n        pts.append([0, 0, 1.0])\n        pts.append([0, 0, -1.0])\n        return np.array(pts)\n\n    def get_rhombic_dodecahedron():\n        pts = [\n            [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],\n            [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],\n            [1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]\n        ]\n        return np.array(pts)\n\n    best_pts = None\n    best_score = -1\n    \n    # Define initial configurations for the optimization\n    initializations = []\n    # 1. Random configurations on a sphere\n    for _ in range(12):\n        pts_rand = np.random.randn(N, D)\n        initializations.append(center_and_normalize(pts_rand))\n    \n    # 2. Structured configurations based on geometric symmetry\n    for f in [get_capped_hexagonal_prism, get_capped_hexagonal_antiprism, get_rhombic_dodecahedron]:\n        initializations.append(center_and_normalize(f()))\n    \n    # Multi-start optimization loop\n    for pts_init in initializations:\n        pts = pts_init\n        # Optimization in stages with increasing sharpness (k)\n        for k_val in [20, 40, 80]:\n            res = minimize(objective, pts.flatten(), args=(k_val,), method='L-BFGS-B', options={'maxiter': 50})\n            pts = res.x.reshape((N, D))\n        \n        score = get_score(pts)\n        if score > best_score:\n            best_score = score\n            best_pts = pts\n    \n    # Final refinement of the best found configuration\n    res = minimize(objective, best_pts.flatten(), args=(100,), method='L-BFGS-B', options={'maxiter': 200})\n    best_pts = res.x.reshape((N, D))\n    \n    # Normalize the final set of points so that the maximum pairwise distance is 1.0\n    sum_sq = np.sum(best_pts**2, axis=1)\n    d2 = sum_sq[:, None] + sum_sq[None, :] - 2 * (best_pts @ best_pts.T)\n    max_d = np.sqrt(np.max(d2))\n    \n    return best_pts / max_d",
  "metrics": {
    "valid": true,
    "score": 0.9953905825460567,
    "min_max_ratio": 0.23894058552737452,
    "min_distance": 0.4888154923152237,
    "max_distance": 1.0,
    "eval_time": 2.48891282081604,
    "error": null
  },
  "prompt": "Try a multi-start approach: generate 100 sets of 14 random points, and for each, perform a few iterations of a gradient-based maximization of the minimum distance, then pick the best.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The approach uses multi-start optimization with a smooth approximation of the min and max distances.\n    \"\"\"\n    N = 14\n    D = 3\n    triu_idx = np.triu_indices(N, k=1)\n\n    def get_score(pts):\n        # Calculate all pairwise squared distances\n        sum_sq = np.sum(pts**2, axis=1)\n        d2 = sum_sq[:, None] + sum_sq[None, :] - 2 * (pts @ pts.T)\n        d2 = d2[triu_idx]\n        return np.min(d2) / np.max(d2)\n\n    def objective(coords, k):\n        # Coordinates to points\n        pts = coords.reshape((N, D))\n        # Compute pairwise squared distances\n        sum_sq = np.sum(pts**2, axis=1)\n        d2 = sum_sq[:, None] + sum_sq[None, :] - 2 * (pts @ pts.T)\n        # Extract upper triangle and avoid small negative numbers\n        d2_vals = np.maximum(d2[triu_idx], 0)\n        \n        # LogSumExp trick for a smooth approximation of max(d2)\n        m_max = np.max(d2_vals)\n        lse_max = m_max + np.log(np.sum(np.exp(k * (d2_vals - m_max)))) / k\n        \n        # LogSumExp trick for a smooth approximation of min(d2)\n        m_min = np.min(d2_vals)\n        lse_min = m_min - np.log(np.sum(np.exp(-k * (d2_vals - m_min)))) / k\n        \n        # Minimize max_dist^2 / min_dist^2 to maximize min_dist^2 / max_dist^2\n        return lse_max / lse_min\n\n    def center_and_normalize(pts):\n        pts = pts - np.mean(pts, axis=0)\n        norms = np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        pts = pts / np.maximum(norms, 1e-9)\n        return pts\n\n    def get_capped_hexagonal_prism():\n        pts = []\n        for i in range(6):\n            phi = 2 * np.pi * i / 6\n            pts.append([np.cos(phi), np.sin(phi), 0.5])\n            pts.append([np.cos(phi), np.sin(phi), -0.5])\n        pts.append([0, 0, 1.1])\n        pts.append([0, 0, -1.1])\n        return np.array(pts)\n\n    def get_capped_hexagonal_antiprism():\n        pts = []\n        for i in range(6):\n            phi1 = 2 * np.pi * i / 6\n            pts.append([np.cos(phi1), np.sin(phi1), 0.4])\n            phi2 = 2 * np.pi * (i + 0.5) / 6\n            pts.append([np.cos(phi2), np.sin(phi2), -0.4])\n        pts.append([0, 0, 1.0])\n        pts.append([0, 0, -1.0])\n        return np.array(pts)\n\n    def get_rhombic_dodecahedron():\n        pts = [\n            [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],\n            [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],\n            [1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]\n        ]\n        return np.array(pts)\n\n    best_pts = None\n    best_score = -1\n    \n    # Define initial configurations for the optimization\n    initializations = []\n    # 1. Random configurations on a sphere\n    for _ in range(12):\n        pts_rand = np.random.randn(N, D)\n        initializations.append(center_and_normalize(pts_rand))\n    \n    # 2. Structured configurations based on geometric symmetry\n    for f in [get_capped_hexagonal_prism, get_capped_hexagonal_antiprism, get_rhombic_dodecahedron]:\n        initializations.append(center_and_normalize(f()))\n    \n    # Multi-start optimization loop\n    for pts_init in initializations:\n        pts = pts_init\n        # Optimization in stages with increasing sharpness (k)\n        for k_val in [20, 40, 80]:\n            res = minimize(objective, pts.flatten(), args=(k_val,), method='L-BFGS-B', options={'maxiter': 50})\n            pts = res.x.reshape((N, D))\n        \n        score = get_score(pts)\n        if score > best_score:\n            best_score = score\n            best_pts = pts\n    \n    # Final refinement of the best found configuration\n    res = minimize(objective, best_pts.flatten(), args=(100,), method='L-BFGS-B', options={'maxiter': 200})\n    best_pts = res.x.reshape((N, D))\n    \n    # Normalize the final set of points so that the maximum pairwise distance is 1.0\n    sum_sq = np.sum(best_pts**2, axis=1)\n    d2 = sum_sq[:, None] + sum_sq[None, :] - 2 * (best_pts @ best_pts.T)\n    max_d = np.sqrt(np.max(d2))\n    \n    return best_pts / max_d\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:15:21.196857",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 216,
        "candidates_token_count": 1507,
        "thoughts_token_count": 20287
      },
      "response_text_len": 4181
    }
  }
}