{
  "trial_id": "trial_1_4",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Initialize 14 points: 12 at the vertices of an icosahedron and 2 at the poles.\n    Then use a local optimizer (SLSQP) to maximize the squared ratio \n    (min pairwise distance / max pairwise distance)^2.\n    \"\"\"\n    # 1. Initialize 12 vertices of an icosahedron\n    phi = (1 + np.sqrt(5)) / 2\n    verts = [\n        (0, 1, phi), (0, -1, phi), (0, 1, -phi), (0, -1, -phi),\n        (1, phi, 0), (-1, phi, 0), (1, -phi, 0), (-1, -phi, 0),\n        (phi, 0, 1), (-phi, 0, 1), (phi, 0, -1), (-phi, 0, -1)\n    ]\n    points = np.array(verts, dtype=float)\n    \n    # Normalize icosahedron vertices to the unit sphere\n    norms = np.linalg.norm(points, axis=1, keepdims=True)\n    points /= norms\n    \n    # 2. Add 2 points at the poles\n    poles = np.array([[0, 0, 1], [0, 0, -1]], dtype=float)\n    points = np.vstack([points, poles])\n    \n    # Add small noise to break perfect symmetry and avoid saddle points\n    rng = np.random.RandomState(42)\n    points += rng.normal(0, 0.01, points.shape)\n    \n    # 3. Setup Optimization\n    # Objective: Maximize (min_dist / max_dist)^2\n    # Equivalent to: Maximize t subject to dist_sq(i,j) >= t AND dist_sq(i,j) <= 1\n    # This formulation fixes the max distance to 1 and maximizes the min distance squared (t).\n    \n    N = 14\n    # Precompute indices for all pairwise combinations\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    # Rescale initial points so max_dist is exactly 1\n    diff_init = points[idx_i] - points[idx_j]\n    d2_init = np.sum(diff_init**2, axis=1)\n    points /= np.sqrt(np.max(d2_init))\n    \n    # Initial guess for t (min squared distance)\n    diff_scaled = points[idx_i] - points[idx_j]\n    t0 = np.min(np.sum(diff_scaled**2, axis=1))\n    \n    # Optimization variable x contains flattened coordinates + parameter t\n    x0 = np.hstack([points.flatten(), [t0]])\n    \n    def objective(x):\n        # Minimize negative t (maximize t)\n        return -x[-1]\n    \n    def constraints(x):\n        p = x[:-1].reshape(N, 3)\n        t = x[-1]\n        \n        # Vectorized pairwise squared distances\n        diff = p[idx_i] - p[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        \n        # Constraints:\n        # 1. Max distance squared <= 1  =>  1 - d2 >= 0\n        # 2. Min distance squared >= t  =>  d2 - t >= 0\n        return np.concatenate([1.0 - d2, d2 - t])\n    \n    # Constraint to keep center of mass at origin (prevents drift)\n    def com_constraint(x):\n        p = x[:-1].reshape(N, 3)\n        return np.sum(p, axis=0)\n\n    cons = [\n        {'type': 'ineq', 'fun': constraints},\n        {'type': 'eq', 'fun': com_constraint}\n    ]\n    \n    # Run optimization using SLSQP\n    # It handles inequality constraints efficiently for this problem size\n    res = minimize(\n        objective, \n        x0, \n        method='SLSQP', \n        constraints=cons, \n        options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n    )\n    \n    # Extract coordinates\n    final_points = res.x[:-1].reshape(N, 3)\n    \n    return final_points",
  "metrics": {
    "valid": true,
    "score": 0.931785836951738,
    "min_max_ratio": 0.2236724531770034,
    "min_distance": 0.4729402370788408,
    "max_distance": 1.0000000327961407,
    "eval_time": 0.25321125984191895,
    "error": null
  },
  "prompt": "Initialize 14 points: 12 at the vertices of an icosahedron and 2 at the poles. Then use a local optimizer to refine their positions to maximize the min/max distance ratio.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Initialize 14 points: 12 at the vertices of an icosahedron and 2 at the poles.\n    Then use a local optimizer (SLSQP) to maximize the squared ratio \n    (min pairwise distance / max pairwise distance)^2.\n    \"\"\"\n    # 1. Initialize 12 vertices of an icosahedron\n    phi = (1 + np.sqrt(5)) / 2\n    verts = [\n        (0, 1, phi), (0, -1, phi), (0, 1, -phi), (0, -1, -phi),\n        (1, phi, 0), (-1, phi, 0), (1, -phi, 0), (-1, -phi, 0),\n        (phi, 0, 1), (-phi, 0, 1), (phi, 0, -1), (-phi, 0, -1)\n    ]\n    points = np.array(verts, dtype=float)\n    \n    # Normalize icosahedron vertices to the unit sphere\n    norms = np.linalg.norm(points, axis=1, keepdims=True)\n    points /= norms\n    \n    # 2. Add 2 points at the poles\n    poles = np.array([[0, 0, 1], [0, 0, -1]], dtype=float)\n    points = np.vstack([points, poles])\n    \n    # Add small noise to break perfect symmetry and avoid saddle points\n    rng = np.random.RandomState(42)\n    points += rng.normal(0, 0.01, points.shape)\n    \n    # 3. Setup Optimization\n    # Objective: Maximize (min_dist / max_dist)^2\n    # Equivalent to: Maximize t subject to dist_sq(i,j) >= t AND dist_sq(i,j) <= 1\n    # This formulation fixes the max distance to 1 and maximizes the min distance squared (t).\n    \n    N = 14\n    # Precompute indices for all pairwise combinations\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    # Rescale initial points so max_dist is exactly 1\n    diff_init = points[idx_i] - points[idx_j]\n    d2_init = np.sum(diff_init**2, axis=1)\n    points /= np.sqrt(np.max(d2_init))\n    \n    # Initial guess for t (min squared distance)\n    diff_scaled = points[idx_i] - points[idx_j]\n    t0 = np.min(np.sum(diff_scaled**2, axis=1))\n    \n    # Optimization variable x contains flattened coordinates + parameter t\n    x0 = np.hstack([points.flatten(), [t0]])\n    \n    def objective(x):\n        # Minimize negative t (maximize t)\n        return -x[-1]\n    \n    def constraints(x):\n        p = x[:-1].reshape(N, 3)\n        t = x[-1]\n        \n        # Vectorized pairwise squared distances\n        diff = p[idx_i] - p[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        \n        # Constraints:\n        # 1. Max distance squared <= 1  =>  1 - d2 >= 0\n        # 2. Min distance squared >= t  =>  d2 - t >= 0\n        return np.concatenate([1.0 - d2, d2 - t])\n    \n    # Constraint to keep center of mass at origin (prevents drift)\n    def com_constraint(x):\n        p = x[:-1].reshape(N, 3)\n        return np.sum(p, axis=0)\n\n    cons = [\n        {'type': 'ineq', 'fun': constraints},\n        {'type': 'eq', 'fun': com_constraint}\n    ]\n    \n    # Run optimization using SLSQP\n    # It handles inequality constraints efficiently for this problem size\n    res = minimize(\n        objective, \n        x0, \n        method='SLSQP', \n        constraints=cons, \n        options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n    )\n    \n    # Extract coordinates\n    final_points = res.x[:-1].reshape(N, 3)\n    \n    return final_points\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:15:19.183426",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 214,
        "candidates_token_count": 1071,
        "thoughts_token_count": 12718
      },
      "response_text_len": 3095
    }
  }
}