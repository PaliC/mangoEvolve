{
  "trial_id": "trial_1_12",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the \n    squared ratio of the minimum pairwise distance to the maximum pairwise distance.\n    The method uses a 3x3x2 grid initialization with jitter, followed by Basin-hopping.\n    \"\"\"\n    N = 14\n    \n    # 1. Grid initialization (3x3x2 grid)\n    # A 3x3x2 grid provides 18 points; we take the first 14.\n    grid = []\n    for z in [0.0, 1.0]:\n        for y in [0.0, 1.0, 2.0]:\n            for x in [0.0, 1.0, 2.0]:\n                grid.append([x, y, z])\n    pts = np.array(grid[:N])\n    \n    # 2. Apply a small jitter to break symmetry\n    np.random.seed(42)\n    pts += np.random.uniform(-0.1, 0.1, pts.shape)\n    \n    # 3. Define a smooth objective function for the optimizer\n    # We use a stable log-sum-exp approximation of the minimum distance\n    # to provide better gradients for the local optimization step.\n    def smooth_obj(x):\n        p = x.reshape((N, 3))\n        # Compute pairwise squared distances\n        dists_sq = np.sum((p[:, None, :] - p[None, :, :])**2, axis=-1)\n        # Create a mask to exclude the diagonal (distance from a point to itself)\n        mask = ~np.eye(N, dtype=bool)\n        dists = dists_sq[mask]\n        \n        # Stable log-sum-exp for soft-min\n        alpha = 50.0\n        d_min_sq = np.min(dists)\n        # Smoothly approximates the minimum distance squared\n        min_d2 = d_min_sq - np.log(np.sum(np.exp(-alpha * (dists - d_min_sq)))) / alpha\n        \n        # Calculate the maximum squared distance\n        max_d2 = np.max(dists_sq)\n        if max_d2 < 1e-9:\n            return 0.0\n        \n        # We minimize the negative ratio to maximize the actual ratio\n        return -min_d2 / max_d2\n\n    # 4. Basin-hopping global optimization\n    # This combines random perturbations (steps) with local minimization.\n    # The L-BFGS-B method is used for local searches.\n    res = basinhopping(\n        smooth_obj, \n        pts.flatten(), \n        niter=50, \n        stepsize=0.5, \n        minimizer_kwargs={'method': 'L-BFGS-B'}\n    )\n    \n    # 5. Final polish with the exact (non-smooth) objective\n    # Nelder-Mead is a derivative-free method that can refine the result \n    # based on the exact min/max distances.\n    def exact_obj(x):\n        p = x.reshape((N, 3))\n        dists_sq = np.sum((p[:, None, :] - p[None, :, :])**2, axis=-1)\n        mask = ~np.eye(N, dtype=bool)\n        min_d2 = np.min(dists_sq[mask])\n        max_d2 = np.max(dists_sq)\n        if max_d2 < 1e-9:\n            return 0.0\n        return -min_d2 / max_d2\n        \n    res_final = minimize(exact_obj, res.x, method='Nelder-Mead', options={'maxiter': 1000})\n    \n    # Return the optimized 14 points in the required shape (14, 3)\n    return res_final.x.reshape((N, 3))",
  "metrics": {
    "valid": true,
    "score": 0.9902788469301429,
    "min_max_ratio": 0.23771352840774274,
    "min_distance": 4.744521419412726,
    "max_distance": 9.731179026572411,
    "eval_time": 8.975222110748291,
    "error": null
  },
  "prompt": "Place 14 points in a 3D grid (e.g., 3x3x2 or similar) and apply a jitter, then use Basin-hopping to find the global optimum for the min-max distance ratio.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the \n    squared ratio of the minimum pairwise distance to the maximum pairwise distance.\n    The method uses a 3x3x2 grid initialization with jitter, followed by Basin-hopping.\n    \"\"\"\n    N = 14\n    \n    # 1. Grid initialization (3x3x2 grid)\n    # A 3x3x2 grid provides 18 points; we take the first 14.\n    grid = []\n    for z in [0.0, 1.0]:\n        for y in [0.0, 1.0, 2.0]:\n            for x in [0.0, 1.0, 2.0]:\n                grid.append([x, y, z])\n    pts = np.array(grid[:N])\n    \n    # 2. Apply a small jitter to break symmetry\n    np.random.seed(42)\n    pts += np.random.uniform(-0.1, 0.1, pts.shape)\n    \n    # 3. Define a smooth objective function for the optimizer\n    # We use a stable log-sum-exp approximation of the minimum distance\n    # to provide better gradients for the local optimization step.\n    def smooth_obj(x):\n        p = x.reshape((N, 3))\n        # Compute pairwise squared distances\n        dists_sq = np.sum((p[:, None, :] - p[None, :, :])**2, axis=-1)\n        # Create a mask to exclude the diagonal (distance from a point to itself)\n        mask = ~np.eye(N, dtype=bool)\n        dists = dists_sq[mask]\n        \n        # Stable log-sum-exp for soft-min\n        alpha = 50.0\n        d_min_sq = np.min(dists)\n        # Smoothly approximates the minimum distance squared\n        min_d2 = d_min_sq - np.log(np.sum(np.exp(-alpha * (dists - d_min_sq)))) / alpha\n        \n        # Calculate the maximum squared distance\n        max_d2 = np.max(dists_sq)\n        if max_d2 < 1e-9:\n            return 0.0\n        \n        # We minimize the negative ratio to maximize the actual ratio\n        return -min_d2 / max_d2\n\n    # 4. Basin-hopping global optimization\n    # This combines random perturbations (steps) with local minimization.\n    # The L-BFGS-B method is used for local searches.\n    res = basinhopping(\n        smooth_obj, \n        pts.flatten(), \n        niter=50, \n        stepsize=0.5, \n        minimizer_kwargs={'method': 'L-BFGS-B'}\n    )\n    \n    # 5. Final polish with the exact (non-smooth) objective\n    # Nelder-Mead is a derivative-free method that can refine the result \n    # based on the exact min/max distances.\n    def exact_obj(x):\n        p = x.reshape((N, 3))\n        dists_sq = np.sum((p[:, None, :] - p[None, :, :])**2, axis=-1)\n        mask = ~np.eye(N, dtype=bool)\n        min_d2 = np.min(dists_sq[mask])\n        max_d2 = np.max(dists_sq)\n        if max_d2 < 1e-9:\n            return 0.0\n        return -min_d2 / max_d2\n        \n    res_final = minimize(exact_obj, res.x, method='Nelder-Mead', options={'maxiter': 1000})\n    \n    # Return the optimized 14 points in the required shape (14, 3)\n    return res_final.x.reshape((N, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:17:05.636976",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 220,
        "candidates_token_count": 959,
        "thoughts_token_count": 17479
      },
      "response_text_len": 2877
    }
  }
}