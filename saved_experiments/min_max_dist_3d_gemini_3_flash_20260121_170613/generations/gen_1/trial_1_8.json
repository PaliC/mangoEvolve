{
  "trial_id": "trial_1_8",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Implements a 'Stretching' algorithm to place 14 points in 3D space.\n    The goal is to maximize the ratio (min pairwise distance / max pairwise distance)^2.\n    \n    The algorithm starts with 14 points in a small cluster and iteratively pushes\n    the closest pairs of points apart while normalizing the diameter of the set \n    to keep it constrained.\n    \"\"\"\n    N = 14\n    dim = 3\n    best_pts = None\n    best_ratio = -1\n    \n    # Use a fixed seed for reproducibility within the function\n    np.random.seed(42)\n    \n    # Run multiple restarts to find a strong local maximum\n    num_restarts = 10\n    num_iters = 20000\n    \n    for restart in range(num_restarts):\n        # 1. Start with 14 points in a small cluster around the origin\n        pts = (np.random.rand(N, dim) - 0.5) * 0.1\n        \n        # 2. Iteratively stretch the point set\n        for i in range(num_iters):\n            # Calculate all-pairs differences and distances squared\n            # diffs: (N, N, dim), dists_sq: (N, N)\n            diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            dists_sq = np.sum(diffs**2, axis=2)\n            \n            # Mask the diagonal to ignore self-distances\n            np.fill_diagonal(dists_sq, np.inf)\n            \n            # Find the minimum distance in the current configuration\n            d_min_sq = np.min(dists_sq)\n            d_min = np.sqrt(d_min_sq)\n            \n            # Determine which pairs are the \"closest\" within a small tolerance.\n            # Moving all near-minimum pairs helps avoid oscillations and speeds up convergence.\n            tolerance = 1.001\n            close_mask = (dists_sq < (d_min * tolerance)**2)\n            # Only process each pair once\n            upper_tri = np.triu(close_mask, k=1)\n            \n            # Compute distances and inverse distances for force calculation\n            dists = np.sqrt(dists_sq)\n            # Handle potential zero distances with a small epsilon\n            inv_dists = 1.0 / np.where(dists < 1e-12, 1e-12, dists)\n            \n            # Calculate repulsion force matrix: force[i, j] = (pts[i] - pts[j]) / dist(i, j)\n            # This represents the unit vector direction to move pts[i] away from pts[j].\n            force_matrix = diffs * inv_dists[:, :, np.newaxis]\n            # Apply the mask so only the closest pairs generate a \"stretch\" force\n            force_matrix[~upper_tri] = 0\n            \n            # The total force on each point k is the sum of repulsion from all j > k \n            # minus the sum of repulsion from all i < k (since diffs[i, k] = -diffs[k, i]).\n            forces = np.sum(force_matrix, axis=1) - np.sum(force_matrix, axis=0)\n            \n            # If for some reason no forces are generated (e.g., precision), add small jitter\n            if not np.any(upper_tri):\n                forces = np.random.randn(N, dim) * 0.01\n            \n            # Step size (eta) decreases linearly over time for fine-tuning\n            eta = 0.005 * (1.0 - i / num_iters)\n            pts += forces * eta\n            \n            # 3. Constrain the configuration: center and rescale by the diameter (max distance)\n            # Normalizing every 100 steps is sufficient for stability and improves performance.\n            if i % 100 == 0:\n                pts -= np.mean(pts, axis=0)\n                # Re-calculate all-pairs distances to find the current diameter\n                temp_diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n                temp_dists_sq = np.sum(temp_diffs**2, axis=2)\n                d_max = np.sqrt(np.max(temp_dists_sq))\n                if d_max > 1e-12:\n                    pts /= d_max\n        \n        # 4. Evaluate the final score for this restart\n        final_diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        final_dists_sq = np.sum(final_diffs**2, axis=2)\n        np.fill_diagonal(final_dists_sq, np.inf)\n        d_min_final = np.sqrt(np.min(final_dists_sq))\n        np.fill_diagonal(final_dists_sq, 0)\n        d_max_final = np.sqrt(np.max(final_dists_sq))\n        \n        # Score is normalized (min_dist / max_dist)^2\n        ratio = (d_min_final / d_max_final)**2\n        \n        if ratio > best_ratio:\n            best_ratio = ratio\n            # Ensure the returned set has a diameter of exactly 1.0\n            best_pts = pts / d_max_final\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.8520129305389257,
    "min_max_ratio": 0.20452320131373708,
    "min_distance": 0.452242414324151,
    "max_distance": 1.0,
    "eval_time": 5.193716049194336,
    "error": null
  },
  "prompt": "Implement a 'Stretching' algorithm. Start with 14 points in a small cluster and iteratively move the closest pair of points away from each other while keeping the total bounding box or max distance constrained.",
  "response": "```python\nimport numpy as np\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Implements a 'Stretching' algorithm to place 14 points in 3D space.\n    The goal is to maximize the ratio (min pairwise distance / max pairwise distance)^2.\n    \n    The algorithm starts with 14 points in a small cluster and iteratively pushes\n    the closest pairs of points apart while normalizing the diameter of the set \n    to keep it constrained.\n    \"\"\"\n    N = 14\n    dim = 3\n    best_pts = None\n    best_ratio = -1\n    \n    # Use a fixed seed for reproducibility within the function\n    np.random.seed(42)\n    \n    # Run multiple restarts to find a strong local maximum\n    num_restarts = 10\n    num_iters = 20000\n    \n    for restart in range(num_restarts):\n        # 1. Start with 14 points in a small cluster around the origin\n        pts = (np.random.rand(N, dim) - 0.5) * 0.1\n        \n        # 2. Iteratively stretch the point set\n        for i in range(num_iters):\n            # Calculate all-pairs differences and distances squared\n            # diffs: (N, N, dim), dists_sq: (N, N)\n            diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            dists_sq = np.sum(diffs**2, axis=2)\n            \n            # Mask the diagonal to ignore self-distances\n            np.fill_diagonal(dists_sq, np.inf)\n            \n            # Find the minimum distance in the current configuration\n            d_min_sq = np.min(dists_sq)\n            d_min = np.sqrt(d_min_sq)\n            \n            # Determine which pairs are the \"closest\" within a small tolerance.\n            # Moving all near-minimum pairs helps avoid oscillations and speeds up convergence.\n            tolerance = 1.001\n            close_mask = (dists_sq < (d_min * tolerance)**2)\n            # Only process each pair once\n            upper_tri = np.triu(close_mask, k=1)\n            \n            # Compute distances and inverse distances for force calculation\n            dists = np.sqrt(dists_sq)\n            # Handle potential zero distances with a small epsilon\n            inv_dists = 1.0 / np.where(dists < 1e-12, 1e-12, dists)\n            \n            # Calculate repulsion force matrix: force[i, j] = (pts[i] - pts[j]) / dist(i, j)\n            # This represents the unit vector direction to move pts[i] away from pts[j].\n            force_matrix = diffs * inv_dists[:, :, np.newaxis]\n            # Apply the mask so only the closest pairs generate a \"stretch\" force\n            force_matrix[~upper_tri] = 0\n            \n            # The total force on each point k is the sum of repulsion from all j > k \n            # minus the sum of repulsion from all i < k (since diffs[i, k] = -diffs[k, i]).\n            forces = np.sum(force_matrix, axis=1) - np.sum(force_matrix, axis=0)\n            \n            # If for some reason no forces are generated (e.g., precision), add small jitter\n            if not np.any(upper_tri):\n                forces = np.random.randn(N, dim) * 0.01\n            \n            # Step size (eta) decreases linearly over time for fine-tuning\n            eta = 0.005 * (1.0 - i / num_iters)\n            pts += forces * eta\n            \n            # 3. Constrain the configuration: center and rescale by the diameter (max distance)\n            # Normalizing every 100 steps is sufficient for stability and improves performance.\n            if i % 100 == 0:\n                pts -= np.mean(pts, axis=0)\n                # Re-calculate all-pairs distances to find the current diameter\n                temp_diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n                temp_dists_sq = np.sum(temp_diffs**2, axis=2)\n                d_max = np.sqrt(np.max(temp_dists_sq))\n                if d_max > 1e-12:\n                    pts /= d_max\n        \n        # 4. Evaluate the final score for this restart\n        final_diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        final_dists_sq = np.sum(final_diffs**2, axis=2)\n        np.fill_diagonal(final_dists_sq, np.inf)\n        d_min_final = np.sqrt(np.min(final_dists_sq))\n        np.fill_diagonal(final_dists_sq, 0)\n        d_max_final = np.sqrt(np.max(final_dists_sq))\n        \n        # Score is normalized (min_dist / max_dist)^2\n        ratio = (d_min_final / d_max_final)**2\n        \n        if ratio > best_ratio:\n            best_ratio = ratio\n            # Ensure the returned set has a diameter of exactly 1.0\n            best_pts = pts / d_max_final\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:15:50.737158",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 213,
        "candidates_token_count": 1311,
        "thoughts_token_count": 23231
      },
      "response_text_len": 4448
    }
  }
}