{
  "trial_id": "trial_16_2",
  "generation": 16,
  "parent_id": "trial_15_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, minimize_scalar\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a basin-hopping strategy with SLSQP optimization followed by a Coordinate Descent refinement phase.\n    \"\"\"\n    N = 14\n    M = N * (N - 1) // 2\n    triu_rows, triu_cols = np.triu_indices(N, k=1)\n    \n    start_time = time.time()\n\n    def get_ratio_sq(pts):\n        \"\"\"Calculates the squared ratio (min distance / max distance)^2.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0: return 0.0\n        mx = np.max(dists_sq)\n        if mx < 1e-16: return 0.0\n        return np.min(dists_sq) / mx\n\n    # --- Phase 1: SLSQP Optimization ---\n    # Objective: Maximize slack 's' (min dist squared) subject to max dist squared <= 1.\n    \n    def obj_slsqp(x):\n        return -x[-1]\n\n    def jac_slsqp(x):\n        g = np.zeros(len(x))\n        g[-1] = -1.0\n        return g\n\n    def cons_slsqp(x):\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        d_sq = pdist(pts, 'sqeuclidean')\n        # Constraints: d_ij^2 >= s, d_ij^2 <= 1\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def jac_cons_slsqp(x):\n        pts = x[:-1].reshape((N, 3))\n        jac = np.zeros((2 * M, 3 * N + 1))\n        diffs = pts[triu_rows] - pts[triu_cols]\n        g = 2.0 * diffs\n        row_idx = np.arange(M)\n        # Vectorized filling of Jacobian\n        for d in range(3):\n            jac[row_idx, 3 * triu_rows + d] = g[:, d]\n            jac[row_idx, 3 * triu_cols + d] = -g[:, d]\n        jac[:M, -1] = -1.0\n        jac[M:, :-1] = -jac[:M, :-1]\n        return jac\n\n    def solve_slsqp(pts_init, maxiter=200):\n        try:\n            # Normalize initialization to roughly diameter 1\n            d_sq = pdist(pts_init, 'sqeuclidean')\n            mx = np.max(d_sq)\n            if mx < 1e-16: mx = 1.0\n            pts_init = pts_init / np.sqrt(mx)\n            \n            s_init = np.min(d_sq) / mx\n            x0 = np.concatenate([pts_init.flatten(), [s_init]])\n            \n            cons = {'type': 'ineq', 'fun': cons_slsqp, 'jac': jac_cons_slsqp}\n            bounds = [(None, None)] * (3 * N) + [(0.0, 1.0)]\n            \n            res = minimize(obj_slsqp, x0, method='SLSQP', jac=jac_slsqp, \n                           constraints=cons, bounds=bounds, \n                           options={'maxiter': maxiter, 'ftol': 1e-10})\n            if hasattr(res, 'x'):\n                return res.x[:-1].reshape((N, 3))\n            return pts_init\n        except:\n            return pts_init\n\n    # --- Initialization Seeds ---\n    # 1. Fibonacci Sphere\n    phi = (1.0 + 5.0**0.5) / 2.0\n    idx = np.arange(N) + 0.5\n    z_fib = 1.0 - 2.0 * idx / N\n    r_fib = np.sqrt(np.maximum(0, 1.0 - z_fib*z_fib))\n    theta_fib = 2.0 * np.pi * idx / phi\n    pts_fib = np.stack([r_fib * np.cos(theta_fib), r_fib * np.sin(theta_fib), z_fib], axis=1)\n    \n    # 2. 1-6-6-1 Structure (Hexagonal Antiprism with caps)\n    s2 = [[0, 0, 1], [0, 0, -1]]\n    h = 0.45\n    r_ring = np.sqrt(1 - h**2)\n    for i in range(6):\n        a = 2 * np.pi * i / 6\n        s2.append([r_ring * np.cos(a), r_ring * np.sin(a), h])\n    for i in range(6):\n        a = 2 * np.pi * (i + 0.5) / 6\n        s2.append([r_ring * np.cos(a), r_ring * np.sin(a), -h])\n    pts_1661 = np.array(s2)\n\n    seeds = [pts_fib, pts_1661]\n    # Add random seeds\n    for _ in range(2):\n        seeds.append(np.random.uniform(-1, 1, (N, 3)))\n\n    best_pts = pts_fib\n    best_score = -1.0\n\n    # Initial Polish of Seeds\n    for seed in seeds:\n        if time.time() - start_time > 10: break\n        cand = solve_slsqp(seed, maxiter=400)\n        sc = get_ratio_sq(cand)\n        if sc > best_score:\n            best_score = sc\n            best_pts = cand\n\n    # --- Basin Hopping with SLSQP ---\n    # Run for ~35-40 seconds\n    while time.time() - start_time < 35:\n        if np.random.rand() < 0.2:\n            # Random restart\n            perturb = np.random.uniform(-1, 1, (N, 3))\n            cand_in = perturb\n        else:\n            # Small perturbation\n            scale = 10**(-np.random.uniform(2, 5))\n            cand_in = best_pts + np.random.normal(0, scale, (N, 3))\n        \n        cand = solve_slsqp(cand_in, maxiter=200)\n        sc = get_ratio_sq(cand)\n        if sc > best_score:\n            best_score = sc\n            best_pts = cand\n\n    # --- Phase 2: Coordinate Descent Refinement ---\n    # Optimization directly on the ratio by moving one coordinate at a time.\n    # This helps escape saddle points or ridges where gradient methods stall.\n    \n    current_pts = best_pts.copy()\n    current_score = best_score\n    indices = np.arange(N)\n    \n    # Run until just before timeout\n    while time.time() - start_time < 58:\n        improved_pass = False\n        np.random.shuffle(indices)\n        \n        for i in indices:\n            # Calculate min/max distances for points NOT involving i (static)\n            mask = np.ones(N, dtype=bool)\n            mask[i] = False\n            static_pts = current_pts[mask]\n            \n            d_static = pdist(static_pts, 'sqeuclidean')\n            min_s = np.min(d_static)\n            max_s = np.max(d_static)\n            \n            p_i = current_pts[i].copy()\n            \n            # Optimize each dimension (x, y, z)\n            for dim in range(3):\n                \n                def obj_1d(val):\n                    p_trial = p_i.copy()\n                    p_trial[dim] = val\n                    \n                    # Distances from i to static points\n                    d_new = np.sum((static_pts - p_trial)**2, axis=1)\n                    \n                    # New global min/max\n                    mn = min(min_s, np.min(d_new))\n                    mx = max(max_s, np.max(d_new))\n                    \n                    if mx < 1e-16: return 0.0\n                    return -(mn / mx) # Minimize negative ratio\n                \n                curr_v = p_i[dim]\n                # Search in a small window around current value\n                window = 0.15\n                res = minimize_scalar(obj_1d, bounds=(curr_v - window, curr_v + window), \n                                      method='bounded', options={'xatol': 1e-8})\n                \n                if -res.fun > current_score + 1e-12:\n                    current_score = -res.fun\n                    p_i[dim] = res.x\n                    current_pts[i, dim] = res.x\n                    improved_pass = True\n        \n        if not improved_pass:\n            # If stuck, apply tiny noise to try and dislodge\n            if time.time() - start_time < 55:\n                current_pts += np.random.normal(0, 1e-6, (N, 3))\n                # Recalculate score after perturbation\n                current_score = get_ratio_sq(current_pts)\n            else:\n                break\n                \n    return current_pts",
  "metrics": {
    "valid": true,
    "score": 0.9999541838351539,
    "min_max_ratio": 0.2400360646119176,
    "min_distance": 0.4899158365942244,
    "max_distance": 0.9999613849192778,
    "eval_time": 55.8051540851593,
    "error": null
  },
  "prompt": "Take the best coordinates from trial_15_3 and perform a 'Coordinate Descent' refinement. For each point and each dimension, perform a small 1D optimization or line search to maximize the min-max ratio while keeping other points fixed. Repeat this until convergence. This can often push past the limits of gradient-based optimizers like SLSQP. \nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a basin-hopping strategy with SLSQP optimization and analytical gradients.\n    \"\"\"\n    N = 14\n    M = N * (N - 1) // 2  # Number of pairs\n    triu_rows, triu_cols = np.triu_indices(N, k=1)\n\n    def get_ratio_sq(pts):\n        \"\"\"Calculates the squared ratio (min distance / max distance)^2.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0:\n            return 0.0\n        mx = np.max(dists_sq)\n        if mx < 1e-16:\n            return 0.0\n        return np.min(dists_sq) / mx\n\n    # --- Optimization Objectives and Constraints ---\n    # Variable x: [p1_x, p1_y, p1_z, ..., pN_z, s] (Size 3*N + 1)\n    # Objective: Minimize -s (Maximize slack variable s)\n    # Constraints: \n    #   1. d_ij^2 - s >= 0  (Ensures s <= all squared distances)\n    #   2. 1 - d_ij^2 >= 0  (Ensures all squared distances <= 1.0)\n    \n    def objective(x):\n        return -x[-1]\n\n    def obj_jac(x):\n        grad = np.zeros(len(x))\n        grad[-1] = -1.0\n        return grad\n\n    def constraints(x):\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        d_sq = pdist(pts, 'sqeuclidean')\n        # Combine (d_ij^2 - s >= 0) and (1.0 - d_sq >= 0)\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def constraints_jac(x):\n        pts = x[:-1].reshape((N, 3))\n        jac = np.zeros((2 * M, 3 * N + 1))\n        diffs = pts[triu_rows] - pts[triu_cols]\n        g = 2.0 * diffs\n        row_idx = np.arange(M)\n        # Vectorized filling of the Jacobian matrix\n        for d in range(3):\n            jac[row_idx, 3 * triu_rows + d] = g[:, d]\n            jac[row_idx, 3 * triu_cols + d] = -g[:, d]\n        jac[:M, -1] = -1.0\n        # The second set of constraints (1 - d_sq) has negated gradients\n        jac[M:, :-1] = -jac[:M, :-1]\n        return jac\n\n    def solve(pts_init, maxiter=400, ftol=1e-15):\n        \"\"\"Local optimization using SLSQP with analytical gradients.\"\"\"\n        try:\n            # Normalize initialization to diameter 1\n            d_sq_init = pdist(pts_init, 'sqeuclidean')\n            mx = np.max(d_sq_init)\n            if mx < 1e-16: mx = 1.0\n            pts_init = pts_init / np.sqrt(mx)\n            \n            # Initial slack s is slightly less than the minimum squared distance\n            s_init = np.min(pdist(pts_init, 'sqeuclidean'))\n            x0 = np.concatenate([pts_init.flatten(), [s_init]])\n            \n            cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n            bounds = [(None, None)] * (3 * N) + [(0.0, 1.0)]\n            \n            res = minimize(objective, x0, method='SLSQP', jac=obj_jac, \n                           constraints=cons, bounds=bounds, \n                           options={'maxiter': maxiter, 'ftol': ftol})\n            if hasattr(res, 'x'):\n                return res.x[:-1].reshape((N, 3))\n            return pts_init\n        except:\n            return pts_init\n\n    # --- Initial Search for Best Basin ---\n    start_time = time.time()\n    \n    # Fibonacci Sphere Seed\n    phi = (1.0 + 5.0**0.5) / 2.0\n    idx = np.arange(N) + 0.5\n    z_fib = 1.0 - 2.0 * idx / N\n    r_fib = np.sqrt(np.maximum(0, 1.0 - z_fib*z_fib))\n    theta_fib = 2.0 * np.pi * idx / phi\n    pts_fib = np.stack([r_fib * np.cos(theta_fib), r_fib * np.sin(theta_fib), z_fib], axis=1)\n    \n    # Hexagonal Antiprism Seed (approximate 1-6-6-1 structure)\n    s1 = [[0, 0, 1], [0, 0, -1]]\n    for i in range(6):\n        p = 2 * np.pi * i / 6\n        s1.append([np.sqrt(1-0.4**2)*np.cos(p), np.sqrt(1-0.4**2)*np.sin(p), 0.4])\n    for i in range(6):\n        p = 2 * np.pi * (i+0.5) / 6\n        s1.append([np.sqrt(1-0.4**2)*np.cos(p), np.sqrt(1-0.4**2)*np.sin(p), -0.4])\n    pts_1661 = np.array(s1)\n    \n    seeds = [pts_fib, pts_1661]\n    # Add a few random seeds to diversify the initial search\n    for _ in range(3):\n        seeds.append(np.random.uniform(-1, 1, (N, 3)))\n        \n    best_pts = pts_fib\n    best_score = -1.0\n    \n    # Polish seeds to find the best starting basin\n    for seed in seeds:\n        if time.time() - start_time > 15: break\n        cand = solve(seed, maxiter=800)\n        score = get_ratio_sq(cand)\n        if score > best_score:\n            best_score = score\n            best_pts = cand\n\n    # --- Shaking Loop (Basin Hopping) ---\n    # Refine the best found solution by applying small perturbations\n    while time.time() - start_time < 55:\n        if np.random.rand() < 0.1:\n            # Occasional random restart to escape local traps\n            cand_perturb = np.random.uniform(-1, 1, (N, 3))\n        else:\n            # Shaking Strategy: Apply very small Gaussian noise (1e-6 to 1e-9)\n            scale = 10**(-np.random.uniform(6, 9))\n            cand_perturb = best_pts + np.random.normal(0, scale, (N, 3))\n        \n        cand = solve(cand_perturb, maxiter=300, ftol=1e-15)\n        score = get_ratio_sq(cand)\n        if score > best_score:\n            best_score = score\n            best_pts = cand\n            \n    return best_pts.reshape((14, 3))",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, minimize_scalar\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a basin-hopping strategy with SLSQP optimization followed by a Coordinate Descent refinement phase.\n    \"\"\"\n    N = 14\n    M = N * (N - 1) // 2\n    triu_rows, triu_cols = np.triu_indices(N, k=1)\n    \n    start_time = time.time()\n\n    def get_ratio_sq(pts):\n        \"\"\"Calculates the squared ratio (min distance / max distance)^2.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0: return 0.0\n        mx = np.max(dists_sq)\n        if mx < 1e-16: return 0.0\n        return np.min(dists_sq) / mx\n\n    # --- Phase 1: SLSQP Optimization ---\n    # Objective: Maximize slack 's' (min dist squared) subject to max dist squared <= 1.\n    \n    def obj_slsqp(x):\n        return -x[-1]\n\n    def jac_slsqp(x):\n        g = np.zeros(len(x))\n        g[-1] = -1.0\n        return g\n\n    def cons_slsqp(x):\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        d_sq = pdist(pts, 'sqeuclidean')\n        # Constraints: d_ij^2 >= s, d_ij^2 <= 1\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def jac_cons_slsqp(x):\n        pts = x[:-1].reshape((N, 3))\n        jac = np.zeros((2 * M, 3 * N + 1))\n        diffs = pts[triu_rows] - pts[triu_cols]\n        g = 2.0 * diffs\n        row_idx = np.arange(M)\n        # Vectorized filling of Jacobian\n        for d in range(3):\n            jac[row_idx, 3 * triu_rows + d] = g[:, d]\n            jac[row_idx, 3 * triu_cols + d] = -g[:, d]\n        jac[:M, -1] = -1.0\n        jac[M:, :-1] = -jac[:M, :-1]\n        return jac\n\n    def solve_slsqp(pts_init, maxiter=200):\n        try:\n            # Normalize initialization to roughly diameter 1\n            d_sq = pdist(pts_init, 'sqeuclidean')\n            mx = np.max(d_sq)\n            if mx < 1e-16: mx = 1.0\n            pts_init = pts_init / np.sqrt(mx)\n            \n            s_init = np.min(d_sq) / mx\n            x0 = np.concatenate([pts_init.flatten(), [s_init]])\n            \n            cons = {'type': 'ineq', 'fun': cons_slsqp, 'jac': jac_cons_slsqp}\n            bounds = [(None, None)] * (3 * N) + [(0.0, 1.0)]\n            \n            res = minimize(obj_slsqp, x0, method='SLSQP', jac=jac_slsqp, \n                           constraints=cons, bounds=bounds, \n                           options={'maxiter': maxiter, 'ftol': 1e-10})\n            if hasattr(res, 'x'):\n                return res.x[:-1].reshape((N, 3))\n            return pts_init\n        except:\n            return pts_init\n\n    # --- Initialization Seeds ---\n    # 1. Fibonacci Sphere\n    phi = (1.0 + 5.0**0.5) / 2.0\n    idx = np.arange(N) + 0.5\n    z_fib = 1.0 - 2.0 * idx / N\n    r_fib = np.sqrt(np.maximum(0, 1.0 - z_fib*z_fib))\n    theta_fib = 2.0 * np.pi * idx / phi\n    pts_fib = np.stack([r_fib * np.cos(theta_fib), r_fib * np.sin(theta_fib), z_fib], axis=1)\n    \n    # 2. 1-6-6-1 Structure (Hexagonal Antiprism with caps)\n    s2 = [[0, 0, 1], [0, 0, -1]]\n    h = 0.45\n    r_ring = np.sqrt(1 - h**2)\n    for i in range(6):\n        a = 2 * np.pi * i / 6\n        s2.append([r_ring * np.cos(a), r_ring * np.sin(a), h])\n    for i in range(6):\n        a = 2 * np.pi * (i + 0.5) / 6\n        s2.append([r_ring * np.cos(a), r_ring * np.sin(a), -h])\n    pts_1661 = np.array(s2)\n\n    seeds = [pts_fib, pts_1661]\n    # Add random seeds\n    for _ in range(2):\n        seeds.append(np.random.uniform(-1, 1, (N, 3)))\n\n    best_pts = pts_fib\n    best_score = -1.0\n\n    # Initial Polish of Seeds\n    for seed in seeds:\n        if time.time() - start_time > 10: break\n        cand = solve_slsqp(seed, maxiter=400)\n        sc = get_ratio_sq(cand)\n        if sc > best_score:\n            best_score = sc\n            best_pts = cand\n\n    # --- Basin Hopping with SLSQP ---\n    # Run for ~35-40 seconds\n    while time.time() - start_time < 35:\n        if np.random.rand() < 0.2:\n            # Random restart\n            perturb = np.random.uniform(-1, 1, (N, 3))\n            cand_in = perturb\n        else:\n            # Small perturbation\n            scale = 10**(-np.random.uniform(2, 5))\n            cand_in = best_pts + np.random.normal(0, scale, (N, 3))\n        \n        cand = solve_slsqp(cand_in, maxiter=200)\n        sc = get_ratio_sq(cand)\n        if sc > best_score:\n            best_score = sc\n            best_pts = cand\n\n    # --- Phase 2: Coordinate Descent Refinement ---\n    # Optimization directly on the ratio by moving one coordinate at a time.\n    # This helps escape saddle points or ridges where gradient methods stall.\n    \n    current_pts = best_pts.copy()\n    current_score = best_score\n    indices = np.arange(N)\n    \n    # Run until just before timeout\n    while time.time() - start_time < 58:\n        improved_pass = False\n        np.random.shuffle(indices)\n        \n        for i in indices:\n            # Calculate min/max distances for points NOT involving i (static)\n            mask = np.ones(N, dtype=bool)\n            mask[i] = False\n            static_pts = current_pts[mask]\n            \n            d_static = pdist(static_pts, 'sqeuclidean')\n            min_s = np.min(d_static)\n            max_s = np.max(d_static)\n            \n            p_i = current_pts[i].copy()\n            \n            # Optimize each dimension (x, y, z)\n            for dim in range(3):\n                \n                def obj_1d(val):\n                    p_trial = p_i.copy()\n                    p_trial[dim] = val\n                    \n                    # Distances from i to static points\n                    d_new = np.sum((static_pts - p_trial)**2, axis=1)\n                    \n                    # New global min/max\n                    mn = min(min_s, np.min(d_new))\n                    mx = max(max_s, np.max(d_new))\n                    \n                    if mx < 1e-16: return 0.0\n                    return -(mn / mx) # Minimize negative ratio\n                \n                curr_v = p_i[dim]\n                # Search in a small window around current value\n                window = 0.15\n                res = minimize_scalar(obj_1d, bounds=(curr_v - window, curr_v + window), \n                                      method='bounded', options={'xatol': 1e-8})\n                \n                if -res.fun > current_score + 1e-12:\n                    current_score = -res.fun\n                    p_i[dim] = res.x\n                    current_pts[i, dim] = res.x\n                    improved_pass = True\n        \n        if not improved_pass:\n            # If stuck, apply tiny noise to try and dislodge\n            if time.time() - start_time < 55:\n                current_pts += np.random.normal(0, 1e-6, (N, 3))\n                # Recalculate score after perturbation\n                current_score = get_ratio_sq(current_pts)\n            else:\n                break\n                \n    return current_pts\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:40:57.829352",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2107,
        "candidates_token_count": 2337,
        "thoughts_token_count": 11507
      },
      "response_text_len": 7007
    }
  }
}