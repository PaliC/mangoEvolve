{
  "trial_id": "trial_13_1",
  "generation": 13,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Returns a numpy array of shape (14, 3) representing the coordinates of 14 points\n    that maximize the squared ratio (min_dist / max_dist)^2.\n    \n    The algorithm initializes points based on the vertices of a Rhombic Dodecahedron\n    (6 octahedron vertices + 8 cube vertices) and optimizes the configuration using SLSQP.\n    It sweeps over different aspect ratios of the Rhombic Dodecahedron to find the global peak.\n    \"\"\"\n    N = 14\n    dim = 3\n    num_pairs = N * (N - 1) // 2\n    \n    # Precompute indices for pairwise distance calculations\n    idx_i = np.zeros(num_pairs, dtype=int)\n    idx_j = np.zeros(num_pairs, dtype=int)\n    k = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i[k] = i\n            idx_j[k] = j\n            k += 1\n\n    def get_rd_points(a, b=1.0):\n        \"\"\"Generate Rhombic Dodecahedron vertices with scaling parameters.\"\"\"\n        # 6 points on octahedron: (\u00b1a, 0, 0), (0, \u00b1a, 0), (0, 0, \u00b1a)\n        octa = [\n            [a, 0, 0], [-a, 0, 0],\n            [0, a, 0], [0, -a, 0],\n            [0, 0, a], [0, 0, -a]\n        ]\n        # 8 points on cube: (\u00b1b, \u00b1b, \u00b1b)\n        cube = []\n        for x in [-b, b]:\n            for y in [-b, b]:\n                for z in [-b, b]:\n                    cube.append([x, y, z])\n        return np.array(octa + cube)\n\n    def optimize_seed(seed_points):\n        \"\"\"Run SLSQP optimization on the given seed.\"\"\"\n        # Calculate initial distances\n        diffs = seed_points[idx_i] - seed_points[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        max_d2 = np.max(d2)\n        min_d2 = np.min(d2)\n        \n        # Normalize seed so max distance is 1.0\n        scale = 1.0 / np.sqrt(max_d2)\n        x_init = (seed_points * scale).flatten()\n        s_init = min_d2 / max_d2  # Initial slack variable (squared ratio)\n        \n        # Combine coordinates and slack variable into one parameter vector\n        x0 = np.concatenate([x_init, [s_init]])\n        \n        # Objective: Maximize s (Minimize -s)\n        def objective(x):\n            return -x[-1]\n        \n        def obj_jac(x):\n            grad = np.zeros_like(x)\n            grad[-1] = -1.0\n            return grad\n        \n        # Constraints function\n        # Returns vector of size 2*num_pairs\n        # 1. Upper bound: 1 - d_ij^2 >= 0\n        # 2. Lower bound: d_ij^2 - s >= 0\n        def constraints_func(x):\n            pts = x[:-1].reshape((N, dim))\n            s = x[-1]\n            diffs = pts[idx_i] - pts[idx_j]\n            d2 = np.sum(diffs**2, axis=1)\n            return np.concatenate([1.0 - d2, d2 - s])\n        \n        # Jacobian of constraints\n        def constraints_jac(x):\n            pts = x[:-1].reshape((N, dim))\n            # s = x[-1]\n            diffs = pts[idx_i] - pts[idx_j]\n            grad_d2 = 2 * diffs  # Gradient of d^2 w.r.t (xi - xj)\n            \n            J = np.zeros((2 * num_pairs, 3 * N + 1))\n            \n            # Fill Jacobian\n            # We iterate to fill the matrix. Vectorization is possible but complex with indices.\n            # Given the small size (182 constraints), a loop is negligible in cost.\n            for k in range(num_pairs):\n                u, v = idx_i[k], idx_j[k]\n                g = grad_d2[k]\n                \n                # Part 1: 1 - d^2 >= 0  => grad is -grad(d^2)\n                J[k, 3*u:3*u+3] = -g\n                J[k, 3*v:3*v+3] = g\n                # J[k, -1] is 0\n                \n                # Part 2: d^2 - s >= 0  => grad is grad(d^2), -1 w.r.t s\n                row2 = num_pairs + k\n                J[row2, 3*u:3*u+3] = g\n                J[row2, 3*v:3*v+3] = -g\n                J[row2, -1] = -1.0\n                \n            return J\n\n        nlc = NonlinearConstraint(constraints_func, 0.0, np.inf, jac=constraints_jac)\n        \n        # Run optimization\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            jac=obj_jac, \n            constraints=[nlc],\n            options={'ftol': 1e-8, 'maxiter': 500}\n        )\n        \n        return res.x[:-1].reshape((N, dim)), res.x[-1]\n\n    # Main logic: Sweep through a/b ratios\n    # Standard Rhombic Dodecahedron has a=2, b=1 (ratio 2.0)\n    # or a=sqrt(2), b=1/sqrt(2) etc.\n    # We sweep a range to find the optimal distortion.\n    ratios = np.linspace(1.2, 2.8, 17)\n    \n    best_s = -1.0\n    best_points = None\n    \n    for r in ratios:\n        seed = get_rd_points(a=r, b=1.0)\n        pts, s = optimize_seed(seed)\n        if s > best_s:\n            best_s = s\n            best_points = pts\n            \n    return best_points",
  "metrics": {
    "valid": true,
    "score": 0.9264459711893988,
    "min_max_ratio": 0.22239063408582077,
    "min_distance": 0.47158311471689845,
    "max_distance": 1.0000000000006084,
    "eval_time": 0.31215596199035645,
    "error": null
  },
  "prompt": "The best score (~1.000016) corresponds to the Rhombic Dodecahedron (6 points on an octahedron, 8 on a cube).\nWrite a script that:\n1. Initializes points exactly at the vertices of a Rhombic Dodecahedron.\n   - 6 points: (\u00b1a, 0, 0), (0, \u00b1a, 0), (0, 0, \u00b1a)\n   - 8 points: (\u00b1b, \u00b1b, \u00b1b)\n2. Uses these as a seed for an SLSQP optimizer.\n3. Instead of maximizing min/max, maximize a slack variable 's' where d_ij^2 >= s and d_ij^2 <= 1.\n4. Run this for various ratios of a/b to find the exact peak.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Returns a numpy array of shape (14, 3) representing the coordinates of 14 points\n    that maximize the squared ratio (min_dist / max_dist)^2.\n    \n    The algorithm initializes points based on the vertices of a Rhombic Dodecahedron\n    (6 octahedron vertices + 8 cube vertices) and optimizes the configuration using SLSQP.\n    It sweeps over different aspect ratios of the Rhombic Dodecahedron to find the global peak.\n    \"\"\"\n    N = 14\n    dim = 3\n    num_pairs = N * (N - 1) // 2\n    \n    # Precompute indices for pairwise distance calculations\n    idx_i = np.zeros(num_pairs, dtype=int)\n    idx_j = np.zeros(num_pairs, dtype=int)\n    k = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i[k] = i\n            idx_j[k] = j\n            k += 1\n\n    def get_rd_points(a, b=1.0):\n        \"\"\"Generate Rhombic Dodecahedron vertices with scaling parameters.\"\"\"\n        # 6 points on octahedron: (\u00b1a, 0, 0), (0, \u00b1a, 0), (0, 0, \u00b1a)\n        octa = [\n            [a, 0, 0], [-a, 0, 0],\n            [0, a, 0], [0, -a, 0],\n            [0, 0, a], [0, 0, -a]\n        ]\n        # 8 points on cube: (\u00b1b, \u00b1b, \u00b1b)\n        cube = []\n        for x in [-b, b]:\n            for y in [-b, b]:\n                for z in [-b, b]:\n                    cube.append([x, y, z])\n        return np.array(octa + cube)\n\n    def optimize_seed(seed_points):\n        \"\"\"Run SLSQP optimization on the given seed.\"\"\"\n        # Calculate initial distances\n        diffs = seed_points[idx_i] - seed_points[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        max_d2 = np.max(d2)\n        min_d2 = np.min(d2)\n        \n        # Normalize seed so max distance is 1.0\n        scale = 1.0 / np.sqrt(max_d2)\n        x_init = (seed_points * scale).flatten()\n        s_init = min_d2 / max_d2  # Initial slack variable (squared ratio)\n        \n        # Combine coordinates and slack variable into one parameter vector\n        x0 = np.concatenate([x_init, [s_init]])\n        \n        # Objective: Maximize s (Minimize -s)\n        def objective(x):\n            return -x[-1]\n        \n        def obj_jac(x):\n            grad = np.zeros_like(x)\n            grad[-1] = -1.0\n            return grad\n        \n        # Constraints function\n        # Returns vector of size 2*num_pairs\n        # 1. Upper bound: 1 - d_ij^2 >= 0\n        # 2. Lower bound: d_ij^2 - s >= 0\n        def constraints_func(x):\n            pts = x[:-1].reshape((N, dim))\n            s = x[-1]\n            diffs = pts[idx_i] - pts[idx_j]\n            d2 = np.sum(diffs**2, axis=1)\n            return np.concatenate([1.0 - d2, d2 - s])\n        \n        # Jacobian of constraints\n        def constraints_jac(x):\n            pts = x[:-1].reshape((N, dim))\n            # s = x[-1]\n            diffs = pts[idx_i] - pts[idx_j]\n            grad_d2 = 2 * diffs  # Gradient of d^2 w.r.t (xi - xj)\n            \n            J = np.zeros((2 * num_pairs, 3 * N + 1))\n            \n            # Fill Jacobian\n            # We iterate to fill the matrix. Vectorization is possible but complex with indices.\n            # Given the small size (182 constraints), a loop is negligible in cost.\n            for k in range(num_pairs):\n                u, v = idx_i[k], idx_j[k]\n                g = grad_d2[k]\n                \n                # Part 1: 1 - d^2 >= 0  => grad is -grad(d^2)\n                J[k, 3*u:3*u+3] = -g\n                J[k, 3*v:3*v+3] = g\n                # J[k, -1] is 0\n                \n                # Part 2: d^2 - s >= 0  => grad is grad(d^2), -1 w.r.t s\n                row2 = num_pairs + k\n                J[row2, 3*u:3*u+3] = g\n                J[row2, 3*v:3*v+3] = -g\n                J[row2, -1] = -1.0\n                \n            return J\n\n        nlc = NonlinearConstraint(constraints_func, 0.0, np.inf, jac=constraints_jac)\n        \n        # Run optimization\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            jac=obj_jac, \n            constraints=[nlc],\n            options={'ftol': 1e-8, 'maxiter': 500}\n        )\n        \n        return res.x[:-1].reshape((N, dim)), res.x[-1]\n\n    # Main logic: Sweep through a/b ratios\n    # Standard Rhombic Dodecahedron has a=2, b=1 (ratio 2.0)\n    # or a=sqrt(2), b=1/sqrt(2) etc.\n    # We sweep a range to find the optimal distortion.\n    ratios = np.linspace(1.2, 2.8, 17)\n    \n    best_s = -1.0\n    best_points = None\n    \n    for r in ratios:\n        seed = get_rd_points(a=r, b=1.0)\n        pts, s = optimize_seed(seed)\n        if s > best_s:\n            best_s = s\n            best_points = pts\n            \n    return best_points\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:22:25.747922",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 351,
        "candidates_token_count": 1597,
        "thoughts_token_count": 11120
      },
      "response_text_len": 4721
    }
  }
}