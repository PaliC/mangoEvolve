{
  "trial_id": "trial_13_7",
  "generation": 13,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping\nfrom scipy.special import logsumexp\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Find 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a Basin-hopping global optimization strategy with multiple initializations.\n    \"\"\"\n    N = 14\n    D = 3\n    \n    def objective(coords):\n        \"\"\"\n        Smoothed objective function to minimize max_distance^2 / min_distance^2.\n        Uses the log-sum-exp trick for numerical stability of soft-max and soft-min.\n        \"\"\"\n        pts = coords.reshape((N, D))\n        # Vectorized pairwise squared distances calculation\n        gram = np.dot(pts, pts.T)\n        diag = np.diag(gram)\n        # d2[i, j] = ||pts[i] - pts[j]||^2\n        d2 = diag[:, None] + diag[None, :] - 2 * gram\n        # Extract upper triangle indices to avoid zero distances (diagonal)\n        d2 = d2[np.triu_indices(N, k=1)]\n        # Clip very small values to avoid log(0) issues, although logsumexp handles -inf\n        d2 = np.maximum(d2, 1e-15)\n        \n        # Smoothing parameter p. p=15 provides a good balance between approximation accuracy\n        # and objective function smoothness for the L-BFGS-B optimizer.\n        p = 15\n        log_d2 = np.log(d2)\n        \n        # log_s_max = log((sum(d2^p))^(1/p))\n        log_s_max = (1.0 / p) * logsumexp(p * log_d2)\n        # log_s_min = log((sum(d2^-p))^(-1/p))\n        log_s_min = -(1.0 / p) * logsumexp(-p * log_d2)\n        \n        # Minimizing s_max / s_min is equivalent to maximizing s_min / s_max\n        return np.exp(log_s_max - log_s_min)\n\n    best_pts = None\n    best_val = np.inf\n    start_time = time.time()\n    \n    # Strategy: Multiple restarts with diverse initializations\n    # Strategy B (uniform box) and others (sphere, cube+face centers)\n    for i in range(12):\n        # Monitor time to ensure completion within 60 seconds\n        if time.time() - start_time > 54:\n            break\n            \n        if i == 0:\n            # Initialization A: Cube vertices + Face centers (14 points)\n            pts = []\n            for x in [-1, 1]:\n                for y in [-1, 1]:\n                    for z in [-1, 1]:\n                        pts.append([x, y, z])\n            for c in [-1, 1]:\n                pts.append([c, 0, 0])\n                pts.append([0, c, 0])\n                pts.append([0, 0, c])\n            initial_pts = np.array(pts)\n        elif i == 1:\n            # Initialization B: Fibonacci spiral distribution on a sphere\n            phi = np.arccos(1 - 2 * np.arange(0.5, N, 1) / N)\n            theta = np.pi * (1 + 5**0.5) * np.arange(0.5, N, 1)\n            initial_pts = np.stack([np.sin(phi) * np.cos(theta), \n                                    np.sin(phi) * np.sin(theta), \n                                    np.cos(phi)], axis=1)\n        elif i == 2:\n            # Initialization C: Uniform random points within a sphere\n            pts = np.random.normal(0, 1, (N, D))\n            pts /= (np.linalg.norm(pts, axis=1)[:, None] + 1e-15)\n            pts *= np.random.uniform(0, 1, (N, 1))**(1/3)\n            initial_pts = pts\n        else:\n            # Initialization D: Strategy B - Uniform random points in a box [-1, 1]^3\n            initial_pts = np.random.uniform(-1, 1, (N, D))\n            \n        # Basin-hopping with L-BFGS-B as the local minimizer\n        res = basinhopping(\n            objective, \n            initial_pts.flatten(),\n            niter=30,\n            T=0.5,\n            stepsize=0.5,\n            minimizer_kwargs={\n                \"method\": \"L-BFGS-B\", \n                \"options\": {\n                    \"ftol\": 1e-14, # Requested tighter tolerance\n                    \"gtol\": 1e-14\n                }\n            }\n        )\n        \n        # Track the best configuration found across all restarts\n        if res.fun < best_val:\n            best_val = res.fun\n            best_pts = res.x.reshape((N, D))\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9579769587895713,
    "min_max_ratio": 0.2299595550416236,
    "min_distance": 2.024060006792969,
    "max_distance": 4.220827990975469,
    "eval_time": 56.01216101646423,
    "error": null
  },
  "prompt": "Re-implement the Basin-hopping strategy from trial_8_0 but increase the number of random restarts and use a tighter tolerance (1e-14). Focus on the 'Strategy B' (uniform box) which found the global optimum.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping\nfrom scipy.special import logsumexp\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Find 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a Basin-hopping global optimization strategy with multiple initializations.\n    \"\"\"\n    N = 14\n    D = 3\n    \n    def objective(coords):\n        \"\"\"\n        Smoothed objective function to minimize max_distance^2 / min_distance^2.\n        Uses the log-sum-exp trick for numerical stability of soft-max and soft-min.\n        \"\"\"\n        pts = coords.reshape((N, D))\n        # Vectorized pairwise squared distances calculation\n        gram = np.dot(pts, pts.T)\n        diag = np.diag(gram)\n        # d2[i, j] = ||pts[i] - pts[j]||^2\n        d2 = diag[:, None] + diag[None, :] - 2 * gram\n        # Extract upper triangle indices to avoid zero distances (diagonal)\n        d2 = d2[np.triu_indices(N, k=1)]\n        # Clip very small values to avoid log(0) issues, although logsumexp handles -inf\n        d2 = np.maximum(d2, 1e-15)\n        \n        # Smoothing parameter p. p=15 provides a good balance between approximation accuracy\n        # and objective function smoothness for the L-BFGS-B optimizer.\n        p = 15\n        log_d2 = np.log(d2)\n        \n        # log_s_max = log((sum(d2^p))^(1/p))\n        log_s_max = (1.0 / p) * logsumexp(p * log_d2)\n        # log_s_min = log((sum(d2^-p))^(-1/p))\n        log_s_min = -(1.0 / p) * logsumexp(-p * log_d2)\n        \n        # Minimizing s_max / s_min is equivalent to maximizing s_min / s_max\n        return np.exp(log_s_max - log_s_min)\n\n    best_pts = None\n    best_val = np.inf\n    start_time = time.time()\n    \n    # Strategy: Multiple restarts with diverse initializations\n    # Strategy B (uniform box) and others (sphere, cube+face centers)\n    for i in range(12):\n        # Monitor time to ensure completion within 60 seconds\n        if time.time() - start_time > 54:\n            break\n            \n        if i == 0:\n            # Initialization A: Cube vertices + Face centers (14 points)\n            pts = []\n            for x in [-1, 1]:\n                for y in [-1, 1]:\n                    for z in [-1, 1]:\n                        pts.append([x, y, z])\n            for c in [-1, 1]:\n                pts.append([c, 0, 0])\n                pts.append([0, c, 0])\n                pts.append([0, 0, c])\n            initial_pts = np.array(pts)\n        elif i == 1:\n            # Initialization B: Fibonacci spiral distribution on a sphere\n            phi = np.arccos(1 - 2 * np.arange(0.5, N, 1) / N)\n            theta = np.pi * (1 + 5**0.5) * np.arange(0.5, N, 1)\n            initial_pts = np.stack([np.sin(phi) * np.cos(theta), \n                                    np.sin(phi) * np.sin(theta), \n                                    np.cos(phi)], axis=1)\n        elif i == 2:\n            # Initialization C: Uniform random points within a sphere\n            pts = np.random.normal(0, 1, (N, D))\n            pts /= (np.linalg.norm(pts, axis=1)[:, None] + 1e-15)\n            pts *= np.random.uniform(0, 1, (N, 1))**(1/3)\n            initial_pts = pts\n        else:\n            # Initialization D: Strategy B - Uniform random points in a box [-1, 1]^3\n            initial_pts = np.random.uniform(-1, 1, (N, D))\n            \n        # Basin-hopping with L-BFGS-B as the local minimizer\n        res = basinhopping(\n            objective, \n            initial_pts.flatten(),\n            niter=30,\n            T=0.5,\n            stepsize=0.5,\n            minimizer_kwargs={\n                \"method\": \"L-BFGS-B\", \n                \"options\": {\n                    \"ftol\": 1e-14, # Requested tighter tolerance\n                    \"gtol\": 1e-14\n                }\n            }\n        )\n        \n        # Track the best configuration found across all restarts\n        if res.fun < best_val:\n            best_val = res.fun\n            best_pts = res.x.reshape((N, D))\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:23:41.490467",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 222,
        "candidates_token_count": 1242,
        "thoughts_token_count": 19093
      },
      "response_text_len": 4023
    }
  }
}