{
  "trial_id": "trial_7_3",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a LogSumExp smoothing of the minimum and maximum distances with a cooling schedule \n    and SLSQP refinement.\n    \"\"\"\n    N = 14\n    dim = 3\n    # Pairwise indices for 14 points (91 pairs)\n    i_triu, j_triu = np.triu_indices(N, k=1)\n\n    def objective(X_flat, beta):\n        \"\"\"\n        Smooth approximation of -(min_dist^2 / max_dist^2) using LogSumExp.\n        \"\"\"\n        X = X_flat.reshape((N, dim))\n        # Compute all pairwise squared distances\n        diff = X[i_triu] - X[j_triu]\n        d2 = np.sum(diff**2, axis=1)\n        \n        d2_min = np.min(d2)\n        d2_max = np.max(d2)\n        \n        # LogSumExp trick for numerical stability (all arguments to exp will be <= 0)\n        arg_min = -beta * (d2 - d2_min)\n        arg_max = beta * (d2 - d2_max)\n        \n        # Smooth min and max squared distances\n        s_min = d2_min - (1.0 / beta) * np.log(np.sum(np.exp(arg_min)))\n        s_max = d2_max + (1.0 / beta) * np.log(np.sum(np.exp(arg_max)))\n        \n        # We minimize the negative ratio\n        return -s_min / s_max\n\n    def get_ratio_sq(X):\n        \"\"\"\n        Calculates the actual (min_dist / max_dist)^2.\n        \"\"\"\n        X = X.reshape((N, dim))\n        diff = X[i_triu] - X[j_triu]\n        d2 = np.sum(diff**2, axis=1)\n        return np.min(d2) / np.max(d2)\n\n    best_X = None\n    best_val = -1\n    \n    # Generate a variety of starting configurations\n    starts = []\n    # 1. Random configurations in a cube\n    for _ in range(3):\n        starts.append(np.random.rand(N, dim) - 0.5)\n    # 2. Random configurations on a sphere\n    for _ in range(1):\n        X_sphere = np.random.randn(N, dim)\n        X_sphere /= np.linalg.norm(X_sphere, axis=1)[:, np.newaxis]\n        starts.append(X_sphere)\n    # 3. Rhombic dodecahedron-like structure\n    rd = np.array([\n        [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],\n        [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],\n        [1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]\n    ])\n    starts.append(rd)\n    # 4. Hexagonal antiprism with caps\n    ha = []\n    for i in range(6):\n        angle1 = 2 * np.pi * i / 6\n        ha.append([np.cos(angle1), np.sin(angle1), 0.5])\n        angle2 = 2 * np.pi * i / 6 + np.pi / 6\n        ha.append([np.cos(angle2), np.sin(angle2), -0.5])\n    ha.append([0, 0, 1.2])\n    ha.append([0, 0, -1.2])\n    starts.append(np.array(ha))\n\n    # Cooling schedule with SLSQP refinement\n    for X in starts:\n        X_curr = X.copy()\n        for beta in [20, 60, 150]:\n            # Refine the configuration at the current temperature using SLSQP\n            res = minimize(objective, X_curr.flatten(), args=(beta,), method='SLSQP', options={'maxiter': 50})\n            if res.success:\n                X_curr = res.x.reshape((N, dim))\n            \n            # Re-center and normalize to maintain scale and prevent drifting\n            X_curr -= np.mean(X_curr, axis=0)\n            diff = X_curr[i_triu] - X_curr[j_triu]\n            d2_temp = np.sum(diff**2, axis=1)\n            X_curr /= np.sqrt(np.max(d2_temp))\n        \n        # Evaluate the final ratio for this start\n        val = get_ratio_sq(X_curr)\n        if val > best_val:\n            best_val = val\n            best_X = X_curr.copy()\n    \n    # Final high-temperature polish for the overall best result\n    res_final = minimize(objective, best_X.flatten(), args=(400,), method='SLSQP', options={'maxiter': 100})\n    if res_final.success:\n        best_X = res_final.x.reshape((N, dim))\n    \n    # Final normalization before returning\n    best_X -= np.mean(best_X, axis=0)\n    diff_final = best_X[i_triu] - best_X[j_triu]\n    d2_final = np.sum(diff_final**2, axis=1)\n    best_X /= np.sqrt(np.max(d2_final))\n\n    return best_X",
  "metrics": {
    "valid": true,
    "score": 0.8802894001148265,
    "min_max_ratio": 0.21131088477747942,
    "min_distance": 0.45968563690578734,
    "max_distance": 0.9999999999999999,
    "eval_time": 1.2057559490203857,
    "error": null
  },
  "prompt": "Generate a solution for 14 points using a 'LogSumExp' smoothing of the \n        minimum distance, but instead of just one temperature, use a 'cooling schedule' \n        where the temperature increases (making it closer to the true min) while \n        simultaneously using SLSQP to refine the result at each step.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a LogSumExp smoothing of the minimum and maximum distances with a cooling schedule \n    and SLSQP refinement.\n    \"\"\"\n    N = 14\n    dim = 3\n    # Pairwise indices for 14 points (91 pairs)\n    i_triu, j_triu = np.triu_indices(N, k=1)\n\n    def objective(X_flat, beta):\n        \"\"\"\n        Smooth approximation of -(min_dist^2 / max_dist^2) using LogSumExp.\n        \"\"\"\n        X = X_flat.reshape((N, dim))\n        # Compute all pairwise squared distances\n        diff = X[i_triu] - X[j_triu]\n        d2 = np.sum(diff**2, axis=1)\n        \n        d2_min = np.min(d2)\n        d2_max = np.max(d2)\n        \n        # LogSumExp trick for numerical stability (all arguments to exp will be <= 0)\n        arg_min = -beta * (d2 - d2_min)\n        arg_max = beta * (d2 - d2_max)\n        \n        # Smooth min and max squared distances\n        s_min = d2_min - (1.0 / beta) * np.log(np.sum(np.exp(arg_min)))\n        s_max = d2_max + (1.0 / beta) * np.log(np.sum(np.exp(arg_max)))\n        \n        # We minimize the negative ratio\n        return -s_min / s_max\n\n    def get_ratio_sq(X):\n        \"\"\"\n        Calculates the actual (min_dist / max_dist)^2.\n        \"\"\"\n        X = X.reshape((N, dim))\n        diff = X[i_triu] - X[j_triu]\n        d2 = np.sum(diff**2, axis=1)\n        return np.min(d2) / np.max(d2)\n\n    best_X = None\n    best_val = -1\n    \n    # Generate a variety of starting configurations\n    starts = []\n    # 1. Random configurations in a cube\n    for _ in range(3):\n        starts.append(np.random.rand(N, dim) - 0.5)\n    # 2. Random configurations on a sphere\n    for _ in range(1):\n        X_sphere = np.random.randn(N, dim)\n        X_sphere /= np.linalg.norm(X_sphere, axis=1)[:, np.newaxis]\n        starts.append(X_sphere)\n    # 3. Rhombic dodecahedron-like structure\n    rd = np.array([\n        [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],\n        [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],\n        [1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]\n    ])\n    starts.append(rd)\n    # 4. Hexagonal antiprism with caps\n    ha = []\n    for i in range(6):\n        angle1 = 2 * np.pi * i / 6\n        ha.append([np.cos(angle1), np.sin(angle1), 0.5])\n        angle2 = 2 * np.pi * i / 6 + np.pi / 6\n        ha.append([np.cos(angle2), np.sin(angle2), -0.5])\n    ha.append([0, 0, 1.2])\n    ha.append([0, 0, -1.2])\n    starts.append(np.array(ha))\n\n    # Cooling schedule with SLSQP refinement\n    for X in starts:\n        X_curr = X.copy()\n        for beta in [20, 60, 150]:\n            # Refine the configuration at the current temperature using SLSQP\n            res = minimize(objective, X_curr.flatten(), args=(beta,), method='SLSQP', options={'maxiter': 50})\n            if res.success:\n                X_curr = res.x.reshape((N, dim))\n            \n            # Re-center and normalize to maintain scale and prevent drifting\n            X_curr -= np.mean(X_curr, axis=0)\n            diff = X_curr[i_triu] - X_curr[j_triu]\n            d2_temp = np.sum(diff**2, axis=1)\n            X_curr /= np.sqrt(np.max(d2_temp))\n        \n        # Evaluate the final ratio for this start\n        val = get_ratio_sq(X_curr)\n        if val > best_val:\n            best_val = val\n            best_X = X_curr.copy()\n    \n    # Final high-temperature polish for the overall best result\n    res_final = minimize(objective, best_X.flatten(), args=(400,), method='SLSQP', options={'maxiter': 100})\n    if res_final.success:\n        best_X = res_final.x.reshape((N, dim))\n    \n    # Final normalization before returning\n    best_X -= np.mean(best_X, axis=0)\n    diff_final = best_X[i_triu] - best_X[j_triu]\n    d2_final = np.sum(diff_final**2, axis=1)\n    best_X /= np.sqrt(np.max(d2_final))\n\n    return best_X\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:48:31.330748",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 243,
        "candidates_token_count": 1454,
        "thoughts_token_count": 21870
      },
      "response_text_len": 3964
    }
  }
}