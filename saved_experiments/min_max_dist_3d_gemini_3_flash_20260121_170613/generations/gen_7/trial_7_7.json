{
  "trial_id": "trial_7_7",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a high-restart Basin-hopping search with a slack-variable SLSQP polish.\n    \"\"\"\n    start_time = time.time()\n    n_points = 14\n    triu_indices = np.triu_indices(n_points, k=1)\n    rows, cols = triu_indices\n\n    def get_fibonacci_sphere(n, phi):\n        \"\"\"Generates points on a sphere using a Fibonacci-like distribution.\"\"\"\n        i = np.arange(n)\n        z = 1 - 2 * (i + 0.5) / n\n        r = np.sqrt(np.maximum(0, 1 - z * z))\n        theta = 2 * np.pi * i / phi\n        return np.column_stack([r * np.cos(theta), r * np.sin(theta), z])\n\n    def solve_slsqp(x0):\n        \"\"\"Polishes a configuration using the slack-variable SLSQP formulation.\"\"\"\n        try:\n            # Initial distance calculation for normalization\n            diffs = x0[rows] - x0[cols]\n            d2_triu = np.sum(diffs**2, axis=-1)\n            max_d2 = np.max(d2_triu)\n            if max_d2 == 0: max_d2 = 1\n            \n            # Normalize so that max distance is 1\n            x0 = x0 / np.sqrt(max_d2)\n            d2_triu = d2_triu / max_d2\n            s0 = np.min(d2_triu)\n            \n            # Parameters: [x1, y1, z1, ..., x14, y14, z14, s]\n            initial_params = np.concatenate([x0.flatten(), [s0]])\n            \n            def obj(p):\n                # Maximize s (the squared ratio)\n                return -p[-1]\n            \n            def grad_obj(p):\n                g = np.zeros(43)\n                g[-1] = -1\n                return g\n            \n            def combined_cons(p):\n                # Two sets of constraints:\n                # 1. All pairwise distances squared >= s\n                # 2. All pairwise distances squared <= 1\n                x = p[:-1].reshape((n_points, 3))\n                s = p[-1]\n                diffs = x[rows] - x[cols]\n                d2_triu = np.sum(diffs**2, axis=-1)\n                return np.concatenate([d2_triu - s, 1.0 - d2_triu])\n\n            def combined_cons_jac(p):\n                # Jacobian for the 182 constraints\n                x = p[:-1].reshape((n_points, 3))\n                jac_min = np.zeros((91, 43))\n                diffs = x[rows] - x[cols]\n                for idx in range(91):\n                    i, j = rows[idx], cols[idx]\n                    d = 2 * diffs[idx]\n                    jac_min[idx, 3*i:3*i+3] = d\n                    jac_min[idx, 3*j:3*j+3] = -d\n                jac_min[:, -1] = -1\n                \n                jac_max = -jac_min.copy()\n                jac_max[:, -1] = 0\n                return np.vstack([jac_min, jac_max])\n\n            # Coordinate bounds and ratio bounds\n            bounds = [(-1.5, 1.5)] * 42 + [(0.0, 1.0)]\n            \n            res = minimize(\n                obj, initial_params, jac=grad_obj,\n                constraints={'type': 'ineq', 'fun': combined_cons, 'jac': combined_cons_jac},\n                method='SLSQP', bounds=bounds,\n                options={'maxiter': 120, 'ftol': 1e-7}\n            )\n            return res\n        except:\n            # Fallback for optimization failure\n            class Dummy:\n                def __init__(self):\n                    self.fun = 1e9\n                    self.x = np.zeros(43)\n            return Dummy()\n\n    best_s = -1\n    best_params = None\n    \n    # 1. Fibonacci Sphere Initializations (as requested)\n    phi_user = (1 + 5**0.5) / 2 + 0.02\n    phi_values = [phi_user, (1 + 5**0.5) / 2, 1.58, 1.65, 1.70, 1.50]\n    \n    for phi in phi_values:\n        if time.time() - start_time > 55:\n            break\n        x0 = get_fibonacci_sphere(n_points, phi)\n        res = solve_slsqp(x0)\n        if -res.fun > best_s:\n            best_s = -res.fun\n            best_params = res.x\n    \n    # 2. Basin-hopping loop: alternate between random starts and perturbations\n    while time.time() - start_time < 55:\n        # Perturbation of the current best configuration\n        if best_params is not None:\n            x_pert = best_params[:-1].reshape((n_points, 3)) + np.random.normal(0, 0.08, (n_points, 3))\n            res = solve_slsqp(x_pert)\n            if -res.fun > best_s:\n                best_s = -res.fun\n                best_params = res.x\n        \n        # New random start to explore a different basin\n        x_rand = np.random.uniform(-0.5, 0.5, (n_points, 3))\n        res = solve_slsqp(x_rand)\n        if -res.fun > best_s:\n            best_s = -res.fun\n            best_params = res.x\n\n    # Return the best found configuration\n    if best_params is None:\n        return np.random.uniform(-0.5, 0.5, (n_points, 3))\n    \n    return best_params[:-1].reshape((n_points, 3))",
  "metrics": {
    "valid": true,
    "score": 0.002270444892435727,
    "min_max_ratio": 0.0005450136273326937,
    "min_distance": 0.06801097882315198,
    "max_distance": 2.913233830455493,
    "eval_time": 55.334468126297,
    "error": null
  },
  "prompt": "Perform a high-restart Basin-hopping search for 14 points. Use a Fibonacci sphere with a slightly different 'golden ratio' (e.g., (1+sqrt(5))/2 + 0.02) to see if it leads to a better basin. Use the slack-variable SLSQP polish.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a high-restart Basin-hopping search with a slack-variable SLSQP polish.\n    \"\"\"\n    start_time = time.time()\n    n_points = 14\n    triu_indices = np.triu_indices(n_points, k=1)\n    rows, cols = triu_indices\n\n    def get_fibonacci_sphere(n, phi):\n        \"\"\"Generates points on a sphere using a Fibonacci-like distribution.\"\"\"\n        i = np.arange(n)\n        z = 1 - 2 * (i + 0.5) / n\n        r = np.sqrt(np.maximum(0, 1 - z * z))\n        theta = 2 * np.pi * i / phi\n        return np.column_stack([r * np.cos(theta), r * np.sin(theta), z])\n\n    def solve_slsqp(x0):\n        \"\"\"Polishes a configuration using the slack-variable SLSQP formulation.\"\"\"\n        try:\n            # Initial distance calculation for normalization\n            diffs = x0[rows] - x0[cols]\n            d2_triu = np.sum(diffs**2, axis=-1)\n            max_d2 = np.max(d2_triu)\n            if max_d2 == 0: max_d2 = 1\n            \n            # Normalize so that max distance is 1\n            x0 = x0 / np.sqrt(max_d2)\n            d2_triu = d2_triu / max_d2\n            s0 = np.min(d2_triu)\n            \n            # Parameters: [x1, y1, z1, ..., x14, y14, z14, s]\n            initial_params = np.concatenate([x0.flatten(), [s0]])\n            \n            def obj(p):\n                # Maximize s (the squared ratio)\n                return -p[-1]\n            \n            def grad_obj(p):\n                g = np.zeros(43)\n                g[-1] = -1\n                return g\n            \n            def combined_cons(p):\n                # Two sets of constraints:\n                # 1. All pairwise distances squared >= s\n                # 2. All pairwise distances squared <= 1\n                x = p[:-1].reshape((n_points, 3))\n                s = p[-1]\n                diffs = x[rows] - x[cols]\n                d2_triu = np.sum(diffs**2, axis=-1)\n                return np.concatenate([d2_triu - s, 1.0 - d2_triu])\n\n            def combined_cons_jac(p):\n                # Jacobian for the 182 constraints\n                x = p[:-1].reshape((n_points, 3))\n                jac_min = np.zeros((91, 43))\n                diffs = x[rows] - x[cols]\n                for idx in range(91):\n                    i, j = rows[idx], cols[idx]\n                    d = 2 * diffs[idx]\n                    jac_min[idx, 3*i:3*i+3] = d\n                    jac_min[idx, 3*j:3*j+3] = -d\n                jac_min[:, -1] = -1\n                \n                jac_max = -jac_min.copy()\n                jac_max[:, -1] = 0\n                return np.vstack([jac_min, jac_max])\n\n            # Coordinate bounds and ratio bounds\n            bounds = [(-1.5, 1.5)] * 42 + [(0.0, 1.0)]\n            \n            res = minimize(\n                obj, initial_params, jac=grad_obj,\n                constraints={'type': 'ineq', 'fun': combined_cons, 'jac': combined_cons_jac},\n                method='SLSQP', bounds=bounds,\n                options={'maxiter': 120, 'ftol': 1e-7}\n            )\n            return res\n        except:\n            # Fallback for optimization failure\n            class Dummy:\n                def __init__(self):\n                    self.fun = 1e9\n                    self.x = np.zeros(43)\n            return Dummy()\n\n    best_s = -1\n    best_params = None\n    \n    # 1. Fibonacci Sphere Initializations (as requested)\n    phi_user = (1 + 5**0.5) / 2 + 0.02\n    phi_values = [phi_user, (1 + 5**0.5) / 2, 1.58, 1.65, 1.70, 1.50]\n    \n    for phi in phi_values:\n        if time.time() - start_time > 55:\n            break\n        x0 = get_fibonacci_sphere(n_points, phi)\n        res = solve_slsqp(x0)\n        if -res.fun > best_s:\n            best_s = -res.fun\n            best_params = res.x\n    \n    # 2. Basin-hopping loop: alternate between random starts and perturbations\n    while time.time() - start_time < 55:\n        # Perturbation of the current best configuration\n        if best_params is not None:\n            x_pert = best_params[:-1].reshape((n_points, 3)) + np.random.normal(0, 0.08, (n_points, 3))\n            res = solve_slsqp(x_pert)\n            if -res.fun > best_s:\n                best_s = -res.fun\n                best_params = res.x\n        \n        # New random start to explore a different basin\n        x_rand = np.random.uniform(-0.5, 0.5, (n_points, 3))\n        res = solve_slsqp(x_rand)\n        if -res.fun > best_s:\n            best_s = -res.fun\n            best_params = res.x\n\n    # Return the best found configuration\n    if best_params is None:\n        return np.random.uniform(-0.5, 0.5, (n_points, 3))\n    \n    return best_params[:-1].reshape((n_points, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:49:22.946398",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 238,
        "candidates_token_count": 1553,
        "thoughts_token_count": 24952
      },
      "response_text_len": 4795
    }
  }
}