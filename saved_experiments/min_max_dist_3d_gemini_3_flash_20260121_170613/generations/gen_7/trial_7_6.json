{
  "trial_id": "trial_7_6",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a basin-hopping search starting with a modified Fibonacci sphere and SLSQP optimization.\n    \"\"\"\n    n = 14\n    indices = np.triu_indices(n, k=1)\n    num_pairs = len(indices[0])\n\n    def get_initial_pts(phi_offset):\n        \"\"\"Generates initial points using a Fibonacci sphere with a modified golden ratio.\"\"\"\n        phi = (1 + 5**0.5) / 2 + phi_offset\n        pts = []\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            radius = np.sqrt(max(0, 1 - y * y))\n            theta = 2 * np.pi * i / phi\n            x = np.cos(theta) * radius\n            z = np.sin(theta) * radius\n            pts.append([x, y, z])\n        return np.array(pts)\n\n    def objective(v):\n        \"\"\"Objective function to maximize the slack variable s (which represents d_min^2).\"\"\"\n        return -v[-1]\n\n    def objective_jac(v):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        j = np.zeros(n * 3 + 1)\n        j[-1] = -1\n        return j\n\n    def constraint_fn(v, n, indices):\n        \"\"\"\n        Constraints for SLSQP:\n        1) dist(i, j)^2 >= s (for all pairs)\n        2) dist(i, j)^2 <= 1 (for all pairs)\n        \"\"\"\n        p = v[:-1].reshape((n, 3))\n        s = v[-1]\n        diffs = p[indices[0]] - p[indices[1]]\n        dists_sq = np.sum(diffs**2, axis=1)\n        return np.concatenate([dists_sq - s, 1.0 - dists_sq])\n\n    def constraint_jac(v, n, indices):\n        \"\"\"Jacobian of the constraints.\"\"\"\n        p = v[:-1].reshape((n, 3))\n        jac = np.zeros((2 * num_pairs, n * 3 + 1))\n        diffs = p[indices[0]] - p[indices[1]]\n        rows = np.arange(num_pairs)\n        for d_idx in range(3):\n            # Derivatives for dists_sq - s\n            jac[rows, indices[0] * 3 + d_idx] = 2 * diffs[:, d_idx]\n            jac[rows, indices[1] * 3 + d_idx] = -2 * diffs[:, d_idx]\n            # Derivatives for 1.0 - dists_sq\n            jac[rows + num_pairs, indices[0] * 3 + d_idx] = -2 * diffs[:, d_idx]\n            jac[rows + num_pairs, indices[1] * 3 + d_idx] = 2 * diffs[:, d_idx]\n        # Partial derivative with respect to slack variable s\n        jac[rows, -1] = -1\n        return jac\n\n    best_pts = None\n    best_score = -1\n    start_time = time.time()\n    \n    # Start with the requested Fibonacci sphere offset\n    current_pts = get_initial_pts(0.01)\n    \n    while time.time() - start_time < 55:\n        # Normalize current configuration so that max distance is at most 1\n        diffs_init = current_pts[:, np.newaxis, :] - current_pts[np.newaxis, :, :]\n        dists_sq_init = np.sum(diffs_init**2, axis=-1)\n        max_dsq_init = np.max(dists_sq_init)\n        if max_dsq_init == 0: \n            max_dsq_init = 1.0\n        \n        norm_pts = current_pts / np.sqrt(max_dsq_init)\n        tri_dists_sq_init = dists_sq_init[indices] / max_dsq_init\n        s_init = np.min(tri_dists_sq_init)\n        \n        # Initial variables for SLSQP: [flattened points, slack variable s]\n        init_vars = np.concatenate([norm_pts.flatten(), [s_init]])\n        \n        # Refine using SLSQP\n        res = minimize(\n            objective, \n            init_vars, \n            jac=objective_jac,\n            constraints={'type': 'ineq', 'fun': constraint_fn, 'jac': constraint_jac, 'args': (n, indices)}, \n            method='SLSQP', \n            bounds=[(None, None)] * (n * 3) + [(0.0, 1.0)],\n            options={'maxiter': 200, 'disp': False}\n        )\n        \n        if res.success or True:\n            # Evaluate the result\n            if not np.any(np.isnan(res.x)):\n                pts_res = res.x[:-1].reshape((n, 3))\n                diffs = pts_res[:, np.newaxis, :] - pts_res[np.newaxis, :, :]\n                d_sq = np.sum(diffs**2, axis=-1)[indices]\n                max_dsq = np.max(d_sq)\n                if max_dsq > 0:\n                    score = np.min(d_sq) / max_dsq\n                    if score > best_score:\n                        best_score = score\n                        best_pts = pts_res\n        \n        # Basin-hopping: perturb the best found solution or reset to a new Fibonacci sphere\n        if best_pts is not None:\n            if np.random.rand() < 0.7:\n                # Small perturbation\n                current_pts = best_pts + np.random.normal(0, 0.05, (n, 3))\n            else:\n                # Random Fibonacci reset\n                current_pts = get_initial_pts(np.random.uniform(-0.5, 0.5))\n        else:\n            current_pts = get_initial_pts(np.random.uniform(-0.5, 0.5))\n            \n    return best_pts if best_pts is not None else get_initial_pts(0.01)",
  "metrics": {
    "valid": true,
    "score": 1.0000159135537656,
    "min_max_ratio": 0.24005088264954844,
    "min_distance": 0.48994987769114084,
    "max_distance": 1.0000000000000322,
    "eval_time": 55.26400899887085,
    "error": null
  },
  "prompt": "Perform a high-restart Basin-hopping search for 14 points. Use a Fibonacci sphere with a slightly different 'golden ratio' (e.g., (1+sqrt(5))/2 + 0.01) to see if it leads to a better basin. Use the slack-variable SLSQP polish.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a basin-hopping search starting with a modified Fibonacci sphere and SLSQP optimization.\n    \"\"\"\n    n = 14\n    indices = np.triu_indices(n, k=1)\n    num_pairs = len(indices[0])\n\n    def get_initial_pts(phi_offset):\n        \"\"\"Generates initial points using a Fibonacci sphere with a modified golden ratio.\"\"\"\n        phi = (1 + 5**0.5) / 2 + phi_offset\n        pts = []\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            radius = np.sqrt(max(0, 1 - y * y))\n            theta = 2 * np.pi * i / phi\n            x = np.cos(theta) * radius\n            z = np.sin(theta) * radius\n            pts.append([x, y, z])\n        return np.array(pts)\n\n    def objective(v):\n        \"\"\"Objective function to maximize the slack variable s (which represents d_min^2).\"\"\"\n        return -v[-1]\n\n    def objective_jac(v):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        j = np.zeros(n * 3 + 1)\n        j[-1] = -1\n        return j\n\n    def constraint_fn(v, n, indices):\n        \"\"\"\n        Constraints for SLSQP:\n        1) dist(i, j)^2 >= s (for all pairs)\n        2) dist(i, j)^2 <= 1 (for all pairs)\n        \"\"\"\n        p = v[:-1].reshape((n, 3))\n        s = v[-1]\n        diffs = p[indices[0]] - p[indices[1]]\n        dists_sq = np.sum(diffs**2, axis=1)\n        return np.concatenate([dists_sq - s, 1.0 - dists_sq])\n\n    def constraint_jac(v, n, indices):\n        \"\"\"Jacobian of the constraints.\"\"\"\n        p = v[:-1].reshape((n, 3))\n        jac = np.zeros((2 * num_pairs, n * 3 + 1))\n        diffs = p[indices[0]] - p[indices[1]]\n        rows = np.arange(num_pairs)\n        for d_idx in range(3):\n            # Derivatives for dists_sq - s\n            jac[rows, indices[0] * 3 + d_idx] = 2 * diffs[:, d_idx]\n            jac[rows, indices[1] * 3 + d_idx] = -2 * diffs[:, d_idx]\n            # Derivatives for 1.0 - dists_sq\n            jac[rows + num_pairs, indices[0] * 3 + d_idx] = -2 * diffs[:, d_idx]\n            jac[rows + num_pairs, indices[1] * 3 + d_idx] = 2 * diffs[:, d_idx]\n        # Partial derivative with respect to slack variable s\n        jac[rows, -1] = -1\n        return jac\n\n    best_pts = None\n    best_score = -1\n    start_time = time.time()\n    \n    # Start with the requested Fibonacci sphere offset\n    current_pts = get_initial_pts(0.01)\n    \n    while time.time() - start_time < 55:\n        # Normalize current configuration so that max distance is at most 1\n        diffs_init = current_pts[:, np.newaxis, :] - current_pts[np.newaxis, :, :]\n        dists_sq_init = np.sum(diffs_init**2, axis=-1)\n        max_dsq_init = np.max(dists_sq_init)\n        if max_dsq_init == 0: \n            max_dsq_init = 1.0\n        \n        norm_pts = current_pts / np.sqrt(max_dsq_init)\n        tri_dists_sq_init = dists_sq_init[indices] / max_dsq_init\n        s_init = np.min(tri_dists_sq_init)\n        \n        # Initial variables for SLSQP: [flattened points, slack variable s]\n        init_vars = np.concatenate([norm_pts.flatten(), [s_init]])\n        \n        # Refine using SLSQP\n        res = minimize(\n            objective, \n            init_vars, \n            jac=objective_jac,\n            constraints={'type': 'ineq', 'fun': constraint_fn, 'jac': constraint_jac, 'args': (n, indices)}, \n            method='SLSQP', \n            bounds=[(None, None)] * (n * 3) + [(0.0, 1.0)],\n            options={'maxiter': 200, 'disp': False}\n        )\n        \n        if res.success or True:\n            # Evaluate the result\n            if not np.any(np.isnan(res.x)):\n                pts_res = res.x[:-1].reshape((n, 3))\n                diffs = pts_res[:, np.newaxis, :] - pts_res[np.newaxis, :, :]\n                d_sq = np.sum(diffs**2, axis=-1)[indices]\n                max_dsq = np.max(d_sq)\n                if max_dsq > 0:\n                    score = np.min(d_sq) / max_dsq\n                    if score > best_score:\n                        best_score = score\n                        best_pts = pts_res\n        \n        # Basin-hopping: perturb the best found solution or reset to a new Fibonacci sphere\n        if best_pts is not None:\n            if np.random.rand() < 0.7:\n                # Small perturbation\n                current_pts = best_pts + np.random.normal(0, 0.05, (n, 3))\n            else:\n                # Random Fibonacci reset\n                current_pts = get_initial_pts(np.random.uniform(-0.5, 0.5))\n        else:\n            current_pts = get_initial_pts(np.random.uniform(-0.5, 0.5))\n            \n    return best_pts if best_pts is not None else get_initial_pts(0.01)\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:49:09.423275",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 238,
        "candidates_token_count": 1559,
        "thoughts_token_count": 19521
      },
      "response_text_len": 4772
    }
  }
}