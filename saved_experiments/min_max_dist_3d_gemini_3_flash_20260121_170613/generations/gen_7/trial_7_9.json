{
  "trial_id": "trial_7_9",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a high-restart Basin-hopping approach with Fibonacci sphere initializations and SLSQP polishing.\n    \"\"\"\n    N = 14\n    start_time = time.time()\n    idx_tri = np.triu_indices(N, k=1)\n\n    def get_score(pts):\n        \"\"\"Calculates the squared ratio (min_dist / max_dist)^2.\"\"\"\n        # pts is expected to be (N, 3)\n        diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=-1)\n        d2_tri = d2[idx_tri]\n        dmax2 = np.max(d2_tri)\n        if dmax2 == 0:\n            return 0\n        return np.min(d2_tri) / dmax2\n\n    def slsqp_polish(pts_init, maxiter=200, ftol=1e-8):\n        \"\"\"Refines point positions using SLSQP with a slack variable to maximize min_dist^2.\"\"\"\n        # Initial normalization to set d_max^2 = 1\n        diffs = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=-1)\n        d2_tri = d2[idx_tri]\n        dmax = np.sqrt(np.max(d2_tri))\n        if dmax == 0:\n            dmax = 1.0\n        pts_init = pts_init / dmax\n        s_init = np.min(d2_tri) / (dmax**2)\n        \n        # Variables: [x1, y1, z1, ..., x14, y14, z14, s]\n        v0 = np.zeros(N * 3 + 1)\n        v0[:-1] = pts_init.flatten()\n        v0[-1] = s_init\n        \n        def obj(v):\n            # Maximize slack variable s\n            return -v[-1]\n        \n        def constr(v):\n            p = v[:-1].reshape((N, 3))\n            s = v[-1]\n            # Calculate all pairwise distances squared\n            d2 = np.sum((p[:, np.newaxis, :] - p[np.newaxis, :, :])**2, axis=-1)\n            d2_tri_vals = d2[idx_tri]\n            # Constraints: s <= d_ij^2 <= 1.0\n            # SLSQP requires constraints to be >= 0\n            return np.concatenate([d2_tri_vals - s, 1.0 - d2_tri_vals])\n        \n        try:\n            res = minimize(obj, v0, method='SLSQP', \n                           constraints={'type': 'ineq', 'fun': constr},\n                           options={'maxiter': maxiter, 'ftol': ftol})\n            pts_out = res.x[:-1].reshape((N, 3))\n        except:\n            pts_out = pts_init\n        \n        return pts_out, get_score(pts_out)\n\n    # 1. Fibonacci Sphere Initializations\n    best_pts = None\n    best_val = -1\n    phi_base = (1 + np.sqrt(5)) / 2\n    \n    # Try different golden ratio offsets as suggested\n    phi_vals = [phi_base + 0.04, phi_base, phi_base - 0.04, phi_base + 0.02, phi_base - 0.02]\n    for phi in phi_vals:\n        pts = []\n        for i in range(N):\n            z = 1 - (2 * i) / (N - 1)\n            radius = np.sqrt(max(0, 1 - z * z))\n            theta = 2 * np.pi * i / phi\n            pts.append([radius * np.cos(theta), radius * np.sin(theta), z])\n        pts = np.array(pts)\n        \n        pts_polished, val = slsqp_polish(pts)\n        if val > best_val:\n            best_val = val\n            best_pts = pts_polished\n    \n    # 2. Basin-hopping and Random Restart Loop\n    # Continue searching until nearly the time limit (60s)\n    while time.time() - start_time < 50:\n        # Strategy A: Perturb the current best solution (Basin-hopping step)\n        for scale in [0.05, 0.01]:\n            pts_perturbed = best_pts + np.random.normal(0, scale, best_pts.shape)\n            pts_polished, val = slsqp_polish(pts_perturbed, maxiter=100, ftol=1e-7)\n            if val > best_val:\n                best_val = val\n                best_pts = pts_polished\n        \n        # Strategy B: Completely random initialization\n        pts_random = np.random.normal(0, 1, (N, 3))\n        pts_polished, val = slsqp_polish(pts_random, maxiter=100, ftol=1e-7)\n        if val > best_val:\n            best_val = val\n            best_pts = pts_polished\n            \n    # 3. Final high-precision polish of the best found configuration\n    best_pts, best_val = slsqp_polish(best_pts, maxiter=400, ftol=1e-10)\n    \n    return best_pts.reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539108,
    "min_max_ratio": 0.2400508826495833,
    "min_distance": 0.4899498776911608,
    "max_distance": 1.0000000000000002,
    "eval_time": 50.29984903335571,
    "error": null
  },
  "prompt": "Perform a high-restart Basin-hopping search for 14 points. Use a Fibonacci sphere with a slightly different 'golden ratio' (e.g., (1+sqrt(5))/2 + 0.04) to see if it leads to a better basin. Use the slack-variable SLSQP polish.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a high-restart Basin-hopping approach with Fibonacci sphere initializations and SLSQP polishing.\n    \"\"\"\n    N = 14\n    start_time = time.time()\n    idx_tri = np.triu_indices(N, k=1)\n\n    def get_score(pts):\n        \"\"\"Calculates the squared ratio (min_dist / max_dist)^2.\"\"\"\n        # pts is expected to be (N, 3)\n        diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=-1)\n        d2_tri = d2[idx_tri]\n        dmax2 = np.max(d2_tri)\n        if dmax2 == 0:\n            return 0\n        return np.min(d2_tri) / dmax2\n\n    def slsqp_polish(pts_init, maxiter=200, ftol=1e-8):\n        \"\"\"Refines point positions using SLSQP with a slack variable to maximize min_dist^2.\"\"\"\n        # Initial normalization to set d_max^2 = 1\n        diffs = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=-1)\n        d2_tri = d2[idx_tri]\n        dmax = np.sqrt(np.max(d2_tri))\n        if dmax == 0:\n            dmax = 1.0\n        pts_init = pts_init / dmax\n        s_init = np.min(d2_tri) / (dmax**2)\n        \n        # Variables: [x1, y1, z1, ..., x14, y14, z14, s]\n        v0 = np.zeros(N * 3 + 1)\n        v0[:-1] = pts_init.flatten()\n        v0[-1] = s_init\n        \n        def obj(v):\n            # Maximize slack variable s\n            return -v[-1]\n        \n        def constr(v):\n            p = v[:-1].reshape((N, 3))\n            s = v[-1]\n            # Calculate all pairwise distances squared\n            d2 = np.sum((p[:, np.newaxis, :] - p[np.newaxis, :, :])**2, axis=-1)\n            d2_tri_vals = d2[idx_tri]\n            # Constraints: s <= d_ij^2 <= 1.0\n            # SLSQP requires constraints to be >= 0\n            return np.concatenate([d2_tri_vals - s, 1.0 - d2_tri_vals])\n        \n        try:\n            res = minimize(obj, v0, method='SLSQP', \n                           constraints={'type': 'ineq', 'fun': constr},\n                           options={'maxiter': maxiter, 'ftol': ftol})\n            pts_out = res.x[:-1].reshape((N, 3))\n        except:\n            pts_out = pts_init\n        \n        return pts_out, get_score(pts_out)\n\n    # 1. Fibonacci Sphere Initializations\n    best_pts = None\n    best_val = -1\n    phi_base = (1 + np.sqrt(5)) / 2\n    \n    # Try different golden ratio offsets as suggested\n    phi_vals = [phi_base + 0.04, phi_base, phi_base - 0.04, phi_base + 0.02, phi_base - 0.02]\n    for phi in phi_vals:\n        pts = []\n        for i in range(N):\n            z = 1 - (2 * i) / (N - 1)\n            radius = np.sqrt(max(0, 1 - z * z))\n            theta = 2 * np.pi * i / phi\n            pts.append([radius * np.cos(theta), radius * np.sin(theta), z])\n        pts = np.array(pts)\n        \n        pts_polished, val = slsqp_polish(pts)\n        if val > best_val:\n            best_val = val\n            best_pts = pts_polished\n    \n    # 2. Basin-hopping and Random Restart Loop\n    # Continue searching until nearly the time limit (60s)\n    while time.time() - start_time < 50:\n        # Strategy A: Perturb the current best solution (Basin-hopping step)\n        for scale in [0.05, 0.01]:\n            pts_perturbed = best_pts + np.random.normal(0, scale, best_pts.shape)\n            pts_polished, val = slsqp_polish(pts_perturbed, maxiter=100, ftol=1e-7)\n            if val > best_val:\n                best_val = val\n                best_pts = pts_polished\n        \n        # Strategy B: Completely random initialization\n        pts_random = np.random.normal(0, 1, (N, 3))\n        pts_polished, val = slsqp_polish(pts_random, maxiter=100, ftol=1e-7)\n        if val > best_val:\n            best_val = val\n            best_pts = pts_polished\n            \n    # 3. Final high-precision polish of the best found configuration\n    best_pts, best_val = slsqp_polish(best_pts, maxiter=400, ftol=1e-10)\n    \n    return best_pts.reshape((14, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:48:51.147688",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 238,
        "candidates_token_count": 1401,
        "thoughts_token_count": 20470
      },
      "response_text_len": 4090
    }
  }
}