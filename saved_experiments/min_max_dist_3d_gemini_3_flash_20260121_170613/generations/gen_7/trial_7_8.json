{
  "trial_id": "trial_7_8",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a basin-hopping approach with random restarts and SLSQP polishing with a slack variable.\n    \"\"\"\n    N = 14\n    dim = 3\n    start_time = time.time()\n\n    def get_dists_sq_and_jac_fast(x):\n        \"\"\"\n        Computes all pairwise squared distances and their gradients for a set of points.\n        \"\"\"\n        pts = x[:-1].reshape((N, dim))\n        s = x[-1]\n        \n        # pts: (N, 3)\n        # diffs: (N, N, 3) where diffs[i, j, :] = pts[i] - pts[j]\n        diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        # dists_sq_mat: (N, N)\n        dists_sq_mat = np.sum(diffs**2, axis=2)\n        \n        # Use upper triangle to get pairwise distances\n        tri_indices = np.triu_indices(N, k=1)\n        dists_sq = dists_sq_mat[tri_indices]\n        \n        num_pairs = N * (N - 1) // 2\n        i, j = tri_indices\n        pair_idx = np.arange(num_pairs)\n        \n        # Jacobian of distances with respect to coordinates\n        jac_dists_sq = np.zeros((num_pairs, N, dim))\n        # d(d_ij^2)/d(p_i) = 2*(p_i - p_j)\n        jac_dists_sq[pair_idx, i, :] = 2 * diffs[i, j, :]\n        # d(d_ij^2)/d(p_j) = -2*(p_i - p_j)\n        jac_dists_sq[pair_idx, j, :] = -2 * diffs[i, j, :]\n        jac_dists_sq = jac_dists_sq.reshape((num_pairs, N * dim))\n        \n        # jac_min: d(d_ij^2 - s) / dx\n        jac_min = np.hstack([jac_dists_sq, -np.ones((num_pairs, 1))])\n        # jac_max: d(1.0 - d_ij^2) / dx\n        jac_max = np.hstack([-jac_dists_sq, np.zeros((num_pairs, 1))])\n        \n        return dists_sq, jac_min, jac_max\n\n    def solve_with_init(pts_init):\n        \"\"\"\n        Runs a local optimization (SLSQP) starting from a given set of points.\n        \"\"\"\n        # Normalize initial points to have a diameter of 1\n        diffs = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=2)\n        d_max_sq = np.max(d2)\n        if d_max_sq < 1e-9: d_max_sq = 1.0\n        pts_init = pts_init / np.sqrt(d_max_sq)\n        \n        # Initial slack variable s (minimum squared distance)\n        diffs = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=2)\n        tri_indices = np.triu_indices(N, k=1)\n        s_init = np.min(d2[tri_indices])\n        \n        # Optimization variables: flat coordinates followed by slack variable s\n        x0 = np.concatenate([pts_init.flatten(), [s_init]])\n        \n        def objective(x):\n            return -x[-1]\n        \n        def objective_jac(x):\n            grad = np.zeros(N * dim + 1)\n            grad[-1] = -1\n            return grad\n\n        def constraint_min(x):\n            dists_sq, _, _ = get_dists_sq_and_jac_fast(x)\n            return dists_sq - x[-1]\n\n        def constraint_min_jac(x):\n            _, jac_min, _ = get_dists_sq_and_jac_fast(x)\n            return jac_min\n\n        def constraint_max(x):\n            dists_sq, _, _ = get_dists_sq_and_jac_fast(x)\n            return 1.0 - dists_sq\n\n        def constraint_max_jac(x):\n            _, _, jac_max = get_dists_sq_and_jac_fast(x)\n            return jac_max\n\n        cons = [\n            {'type': 'ineq', 'fun': constraint_min, 'jac': constraint_min_jac},\n            {'type': 'ineq', 'fun': constraint_max, 'jac': constraint_max_jac}\n        ]\n        \n        res = minimize(objective, x0, jac=objective_jac, constraints=cons, method='SLSQP', \n                       options={'maxiter': 60, 'disp': False})\n        \n        final_pts = res.x[:-1].reshape((N, dim))\n        # Recalculate final squared ratio\n        diffs = final_pts[:, np.newaxis, :] - final_pts[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=2)\n        tri_indices = np.triu_indices(N, k=1)\n        final_s = np.min(d2[tri_indices])\n        final_dmax2 = np.max(d2[tri_indices])\n        if final_dmax2 < 1e-9: final_dmax2 = 1.0\n        return final_pts, final_s / final_dmax2\n\n    best_pts = None\n    best_score = -1\n    \n    # 1. Fibonacci Sphere Initializations with different golden ratio offsets\n    phi_base = (1 + 5**0.5) / 2\n    for offset in [0.03, 0.0, 0.01, 0.05]:\n        phi = phi_base + offset\n        pts = []\n        for i in range(N):\n            z = 1 - 2 * i / (N - 1)\n            r = np.sqrt(max(0, 1 - z*z))\n            theta = 2 * np.pi * i / phi\n            pts.append([r * np.cos(theta), r * np.sin(theta), z])\n        res_pts, score = solve_with_init(np.array(pts))\n        if score > best_score:\n            best_score = score\n            best_pts = res_pts\n\n    # 2. Basin-hopping: Random restarts and perturbations\n    while time.time() - start_time < 50:\n        # Perturb the current best solution to explore new basins\n        scale = np.random.choice([0.02, 0.05, 0.1])\n        pts_perturbed = best_pts + np.random.normal(0, scale, (N, dim))\n        res_pts, score = solve_with_init(pts_perturbed)\n        if score > best_score:\n            best_score = score\n            best_pts = res_pts\n        \n        # Completely random initialization to ensure global coverage\n        pts_random = np.random.uniform(-0.5, 0.5, (N, dim))\n        res_pts, score = solve_with_init(pts_random)\n        if score > best_score:\n            best_score = score\n            best_pts = res_pts\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 1.0000159135536253,
    "min_max_ratio": 0.2400508826495147,
    "min_distance": 0.48994987769110787,
    "max_distance": 1.000000000000035,
    "eval_time": 50.260369062423706,
    "error": null
  },
  "prompt": "Perform a high-restart Basin-hopping search for 14 points. Use a Fibonacci sphere with a slightly different 'golden ratio' (e.g., (1+sqrt(5))/2 + 0.03) to see if it leads to a better basin. Use the slack-variable SLSQP polish.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a basin-hopping approach with random restarts and SLSQP polishing with a slack variable.\n    \"\"\"\n    N = 14\n    dim = 3\n    start_time = time.time()\n\n    def get_dists_sq_and_jac_fast(x):\n        \"\"\"\n        Computes all pairwise squared distances and their gradients for a set of points.\n        \"\"\"\n        pts = x[:-1].reshape((N, dim))\n        s = x[-1]\n        \n        # pts: (N, 3)\n        # diffs: (N, N, 3) where diffs[i, j, :] = pts[i] - pts[j]\n        diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        # dists_sq_mat: (N, N)\n        dists_sq_mat = np.sum(diffs**2, axis=2)\n        \n        # Use upper triangle to get pairwise distances\n        tri_indices = np.triu_indices(N, k=1)\n        dists_sq = dists_sq_mat[tri_indices]\n        \n        num_pairs = N * (N - 1) // 2\n        i, j = tri_indices\n        pair_idx = np.arange(num_pairs)\n        \n        # Jacobian of distances with respect to coordinates\n        jac_dists_sq = np.zeros((num_pairs, N, dim))\n        # d(d_ij^2)/d(p_i) = 2*(p_i - p_j)\n        jac_dists_sq[pair_idx, i, :] = 2 * diffs[i, j, :]\n        # d(d_ij^2)/d(p_j) = -2*(p_i - p_j)\n        jac_dists_sq[pair_idx, j, :] = -2 * diffs[i, j, :]\n        jac_dists_sq = jac_dists_sq.reshape((num_pairs, N * dim))\n        \n        # jac_min: d(d_ij^2 - s) / dx\n        jac_min = np.hstack([jac_dists_sq, -np.ones((num_pairs, 1))])\n        # jac_max: d(1.0 - d_ij^2) / dx\n        jac_max = np.hstack([-jac_dists_sq, np.zeros((num_pairs, 1))])\n        \n        return dists_sq, jac_min, jac_max\n\n    def solve_with_init(pts_init):\n        \"\"\"\n        Runs a local optimization (SLSQP) starting from a given set of points.\n        \"\"\"\n        # Normalize initial points to have a diameter of 1\n        diffs = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=2)\n        d_max_sq = np.max(d2)\n        if d_max_sq < 1e-9: d_max_sq = 1.0\n        pts_init = pts_init / np.sqrt(d_max_sq)\n        \n        # Initial slack variable s (minimum squared distance)\n        diffs = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=2)\n        tri_indices = np.triu_indices(N, k=1)\n        s_init = np.min(d2[tri_indices])\n        \n        # Optimization variables: flat coordinates followed by slack variable s\n        x0 = np.concatenate([pts_init.flatten(), [s_init]])\n        \n        def objective(x):\n            return -x[-1]\n        \n        def objective_jac(x):\n            grad = np.zeros(N * dim + 1)\n            grad[-1] = -1\n            return grad\n\n        def constraint_min(x):\n            dists_sq, _, _ = get_dists_sq_and_jac_fast(x)\n            return dists_sq - x[-1]\n\n        def constraint_min_jac(x):\n            _, jac_min, _ = get_dists_sq_and_jac_fast(x)\n            return jac_min\n\n        def constraint_max(x):\n            dists_sq, _, _ = get_dists_sq_and_jac_fast(x)\n            return 1.0 - dists_sq\n\n        def constraint_max_jac(x):\n            _, _, jac_max = get_dists_sq_and_jac_fast(x)\n            return jac_max\n\n        cons = [\n            {'type': 'ineq', 'fun': constraint_min, 'jac': constraint_min_jac},\n            {'type': 'ineq', 'fun': constraint_max, 'jac': constraint_max_jac}\n        ]\n        \n        res = minimize(objective, x0, jac=objective_jac, constraints=cons, method='SLSQP', \n                       options={'maxiter': 60, 'disp': False})\n        \n        final_pts = res.x[:-1].reshape((N, dim))\n        # Recalculate final squared ratio\n        diffs = final_pts[:, np.newaxis, :] - final_pts[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=2)\n        tri_indices = np.triu_indices(N, k=1)\n        final_s = np.min(d2[tri_indices])\n        final_dmax2 = np.max(d2[tri_indices])\n        if final_dmax2 < 1e-9: final_dmax2 = 1.0\n        return final_pts, final_s / final_dmax2\n\n    best_pts = None\n    best_score = -1\n    \n    # 1. Fibonacci Sphere Initializations with different golden ratio offsets\n    phi_base = (1 + 5**0.5) / 2\n    for offset in [0.03, 0.0, 0.01, 0.05]:\n        phi = phi_base + offset\n        pts = []\n        for i in range(N):\n            z = 1 - 2 * i / (N - 1)\n            r = np.sqrt(max(0, 1 - z*z))\n            theta = 2 * np.pi * i / phi\n            pts.append([r * np.cos(theta), r * np.sin(theta), z])\n        res_pts, score = solve_with_init(np.array(pts))\n        if score > best_score:\n            best_score = score\n            best_pts = res_pts\n\n    # 2. Basin-hopping: Random restarts and perturbations\n    while time.time() - start_time < 50:\n        # Perturb the current best solution to explore new basins\n        scale = np.random.choice([0.02, 0.05, 0.1])\n        pts_perturbed = best_pts + np.random.normal(0, scale, (N, dim))\n        res_pts, score = solve_with_init(pts_perturbed)\n        if score > best_score:\n            best_score = score\n            best_pts = res_pts\n        \n        # Completely random initialization to ensure global coverage\n        pts_random = np.random.uniform(-0.5, 0.5, (N, dim))\n        res_pts, score = solve_with_init(pts_random)\n        if score > best_score:\n            best_score = score\n            best_pts = res_pts\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:48:54.376496",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 238,
        "candidates_token_count": 1899,
        "thoughts_token_count": 18692
      },
      "response_text_len": 5460
    }
  }
}