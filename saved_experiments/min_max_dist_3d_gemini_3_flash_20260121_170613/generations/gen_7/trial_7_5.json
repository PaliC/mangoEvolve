{
  "trial_id": "trial_7_5",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a high-restart Basin-hopping search with SLSQP local optimization and a slack variable.\n    Initializes with a Fibonacci sphere using the specified golden ratio.\n    \"\"\"\n    N = 14\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the squared ratio of min distance to max distance.\"\"\"\n        if pts.shape[0] < 2:\n            return 0.0\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0:\n            return 0.0\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def solve_with_init(pts_init):\n        \"\"\"\n        Local optimization using SLSQP with a slack variable.\n        Maximizes s subject to d_min^2 >= s and d_max^2 <= 1.\n        \"\"\"\n        def objective(vars):\n            # Maximize the slack variable s\n            return -vars[-1]\n\n        def constraints(vars):\n            pts = vars[:-1].reshape((N, 3))\n            s = vars[-1]\n            d_sq = pdist(pts, 'sqeuclidean')\n            # Constraints: d_ij^2 - s >= 0 (min distance) and 1.0 - d_ij^2 >= 0 (max distance)\n            return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n        # Normalize the initial points so that the maximum distance is 1.0\n        dists_sq_init = pdist(pts_init, 'sqeuclidean')\n        d_max_sq_init = np.max(dists_sq_init)\n        pts_init_norm = pts_init / np.sqrt(d_max_sq_init)\n        \n        # Initial slack variable is the minimum squared distance of the normalized set\n        s_init = np.min(pdist(pts_init_norm, 'sqeuclidean'))\n        \n        # Flattened points + slack variable s\n        vars_init = np.concatenate([pts_init_norm.flatten(), [s_init]])\n        \n        # Run SLSQP\n        res = minimize(objective, vars_init, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options={'maxiter': 400, 'ftol': 1e-8})\n        return res\n\n    # 1. Fibonacci Sphere Initialization\n    # Use the golden ratio specified: (1 + sqrt(5)) / 2 + 0.0\n    phi = (1.0 + 5.0**0.5) / 2.0 + 0.0\n    indices = np.arange(N) + 0.5\n    z = 1.0 - 2.0 * indices / N\n    radius = np.sqrt(np.maximum(0, 1.0 - z * z))\n    theta = 2.0 * np.pi * indices / phi\n    pts_fib = np.stack([radius * np.cos(theta), radius * np.sin(theta), z], axis=1)\n    \n    # Polish the Fibonacci initialization\n    best_pts = pts_fib\n    best_ratio = get_ratio_sq(pts_fib)\n    \n    res = solve_with_init(pts_fib)\n    pts_out = res.x[:-1].reshape((N, 3))\n    ratio = get_ratio_sq(pts_out)\n    if ratio > best_ratio:\n        best_ratio = ratio\n        best_pts = pts_out\n    \n    # 2. High-Restart Basin-Hopping Search\n    start_time = time.time()\n    # Search for up to 50 seconds to ensure completion within the 60s limit\n    while time.time() - start_time < 50:\n        # Strategy A: Perturb the current best solution (Basin-hopping step)\n        scale = np.random.choice([0.02, 0.05, 0.1, 0.15])\n        pts_perturbed = best_pts + np.random.normal(0, scale, best_pts.shape)\n        res = solve_with_init(pts_perturbed)\n        pts_out = res.x[:-1].reshape((N, 3))\n        ratio = get_ratio_sq(pts_out)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_out\n        \n        # Strategy B: Random restart from a uniform distribution occasionally\n        if np.random.rand() < 0.25:\n            pts_rand = np.random.uniform(-0.5, 0.5, (N, 3))\n            res = solve_with_init(pts_rand)\n            pts_out = res.x[:-1].reshape((N, 3))\n            ratio = get_ratio_sq(pts_out)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_pts = pts_out\n                \n    # Return the best point configuration found\n    return best_pts.reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539164,
    "min_max_ratio": 0.2400508826495846,
    "min_distance": 0.489949877691162,
    "max_distance": 1.0,
    "eval_time": 50.27819895744324,
    "error": null
  },
  "prompt": "Perform a high-restart Basin-hopping search for 14 points. Use a Fibonacci sphere with a slightly different 'golden ratio' (e.g., (1+sqrt(5))/2 + 0.0) to see if it leads to a better basin. Use the slack-variable SLSQP polish.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a high-restart Basin-hopping search with SLSQP local optimization and a slack variable.\n    Initializes with a Fibonacci sphere using the specified golden ratio.\n    \"\"\"\n    N = 14\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the squared ratio of min distance to max distance.\"\"\"\n        if pts.shape[0] < 2:\n            return 0.0\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0:\n            return 0.0\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def solve_with_init(pts_init):\n        \"\"\"\n        Local optimization using SLSQP with a slack variable.\n        Maximizes s subject to d_min^2 >= s and d_max^2 <= 1.\n        \"\"\"\n        def objective(vars):\n            # Maximize the slack variable s\n            return -vars[-1]\n\n        def constraints(vars):\n            pts = vars[:-1].reshape((N, 3))\n            s = vars[-1]\n            d_sq = pdist(pts, 'sqeuclidean')\n            # Constraints: d_ij^2 - s >= 0 (min distance) and 1.0 - d_ij^2 >= 0 (max distance)\n            return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n        # Normalize the initial points so that the maximum distance is 1.0\n        dists_sq_init = pdist(pts_init, 'sqeuclidean')\n        d_max_sq_init = np.max(dists_sq_init)\n        pts_init_norm = pts_init / np.sqrt(d_max_sq_init)\n        \n        # Initial slack variable is the minimum squared distance of the normalized set\n        s_init = np.min(pdist(pts_init_norm, 'sqeuclidean'))\n        \n        # Flattened points + slack variable s\n        vars_init = np.concatenate([pts_init_norm.flatten(), [s_init]])\n        \n        # Run SLSQP\n        res = minimize(objective, vars_init, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options={'maxiter': 400, 'ftol': 1e-8})\n        return res\n\n    # 1. Fibonacci Sphere Initialization\n    # Use the golden ratio specified: (1 + sqrt(5)) / 2 + 0.0\n    phi = (1.0 + 5.0**0.5) / 2.0 + 0.0\n    indices = np.arange(N) + 0.5\n    z = 1.0 - 2.0 * indices / N\n    radius = np.sqrt(np.maximum(0, 1.0 - z * z))\n    theta = 2.0 * np.pi * indices / phi\n    pts_fib = np.stack([radius * np.cos(theta), radius * np.sin(theta), z], axis=1)\n    \n    # Polish the Fibonacci initialization\n    best_pts = pts_fib\n    best_ratio = get_ratio_sq(pts_fib)\n    \n    res = solve_with_init(pts_fib)\n    pts_out = res.x[:-1].reshape((N, 3))\n    ratio = get_ratio_sq(pts_out)\n    if ratio > best_ratio:\n        best_ratio = ratio\n        best_pts = pts_out\n    \n    # 2. High-Restart Basin-Hopping Search\n    start_time = time.time()\n    # Search for up to 50 seconds to ensure completion within the 60s limit\n    while time.time() - start_time < 50:\n        # Strategy A: Perturb the current best solution (Basin-hopping step)\n        scale = np.random.choice([0.02, 0.05, 0.1, 0.15])\n        pts_perturbed = best_pts + np.random.normal(0, scale, best_pts.shape)\n        res = solve_with_init(pts_perturbed)\n        pts_out = res.x[:-1].reshape((N, 3))\n        ratio = get_ratio_sq(pts_out)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_out\n        \n        # Strategy B: Random restart from a uniform distribution occasionally\n        if np.random.rand() < 0.25:\n            pts_rand = np.random.uniform(-0.5, 0.5, (N, 3))\n            res = solve_with_init(pts_rand)\n            pts_out = res.x[:-1].reshape((N, 3))\n            ratio = get_ratio_sq(pts_out)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_pts = pts_out\n                \n    # Return the best point configuration found\n    return best_pts.reshape((14, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:48:56.944491",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 237,
        "candidates_token_count": 1277,
        "thoughts_token_count": 18377
      },
      "response_text_len": 3961
    }
  }
}