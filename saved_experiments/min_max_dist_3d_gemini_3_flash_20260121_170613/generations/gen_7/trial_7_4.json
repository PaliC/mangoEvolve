{
  "trial_id": "trial_7_4",
  "generation": 7,
  "parent_id": "trial_6_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Starting from a bicapped hexagonal antiprism configuration and refining it using coordinate descent.\n    \"\"\"\n    n_pts = 14\n    \n    def get_ratio_sq(p):\n        \"\"\"Calculates the squared ratio of minimum to maximum pairwise distances.\"\"\"\n        d2 = np.sum((p[:, np.newaxis, :] - p[np.newaxis, :, :])**2, axis=2)\n        d2 = d2[np.triu_indices(n_pts, k=1)]\n        return np.min(d2) / np.max(d2)\n\n    # Initial configuration: Bicapped hexagonal antiprism (1-6-6-1 structure)\n    # This is a strong initial candidate for the 14-point Tammes problem.\n    h = 0.35\n    r = np.sqrt(1 - h**2)\n    pts = [[0, 0, 1], [0, 0, -1]]\n    for i in range(6):\n        phi = i * np.pi / 3\n        pts.append([r * np.cos(phi), r * np.sin(phi), h])\n        pts.append([r * np.cos(phi + np.pi/6), r * np.sin(phi + np.pi/6), -h])\n    pts = np.array(pts)\n\n    # Step 1: Smooth global optimization to find a high-quality starting point.\n    # The smooth objective function approximates the min-max distance ratio.\n    def smooth_obj(x):\n        p = x.reshape((n_pts, 3))\n        d2 = np.sum((p[:, np.newaxis, :] - p[np.newaxis, :, :])**2, axis=2)\n        d2 = d2[np.triu_indices(n_pts, k=1)]\n        max_d2 = np.max(d2)\n        # Using a log-sum-exp-like approach to maximize minimum distance.\n        return np.sum(np.exp(-40.0 * d2 / max_d2))\n\n    res = minimize(smooth_obj, pts.flatten(), method='L-BFGS-B', options={'maxiter': 500})\n    pts = res.x.reshape((n_pts, 3))\n\n    # Step 2: Coordinate Descent refinement.\n    # Iteratively picks one point and moves it to maximize the minimum distance \n    # while keeping the maximum pairwise distance <= 1.\n    for _ in range(25):\n        # Rescale the entire configuration so that max pairwise distance is exactly 1 before each pass.\n        d2_all = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=2)\n        pts /= np.sqrt(np.max(d2_all))\n        \n        for i in range(n_pts):\n            # Coordinates of all points except the one being optimized.\n            others = np.delete(pts, i, axis=0)\n            \n            # Precompute constant pairwise distances among the other points.\n            d2_others = np.sum((others[:, np.newaxis, :] - others[np.newaxis, :, :])**2, axis=2)\n            d2_others_tri = d2_others[np.triu_indices(n_pts - 1, k=1)]\n            d2_min_others = np.min(d2_others_tri)\n            d2_max_others = np.max(d2_others_tri)\n\n            def local_obj(x):\n                \"\"\"Objective function for moving a single point i.\"\"\"\n                # Distances from the new candidate position of point i to all other points.\n                d2_i = np.sum((others - x)**2, axis=1)\n                d2_min_i = np.min(d2_i)\n                d2_max_i = np.max(d2_i)\n                \n                # Global min and max distances if point i is at position x.\n                d2_min_all = min(d2_min_others, d2_min_i)\n                d2_max_all = max(d2_max_others, d2_max_i)\n                \n                # Constraint: maximum distance must not exceed 1.\n                if d2_max_all > 1.0000000001:\n                    return 1e10 + d2_max_all\n                \n                # Maximize global minimum distance. \n                # Tie-breaker (1e-7) encourages the point to move away even if it's not the closest pair.\n                return -d2_min_all - 1e-7 * d2_min_i\n\n            # Local refinement of point i using Nelder-Mead (direct search).\n            res_local = minimize(local_obj, pts[i], method='Nelder-Mead', options={'maxiter': 100})\n            pts[i] = res_local.x\n    \n    # Final normalization to ensure max pairwise distance is exactly 1.\n    d2_all = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=2)\n    pts /= np.sqrt(np.max(d2_all))\n    \n    return pts",
  "metrics": {
    "valid": true,
    "score": 0.9278476775013801,
    "min_max_ratio": 0.22272710956870664,
    "min_distance": 0.4719397308647648,
    "max_distance": 1.0,
    "eval_time": 0.7055850028991699,
    "error": null
  },
  "prompt": "Take the coordinates from trial_6_0. \n        Apply a 'Coordinate Descent' refinement. Iteratively pick one point and \n        move it slightly to maximize the minimum distance to all other points while \n        keeping the maximum distance between any two points <= 1. \n        Repeat this for all 14 points for many iterations.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Starting from a bicapped hexagonal antiprism configuration and refining it using coordinate descent.\n    \"\"\"\n    n_pts = 14\n    \n    def get_ratio_sq(p):\n        \"\"\"Calculates the squared ratio of minimum to maximum pairwise distances.\"\"\"\n        d2 = np.sum((p[:, np.newaxis, :] - p[np.newaxis, :, :])**2, axis=2)\n        d2 = d2[np.triu_indices(n_pts, k=1)]\n        return np.min(d2) / np.max(d2)\n\n    # Initial configuration: Bicapped hexagonal antiprism (1-6-6-1 structure)\n    # This is a strong initial candidate for the 14-point Tammes problem.\n    h = 0.35\n    r = np.sqrt(1 - h**2)\n    pts = [[0, 0, 1], [0, 0, -1]]\n    for i in range(6):\n        phi = i * np.pi / 3\n        pts.append([r * np.cos(phi), r * np.sin(phi), h])\n        pts.append([r * np.cos(phi + np.pi/6), r * np.sin(phi + np.pi/6), -h])\n    pts = np.array(pts)\n\n    # Step 1: Smooth global optimization to find a high-quality starting point.\n    # The smooth objective function approximates the min-max distance ratio.\n    def smooth_obj(x):\n        p = x.reshape((n_pts, 3))\n        d2 = np.sum((p[:, np.newaxis, :] - p[np.newaxis, :, :])**2, axis=2)\n        d2 = d2[np.triu_indices(n_pts, k=1)]\n        max_d2 = np.max(d2)\n        # Using a log-sum-exp-like approach to maximize minimum distance.\n        return np.sum(np.exp(-40.0 * d2 / max_d2))\n\n    res = minimize(smooth_obj, pts.flatten(), method='L-BFGS-B', options={'maxiter': 500})\n    pts = res.x.reshape((n_pts, 3))\n\n    # Step 2: Coordinate Descent refinement.\n    # Iteratively picks one point and moves it to maximize the minimum distance \n    # while keeping the maximum pairwise distance <= 1.\n    for _ in range(25):\n        # Rescale the entire configuration so that max pairwise distance is exactly 1 before each pass.\n        d2_all = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=2)\n        pts /= np.sqrt(np.max(d2_all))\n        \n        for i in range(n_pts):\n            # Coordinates of all points except the one being optimized.\n            others = np.delete(pts, i, axis=0)\n            \n            # Precompute constant pairwise distances among the other points.\n            d2_others = np.sum((others[:, np.newaxis, :] - others[np.newaxis, :, :])**2, axis=2)\n            d2_others_tri = d2_others[np.triu_indices(n_pts - 1, k=1)]\n            d2_min_others = np.min(d2_others_tri)\n            d2_max_others = np.max(d2_others_tri)\n\n            def local_obj(x):\n                \"\"\"Objective function for moving a single point i.\"\"\"\n                # Distances from the new candidate position of point i to all other points.\n                d2_i = np.sum((others - x)**2, axis=1)\n                d2_min_i = np.min(d2_i)\n                d2_max_i = np.max(d2_i)\n                \n                # Global min and max distances if point i is at position x.\n                d2_min_all = min(d2_min_others, d2_min_i)\n                d2_max_all = max(d2_max_others, d2_max_i)\n                \n                # Constraint: maximum distance must not exceed 1.\n                if d2_max_all > 1.0000000001:\n                    return 1e10 + d2_max_all\n                \n                # Maximize global minimum distance. \n                # Tie-breaker (1e-7) encourages the point to move away even if it's not the closest pair.\n                return -d2_min_all - 1e-7 * d2_min_i\n\n            # Local refinement of point i using Nelder-Mead (direct search).\n            res_local = minimize(local_obj, pts[i], method='Nelder-Mead', options={'maxiter': 100})\n            pts[i] = res_local.x\n    \n    # Final normalization to ensure max pairwise distance is exactly 1.\n    d2_all = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=2)\n    pts /= np.sqrt(np.max(d2_all))\n    \n    return pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:48:58.614015",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 245,
        "candidates_token_count": 1309,
        "thoughts_token_count": 27513
      },
      "response_text_len": 3992
    }
  }
}