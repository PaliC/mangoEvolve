{
  "trial_id": "trial_6_5",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    n = 14\n    dim = 3\n    iu = np.triu_indices(n, k=1)\n    num_pairs = n * (n - 1) // 2\n\n    def get_ratio_sq(pts):\n        diff = pts[:, None, :] - pts[None, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        tri_dists_sq = dists_sq[iu]\n        return np.min(tri_dists_sq) / np.max(tri_dists_sq)\n\n    def solve(init_pts):\n        # Normalize initial points\n        init_pts = init_pts.copy()\n        init_pts -= np.mean(init_pts, axis=0)\n        init_pts *= np.sqrt(n / np.sum(init_pts**2))\n        \n        # Initial slack variables\n        diff = init_pts[:, None, :] - init_pts[None, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        tri_dists_sq = dists_sq[iu]\n        s_init = np.min(tri_dists_sq)\n        eps_init = np.max(tri_dists_sq) - 1\n        \n        # Initial guess vector: [pts_ravel, s, eps]\n        x0 = np.concatenate([init_pts.ravel(), [s_init, eps_init]])\n        \n        def objective(x):\n            return x[43] - x[42] # eps - s\n        \n        def jac_obj(x):\n            j = np.zeros(44)\n            j[42] = -1\n            j[43] = 1\n            return j\n        \n        def constraints_ineq(x):\n            pts = x[:42].reshape((14, 3))\n            s, eps = x[42], x[43]\n            diff = pts[:, None, :] - pts[None, :, :]\n            dists_sq = np.sum(diff**2, axis=-1)\n            tri_dists_sq = dists_sq[iu]\n            return np.concatenate([\n                tri_dists_sq - s,\n                (1 + eps) - tri_dists_sq\n            ])\n        \n        def jac_ineq(x):\n            pts = x[:42].reshape((14, 3))\n            jac = np.zeros((2 * num_pairs, 44))\n            diffs = pts[iu[0]] - pts[iu[1]] # (91, 3)\n            \n            # Constraints: tri_dists_sq - s >= 0\n            for idx, (i, j) in enumerate(zip(iu[0], iu[1])):\n                jac[idx, i*3:i*3+3] = 2 * diffs[idx]\n                jac[idx, j*3:j*3+3] = -2 * diffs[idx]\n            jac[:num_pairs, 42] = -1\n            \n            # Constraints: (1 + eps) - tri_dists_sq >= 0\n            jac[num_pairs:, :42] = -jac[:num_pairs, :42]\n            jac[num_pairs:, 43] = 1\n            return jac\n        \n        def constraints_eq(x):\n            pts = x[:42].reshape((14, 3))\n            return np.concatenate([\n                [np.sum(pts**2) - n],\n                np.sum(pts, axis=0)\n            ])\n        \n        def jac_eq(x):\n            pts = x[:42].reshape((14, 3))\n            jac = np.zeros((4, 44))\n            jac[0, :42] = 2 * pts.ravel()\n            for d in range(3):\n                jac[1+d, d:42:3] = 1.0\n            return jac\n\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=jac_obj,\n            constraints=[\n                {'type': 'ineq', 'fun': constraints_ineq, 'jac': jac_ineq},\n                {'type': 'eq', 'fun': constraints_eq, 'jac': jac_eq}\n            ],\n            bounds=[(None, None)]*42 + [(0, None), (-1, None)],\n            options={'maxiter': 300, 'ftol': 1e-8}\n        )\n        return res.x[:42].reshape((14, 3))\n\n    # Pre-defined initializations\n    def fibonacci_sphere(n):\n        phi = np.pi * (3. - np.sqrt(5.))\n        pts = []\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            radius = np.sqrt(1 - y * y)\n            theta = phi * i\n            pts.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n        return np.array(pts)\n\n    def heptagonal_prism():\n        pts = []\n        for i in range(7):\n            theta = 2 * np.pi * i / 7\n            pts.append([np.cos(theta), np.sin(theta), 0.5])\n            pts.append([np.cos(theta), np.sin(theta), -0.5])\n        return np.array(pts)\n\n    def structured_cube():\n        corners = np.array([[x, y, z] for x in [-1, 1] for y in [-1, 1] for z in [-1, 1]])\n        faces = np.array([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]])\n        return np.vstack([corners, faces])\n\n    start_time = time.time()\n    best_pts = None\n    best_ratio = -1.0\n    \n    # Try initializations\n    init_list = [fibonacci_sphere(14), heptagonal_prism(), structured_cube()]\n    \n    for init_pts in init_list:\n        if time.time() - start_time > 55: break\n        pts = solve(init_pts + np.random.normal(0, 0.05, init_pts.shape))\n        ratio = get_ratio_sq(pts)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts\n            \n    # Random restarts until time is up\n    while time.time() - start_time < 50:\n        pts = solve(np.random.normal(0, 1, (14, 3)))\n        ratio = get_ratio_sq(pts)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9613508754069949,
    "min_max_ratio": 0.23076945381525443,
    "min_distance": 0.9535360100897076,
    "max_distance": 1.9849425322145702,
    "eval_time": 50.2319598197937,
    "error": null
  },
  "prompt": "Use the 'SLSQP' optimizer but instead of just one slack variable for d_min, add 'epsilon' slack to d_max as well (d_ij^2 <= 1 + epsilon). Try to minimize epsilon - slack. This might allow the optimizer to move through a more flexible space before tightening the d_max <= 1 constraint.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    n = 14\n    dim = 3\n    iu = np.triu_indices(n, k=1)\n    num_pairs = n * (n - 1) // 2\n\n    def get_ratio_sq(pts):\n        diff = pts[:, None, :] - pts[None, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        tri_dists_sq = dists_sq[iu]\n        return np.min(tri_dists_sq) / np.max(tri_dists_sq)\n\n    def solve(init_pts):\n        # Normalize initial points\n        init_pts = init_pts.copy()\n        init_pts -= np.mean(init_pts, axis=0)\n        init_pts *= np.sqrt(n / np.sum(init_pts**2))\n        \n        # Initial slack variables\n        diff = init_pts[:, None, :] - init_pts[None, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        tri_dists_sq = dists_sq[iu]\n        s_init = np.min(tri_dists_sq)\n        eps_init = np.max(tri_dists_sq) - 1\n        \n        # Initial guess vector: [pts_ravel, s, eps]\n        x0 = np.concatenate([init_pts.ravel(), [s_init, eps_init]])\n        \n        def objective(x):\n            return x[43] - x[42] # eps - s\n        \n        def jac_obj(x):\n            j = np.zeros(44)\n            j[42] = -1\n            j[43] = 1\n            return j\n        \n        def constraints_ineq(x):\n            pts = x[:42].reshape((14, 3))\n            s, eps = x[42], x[43]\n            diff = pts[:, None, :] - pts[None, :, :]\n            dists_sq = np.sum(diff**2, axis=-1)\n            tri_dists_sq = dists_sq[iu]\n            return np.concatenate([\n                tri_dists_sq - s,\n                (1 + eps) - tri_dists_sq\n            ])\n        \n        def jac_ineq(x):\n            pts = x[:42].reshape((14, 3))\n            jac = np.zeros((2 * num_pairs, 44))\n            diffs = pts[iu[0]] - pts[iu[1]] # (91, 3)\n            \n            # Constraints: tri_dists_sq - s >= 0\n            for idx, (i, j) in enumerate(zip(iu[0], iu[1])):\n                jac[idx, i*3:i*3+3] = 2 * diffs[idx]\n                jac[idx, j*3:j*3+3] = -2 * diffs[idx]\n            jac[:num_pairs, 42] = -1\n            \n            # Constraints: (1 + eps) - tri_dists_sq >= 0\n            jac[num_pairs:, :42] = -jac[:num_pairs, :42]\n            jac[num_pairs:, 43] = 1\n            return jac\n        \n        def constraints_eq(x):\n            pts = x[:42].reshape((14, 3))\n            return np.concatenate([\n                [np.sum(pts**2) - n],\n                np.sum(pts, axis=0)\n            ])\n        \n        def jac_eq(x):\n            pts = x[:42].reshape((14, 3))\n            jac = np.zeros((4, 44))\n            jac[0, :42] = 2 * pts.ravel()\n            for d in range(3):\n                jac[1+d, d:42:3] = 1.0\n            return jac\n\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=jac_obj,\n            constraints=[\n                {'type': 'ineq', 'fun': constraints_ineq, 'jac': jac_ineq},\n                {'type': 'eq', 'fun': constraints_eq, 'jac': jac_eq}\n            ],\n            bounds=[(None, None)]*42 + [(0, None), (-1, None)],\n            options={'maxiter': 300, 'ftol': 1e-8}\n        )\n        return res.x[:42].reshape((14, 3))\n\n    # Pre-defined initializations\n    def fibonacci_sphere(n):\n        phi = np.pi * (3. - np.sqrt(5.))\n        pts = []\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            radius = np.sqrt(1 - y * y)\n            theta = phi * i\n            pts.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n        return np.array(pts)\n\n    def heptagonal_prism():\n        pts = []\n        for i in range(7):\n            theta = 2 * np.pi * i / 7\n            pts.append([np.cos(theta), np.sin(theta), 0.5])\n            pts.append([np.cos(theta), np.sin(theta), -0.5])\n        return np.array(pts)\n\n    def structured_cube():\n        corners = np.array([[x, y, z] for x in [-1, 1] for y in [-1, 1] for z in [-1, 1]])\n        faces = np.array([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]])\n        return np.vstack([corners, faces])\n\n    start_time = time.time()\n    best_pts = None\n    best_ratio = -1.0\n    \n    # Try initializations\n    init_list = [fibonacci_sphere(14), heptagonal_prism(), structured_cube()]\n    \n    for init_pts in init_list:\n        if time.time() - start_time > 55: break\n        pts = solve(init_pts + np.random.normal(0, 0.05, init_pts.shape))\n        ratio = get_ratio_sq(pts)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts\n            \n    # Random restarts until time is up\n    while time.time() - start_time < 50:\n        pts = solve(np.random.normal(0, 1, (14, 3)))\n        ratio = get_ratio_sq(pts)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:43:48.668694",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 245,
        "candidates_token_count": 1720,
        "thoughts_token_count": 22109
      },
      "response_text_len": 4796
    }
  }
}