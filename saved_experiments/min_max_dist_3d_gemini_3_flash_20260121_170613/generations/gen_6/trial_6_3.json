{
  "trial_id": "trial_6_3",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The strategy uses a force-directed approach to find a good starting basin, followed by SLSQP\n    refinement to maximize the ratio directly.\n    \"\"\"\n    n = 14\n    dim = 3\n    idx = np.triu_indices(n, k=1)\n\n    def run_force_directed(n_pts, steps=1000, p=12):\n        \"\"\"\n        Standard force-directed approach with a 1/r^p repulsive potential.\n        Normalizes points to a unit sphere at each iteration.\n        \"\"\"\n        pts = np.random.normal(0, 1, (n_pts, dim))\n        pts /= np.linalg.norm(pts, axis=1, keepdims=True)\n        lr = 0.05\n        for _ in range(steps):\n            # Calculate pairwise vectors and squared distances\n            diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            # Avoid division by zero on the diagonal\n            np.fill_diagonal(d2, 1e-10)\n            \n            # Repulsive force: F_i = sum_j (x_i - x_j) / r_ij^(p+2)\n            dist_p = d2**((p + 2) / 2)\n            force = np.sum(diff / dist_p[:, :, np.newaxis], axis=1)\n            \n            # Update positions and project back onto the sphere\n            pts += lr * force\n            pts /= np.linalg.norm(pts, axis=1, keepdims=True)\n            \n            # Decay learning rate for convergence\n            lr *= 0.998\n        return pts\n\n    # We try different initial configurations to find the best local basin.\n    # 1. Standard approach: all 14 points start on a sphere (Tammes-like).\n    # 2. Heuristic: 13 points on a sphere and 1 at the center (often optimal for n=14).\n    inits = []\n    # Two 14-point sphere-based inits\n    for _ in range(2):\n        inits.append(run_force_directed(14, steps=1000, p=12))\n    # One 13+1 init (13 points on sphere, 1 at origin)\n    pts13 = run_force_directed(13, steps=1000, p=12)\n    inits.append(np.concatenate([pts13, [[0, 0, 0]]]))\n\n    best_overall_pts = None\n    best_overall_ratio = -1\n\n    for pts_init in inits:\n        # Scale the initial configuration so that the maximum pairwise distance is 1.0.\n        # This fixes the scale for the SLSQP optimizer.\n        d2_init_raw = np.sum((pts_init[:, None, :] - pts_init[None, :, :])**2, axis=-1)\n        max_d2_init = np.max(d2_init_raw)\n        pts_init_scaled = pts_init / np.sqrt(max_d2_init)\n        min_d2_init = np.min(d2_init_raw[idx]) / max_d2_init\n        \n        # Optimization variables: flat coordinates of 14 points + the minimum squared distance t.\n        # Total variables: 14 * 3 + 1 = 43.\n        x0 = np.concatenate([pts_init_scaled.flatten(), [min_d2_init]])\n\n        def objective(x):\n            # We want to maximize t, which is the minimum squared distance.\n            return -x[-1]\n\n        def constraint(x):\n            # Extract points and t\n            pts_curr = x[:-1].reshape((n, dim))\n            t = x[-1]\n            # Calculate all pairwise squared distances\n            diff = pts_curr[:, np.newaxis, :] - pts_curr[None, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            pairwise_d2 = d2[idx]\n            \n            # Constraints: \n            # 1. Every pairwise distance squared must be >= t.\n            # 2. Every pairwise distance squared must be <= 1.0 (to fix max distance).\n            # These 182 inequality constraints (91 + 91) are smooth and handleable by SLSQP.\n            c_min = pairwise_d2 - t\n            c_max = 1.0 - pairwise_d2\n            return np.concatenate([c_min, c_max])\n\n        # Run SLSQP refinement\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            constraints={'type': 'ineq', 'fun': constraint},\n            options={'maxiter': 500, 'ftol': 1e-9}\n        )\n        \n        # Calculate the resulting ratio for this initialization\n        pts_final = res.x[:-1].reshape((n, dim))\n        d2_final = np.sum((pts_final[:, None, :] - pts_final[None, :, :])**2, axis=-1)\n        # Ratio squared = min(d^2) / max(d^2)\n        ratio = np.min(d2_final[idx]) / np.max(d2_final[idx])\n        \n        if ratio > best_overall_ratio:\n            best_overall_ratio = ratio\n            best_overall_pts = pts_final\n            \n    return best_overall_pts",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.27335286140441895,
    "error": "Invalid points shape: (), expected (14, 3)"
  },
  "prompt": "Try a force-directed approach (repulsive potential 1/r^p with p=12 or 24) to find a good basin, but normalize the points to a unit sphere at each iteration. After 1000 steps of gradient descent on this potential, use SLSQP to maximize the (min/max)^2 ratio directly.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The strategy uses a force-directed approach to find a good starting basin, followed by SLSQP\n    refinement to maximize the ratio directly.\n    \"\"\"\n    n = 14\n    dim = 3\n    idx = np.triu_indices(n, k=1)\n\n    def run_force_directed(n_pts, steps=1000, p=12):\n        \"\"\"\n        Standard force-directed approach with a 1/r^p repulsive potential.\n        Normalizes points to a unit sphere at each iteration.\n        \"\"\"\n        pts = np.random.normal(0, 1, (n_pts, dim))\n        pts /= np.linalg.norm(pts, axis=1, keepdims=True)\n        lr = 0.05\n        for _ in range(steps):\n            # Calculate pairwise vectors and squared distances\n            diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            # Avoid division by zero on the diagonal\n            np.fill_diagonal(d2, 1e-10)\n            \n            # Repulsive force: F_i = sum_j (x_i - x_j) / r_ij^(p+2)\n            dist_p = d2**((p + 2) / 2)\n            force = np.sum(diff / dist_p[:, :, np.newaxis], axis=1)\n            \n            # Update positions and project back onto the sphere\n            pts += lr * force\n            pts /= np.linalg.norm(pts, axis=1, keepdims=True)\n            \n            # Decay learning rate for convergence\n            lr *= 0.998\n        return pts\n\n    # We try different initial configurations to find the best local basin.\n    # 1. Standard approach: all 14 points start on a sphere (Tammes-like).\n    # 2. Heuristic: 13 points on a sphere and 1 at the center (often optimal for n=14).\n    inits = []\n    # Two 14-point sphere-based inits\n    for _ in range(2):\n        inits.append(run_force_directed(14, steps=1000, p=12))\n    # One 13+1 init (13 points on sphere, 1 at origin)\n    pts13 = run_force_directed(13, steps=1000, p=12)\n    inits.append(np.concatenate([pts13, [[0, 0, 0]]]))\n\n    best_overall_pts = None\n    best_overall_ratio = -1\n\n    for pts_init in inits:\n        # Scale the initial configuration so that the maximum pairwise distance is 1.0.\n        # This fixes the scale for the SLSQP optimizer.\n        d2_init_raw = np.sum((pts_init[:, None, :] - pts_init[None, :, :])**2, axis=-1)\n        max_d2_init = np.max(d2_init_raw)\n        pts_init_scaled = pts_init / np.sqrt(max_d2_init)\n        min_d2_init = np.min(d2_init_raw[idx]) / max_d2_init\n        \n        # Optimization variables: flat coordinates of 14 points + the minimum squared distance t.\n        # Total variables: 14 * 3 + 1 = 43.\n        x0 = np.concatenate([pts_init_scaled.flatten(), [min_d2_init]])\n\n        def objective(x):\n            # We want to maximize t, which is the minimum squared distance.\n            return -x[-1]\n\n        def constraint(x):\n            # Extract points and t\n            pts_curr = x[:-1].reshape((n, dim))\n            t = x[-1]\n            # Calculate all pairwise squared distances\n            diff = pts_curr[:, np.newaxis, :] - pts_curr[None, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            pairwise_d2 = d2[idx]\n            \n            # Constraints: \n            # 1. Every pairwise distance squared must be >= t.\n            # 2. Every pairwise distance squared must be <= 1.0 (to fix max distance).\n            # These 182 inequality constraints (91 + 91) are smooth and handleable by SLSQP.\n            c_min = pairwise_d2 - t\n            c_max = 1.0 - pairwise_d2\n            return np.concatenate([c_min, c_max])\n\n        # Run SLSQP refinement\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            constraints={'type': 'ineq', 'fun': constraint},\n            options={'maxiter': 500, 'ftol': 1e-9}\n        )\n        \n        # Calculate the resulting ratio for this initialization\n        pts_final = res.x[:-1].reshape((n, dim))\n        d2_final = np.sum((pts_final[:, None, :] - pts_final[None, :, :])**2, axis=-1)\n        # Ratio squared = min(d^2) / max(d^2)\n        ratio = np.min(d2_final[idx]) / np.max(d2_final[idx])\n        \n        if ratio > best_overall_ratio:\n            best_overall_ratio = ratio\n            best_overall_pts = pts_final\n            \n    return best_overall_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:43:28.105892",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 245,
        "candidates_token_count": 1376,
        "thoughts_token_count": 25408
      },
      "response_text_len": 4374
    }
  }
}