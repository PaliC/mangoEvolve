{
  "trial_id": "trial_6_1",
  "generation": 6,
  "parent_id": "trial_3_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio \n    (min pairwise distance / max pairwise distance)^2.\n    \"\"\"\n    n_points = 14\n    # Precompute indices for all pairwise combinations (14*13/2 = 91)\n    idx_i, idx_j = np.triu_indices(n_points, k=1)\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates (min_dist / max_dist)^2 for a given set of points.\"\"\"\n        diffs = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        return np.min(d2) / np.max(d2)\n\n    def solve_for_init(init_points):\n        \"\"\"Optimizes points from a given initialization using SLSQP.\"\"\"\n        # Variables: 14 points (42 coordinates) + 1 slack variable s\n        x0 = np.zeros(n_points * 3 + 1)\n        x0[:n_points * 3] = init_points.flatten()\n        \n        diffs_init = init_points[idx_i] - init_points[idx_j]\n        d2_init = np.sum(diffs_init**2, axis=1)\n        x0[-1] = np.min(d2_init)\n\n        # Objective: Maximize s (the minimum squared distance)\n        def obj(v):\n            return -v[-1]\n\n        def obj_grad(v):\n            grad = np.zeros(n_points * 3 + 1)\n            grad[-1] = -1\n            return grad\n\n        # Constraints: \n        # 1. d_ij^2 - s >= 0 (minimum distance constraint)\n        # 2. 1.0 - d_ij^2 >= 0 (maximum distance constraint, diameter <= 1)\n        def cons_func(v):\n            pts = v[:-1].reshape((n_points, 3))\n            s = v[-1]\n            diffs = pts[idx_i] - pts[idx_j]\n            d2 = np.sum(diffs**2, axis=1)\n            return np.concatenate([d2 - s, 1.0 - d2])\n\n        def cons_jac(v):\n            pts = v[:-1].reshape((n_points, 3))\n            diffs = pts[idx_i] - pts[idx_j]\n            jac_min = np.zeros((91, 43))\n            rows = np.arange(91)\n            for d in range(3):\n                jac_min[rows, 3*idx_i + d] = 2 * diffs[:, d]\n                jac_min[rows, 3*idx_j + d] = -2 * diffs[:, d]\n            jac_min[:, 42] = -1\n            jac_max = -jac_min.copy()\n            jac_max[:, 42] = 0\n            return np.vstack([jac_min, jac_max])\n\n        # Bounds for s and coordinates\n        bounds = [(-1.0, 1.0)] * (n_points * 3) + [(0.0, 1.0)]\n        \n        res = minimize(obj, x0, jac=obj_grad, \n                       constraints={'type': 'ineq', 'fun': cons_func, 'jac': cons_jac},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 200})\n        \n        final_pts = res.x[:-1].reshape((n_points, 3))\n        # Ensure exact normalization of the max distance to 1.0\n        diffs = final_pts[idx_i] - final_pts[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        final_pts /= np.sqrt(np.max(d2))\n        return final_pts\n\n    start_time = time.time()\n    best_points = None\n    best_ratio = -1\n    \n    # List of initial point configurations\n    inits = []\n    \n    # 1. Fibonacci spirals with various metallic ratios and phases\n    phi = (1 + 5**0.5) / 2\n    ratios = [phi, 1 + 2**0.5, (3 + 13**0.5) / 2, np.sqrt(2), np.sqrt(3), np.pi]\n    phases = [0, np.pi/3]\n    for r in ratios:\n        for p in phases:\n            pts = []\n            for i in range(n_points):\n                z = 1 - (2 * i) / (n_points - 1)\n                radius = np.sqrt(max(0, 1 - z * z))\n                theta = 2 * np.pi * r * i + p\n                pts.append([radius * np.cos(theta), radius * np.sin(theta), z])\n            inits.append(np.array(pts))\n    \n    # 2. Symmetric Layer-based initialization (2-6-6)\n    pts266 = [[0.0, 0.0, 0.5], [0.0, 0.0, -0.5]]\n    for i in range(6):\n        theta = 2 * np.pi * i / 6\n        pts266.append([0.4 * np.cos(theta), 0.4 * np.sin(theta), 0.2])\n        pts266.append([0.4 * np.cos(theta + np.pi/6), 0.4 * np.sin(theta + np.pi/6), -0.2])\n    inits.append(np.array(pts266))\n    \n    # 3. Symmetric Layer-based initialization (2-4-4-4)\n    pts2444 = [[0.0, 0.0, 0.5], [0.0, 0.0, -0.5]]\n    for i in range(4):\n        theta = 2 * np.pi * i / 4\n        pts2444.append([0.45 * np.cos(theta), 0.45 * np.sin(theta), 0.3])\n        pts2444.append([0.5 * np.cos(theta + np.pi/8), 0.5 * np.sin(theta + np.pi/8), 0.0])\n        pts2444.append([0.45 * np.cos(theta + np.pi/4), 0.45 * np.sin(theta + np.pi/4), -0.3])\n    inits.append(np.array(pts2444))\n\n    # 4. Random initialization\n    np.random.seed(42)\n    inits.append(np.random.rand(n_points, 3) - 0.5)\n\n    # Solve for each initialization until time limit\n    for init_pts in inits:\n        if time.time() - start_time > 55:\n            break\n        # Initial scaling\n        diffs = init_pts[idx_i] - init_pts[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        init_pts /= np.sqrt(np.max(d2))\n        \n        # SLSQP Optimization\n        pts = solve_for_init(init_pts)\n        ratio = get_ratio_sq(pts)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_points = pts\n            \n    return best_points",
  "metrics": {
    "valid": true,
    "score": 1.0000159134503421,
    "min_max_ratio": 0.24005088262472193,
    "min_distance": 0.48994987766578935,
    "max_distance": 1.0,
    "eval_time": 0.4064011573791504,
    "error": null
  },
  "prompt": "The current best solutions use a Fibonacci spiral for initialization. Experiment with varying the 'golden ratio' in the Fibonacci spiral to other metallic ratios or adding a small phase shift to the theta calculation. Then apply the SLSQP polishing with analytical Jacobians as seen in trial_3_6.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio \n    (min pairwise distance / max pairwise distance)^2.\n    \"\"\"\n    n_points = 14\n    # Precompute indices for all pairwise combinations (14*13/2 = 91)\n    idx_i, idx_j = np.triu_indices(n_points, k=1)\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates (min_dist / max_dist)^2 for a given set of points.\"\"\"\n        diffs = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        return np.min(d2) / np.max(d2)\n\n    def solve_for_init(init_points):\n        \"\"\"Optimizes points from a given initialization using SLSQP.\"\"\"\n        # Variables: 14 points (42 coordinates) + 1 slack variable s\n        x0 = np.zeros(n_points * 3 + 1)\n        x0[:n_points * 3] = init_points.flatten()\n        \n        diffs_init = init_points[idx_i] - init_points[idx_j]\n        d2_init = np.sum(diffs_init**2, axis=1)\n        x0[-1] = np.min(d2_init)\n\n        # Objective: Maximize s (the minimum squared distance)\n        def obj(v):\n            return -v[-1]\n\n        def obj_grad(v):\n            grad = np.zeros(n_points * 3 + 1)\n            grad[-1] = -1\n            return grad\n\n        # Constraints: \n        # 1. d_ij^2 - s >= 0 (minimum distance constraint)\n        # 2. 1.0 - d_ij^2 >= 0 (maximum distance constraint, diameter <= 1)\n        def cons_func(v):\n            pts = v[:-1].reshape((n_points, 3))\n            s = v[-1]\n            diffs = pts[idx_i] - pts[idx_j]\n            d2 = np.sum(diffs**2, axis=1)\n            return np.concatenate([d2 - s, 1.0 - d2])\n\n        def cons_jac(v):\n            pts = v[:-1].reshape((n_points, 3))\n            diffs = pts[idx_i] - pts[idx_j]\n            jac_min = np.zeros((91, 43))\n            rows = np.arange(91)\n            for d in range(3):\n                jac_min[rows, 3*idx_i + d] = 2 * diffs[:, d]\n                jac_min[rows, 3*idx_j + d] = -2 * diffs[:, d]\n            jac_min[:, 42] = -1\n            jac_max = -jac_min.copy()\n            jac_max[:, 42] = 0\n            return np.vstack([jac_min, jac_max])\n\n        # Bounds for s and coordinates\n        bounds = [(-1.0, 1.0)] * (n_points * 3) + [(0.0, 1.0)]\n        \n        res = minimize(obj, x0, jac=obj_grad, \n                       constraints={'type': 'ineq', 'fun': cons_func, 'jac': cons_jac},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 200})\n        \n        final_pts = res.x[:-1].reshape((n_points, 3))\n        # Ensure exact normalization of the max distance to 1.0\n        diffs = final_pts[idx_i] - final_pts[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        final_pts /= np.sqrt(np.max(d2))\n        return final_pts\n\n    start_time = time.time()\n    best_points = None\n    best_ratio = -1\n    \n    # List of initial point configurations\n    inits = []\n    \n    # 1. Fibonacci spirals with various metallic ratios and phases\n    phi = (1 + 5**0.5) / 2\n    ratios = [phi, 1 + 2**0.5, (3 + 13**0.5) / 2, np.sqrt(2), np.sqrt(3), np.pi]\n    phases = [0, np.pi/3]\n    for r in ratios:\n        for p in phases:\n            pts = []\n            for i in range(n_points):\n                z = 1 - (2 * i) / (n_points - 1)\n                radius = np.sqrt(max(0, 1 - z * z))\n                theta = 2 * np.pi * r * i + p\n                pts.append([radius * np.cos(theta), radius * np.sin(theta), z])\n            inits.append(np.array(pts))\n    \n    # 2. Symmetric Layer-based initialization (2-6-6)\n    pts266 = [[0.0, 0.0, 0.5], [0.0, 0.0, -0.5]]\n    for i in range(6):\n        theta = 2 * np.pi * i / 6\n        pts266.append([0.4 * np.cos(theta), 0.4 * np.sin(theta), 0.2])\n        pts266.append([0.4 * np.cos(theta + np.pi/6), 0.4 * np.sin(theta + np.pi/6), -0.2])\n    inits.append(np.array(pts266))\n    \n    # 3. Symmetric Layer-based initialization (2-4-4-4)\n    pts2444 = [[0.0, 0.0, 0.5], [0.0, 0.0, -0.5]]\n    for i in range(4):\n        theta = 2 * np.pi * i / 4\n        pts2444.append([0.45 * np.cos(theta), 0.45 * np.sin(theta), 0.3])\n        pts2444.append([0.5 * np.cos(theta + np.pi/8), 0.5 * np.sin(theta + np.pi/8), 0.0])\n        pts2444.append([0.45 * np.cos(theta + np.pi/4), 0.45 * np.sin(theta + np.pi/4), -0.3])\n    inits.append(np.array(pts2444))\n\n    # 4. Random initialization\n    np.random.seed(42)\n    inits.append(np.random.rand(n_points, 3) - 0.5)\n\n    # Solve for each initialization until time limit\n    for init_pts in inits:\n        if time.time() - start_time > 55:\n            break\n        # Initial scaling\n        diffs = init_pts[idx_i] - init_pts[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        init_pts /= np.sqrt(np.max(d2))\n        \n        # SLSQP Optimization\n        pts = solve_for_init(init_pts)\n        ratio = get_ratio_sq(pts)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_points = pts\n            \n    return best_points\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:42:56.849762",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 229,
        "candidates_token_count": 1863,
        "thoughts_token_count": 23403
      },
      "response_text_len": 4944
    }
  }
}