{
  "trial_id": "trial_6_2",
  "generation": 6,
  "parent_id": "trial_4_8",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, basinhopping\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a Basin-Hopping approach with trust-constr local minimization and slack-variable formulation.\n    \"\"\"\n    N = 14\n    D = 3\n    # Use a fixed random seed for consistent behavior\n    np.random.seed(42)\n\n    def get_dist_sq_matrix(pts):\n        \"\"\"Computes the squared pairwise distances between points.\"\"\"\n        dists = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        return np.sum(dists**2, axis=-1)\n\n    def objective(x):\n        \"\"\"The objective is to maximize the slack variable s, so we minimize -s.\"\"\"\n        return -x[-1]\n\n    def grad_objective(x):\n        \"\"\"Gradient of the objective function.\"\"\"\n        g = np.zeros(N * D + 1)\n        g[-1] = -1\n        return g\n\n    def constraints_func(x):\n        \"\"\"\n        Constraints for the slack variable formulation:\n        1. d_ij^2 >= s (min distance squared is at least s)\n        2. d_ij^2 <= 1 (max distance squared is at most 1)\n        Together, these make s <= (d_min / d_max)^2.\n        \"\"\"\n        pts = x[:-1].reshape((N, D))\n        s = x[-1]\n        indices = np.triu_indices(N, k=1)\n        dists_sq = get_dist_sq_matrix(pts)[indices]\n        \n        # We return a flat array where each pair (i, j) provides two constraints:\n        # dists_sq[k] - s >= 0\n        # 1.0 - dists_sq[k] >= 0\n        res = np.empty(2 * len(dists_sq))\n        res[0::2] = dists_sq - s\n        res[1::2] = 1.0 - dists_sq\n        return res\n\n    def jacobian_func(x):\n        \"\"\"Analytical Jacobian for the constraints.\"\"\"\n        pts = x[:-1].reshape((N, D))\n        indices = np.triu_indices(N, k=1)\n        num_pairs = len(indices[0])\n        jac = np.zeros((2 * num_pairs, N * D + 1))\n        \n        for k, (i, j) in enumerate(zip(*indices)):\n            diff = 2 * (pts[i] - pts[j])\n            # Row index for d_ij^2 - s >= 0\n            jac[2*k, i*D : i*D+D] = diff\n            jac[2*k, j*D : j*D+D] = -diff\n            jac[2*k, -1] = -1\n            \n            # Row index for 1.0 - d_ij^2 >= 0\n            jac[2*k+1, i*D : i*D+D] = -diff\n            jac[2*k+1, j*D : j*D+D] = diff\n            # jac[2*k+1, -1] is 0 by initialization\n        return jac\n\n    # Initial points: A Face-Centered Cubic (FCC) like configuration as a heuristic start\n    c = 0.5 / np.sqrt(3)\n    pts = np.array([[x, y, z] for x in [-c, c] for y in [-c, c] for z in [-c, c]])\n    f = 0.5\n    face_centers = np.array([[f, 0, 0], [-f, 0, 0], [0, f, 0], [0, -f, 0], [0, 0, f], [0, 0, -f]])\n    pts = np.vstack([pts, face_centers])[:N]\n    \n    # Initial normalization to ensure d_max^2 = 1 and set initial s\n    d2 = get_dist_sq_matrix(pts)\n    indices = np.triu_indices(N, k=1)\n    d_max2 = np.max(d2[indices])\n    pts /= np.sqrt(d_max2)\n    s = np.min(d2[indices]) / d_max2\n    x0 = np.concatenate([pts.ravel(), [s]])\n\n    # Define NonlinearConstraint for trust-constr\n    cons = NonlinearConstraint(constraints_func, 0, np.inf, jac=jacobian_func)\n    \n    # Custom perturbation step for basin-hopping\n    class MyTakeStep:\n        def __init__(self, stepsize=0.05):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            pts = x[:-1].reshape((N, D))\n            if np.random.random() < 0.2:\n                # Swap two points' positions randomly\n                i, j = np.random.choice(N, 2, replace=False)\n                pts[i], pts[j] = pts[j].copy(), pts[i].copy()\n            else:\n                # Apply Gaussian noise\n                pts += np.random.normal(0, self.stepsize, size=pts.shape)\n            \n            # Re-normalize to d_max^2 = 1 and update s for the new state\n            d2 = get_dist_sq_matrix(pts)\n            indices = np.triu_indices(N, k=1)\n            d_max2 = np.max(d2[indices])\n            if d_max2 > 1e-7:\n                pts /= np.sqrt(d_max2)\n                s = np.min(d2[indices]) / d_max2\n            else:\n                pts = np.random.rand(N, D)\n                s = 0.01\n            return np.concatenate([pts.ravel(), [s]])\n\n    # Local minimizer configuration using trust-constr\n    minimizer_kwargs = {\n        \"method\": \"trust-constr\",\n        \"jac\": grad_objective,\n        \"constraints\": [cons],\n        \"options\": {\"maxiter\": 20, \"verbose\": 0}\n    }\n    \n    # Basin-hopping to explore the solution space within the time limit\n    res = basinhopping(objective, x0, \n                       minimizer_kwargs=minimizer_kwargs,\n                       take_step=MyTakeStep(0.05),\n                       niter=3,\n                       seed=42)\n\n    # Reshape the best found coordinates to (14, 3)\n    final_pts = res.x[:-1].reshape((N, D))\n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.217683289088301,
    "min_max_ratio": 0.05225423413313911,
    "min_distance": 1.097884502521368e-09,
    "max_distance": 4.802815585636827e-09,
    "eval_time": 0.4868338108062744,
    "error": null
  },
  "prompt": "Implement a 'Basin-Hopping' approach where the local minimization step uses the 'trust-constr' method with the analytical Jacobian for the slack-variable formulation. For the perturbation, use a mixture of Gaussian noise and 'swapping' coordinates of two points. Use trial_4_8 as a reference for the objective function.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, basinhopping\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a Basin-Hopping approach with trust-constr local minimization and slack-variable formulation.\n    \"\"\"\n    N = 14\n    D = 3\n    # Use a fixed random seed for consistent behavior\n    np.random.seed(42)\n\n    def get_dist_sq_matrix(pts):\n        \"\"\"Computes the squared pairwise distances between points.\"\"\"\n        dists = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        return np.sum(dists**2, axis=-1)\n\n    def objective(x):\n        \"\"\"The objective is to maximize the slack variable s, so we minimize -s.\"\"\"\n        return -x[-1]\n\n    def grad_objective(x):\n        \"\"\"Gradient of the objective function.\"\"\"\n        g = np.zeros(N * D + 1)\n        g[-1] = -1\n        return g\n\n    def constraints_func(x):\n        \"\"\"\n        Constraints for the slack variable formulation:\n        1. d_ij^2 >= s (min distance squared is at least s)\n        2. d_ij^2 <= 1 (max distance squared is at most 1)\n        Together, these make s <= (d_min / d_max)^2.\n        \"\"\"\n        pts = x[:-1].reshape((N, D))\n        s = x[-1]\n        indices = np.triu_indices(N, k=1)\n        dists_sq = get_dist_sq_matrix(pts)[indices]\n        \n        # We return a flat array where each pair (i, j) provides two constraints:\n        # dists_sq[k] - s >= 0\n        # 1.0 - dists_sq[k] >= 0\n        res = np.empty(2 * len(dists_sq))\n        res[0::2] = dists_sq - s\n        res[1::2] = 1.0 - dists_sq\n        return res\n\n    def jacobian_func(x):\n        \"\"\"Analytical Jacobian for the constraints.\"\"\"\n        pts = x[:-1].reshape((N, D))\n        indices = np.triu_indices(N, k=1)\n        num_pairs = len(indices[0])\n        jac = np.zeros((2 * num_pairs, N * D + 1))\n        \n        for k, (i, j) in enumerate(zip(*indices)):\n            diff = 2 * (pts[i] - pts[j])\n            # Row index for d_ij^2 - s >= 0\n            jac[2*k, i*D : i*D+D] = diff\n            jac[2*k, j*D : j*D+D] = -diff\n            jac[2*k, -1] = -1\n            \n            # Row index for 1.0 - d_ij^2 >= 0\n            jac[2*k+1, i*D : i*D+D] = -diff\n            jac[2*k+1, j*D : j*D+D] = diff\n            # jac[2*k+1, -1] is 0 by initialization\n        return jac\n\n    # Initial points: A Face-Centered Cubic (FCC) like configuration as a heuristic start\n    c = 0.5 / np.sqrt(3)\n    pts = np.array([[x, y, z] for x in [-c, c] for y in [-c, c] for z in [-c, c]])\n    f = 0.5\n    face_centers = np.array([[f, 0, 0], [-f, 0, 0], [0, f, 0], [0, -f, 0], [0, 0, f], [0, 0, -f]])\n    pts = np.vstack([pts, face_centers])[:N]\n    \n    # Initial normalization to ensure d_max^2 = 1 and set initial s\n    d2 = get_dist_sq_matrix(pts)\n    indices = np.triu_indices(N, k=1)\n    d_max2 = np.max(d2[indices])\n    pts /= np.sqrt(d_max2)\n    s = np.min(d2[indices]) / d_max2\n    x0 = np.concatenate([pts.ravel(), [s]])\n\n    # Define NonlinearConstraint for trust-constr\n    cons = NonlinearConstraint(constraints_func, 0, np.inf, jac=jacobian_func)\n    \n    # Custom perturbation step for basin-hopping\n    class MyTakeStep:\n        def __init__(self, stepsize=0.05):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            pts = x[:-1].reshape((N, D))\n            if np.random.random() < 0.2:\n                # Swap two points' positions randomly\n                i, j = np.random.choice(N, 2, replace=False)\n                pts[i], pts[j] = pts[j].copy(), pts[i].copy()\n            else:\n                # Apply Gaussian noise\n                pts += np.random.normal(0, self.stepsize, size=pts.shape)\n            \n            # Re-normalize to d_max^2 = 1 and update s for the new state\n            d2 = get_dist_sq_matrix(pts)\n            indices = np.triu_indices(N, k=1)\n            d_max2 = np.max(d2[indices])\n            if d_max2 > 1e-7:\n                pts /= np.sqrt(d_max2)\n                s = np.min(d2[indices]) / d_max2\n            else:\n                pts = np.random.rand(N, D)\n                s = 0.01\n            return np.concatenate([pts.ravel(), [s]])\n\n    # Local minimizer configuration using trust-constr\n    minimizer_kwargs = {\n        \"method\": \"trust-constr\",\n        \"jac\": grad_objective,\n        \"constraints\": [cons],\n        \"options\": {\"maxiter\": 20, \"verbose\": 0}\n    }\n    \n    # Basin-hopping to explore the solution space within the time limit\n    res = basinhopping(objective, x0, \n                       minimizer_kwargs=minimizer_kwargs,\n                       take_step=MyTakeStep(0.05),\n                       niter=3,\n                       seed=42)\n\n    # Reshape the best found coordinates to (14, 3)\n    final_pts = res.x[:-1].reshape((N, D))\n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:42:39.201232",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 240,
        "candidates_token_count": 1622,
        "thoughts_token_count": 18487
      },
      "response_text_len": 4853
    }
  }
}