{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nfrom scipy.special import logsumexp\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize (min distance / max distance)^2.\n    Uses a combination of smooth optimization and local refinement with multiple restarts.\n    \"\"\"\n    N = 14\n    \n    def get_score_sq(pts):\n        \"\"\"Calculates the squared ratio of min distance to max distance.\"\"\"\n        if pts is None or len(pts) == 0:\n            return 0\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        min_d = np.min(dists)\n        max_d = np.max(dists)\n        if max_d == 0:\n            return 0\n        return (min_d / max_d)**2\n\n    def smooth_objective(x, k):\n        \"\"\"\n        A smooth objective function to minimize the spread between max and min distances.\n        Uses the log-sum-exp trick to approximate max(dists^2) and -min(dists^2).\n        \"\"\"\n        pts = x.reshape((N, 3))\n        dsq = pdist(pts)**2\n        # Minimizing [smooth_max(dsq) - smooth_min(dsq)]\n        # This is equivalent to minimizing [logsumexp(k*dsq) + logsumexp(-k*dsq)] / k\n        return (logsumexp(k * dsq) + logsumexp(-k * dsq)) / k\n\n    def final_objective(x):\n        \"\"\"The actual objective to maximize: the ratio min_dist / max_dist.\"\"\"\n        pts = x.reshape((N, 3))\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        max_d = np.max(dists)\n        if max_d == 0:\n            return 0\n        # Minimize the negative ratio to maximize the ratio\n        return -np.min(dists) / max_d\n\n    best_pts = None\n    best_score = -1\n    start_time = time.time()\n    \n    # Predefined interesting starting configurations\n    inits = []\n    \n    # 1. Rhombic Dodecahedron-like structure (8 cube vertices + 6 dual octahedron vertices)\n    pts_rd = np.array([\n        [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],\n        [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],\n        [1.7, 0, 0], [-1.7, 0, 0], [0, 1.7, 0], [0, -1.7, 0], [0, 0, 1.7], [0, 0, -1.7]\n    ], dtype=float)\n    inits.append(pts_rd.flatten())\n    \n    # 2. Heptagonal prism-like structure (7 points on two parallel rings)\n    theta = np.linspace(0, 2 * np.pi, 7, endpoint=False)\n    pts_hp = np.vstack([\n        np.column_stack([np.cos(theta), np.sin(theta), np.full(7, 0.5)]),\n        np.column_stack([np.cos(theta + np.pi/7), np.sin(theta + np.pi/7), np.full(7, -0.5)])\n    ])\n    inits.append(pts_hp.flatten())\n\n    # Main optimization loop with multiple restarts\n    while time.time() - start_time < 55:\n        if inits:\n            x0 = inits.pop()\n        else:\n            # Random initialization: either on a sphere or within a cube\n            if np.random.rand() > 0.5:\n                pts = np.random.randn(N, 3)\n                pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n            else:\n                pts = np.random.uniform(-1, 1, (N, 3))\n            x0 = pts.flatten()\n        \n        try:\n            # Step 1: Smooth optimization to get into a good basin\n            # L-BFGS-B is efficient for high-dimensional smooth problems\n            curr_x = x0\n            for k in [10, 30]:\n                res = minimize(smooth_objective, curr_x, args=(k,), method='L-BFGS-B', \n                               options={'maxiter': 100, 'ftol': 1e-6})\n                curr_x = res.x\n            \n            # Step 2: Local refinement with the actual (non-smooth) ratio objective\n            # SLSQP handles non-smooth objectives and constraints reasonably well\n            res = minimize(final_objective, curr_x, method='SLSQP', \n                           options={'maxiter': 100, 'ftol': 1e-7})\n            \n            # Evaluate and track the best found configuration\n            pts_result = res.x.reshape((N, 3))\n            score = get_score_sq(pts_result)\n            if score > best_score:\n                best_score = score\n                best_pts = pts_result.copy()\n        except Exception:\n            # In case of numerical issues with a specific restart, continue to the next\n            continue\n            \n    # Ensure the final output is exactly 14 points in 3D\n    if best_pts is None:\n        # Fallback to a basic configuration if no optimization succeeded\n        best_pts = np.random.randn(14, 3)\n        \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9304889676907147,
    "min_max_ratio": 0.22336114352025663,
    "min_distance": 0.3476163093226419,
    "max_distance": 0.7355231259146963,
    "eval_time": 55.28597712516785,
    "error": null
  },
  "prompt": "Maximize (min_dist / max_dist)^2 for 14 points in 3D. Implement a Simulated Annealing algorithm that moves points individually and uses a cooling schedule. Start with points on a sphere and allow them to move both on the surface and slightly radially.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nfrom scipy.special import logsumexp\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize (min distance / max distance)^2.\n    Uses a combination of smooth optimization and local refinement with multiple restarts.\n    \"\"\"\n    N = 14\n    \n    def get_score_sq(pts):\n        \"\"\"Calculates the squared ratio of min distance to max distance.\"\"\"\n        if pts is None or len(pts) == 0:\n            return 0\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        min_d = np.min(dists)\n        max_d = np.max(dists)\n        if max_d == 0:\n            return 0\n        return (min_d / max_d)**2\n\n    def smooth_objective(x, k):\n        \"\"\"\n        A smooth objective function to minimize the spread between max and min distances.\n        Uses the log-sum-exp trick to approximate max(dists^2) and -min(dists^2).\n        \"\"\"\n        pts = x.reshape((N, 3))\n        dsq = pdist(pts)**2\n        # Minimizing [smooth_max(dsq) - smooth_min(dsq)]\n        # This is equivalent to minimizing [logsumexp(k*dsq) + logsumexp(-k*dsq)] / k\n        return (logsumexp(k * dsq) + logsumexp(-k * dsq)) / k\n\n    def final_objective(x):\n        \"\"\"The actual objective to maximize: the ratio min_dist / max_dist.\"\"\"\n        pts = x.reshape((N, 3))\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        max_d = np.max(dists)\n        if max_d == 0:\n            return 0\n        # Minimize the negative ratio to maximize the ratio\n        return -np.min(dists) / max_d\n\n    best_pts = None\n    best_score = -1\n    start_time = time.time()\n    \n    # Predefined interesting starting configurations\n    inits = []\n    \n    # 1. Rhombic Dodecahedron-like structure (8 cube vertices + 6 dual octahedron vertices)\n    pts_rd = np.array([\n        [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],\n        [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],\n        [1.7, 0, 0], [-1.7, 0, 0], [0, 1.7, 0], [0, -1.7, 0], [0, 0, 1.7], [0, 0, -1.7]\n    ], dtype=float)\n    inits.append(pts_rd.flatten())\n    \n    # 2. Heptagonal prism-like structure (7 points on two parallel rings)\n    theta = np.linspace(0, 2 * np.pi, 7, endpoint=False)\n    pts_hp = np.vstack([\n        np.column_stack([np.cos(theta), np.sin(theta), np.full(7, 0.5)]),\n        np.column_stack([np.cos(theta + np.pi/7), np.sin(theta + np.pi/7), np.full(7, -0.5)])\n    ])\n    inits.append(pts_hp.flatten())\n\n    # Main optimization loop with multiple restarts\n    while time.time() - start_time < 55:\n        if inits:\n            x0 = inits.pop()\n        else:\n            # Random initialization: either on a sphere or within a cube\n            if np.random.rand() > 0.5:\n                pts = np.random.randn(N, 3)\n                pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n            else:\n                pts = np.random.uniform(-1, 1, (N, 3))\n            x0 = pts.flatten()\n        \n        try:\n            # Step 1: Smooth optimization to get into a good basin\n            # L-BFGS-B is efficient for high-dimensional smooth problems\n            curr_x = x0\n            for k in [10, 30]:\n                res = minimize(smooth_objective, curr_x, args=(k,), method='L-BFGS-B', \n                               options={'maxiter': 100, 'ftol': 1e-6})\n                curr_x = res.x\n            \n            # Step 2: Local refinement with the actual (non-smooth) ratio objective\n            # SLSQP handles non-smooth objectives and constraints reasonably well\n            res = minimize(final_objective, curr_x, method='SLSQP', \n                           options={'maxiter': 100, 'ftol': 1e-7})\n            \n            # Evaluate and track the best found configuration\n            pts_result = res.x.reshape((N, 3))\n            score = get_score_sq(pts_result)\n            if score > best_score:\n                best_score = score\n                best_pts = pts_result.copy()\n        except Exception:\n            # In case of numerical issues with a specific restart, continue to the next\n            continue\n            \n    # Ensure the final output is exactly 14 points in 3D\n    if best_pts is None:\n        # Fallback to a basic configuration if no optimization succeeded\n        best_pts = np.random.randn(14, 3)\n        \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:10:41.117624",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 228,
        "candidates_token_count": 1410,
        "thoughts_token_count": 23143
      },
      "response_text_len": 4401
    }
  }
}