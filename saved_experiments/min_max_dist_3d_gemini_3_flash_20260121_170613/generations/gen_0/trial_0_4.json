{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximizes the squared ratio (min pairwise distance / max pairwise distance)^2\n    for 14 points in 3D space.\n    \"\"\"\n    n = 14\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the actual squared ratio (min_dist / max_dist)^2.\"\"\"\n        pts = pts.reshape((n, 3))\n        # Pairwise squared distances\n        dist_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        # Off-diagonal elements only\n        np.fill_diagonal(dist_sq, np.inf)\n        min_d2 = np.min(dist_sq)\n        np.fill_diagonal(dist_sq, -np.inf)\n        max_d2 = np.max(dist_sq)\n        return min_d2 / max_d2\n\n    # Pre-calculate indices for the upper triangle of the distance matrix\n    triu_idx = np.triu_indices(n, 1)\n\n    def objective(coords):\n        \"\"\"Smooth approximation of - (min_dist / max_dist)^2.\"\"\"\n        pts = coords.reshape((n, 3))\n        d2 = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        off_diag = d2[triu_idx]\n        \n        # Use log-sum-exp trick for smooth min and max approximations\n        k = 60.0 # Sharpness parameter\n        \n        x_min = np.min(off_diag)\n        # Smooth min: x_min - 1/k * log(sum(exp(-k * (x - x_min))))\n        min_d2 = x_min - (1.0/k) * np.log(np.sum(np.exp(-k * (off_diag - x_min))))\n        \n        x_max = np.max(off_diag)\n        # Smooth max: x_max + 1/k * log(sum(exp(k * (x - x_max))))\n        max_d2 = x_max + (1.0/k) * np.log(np.sum(np.exp(k * (off_diag - x_max))))\n        \n        return -min_d2 / max_d2\n\n    best_pts = None\n    best_ratio = -1\n    \n    # Selection of initial configurations to start the optimization\n    seeds = []\n    \n    # 1. Fibonacci sphere (uniform distribution on a sphere)\n    phi = np.pi * (3. - np.sqrt(5.))\n    pts_fib = []\n    for i in range(n):\n        y = 1 - (i / float(n - 1)) * 2\n        r = np.sqrt(max(0, 1 - y * y))\n        theta = phi * i\n        pts_fib.append([np.cos(theta) * r, y, np.sin(theta) * r])\n    seeds.append(np.array(pts_fib))\n    \n    # 2. Rhombic Dodecahedron (known structure with 14 vertices)\n    a, b = 1.0, np.sqrt(3)\n    pts_rd = []\n    for i in [-a, a]:\n        for j in [-a, a]:\n            for k in [-a, a]:\n                pts_rd.append([i, j, k])\n    pts_rd.extend([[b, 0, 0], [-b, 0, 0], [0, b, 0], [0, -b, 0], [0, 0, b], [0, 0, -b]])\n    seeds.append(np.array(pts_rd))\n    \n    # 3. Random seeds\n    for _ in range(6):\n        seeds.append(np.random.normal(size=(n, 3)))\n        \n    for pts in seeds:\n        # Pre-process: center and normalize the scale\n        pts = pts - np.mean(pts, axis=0)\n        norms = np.linalg.norm(pts, axis=1)\n        pts /= np.max(norms) if np.max(norms) > 0 else 1.0\n        \n        # Phase 1: Force-directed relaxation (repulsive force 1/r^7)\n        # This helps in quickly reaching a near-optimal configuration.\n        dt = 0.05\n        for _ in range(400):\n            diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=2)\n            np.fill_diagonal(d2, 1.0)\n            # Magnitude proportional to 1/r^8 (force vector uses diff/r, so total 1/r^7)\n            force_mag = 1.0 / (d2**4)\n            np.fill_diagonal(force_mag, 0)\n            force_vec = np.sum(force_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            pts += force_vec * dt\n            pts -= np.mean(pts, axis=0)\n            norms = np.linalg.norm(pts, axis=1)\n            pts /= np.max(norms) if np.max(norms) > 0 else 1.0\n            dt *= 0.985 # Decay the step size\n            \n        # Phase 2: Refine using Scipy's L-BFGS-B optimizer on the smooth objective\n        res = minimize(objective, pts.flatten(), method='L-BFGS-B', options={'maxiter': 600})\n        refined_pts = res.x.reshape((n, 3))\n        \n        # Update the overall best found configuration\n        ratio = get_ratio_sq(refined_pts)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = refined_pts\n            \n    return best_pts.reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 0.8803474972615929,
    "min_max_ratio": 0.21132483082690892,
    "min_distance": 124.54929437463265,
    "max_distance": 270.9355581085458,
    "eval_time": 1.2540841102600098,
    "error": null
  },
  "prompt": "Maximize (min_dist / max_dist)^2 for 14 points in 3D. Use a force-directed approach where points repel each other with a force proportional to 1/r^2. Include a 'containment' force to keep them from flying to infinity, or constrain them to a unit sphere.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximizes the squared ratio (min pairwise distance / max pairwise distance)^2\n    for 14 points in 3D space.\n    \"\"\"\n    n = 14\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the actual squared ratio (min_dist / max_dist)^2.\"\"\"\n        pts = pts.reshape((n, 3))\n        # Pairwise squared distances\n        dist_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        # Off-diagonal elements only\n        np.fill_diagonal(dist_sq, np.inf)\n        min_d2 = np.min(dist_sq)\n        np.fill_diagonal(dist_sq, -np.inf)\n        max_d2 = np.max(dist_sq)\n        return min_d2 / max_d2\n\n    # Pre-calculate indices for the upper triangle of the distance matrix\n    triu_idx = np.triu_indices(n, 1)\n\n    def objective(coords):\n        \"\"\"Smooth approximation of - (min_dist / max_dist)^2.\"\"\"\n        pts = coords.reshape((n, 3))\n        d2 = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        off_diag = d2[triu_idx]\n        \n        # Use log-sum-exp trick for smooth min and max approximations\n        k = 60.0 # Sharpness parameter\n        \n        x_min = np.min(off_diag)\n        # Smooth min: x_min - 1/k * log(sum(exp(-k * (x - x_min))))\n        min_d2 = x_min - (1.0/k) * np.log(np.sum(np.exp(-k * (off_diag - x_min))))\n        \n        x_max = np.max(off_diag)\n        # Smooth max: x_max + 1/k * log(sum(exp(k * (x - x_max))))\n        max_d2 = x_max + (1.0/k) * np.log(np.sum(np.exp(k * (off_diag - x_max))))\n        \n        return -min_d2 / max_d2\n\n    best_pts = None\n    best_ratio = -1\n    \n    # Selection of initial configurations to start the optimization\n    seeds = []\n    \n    # 1. Fibonacci sphere (uniform distribution on a sphere)\n    phi = np.pi * (3. - np.sqrt(5.))\n    pts_fib = []\n    for i in range(n):\n        y = 1 - (i / float(n - 1)) * 2\n        r = np.sqrt(max(0, 1 - y * y))\n        theta = phi * i\n        pts_fib.append([np.cos(theta) * r, y, np.sin(theta) * r])\n    seeds.append(np.array(pts_fib))\n    \n    # 2. Rhombic Dodecahedron (known structure with 14 vertices)\n    a, b = 1.0, np.sqrt(3)\n    pts_rd = []\n    for i in [-a, a]:\n        for j in [-a, a]:\n            for k in [-a, a]:\n                pts_rd.append([i, j, k])\n    pts_rd.extend([[b, 0, 0], [-b, 0, 0], [0, b, 0], [0, -b, 0], [0, 0, b], [0, 0, -b]])\n    seeds.append(np.array(pts_rd))\n    \n    # 3. Random seeds\n    for _ in range(6):\n        seeds.append(np.random.normal(size=(n, 3)))\n        \n    for pts in seeds:\n        # Pre-process: center and normalize the scale\n        pts = pts - np.mean(pts, axis=0)\n        norms = np.linalg.norm(pts, axis=1)\n        pts /= np.max(norms) if np.max(norms) > 0 else 1.0\n        \n        # Phase 1: Force-directed relaxation (repulsive force 1/r^7)\n        # This helps in quickly reaching a near-optimal configuration.\n        dt = 0.05\n        for _ in range(400):\n            diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=2)\n            np.fill_diagonal(d2, 1.0)\n            # Magnitude proportional to 1/r^8 (force vector uses diff/r, so total 1/r^7)\n            force_mag = 1.0 / (d2**4)\n            np.fill_diagonal(force_mag, 0)\n            force_vec = np.sum(force_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            pts += force_vec * dt\n            pts -= np.mean(pts, axis=0)\n            norms = np.linalg.norm(pts, axis=1)\n            pts /= np.max(norms) if np.max(norms) > 0 else 1.0\n            dt *= 0.985 # Decay the step size\n            \n        # Phase 2: Refine using Scipy's L-BFGS-B optimizer on the smooth objective\n        res = minimize(objective, pts.flatten(), method='L-BFGS-B', options={'maxiter': 600})\n        refined_pts = res.x.reshape((n, 3))\n        \n        # Update the overall best found configuration\n        ratio = get_ratio_sq(refined_pts)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = refined_pts\n            \n    return best_pts.reshape((14, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:10:09.572911",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 239,
        "candidates_token_count": 1465,
        "thoughts_token_count": 25970
      },
      "response_text_len": 4097
    }
  }
}