{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping, minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the position of 14 points in 3D to maximize the squared ratio \n    (min_dist / max_dist)^2.\n    \n    The problem is approximated by minimizing the Riesz potential energy (1/r^k) \n    for points constrained to the surface of a sphere. This is known as the \n    Thomson problem (for k=1) or generalized Tammes problem (as k -> infinity).\n    \n    Algorithm:\n    1. Define objective: E = sum(1/r_ij^k) + Penalty * sum((|x_i|^2 - 1)^2).\n    2. Use Basin-Hopping with L-BFGS-B to find the global minimum for k=12.\n    3. Refine the result with a higher k (e.g., k=60) to approximate the hard-sphere limit.\n    \"\"\"\n    \n    N = 14\n    K_SEARCH = 12.0   # Power for global search (smoother landscape)\n    K_REFINE = 60.0   # Power for refinement (closer to max-min)\n    PENALTY = 1e5     # Penalty weight to enforce spherical constraint\n    \n    # Initialize random points on the unit sphere\n    rng = np.random.default_rng(42)\n    x0 = rng.standard_normal((N, 3))\n    x0 /= np.linalg.norm(x0, axis=1, keepdims=True)\n    x0 = x0.flatten()\n    \n    def energy_and_grad(flat_x, k):\n        \"\"\"\n        Computes the Riesz potential energy and its gradient, plus a penalty \n        term to keep points on the unit sphere.\n        \"\"\"\n        X = flat_x.reshape((N, 3))\n        \n        # 1. Compute pairwise differences and squared distances\n        # diff[i, j] = X[i] - X[j]\n        diff = X[:, np.newaxis, :] - X[np.newaxis, :, :]\n        \n        # d2[i, j] = ||X[i] - X[j]||^2\n        d2 = np.sum(diff**2, axis=2)\n        \n        # Avoid division by zero on diagonal (self-interaction)\n        np.fill_diagonal(d2, np.inf)\n        \n        # 2. Potential Energy: E_pot = 0.5 * sum_{i!=j} (1 / r_{ij}^k)\n        # r_{ij}^k = (r_{ij}^2)^(k/2)\n        inv_d2 = 1.0 / d2\n        pot_terms = inv_d2**(k / 2.0)\n        E_pot = 0.5 * np.sum(pot_terms)\n        \n        # 3. Constraint Penalty: E_pen = sum_i (r_i^2 - 1)^2\n        r2 = np.sum(X**2, axis=1)\n        deviations = r2 - 1.0\n        E_pen = np.sum(deviations**2)\n        \n        total_energy = E_pot + PENALTY * E_pen\n        \n        # 4. Gradients\n        \n        # Gradient of Potential Energy\n        # dE_pot/dx_i = sum_j [ -k * (x_i - x_j) / r_{ij}^{k+2} ]\n        # factor = -k * (1/r^2)^((k+2)/2)\n        grad_factor = -k * (inv_d2**((k + 2.0) / 2.0))\n        np.fill_diagonal(grad_factor, 0.0)\n        \n        # Sum over j: (N, N, 1) * (N, N, 3) -> sum axis 1 -> (N, 3)\n        grad_pot = np.sum(grad_factor[:, :, np.newaxis] * diff, axis=1)\n        \n        # Gradient of Penalty\n        # dE_pen/dx_i = 4 * (r_i^2 - 1) * x_i\n        grad_pen = 4.0 * deviations[:, np.newaxis] * X\n        \n        total_grad = grad_pot + PENALTY * grad_pen\n        \n        return total_energy, total_grad.flatten()\n\n    # Objective functions for the two phases\n    obj_search = lambda x: energy_and_grad(x, K_SEARCH)\n    obj_refine = lambda x: energy_and_grad(x, K_REFINE)\n\n    # Custom step taker for Basin Hopping\n    # Perturbs points and projects them back to the sphere to explore valid space\n    class SphereStep:\n        def __init__(self, stepsize=0.2):\n            self.stepsize = stepsize\n            self.rng = np.random.default_rng()\n            \n        def __call__(self, x):\n            X = x.reshape((N, 3))\n            perturbation = self.rng.uniform(-self.stepsize, self.stepsize, X.shape)\n            X_new = X + perturbation\n            # Project to sphere\n            X_new /= np.linalg.norm(X_new, axis=1, keepdims=True)\n            return X_new.flatten()\n\n    # L-BFGS-B configuration\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"jac\": True,\n        \"options\": {\"maxiter\": 100, \"ftol\": 1e-6}\n    }\n    \n    # Phase 1: Global Search with Basin Hopping (k=12)\n    res = basinhopping(\n        obj_search, \n        x0, \n        niter=100, \n        T=0.5, \n        stepsize=0.25,\n        minimizer_kwargs=minimizer_kwargs,\n        take_step=SphereStep(0.25),\n        seed=1\n    )\n    \n    # Phase 2: Refinement with higher k (k=60)\n    # This sharpens the potential to better approximate the max-min distance objective\n    res_final = minimize(\n        obj_refine, \n        res.x, \n        method=\"L-BFGS-B\", \n        jac=True,\n        options={\"maxiter\": 500, \"ftol\": 1e-9}\n    )\n    \n    # Final projection to ensure points are exactly on the sphere\n    final_points = res_final.x.reshape((N, 3))\n    final_points /= np.linalg.norm(final_points, axis=1, keepdims=True)\n    \n    return final_points",
  "metrics": {
    "valid": true,
    "score": 0.897990579051888,
    "min_max_ratio": 0.21556000078672255,
    "min_distance": 0.9285687928976285,
    "max_distance": 1.9999999999959046,
    "eval_time": 0.83138108253479,
    "error": null
  },
  "prompt": "Maximize the ratio (min_dist / max_dist)^2 for 14 points in 3D. Use the Basin-Hopping algorithm from scipy.optimize, using L-BFGS-B as the local minimizer. For the objective, minimize the potential energy of the points where the potential is 1/r^k for a large k (e.g., k=12), which approximates the max-min distance problem.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the position of 14 points in 3D to maximize the squared ratio \n    (min_dist / max_dist)^2.\n    \n    The problem is approximated by minimizing the Riesz potential energy (1/r^k) \n    for points constrained to the surface of a sphere. This is known as the \n    Thomson problem (for k=1) or generalized Tammes problem (as k -> infinity).\n    \n    Algorithm:\n    1. Define objective: E = sum(1/r_ij^k) + Penalty * sum((|x_i|^2 - 1)^2).\n    2. Use Basin-Hopping with L-BFGS-B to find the global minimum for k=12.\n    3. Refine the result with a higher k (e.g., k=60) to approximate the hard-sphere limit.\n    \"\"\"\n    \n    N = 14\n    K_SEARCH = 12.0   # Power for global search (smoother landscape)\n    K_REFINE = 60.0   # Power for refinement (closer to max-min)\n    PENALTY = 1e5     # Penalty weight to enforce spherical constraint\n    \n    # Initialize random points on the unit sphere\n    rng = np.random.default_rng(42)\n    x0 = rng.standard_normal((N, 3))\n    x0 /= np.linalg.norm(x0, axis=1, keepdims=True)\n    x0 = x0.flatten()\n    \n    def energy_and_grad(flat_x, k):\n        \"\"\"\n        Computes the Riesz potential energy and its gradient, plus a penalty \n        term to keep points on the unit sphere.\n        \"\"\"\n        X = flat_x.reshape((N, 3))\n        \n        # 1. Compute pairwise differences and squared distances\n        # diff[i, j] = X[i] - X[j]\n        diff = X[:, np.newaxis, :] - X[np.newaxis, :, :]\n        \n        # d2[i, j] = ||X[i] - X[j]||^2\n        d2 = np.sum(diff**2, axis=2)\n        \n        # Avoid division by zero on diagonal (self-interaction)\n        np.fill_diagonal(d2, np.inf)\n        \n        # 2. Potential Energy: E_pot = 0.5 * sum_{i!=j} (1 / r_{ij}^k)\n        # r_{ij}^k = (r_{ij}^2)^(k/2)\n        inv_d2 = 1.0 / d2\n        pot_terms = inv_d2**(k / 2.0)\n        E_pot = 0.5 * np.sum(pot_terms)\n        \n        # 3. Constraint Penalty: E_pen = sum_i (r_i^2 - 1)^2\n        r2 = np.sum(X**2, axis=1)\n        deviations = r2 - 1.0\n        E_pen = np.sum(deviations**2)\n        \n        total_energy = E_pot + PENALTY * E_pen\n        \n        # 4. Gradients\n        \n        # Gradient of Potential Energy\n        # dE_pot/dx_i = sum_j [ -k * (x_i - x_j) / r_{ij}^{k+2} ]\n        # factor = -k * (1/r^2)^((k+2)/2)\n        grad_factor = -k * (inv_d2**((k + 2.0) / 2.0))\n        np.fill_diagonal(grad_factor, 0.0)\n        \n        # Sum over j: (N, N, 1) * (N, N, 3) -> sum axis 1 -> (N, 3)\n        grad_pot = np.sum(grad_factor[:, :, np.newaxis] * diff, axis=1)\n        \n        # Gradient of Penalty\n        # dE_pen/dx_i = 4 * (r_i^2 - 1) * x_i\n        grad_pen = 4.0 * deviations[:, np.newaxis] * X\n        \n        total_grad = grad_pot + PENALTY * grad_pen\n        \n        return total_energy, total_grad.flatten()\n\n    # Objective functions for the two phases\n    obj_search = lambda x: energy_and_grad(x, K_SEARCH)\n    obj_refine = lambda x: energy_and_grad(x, K_REFINE)\n\n    # Custom step taker for Basin Hopping\n    # Perturbs points and projects them back to the sphere to explore valid space\n    class SphereStep:\n        def __init__(self, stepsize=0.2):\n            self.stepsize = stepsize\n            self.rng = np.random.default_rng()\n            \n        def __call__(self, x):\n            X = x.reshape((N, 3))\n            perturbation = self.rng.uniform(-self.stepsize, self.stepsize, X.shape)\n            X_new = X + perturbation\n            # Project to sphere\n            X_new /= np.linalg.norm(X_new, axis=1, keepdims=True)\n            return X_new.flatten()\n\n    # L-BFGS-B configuration\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"jac\": True,\n        \"options\": {\"maxiter\": 100, \"ftol\": 1e-6}\n    }\n    \n    # Phase 1: Global Search with Basin Hopping (k=12)\n    res = basinhopping(\n        obj_search, \n        x0, \n        niter=100, \n        T=0.5, \n        stepsize=0.25,\n        minimizer_kwargs=minimizer_kwargs,\n        take_step=SphereStep(0.25),\n        seed=1\n    )\n    \n    # Phase 2: Refinement with higher k (k=60)\n    # This sharpens the potential to better approximate the max-min distance objective\n    res_final = minimize(\n        obj_refine, \n        res.x, \n        method=\"L-BFGS-B\", \n        jac=True,\n        options={\"maxiter\": 500, \"ftol\": 1e-9}\n    )\n    \n    # Final projection to ensure points are exactly on the sphere\n    final_points = res_final.x.reshape((N, 3))\n    final_points /= np.linalg.norm(final_points, axis=1, keepdims=True)\n    \n    return final_points\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:09:56.193093",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 264,
        "candidates_token_count": 1622,
        "thoughts_token_count": 13883
      },
      "response_text_len": 4617
    }
  }
}