{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses an iterative refinement algorithm that moves pairs with minimum distance apart\n    and pairs with maximum distance closer together.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    # Initialize best points and best ratio squared\n    best_pts = None\n    best_r2 = -1\n    \n    # Run multiple restarts to avoid local maxima\n    for restart in range(10):\n        # Mixed initialization strategies: normal distribution and uniform distribution\n        if restart % 2 == 0:\n            points = np.random.normal(0, 1, (N, dim))\n        else:\n            points = np.random.uniform(-1, 1, (N, dim))\n        \n        # Center points initially\n        points -= np.mean(points, axis=0)\n        \n        # Initial step size and its decay rate\n        step = 0.05\n        num_iterations = 5000\n        \n        for i in range(num_iterations):\n            # Calculate all pairwise differences and squared distances\n            diff = points[:, np.newaxis, :] - points[np.newaxis, :, :]\n            dist_sq = np.sum(diff**2, axis=-1)\n            \n            # Mask the diagonal to find the minimum distance between distinct points\n            mask = np.eye(N, dtype=bool)\n            d_min_sq = np.min(dist_sq[~mask])\n            d_max_sq = np.max(dist_sq)\n            \n            # Keep track of the best squared ratio found\n            r2 = d_min_sq / d_max_sq\n            if r2 > best_r2:\n                best_r2 = r2\n                best_pts = points.copy()\n            \n            # Adaptive threshold for identifying pairs close to the min or max distance\n            # The threshold narrows over time to refine the local structure\n            thresh_width = 0.05 * (1 - i / num_iterations)\n            min_threshold = d_min_sq * (1.0 + thresh_width)\n            max_threshold = d_max_sq * (1.0 - thresh_width)\n            \n            forces = np.zeros((N, dim))\n            \n            # Force 1: Repel pairs that are near the current minimum distance\n            idx1_min, idx2_min = np.where((dist_sq < min_threshold) & (~mask))\n            if len(idx1_min) > 0:\n                d_min = np.sqrt(dist_sq[idx1_min, idx2_min] + 1e-12)\n                directions = (points[idx1_min] - points[idx2_min]) / d_min[:, np.newaxis]\n                # Linear weighting: strongest force at the absolute minimum distance\n                weights = (min_threshold - dist_sq[idx1_min, idx2_min]) / (min_threshold - d_min_sq + 1e-12)\n                np.add.at(forces, idx1_min, directions * weights[:, np.newaxis])\n            \n            # Force 2: Attract pairs that are near the current maximum distance\n            idx1_max, idx2_max = np.where(dist_sq > max_threshold)\n            if len(idx1_max) > 0:\n                d_max = np.sqrt(dist_sq[idx1_max, idx2_max] + 1e-12)\n                directions = (points[idx1_max] - points[idx2_max]) / d_max[:, np.newaxis]\n                # Linear weighting: strongest force at the absolute maximum distance\n                weights = (dist_sq[idx1_max, idx2_max] - max_threshold) / (d_max_sq - max_threshold + 1e-12)\n                np.add.at(forces, idx1_max, -directions * weights[:, np.newaxis])\n            \n            # Apply forces: normalize the maximum force per point to the step size\n            f_max_norm = np.max(np.linalg.norm(forces, axis=1))\n            if f_max_norm > 1e-12:\n                points += (forces / f_max_norm) * step\n            \n            # Decay step size for convergence\n            step *= 0.999\n            \n            # Periodic centering and normalization to keep the configuration stable\n            if i % 100 == 0:\n                points -= np.mean(points, axis=0)\n                current_d_max = np.sqrt(np.max(dist_sq))\n                if current_d_max > 1e-12:\n                    points /= current_d_max\n\n    # Final normalization of the best found configuration\n    best_diff = best_pts[:, np.newaxis, :] - best_pts[np.newaxis, :, :]\n    best_dist_sq = np.sum(best_diff**2, axis=-1)\n    best_pts /= np.sqrt(np.max(best_dist_sq))\n    \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9961040897874706,
    "min_max_ratio": 0.23911186084485378,
    "min_distance": 0.4889906551712965,
    "max_distance": 1.0,
    "eval_time": 1.748136281967163,
    "error": null
  },
  "prompt": "Implement an iterative refinement algorithm for 14 points in 3D. In each step, identify the pair of points with the minimum distance and move them slightly apart, while also identifying the pair with the maximum distance and moving them slightly closer. Maintain a balance to maximize the ratio.",
  "response": "```python\nimport numpy as np\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses an iterative refinement algorithm that moves pairs with minimum distance apart\n    and pairs with maximum distance closer together.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    # Initialize best points and best ratio squared\n    best_pts = None\n    best_r2 = -1\n    \n    # Run multiple restarts to avoid local maxima\n    for restart in range(10):\n        # Mixed initialization strategies: normal distribution and uniform distribution\n        if restart % 2 == 0:\n            points = np.random.normal(0, 1, (N, dim))\n        else:\n            points = np.random.uniform(-1, 1, (N, dim))\n        \n        # Center points initially\n        points -= np.mean(points, axis=0)\n        \n        # Initial step size and its decay rate\n        step = 0.05\n        num_iterations = 5000\n        \n        for i in range(num_iterations):\n            # Calculate all pairwise differences and squared distances\n            diff = points[:, np.newaxis, :] - points[np.newaxis, :, :]\n            dist_sq = np.sum(diff**2, axis=-1)\n            \n            # Mask the diagonal to find the minimum distance between distinct points\n            mask = np.eye(N, dtype=bool)\n            d_min_sq = np.min(dist_sq[~mask])\n            d_max_sq = np.max(dist_sq)\n            \n            # Keep track of the best squared ratio found\n            r2 = d_min_sq / d_max_sq\n            if r2 > best_r2:\n                best_r2 = r2\n                best_pts = points.copy()\n            \n            # Adaptive threshold for identifying pairs close to the min or max distance\n            # The threshold narrows over time to refine the local structure\n            thresh_width = 0.05 * (1 - i / num_iterations)\n            min_threshold = d_min_sq * (1.0 + thresh_width)\n            max_threshold = d_max_sq * (1.0 - thresh_width)\n            \n            forces = np.zeros((N, dim))\n            \n            # Force 1: Repel pairs that are near the current minimum distance\n            idx1_min, idx2_min = np.where((dist_sq < min_threshold) & (~mask))\n            if len(idx1_min) > 0:\n                d_min = np.sqrt(dist_sq[idx1_min, idx2_min] + 1e-12)\n                directions = (points[idx1_min] - points[idx2_min]) / d_min[:, np.newaxis]\n                # Linear weighting: strongest force at the absolute minimum distance\n                weights = (min_threshold - dist_sq[idx1_min, idx2_min]) / (min_threshold - d_min_sq + 1e-12)\n                np.add.at(forces, idx1_min, directions * weights[:, np.newaxis])\n            \n            # Force 2: Attract pairs that are near the current maximum distance\n            idx1_max, idx2_max = np.where(dist_sq > max_threshold)\n            if len(idx1_max) > 0:\n                d_max = np.sqrt(dist_sq[idx1_max, idx2_max] + 1e-12)\n                directions = (points[idx1_max] - points[idx2_max]) / d_max[:, np.newaxis]\n                # Linear weighting: strongest force at the absolute maximum distance\n                weights = (dist_sq[idx1_max, idx2_max] - max_threshold) / (d_max_sq - max_threshold + 1e-12)\n                np.add.at(forces, idx1_max, -directions * weights[:, np.newaxis])\n            \n            # Apply forces: normalize the maximum force per point to the step size\n            f_max_norm = np.max(np.linalg.norm(forces, axis=1))\n            if f_max_norm > 1e-12:\n                points += (forces / f_max_norm) * step\n            \n            # Decay step size for convergence\n            step *= 0.999\n            \n            # Periodic centering and normalization to keep the configuration stable\n            if i % 100 == 0:\n                points -= np.mean(points, axis=0)\n                current_d_max = np.sqrt(np.max(dist_sq))\n                if current_d_max > 1e-12:\n                    points /= current_d_max\n\n    # Final normalization of the best found configuration\n    best_diff = best_pts[:, np.newaxis, :] - best_pts[np.newaxis, :, :]\n    best_dist_sq = np.sum(best_diff**2, axis=-1)\n    best_pts /= np.sqrt(np.max(best_dist_sq))\n    \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:09:45.625400",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 229,
        "candidates_token_count": 1228,
        "thoughts_token_count": 22507
      },
      "response_text_len": 4216
    }
  }
}