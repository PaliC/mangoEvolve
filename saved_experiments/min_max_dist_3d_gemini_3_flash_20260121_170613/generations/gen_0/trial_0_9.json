{
  "trial_id": "trial_0_9",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the \n    squared ratio (min pairwise distance / max pairwise distance)^2.\n    \n    The strategy uses spherical coordinates to keep the 14 points on the surface\n    of a unit sphere, reducing the search space to 28 angular parameters.\n    The Basin-Hopping algorithm is employed for global optimization, \n    with L-BFGS-B as the local minimizer.\n    \"\"\"\n    \n    n_pts = 14\n    \n    def get_pts(angles):\n        \"\"\"\n        Converts 28 spherical angles (theta, phi) into 14 3D points on a unit sphere.\n        \"\"\"\n        theta = angles[:n_pts]\n        phi = angles[n_pts:]\n        \n        # Spherical to Cartesian conversion\n        x = np.sin(theta) * np.cos(phi)\n        y = np.sin(theta) * np.sin(phi)\n        z = np.cos(theta)\n        \n        return np.stack([x, y, z], axis=1)\n\n    def objective(angles):\n        \"\"\"\n        Calculates the negative squared ratio -(d_min/d_max)^2.\n        Minimizing this function maximizes the ratio.\n        \"\"\"\n        pts = get_pts(angles)\n        \n        # Efficiently compute pairwise squared distances using the identity:\n        # ||a - b||^2 = ||a||^2 + ||b||^2 - 2 * <a, b>\n        # For points on a unit sphere, ||a||^2 = ||b||^2 = 1.\n        # However, we use a more general dot product approach for robustness.\n        inner_prod = np.dot(pts, pts.T)\n        diag = np.diag(inner_prod)\n        # Using broadcasting to compute all pairwise squared distances\n        dist_sq = diag[:, np.newaxis] + diag[np.newaxis, :] - 2 * inner_prod\n        \n        # Extract the upper triangle of the distance matrix to get unique pairs\n        i, j = np.triu_indices(n_pts, k=1)\n        d_min_sq = np.min(dist_sq[i, j])\n        d_max_sq = np.max(dist_sq)\n        \n        # Avoid division by zero in degenerate cases\n        if d_max_sq <= 1e-12:\n            return 0.0\n            \n        # The goal is to maximize (min_dist / max_dist)^2\n        return -d_min_sq / d_max_sq\n\n    # Initial guess: 14 points randomly distributed in angular space\n    # theta in [0, pi], phi in [0, 2*pi]\n    np.random.seed(42)\n    init_angles = np.random.rand(2 * n_pts)\n    init_angles[:n_pts] *= np.pi        # Initial theta values\n    init_angles[n_pts:] *= 2 * np.pi    # Initial phi values\n    \n    # Local minimizer configuration\n    # L-BFGS-B is used to find local minima within the basin-hopping process\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": [(0, np.pi)] * n_pts + [(0, 2 * np.pi)] * n_pts,\n        \"options\": {\"maxiter\": 100}\n    }\n    \n    # Basin-Hopping algorithm to explore the global landscape\n    # niter is chosen to comfortably fit within the 60-second time limit\n    res = basinhopping(\n        objective, \n        init_angles, \n        niter=40, \n        T=0.01, \n        stepsize=0.5, \n        minimizer_kwargs=minimizer_kwargs\n    )\n    \n    # Convert the optimal angles found back to 3D Cartesian coordinates\n    best_pts = get_pts(res.x)\n    \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.6540347415797906,
    "min_max_ratio": 0.15699911858578328,
    "min_distance": 0.7838486659792006,
    "max_distance": 1.9782611237655872,
    "eval_time": 3.617494821548462,
    "error": null
  },
  "prompt": "Place 14 points in 3D to maximize the min-max distance ratio. Use spherical coordinates (theta, phi) to keep all points on the surface of a sphere, reducing the dimensionality of the search space. Use Basin-Hopping to find the optimal configuration on the sphere.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the \n    squared ratio (min pairwise distance / max pairwise distance)^2.\n    \n    The strategy uses spherical coordinates to keep the 14 points on the surface\n    of a unit sphere, reducing the search space to 28 angular parameters.\n    The Basin-Hopping algorithm is employed for global optimization, \n    with L-BFGS-B as the local minimizer.\n    \"\"\"\n    \n    n_pts = 14\n    \n    def get_pts(angles):\n        \"\"\"\n        Converts 28 spherical angles (theta, phi) into 14 3D points on a unit sphere.\n        \"\"\"\n        theta = angles[:n_pts]\n        phi = angles[n_pts:]\n        \n        # Spherical to Cartesian conversion\n        x = np.sin(theta) * np.cos(phi)\n        y = np.sin(theta) * np.sin(phi)\n        z = np.cos(theta)\n        \n        return np.stack([x, y, z], axis=1)\n\n    def objective(angles):\n        \"\"\"\n        Calculates the negative squared ratio -(d_min/d_max)^2.\n        Minimizing this function maximizes the ratio.\n        \"\"\"\n        pts = get_pts(angles)\n        \n        # Efficiently compute pairwise squared distances using the identity:\n        # ||a - b||^2 = ||a||^2 + ||b||^2 - 2 * <a, b>\n        # For points on a unit sphere, ||a||^2 = ||b||^2 = 1.\n        # However, we use a more general dot product approach for robustness.\n        inner_prod = np.dot(pts, pts.T)\n        diag = np.diag(inner_prod)\n        # Using broadcasting to compute all pairwise squared distances\n        dist_sq = diag[:, np.newaxis] + diag[np.newaxis, :] - 2 * inner_prod\n        \n        # Extract the upper triangle of the distance matrix to get unique pairs\n        i, j = np.triu_indices(n_pts, k=1)\n        d_min_sq = np.min(dist_sq[i, j])\n        d_max_sq = np.max(dist_sq)\n        \n        # Avoid division by zero in degenerate cases\n        if d_max_sq <= 1e-12:\n            return 0.0\n            \n        # The goal is to maximize (min_dist / max_dist)^2\n        return -d_min_sq / d_max_sq\n\n    # Initial guess: 14 points randomly distributed in angular space\n    # theta in [0, pi], phi in [0, 2*pi]\n    np.random.seed(42)\n    init_angles = np.random.rand(2 * n_pts)\n    init_angles[:n_pts] *= np.pi        # Initial theta values\n    init_angles[n_pts:] *= 2 * np.pi    # Initial phi values\n    \n    # Local minimizer configuration\n    # L-BFGS-B is used to find local minima within the basin-hopping process\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": [(0, np.pi)] * n_pts + [(0, 2 * np.pi)] * n_pts,\n        \"options\": {\"maxiter\": 100}\n    }\n    \n    # Basin-Hopping algorithm to explore the global landscape\n    # niter is chosen to comfortably fit within the 60-second time limit\n    res = basinhopping(\n        objective, \n        init_angles, \n        niter=40, \n        T=0.01, \n        stepsize=0.5, \n        minimizer_kwargs=minimizer_kwargs\n    )\n    \n    # Convert the optimal angles found back to 3D Cartesian coordinates\n    best_pts = get_pts(res.x)\n    \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:09:30.074200",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 231,
        "candidates_token_count": 980,
        "thoughts_token_count": 19873
      },
      "response_text_len": 3124
    }
  }
}