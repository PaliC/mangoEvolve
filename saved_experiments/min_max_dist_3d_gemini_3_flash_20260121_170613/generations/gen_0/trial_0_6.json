{
  "trial_id": "trial_0_6",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D to maximize the squared ratio (min_dist / max_dist)^2.\n    Uses several structured initial configurations and refines them using the SLSQP optimizer.\n    \"\"\"\n    \n    def thompson_points(n, iterations=200):\n        \"\"\"Generates a good initial point set by solving the Thompson problem (minimizing energy).\"\"\"\n        pts = np.random.normal(0, 1, (n, 3))\n        pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        lr = 0.05\n        for _ in range(iterations):\n            diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :] # (n, n, 3)\n            dist = np.linalg.norm(diff, axis=2)[:, :, np.newaxis] # (n, n, 1)\n            dist[dist < 1e-8] = 1.0 # avoid division by zero\n            forces = np.sum(diff / (dist**3), axis=1) # Coulomb force\n            pts += forces * lr\n            pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n            lr *= 0.98\n        return pts * 0.5\n\n    def get_seeds():\n        \"\"\"Creates a list of diverse initial configurations.\"\"\"\n        seeds = []\n        \n        # Cube + Octahedron (Rhombic Dodecahedron-like)\n        for s in [1.2, 1.5, 1.8, 2.0]:\n            pts = []\n            a = 1.0\n            for i in [-a, a]:\n                for j in [-a, a]:\n                    for k in [-a, a]:\n                        pts.append([i, j, k])\n            b = s\n            pts.append([b, 0, 0]); pts.append([-b, 0, 0])\n            pts.append([0, b, 0]); pts.append([0, -b, 0])\n            pts.append([0, 0, b]); pts.append([0, 0, -b])\n            seeds.append(np.array(pts))\n            \n        # Two twisted rings of 7\n        pts = []\n        for i in range(7):\n            theta = 2 * np.pi * i / 7\n            pts.append([0.5 * np.cos(theta), 0.5 * np.sin(theta), 0.25])\n            theta = 2 * np.pi * (i + 0.5) / 7\n            pts.append([0.5 * np.cos(theta), 0.5 * np.sin(theta), -0.25])\n        seeds.append(np.array(pts))\n        \n        # 2 poles + two twisted rings of 6\n        pts = [[0, 0, 0.5], [0, 0, -0.5]]\n        for i in range(6):\n            theta = 2 * np.pi * i / 6\n            pts.append([0.5 * np.cos(theta), 0.5 * np.sin(theta), 0.2])\n            theta = 2 * np.pi * (i + 0.5) / 6\n            pts.append([0.5 * np.cos(theta), 0.5 * np.sin(theta), -0.2])\n        seeds.append(np.array(pts))\n        \n        # Thompson problem solution\n        seeds.append(thompson_points(14, 200))\n        \n        # Random configuration\n        pts = np.random.normal(0, 1, (14, 3))\n        pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        seeds.append(pts * 0.5)\n        \n        return seeds\n\n    def optimize_pts(pts):\n        \"\"\"Refines the point set using SLSQP optimization.\"\"\"\n        n = 14\n        triu_indices = np.triu_indices(n, k=1)\n        \n        # Normalize initial points to fit within d_max^2 = 0.9 to avoid violating constraints at start\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        max_d2 = np.max(d2)\n        if max_d2 == 0: max_d2 = 1.0\n        pts = pts * np.sqrt(0.9 / max_d2)\n        \n        # Variables: [x1, y1, z1, ..., x14, y14, z14, d_min2]\n        x0 = np.zeros(n * 3 + 1)\n        x0[:n*3] = pts.flatten()\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        x0[-1] = np.min(d2[triu_indices])\n\n        def obj(x):\n            return -x[-1] # Maximize d_min^2\n\n        def constr(x):\n            p = x[:-1].reshape((n, 3))\n            dm2 = x[-1]\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            dist_sq = d2[triu_indices]\n            # Constraints: d_ij^2 >= d_min2 and d_ij^2 <= 1.0\n            return np.concatenate([dist_sq - dm2, 1.0 - dist_sq])\n\n        res = minimize(obj, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constr},\n                       options={'maxiter': 200, 'ftol': 1e-9})\n        \n        # Post-process results\n        final_pts = res.x[:-1].reshape((n, 3))\n        diff = final_pts[:, np.newaxis, :] - final_pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        max_d2_final = np.max(d2)\n        if max_d2_final == 0: max_d2_final = 1.0\n        \n        # Rescale so max distance is exactly 1.0\n        final_pts = final_pts / np.sqrt(max_d2_final)\n        \n        # Recalculate d_min2 after scaling\n        diff = final_pts[:, np.newaxis, :] - final_pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        final_dmin2 = np.min(d2[triu_indices])\n        \n        return final_pts, final_dmin2\n\n    best_pts = None\n    best_val = -1\n    \n    # Iterate through all seed configurations to find the global optimum\n    for seed_pts in get_seeds():\n        pts, val = optimize_pts(seed_pts)\n        if val > best_val:\n            best_val = val\n            best_pts = pts\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9412488659611474,
    "min_max_ratio": 0.22594402549446221,
    "min_distance": 0.4753356976858169,
    "max_distance": 1.0000000000000002,
    "eval_time": 0.3669748306274414,
    "error": null
  },
  "prompt": "Solve the 14-point packing problem in 3D to maximize (min_dist / max_dist)^2. Start by placing points in a structured way (e.g., a combination of an octahedron and a cube, or a Thompson-problem solution for N=14) and then use scipy.optimize.minimize to refine the positions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D to maximize the squared ratio (min_dist / max_dist)^2.\n    Uses several structured initial configurations and refines them using the SLSQP optimizer.\n    \"\"\"\n    \n    def thompson_points(n, iterations=200):\n        \"\"\"Generates a good initial point set by solving the Thompson problem (minimizing energy).\"\"\"\n        pts = np.random.normal(0, 1, (n, 3))\n        pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        lr = 0.05\n        for _ in range(iterations):\n            diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :] # (n, n, 3)\n            dist = np.linalg.norm(diff, axis=2)[:, :, np.newaxis] # (n, n, 1)\n            dist[dist < 1e-8] = 1.0 # avoid division by zero\n            forces = np.sum(diff / (dist**3), axis=1) # Coulomb force\n            pts += forces * lr\n            pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n            lr *= 0.98\n        return pts * 0.5\n\n    def get_seeds():\n        \"\"\"Creates a list of diverse initial configurations.\"\"\"\n        seeds = []\n        \n        # Cube + Octahedron (Rhombic Dodecahedron-like)\n        for s in [1.2, 1.5, 1.8, 2.0]:\n            pts = []\n            a = 1.0\n            for i in [-a, a]:\n                for j in [-a, a]:\n                    for k in [-a, a]:\n                        pts.append([i, j, k])\n            b = s\n            pts.append([b, 0, 0]); pts.append([-b, 0, 0])\n            pts.append([0, b, 0]); pts.append([0, -b, 0])\n            pts.append([0, 0, b]); pts.append([0, 0, -b])\n            seeds.append(np.array(pts))\n            \n        # Two twisted rings of 7\n        pts = []\n        for i in range(7):\n            theta = 2 * np.pi * i / 7\n            pts.append([0.5 * np.cos(theta), 0.5 * np.sin(theta), 0.25])\n            theta = 2 * np.pi * (i + 0.5) / 7\n            pts.append([0.5 * np.cos(theta), 0.5 * np.sin(theta), -0.25])\n        seeds.append(np.array(pts))\n        \n        # 2 poles + two twisted rings of 6\n        pts = [[0, 0, 0.5], [0, 0, -0.5]]\n        for i in range(6):\n            theta = 2 * np.pi * i / 6\n            pts.append([0.5 * np.cos(theta), 0.5 * np.sin(theta), 0.2])\n            theta = 2 * np.pi * (i + 0.5) / 6\n            pts.append([0.5 * np.cos(theta), 0.5 * np.sin(theta), -0.2])\n        seeds.append(np.array(pts))\n        \n        # Thompson problem solution\n        seeds.append(thompson_points(14, 200))\n        \n        # Random configuration\n        pts = np.random.normal(0, 1, (14, 3))\n        pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        seeds.append(pts * 0.5)\n        \n        return seeds\n\n    def optimize_pts(pts):\n        \"\"\"Refines the point set using SLSQP optimization.\"\"\"\n        n = 14\n        triu_indices = np.triu_indices(n, k=1)\n        \n        # Normalize initial points to fit within d_max^2 = 0.9 to avoid violating constraints at start\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        max_d2 = np.max(d2)\n        if max_d2 == 0: max_d2 = 1.0\n        pts = pts * np.sqrt(0.9 / max_d2)\n        \n        # Variables: [x1, y1, z1, ..., x14, y14, z14, d_min2]\n        x0 = np.zeros(n * 3 + 1)\n        x0[:n*3] = pts.flatten()\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        x0[-1] = np.min(d2[triu_indices])\n\n        def obj(x):\n            return -x[-1] # Maximize d_min^2\n\n        def constr(x):\n            p = x[:-1].reshape((n, 3))\n            dm2 = x[-1]\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            dist_sq = d2[triu_indices]\n            # Constraints: d_ij^2 >= d_min2 and d_ij^2 <= 1.0\n            return np.concatenate([dist_sq - dm2, 1.0 - dist_sq])\n\n        res = minimize(obj, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constr},\n                       options={'maxiter': 200, 'ftol': 1e-9})\n        \n        # Post-process results\n        final_pts = res.x[:-1].reshape((n, 3))\n        diff = final_pts[:, np.newaxis, :] - final_pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        max_d2_final = np.max(d2)\n        if max_d2_final == 0: max_d2_final = 1.0\n        \n        # Rescale so max distance is exactly 1.0\n        final_pts = final_pts / np.sqrt(max_d2_final)\n        \n        # Recalculate d_min2 after scaling\n        diff = final_pts[:, np.newaxis, :] - final_pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        final_dmin2 = np.min(d2[triu_indices])\n        \n        return final_pts, final_dmin2\n\n    best_pts = None\n    best_val = -1\n    \n    # Iterate through all seed configurations to find the global optimum\n    for seed_pts in get_seeds():\n        pts, val = optimize_pts(seed_pts)\n        if val > best_val:\n            best_val = val\n            best_pts = pts\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:09:41.234668",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 246,
        "candidates_token_count": 1782,
        "thoughts_token_count": 22579
      },
      "response_text_len": 5025
    }
  }
}