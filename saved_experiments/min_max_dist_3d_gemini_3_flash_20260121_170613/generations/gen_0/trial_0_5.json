{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes 14 points in 3D to maximize the squared ratio (min_dist / max_dist)^2\n    using a simplified CMA-ES implementation.\n    \"\"\"\n    # Problem Parameters\n    N_points = 14\n    dim = 3\n    N = N_points * dim  # Flattened dimension (42)\n\n    # 1. Initialization: Fibonacci Spiral on Sphere\n    # This provides a near-optimal starting configuration.\n    indices = np.arange(0, N_points, dtype=float) + 0.5\n    phi = np.arccos(1 - 2 * indices / N_points)\n    theta = np.pi * (1 + 5**0.5) * indices\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    xmean = np.column_stack((x, y, z)).flatten()\n\n    # 2. Objective Function\n    # We want to maximize (min/max)^2, which is equivalent to minimizing -(min/max)^2.\n    # Since (min/max)^2 = (min^2 / max^2), we work with squared distances directly.\n    def fitness(x_flat):\n        pts = x_flat.reshape((N_points, dim))\n        \n        # Compute squared pairwise distances matrix\n        # (N, 1, 3) - (1, N, 3) -> (N, N, 3)\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        \n        # Extract unique pairwise distances (upper triangle)\n        # Using triu_indices is faster than mask\n        iu = np.triu_indices(N_points, 1)\n        vals = dists_sq[iu]\n        \n        if vals.size == 0:\n            return 0.0\n            \n        min_sq = np.min(vals)\n        max_sq = np.max(vals)\n        \n        # Avoid division by zero\n        if max_sq < 1e-14:\n            return 1e10 # Penalty for collapse\n            \n        # Return negative squared ratio\n        return - (min_sq / max_sq)\n\n    # 3. CMA-ES Parameters\n    # Strategy parameter setting: Selection\n    lambda_ = 4 + int(3 * np.log(N))  # Population size (~15)\n    mu = lambda_ // 2\n    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n    weights /= np.sum(weights)\n    mueff = np.sum(weights)**2 / np.sum(weights**2)\n\n    # Strategy parameter setting: Adaptation\n    cc = (4 + mueff/N) / (N + 4 + 2 * mueff/N)\n    cs = (mueff + 2) / (N + mueff + 5)\n    c1 = 2 / ((N + 1.3)**2 + mueff)\n    cmu = min(1 - c1, 2 * (mueff - 2 + 1/mueff) / ((N + 2)**2 + mueff))\n    damps = 1 + 2 * max(0, np.sqrt((mueff - 1) / (N + 1)) - 1) + cs\n\n    # Initialize dynamic strategy parameters\n    sigma = 0.02  # Small initial step size (fine-tuning the heuristic)\n    pc = np.zeros(N)\n    ps = np.zeros(N)\n    B = np.eye(N)\n    D = np.ones(N)\n    C = np.eye(N)\n    chiN = N**0.5 * (1 - 1/(4*N) + 1/(21*N**2))\n\n    # Optimization Loop\n    best_fit = np.inf\n    best_x = xmean.copy()\n    \n    start_time = time.time()\n    gen = 0\n    time_limit = 55.0 # Seconds\n\n    while time.time() - start_time < time_limit:\n        gen += 1\n        \n        # A. Sample offspring\n        # arz ~ N(0, I)\n        arz = np.random.randn(lambda_, N)\n        \n        # arx = m + sigma * B * D * arz\n        # Efficient computation: (arz * D) scales rows, then rotate by B\n        # dy = B @ (D * z) -> (arz * D) @ B.T\n        dy = (arz * D) @ B.T\n        arx = xmean + sigma * dy\n        \n        # B. Evaluate fitness\n        fits = np.zeros(lambda_)\n        for i in range(lambda_):\n            fits[i] = fitness(arx[i])\n        \n        # C. Selection and Recombination\n        arindex = np.argsort(fits)\n        \n        # Update best solution found so far\n        if fits[arindex[0]] < best_fit:\n            best_fit = fits[arindex[0]]\n            best_x = arx[arindex[0]].copy()\n            \n        # Compute weighted mean of selected steps\n        zmean = np.dot(weights, arz[arindex[:mu]]) # (N,)\n        \n        # Update mean: xmean = xmean + sigma * B * D * zmean\n        dy_mean = (zmean * D) @ B.T\n        xmean += sigma * dy_mean\n        \n        # D. Update Evolution Paths\n        # ps path for step size control\n        ps = (1 - cs) * ps + np.sqrt(cs * (2 - cs) * mueff) * (zmean @ B.T)\n        \n        # hsig check (stall prevention)\n        hsig = np.linalg.norm(ps) / chiN / np.sqrt(1 - (1 - cs)**(2 * gen)) < 1.4 + 2/(N + 1)\n        \n        # pc path for covariance matrix adaptation\n        pc = (1 - cc) * pc + hsig * np.sqrt(cc * (2 - cc) * mueff) * dy_mean\n        \n        # E. Update Covariance Matrix C\n        # Rank-mu update: weighted covariance of successful steps\n        y_s = dy[arindex[:mu]]\n        rank_mu = (y_s.T * weights) @ y_s\n        \n        # Rank-1 update: outer product of evolution path\n        rank_1 = np.outer(pc, pc)\n        \n        C = (1 - c1 - cmu) * C + \\\n            c1 * (rank_1 + (1 - hsig) * cc * (2 - cc) * C) + \\\n            cmu * rank_mu\n            \n        # F. Adapt Step Size sigma\n        sigma *= np.exp((cs / damps) * (np.linalg.norm(ps) / chiN - 1))\n        \n        # G. Eigen Decomposition (every few generations for efficiency)\n        if gen % 10 == 0:\n            # Enforce symmetry\n            C = np.triu(C) + np.triu(C, 1).T\n            try:\n                vals, vecs = np.linalg.eigh(C)\n                # Numerical stability\n                D = np.sqrt(np.maximum(vals, 1e-10))\n                B = vecs\n            except np.linalg.LinAlgError:\n                pass\n\n    return best_x.reshape((N_points, dim))",
  "metrics": {
    "valid": true,
    "score": 0.9379341101763063,
    "min_max_ratio": 0.22514832810491658,
    "min_distance": 0.9112686965123823,
    "max_distance": 1.9204901704056372,
    "eval_time": 55.0620276927948,
    "error": null
  },
  "prompt": "Optimize 14 points in 3D to maximize the squared ratio of min to max distance. Use CMA-ES (Covariance Matrix Adaptation Evolution Strategy) if available via a library or implement a simplified version. CMA-ES is excellent for non-convex continuous optimization.",
  "response": "An implementation of the **CMA-ES (Covariance Matrix Adaptation Evolution Strategy)** algorithm to optimize the configuration of 14 points in 3D space. The goal is to maximize the squared ratio of the minimum pairwise distance to the maximum pairwise distance.\n\nThe solution seeds the optimization with a Fibonacci spiral projected onto a sphere, which is a known high-quality heuristic for sphere packing, and then refines it using CMA-ES.\n\n```python\nimport numpy as np\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes 14 points in 3D to maximize the squared ratio (min_dist / max_dist)^2\n    using a simplified CMA-ES implementation.\n    \"\"\"\n    # Problem Parameters\n    N_points = 14\n    dim = 3\n    N = N_points * dim  # Flattened dimension (42)\n\n    # 1. Initialization: Fibonacci Spiral on Sphere\n    # This provides a near-optimal starting configuration.\n    indices = np.arange(0, N_points, dtype=float) + 0.5\n    phi = np.arccos(1 - 2 * indices / N_points)\n    theta = np.pi * (1 + 5**0.5) * indices\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    xmean = np.column_stack((x, y, z)).flatten()\n\n    # 2. Objective Function\n    # We want to maximize (min/max)^2, which is equivalent to minimizing -(min/max)^2.\n    # Since (min/max)^2 = (min^2 / max^2), we work with squared distances directly.\n    def fitness(x_flat):\n        pts = x_flat.reshape((N_points, dim))\n        \n        # Compute squared pairwise distances matrix\n        # (N, 1, 3) - (1, N, 3) -> (N, N, 3)\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        \n        # Extract unique pairwise distances (upper triangle)\n        # Using triu_indices is faster than mask\n        iu = np.triu_indices(N_points, 1)\n        vals = dists_sq[iu]\n        \n        if vals.size == 0:\n            return 0.0\n            \n        min_sq = np.min(vals)\n        max_sq = np.max(vals)\n        \n        # Avoid division by zero\n        if max_sq < 1e-14:\n            return 1e10 # Penalty for collapse\n            \n        # Return negative squared ratio\n        return - (min_sq / max_sq)\n\n    # 3. CMA-ES Parameters\n    # Strategy parameter setting: Selection\n    lambda_ = 4 + int(3 * np.log(N))  # Population size (~15)\n    mu = lambda_ // 2\n    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n    weights /= np.sum(weights)\n    mueff = np.sum(weights)**2 / np.sum(weights**2)\n\n    # Strategy parameter setting: Adaptation\n    cc = (4 + mueff/N) / (N + 4 + 2 * mueff/N)\n    cs = (mueff + 2) / (N + mueff + 5)\n    c1 = 2 / ((N + 1.3)**2 + mueff)\n    cmu = min(1 - c1, 2 * (mueff - 2 + 1/mueff) / ((N + 2)**2 + mueff))\n    damps = 1 + 2 * max(0, np.sqrt((mueff - 1) / (N + 1)) - 1) + cs\n\n    # Initialize dynamic strategy parameters\n    sigma = 0.02  # Small initial step size (fine-tuning the heuristic)\n    pc = np.zeros(N)\n    ps = np.zeros(N)\n    B = np.eye(N)\n    D = np.ones(N)\n    C = np.eye(N)\n    chiN = N**0.5 * (1 - 1/(4*N) + 1/(21*N**2))\n\n    # Optimization Loop\n    best_fit = np.inf\n    best_x = xmean.copy()\n    \n    start_time = time.time()\n    gen = 0\n    time_limit = 55.0 # Seconds\n\n    while time.time() - start_time < time_limit:\n        gen += 1\n        \n        # A. Sample offspring\n        # arz ~ N(0, I)\n        arz = np.random.randn(lambda_, N)\n        \n        # arx = m + sigma * B * D * arz\n        # Efficient computation: (arz * D) scales rows, then rotate by B\n        # dy = B @ (D * z) -> (arz * D) @ B.T\n        dy = (arz * D) @ B.T\n        arx = xmean + sigma * dy\n        \n        # B. Evaluate fitness\n        fits = np.zeros(lambda_)\n        for i in range(lambda_):\n            fits[i] = fitness(arx[i])\n        \n        # C. Selection and Recombination\n        arindex = np.argsort(fits)\n        \n        # Update best solution found so far\n        if fits[arindex[0]] < best_fit:\n            best_fit = fits[arindex[0]]\n            best_x = arx[arindex[0]].copy()\n            \n        # Compute weighted mean of selected steps\n        zmean = np.dot(weights, arz[arindex[:mu]]) # (N,)\n        \n        # Update mean: xmean = xmean + sigma * B * D * zmean\n        dy_mean = (zmean * D) @ B.T\n        xmean += sigma * dy_mean\n        \n        # D. Update Evolution Paths\n        # ps path for step size control\n        ps = (1 - cs) * ps + np.sqrt(cs * (2 - cs) * mueff) * (zmean @ B.T)\n        \n        # hsig check (stall prevention)\n        hsig = np.linalg.norm(ps) / chiN / np.sqrt(1 - (1 - cs)**(2 * gen)) < 1.4 + 2/(N + 1)\n        \n        # pc path for covariance matrix adaptation\n        pc = (1 - cc) * pc + hsig * np.sqrt(cc * (2 - cc) * mueff) * dy_mean\n        \n        # E. Update Covariance Matrix C\n        # Rank-mu update: weighted covariance of successful steps\n        y_s = dy[arindex[:mu]]\n        rank_mu = (y_s.T * weights) @ y_s\n        \n        # Rank-1 update: outer product of evolution path\n        rank_1 = np.outer(pc, pc)\n        \n        C = (1 - c1 - cmu) * C + \\\n            c1 * (rank_1 + (1 - hsig) * cc * (2 - cc) * C) + \\\n            cmu * rank_mu\n            \n        # F. Adapt Step Size sigma\n        sigma *= np.exp((cs / damps) * (np.linalg.norm(ps) / chiN - 1))\n        \n        # G. Eigen Decomposition (every few generations for efficiency)\n        if gen % 10 == 0:\n            # Enforce symmetry\n            C = np.triu(C) + np.triu(C, 1).T\n            try:\n                vals, vecs = np.linalg.eigh(C)\n                # Numerical stability\n                D = np.sqrt(np.maximum(vals, 1e-10))\n                B = vecs\n            except np.linalg.LinAlgError:\n                pass\n\n    return best_x.reshape((N_points, dim))\n```",
  "reasoning": "An implementation of the **CMA-ES (Covariance Matrix Adaptation Evolution Strategy)** algorithm to optimize the configuration of 14 points in 3D space. The goal is to maximize the squared ratio of the minimum pairwise distance to the maximum pairwise distance.\n\nThe solution seeds the optimization with a Fibonacci spiral projected onto a sphere, which is a known high-quality heuristic for sphere packing, and then refines it using CMA-ES.",
  "timestamp": "2026-01-21T17:10:44.539824",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 227,
        "candidates_token_count": 1929,
        "thoughts_token_count": 12351
      },
      "response_text_len": 5716
    }
  }
}