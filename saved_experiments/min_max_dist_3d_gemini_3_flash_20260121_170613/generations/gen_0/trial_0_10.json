{
  "trial_id": "trial_0_10",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D to maximize the squared ratio \n    (min_dist / max_dist)^2.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    # Precompute indices for all pairwise combinations (upper triangle)\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    def get_diffs(x):\n        # Computes displacement vectors for all pairs\n        # x shape: (N, 3)\n        # Returns: (M, 3) where M = N*(N-1)/2\n        return x[idx_i] - x[idx_j]\n\n    def objective(x_flat):\n        \"\"\"\n        Objective: Maximize min pairwise distance.\n        Equivalent to minimizing negative min squared distance.\n        \"\"\"\n        x = x_flat.reshape((N, dim))\n        diffs = get_diffs(x)\n        dists_sq = np.sum(diffs**2, axis=1)\n        return -np.min(dists_sq)\n\n    def obj_grad(x_flat):\n        \"\"\"\n        Gradient of the objective function.\n        Uses the fact that grad(min(f_i)) is grad(f_k) where k is the index achieving the minimum.\n        Averages gradients if multiple pairs are within tolerance to handle symmetry.\n        \"\"\"\n        x = x_flat.reshape((N, dim))\n        diffs = get_diffs(x)\n        dists_sq = np.sum(diffs**2, axis=1)\n        min_sq = np.min(dists_sq)\n        \n        # Identify active pairs (those with minimal distance)\n        # Use a small epsilon for numerical stability\n        active_indices = np.where(dists_sq <= min_sq + 1e-6)[0]\n        \n        grad = np.zeros((N, dim))\n        \n        # Gradient derivation:\n        # L = - ||xi - xj||^2\n        # dL/dxi = -2(xi - xj)\n        # dL/dxj = -2(xj - xi) = 2(xi - xj)\n        \n        for k in active_indices:\n            i, j = idx_i[k], idx_j[k]\n            diff = diffs[k] # vector xi - xj\n            \n            grad[i] += -2 * diff\n            grad[j] += 2 * diff\n            \n        return grad.flatten()\n\n    def constraints(x_flat):\n        \"\"\"\n        Constraints: All pairwise distances must be <= 1.\n        Formulated as: 1 - dist_sq >= 0\n        \"\"\"\n        x = x_flat.reshape((N, dim))\n        diffs = get_diffs(x)\n        dists_sq = np.sum(diffs**2, axis=1)\n        return 1.0 - dists_sq\n\n    def constraints_jac(x_flat):\n        \"\"\"\n        Jacobian of the constraints.\n        Constraint k: g_k(x) = 1 - ||xi - xj||^2\n        grad_xi(g_k) = -2(xi - xj)\n        grad_xj(g_k) = 2(xi - xj)\n        \"\"\"\n        x = x_flat.reshape((N, dim))\n        diffs = get_diffs(x)\n        M = len(diffs)\n        \n        jac = np.zeros((M, N, dim))\n        rows = np.arange(M)\n        \n        # Vectorized assignment of gradients\n        jac[rows, idx_i, :] = -2 * diffs\n        jac[rows, idx_j, :] = 2 * diffs\n        \n        # Reshape to (M, N*dim)\n        return jac.reshape((M, N * dim))\n\n    best_x = np.random.rand(N, dim)\n    best_score = -1.0\n    \n    start_time = time.time()\n    \n    # Run optimization with multiple restarts to avoid local optima\n    # We allocate ~50 seconds for restarts\n    cnt = 0\n    while time.time() - start_time < 50:\n        cnt += 1\n        \n        # Initialize points\n        # Strategy: Mix between points on sphere surface and points inside a ball\n        x0 = np.random.normal(size=(N, dim))\n        x0 /= np.linalg.norm(x0, axis=1, keepdims=True)\n        \n        if cnt % 2 == 0:\n            # Surface initialization (radius 0.5 -> diameter 1)\n            x0 *= 0.5\n        else:\n            # Volumetric initialization\n            r = np.random.rand(N, 1) ** (1/3) * 0.5\n            x0 *= r\n\n        cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n        \n        try:\n            # SLSQP optimizer\n            res = minimize(objective, x0.flatten(), jac=obj_grad, \n                           constraints=cons, method='SLSQP', \n                           options={'ftol': 1e-6, 'maxiter': 1000})\n            \n            # Evaluate result\n            x_res = res.x.reshape((N, dim))\n            diffs = get_diffs(x_res)\n            dists_sq = np.sum(diffs**2, axis=1)\n            \n            min_d2 = np.min(dists_sq)\n            max_d2 = np.max(dists_sq)\n            \n            if max_d2 > 1e-9:\n                # Score is (min_dist / max_dist)^2 = min_d2 / max_d2\n                score = min_d2 / max_d2\n                if score > best_score:\n                    best_score = score\n                    best_x = x_res\n        except Exception:\n            pass\n\n    return best_x",
  "metrics": {
    "valid": true,
    "score": 0.9776929793115771,
    "min_max_ratio": 0.23469232785503305,
    "min_distance": 0.48441735437741273,
    "max_distance": 0.9999314938525093,
    "eval_time": 50.23781108856201,
    "error": null
  },
  "prompt": "Optimize 14 points in 3D for (min_dist / max_dist)^2. Use the 'SLSQP' optimizer with a custom gradient. The objective should be the minimum of all pairwise distances. Since min is not differentiable, use the fact that the gradient of min(f_i(x)) is the gradient of the f_i that achieves the minimum.",
  "response": "Here is the Python solution using `scipy.optimize.minimize` with the 'SLSQP' solver and a custom gradient implementation as requested.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D to maximize the squared ratio \n    (min_dist / max_dist)^2.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    # Precompute indices for all pairwise combinations (upper triangle)\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    def get_diffs(x):\n        # Computes displacement vectors for all pairs\n        # x shape: (N, 3)\n        # Returns: (M, 3) where M = N*(N-1)/2\n        return x[idx_i] - x[idx_j]\n\n    def objective(x_flat):\n        \"\"\"\n        Objective: Maximize min pairwise distance.\n        Equivalent to minimizing negative min squared distance.\n        \"\"\"\n        x = x_flat.reshape((N, dim))\n        diffs = get_diffs(x)\n        dists_sq = np.sum(diffs**2, axis=1)\n        return -np.min(dists_sq)\n\n    def obj_grad(x_flat):\n        \"\"\"\n        Gradient of the objective function.\n        Uses the fact that grad(min(f_i)) is grad(f_k) where k is the index achieving the minimum.\n        Averages gradients if multiple pairs are within tolerance to handle symmetry.\n        \"\"\"\n        x = x_flat.reshape((N, dim))\n        diffs = get_diffs(x)\n        dists_sq = np.sum(diffs**2, axis=1)\n        min_sq = np.min(dists_sq)\n        \n        # Identify active pairs (those with minimal distance)\n        # Use a small epsilon for numerical stability\n        active_indices = np.where(dists_sq <= min_sq + 1e-6)[0]\n        \n        grad = np.zeros((N, dim))\n        \n        # Gradient derivation:\n        # L = - ||xi - xj||^2\n        # dL/dxi = -2(xi - xj)\n        # dL/dxj = -2(xj - xi) = 2(xi - xj)\n        \n        for k in active_indices:\n            i, j = idx_i[k], idx_j[k]\n            diff = diffs[k] # vector xi - xj\n            \n            grad[i] += -2 * diff\n            grad[j] += 2 * diff\n            \n        return grad.flatten()\n\n    def constraints(x_flat):\n        \"\"\"\n        Constraints: All pairwise distances must be <= 1.\n        Formulated as: 1 - dist_sq >= 0\n        \"\"\"\n        x = x_flat.reshape((N, dim))\n        diffs = get_diffs(x)\n        dists_sq = np.sum(diffs**2, axis=1)\n        return 1.0 - dists_sq\n\n    def constraints_jac(x_flat):\n        \"\"\"\n        Jacobian of the constraints.\n        Constraint k: g_k(x) = 1 - ||xi - xj||^2\n        grad_xi(g_k) = -2(xi - xj)\n        grad_xj(g_k) = 2(xi - xj)\n        \"\"\"\n        x = x_flat.reshape((N, dim))\n        diffs = get_diffs(x)\n        M = len(diffs)\n        \n        jac = np.zeros((M, N, dim))\n        rows = np.arange(M)\n        \n        # Vectorized assignment of gradients\n        jac[rows, idx_i, :] = -2 * diffs\n        jac[rows, idx_j, :] = 2 * diffs\n        \n        # Reshape to (M, N*dim)\n        return jac.reshape((M, N * dim))\n\n    best_x = np.random.rand(N, dim)\n    best_score = -1.0\n    \n    start_time = time.time()\n    \n    # Run optimization with multiple restarts to avoid local optima\n    # We allocate ~50 seconds for restarts\n    cnt = 0\n    while time.time() - start_time < 50:\n        cnt += 1\n        \n        # Initialize points\n        # Strategy: Mix between points on sphere surface and points inside a ball\n        x0 = np.random.normal(size=(N, dim))\n        x0 /= np.linalg.norm(x0, axis=1, keepdims=True)\n        \n        if cnt % 2 == 0:\n            # Surface initialization (radius 0.5 -> diameter 1)\n            x0 *= 0.5\n        else:\n            # Volumetric initialization\n            r = np.random.rand(N, 1) ** (1/3) * 0.5\n            x0 *= r\n\n        cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n        \n        try:\n            # SLSQP optimizer\n            res = minimize(objective, x0.flatten(), jac=obj_grad, \n                           constraints=cons, method='SLSQP', \n                           options={'ftol': 1e-6, 'maxiter': 1000})\n            \n            # Evaluate result\n            x_res = res.x.reshape((N, dim))\n            diffs = get_diffs(x_res)\n            dists_sq = np.sum(diffs**2, axis=1)\n            \n            min_d2 = np.min(dists_sq)\n            max_d2 = np.max(dists_sq)\n            \n            if max_d2 > 1e-9:\n                # Score is (min_dist / max_dist)^2 = min_d2 / max_d2\n                score = min_d2 / max_d2\n                if score > best_score:\n                    best_score = score\n                    best_x = x_res\n        except Exception:\n            pass\n\n    return best_x\n```",
  "reasoning": "Here is the Python solution using `scipy.optimize.minimize` with the 'SLSQP' solver and a custom gradient implementation as requested.",
  "timestamp": "2026-01-21T17:10:23.626051",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 251,
        "candidates_token_count": 1480,
        "thoughts_token_count": 11965
      },
      "response_text_len": 4599
    }
  }
}