{
  "trial_id": "trial_4_7",
  "generation": 4,
  "parent_id": "trial_3_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    This implementation uses a multi-start SLSQP refinement strategy, incorporating seeds from \n    Fibonacci sphere distributions, hexagonal antiprism configurations, and their averages.\n    \"\"\"\n    n = 14\n    dim = 3\n\n    def get_ratio(pts_flat):\n        \"\"\"Calculates the ratio of the minimum pairwise distance to the maximum pairwise distance.\"\"\"\n        pts = pts_flat.reshape((n, dim))\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        max_d = np.max(dists)\n        if max_d < 1e-10:\n            return 0\n        min_d = np.min(dists)\n        return min_d / max_d\n\n    def objective(pts_flat):\n        \"\"\"Objective function for the optimizer: minimize the negative ratio.\"\"\"\n        return -get_ratio(pts_flat)\n\n    def fibonacci_sphere(n_pts):\n        \"\"\"Generates points on a unit sphere using the Fibonacci lattice method.\"\"\"\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))  # Golden angle in radians\n        for i in range(n_pts):\n            y = 1 - (i / float(n_pts - 1)) * 2\n            radius = np.sqrt(max(0, 1 - y * y))\n            theta = phi * i\n            pts.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n        return np.array(pts)\n\n    def hexagonal_antiprism(h):\n        \"\"\"Generates a configuration based on a hexagonal antiprism with two polar caps.\"\"\"\n        pts = [[0, 0, 1.0], [0, 0, -1.0]]\n        r = np.sqrt(max(0, 1.0 - h**2))\n        for i in range(6):\n            # Layer 1 at z = h\n            theta1 = 2 * np.pi * i / 6\n            pts.append([r * np.cos(theta1), r * np.sin(theta1), h])\n            # Layer 2 at z = -h, offset by 30 degrees\n            theta2 = 2 * np.pi * (i + 0.5) / 6\n            pts.append([r * np.cos(theta2), r * np.sin(theta2), -h])\n        return np.array(pts)\n\n    # Generate initial seeds\n    s1 = fibonacci_sphere(n)\n    s2 = hexagonal_antiprism(0.33)  # Roughly optimal height for Tammes n=14\n    \n    # Combined seed: Average of Fibonacci and Hexagonal Antiprism, then normalized\n    s3 = (s1 + s2) / 2.0\n    norms = np.linalg.norm(s3, axis=1)[:, np.newaxis]\n    s3 = s3 / np.where(norms == 0, 1.0, norms)\n    \n    seeds = [s1, s2, s3, hexagonal_antiprism(0.5), hexagonal_antiprism(0.15)]\n    \n    # Add a random seed to increase search diversity\n    np.random.seed(42)\n    seeds.append(np.random.uniform(-1, 1, (n, dim)))\n\n    best_pts_flat = s1.flatten()\n    best_val = -1\n\n    # Multi-start refinement using SLSQP\n    # A constraint is used to fix the scale of the points to prevent collapse/drift.\n    scale_constraint = {'type': 'eq', 'fun': lambda x: np.sum(x**2) - n}\n\n    for s in seeds:\n        res = minimize(objective, s.flatten(), method='SLSQP', \n                       options={'maxiter': 150},\n                       constraints=[scale_constraint])\n        if res.success:\n            r = get_ratio(res.x)\n            if r > best_val:\n                best_val = r\n                best_pts_flat = res.x\n\n    # Stochastic local search: perturb the best result and re-optimize\n    for _ in range(3):\n        perturbed = best_pts_flat + np.random.normal(0, 0.04, n * dim)\n        res = minimize(objective, perturbed, method='SLSQP', \n                       options={'maxiter': 150},\n                       constraints=[scale_constraint])\n        r = get_ratio(res.x)\n        if r > best_val:\n            best_val = r\n            best_pts_flat = res.x\n            \n    # Reshape and return the final configuration\n    return best_pts_flat.reshape((n, dim))",
  "metrics": {
    "valid": true,
    "score": 0.9331269725962539,
    "min_max_ratio": 0.22399438884908157,
    "min_distance": 0.9300334745316046,
    "max_distance": 1.9650789826539328,
    "eval_time": 1.3859751224517822,
    "error": null
  },
  "prompt": "Combine the best features of trial_3_6 and trial_3_4. Average their coordinates, normalize, and then run a multi-start SLSQP refinement.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    This implementation uses a multi-start SLSQP refinement strategy, incorporating seeds from \n    Fibonacci sphere distributions, hexagonal antiprism configurations, and their averages.\n    \"\"\"\n    n = 14\n    dim = 3\n\n    def get_ratio(pts_flat):\n        \"\"\"Calculates the ratio of the minimum pairwise distance to the maximum pairwise distance.\"\"\"\n        pts = pts_flat.reshape((n, dim))\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        max_d = np.max(dists)\n        if max_d < 1e-10:\n            return 0\n        min_d = np.min(dists)\n        return min_d / max_d\n\n    def objective(pts_flat):\n        \"\"\"Objective function for the optimizer: minimize the negative ratio.\"\"\"\n        return -get_ratio(pts_flat)\n\n    def fibonacci_sphere(n_pts):\n        \"\"\"Generates points on a unit sphere using the Fibonacci lattice method.\"\"\"\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))  # Golden angle in radians\n        for i in range(n_pts):\n            y = 1 - (i / float(n_pts - 1)) * 2\n            radius = np.sqrt(max(0, 1 - y * y))\n            theta = phi * i\n            pts.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n        return np.array(pts)\n\n    def hexagonal_antiprism(h):\n        \"\"\"Generates a configuration based on a hexagonal antiprism with two polar caps.\"\"\"\n        pts = [[0, 0, 1.0], [0, 0, -1.0]]\n        r = np.sqrt(max(0, 1.0 - h**2))\n        for i in range(6):\n            # Layer 1 at z = h\n            theta1 = 2 * np.pi * i / 6\n            pts.append([r * np.cos(theta1), r * np.sin(theta1), h])\n            # Layer 2 at z = -h, offset by 30 degrees\n            theta2 = 2 * np.pi * (i + 0.5) / 6\n            pts.append([r * np.cos(theta2), r * np.sin(theta2), -h])\n        return np.array(pts)\n\n    # Generate initial seeds\n    s1 = fibonacci_sphere(n)\n    s2 = hexagonal_antiprism(0.33)  # Roughly optimal height for Tammes n=14\n    \n    # Combined seed: Average of Fibonacci and Hexagonal Antiprism, then normalized\n    s3 = (s1 + s2) / 2.0\n    norms = np.linalg.norm(s3, axis=1)[:, np.newaxis]\n    s3 = s3 / np.where(norms == 0, 1.0, norms)\n    \n    seeds = [s1, s2, s3, hexagonal_antiprism(0.5), hexagonal_antiprism(0.15)]\n    \n    # Add a random seed to increase search diversity\n    np.random.seed(42)\n    seeds.append(np.random.uniform(-1, 1, (n, dim)))\n\n    best_pts_flat = s1.flatten()\n    best_val = -1\n\n    # Multi-start refinement using SLSQP\n    # A constraint is used to fix the scale of the points to prevent collapse/drift.\n    scale_constraint = {'type': 'eq', 'fun': lambda x: np.sum(x**2) - n}\n\n    for s in seeds:\n        res = minimize(objective, s.flatten(), method='SLSQP', \n                       options={'maxiter': 150},\n                       constraints=[scale_constraint])\n        if res.success:\n            r = get_ratio(res.x)\n            if r > best_val:\n                best_val = r\n                best_pts_flat = res.x\n\n    # Stochastic local search: perturb the best result and re-optimize\n    for _ in range(3):\n        perturbed = best_pts_flat + np.random.normal(0, 0.04, n * dim)\n        res = minimize(objective, perturbed, method='SLSQP', \n                       options={'maxiter': 150},\n                       constraints=[scale_constraint])\n        r = get_ratio(res.x)\n        if r > best_val:\n            best_val = r\n            best_pts_flat = res.x\n            \n    # Reshape and return the final configuration\n    return best_pts_flat.reshape((n, dim))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:33:45.514703",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 206,
        "candidates_token_count": 1186,
        "thoughts_token_count": 18298
      },
      "response_text_len": 3755
    }
  }
}