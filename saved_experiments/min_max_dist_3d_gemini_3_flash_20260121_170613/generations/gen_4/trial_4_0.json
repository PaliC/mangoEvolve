{
  "trial_id": "trial_4_0",
  "generation": 4,
  "parent_id": "trial_3_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport random\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Returns a numpy array of shape (14, 3) representing 14 points in 3D space\n    that maximize the squared ratio (min_dist / max_dist)^2.\n    \"\"\"\n    n_points = 14\n    n_dim = 3\n    \n    # Precompute indices for all pairs to speed up calculations\n    pairs = []\n    for i in range(n_points):\n        for j in range(i + 1, n_points):\n            pairs.append((i, j))\n    pairs = np.array(pairs)\n    idx_i = pairs[:, 0]\n    idx_j = pairs[:, 1]\n    num_pairs = len(pairs)\n\n    # --- Helper Functions ---\n\n    def get_dists_sq(flat_coords):\n        points = flat_coords.reshape((n_points, n_dim))\n        diff = points[idx_i] - points[idx_j]\n        return np.sum(diff**2, axis=1)\n\n    # --- Stage 1: Generate Initial Candidates ---\n    # We try a few random starts and a structured heuristic to find a good basin.\n    \n    candidates = []\n\n    # Heuristic: Capped Hexagonal Antiprism (often close to optimal for N=14)\n    # 1 top, 1 bottom, 6 ring A, 6 ring B (rotated)\n    def make_antiprism():\n        pts = []\n        pts.append([0, 0, 1]) # Top\n        pts.append([0, 0, -1]) # Bottom\n        \n        # Rings\n        r = 0.8  # Radius estimate\n        h = 0.5  # Height estimate\n        for k in range(6):\n            theta = 2 * np.pi * k / 6\n            pts.append([r * np.cos(theta), r * np.sin(theta), h])\n        \n        for k in range(6):\n            theta = 2 * np.pi * k / 6 + np.pi / 6 # Offset\n            pts.append([r * np.cos(theta), r * np.sin(theta), -h])\n            \n        pts = np.array(pts)\n        # Normalize to sphere\n        norms = np.linalg.norm(pts, axis=1, keepdims=True)\n        return pts / norms\n\n    # Generate a pool of starting points\n    init_configs = []\n    init_configs.append(make_antiprism().flatten())\n    for _ in range(4): # 4 random restarts\n        pts = np.random.normal(0, 1, (n_points, n_dim))\n        pts /= np.linalg.norm(pts, axis=1, keepdims=True)\n        init_configs.append(pts.flatten())\n\n    # Quick pre-optimization on sphere to settle candidates\n    best_candidate = None\n    best_score = -1.0\n\n    def sphere_loss(x):\n        # Maximize min distance on sphere\n        d2 = get_dists_sq(x)\n        return -np.min(d2)\n\n    sphere_cons = []\n    # Constraint: points on unit sphere\n    for i in range(n_points):\n        def constr_on_sphere(x, idx=i):\n            p = x[3*idx : 3*idx+3]\n            return np.sum(p**2) - 1.0\n        sphere_cons.append({'type': 'eq', 'fun': constr_on_sphere})\n\n    # Run quick optim for each candidate\n    for x0 in init_configs:\n        # Use a looser tolerance for speed in this pre-stage\n        res = minimize(sphere_loss, x0, method='SLSQP', constraints=sphere_cons, \n                       options={'ftol': 1e-4, 'maxiter': 100})\n        \n        # Evaluate ratio\n        d2 = get_dists_sq(res.x)\n        if len(d2) > 0:\n            min_d = np.sqrt(np.min(d2))\n            max_d = np.sqrt(np.max(d2))\n            ratio = (min_d / max_d)**2\n            if ratio > best_score:\n                best_score = ratio\n                best_candidate = res.x\n\n    # --- Stage 2: High-Precision Refinement ---\n    # As requested: Perturb, then refine using SLSQP with ftol=1e-14.\n    # Formulation: Maximize t subject to t <= dist_sq <= 1.\n    \n    # 1. Perturb slightly to escape local ridges\n    current_points = best_candidate + np.random.normal(0, 0.005, best_candidate.shape)\n    \n    # 2. Setup variables for final optimization: [x0, y0, z0, ... x13, y13, z13, t]\n    # We optimize t (squared min dist) directly.\n    \n    # Initial t guess (slightly lower than current min dist sq to be safe)\n    d2_init = get_dists_sq(current_points)\n    max_d2_init = np.max(d2_init)\n    # Rescale points so max_dist is approx 1.0\n    current_points /= np.sqrt(max_d2_init)\n    \n    d2_scaled = get_dists_sq(current_points)\n    t_init = np.min(d2_scaled) * 0.9\n    \n    x_init = np.concatenate([current_points, [t_init]])\n\n    # Objective: Maximize t => Minimize -t\n    def objective(x):\n        return -x[-1]\n\n    def objective_grad(x):\n        grad = np.zeros_like(x)\n        grad[-1] = -1.0\n        return grad\n\n    # Constraints\n    # 1. dist_sq[k] >= t  =>  dist_sq[k] - t >= 0\n    # 2. dist_sq[k] <= 1  =>  1 - dist_sq[k] >= 0\n    \n    # We implement the Jacobian for speed and precision\n    \n    def constraints(x):\n        points = x[:-1].reshape((n_points, n_dim))\n        t = x[-1]\n        \n        # Vectorized distance computation\n        p_i = points[idx_i]\n        p_j = points[idx_j]\n        diff = p_i - p_j\n        d2 = np.sum(diff**2, axis=1)\n        \n        # Lower bound constraints: d^2 - t >= 0\n        c_lower = d2 - t\n        # Upper bound constraints: 1 - d^2 >= 0\n        c_upper = 1.0 - d2\n        \n        return np.concatenate([c_lower, c_upper])\n\n    def constraints_jac(x):\n        points = x[:-1].reshape((n_points, n_dim))\n        # t = x[-1] # Not needed for jacobian calculation\n        \n        n_vars = len(x)\n        n_cons = 2 * num_pairs\n        jac = np.zeros((n_cons, n_vars))\n        \n        # Precompute differences\n        p_i = points[idx_i]\n        p_j = points[idx_j]\n        diff = p_i - p_j # Shape (num_pairs, 3)\n        \n        # Derivatives of d^2_k w.r.t points\n        # d(d^2_k)/d(p_i) = 2*(p_i - p_j)\n        # d(d^2_k)/d(p_j) = -2*(p_i - p_j)\n        \n        # Fill Jacobian\n        # We iterate, but can be vectorized. Given N=14, loop is fast enough (91 pairs).\n        for k in range(num_pairs):\n            i = idx_i[k]\n            j = idx_j[k]\n            \n            # Gradient of d^2 w.r.t coordinates\n            grad_d2_i = 2 * diff[k]\n            grad_d2_j = -2 * diff[k]\n            \n            # Lower constraint: d^2 - t\n            # w.r.t coordinates\n            jac[k, 3*i : 3*i+3] = grad_d2_i\n            jac[k, 3*j : 3*j+3] = grad_d2_j\n            # w.r.t t\n            jac[k, -1] = -1.0\n            \n            # Upper constraint: 1 - d^2\n            # w.r.t coordinates\n            jac[num_pairs + k, 3*i : 3*i+3] = -grad_d2_i\n            jac[num_pairs + k, 3*j : 3*j+3] = -grad_d2_j\n            # w.r.t t is 0\n        \n        return jac\n\n    cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n\n    # Optimization\n    # Using 'SLSQP' as requested with high precision\n    res = minimize(objective, x_init, method='SLSQP', jac=objective_grad,\n                   constraints=cons, options={'ftol': 1e-14, 'maxiter': 2000})\n\n    final_flat = res.x[:-1]\n    final_points = final_flat.reshape((n_points, n_dim))\n    \n    return final_points",
  "metrics": {
    "valid": true,
    "score": 0.942188750965894,
    "min_max_ratio": 0.22616964212907825,
    "min_distance": 0.4755729619407294,
    "max_distance": 1.0000000000000004,
    "eval_time": 1.640476942062378,
    "error": null
  },
  "prompt": "Take the coordinates from trial_3_6 and perform a high-precision local refinement. Use scipy.optimize.minimize with method='SLSQP' or 'L-BFGS-B', setting ftol=1e-14 and maxiter=2000. Try to slightly perturb the points before refining to escape any tiny local ridges. The objective should be to maximize the minimum pairwise distance while keeping the maximum pairwise distance normalized.",
  "response": "An algorithm to place 14 points in 3D space to maximize the squared ratio of the minimum pairwise distance to the maximum pairwise distance.\n\nThe solution employs a two-stage approach:\n1.  **Global Search**: Generates a high-quality initial configuration. It tests random spherical packings and a geometric heuristic (capped hexagonal antiprism), relaxing them to find a good basin of attraction.\n2.  **High-Precision Refinement**: As requested, uses `scipy.optimize.minimize` with the 'SLSQP' method, strict tolerances (`ftol=1e-14`), and a perturbation step. It formulates the problem as maximizing the minimum squared distance $t$ subject to the constraint that all pairwise squared distances are between $t$ and $1.0$.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport random\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Returns a numpy array of shape (14, 3) representing 14 points in 3D space\n    that maximize the squared ratio (min_dist / max_dist)^2.\n    \"\"\"\n    n_points = 14\n    n_dim = 3\n    \n    # Precompute indices for all pairs to speed up calculations\n    pairs = []\n    for i in range(n_points):\n        for j in range(i + 1, n_points):\n            pairs.append((i, j))\n    pairs = np.array(pairs)\n    idx_i = pairs[:, 0]\n    idx_j = pairs[:, 1]\n    num_pairs = len(pairs)\n\n    # --- Helper Functions ---\n\n    def get_dists_sq(flat_coords):\n        points = flat_coords.reshape((n_points, n_dim))\n        diff = points[idx_i] - points[idx_j]\n        return np.sum(diff**2, axis=1)\n\n    # --- Stage 1: Generate Initial Candidates ---\n    # We try a few random starts and a structured heuristic to find a good basin.\n    \n    candidates = []\n\n    # Heuristic: Capped Hexagonal Antiprism (often close to optimal for N=14)\n    # 1 top, 1 bottom, 6 ring A, 6 ring B (rotated)\n    def make_antiprism():\n        pts = []\n        pts.append([0, 0, 1]) # Top\n        pts.append([0, 0, -1]) # Bottom\n        \n        # Rings\n        r = 0.8  # Radius estimate\n        h = 0.5  # Height estimate\n        for k in range(6):\n            theta = 2 * np.pi * k / 6\n            pts.append([r * np.cos(theta), r * np.sin(theta), h])\n        \n        for k in range(6):\n            theta = 2 * np.pi * k / 6 + np.pi / 6 # Offset\n            pts.append([r * np.cos(theta), r * np.sin(theta), -h])\n            \n        pts = np.array(pts)\n        # Normalize to sphere\n        norms = np.linalg.norm(pts, axis=1, keepdims=True)\n        return pts / norms\n\n    # Generate a pool of starting points\n    init_configs = []\n    init_configs.append(make_antiprism().flatten())\n    for _ in range(4): # 4 random restarts\n        pts = np.random.normal(0, 1, (n_points, n_dim))\n        pts /= np.linalg.norm(pts, axis=1, keepdims=True)\n        init_configs.append(pts.flatten())\n\n    # Quick pre-optimization on sphere to settle candidates\n    best_candidate = None\n    best_score = -1.0\n\n    def sphere_loss(x):\n        # Maximize min distance on sphere\n        d2 = get_dists_sq(x)\n        return -np.min(d2)\n\n    sphere_cons = []\n    # Constraint: points on unit sphere\n    for i in range(n_points):\n        def constr_on_sphere(x, idx=i):\n            p = x[3*idx : 3*idx+3]\n            return np.sum(p**2) - 1.0\n        sphere_cons.append({'type': 'eq', 'fun': constr_on_sphere})\n\n    # Run quick optim for each candidate\n    for x0 in init_configs:\n        # Use a looser tolerance for speed in this pre-stage\n        res = minimize(sphere_loss, x0, method='SLSQP', constraints=sphere_cons, \n                       options={'ftol': 1e-4, 'maxiter': 100})\n        \n        # Evaluate ratio\n        d2 = get_dists_sq(res.x)\n        if len(d2) > 0:\n            min_d = np.sqrt(np.min(d2))\n            max_d = np.sqrt(np.max(d2))\n            ratio = (min_d / max_d)**2\n            if ratio > best_score:\n                best_score = ratio\n                best_candidate = res.x\n\n    # --- Stage 2: High-Precision Refinement ---\n    # As requested: Perturb, then refine using SLSQP with ftol=1e-14.\n    # Formulation: Maximize t subject to t <= dist_sq <= 1.\n    \n    # 1. Perturb slightly to escape local ridges\n    current_points = best_candidate + np.random.normal(0, 0.005, best_candidate.shape)\n    \n    # 2. Setup variables for final optimization: [x0, y0, z0, ... x13, y13, z13, t]\n    # We optimize t (squared min dist) directly.\n    \n    # Initial t guess (slightly lower than current min dist sq to be safe)\n    d2_init = get_dists_sq(current_points)\n    max_d2_init = np.max(d2_init)\n    # Rescale points so max_dist is approx 1.0\n    current_points /= np.sqrt(max_d2_init)\n    \n    d2_scaled = get_dists_sq(current_points)\n    t_init = np.min(d2_scaled) * 0.9\n    \n    x_init = np.concatenate([current_points, [t_init]])\n\n    # Objective: Maximize t => Minimize -t\n    def objective(x):\n        return -x[-1]\n\n    def objective_grad(x):\n        grad = np.zeros_like(x)\n        grad[-1] = -1.0\n        return grad\n\n    # Constraints\n    # 1. dist_sq[k] >= t  =>  dist_sq[k] - t >= 0\n    # 2. dist_sq[k] <= 1  =>  1 - dist_sq[k] >= 0\n    \n    # We implement the Jacobian for speed and precision\n    \n    def constraints(x):\n        points = x[:-1].reshape((n_points, n_dim))\n        t = x[-1]\n        \n        # Vectorized distance computation\n        p_i = points[idx_i]\n        p_j = points[idx_j]\n        diff = p_i - p_j\n        d2 = np.sum(diff**2, axis=1)\n        \n        # Lower bound constraints: d^2 - t >= 0\n        c_lower = d2 - t\n        # Upper bound constraints: 1 - d^2 >= 0\n        c_upper = 1.0 - d2\n        \n        return np.concatenate([c_lower, c_upper])\n\n    def constraints_jac(x):\n        points = x[:-1].reshape((n_points, n_dim))\n        # t = x[-1] # Not needed for jacobian calculation\n        \n        n_vars = len(x)\n        n_cons = 2 * num_pairs\n        jac = np.zeros((n_cons, n_vars))\n        \n        # Precompute differences\n        p_i = points[idx_i]\n        p_j = points[idx_j]\n        diff = p_i - p_j # Shape (num_pairs, 3)\n        \n        # Derivatives of d^2_k w.r.t points\n        # d(d^2_k)/d(p_i) = 2*(p_i - p_j)\n        # d(d^2_k)/d(p_j) = -2*(p_i - p_j)\n        \n        # Fill Jacobian\n        # We iterate, but can be vectorized. Given N=14, loop is fast enough (91 pairs).\n        for k in range(num_pairs):\n            i = idx_i[k]\n            j = idx_j[k]\n            \n            # Gradient of d^2 w.r.t coordinates\n            grad_d2_i = 2 * diff[k]\n            grad_d2_j = -2 * diff[k]\n            \n            # Lower constraint: d^2 - t\n            # w.r.t coordinates\n            jac[k, 3*i : 3*i+3] = grad_d2_i\n            jac[k, 3*j : 3*j+3] = grad_d2_j\n            # w.r.t t\n            jac[k, -1] = -1.0\n            \n            # Upper constraint: 1 - d^2\n            # w.r.t coordinates\n            jac[num_pairs + k, 3*i : 3*i+3] = -grad_d2_i\n            jac[num_pairs + k, 3*j : 3*j+3] = -grad_d2_j\n            # w.r.t t is 0\n        \n        return jac\n\n    cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n\n    # Optimization\n    # Using 'SLSQP' as requested with high precision\n    res = minimize(objective, x_init, method='SLSQP', jac=objective_grad,\n                   constraints=cons, options={'ftol': 1e-14, 'maxiter': 2000})\n\n    final_flat = res.x[:-1]\n    final_points = final_flat.reshape((n_points, n_dim))\n    \n    return final_points\n```",
  "reasoning": "An algorithm to place 14 points in 3D space to maximize the squared ratio of the minimum pairwise distance to the maximum pairwise distance.\n\nThe solution employs a two-stage approach:\n1.  **Global Search**: Generates a high-quality initial configuration. It tests random spherical packings and a geometric heuristic (capped hexagonal antiprism), relaxing them to find a good basin of attraction.\n2.  **High-Precision Refinement**: As requested, uses `scipy.optimize.minimize` with the 'SLSQP' method, strict tolerances (`ftol=1e-14`), and a perturbation step. It formulates the problem as maximizing the minimum squared distance $t$ subject to the constraint that all pairwise squared distances are between $t$ and $1.0$.",
  "timestamp": "2026-01-21T17:30:54.655900",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 263,
        "candidates_token_count": 2477,
        "thoughts_token_count": 5673
      },
      "response_text_len": 7361
    }
  }
}