{
  "trial_id": "trial_4_8",
  "generation": 4,
  "parent_id": "trial_3_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space that maximize the squared ratio (min_dist / max_dist)^2.\n    This is achieved by maximizing the minimum pairwise distance while keeping the \n    maximum pairwise distance (diameter of the set) less than or equal to 1.0.\n    \"\"\"\n    N = 14\n    \n    def objective(v):\n        # The last variable is the squared minimum distance 's'\n        return -v[-1]\n        \n    def constraints(v):\n        pts = v[:-1].reshape((N, 3))\n        s = v[-1]\n        # Calculate all pairwise differences\n        diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        # Calculate squared distances\n        dist_sq = np.sum(diffs**2, axis=-1)\n        # We only care about the upper triangle of the distance matrix\n        iu = np.triu_indices(N, k=1)\n        dists = dist_sq[iu]\n        \n        # Constraints: \n        # 1. All squared distances must be >= s (min distance)\n        # 2. All squared distances must be <= 1.0 (max distance)\n        # This effectively fixes the diameter of the set to be <= 1.0\n        return np.concatenate([dists - s, 1.0 - dists])\n\n    best_pts = None\n    best_val = -1\n\n    # List of initial configurations for the optimizer\n    starts = []\n    \n    # 1. Rhombic Dodecahedron-like configuration (BCC-related)\n    # This structure (8 cube corners + 6 face centers) is very efficient for N=14.\n    pts_rh = []\n    for x in [-1, 1]:\n        for y in [-1, 1]:\n            for z in [-1, 1]:\n                pts_rh.append([x, y, z])\n    # k is the distance for the face centers, which SLSQP will optimize.\n    k = 1.732 \n    for coord in [[k, 0, 0], [-k, 0, 0], [0, k, 0], [0, -k, 0], [0, 0, k], [0, 0, -k]]:\n        pts_rh.append(coord)\n    starts.append(np.array(pts_rh))\n    \n    # 2. Fibonacci sphere distribution (evenly distributed on a sphere)\n    phi = np.pi * (3.0 - np.sqrt(5.0))\n    pts_fib = []\n    for i in range(N):\n        y = 1 - (i / float(N - 1)) * 2\n        radius = np.sqrt(max(0, 1 - y * y))\n        theta = phi * i\n        pts_fib.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    starts.append(np.array(pts_fib))\n    \n    # 3. 1-6-6-1 configuration (gyroelongated hexagonal bipyramid)\n    pts_1661 = [[0, 0, 1], [0, 0, -1]]\n    for i in range(6):\n        theta = 2 * np.pi * i / 6\n        pts_1661.append([np.cos(theta), np.sin(theta), 0.3])\n    for i in range(6):\n        theta = 2 * np.pi * (i + 0.5) / 6\n        pts_1661.append([np.cos(theta), np.sin(theta), -0.3])\n    starts.append(np.array(pts_1661))\n    \n    # 4. Random configuration\n    np.random.seed(42)\n    starts.append(np.random.uniform(-1, 1, (N, 3)))\n\n    iu = np.triu_indices(N, k=1)\n    \n    # Run SLSQP optimization for each starting configuration\n    for pts_init in starts:\n        # Pre-process: center and normalize the starting points\n        pts_init -= np.mean(pts_init, axis=0)\n        diffs = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        dists_sq = np.sum(diffs**2, axis=-1)[iu]\n        max_d = np.sqrt(np.max(dists_sq))\n        pts_init /= (max_d if max_d > 0 else 1.0)\n        \n        # Calculate initial s (min squared distance)\n        diffs = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        dists_sq = np.sum(diffs**2, axis=-1)[iu]\n        s_init = np.min(dists_sq)\n        \n        # Initial variable vector: flattened points + s\n        x0 = np.concatenate([pts_init.flatten(), [s_init]])\n        \n        # Refine with SLSQP\n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options={'maxiter': 200, 'ftol': 1e-9})\n        \n        # Track the best result found across all starts\n        if -res.fun > best_val:\n            best_val = -res.fun\n            best_pts = res.x[:-1].reshape((N, 3))\n    \n    if best_pts is None:\n        # Fallback to the first start if optimization fails\n        best_pts = starts[0]\n\n    # Final scaling to ensure the maximum pairwise distance is exactly 1.0\n    diffs = best_pts[:, np.newaxis, :] - best_pts[np.newaxis, :, :]\n    dists_sq = np.sum(diffs**2, axis=-1)\n    max_d = np.sqrt(np.max(dists_sq))\n    \n    return best_pts / max_d",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539046,
    "min_max_ratio": 0.24005088264958177,
    "min_distance": 0.4899498776911592,
    "max_distance": 1.0000000000000002,
    "eval_time": 0.2911810874938965,
    "error": null
  },
  "prompt": "Combine the best features of trial_3_6 and trial_3_4. Average their coordinates, normalize, and then run a multi-start SLSQP refinement.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space that maximize the squared ratio (min_dist / max_dist)^2.\n    This is achieved by maximizing the minimum pairwise distance while keeping the \n    maximum pairwise distance (diameter of the set) less than or equal to 1.0.\n    \"\"\"\n    N = 14\n    \n    def objective(v):\n        # The last variable is the squared minimum distance 's'\n        return -v[-1]\n        \n    def constraints(v):\n        pts = v[:-1].reshape((N, 3))\n        s = v[-1]\n        # Calculate all pairwise differences\n        diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        # Calculate squared distances\n        dist_sq = np.sum(diffs**2, axis=-1)\n        # We only care about the upper triangle of the distance matrix\n        iu = np.triu_indices(N, k=1)\n        dists = dist_sq[iu]\n        \n        # Constraints: \n        # 1. All squared distances must be >= s (min distance)\n        # 2. All squared distances must be <= 1.0 (max distance)\n        # This effectively fixes the diameter of the set to be <= 1.0\n        return np.concatenate([dists - s, 1.0 - dists])\n\n    best_pts = None\n    best_val = -1\n\n    # List of initial configurations for the optimizer\n    starts = []\n    \n    # 1. Rhombic Dodecahedron-like configuration (BCC-related)\n    # This structure (8 cube corners + 6 face centers) is very efficient for N=14.\n    pts_rh = []\n    for x in [-1, 1]:\n        for y in [-1, 1]:\n            for z in [-1, 1]:\n                pts_rh.append([x, y, z])\n    # k is the distance for the face centers, which SLSQP will optimize.\n    k = 1.732 \n    for coord in [[k, 0, 0], [-k, 0, 0], [0, k, 0], [0, -k, 0], [0, 0, k], [0, 0, -k]]:\n        pts_rh.append(coord)\n    starts.append(np.array(pts_rh))\n    \n    # 2. Fibonacci sphere distribution (evenly distributed on a sphere)\n    phi = np.pi * (3.0 - np.sqrt(5.0))\n    pts_fib = []\n    for i in range(N):\n        y = 1 - (i / float(N - 1)) * 2\n        radius = np.sqrt(max(0, 1 - y * y))\n        theta = phi * i\n        pts_fib.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    starts.append(np.array(pts_fib))\n    \n    # 3. 1-6-6-1 configuration (gyroelongated hexagonal bipyramid)\n    pts_1661 = [[0, 0, 1], [0, 0, -1]]\n    for i in range(6):\n        theta = 2 * np.pi * i / 6\n        pts_1661.append([np.cos(theta), np.sin(theta), 0.3])\n    for i in range(6):\n        theta = 2 * np.pi * (i + 0.5) / 6\n        pts_1661.append([np.cos(theta), np.sin(theta), -0.3])\n    starts.append(np.array(pts_1661))\n    \n    # 4. Random configuration\n    np.random.seed(42)\n    starts.append(np.random.uniform(-1, 1, (N, 3)))\n\n    iu = np.triu_indices(N, k=1)\n    \n    # Run SLSQP optimization for each starting configuration\n    for pts_init in starts:\n        # Pre-process: center and normalize the starting points\n        pts_init -= np.mean(pts_init, axis=0)\n        diffs = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        dists_sq = np.sum(diffs**2, axis=-1)[iu]\n        max_d = np.sqrt(np.max(dists_sq))\n        pts_init /= (max_d if max_d > 0 else 1.0)\n        \n        # Calculate initial s (min squared distance)\n        diffs = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        dists_sq = np.sum(diffs**2, axis=-1)[iu]\n        s_init = np.min(dists_sq)\n        \n        # Initial variable vector: flattened points + s\n        x0 = np.concatenate([pts_init.flatten(), [s_init]])\n        \n        # Refine with SLSQP\n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options={'maxiter': 200, 'ftol': 1e-9})\n        \n        # Track the best result found across all starts\n        if -res.fun > best_val:\n            best_val = -res.fun\n            best_pts = res.x[:-1].reshape((N, 3))\n    \n    if best_pts is None:\n        # Fallback to the first start if optimization fails\n        best_pts = starts[0]\n\n    # Final scaling to ensure the maximum pairwise distance is exactly 1.0\n    diffs = best_pts[:, np.newaxis, :] - best_pts[np.newaxis, :, :]\n    dists_sq = np.sum(diffs**2, axis=-1)\n    max_d = np.sqrt(np.max(dists_sq))\n    \n    return best_pts / max_d\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:34:46.504175",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 206,
        "candidates_token_count": 1478,
        "thoughts_token_count": 25201
      },
      "response_text_len": 4283
    }
  }
}