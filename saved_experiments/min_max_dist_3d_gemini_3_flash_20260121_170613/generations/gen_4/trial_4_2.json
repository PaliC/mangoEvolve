{
  "trial_id": "trial_4_2",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the ratio\n    of the minimum pairwise distance to the maximum pairwise distance.\n    The configuration is found by starting from several symmetric and random seeds\n    and refining them using a combination of a repulsion energy-based optimizer\n    (L-BFGS-B) and a direct ratio optimizer (Nelder-Mead).\n    \"\"\"\n    N = 14\n    start_time = time.time()\n    \n    def get_ratio(pts):\n        pts = pts.reshape((N, 3))\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        d_min = np.min(dists)\n        d_max = np.max(dists)\n        if d_max < 1e-10:\n            return 0\n        return d_min / d_max\n\n    def energy(coords, k):\n        pts = coords.reshape((N, 3))\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 1e10\n        d_max = np.max(dists)\n        if d_max < 1e-10:\n            return 1e10\n        # Scale-invariant repulsion energy: minimizes the sum of (d_max/d_ij)^k\n        # This effectively pushes the minimum distance to be as large as possible relative to the maximum distance.\n        return np.sum((d_max / dists)**k)\n\n    best_pts = None\n    best_ratio = 0\n    \n    # Generate initial seeds based on common symmetric structures for N=14\n    seeds = []\n    \n    # Seed 1: Rhombic dodecahedron vertices (Cube + Octahedron, Oh symmetry)\n    c, s = 1.0, 2.0\n    cube = np.array([[c,c,c],[c,c,-c],[c,-c,c],[c,-c,-c],[-c,c,c],[-c,c,-c],[-c,-c,c],[-c,-c,-c]])\n    octa = np.array([[s,0,0],[-s,0,0],[0,s,0],[0,-s,0],[0,0,s],[0,0,-s]])\n    seed_co = np.vstack([cube, octa])\n    seeds.append(seed_co)\n    \n    # Seed 2: Hexagonal Prism + 2 axial points (D6h symmetry)\n    h, H = 1.0, 2.2\n    hex_p = []\n    for i in range(6):\n        angle = i * np.pi / 3\n        hex_p.append([np.cos(angle), np.sin(angle), h])\n        hex_p.append([np.cos(angle), np.sin(angle), -h])\n    hex_p.append([0, 0, H])\n    hex_p.append([0, 0, -H])\n    seeds.append(np.array(hex_p))\n\n    # Seed 3: Bi-capped hexagonal antiprism (D6d symmetry)\n    h_a, H_a = 0.6, 1.8\n    hex_a = []\n    for i in range(6):\n        angle1 = i * np.pi / 3\n        angle2 = i * np.pi / 3 + np.pi / 6\n        hex_a.append([np.cos(angle1), np.sin(angle1), h_a])\n        hex_a.append([np.cos(angle2), np.sin(angle2), -h_a])\n    hex_a.append([0, 0, H_a])\n    hex_a.append([0, 0, -H_a])\n    seeds.append(np.array(hex_a))\n\n    # Add slightly perturbed versions of the symmetric seeds to break symmetry if necessary\n    np.random.seed(42)\n    original_seeds_count = len(seeds)\n    for i in range(original_seeds_count):\n        seeds.append(seeds[i] + np.random.normal(0, 0.05, seeds[i].shape))\n    \n    # Fill the rest with random seeds\n    while len(seeds) < 20:\n        seeds.append(np.random.normal(size=(N, 3)))\n\n    # Optimization loop\n    for pts_init in seeds:\n        if time.time() - start_time > 54:\n            break\n        \n        # Step 1: Broad optimization using scale-invariant repulsion energy\n        # k=12 provides a smooth landscape to reach the vicinity of a good configuration.\n        res = minimize(energy, pts_init.flatten(), args=(12,), method='L-BFGS-B', options={'maxiter': 200})\n        # k=24 sharpens the minimum distance objective.\n        res = minimize(energy, res.x, args=(24,), method='L-BFGS-B', options={'maxiter': 200})\n        \n        # Step 2: Direct refinement of the ratio using the Nelder-Mead algorithm\n        # This handles the non-differentiable nature of min/max distances.\n        res = minimize(lambda x: -get_ratio(x), res.x, method='Nelder-Mead', \n                       tol=1e-9, options={'maxiter': 1000})\n        \n        current_ratio = -res.fun\n        if current_ratio > best_ratio:\n            best_ratio = current_ratio\n            best_pts = res.x.reshape((N, 3))\n            \n    # Normalize the final set to have a max distance of 1.0 for consistency\n    if best_pts is not None:\n        dists = pdist(best_pts)\n        best_pts /= np.max(dists)\n        \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9598474802569423,
    "min_max_ratio": 0.2304085682254855,
    "min_distance": 0.4800089251519033,
    "max_distance": 1.0,
    "eval_time": 6.912923097610474,
    "error": null
  },
  "prompt": "For 14 points, explore configurations with potential symmetries (e.g., D4h, Oh, or C2v). Start with a symmetric seed (like a cube plus an octahedron, or a dual of a deltahedron) and use an optimizer that maintains or slightly breaks symmetry to find the 1.000016+ configuration.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the ratio\n    of the minimum pairwise distance to the maximum pairwise distance.\n    The configuration is found by starting from several symmetric and random seeds\n    and refining them using a combination of a repulsion energy-based optimizer\n    (L-BFGS-B) and a direct ratio optimizer (Nelder-Mead).\n    \"\"\"\n    N = 14\n    start_time = time.time()\n    \n    def get_ratio(pts):\n        pts = pts.reshape((N, 3))\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 0\n        d_min = np.min(dists)\n        d_max = np.max(dists)\n        if d_max < 1e-10:\n            return 0\n        return d_min / d_max\n\n    def energy(coords, k):\n        pts = coords.reshape((N, 3))\n        dists = pdist(pts)\n        if len(dists) == 0:\n            return 1e10\n        d_max = np.max(dists)\n        if d_max < 1e-10:\n            return 1e10\n        # Scale-invariant repulsion energy: minimizes the sum of (d_max/d_ij)^k\n        # This effectively pushes the minimum distance to be as large as possible relative to the maximum distance.\n        return np.sum((d_max / dists)**k)\n\n    best_pts = None\n    best_ratio = 0\n    \n    # Generate initial seeds based on common symmetric structures for N=14\n    seeds = []\n    \n    # Seed 1: Rhombic dodecahedron vertices (Cube + Octahedron, Oh symmetry)\n    c, s = 1.0, 2.0\n    cube = np.array([[c,c,c],[c,c,-c],[c,-c,c],[c,-c,-c],[-c,c,c],[-c,c,-c],[-c,-c,c],[-c,-c,-c]])\n    octa = np.array([[s,0,0],[-s,0,0],[0,s,0],[0,-s,0],[0,0,s],[0,0,-s]])\n    seed_co = np.vstack([cube, octa])\n    seeds.append(seed_co)\n    \n    # Seed 2: Hexagonal Prism + 2 axial points (D6h symmetry)\n    h, H = 1.0, 2.2\n    hex_p = []\n    for i in range(6):\n        angle = i * np.pi / 3\n        hex_p.append([np.cos(angle), np.sin(angle), h])\n        hex_p.append([np.cos(angle), np.sin(angle), -h])\n    hex_p.append([0, 0, H])\n    hex_p.append([0, 0, -H])\n    seeds.append(np.array(hex_p))\n\n    # Seed 3: Bi-capped hexagonal antiprism (D6d symmetry)\n    h_a, H_a = 0.6, 1.8\n    hex_a = []\n    for i in range(6):\n        angle1 = i * np.pi / 3\n        angle2 = i * np.pi / 3 + np.pi / 6\n        hex_a.append([np.cos(angle1), np.sin(angle1), h_a])\n        hex_a.append([np.cos(angle2), np.sin(angle2), -h_a])\n    hex_a.append([0, 0, H_a])\n    hex_a.append([0, 0, -H_a])\n    seeds.append(np.array(hex_a))\n\n    # Add slightly perturbed versions of the symmetric seeds to break symmetry if necessary\n    np.random.seed(42)\n    original_seeds_count = len(seeds)\n    for i in range(original_seeds_count):\n        seeds.append(seeds[i] + np.random.normal(0, 0.05, seeds[i].shape))\n    \n    # Fill the rest with random seeds\n    while len(seeds) < 20:\n        seeds.append(np.random.normal(size=(N, 3)))\n\n    # Optimization loop\n    for pts_init in seeds:\n        if time.time() - start_time > 54:\n            break\n        \n        # Step 1: Broad optimization using scale-invariant repulsion energy\n        # k=12 provides a smooth landscape to reach the vicinity of a good configuration.\n        res = minimize(energy, pts_init.flatten(), args=(12,), method='L-BFGS-B', options={'maxiter': 200})\n        # k=24 sharpens the minimum distance objective.\n        res = minimize(energy, res.x, args=(24,), method='L-BFGS-B', options={'maxiter': 200})\n        \n        # Step 2: Direct refinement of the ratio using the Nelder-Mead algorithm\n        # This handles the non-differentiable nature of min/max distances.\n        res = minimize(lambda x: -get_ratio(x), res.x, method='Nelder-Mead', \n                       tol=1e-9, options={'maxiter': 1000})\n        \n        current_ratio = -res.fun\n        if current_ratio > best_ratio:\n            best_ratio = current_ratio\n            best_pts = res.x.reshape((N, 3))\n            \n    # Normalize the final set to have a max distance of 1.0 for consistency\n    if best_pts is not None:\n        dists = pdist(best_pts)\n        best_pts /= np.max(dists)\n        \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:32:28.898773",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 246,
        "candidates_token_count": 1439,
        "thoughts_token_count": 23820
      },
      "response_text_len": 4178
    }
  }
}