{
  "trial_id": "trial_4_12",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance)^2.\n    Uses multiple initializations including Fibonacci spiral on a sphere, a triakis octahedron variant,\n    and a capped hexagonal antiprism, followed by local optimization.\n    \"\"\"\n    N = 14\n    \n    # Helper to calculate pairwise squared distances\n    def get_dists_sq(pts):\n        pts = pts.reshape((N, 3))\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        return dists_sq\n\n    # The actual ratio squared: min(dist^2) / max(dist^2)\n    def get_score(pts):\n        dists_sq = get_dists_sq(pts)\n        idx = np.triu_indices(N, k=1)\n        d_sq_triu = dists_sq[idx]\n        return np.min(d_sq_triu) / np.max(d_sq_triu)\n\n    # Smooth objective for L-BFGS-B using Log-Sum-Exp for min and max\n    def objective(pts, k):\n        pts = pts.reshape((N, 3))\n        dists_sq = get_dists_sq(pts)\n        idx = np.triu_indices(N, k=1)\n        d_sq_triu = dists_sq[idx]\n        \n        # Log-Sum-Exp trick for smooth min: s_min = -1/k * log(sum(exp(-k * x)))\n        mk = -k\n        x_max_min = np.max(mk * d_sq_triu)\n        s_min = -(x_max_min + np.log(np.sum(np.exp(mk * d_sq_triu - x_max_min)))) / k\n        \n        # Log-Sum-Exp trick for smooth max: s_max = 1/k * log(sum(exp(k * x)))\n        x_max_max = np.max(k * d_sq_triu)\n        s_max = (x_max_max + np.log(np.sum(np.exp(k * d_sq_triu - x_max_max)))) / k\n        \n        # We want to maximize s_min/s_max, so minimize the negative ratio\n        return -s_min / s_max\n\n    best_pts = None\n    best_score = -1\n    inits = []\n    \n    # 1. Fibonacci spiral on a sphere\n    phi = np.pi * (3 - np.sqrt(5))  # golden angle\n    y_vals = np.linspace(1 - 1/N, -(1 - 1/N), N)\n    radius = np.sqrt(1 - y_vals*y_vals)\n    theta = phi * np.arange(N)\n    inits.append(np.column_stack((np.cos(theta) * radius, y_vals, np.sin(theta) * radius)))\n    \n    # 2. Triakis octahedron variant (cube vertices + pushed-out face centers)\n    cube = np.array([[x, y, z] for x in [-1, 1] for y in [-1, 1] for z in [-1, 1]])\n    # a=1.732 (approx sqrt(3)) balances some key distances\n    a = 1.732\n    centers = np.array([[a,0,0], [-a,0,0], [0,a,0], [0,-a,0], [0,0,a], [0,0,-a]])\n    inits.append(np.vstack((cube, centers)))\n    \n    # 3. Capped hexagonal antiprism\n    h = 0.6\n    angles = np.linspace(0, 2*np.pi, 6, endpoint=False)\n    hex1 = np.column_stack((np.cos(angles), np.sin(angles), np.full(6, h)))\n    hex2 = np.column_stack((np.cos(angles + np.pi/6), np.sin(angles + np.pi/6), np.full(6, -h)))\n    caps = np.array([[0, 0, 1.2], [0, 0, -1.2]])\n    inits.append(np.vstack((hex1, hex2, caps)))\n\n    # 4. Random initialization\n    np.random.seed(42)\n    inits.append(np.random.rand(N, 3) * 2 - 1)\n\n    # Run optimization for each initialization\n    for pts_init in inits:\n        try:\n            # Phase 1: Smooth optimization with increasing k for sharpness\n            res = minimize(objective, pts_init.flatten(), args=(25,), method='L-BFGS-B')\n            res = minimize(objective, res.x, args=(80,), method='L-BFGS-B')\n            \n            # Phase 2: Refine with Powell to handle the non-smooth min/max objective directly\n            res = minimize(lambda p: -get_score(p), res.x, method='Powell', \n                           tol=1e-7, options={'maxiter': 1000})\n            \n            score = get_score(res.x)\n            if score > best_score:\n                best_score = score\n                best_pts = res.x.reshape((N, 3))\n        except:\n            continue\n            \n    # Normalize the final set of points so max distance is 1 (optional, doesn't affect ratio)\n    dists_sq = get_dists_sq(best_pts)\n    max_d = np.sqrt(np.max(dists_sq))\n    final_pts = best_pts / max_d\n    \n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.9975236911635875,
    "min_max_ratio": 0.23945263198532132,
    "min_distance": 0.4893389745210586,
    "max_distance": 0.9999999999999999,
    "eval_time": 4.632342100143433,
    "error": null
  },
  "prompt": "Try a completely different initialization: 14 points sampled from a Fibonacci spiral on a sphere, then allow them to expand/contract in 3D space to maximize the min-max ratio.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance)^2.\n    Uses multiple initializations including Fibonacci spiral on a sphere, a triakis octahedron variant,\n    and a capped hexagonal antiprism, followed by local optimization.\n    \"\"\"\n    N = 14\n    \n    # Helper to calculate pairwise squared distances\n    def get_dists_sq(pts):\n        pts = pts.reshape((N, 3))\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        return dists_sq\n\n    # The actual ratio squared: min(dist^2) / max(dist^2)\n    def get_score(pts):\n        dists_sq = get_dists_sq(pts)\n        idx = np.triu_indices(N, k=1)\n        d_sq_triu = dists_sq[idx]\n        return np.min(d_sq_triu) / np.max(d_sq_triu)\n\n    # Smooth objective for L-BFGS-B using Log-Sum-Exp for min and max\n    def objective(pts, k):\n        pts = pts.reshape((N, 3))\n        dists_sq = get_dists_sq(pts)\n        idx = np.triu_indices(N, k=1)\n        d_sq_triu = dists_sq[idx]\n        \n        # Log-Sum-Exp trick for smooth min: s_min = -1/k * log(sum(exp(-k * x)))\n        mk = -k\n        x_max_min = np.max(mk * d_sq_triu)\n        s_min = -(x_max_min + np.log(np.sum(np.exp(mk * d_sq_triu - x_max_min)))) / k\n        \n        # Log-Sum-Exp trick for smooth max: s_max = 1/k * log(sum(exp(k * x)))\n        x_max_max = np.max(k * d_sq_triu)\n        s_max = (x_max_max + np.log(np.sum(np.exp(k * d_sq_triu - x_max_max)))) / k\n        \n        # We want to maximize s_min/s_max, so minimize the negative ratio\n        return -s_min / s_max\n\n    best_pts = None\n    best_score = -1\n    inits = []\n    \n    # 1. Fibonacci spiral on a sphere\n    phi = np.pi * (3 - np.sqrt(5))  # golden angle\n    y_vals = np.linspace(1 - 1/N, -(1 - 1/N), N)\n    radius = np.sqrt(1 - y_vals*y_vals)\n    theta = phi * np.arange(N)\n    inits.append(np.column_stack((np.cos(theta) * radius, y_vals, np.sin(theta) * radius)))\n    \n    # 2. Triakis octahedron variant (cube vertices + pushed-out face centers)\n    cube = np.array([[x, y, z] for x in [-1, 1] for y in [-1, 1] for z in [-1, 1]])\n    # a=1.732 (approx sqrt(3)) balances some key distances\n    a = 1.732\n    centers = np.array([[a,0,0], [-a,0,0], [0,a,0], [0,-a,0], [0,0,a], [0,0,-a]])\n    inits.append(np.vstack((cube, centers)))\n    \n    # 3. Capped hexagonal antiprism\n    h = 0.6\n    angles = np.linspace(0, 2*np.pi, 6, endpoint=False)\n    hex1 = np.column_stack((np.cos(angles), np.sin(angles), np.full(6, h)))\n    hex2 = np.column_stack((np.cos(angles + np.pi/6), np.sin(angles + np.pi/6), np.full(6, -h)))\n    caps = np.array([[0, 0, 1.2], [0, 0, -1.2]])\n    inits.append(np.vstack((hex1, hex2, caps)))\n\n    # 4. Random initialization\n    np.random.seed(42)\n    inits.append(np.random.rand(N, 3) * 2 - 1)\n\n    # Run optimization for each initialization\n    for pts_init in inits:\n        try:\n            # Phase 1: Smooth optimization with increasing k for sharpness\n            res = minimize(objective, pts_init.flatten(), args=(25,), method='L-BFGS-B')\n            res = minimize(objective, res.x, args=(80,), method='L-BFGS-B')\n            \n            # Phase 2: Refine with Powell to handle the non-smooth min/max objective directly\n            res = minimize(lambda p: -get_score(p), res.x, method='Powell', \n                           tol=1e-7, options={'maxiter': 1000})\n            \n            score = get_score(res.x)\n            if score > best_score:\n                best_score = score\n                best_pts = res.x.reshape((N, 3))\n        except:\n            continue\n            \n    # Normalize the final set of points so max distance is 1 (optional, doesn't affect ratio)\n    dists_sq = get_dists_sq(best_pts)\n    max_d = np.sqrt(np.max(dists_sq))\n    final_pts = best_pts / max_d\n    \n    return final_pts\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:31:58.380752",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 211,
        "candidates_token_count": 1435,
        "thoughts_token_count": 21341
      },
      "response_text_len": 3934
    }
  }
}