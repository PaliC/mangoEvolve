{
  "trial_id": "trial_4_11",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.special import logsumexp\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The approach uses a Fibonacci spiral on a sphere as the initial guess, followed by\n    multi-stage optimization (L-BFGS-B and Nelder-Mead) to refine the configuration.\n    \"\"\"\n    n = 14\n    \n    def get_ratio_sq(coords):\n        \"\"\"Calculates the squared ratio of the minimum distance to the maximum distance.\"\"\"\n        pts = coords.reshape((n, 3))\n        # Compute all pairwise squared distances\n        dist_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n        # Filter out self-distances (diagonal)\n        mask = ~np.eye(n, dtype=bool)\n        d_sq = dist_sq[mask]\n        min_d2 = np.min(d_sq)\n        max_d2 = np.max(d_sq)\n        return min_d2 / max_d2\n\n    def objective(coords):\n        \"\"\"Smooth objective function to maximize the min-max ratio using softmin/softmax.\"\"\"\n        pts = coords.reshape((n, 3))\n        dist_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n        mask = ~np.eye(n, dtype=bool)\n        d_sq = dist_sq[mask]\n        \n        # We use a sharp soft-min and soft-max to approximate the discrete min and max.\n        # k controls the sharpness of the approximation.\n        k = 50.0\n        # logsumexp trick is used for numerical stability when calculating softmin and softmax.\n        s_min = -1.0/k * logsumexp(-k * d_sq)\n        s_max = 1.0/k * logsumexp(k * d_sq)\n        \n        # We minimize the ratio of soft-max to soft-min to maximize the min-max ratio.\n        return s_max / s_min\n\n    def fibonacci_sphere(n):\n        \"\"\"Initializes n points approximately uniformly distributed on the surface of a sphere.\"\"\"\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))  # Golden angle\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2  # y goes from 1 to -1\n            radius = np.sqrt(max(0, 1 - y * y))\n            theta = phi * i\n            pts.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n        return np.array(pts)\n\n    best_pts = None\n    best_score = -1\n    \n    # Try multiple initializations: Fibonacci spiral, perturbed Fibonacci, and random points.\n    # This helps escape local optima and explore different regions of the configuration space.\n    for i in range(3):\n        if i == 0:\n            pts = fibonacci_sphere(n)\n        elif i == 1:\n            pts = fibonacci_sphere(n) + np.random.normal(0, 0.1, (n, 3))\n        else:\n            pts = np.random.uniform(-1, 1, (n, 3))\n        \n        # Optimization stage 1: Use L-BFGS-B on the smooth objective for fast convergence.\n        res = minimize(objective, pts.flatten(), method='L-BFGS-B', options={'maxiter': 800})\n        \n        # Optimization stage 2: Use Nelder-Mead on the actual non-smooth ratio for fine-tuning.\n        res = minimize(lambda x: -get_ratio_sq(x), res.x, method='Nelder-Mead', tol=1e-8, options={'maxiter': 1200})\n        \n        # Track the best configuration found across all initializations.\n        current_score = -res.fun\n        if current_score > best_score:\n            best_score = current_score\n            best_pts = res.x.reshape((n, 3))\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9926270206914677,
    "min_max_ratio": 0.23827720062173516,
    "min_distance": 431.6958029159033,
    "max_distance": 884.3752535856667,
    "eval_time": 3.5347397327423096,
    "error": null
  },
  "prompt": "Try a completely different initialization: 14 points sampled from a Fibonacci spiral on a sphere, then allow them to expand/contract in 3D space to maximize the min-max ratio.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.special import logsumexp\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The approach uses a Fibonacci spiral on a sphere as the initial guess, followed by\n    multi-stage optimization (L-BFGS-B and Nelder-Mead) to refine the configuration.\n    \"\"\"\n    n = 14\n    \n    def get_ratio_sq(coords):\n        \"\"\"Calculates the squared ratio of the minimum distance to the maximum distance.\"\"\"\n        pts = coords.reshape((n, 3))\n        # Compute all pairwise squared distances\n        dist_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n        # Filter out self-distances (diagonal)\n        mask = ~np.eye(n, dtype=bool)\n        d_sq = dist_sq[mask]\n        min_d2 = np.min(d_sq)\n        max_d2 = np.max(d_sq)\n        return min_d2 / max_d2\n\n    def objective(coords):\n        \"\"\"Smooth objective function to maximize the min-max ratio using softmin/softmax.\"\"\"\n        pts = coords.reshape((n, 3))\n        dist_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n        mask = ~np.eye(n, dtype=bool)\n        d_sq = dist_sq[mask]\n        \n        # We use a sharp soft-min and soft-max to approximate the discrete min and max.\n        # k controls the sharpness of the approximation.\n        k = 50.0\n        # logsumexp trick is used for numerical stability when calculating softmin and softmax.\n        s_min = -1.0/k * logsumexp(-k * d_sq)\n        s_max = 1.0/k * logsumexp(k * d_sq)\n        \n        # We minimize the ratio of soft-max to soft-min to maximize the min-max ratio.\n        return s_max / s_min\n\n    def fibonacci_sphere(n):\n        \"\"\"Initializes n points approximately uniformly distributed on the surface of a sphere.\"\"\"\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))  # Golden angle\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2  # y goes from 1 to -1\n            radius = np.sqrt(max(0, 1 - y * y))\n            theta = phi * i\n            pts.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n        return np.array(pts)\n\n    best_pts = None\n    best_score = -1\n    \n    # Try multiple initializations: Fibonacci spiral, perturbed Fibonacci, and random points.\n    # This helps escape local optima and explore different regions of the configuration space.\n    for i in range(3):\n        if i == 0:\n            pts = fibonacci_sphere(n)\n        elif i == 1:\n            pts = fibonacci_sphere(n) + np.random.normal(0, 0.1, (n, 3))\n        else:\n            pts = np.random.uniform(-1, 1, (n, 3))\n        \n        # Optimization stage 1: Use L-BFGS-B on the smooth objective for fast convergence.\n        res = minimize(objective, pts.flatten(), method='L-BFGS-B', options={'maxiter': 800})\n        \n        # Optimization stage 2: Use Nelder-Mead on the actual non-smooth ratio for fine-tuning.\n        res = minimize(lambda x: -get_ratio_sq(x), res.x, method='Nelder-Mead', tol=1e-8, options={'maxiter': 1200})\n        \n        # Track the best configuration found across all initializations.\n        current_score = -res.fun\n        if current_score > best_score:\n            best_score = current_score\n            best_pts = res.x.reshape((n, 3))\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:31:28.306500",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 211,
        "candidates_token_count": 1023,
        "thoughts_token_count": 16839
      },
      "response_text_len": 3357
    }
  }
}