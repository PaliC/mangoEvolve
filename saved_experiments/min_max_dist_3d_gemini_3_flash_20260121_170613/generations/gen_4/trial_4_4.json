{
  "trial_id": "trial_4_4",
  "generation": 4,
  "parent_id": "trial_3_6",
  "code": "import numpy as np\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio \n    (min pairwise distance / max pairwise distance)^2.\n    Uses a combination of repulsion-based optimization and \n    fine-grained coordinate descent.\n    \"\"\"\n    start_time = time.time()\n    N = 14\n    \n    def get_ratio_sq(p):\n        # Calculate all pairwise squared distances efficiently\n        diffs = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        dists_sq = np.sum(diffs**2, axis=-1)\n        # Extract upper triangle indices to avoid diagonal and double-counting\n        i, j = np.triu_indices(N, k=1)\n        d = dists_sq[i, j]\n        # Ratio of min squared distance to max squared distance\n        return np.min(d) / np.max(d)\n\n    best_pts = None\n    best_val = -1\n\n    # Precompute 26 directions for local coordinate descent (axial, diagonal, etc.)\n    directions = []\n    for x in [-1, 0, 1]:\n        for y in [-1, 0, 1]:\n            for z in [-1, 0, 1]:\n                if x == 0 and y == 0 and z == 0:\n                    continue\n                d = np.array([x, y, z], dtype=float)\n                directions.append(d / np.linalg.norm(d))\n    directions = np.array(directions)\n\n    # Diverse initial configurations to avoid local optima\n    inits = []\n    # 1. Random uniform initialization\n    inits.append(np.random.uniform(-0.5, 0.5, (N, 3)))\n    # 2. Random points on a unit sphere\n    pts_sphere = np.random.normal(0, 1, (N, 3))\n    pts_sphere /= np.linalg.norm(pts_sphere, axis=1)[:, None]\n    inits.append(pts_sphere)\n    # 3. Hexagonal structure (gyroelongated hexagonal bipyramid-like)\n    h1, h2, r = 0.2, 0.5, 0.4\n    pts_hex = [[0, 0, h2], [0, 0, -h2]]\n    for k in range(6):\n        pts_hex.append([r * np.cos(2 * np.pi * k / 6), r * np.sin(2 * np.pi * k / 6), h1])\n        pts_hex.append([r * np.cos(2 * np.pi * k / 6 + np.pi / 6), r * np.sin(2 * np.pi * k / 6 + np.pi / 6), -h1])\n    inits.append(np.array(pts_hex))\n    # 4. Cube-octahedron structure (cube vertices + face centers)\n    s, t = 0.4, 0.6\n    pts_cube = [[s, s, s], [s, s, -s], [s, -s, s], [s, -s, -s], \n                [-s, s, s], [-s, s, -s], [-s, -s, s], [-s, -s, -s],\n                [t, 0, 0], [-t, 0, 0], [0, t, 0], [0, -t, 0], [0, 0, t], [0, 0, -t]]\n    inits.append(np.array(pts_cube))\n\n    idx = 0\n    # Optimization loop: continues until time runs out (55 seconds)\n    while time.time() - start_time < 55:\n        if idx < len(inits):\n            pts = inits[idx].copy()\n        else:\n            # Subsequent starts are random\n            pts = np.random.uniform(-0.5, 0.5, (N, 3))\n        idx += 1\n        \n        # Phase 1: Repulsion-based spreading\n        # Points repel each other using a 1/d^3 force to establish a good layout\n        for _ in range(200):\n            dists_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n            np.fill_diagonal(dists_sq, np.inf)\n            forces = np.zeros((N, 3))\n            for i in range(N):\n                diff = pts[i] - pts  # Vector from every j to i\n                d2 = dists_sq[i][:, np.newaxis]\n                # Repulsion force proportional to 1/d^4 (potential 1/d^3)\n                forces[i] = np.sum(diff / (d2**2), axis=0)\n            pts += 0.01 * forces\n            # Normalize diameter to keep configuration scale-invariant\n            d_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n            pts /= np.sqrt(np.max(d_sq))\n\n        # Phase 2: Fine-grained coordinate descent\n        # Iteratively move each point in small steps to maximize the min/max ratio\n        for step_size in [0.01, 0.003, 0.001, 0.0003, 0.0001, 0.00003]:\n            if time.time() - start_time > 55:\n                break\n            for cycle in range(50):\n                improved_any = False\n                for i in range(N):\n                    current_val = get_ratio_sq(pts)\n                    best_p_i = pts[i].copy()\n                    # Search around the current point in 26 directions\n                    for d in directions:\n                        pts[i] = best_p_i + d * step_size\n                        val = get_ratio_sq(pts)\n                        if val > current_val:\n                            current_val = val\n                            best_p_i = pts[i].copy()\n                            improved_any = True\n                        else:\n                            pts[i] = best_p_i\n                # If no point moved in this cycle, move to a smaller step size\n                if not improved_any:\n                    break\n        \n        # Evaluate final configuration for this initialization\n        final_val = get_ratio_sq(pts)\n        if final_val > best_val:\n            best_val = final_val\n            best_pts = pts.copy()\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9750190058510569,
    "min_max_ratio": 0.23405044838023728,
    "min_distance": 0.4772143344488303,
    "max_distance": 0.9864128966026773,
    "eval_time": 55.070395946502686,
    "error": null
  },
  "prompt": "Starting from trial_3_6, implement a fine-grained coordinate descent. For each point, perform a local grid search or a small-scale optimization (like golden-section search) in 3D to move it to a position that maximizes the overall minimum distance. Repeat this for all 14 points for several cycles.",
  "response": "```python\nimport numpy as np\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio \n    (min pairwise distance / max pairwise distance)^2.\n    Uses a combination of repulsion-based optimization and \n    fine-grained coordinate descent.\n    \"\"\"\n    start_time = time.time()\n    N = 14\n    \n    def get_ratio_sq(p):\n        # Calculate all pairwise squared distances efficiently\n        diffs = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        dists_sq = np.sum(diffs**2, axis=-1)\n        # Extract upper triangle indices to avoid diagonal and double-counting\n        i, j = np.triu_indices(N, k=1)\n        d = dists_sq[i, j]\n        # Ratio of min squared distance to max squared distance\n        return np.min(d) / np.max(d)\n\n    best_pts = None\n    best_val = -1\n\n    # Precompute 26 directions for local coordinate descent (axial, diagonal, etc.)\n    directions = []\n    for x in [-1, 0, 1]:\n        for y in [-1, 0, 1]:\n            for z in [-1, 0, 1]:\n                if x == 0 and y == 0 and z == 0:\n                    continue\n                d = np.array([x, y, z], dtype=float)\n                directions.append(d / np.linalg.norm(d))\n    directions = np.array(directions)\n\n    # Diverse initial configurations to avoid local optima\n    inits = []\n    # 1. Random uniform initialization\n    inits.append(np.random.uniform(-0.5, 0.5, (N, 3)))\n    # 2. Random points on a unit sphere\n    pts_sphere = np.random.normal(0, 1, (N, 3))\n    pts_sphere /= np.linalg.norm(pts_sphere, axis=1)[:, None]\n    inits.append(pts_sphere)\n    # 3. Hexagonal structure (gyroelongated hexagonal bipyramid-like)\n    h1, h2, r = 0.2, 0.5, 0.4\n    pts_hex = [[0, 0, h2], [0, 0, -h2]]\n    for k in range(6):\n        pts_hex.append([r * np.cos(2 * np.pi * k / 6), r * np.sin(2 * np.pi * k / 6), h1])\n        pts_hex.append([r * np.cos(2 * np.pi * k / 6 + np.pi / 6), r * np.sin(2 * np.pi * k / 6 + np.pi / 6), -h1])\n    inits.append(np.array(pts_hex))\n    # 4. Cube-octahedron structure (cube vertices + face centers)\n    s, t = 0.4, 0.6\n    pts_cube = [[s, s, s], [s, s, -s], [s, -s, s], [s, -s, -s], \n                [-s, s, s], [-s, s, -s], [-s, -s, s], [-s, -s, -s],\n                [t, 0, 0], [-t, 0, 0], [0, t, 0], [0, -t, 0], [0, 0, t], [0, 0, -t]]\n    inits.append(np.array(pts_cube))\n\n    idx = 0\n    # Optimization loop: continues until time runs out (55 seconds)\n    while time.time() - start_time < 55:\n        if idx < len(inits):\n            pts = inits[idx].copy()\n        else:\n            # Subsequent starts are random\n            pts = np.random.uniform(-0.5, 0.5, (N, 3))\n        idx += 1\n        \n        # Phase 1: Repulsion-based spreading\n        # Points repel each other using a 1/d^3 force to establish a good layout\n        for _ in range(200):\n            dists_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n            np.fill_diagonal(dists_sq, np.inf)\n            forces = np.zeros((N, 3))\n            for i in range(N):\n                diff = pts[i] - pts  # Vector from every j to i\n                d2 = dists_sq[i][:, np.newaxis]\n                # Repulsion force proportional to 1/d^4 (potential 1/d^3)\n                forces[i] = np.sum(diff / (d2**2), axis=0)\n            pts += 0.01 * forces\n            # Normalize diameter to keep configuration scale-invariant\n            d_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n            pts /= np.sqrt(np.max(d_sq))\n\n        # Phase 2: Fine-grained coordinate descent\n        # Iteratively move each point in small steps to maximize the min/max ratio\n        for step_size in [0.01, 0.003, 0.001, 0.0003, 0.0001, 0.00003]:\n            if time.time() - start_time > 55:\n                break\n            for cycle in range(50):\n                improved_any = False\n                for i in range(N):\n                    current_val = get_ratio_sq(pts)\n                    best_p_i = pts[i].copy()\n                    # Search around the current point in 26 directions\n                    for d in directions:\n                        pts[i] = best_p_i + d * step_size\n                        val = get_ratio_sq(pts)\n                        if val > current_val:\n                            current_val = val\n                            best_p_i = pts[i].copy()\n                            improved_any = True\n                        else:\n                            pts[i] = best_p_i\n                # If no point moved in this cycle, move to a smaller step size\n                if not improved_any:\n                    break\n        \n        # Evaluate final configuration for this initialization\n        final_val = get_ratio_sq(pts)\n        if final_val > best_val:\n            best_val = final_val\n            best_pts = pts.copy()\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:34:47.258216",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 239,
        "candidates_token_count": 1597,
        "thoughts_token_count": 19534
      },
      "response_text_len": 4832
    }
  }
}