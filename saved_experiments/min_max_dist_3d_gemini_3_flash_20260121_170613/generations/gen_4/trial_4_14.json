{
  "trial_id": "trial_4_14",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio:\n    (min_dist / max_dist)^2\n    \n    Uses a constrained optimizer (SLSQP) to maximize min_dist (t) \n    subject to max_dist <= 1.\n    \"\"\"\n    N = 14\n    \n    # Precompute indices for all unique pairs\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_pairs = len(idx_i) # 91 for N=14\n\n    # --- Helper Functions ---\n\n    def get_dist_sq(flat_x):\n        \"\"\"Calculates squared distances for all pairs.\"\"\"\n        X = flat_x.reshape((N, 3))\n        # Vectorized difference: shape (num_pairs, 3)\n        diff = X[idx_i] - X[idx_j]\n        return np.sum(diff**2, axis=1)\n\n    def objective(x):\n        \"\"\"\n        Objective: Maximize t (the minimum squared distance target).\n        Since minimize is used, we minimize -t.\n        x = [x_1, y_1, z_1, ..., x_14, z_14, t]\n        \"\"\"\n        return -x[-1]\n\n    def objective_grad(x):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros_like(x)\n        grad[-1] = -1.0\n        return grad\n\n    def constraints(x):\n        \"\"\"\n        Constraints vector (must be >= 0):\n        1. dist_sq_ij >= t   => dist_sq_ij - t >= 0\n        2. dist_sq_ij <= 1   => 1 - dist_sq_ij >= 0\n        \"\"\"\n        X_flat = x[:-1]\n        t = x[-1]\n        d2 = get_dist_sq(X_flat)\n        return np.concatenate([d2 - t, 1.0 - d2])\n\n    def jacobian(x):\n        \"\"\"\n        Analytic Jacobian of the constraints.\n        Crucial for performance with 182 constraints.\n        \"\"\"\n        X = x[:-1].reshape((N, 3))\n        \n        diff = X[idx_i] - X[idx_j]\n        scaled_diff = 2 * diff # Gradient of d^2 w.r.t coord is 2*(xi-xj)\n        \n        jac = np.zeros((2 * num_pairs, 3 * N + 1))\n        \n        # Constraint 1: d2 - t >= 0\n        # deriv w.r.t t is -1\n        jac[:num_pairs, -1] = -1.0\n        \n        # deriv w.r.t coordinates\n        # We fill the matrix. Although a Python loop, 91 iters is very fast.\n        for k in range(num_pairs):\n            u, v = idx_i[k], idx_j[k]\n            # Deriv w.r.t X_u is  2(Xu - Xv)\n            jac[k, 3*u:3*u+3] = scaled_diff[k]\n            # Deriv w.r.t X_v is -2(Xu - Xv)\n            jac[k, 3*v:3*v+3] = -scaled_diff[k]\n            \n        # Constraint 2: 1 - d2 >= 0\n        # deriv w.r.t t is 0\n        # deriv w.r.t coords is negative of Constraint 1\n        jac[num_pairs:, :-1] = -jac[:num_pairs, :-1]\n        \n        return jac\n\n    # --- Initialization Strategies ---\n    \n    configs = []\n\n    # 1. Fibonacci Sphere (Uniform distribution on sphere surface)\n    indices = np.arange(0, N, dtype=float) + 0.5\n    phi = np.arccos(1 - 2*indices/N)\n    theta = np.pi * (1 + 5**0.5) * indices\n    fib_pts = np.column_stack((np.cos(theta)*np.sin(phi), np.sin(theta)*np.sin(phi), np.cos(phi)))\n    configs.append(fib_pts)\n    \n    # 2. FCC-like Cluster (Center + 12 neighbors + 1 extra)\n    fcc = [[0,0,0]]\n    for x in [-1, 1]:\n        for y in [-1, 1]:\n            fcc.append([x, y, 0])\n            fcc.append([x, 0, y])\n            fcc.append([0, x, y])\n    fcc = np.array(fcc) # 13 points\n    # Add 14th point roughly in a gap\n    fcc = np.vstack([fcc, [0, 0, 2.0]]) \n    configs.append(fcc)\n\n    # 3. Random Clouds\n    for _ in range(8):\n        configs.append(np.random.randn(N, 3))\n\n    # --- Optimization Loop ---\n\n    best_ratio_sq = -1.0\n    best_points = fib_pts # Default fallback\n    \n    start_time = time.time()\n    time_limit = 55 # Leave buffer for final refinement\n\n    for pts in configs:\n        if time.time() - start_time > time_limit:\n            break\n            \n        # Normalize initialization to satisfy max_dist ~ 1\n        d2 = np.sum((pts[idx_i] - pts[idx_j])**2, axis=1)\n        max_d = np.max(d2) if np.max(d2) > 1e-9 else 1.0\n        pts = pts / np.sqrt(max_d)\n        \n        # Initial guess for t (min dist sq)\n        d2 = np.sum((pts[idx_i] - pts[idx_j])**2, axis=1)\n        t_init = np.min(d2) * 0.9 # Start slightly feasible\n        \n        x0 = np.concatenate([pts.flatten(), [t_init]])\n        \n        try:\n            # First pass: Coarse optimization\n            res = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                jac=jacobian,\n                constraints={'type': 'ineq', 'fun': constraints},\n                options={'maxiter': 150, 'ftol': 1e-4}\n            )\n            \n            # Evaluate result\n            X_res = res.x[:-1].reshape((N, 3))\n            d2_res = np.sum((X_res[idx_i] - X_res[idx_j])**2, axis=1)\n            mn = np.min(d2_res)\n            mx = np.max(d2_res)\n            \n            if mx > 1e-9:\n                ratio_sq = mn / mx\n                if ratio_sq > best_ratio_sq:\n                    best_ratio_sq = ratio_sq\n                    best_points = X_res\n        except Exception:\n            continue\n\n    # --- Final Refinement ---\n    # Run a tighter optimization on the best candidate found\n    if time.time() - start_time < 58:\n        d2 = np.sum((best_points[idx_i] - best_points[idx_j])**2, axis=1)\n        max_d = np.max(d2)\n        if max_d > 1e-9:\n            best_points = best_points / np.sqrt(max_d) # Ensure max_dist is exactly 1\n            t_init = np.min(d2) / max_d\n            x0 = np.concatenate([best_points.flatten(), [t_init]])\n            \n            try:\n                res = minimize(\n                    objective,\n                    x0,\n                    method='SLSQP',\n                    jac=jacobian,\n                    constraints={'type': 'ineq', 'fun': constraints},\n                    options={'maxiter': 500, 'ftol': 1e-7}\n                )\n                best_points = res.x[:-1].reshape((N, 3))\n            except Exception:\n                pass\n\n    return best_points",
  "metrics": {
    "valid": true,
    "score": 0.7174870661191572,
    "min_max_ratio": 0.17223066270962747,
    "min_distance": 0.41500682248563997,
    "max_distance": 1.0,
    "eval_time": 0.2307138442993164,
    "error": null
  },
  "prompt": "Focus on the 'critical' pairs. Identify the pairs of points that currently define the minimum distance and the maximum distance. Use a constrained optimizer where you explicitly try to increase the distance of the closest pairs while keeping the furthest pairs from getting further apart.",
  "response": "Here is the Python solution using `scipy.optimize` with a constrained formulation that explicitly manages the critical pairs (closest and furthest points).\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio:\n    (min_dist / max_dist)^2\n    \n    Uses a constrained optimizer (SLSQP) to maximize min_dist (t) \n    subject to max_dist <= 1.\n    \"\"\"\n    N = 14\n    \n    # Precompute indices for all unique pairs\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_pairs = len(idx_i) # 91 for N=14\n\n    # --- Helper Functions ---\n\n    def get_dist_sq(flat_x):\n        \"\"\"Calculates squared distances for all pairs.\"\"\"\n        X = flat_x.reshape((N, 3))\n        # Vectorized difference: shape (num_pairs, 3)\n        diff = X[idx_i] - X[idx_j]\n        return np.sum(diff**2, axis=1)\n\n    def objective(x):\n        \"\"\"\n        Objective: Maximize t (the minimum squared distance target).\n        Since minimize is used, we minimize -t.\n        x = [x_1, y_1, z_1, ..., x_14, z_14, t]\n        \"\"\"\n        return -x[-1]\n\n    def objective_grad(x):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros_like(x)\n        grad[-1] = -1.0\n        return grad\n\n    def constraints(x):\n        \"\"\"\n        Constraints vector (must be >= 0):\n        1. dist_sq_ij >= t   => dist_sq_ij - t >= 0\n        2. dist_sq_ij <= 1   => 1 - dist_sq_ij >= 0\n        \"\"\"\n        X_flat = x[:-1]\n        t = x[-1]\n        d2 = get_dist_sq(X_flat)\n        return np.concatenate([d2 - t, 1.0 - d2])\n\n    def jacobian(x):\n        \"\"\"\n        Analytic Jacobian of the constraints.\n        Crucial for performance with 182 constraints.\n        \"\"\"\n        X = x[:-1].reshape((N, 3))\n        \n        diff = X[idx_i] - X[idx_j]\n        scaled_diff = 2 * diff # Gradient of d^2 w.r.t coord is 2*(xi-xj)\n        \n        jac = np.zeros((2 * num_pairs, 3 * N + 1))\n        \n        # Constraint 1: d2 - t >= 0\n        # deriv w.r.t t is -1\n        jac[:num_pairs, -1] = -1.0\n        \n        # deriv w.r.t coordinates\n        # We fill the matrix. Although a Python loop, 91 iters is very fast.\n        for k in range(num_pairs):\n            u, v = idx_i[k], idx_j[k]\n            # Deriv w.r.t X_u is  2(Xu - Xv)\n            jac[k, 3*u:3*u+3] = scaled_diff[k]\n            # Deriv w.r.t X_v is -2(Xu - Xv)\n            jac[k, 3*v:3*v+3] = -scaled_diff[k]\n            \n        # Constraint 2: 1 - d2 >= 0\n        # deriv w.r.t t is 0\n        # deriv w.r.t coords is negative of Constraint 1\n        jac[num_pairs:, :-1] = -jac[:num_pairs, :-1]\n        \n        return jac\n\n    # --- Initialization Strategies ---\n    \n    configs = []\n\n    # 1. Fibonacci Sphere (Uniform distribution on sphere surface)\n    indices = np.arange(0, N, dtype=float) + 0.5\n    phi = np.arccos(1 - 2*indices/N)\n    theta = np.pi * (1 + 5**0.5) * indices\n    fib_pts = np.column_stack((np.cos(theta)*np.sin(phi), np.sin(theta)*np.sin(phi), np.cos(phi)))\n    configs.append(fib_pts)\n    \n    # 2. FCC-like Cluster (Center + 12 neighbors + 1 extra)\n    fcc = [[0,0,0]]\n    for x in [-1, 1]:\n        for y in [-1, 1]:\n            fcc.append([x, y, 0])\n            fcc.append([x, 0, y])\n            fcc.append([0, x, y])\n    fcc = np.array(fcc) # 13 points\n    # Add 14th point roughly in a gap\n    fcc = np.vstack([fcc, [0, 0, 2.0]]) \n    configs.append(fcc)\n\n    # 3. Random Clouds\n    for _ in range(8):\n        configs.append(np.random.randn(N, 3))\n\n    # --- Optimization Loop ---\n\n    best_ratio_sq = -1.0\n    best_points = fib_pts # Default fallback\n    \n    start_time = time.time()\n    time_limit = 55 # Leave buffer for final refinement\n\n    for pts in configs:\n        if time.time() - start_time > time_limit:\n            break\n            \n        # Normalize initialization to satisfy max_dist ~ 1\n        d2 = np.sum((pts[idx_i] - pts[idx_j])**2, axis=1)\n        max_d = np.max(d2) if np.max(d2) > 1e-9 else 1.0\n        pts = pts / np.sqrt(max_d)\n        \n        # Initial guess for t (min dist sq)\n        d2 = np.sum((pts[idx_i] - pts[idx_j])**2, axis=1)\n        t_init = np.min(d2) * 0.9 # Start slightly feasible\n        \n        x0 = np.concatenate([pts.flatten(), [t_init]])\n        \n        try:\n            # First pass: Coarse optimization\n            res = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                jac=jacobian,\n                constraints={'type': 'ineq', 'fun': constraints},\n                options={'maxiter': 150, 'ftol': 1e-4}\n            )\n            \n            # Evaluate result\n            X_res = res.x[:-1].reshape((N, 3))\n            d2_res = np.sum((X_res[idx_i] - X_res[idx_j])**2, axis=1)\n            mn = np.min(d2_res)\n            mx = np.max(d2_res)\n            \n            if mx > 1e-9:\n                ratio_sq = mn / mx\n                if ratio_sq > best_ratio_sq:\n                    best_ratio_sq = ratio_sq\n                    best_points = X_res\n        except Exception:\n            continue\n\n    # --- Final Refinement ---\n    # Run a tighter optimization on the best candidate found\n    if time.time() - start_time < 58:\n        d2 = np.sum((best_points[idx_i] - best_points[idx_j])**2, axis=1)\n        max_d = np.max(d2)\n        if max_d > 1e-9:\n            best_points = best_points / np.sqrt(max_d) # Ensure max_dist is exactly 1\n            t_init = np.min(d2) / max_d\n            x0 = np.concatenate([best_points.flatten(), [t_init]])\n            \n            try:\n                res = minimize(\n                    objective,\n                    x0,\n                    method='SLSQP',\n                    jac=jacobian,\n                    constraints={'type': 'ineq', 'fun': constraints},\n                    options={'maxiter': 500, 'ftol': 1e-7}\n                )\n                best_points = res.x[:-1].reshape((N, 3))\n            except Exception:\n                pass\n\n    return best_points\n```",
  "reasoning": "Here is the Python solution using `scipy.optimize` with a constrained formulation that explicitly manages the critical pairs (closest and furthest points).",
  "timestamp": "2026-01-21T17:31:50.901994",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 222,
        "candidates_token_count": 2029,
        "thoughts_token_count": 12230
      },
      "response_text_len": 6006
    }
  }
}