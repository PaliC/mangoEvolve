{
  "trial_id": "trial_4_9",
  "generation": 4,
  "parent_id": "trial_3_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef fibonacci_sphere(n):\n    \"\"\"Generates n points approximately evenly distributed on a unit sphere.\"\"\"\n    pts = []\n    phi = np.pi * (3. - np.sqrt(5.))\n    for i in range(n):\n        y = 1 - (i / float(n - 1)) * 2\n        radius = np.sqrt(max(0.0, 1 - y * y))\n        theta = phi * i\n        pts.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    return np.array(pts)\n\ndef rhombic_dodecahedron():\n    \"\"\"Generates 14 points corresponding to the vertices of a rhombic dodecahedron (cube + octahedron).\"\"\"\n    a = 1.0 / np.sqrt(3)\n    cube = np.array([[i, j, k] for i in [-a, a] for j in [-a, a] for k in [-a, a]])\n    octa = np.array([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]])\n    return np.vstack([cube, octa])\n\ndef align(p1, p2):\n    \"\"\"Aligns p2 to p1 using the Kabsch algorithm (Procrustes analysis).\"\"\"\n    C = np.dot(p1.T, p2)\n    U, S, Vh = np.linalg.svd(C)\n    R = np.dot(U, Vh)\n    return np.dot(p2, R.T)\n\ndef get_score(pts):\n    \"\"\"Calculates the squared ratio of (min pairwise distance / max pairwise distance).\"\"\"\n    dists_sq = np.sum((pts[:, None] - pts[None, :])**2, axis=-1)\n    mask = np.triu_indices(len(pts), k=1)\n    upper = dists_sq[mask]\n    return np.min(upper) / np.max(upper)\n\ndef refine(pts_init, maxiter=200):\n    \"\"\"Refines point coordinates using SLSQP to maximize the min/max distance ratio.\"\"\"\n    N = 14\n    mask = np.triu_indices(N, k=1)\n    \n    # Scale initial points so max pairwise distance squared is 1.0\n    dists_sq_init = np.sum((pts_init[:, None] - pts_init[None, :])**2, axis=-1)\n    max_d2 = np.max(dists_sq_init)\n    if max_d2 < 1e-9: max_d2 = 1.0\n    pts_init = pts_init / np.sqrt(max_d2)\n    s0 = np.min(dists_sq_init[mask]) / max_d2\n    \n    def obj(x):\n        # Minimize -s (maximize min distance squared)\n        return -x[-1]\n    \n    def cons(x):\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        dists_sq = np.sum((pts[:, None] - pts[None, :])**2, axis=-1)\n        upper = dists_sq[mask]\n        # Constraints: pairwise dists >= s and pairwise dists <= 1.0\n        return np.concatenate([upper - s, 1.0 - upper])\n\n    # Initial guess: flattened points + initial min distance squared\n    x0 = np.concatenate([pts_init.flatten(), [s0]])\n    # Add a tiny bit of noise to help escape local saddle points\n    x0 += np.random.normal(0, 1e-7, x0.shape)\n    \n    res = minimize(obj, x0, method='SLSQP', constraints={'type': 'ineq', 'fun': cons},\n                   options={'maxiter': maxiter, 'ftol': 1e-7})\n    \n    return res.x[:-1].reshape((N, 3))\n\ndef min_max_dist_dim3_14():\n    \"\"\"Main entry function to find the optimal 14 points in 3D space.\"\"\"\n    # 1. Generate primary starting configurations\n    p_fib = fibonacci_sphere(14)\n    p_rho = rhombic_dodecahedron()\n    \n    # 2. Refine primary starts\n    p_fib_ref = refine(p_fib, maxiter=100)\n    p_rho_ref = refine(p_rho, maxiter=100)\n    \n    # 3. Combine primary starts (average and normalize as requested)\n    # Sort points to establish a rough correspondence before alignment\n    p_fib_s = p_fib_ref[np.lexsort(p_fib_ref.T)]\n    p_rho_s = p_rho_ref[np.lexsort(p_rho_ref.T)]\n    p_rho_aligned = align(p_fib_s, p_rho_s)\n    \n    p_avg = (p_fib_s + p_rho_aligned) / 2.0\n    norms = np.linalg.norm(p_avg, axis=1)[:, np.newaxis]\n    p_avg = np.divide(p_avg, norms, out=p_avg, where=norms > 1e-9)\n    \n    # 4. Refine the averaged configuration and a random one\n    p_avg_ref = refine(p_avg, maxiter=200)\n    \n    p_rand = np.random.normal(0, 1, (14, 3))\n    norms_r = np.linalg.norm(p_rand, axis=1)[:, np.newaxis]\n    p_rand = np.divide(p_rand, norms_r, out=p_rand, where=norms_r > 1e-9)\n    p_rand_ref = refine(p_rand, maxiter=200)\n    \n    # 5. Select the best result found\n    best_pts = p_fib_ref\n    best_s = get_score(p_fib_ref)\n    for p in [p_rho_ref, p_avg_ref, p_rand_ref]:\n        s = get_score(p)\n        if s > best_s:\n            best_s = s\n            best_pts = p\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9412488659581957,
    "min_max_ratio": 0.22594402549375364,
    "min_distance": 0.47533569768547207,
    "max_distance": 1.0000000000008429,
    "eval_time": 0.311535120010376,
    "error": null
  },
  "prompt": "Combine the best features of trial_3_6 and trial_3_4. Average their coordinates, normalize, and then run a multi-start SLSQP refinement.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef fibonacci_sphere(n):\n    \"\"\"Generates n points approximately evenly distributed on a unit sphere.\"\"\"\n    pts = []\n    phi = np.pi * (3. - np.sqrt(5.))\n    for i in range(n):\n        y = 1 - (i / float(n - 1)) * 2\n        radius = np.sqrt(max(0.0, 1 - y * y))\n        theta = phi * i\n        pts.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    return np.array(pts)\n\ndef rhombic_dodecahedron():\n    \"\"\"Generates 14 points corresponding to the vertices of a rhombic dodecahedron (cube + octahedron).\"\"\"\n    a = 1.0 / np.sqrt(3)\n    cube = np.array([[i, j, k] for i in [-a, a] for j in [-a, a] for k in [-a, a]])\n    octa = np.array([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]])\n    return np.vstack([cube, octa])\n\ndef align(p1, p2):\n    \"\"\"Aligns p2 to p1 using the Kabsch algorithm (Procrustes analysis).\"\"\"\n    C = np.dot(p1.T, p2)\n    U, S, Vh = np.linalg.svd(C)\n    R = np.dot(U, Vh)\n    return np.dot(p2, R.T)\n\ndef get_score(pts):\n    \"\"\"Calculates the squared ratio of (min pairwise distance / max pairwise distance).\"\"\"\n    dists_sq = np.sum((pts[:, None] - pts[None, :])**2, axis=-1)\n    mask = np.triu_indices(len(pts), k=1)\n    upper = dists_sq[mask]\n    return np.min(upper) / np.max(upper)\n\ndef refine(pts_init, maxiter=200):\n    \"\"\"Refines point coordinates using SLSQP to maximize the min/max distance ratio.\"\"\"\n    N = 14\n    mask = np.triu_indices(N, k=1)\n    \n    # Scale initial points so max pairwise distance squared is 1.0\n    dists_sq_init = np.sum((pts_init[:, None] - pts_init[None, :])**2, axis=-1)\n    max_d2 = np.max(dists_sq_init)\n    if max_d2 < 1e-9: max_d2 = 1.0\n    pts_init = pts_init / np.sqrt(max_d2)\n    s0 = np.min(dists_sq_init[mask]) / max_d2\n    \n    def obj(x):\n        # Minimize -s (maximize min distance squared)\n        return -x[-1]\n    \n    def cons(x):\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        dists_sq = np.sum((pts[:, None] - pts[None, :])**2, axis=-1)\n        upper = dists_sq[mask]\n        # Constraints: pairwise dists >= s and pairwise dists <= 1.0\n        return np.concatenate([upper - s, 1.0 - upper])\n\n    # Initial guess: flattened points + initial min distance squared\n    x0 = np.concatenate([pts_init.flatten(), [s0]])\n    # Add a tiny bit of noise to help escape local saddle points\n    x0 += np.random.normal(0, 1e-7, x0.shape)\n    \n    res = minimize(obj, x0, method='SLSQP', constraints={'type': 'ineq', 'fun': cons},\n                   options={'maxiter': maxiter, 'ftol': 1e-7})\n    \n    return res.x[:-1].reshape((N, 3))\n\ndef min_max_dist_dim3_14():\n    \"\"\"Main entry function to find the optimal 14 points in 3D space.\"\"\"\n    # 1. Generate primary starting configurations\n    p_fib = fibonacci_sphere(14)\n    p_rho = rhombic_dodecahedron()\n    \n    # 2. Refine primary starts\n    p_fib_ref = refine(p_fib, maxiter=100)\n    p_rho_ref = refine(p_rho, maxiter=100)\n    \n    # 3. Combine primary starts (average and normalize as requested)\n    # Sort points to establish a rough correspondence before alignment\n    p_fib_s = p_fib_ref[np.lexsort(p_fib_ref.T)]\n    p_rho_s = p_rho_ref[np.lexsort(p_rho_ref.T)]\n    p_rho_aligned = align(p_fib_s, p_rho_s)\n    \n    p_avg = (p_fib_s + p_rho_aligned) / 2.0\n    norms = np.linalg.norm(p_avg, axis=1)[:, np.newaxis]\n    p_avg = np.divide(p_avg, norms, out=p_avg, where=norms > 1e-9)\n    \n    # 4. Refine the averaged configuration and a random one\n    p_avg_ref = refine(p_avg, maxiter=200)\n    \n    p_rand = np.random.normal(0, 1, (14, 3))\n    norms_r = np.linalg.norm(p_rand, axis=1)[:, np.newaxis]\n    p_rand = np.divide(p_rand, norms_r, out=p_rand, where=norms_r > 1e-9)\n    p_rand_ref = refine(p_rand, maxiter=200)\n    \n    # 5. Select the best result found\n    best_pts = p_fib_ref\n    best_s = get_score(p_fib_ref)\n    for p in [p_rho_ref, p_avg_ref, p_rand_ref]:\n        s = get_score(p)\n        if s > best_s:\n            best_s = s\n            best_pts = p\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:34:36.111749",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 206,
        "candidates_token_count": 1551,
        "thoughts_token_count": 22819
      },
      "response_text_len": 4043
    }
  }
}