{
  "trial_id": "trial_4_15",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the squared ratio\n    (min_dist / max_dist)^2.\n    \n    Strategy:\n    1.  Formulate as a constrained optimization problem:\n        Maximize t\n        Subject to:\n            dist(p_i, p_j)^2 >= t      (for all i < j)\n            dist(p_i, p_j)^2 <= 1      (for all i < j)\n            Center of Mass == 0        (to remove translational drift)\n    2.  Use SciPy's SLSQP solver which can handle these inequality constraints efficiently.\n    3.  Run multiple restarts with different initializations (Fibonacci sphere, Random) \n        to avoid local optima.\n    \"\"\"\n    \n    N = 14\n    n_pairs = N * (N - 1) // 2\n    \n    # Precompute pair indices for vectorized operations\n    idx_i = []\n    idx_j = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n    \n    # --------------------------------------------------------\n    # Optimization Problem Definitions\n    # Variable x has size 3*N + 1: [x1, y1, z1, ..., x14, y14, z14, t]\n    # --------------------------------------------------------\n    \n    def objective(x):\n        # We want to maximize t, so minimize -t\n        return -x[-1]\n\n    def jac_objective(x):\n        # Gradient of objective w.r.t x\n        g = np.zeros_like(x)\n        g[-1] = -1.0\n        return g\n    \n    def constraints_func(x):\n        pts = x[:-1].reshape((N, 3))\n        t = x[-1]\n        \n        # Calculate all pairwise vectors and squared distances\n        vecs = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(vecs**2, axis=1)\n        \n        # Constraints:\n        # 1. d^2 >= t  =>  d^2 - t >= 0\n        # 2. d^2 <= 1  =>  1 - d^2 >= 0\n        \n        c_lower = d2 - t\n        c_upper = 1.0 - d2\n        return np.concatenate([c_lower, c_upper])\n    \n    def constraints_jac(x):\n        pts = x[:-1].reshape((N, 3))\n        # t = x[-1]\n        \n        vecs = pts[idx_i] - pts[idx_j] # Shape (n_pairs, 3)\n        grad_d2 = 2 * vecs             # Gradient of d^2 w.r.t p_i is 2(pi-pj)\n        \n        # Jacobian matrix: (2 * n_pairs) rows, (3 * N + 1) cols\n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        # Fill Jacobian efficiently\n        # We iterate over pairs to set the blocks corresponding to p_i and p_j\n        for k in range(n_pairs):\n            u, v = idx_i[k], idx_j[k]\n            \n            # Row k: constraint d^2 - t >= 0\n            # d(c)/dp_u = grad_d2\n            # d(c)/dp_v = -grad_d2\n            # d(c)/dt   = -1\n            jac[k, 3*u:3*u+3] = grad_d2[k]\n            jac[k, 3*v:3*v+3] = -grad_d2[k]\n            jac[k, -1] = -1.0\n            \n            # Row n_pairs + k: constraint 1 - d^2 >= 0\n            # d(c)/dp_u = -grad_d2\n            # d(c)/dp_v = grad_d2\n            # d(c)/dt   = 0\n            jac[n_pairs + k, 3*u:3*u+3] = -grad_d2[k]\n            jac[n_pairs + k, 3*v:3*v+3] = grad_d2[k]\n            \n        return jac\n    \n    def com_func(x):\n        # Center of mass constraint: sum(p) = 0\n        pts = x[:-1].reshape((N, 3))\n        return np.sum(pts, axis=0)\n    \n    def com_jac(x):\n        # Jacobian of center of mass constraint\n        j = np.zeros((3, 3 * N + 1))\n        for i in range(N):\n            j[:, 3*i:3*i+3] = np.eye(3)\n        return j\n\n    # Define constraint dictionary for SLSQP\n    cons = [\n        {'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n        {'type': 'eq', 'fun': com_func, 'jac': com_jac}\n    ]\n    \n    # --------------------------------------------------------\n    # Initialization Helper\n    # --------------------------------------------------------\n    def get_fibonacci(n):\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            r = np.sqrt(1 - y*y)\n            theta = phi * i\n            pts.append([r * np.cos(theta), y, r * np.sin(theta)])\n        return np.array(pts)\n\n    # --------------------------------------------------------\n    # Main Optimization Loop (Multi-start)\n    # --------------------------------------------------------\n    \n    t_start_global = time.time()\n    best_points = get_fibonacci(N) # Fallback\n    best_score = 0.0\n    \n    seed = 0\n    # Run as many restarts as possible within ~55 seconds\n    while time.time() - t_start_global < 55.0:\n        \n        # 1. Generate Initial Guess\n        if seed == 0:\n            init_pts = get_fibonacci(N)\n        else:\n            np.random.seed(seed)\n            init_pts = np.random.randn(N, 3)\n            init_pts /= np.linalg.norm(init_pts, axis=1, keepdims=True)\n            \n        # 2. Normalize initial guess so max distance is 1.0\n        diff = init_pts[:, None, :] - init_pts[None, :, :]\n        d2_matrix = np.sum(diff**2, axis=-1)\n        max_d2 = np.max(d2_matrix)\n        if max_d2 > 1e-9:\n            init_pts /= np.sqrt(max_d2)\n            \n        # 3. Determine initial t (squared min distance)\n        # We start slightly conservative to ensure feasibility\n        np.fill_diagonal(d2_matrix, np.inf)\n        min_d2 = np.min(d2_matrix)\n        # Rescale min_d2 according to the normalization above\n        if max_d2 > 1e-9:\n            min_d2 /= max_d2\n        \n        t0 = min_d2 * 0.95 \n        \n        x0 = np.concatenate([init_pts.flatten(), [t0]])\n        \n        # 4. Run Optimizer\n        try:\n            res = minimize(\n                objective, \n                x0, \n                method='SLSQP', \n                jac=jac_objective, \n                constraints=cons, \n                options={'maxiter': 300, 'ftol': 1e-6}\n            )\n            \n            # 5. Evaluate Result\n            pts_out = res.x[:-1].reshape((N, 3))\n            \n            # Calculate actual score robustly\n            diff = pts_out[:, None, :] - pts_out[None, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            \n            np.fill_diagonal(d2, np.inf)\n            d_min = np.sqrt(np.min(d2))\n            \n            np.fill_diagonal(d2, 0)\n            d_max = np.sqrt(np.max(d2))\n            \n            if d_max > 1e-9:\n                score = (d_min / d_max)**2\n                if score > best_score:\n                    best_score = score\n                    best_points = pts_out\n                    \n        except Exception:\n            pass\n            \n        seed += 1\n        \n    return best_points",
  "metrics": {
    "valid": true,
    "score": 0.9994412128823078,
    "min_max_ratio": 0.2399129274414633,
    "min_distance": 0.48980907274609975,
    "max_distance": 1.0000000006313348,
    "eval_time": 55.273497104644775,
    "error": null
  },
  "prompt": "Focus on the 'critical' pairs. Identify the pairs of points that currently define the minimum distance and the maximum distance. Use a constrained optimizer where you explicitly try to increase the distance of the closest pairs while keeping the furthest pairs from getting further apart.",
  "response": "An implementation of an algorithm to place 14 points in 3D space to maximize the squared ratio of minimum to maximum pairwise distance. The solution uses a constrained optimizer (SLSQP) to explicitly maximize the minimum distance while constraining the maximum distance, focusing on the \"critical\" pairs as requested.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the squared ratio\n    (min_dist / max_dist)^2.\n    \n    Strategy:\n    1.  Formulate as a constrained optimization problem:\n        Maximize t\n        Subject to:\n            dist(p_i, p_j)^2 >= t      (for all i < j)\n            dist(p_i, p_j)^2 <= 1      (for all i < j)\n            Center of Mass == 0        (to remove translational drift)\n    2.  Use SciPy's SLSQP solver which can handle these inequality constraints efficiently.\n    3.  Run multiple restarts with different initializations (Fibonacci sphere, Random) \n        to avoid local optima.\n    \"\"\"\n    \n    N = 14\n    n_pairs = N * (N - 1) // 2\n    \n    # Precompute pair indices for vectorized operations\n    idx_i = []\n    idx_j = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n    \n    # --------------------------------------------------------\n    # Optimization Problem Definitions\n    # Variable x has size 3*N + 1: [x1, y1, z1, ..., x14, y14, z14, t]\n    # --------------------------------------------------------\n    \n    def objective(x):\n        # We want to maximize t, so minimize -t\n        return -x[-1]\n\n    def jac_objective(x):\n        # Gradient of objective w.r.t x\n        g = np.zeros_like(x)\n        g[-1] = -1.0\n        return g\n    \n    def constraints_func(x):\n        pts = x[:-1].reshape((N, 3))\n        t = x[-1]\n        \n        # Calculate all pairwise vectors and squared distances\n        vecs = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(vecs**2, axis=1)\n        \n        # Constraints:\n        # 1. d^2 >= t  =>  d^2 - t >= 0\n        # 2. d^2 <= 1  =>  1 - d^2 >= 0\n        \n        c_lower = d2 - t\n        c_upper = 1.0 - d2\n        return np.concatenate([c_lower, c_upper])\n    \n    def constraints_jac(x):\n        pts = x[:-1].reshape((N, 3))\n        # t = x[-1]\n        \n        vecs = pts[idx_i] - pts[idx_j] # Shape (n_pairs, 3)\n        grad_d2 = 2 * vecs             # Gradient of d^2 w.r.t p_i is 2(pi-pj)\n        \n        # Jacobian matrix: (2 * n_pairs) rows, (3 * N + 1) cols\n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        # Fill Jacobian efficiently\n        # We iterate over pairs to set the blocks corresponding to p_i and p_j\n        for k in range(n_pairs):\n            u, v = idx_i[k], idx_j[k]\n            \n            # Row k: constraint d^2 - t >= 0\n            # d(c)/dp_u = grad_d2\n            # d(c)/dp_v = -grad_d2\n            # d(c)/dt   = -1\n            jac[k, 3*u:3*u+3] = grad_d2[k]\n            jac[k, 3*v:3*v+3] = -grad_d2[k]\n            jac[k, -1] = -1.0\n            \n            # Row n_pairs + k: constraint 1 - d^2 >= 0\n            # d(c)/dp_u = -grad_d2\n            # d(c)/dp_v = grad_d2\n            # d(c)/dt   = 0\n            jac[n_pairs + k, 3*u:3*u+3] = -grad_d2[k]\n            jac[n_pairs + k, 3*v:3*v+3] = grad_d2[k]\n            \n        return jac\n    \n    def com_func(x):\n        # Center of mass constraint: sum(p) = 0\n        pts = x[:-1].reshape((N, 3))\n        return np.sum(pts, axis=0)\n    \n    def com_jac(x):\n        # Jacobian of center of mass constraint\n        j = np.zeros((3, 3 * N + 1))\n        for i in range(N):\n            j[:, 3*i:3*i+3] = np.eye(3)\n        return j\n\n    # Define constraint dictionary for SLSQP\n    cons = [\n        {'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n        {'type': 'eq', 'fun': com_func, 'jac': com_jac}\n    ]\n    \n    # --------------------------------------------------------\n    # Initialization Helper\n    # --------------------------------------------------------\n    def get_fibonacci(n):\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            r = np.sqrt(1 - y*y)\n            theta = phi * i\n            pts.append([r * np.cos(theta), y, r * np.sin(theta)])\n        return np.array(pts)\n\n    # --------------------------------------------------------\n    # Main Optimization Loop (Multi-start)\n    # --------------------------------------------------------\n    \n    t_start_global = time.time()\n    best_points = get_fibonacci(N) # Fallback\n    best_score = 0.0\n    \n    seed = 0\n    # Run as many restarts as possible within ~55 seconds\n    while time.time() - t_start_global < 55.0:\n        \n        # 1. Generate Initial Guess\n        if seed == 0:\n            init_pts = get_fibonacci(N)\n        else:\n            np.random.seed(seed)\n            init_pts = np.random.randn(N, 3)\n            init_pts /= np.linalg.norm(init_pts, axis=1, keepdims=True)\n            \n        # 2. Normalize initial guess so max distance is 1.0\n        diff = init_pts[:, None, :] - init_pts[None, :, :]\n        d2_matrix = np.sum(diff**2, axis=-1)\n        max_d2 = np.max(d2_matrix)\n        if max_d2 > 1e-9:\n            init_pts /= np.sqrt(max_d2)\n            \n        # 3. Determine initial t (squared min distance)\n        # We start slightly conservative to ensure feasibility\n        np.fill_diagonal(d2_matrix, np.inf)\n        min_d2 = np.min(d2_matrix)\n        # Rescale min_d2 according to the normalization above\n        if max_d2 > 1e-9:\n            min_d2 /= max_d2\n        \n        t0 = min_d2 * 0.95 \n        \n        x0 = np.concatenate([init_pts.flatten(), [t0]])\n        \n        # 4. Run Optimizer\n        try:\n            res = minimize(\n                objective, \n                x0, \n                method='SLSQP', \n                jac=jac_objective, \n                constraints=cons, \n                options={'maxiter': 300, 'ftol': 1e-6}\n            )\n            \n            # 5. Evaluate Result\n            pts_out = res.x[:-1].reshape((N, 3))\n            \n            # Calculate actual score robustly\n            diff = pts_out[:, None, :] - pts_out[None, :, :]\n            d2 = np.sum(diff**2, axis=-1)\n            \n            np.fill_diagonal(d2, np.inf)\n            d_min = np.sqrt(np.min(d2))\n            \n            np.fill_diagonal(d2, 0)\n            d_max = np.sqrt(np.max(d2))\n            \n            if d_max > 1e-9:\n                score = (d_min / d_max)**2\n                if score > best_score:\n                    best_score = score\n                    best_points = pts_out\n                    \n        except Exception:\n            pass\n            \n        seed += 1\n        \n    return best_points\n```",
  "reasoning": "An implementation of an algorithm to place 14 points in 3D space to maximize the squared ratio of minimum to maximum pairwise distance. The solution uses a constrained optimizer (SLSQP) to explicitly maximize the minimum distance while constraining the maximum distance, focusing on the \"critical\" pairs as requested.",
  "timestamp": "2026-01-21T17:32:52.601268",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 222,
        "candidates_token_count": 2242,
        "thoughts_token_count": 12880
      },
      "response_text_len": 6889
    }
  }
}