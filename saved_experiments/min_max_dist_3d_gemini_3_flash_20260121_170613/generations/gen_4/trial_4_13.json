{
  "trial_id": "trial_4_13",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D that maximize the squared ratio (min_dist / max_dist)^2.\n    Uses SLSQP optimization with analytical gradients and multiple restarts.\n    \"\"\"\n    N = 14\n    n_pairs = N * (N - 1) // 2\n    \n    # Precompute pair indices for vectorized operations\n    idx_i = []\n    idx_j = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n    \n    # Precompute indices for Jacobian matrix construction\n    # We map the flattened variables (3*N + 1) to the constraint rows\n    rows = np.arange(n_pairs)\n    \n    # Column indices for x, y, z coordinates of point i and point j\n    col_i_x = 3 * idx_i\n    col_i_y = 3 * idx_i + 1\n    col_i_z = 3 * idx_i + 2\n    \n    col_j_x = 3 * idx_j\n    col_j_y = 3 * idx_j + 1\n    col_j_z = 3 * idx_j + 2\n\n    # Objective: Minimize -s (Maximize s, the squared min distance)\n    def objective(x):\n        return -x[-1]\n\n    # Gradient of objective: [0, ..., 0, -1]\n    def objective_grad(x):\n        grad = np.zeros_like(x)\n        grad[-1] = -1.0\n        return grad\n\n    # Constraints function\n    # Returns array of shape (2 * n_pairs,)\n    # First half: d^2 - s >= 0  (min dist constraint)\n    # Second half: 1 - d^2 >= 0 (max dist constraint)\n    def constraints(x):\n        pts = x[:-1].reshape(N, 3)\n        s = x[-1]\n        \n        # Calculate squared distances for all pairs\n        vecs = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(vecs**2, axis=1)\n        \n        return np.concatenate([d2 - s, 1.0 - d2])\n\n    # Jacobian of constraints\n    # Returns matrix of shape (2 * n_pairs, 3 * N + 1)\n    def constraints_jac(x):\n        pts = x[:-1].reshape(N, 3)\n        vecs = pts[idx_i] - pts[idx_j]\n        \n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        # Derivative of d^2 w.r.t coordinates is 2*(xi - xj)\n        two_vecs = 2 * vecs\n        \n        # 1. Lower bound constraints: d^2 - s >= 0\n        # Derivatives w.r.t x_i\n        jac[rows, col_i_x] = two_vecs[:, 0]\n        jac[rows, col_i_y] = two_vecs[:, 1]\n        jac[rows, col_i_z] = two_vecs[:, 2]\n        \n        # Derivatives w.r.t x_j (negative of x_i)\n        jac[rows, col_j_x] = -two_vecs[:, 0]\n        jac[rows, col_j_y] = -two_vecs[:, 1]\n        jac[rows, col_j_z] = -two_vecs[:, 2]\n        \n        # Derivative w.r.t s\n        jac[rows, -1] = -1.0\n        \n        # 2. Upper bound constraints: 1 - d^2 >= 0\n        # Derivatives are negative of d^2 derivatives\n        jac[n_pairs + rows, col_i_x] = -two_vecs[:, 0]\n        jac[n_pairs + rows, col_i_y] = -two_vecs[:, 1]\n        jac[n_pairs + rows, col_i_z] = -two_vecs[:, 2]\n        \n        jac[n_pairs + rows, col_j_x] = two_vecs[:, 0]\n        jac[n_pairs + rows, col_j_y] = two_vecs[:, 1]\n        jac[n_pairs + rows, col_j_z] = two_vecs[:, 2]\n        \n        return jac\n\n    # Generate initial guesses\n    guesses = []\n    \n    # Guess 1: Rhombic Dodecahedron vertices (projected to sphere)\n    # This polyhedron has 14 vertices and is a good candidate for this number of points\n    rd_pts = []\n    # 6 vertices of type (+-1, 0, 0)\n    for k in [-1, 1]:\n        rd_pts.append([k, 0, 0])\n        rd_pts.append([0, k, 0])\n        rd_pts.append([0, 0, k])\n    # 8 vertices of type (+-1, +-1, +-1)\n    for x in [-1, 1]:\n        for y in [-1, 1]:\n            for z in [-1, 1]:\n                rd_pts.append([x, y, z])\n    rd_pts = np.array(rd_pts, dtype=float)\n    rd_pts /= np.linalg.norm(rd_pts, axis=1, keepdims=True)\n    guesses.append(rd_pts * 0.5) # Scale to radius 0.5 (diameter 1)\n\n    # Guess 2: Random points on sphere (multiple restarts)\n    # The optimal solution is likely a spherical code (Tammes problem)\n    for _ in range(15):\n        p = np.random.randn(N, 3)\n        p /= np.linalg.norm(p, axis=1, keepdims=True)\n        guesses.append(p * 0.5)\n\n    # Guess 3: Random points in box\n    for _ in range(3):\n        guesses.append(np.random.rand(N, 3) - 0.5)\n\n    best_score = -1.0\n    best_points = guesses[0]\n    \n    t_start = time.time()\n    \n    # Run optimization for each guess\n    for guess in guesses:\n        # Check time limit\n        if time.time() - t_start > 55:\n            break\n            \n        # Initialize s slightly below current min dist sq\n        dists = pdist(guess)\n        s0 = np.min(dists)**2 if dists.size > 0 else 0.01\n        if s0 < 1e-6: s0 = 0.01\n        \n        x0 = np.concatenate([guess.flatten(), [s0]])\n        \n        try:\n            res = minimize(\n                objective,\n                x0,\n                jac=objective_grad,\n                constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                method='SLSQP',\n                options={'maxiter': 1000, 'ftol': 1e-7}\n            )\n            \n            pts = res.x[:-1].reshape(N, 3)\n            \n            # Evaluate result\n            d = pdist(pts)\n            if d.size > 0:\n                dmin = np.min(d)\n                dmax = np.max(d)\n                if dmax > 1e-9:\n                    score = (dmin / dmax)**2\n                    if score > best_score:\n                        best_score = score\n                        best_points = pts\n        except Exception:\n            continue\n            \n    return best_points",
  "metrics": {
    "valid": true,
    "score": 0.9967000084434186,
    "min_max_ratio": 0.23925490936779106,
    "min_distance": 0.4891369024906079,
    "max_distance": 1.0000000000215574,
    "eval_time": 0.5629010200500488,
    "error": null
  },
  "prompt": "Focus on the 'critical' pairs. Identify the pairs of points that currently define the minimum distance and the maximum distance. Use a constrained optimizer where you explicitly try to increase the distance of the closest pairs while keeping the furthest pairs from getting further apart.",
  "response": "An algorithm to place 14 points in 3D space to maximize the squared ratio $(d_{\\min} / d_{\\max})^2$.\n\n### Method\nThe problem is equivalent to maximizing the minimum pairwise distance $d_{\\min}$ while constraining the maximum pairwise distance $d_{\\max} \\le 1$. This formulation is suitable for a constrained non-linear optimizer.\n\nWe use `scipy.optimize.minimize` with the **SLSQP** solver, which supports hard inequality constraints.\n1. **Variables**: 43 variables ($14 \\times 3$ coordinates + 1 variable $s$ representing squared minimum distance).\n2. **Objective**: Maximize $s$ (minimize $-s$).\n3. **Constraints**:\n   - For every pair $(i, j)$: $\\|x_i - x_j\\|^2 \\ge s$.\n   - For every pair $(i, j)$: $\\|x_i - x_j\\|^2 \\le 1$.\n4. **Derivatives**: We provide the analytical Jacobian for the constraints to ensure fast and accurate convergence.\n5. **Initialization**: The optimization landscape is non-convex. We use multiple restarts with different initial configurations, including:\n   - Random points on a unit sphere (likely close to optimal for this packing-type problem).\n   - Vertices of a Rhombic Dodecahedron (a 14-vertex polyhedron).\n   - Random points in a box.\n\nThe solver explicitly adjusts critical pairs (those defining min and max distances) via the constraints, satisfying the prompt's strategy.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D that maximize the squared ratio (min_dist / max_dist)^2.\n    Uses SLSQP optimization with analytical gradients and multiple restarts.\n    \"\"\"\n    N = 14\n    n_pairs = N * (N - 1) // 2\n    \n    # Precompute pair indices for vectorized operations\n    idx_i = []\n    idx_j = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n    \n    # Precompute indices for Jacobian matrix construction\n    # We map the flattened variables (3*N + 1) to the constraint rows\n    rows = np.arange(n_pairs)\n    \n    # Column indices for x, y, z coordinates of point i and point j\n    col_i_x = 3 * idx_i\n    col_i_y = 3 * idx_i + 1\n    col_i_z = 3 * idx_i + 2\n    \n    col_j_x = 3 * idx_j\n    col_j_y = 3 * idx_j + 1\n    col_j_z = 3 * idx_j + 2\n\n    # Objective: Minimize -s (Maximize s, the squared min distance)\n    def objective(x):\n        return -x[-1]\n\n    # Gradient of objective: [0, ..., 0, -1]\n    def objective_grad(x):\n        grad = np.zeros_like(x)\n        grad[-1] = -1.0\n        return grad\n\n    # Constraints function\n    # Returns array of shape (2 * n_pairs,)\n    # First half: d^2 - s >= 0  (min dist constraint)\n    # Second half: 1 - d^2 >= 0 (max dist constraint)\n    def constraints(x):\n        pts = x[:-1].reshape(N, 3)\n        s = x[-1]\n        \n        # Calculate squared distances for all pairs\n        vecs = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(vecs**2, axis=1)\n        \n        return np.concatenate([d2 - s, 1.0 - d2])\n\n    # Jacobian of constraints\n    # Returns matrix of shape (2 * n_pairs, 3 * N + 1)\n    def constraints_jac(x):\n        pts = x[:-1].reshape(N, 3)\n        vecs = pts[idx_i] - pts[idx_j]\n        \n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        # Derivative of d^2 w.r.t coordinates is 2*(xi - xj)\n        two_vecs = 2 * vecs\n        \n        # 1. Lower bound constraints: d^2 - s >= 0\n        # Derivatives w.r.t x_i\n        jac[rows, col_i_x] = two_vecs[:, 0]\n        jac[rows, col_i_y] = two_vecs[:, 1]\n        jac[rows, col_i_z] = two_vecs[:, 2]\n        \n        # Derivatives w.r.t x_j (negative of x_i)\n        jac[rows, col_j_x] = -two_vecs[:, 0]\n        jac[rows, col_j_y] = -two_vecs[:, 1]\n        jac[rows, col_j_z] = -two_vecs[:, 2]\n        \n        # Derivative w.r.t s\n        jac[rows, -1] = -1.0\n        \n        # 2. Upper bound constraints: 1 - d^2 >= 0\n        # Derivatives are negative of d^2 derivatives\n        jac[n_pairs + rows, col_i_x] = -two_vecs[:, 0]\n        jac[n_pairs + rows, col_i_y] = -two_vecs[:, 1]\n        jac[n_pairs + rows, col_i_z] = -two_vecs[:, 2]\n        \n        jac[n_pairs + rows, col_j_x] = two_vecs[:, 0]\n        jac[n_pairs + rows, col_j_y] = two_vecs[:, 1]\n        jac[n_pairs + rows, col_j_z] = two_vecs[:, 2]\n        \n        return jac\n\n    # Generate initial guesses\n    guesses = []\n    \n    # Guess 1: Rhombic Dodecahedron vertices (projected to sphere)\n    # This polyhedron has 14 vertices and is a good candidate for this number of points\n    rd_pts = []\n    # 6 vertices of type (+-1, 0, 0)\n    for k in [-1, 1]:\n        rd_pts.append([k, 0, 0])\n        rd_pts.append([0, k, 0])\n        rd_pts.append([0, 0, k])\n    # 8 vertices of type (+-1, +-1, +-1)\n    for x in [-1, 1]:\n        for y in [-1, 1]:\n            for z in [-1, 1]:\n                rd_pts.append([x, y, z])\n    rd_pts = np.array(rd_pts, dtype=float)\n    rd_pts /= np.linalg.norm(rd_pts, axis=1, keepdims=True)\n    guesses.append(rd_pts * 0.5) # Scale to radius 0.5 (diameter 1)\n\n    # Guess 2: Random points on sphere (multiple restarts)\n    # The optimal solution is likely a spherical code (Tammes problem)\n    for _ in range(15):\n        p = np.random.randn(N, 3)\n        p /= np.linalg.norm(p, axis=1, keepdims=True)\n        guesses.append(p * 0.5)\n\n    # Guess 3: Random points in box\n    for _ in range(3):\n        guesses.append(np.random.rand(N, 3) - 0.5)\n\n    best_score = -1.0\n    best_points = guesses[0]\n    \n    t_start = time.time()\n    \n    # Run optimization for each guess\n    for guess in guesses:\n        # Check time limit\n        if time.time() - t_start > 55:\n            break\n            \n        # Initialize s slightly below current min dist sq\n        dists = pdist(guess)\n        s0 = np.min(dists)**2 if dists.size > 0 else 0.01\n        if s0 < 1e-6: s0 = 0.01\n        \n        x0 = np.concatenate([guess.flatten(), [s0]])\n        \n        try:\n            res = minimize(\n                objective,\n                x0,\n                jac=objective_grad,\n                constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                method='SLSQP',\n                options={'maxiter': 1000, 'ftol': 1e-7}\n            )\n            \n            pts = res.x[:-1].reshape(N, 3)\n            \n            # Evaluate result\n            d = pdist(pts)\n            if d.size > 0:\n                dmin = np.min(d)\n                dmax = np.max(d)\n                if dmax > 1e-9:\n                    score = (dmin / dmax)**2\n                    if score > best_score:\n                        best_score = score\n                        best_points = pts\n        except Exception:\n            continue\n            \n    return best_points\n```",
  "reasoning": "An algorithm to place 14 points in 3D space to maximize the squared ratio $(d_{\\min} / d_{\\max})^2$.\n\n### Method\nThe problem is equivalent to maximizing the minimum pairwise distance $d_{\\min}$ while constraining the maximum pairwise distance $d_{\\max} \\le 1$. This formulation is suitable for a constrained non-linear optimizer.\n\nWe use `scipy.optimize.minimize` with the **SLSQP** solver, which supports hard inequality constraints.\n1. **Variables**: 43 variables ($14 \\times 3$ coordinates + 1 variable $s$ representing squared minimum distance).\n2. **Objective**: Maximize $s$ (minimize $-s$).\n3. **Constraints**:\n   - For every pair $(i, j)$: $\\|x_i - x_j\\|^2 \\ge s$.\n   - For every pair $(i, j)$: $\\|x_i - x_j\\|^2 \\le 1$.\n4. **Derivatives**: We provide the analytical Jacobian for the constraints to ensure fast and accurate convergence.\n5. **Initialization**: The optimization landscape is non-convex. We use multiple restarts with different initial configurations, including:\n   - Random points on a unit sphere (likely close to optimal for this packing-type problem).\n   - Vertices of a Rhombic Dodecahedron (a 14-vertex polyhedron).\n   - Random points in a box.\n\nThe solver explicitly adjusts critical pairs (those defining min and max distances) via the constraints, satisfying the prompt's strategy.",
  "timestamp": "2026-01-21T17:32:07.979496",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 222,
        "candidates_token_count": 2262,
        "thoughts_token_count": 13769
      },
      "response_text_len": 6784
    }
  }
}