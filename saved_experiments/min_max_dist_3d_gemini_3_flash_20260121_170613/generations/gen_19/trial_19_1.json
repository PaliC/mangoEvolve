{
  "trial_id": "trial_19_1",
  "generation": 19,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution, minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the squared ratio \n    (min_dist / max_dist)^2 using a D6d symmetry constraint (1-6-6-1 pattern).\n    \n    The pattern consists of:\n    - 2 Polar points at (0, 0, +/-z1)\n    - Ring 1: 6 points at z=z2, radius r1\n    - Ring 2: 6 points at z=-z2, radius r2, rotated by 30 degrees (antiprismatic)\n    \n    Returns:\n        numpy.ndarray: A (14, 3) array of point coordinates.\n    \"\"\"\n\n    def get_points(params):\n        z1, z2, r1, r2 = params\n        points = np.zeros((14, 3))\n        \n        # Poles: (0, 0, z1) and (0, 0, -z1)\n        points[0] = [0, 0, z1]\n        points[1] = [0, 0, -z1]\n        \n        # Ring 1: 6 points at z2\n        # Angles: 0, 60, 120, 180, 240, 300 degrees\n        theta1 = np.linspace(0, 2*np.pi, 6, endpoint=False)\n        points[2:8, 0] = r1 * np.cos(theta1)\n        points[2:8, 1] = r1 * np.sin(theta1)\n        points[2:8, 2] = z2\n        \n        # Ring 2: 6 points at -z2, rotated by 30 degrees (pi/6) relative to Ring 1\n        theta2 = theta1 + np.pi/6\n        points[8:14, 0] = r2 * np.cos(theta2)\n        points[8:14, 1] = r2 * np.sin(theta2)\n        points[8:14, 2] = -z2\n        \n        return points\n\n    def objective(params):\n        # Enforce positive parameters to maintain geometry assumptions\n        if np.any(params <= 1e-8):\n            return 1.0 # Penalty\n            \n        pts = get_points(params)\n        dists = pdist(pts)\n        \n        if dists.size == 0: return 0.0\n        \n        d_min = np.min(dists)\n        d_max = np.max(dists)\n        \n        if d_max <= 1e-9:\n            return 0.0\n            \n        # Maximize (min/max)^2  =>  Minimize -(min/max)^2\n        ratio_sq = (d_min / d_max)**2\n        return -ratio_sq\n\n    # Bounds for [z1, z2, r1, r2]\n    # We allow a generous range; the ratio is scale-invariant.\n    # z1: Pole height\n    # z2: Ring plane height\n    # r1, r2: Ring radii\n    bounds = [\n        (0.01, 5.0), # z1\n        (0.0, 5.0),  # z2\n        (0.01, 5.0), # r1\n        (0.01, 5.0)  # r2\n    ]\n    \n    # 1. Global Optimization\n    # Differential Evolution is robust for this 4-dimensional non-linear problem.\n    result = differential_evolution(\n        objective,\n        bounds,\n        strategy='best1bin',\n        maxiter=1000,\n        popsize=20,\n        tol=1e-7,\n        seed=1 # Fixed seed for reproducibility\n    )\n    \n    # 2. Local Refinement\n    # Use Nelder-Mead to polish the solution found by DE.\n    res_final = minimize(\n        objective,\n        result.x,\n        method='Nelder-Mead',\n        tol=1e-9,\n        options={'maxiter': 2000}\n    )\n    \n    return get_points(res_final.x)",
  "metrics": {
    "valid": true,
    "score": 0.9331888308441757,
    "min_max_ratio": 0.22400923773979575,
    "min_distance": 4.491582585037126,
    "max_distance": 9.490004649071164,
    "eval_time": 0.5430951118469238,
    "error": null
  },
  "prompt": "Implement a D6d symmetry-constrained optimization for 14 points. The 1-6-6-1 pattern means: 2 points on the Z-axis (0, 0, +/-z1), and two rings of 6 points. Ring 1: (r1*cos(phi), r1*sin(phi), z2), Ring 2: (r2*cos(phi + pi/6), r2*sin(phi + pi/6), -z2). Optimize the parameters (z1, z2, r1, r2) to maximize the min/max distance ratio.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution, minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the squared ratio \n    (min_dist / max_dist)^2 using a D6d symmetry constraint (1-6-6-1 pattern).\n    \n    The pattern consists of:\n    - 2 Polar points at (0, 0, +/-z1)\n    - Ring 1: 6 points at z=z2, radius r1\n    - Ring 2: 6 points at z=-z2, radius r2, rotated by 30 degrees (antiprismatic)\n    \n    Returns:\n        numpy.ndarray: A (14, 3) array of point coordinates.\n    \"\"\"\n\n    def get_points(params):\n        z1, z2, r1, r2 = params\n        points = np.zeros((14, 3))\n        \n        # Poles: (0, 0, z1) and (0, 0, -z1)\n        points[0] = [0, 0, z1]\n        points[1] = [0, 0, -z1]\n        \n        # Ring 1: 6 points at z2\n        # Angles: 0, 60, 120, 180, 240, 300 degrees\n        theta1 = np.linspace(0, 2*np.pi, 6, endpoint=False)\n        points[2:8, 0] = r1 * np.cos(theta1)\n        points[2:8, 1] = r1 * np.sin(theta1)\n        points[2:8, 2] = z2\n        \n        # Ring 2: 6 points at -z2, rotated by 30 degrees (pi/6) relative to Ring 1\n        theta2 = theta1 + np.pi/6\n        points[8:14, 0] = r2 * np.cos(theta2)\n        points[8:14, 1] = r2 * np.sin(theta2)\n        points[8:14, 2] = -z2\n        \n        return points\n\n    def objective(params):\n        # Enforce positive parameters to maintain geometry assumptions\n        if np.any(params <= 1e-8):\n            return 1.0 # Penalty\n            \n        pts = get_points(params)\n        dists = pdist(pts)\n        \n        if dists.size == 0: return 0.0\n        \n        d_min = np.min(dists)\n        d_max = np.max(dists)\n        \n        if d_max <= 1e-9:\n            return 0.0\n            \n        # Maximize (min/max)^2  =>  Minimize -(min/max)^2\n        ratio_sq = (d_min / d_max)**2\n        return -ratio_sq\n\n    # Bounds for [z1, z2, r1, r2]\n    # We allow a generous range; the ratio is scale-invariant.\n    # z1: Pole height\n    # z2: Ring plane height\n    # r1, r2: Ring radii\n    bounds = [\n        (0.01, 5.0), # z1\n        (0.0, 5.0),  # z2\n        (0.01, 5.0), # r1\n        (0.01, 5.0)  # r2\n    ]\n    \n    # 1. Global Optimization\n    # Differential Evolution is robust for this 4-dimensional non-linear problem.\n    result = differential_evolution(\n        objective,\n        bounds,\n        strategy='best1bin',\n        maxiter=1000,\n        popsize=20,\n        tol=1e-7,\n        seed=1 # Fixed seed for reproducibility\n    )\n    \n    # 2. Local Refinement\n    # Use Nelder-Mead to polish the solution found by DE.\n    res_final = minimize(\n        objective,\n        result.x,\n        method='Nelder-Mead',\n        tol=1e-9,\n        options={'maxiter': 2000}\n    )\n    \n    return get_points(res_final.x)\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:54:22.144749",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 303,
        "candidates_token_count": 1044,
        "thoughts_token_count": 11329
      },
      "response_text_len": 2837
    }
  }
}