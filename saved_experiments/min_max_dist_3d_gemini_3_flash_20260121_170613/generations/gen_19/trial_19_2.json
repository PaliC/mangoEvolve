{
  "trial_id": "trial_19_2",
  "generation": 19,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The configuration used is the 1-6-6-1 (North pole, two rings of 6 points, South pole).\n    Optimized using SLSQP followed by trust-constr for high-precision polishing.\n    \"\"\"\n    \n    # 1-6-6-1 initial configuration setup\n    # Poles at the top and bottom, two staggered hexagonal rings in between.\n    pts = np.zeros((14, 3))\n    # North Pole\n    pts[0] = [0, 0, 0.5]\n    # South Pole\n    pts[13] = [0, 0, -0.5]\n    # Hexagonal Ring 1 (6 points)\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        pts[i+1] = [0.45 * np.cos(angle), 0.45 * np.sin(angle), 0.2]\n    # Hexagonal Ring 2 (6 points, staggered by 30 degrees)\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi / 6\n        pts[i+7] = [0.45 * np.cos(angle), 0.45 * np.sin(angle), -0.2]\n    \n    # Optimizer variables: 42 coordinates + 1 variable representing d_min^2\n    # x[:42] are coordinates, x[42] is d_min_sq\n    x0 = np.zeros(43)\n    x0[:42] = pts.flatten()\n    x0[42] = 0.1  # Initial guess for d_min^2\n    \n    def obj(x):\n        # We want to maximize d_min^2, so we minimize -d_min_sq\n        return -x[42]\n\n    def get_pairwise_dist_sq(p):\n        \"\"\"Calculates all unique pairwise squared distances for 14 points.\"\"\"\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        dist_sqs = np.sum(diff**2, axis=-1)\n        # Extract upper triangle indices (91 unique pairs for 14 points)\n        i, j = np.triu_indices(14, k=1)\n        return dist_sqs[i, j]\n\n    def cons_func(x):\n        \"\"\"\n        Constraints function:\n        1. All pairwise squared distances must be >= d_min_sq\n        2. All pairwise squared distances must be <= 1.0 (setting d_max^2 = 1.0)\n        \"\"\"\n        p = x[:42].reshape((14, 3))\n        dm_sq = x[42]\n        d2 = get_pairwise_dist_sq(p)\n        # Inequalities: d2 - dm_sq >= 0 and 1.0 - d2 >= 0\n        return np.concatenate([d2 - dm_sq, 1.0 - d2])\n\n    # Phase 1: SLSQP optimization for rapid convergence\n    # Using high iteration count and tight tolerances\n    res_slsqp = minimize(\n        obj, \n        x0, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': cons_func},\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    # Phase 2: trust-constr polishing step for high precision\n    # This method is more robust for refining local optima with many constraints.\n    nlc = NonlinearConstraint(cons_func, 0, np.inf)\n    res_polished = minimize(\n        obj, \n        res_slsqp.x, \n        method='trust-constr',\n        constraints=[nlc],\n        options={\n            'maxiter': 150, \n            'xtol': 1e-10, \n            'gtol': 1e-10, \n            'barrier_tol': 1e-10\n        }\n    )\n\n    # Extract final points from the flattened array\n    final_pts = res_polished.x[:42].reshape((14, 3))\n    \n    # Final normalization to ensure the maximum distance is exactly 1.0\n    # This maximizes the ratio (d_min / d_max)^2 even if d_max was not exactly 1.0.\n    diff = final_pts[:, np.newaxis, :] - final_pts[np.newaxis, :, :]\n    d2_matrix = np.sum(diff**2, axis=-1)\n    dmax_sq = np.max(d2_matrix)\n    \n    final_pts_normalized = final_pts / np.sqrt(dmax_sq)\n    \n    return final_pts_normalized",
  "metrics": {
    "valid": true,
    "score": 0.9380684058770992,
    "min_max_ratio": 0.22518056539341813,
    "min_distance": 0.47453194349107636,
    "max_distance": 0.9999999999999999,
    "eval_time": 0.66178297996521,
    "error": null
  },
  "prompt": "Take the logic from trial_8_0 but add a final 'polishing' step using the 'trust-constr' method with very tight tolerances after the SLSQP phase. Focus on the 1-6-6-1 geometric configuration.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The configuration used is the 1-6-6-1 (North pole, two rings of 6 points, South pole).\n    Optimized using SLSQP followed by trust-constr for high-precision polishing.\n    \"\"\"\n    \n    # 1-6-6-1 initial configuration setup\n    # Poles at the top and bottom, two staggered hexagonal rings in between.\n    pts = np.zeros((14, 3))\n    # North Pole\n    pts[0] = [0, 0, 0.5]\n    # South Pole\n    pts[13] = [0, 0, -0.5]\n    # Hexagonal Ring 1 (6 points)\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        pts[i+1] = [0.45 * np.cos(angle), 0.45 * np.sin(angle), 0.2]\n    # Hexagonal Ring 2 (6 points, staggered by 30 degrees)\n    for i in range(6):\n        angle = 2 * np.pi * i / 6 + np.pi / 6\n        pts[i+7] = [0.45 * np.cos(angle), 0.45 * np.sin(angle), -0.2]\n    \n    # Optimizer variables: 42 coordinates + 1 variable representing d_min^2\n    # x[:42] are coordinates, x[42] is d_min_sq\n    x0 = np.zeros(43)\n    x0[:42] = pts.flatten()\n    x0[42] = 0.1  # Initial guess for d_min^2\n    \n    def obj(x):\n        # We want to maximize d_min^2, so we minimize -d_min_sq\n        return -x[42]\n\n    def get_pairwise_dist_sq(p):\n        \"\"\"Calculates all unique pairwise squared distances for 14 points.\"\"\"\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        dist_sqs = np.sum(diff**2, axis=-1)\n        # Extract upper triangle indices (91 unique pairs for 14 points)\n        i, j = np.triu_indices(14, k=1)\n        return dist_sqs[i, j]\n\n    def cons_func(x):\n        \"\"\"\n        Constraints function:\n        1. All pairwise squared distances must be >= d_min_sq\n        2. All pairwise squared distances must be <= 1.0 (setting d_max^2 = 1.0)\n        \"\"\"\n        p = x[:42].reshape((14, 3))\n        dm_sq = x[42]\n        d2 = get_pairwise_dist_sq(p)\n        # Inequalities: d2 - dm_sq >= 0 and 1.0 - d2 >= 0\n        return np.concatenate([d2 - dm_sq, 1.0 - d2])\n\n    # Phase 1: SLSQP optimization for rapid convergence\n    # Using high iteration count and tight tolerances\n    res_slsqp = minimize(\n        obj, \n        x0, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': cons_func},\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    # Phase 2: trust-constr polishing step for high precision\n    # This method is more robust for refining local optima with many constraints.\n    nlc = NonlinearConstraint(cons_func, 0, np.inf)\n    res_polished = minimize(\n        obj, \n        res_slsqp.x, \n        method='trust-constr',\n        constraints=[nlc],\n        options={\n            'maxiter': 150, \n            'xtol': 1e-10, \n            'gtol': 1e-10, \n            'barrier_tol': 1e-10\n        }\n    )\n\n    # Extract final points from the flattened array\n    final_pts = res_polished.x[:42].reshape((14, 3))\n    \n    # Final normalization to ensure the maximum distance is exactly 1.0\n    # This maximizes the ratio (d_min / d_max)^2 even if d_max was not exactly 1.0.\n    diff = final_pts[:, np.newaxis, :] - final_pts[np.newaxis, :, :]\n    d2_matrix = np.sum(diff**2, axis=-1)\n    dmax_sq = np.max(d2_matrix)\n    \n    final_pts_normalized = final_pts / np.sqrt(dmax_sq)\n    \n    return final_pts_normalized\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:54:16.619869",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 222,
        "candidates_token_count": 1201,
        "thoughts_token_count": 14940
      },
      "response_text_len": 3413
    }
  }
}