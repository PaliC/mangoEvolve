{
  "trial_id": "trial_19_0",
  "generation": 19,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    N = 14\n    \n    # Precompute indices for pairwise distances to match pdist order\n    # pdist returns [d(0,1), d(0,2), ..., d(0,N-1), d(1,2), ...]\n    idx_i = []\n    idx_j = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n    K = len(idx_i)  # Number of pairs = 91\n\n    # Objective: Maximize s => Minimize -s\n    def objective(params):\n        return -params[-1]\n\n    # Gradient of objective\n    def jac_objective(params):\n        grad = np.zeros_like(params)\n        grad[-1] = -1.0\n        return grad\n    \n    # Constraints\n    # 1. d_ij^2 >= s  =>  d_ij^2 - s >= 0\n    # 2. d_ij^2 <= 1  =>  1 - d_ij^2 >= 0\n    def constraints(params):\n        coords = params[:-1].reshape((N, 3))\n        s = params[-1]\n        \n        diff = coords[idx_i] - coords[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        \n        return np.concatenate([d2 - s, 1.0 - d2])\n    \n    # Jacobian of constraints\n    def jac_constraints(params):\n        coords = params[:-1].reshape((N, 3))\n        # s = params[-1]\n        \n        diff = coords[idx_i] - coords[idx_j]\n        two_diff = 2.0 * diff\n        \n        # Jacobian matrix shape: (2*K, 3*N + 1)\n        jac = np.zeros((2 * K, 3 * N + 1))\n        \n        # Fill gradients efficiently\n        for k in range(K):\n            i = idx_i[k]\n            j = idx_j[k]\n            \n            # Constraint 1: d^2 - s >= 0\n            # d(d^2)/dx_i = 2(xi-xj)\n            jac[k, 3*i : 3*i+3] = two_diff[k]\n            jac[k, 3*j : 3*j+3] = -two_diff[k]\n            jac[k, -1] = -1.0\n            \n            # Constraint 2: 1 - d^2 >= 0\n            # d(1-d^2)/dx = -d(d^2)/dx\n            jac[K + k, 3*i : 3*i+3] = -two_diff[k]\n            jac[K + k, 3*j : 3*j+3] = two_diff[k]\n            # d(1-d^2)/ds = 0\n            \n        return jac\n\n    # Initialization strategy:\n    # Since we don't have the exact state of trial_8_0, we generate high-quality \n    # candidates (Sphere, Random, Stacked) and pick the best basin.\n    starts = []\n    \n    # 1. Fibonacci Sphere (often close to optimal for N=14)\n    pts_sphere = []\n    phi = np.pi * (3. - np.sqrt(5.))\n    for i in range(N):\n        y = 1 - (i / float(N - 1)) * 2\n        r = np.sqrt(1 - y * y)\n        theta = phi * i\n        pts_sphere.append([np.cos(theta) * r, y, np.sin(theta) * r])\n    starts.append(np.array(pts_sphere))\n    \n    # 2. Random configurations\n    np.random.seed(42)\n    for _ in range(5):\n        starts.append(np.random.rand(N, 3))\n        \n    # 3. Stacked Hexagonal (approximate prism)\n    pts_hex = []\n    pts_hex.append([0,0,0]) # Center 1\n    for i in range(6): # Ring 1\n        ang = i * np.pi / 3\n        pts_hex.append([np.cos(ang), np.sin(ang), 0])\n    pts_hex.append([0,0,0.8]) # Center 2\n    for i in range(6): # Ring 2 (staggered)\n        ang = i * np.pi / 3 + np.pi/6\n        pts_hex.append([np.cos(ang), np.sin(ang), 0.8])\n    starts.append(np.array(pts_hex) + np.random.normal(0, 0.01, (N, 3)))\n\n    best_coords = None\n    best_s = -1.0\n    \n    cons = {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints}\n\n    # First pass: Coarse optimization to find best basin\n    for pts in starts:\n        # Normalize to satisfy constraints roughly\n        pts = pts - np.mean(pts, axis=0)\n        max_d = np.max(pdist(pts))\n        if max_d > 1e-9: pts /= max_d\n        \n        # Init s slightly feasible\n        s0 = (np.min(pdist(pts))**2) * 0.9\n        \n        x0 = np.concatenate([pts.flatten(), [s0]])\n        \n        # Fast loose run\n        try:\n            res = minimize(objective, x0, method='SLSQP', jac=jac_objective,\n                           constraints=cons, options={'ftol': 1e-3, 'maxiter': 200})\n            if -res.fun > best_s:\n                best_s = -res.fun\n                best_coords = res.x[:-1].reshape((N, 3))\n        except:\n            continue\n\n    # Second pass: Refine best solution with tight tolerances\n    if best_coords is None:\n        best_coords = starts[0]\n\n    pts = best_coords\n    pts = pts - np.mean(pts, axis=0)\n    pts /= np.max(pdist(pts))\n    \n    s0 = (np.min(pdist(pts))**2) * 0.99\n    x0 = np.concatenate([pts.flatten(), [s0]])\n    \n    # Strict optimization as requested\n    res = minimize(objective, x0, method='SLSQP', jac=jac_objective,\n                   constraints=cons, tol=1e-16,\n                   options={'ftol': 1e-16, 'maxiter': 2000})\n                   \n    return res.x[:-1].reshape((N, 3))",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539162,
    "min_max_ratio": 0.24005088264958455,
    "min_distance": 0.48994987769116205,
    "max_distance": 1.0000000000000002,
    "eval_time": 0.37454724311828613,
    "error": null
  },
  "prompt": "Refine the best solution found in trial_8_0 (score 1.0000159135539168). Use the slack variable formulation (maximize s s.t. d_ij^2 >= s and d_ij^2 <= 1). Use SLSQP with tol=1e-16 and maxiter=2000. Start from the coordinates in trial_8_0.",
  "response": "Here is the Python solution using the SLSQP solver with the slack variable formulation as requested. It performs a multi-start optimization to find a high-quality configuration and then refines it with the specified tolerances.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    N = 14\n    \n    # Precompute indices for pairwise distances to match pdist order\n    # pdist returns [d(0,1), d(0,2), ..., d(0,N-1), d(1,2), ...]\n    idx_i = []\n    idx_j = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n    K = len(idx_i)  # Number of pairs = 91\n\n    # Objective: Maximize s => Minimize -s\n    def objective(params):\n        return -params[-1]\n\n    # Gradient of objective\n    def jac_objective(params):\n        grad = np.zeros_like(params)\n        grad[-1] = -1.0\n        return grad\n    \n    # Constraints\n    # 1. d_ij^2 >= s  =>  d_ij^2 - s >= 0\n    # 2. d_ij^2 <= 1  =>  1 - d_ij^2 >= 0\n    def constraints(params):\n        coords = params[:-1].reshape((N, 3))\n        s = params[-1]\n        \n        diff = coords[idx_i] - coords[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        \n        return np.concatenate([d2 - s, 1.0 - d2])\n    \n    # Jacobian of constraints\n    def jac_constraints(params):\n        coords = params[:-1].reshape((N, 3))\n        # s = params[-1]\n        \n        diff = coords[idx_i] - coords[idx_j]\n        two_diff = 2.0 * diff\n        \n        # Jacobian matrix shape: (2*K, 3*N + 1)\n        jac = np.zeros((2 * K, 3 * N + 1))\n        \n        # Fill gradients efficiently\n        for k in range(K):\n            i = idx_i[k]\n            j = idx_j[k]\n            \n            # Constraint 1: d^2 - s >= 0\n            # d(d^2)/dx_i = 2(xi-xj)\n            jac[k, 3*i : 3*i+3] = two_diff[k]\n            jac[k, 3*j : 3*j+3] = -two_diff[k]\n            jac[k, -1] = -1.0\n            \n            # Constraint 2: 1 - d^2 >= 0\n            # d(1-d^2)/dx = -d(d^2)/dx\n            jac[K + k, 3*i : 3*i+3] = -two_diff[k]\n            jac[K + k, 3*j : 3*j+3] = two_diff[k]\n            # d(1-d^2)/ds = 0\n            \n        return jac\n\n    # Initialization strategy:\n    # Since we don't have the exact state of trial_8_0, we generate high-quality \n    # candidates (Sphere, Random, Stacked) and pick the best basin.\n    starts = []\n    \n    # 1. Fibonacci Sphere (often close to optimal for N=14)\n    pts_sphere = []\n    phi = np.pi * (3. - np.sqrt(5.))\n    for i in range(N):\n        y = 1 - (i / float(N - 1)) * 2\n        r = np.sqrt(1 - y * y)\n        theta = phi * i\n        pts_sphere.append([np.cos(theta) * r, y, np.sin(theta) * r])\n    starts.append(np.array(pts_sphere))\n    \n    # 2. Random configurations\n    np.random.seed(42)\n    for _ in range(5):\n        starts.append(np.random.rand(N, 3))\n        \n    # 3. Stacked Hexagonal (approximate prism)\n    pts_hex = []\n    pts_hex.append([0,0,0]) # Center 1\n    for i in range(6): # Ring 1\n        ang = i * np.pi / 3\n        pts_hex.append([np.cos(ang), np.sin(ang), 0])\n    pts_hex.append([0,0,0.8]) # Center 2\n    for i in range(6): # Ring 2 (staggered)\n        ang = i * np.pi / 3 + np.pi/6\n        pts_hex.append([np.cos(ang), np.sin(ang), 0.8])\n    starts.append(np.array(pts_hex) + np.random.normal(0, 0.01, (N, 3)))\n\n    best_coords = None\n    best_s = -1.0\n    \n    cons = {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints}\n\n    # First pass: Coarse optimization to find best basin\n    for pts in starts:\n        # Normalize to satisfy constraints roughly\n        pts = pts - np.mean(pts, axis=0)\n        max_d = np.max(pdist(pts))\n        if max_d > 1e-9: pts /= max_d\n        \n        # Init s slightly feasible\n        s0 = (np.min(pdist(pts))**2) * 0.9\n        \n        x0 = np.concatenate([pts.flatten(), [s0]])\n        \n        # Fast loose run\n        try:\n            res = minimize(objective, x0, method='SLSQP', jac=jac_objective,\n                           constraints=cons, options={'ftol': 1e-3, 'maxiter': 200})\n            if -res.fun > best_s:\n                best_s = -res.fun\n                best_coords = res.x[:-1].reshape((N, 3))\n        except:\n            continue\n\n    # Second pass: Refine best solution with tight tolerances\n    if best_coords is None:\n        best_coords = starts[0]\n\n    pts = best_coords\n    pts = pts - np.mean(pts, axis=0)\n    pts /= np.max(pdist(pts))\n    \n    s0 = (np.min(pdist(pts))**2) * 0.99\n    x0 = np.concatenate([pts.flatten(), [s0]])\n    \n    # Strict optimization as requested\n    res = minimize(objective, x0, method='SLSQP', jac=jac_objective,\n                   constraints=cons, tol=1e-16,\n                   options={'ftol': 1e-16, 'maxiter': 2000})\n                   \n    return res.x[:-1].reshape((N, 3))\n```",
  "reasoning": "Here is the Python solution using the SLSQP solver with the slack variable formulation as requested. It performs a multi-start optimization to find a high-quality configuration and then refines it with the specified tolerances.",
  "timestamp": "2026-01-21T18:54:47.440507",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 266,
        "candidates_token_count": 1753,
        "thoughts_token_count": 13493
      },
      "response_text_len": 4885
    }
  }
}