{
  "trial_id": "trial_19_4",
  "generation": 19,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize (min_dist / max_dist)^2.\n    Uses a multi-start SLSQP optimization approach starting from perturbed\n    1-6-6-1 configurations (bicapped hexagonal antiprism).\n    \"\"\"\n    N = 14\n    idx_i, idx_j = np.triu_indices(N, k=1)\n\n    def get_base_pts():\n        # Generates a 1-6-6-1 configuration (bicapped hexagonal antiprism)\n        pts = []\n        pts.append([0, 0, 0.5])  # Top cap\n        h = 0.22  # Approximate height of the rings for a sphere of radius 0.5\n        r = np.sqrt(0.5**2 - h**2)\n        for i in range(6):\n            a = np.deg2rad(i * 60)\n            pts.append([r * np.cos(a), r * np.sin(a), h])\n        for i in range(6):\n            a = np.deg2rad(i * 60 + 30)  # 30-degree offset for antiprism\n            pts.append([r * np.cos(a), r * np.sin(a), -h])\n        pts.append([0, 0, -0.5])  # Bottom cap\n        return np.array(pts)\n\n    def objective(vars):\n        # Maximize the slack variable s (min distance squared)\n        return -vars[-1]\n\n    def constraints(vars):\n        # vars contains 14 * 3 coordinates + slack variable s\n        pts = vars[:-1].reshape((N, 3))\n        s = vars[-1]\n        diffs = pts[idx_i] - pts[idx_j]\n        d2 = (diffs * diffs).sum(axis=1)\n        # All pairwise distances squared must be >= s and <= 1.0\n        # This ensures min_dist^2 >= s and max_dist^2 <= 1.0\n        return np.concatenate([d2 - s, 1.0 - d2])\n\n    base_pts = get_base_pts()\n    best_pts = base_pts\n    # Initialize best score based on the starting configuration\n    diffs = base_pts[idx_i] - base_pts[idx_j]\n    d2 = (diffs * diffs).sum(axis=1)\n    best_score = np.min(d2) / np.max(d2)\n\n    start_time = time.time()\n    count = 0\n    # Multi-start optimization loop\n    while True:\n        elapsed = time.time() - start_time\n        if elapsed > 55:  # Time limit constraint\n            break\n        # Aim for at least 100 starts if time permits\n        if count >= 120 and elapsed > 50:\n            break\n        \n        if count == 0:\n            # Start with the exact 1-6-6-1 configuration\n            pts = base_pts.copy()\n        elif count % 15 == 0:\n            # Occasionally use a purely random start to escape local optima\n            pts = np.random.uniform(-0.5, 0.5, (N, 3))\n        else:\n            # Slightly perturbed version of the 1-6-6-1 configuration\n            pts = base_pts + np.random.normal(0, 0.05, (N, 3))\n        \n        # Scale the initial points so that the maximum pairwise distance is 1.0\n        diffs_init = pts[idx_i] - pts[idx_j]\n        d2_init = (diffs_init * diffs_init).sum(axis=1)\n        max_d = np.sqrt(np.max(d2_init))\n        pts = pts / max_d\n        \n        # Initialize the slack variable s to the minimum distance squared\n        d2_scaled = (diffs_init * diffs_init).sum(axis=1) / (max_d**2)\n        s_init = np.min(d2_scaled)\n        \n        # Prepare the optimization variable vector\n        x0 = np.concatenate([pts.flatten(), [s_init]])\n        \n        # Perform SLSQP optimization to maximize the minimum distance\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            constraints={'type': 'ineq', 'fun': constraints},\n            options={'maxiter': 40, 'disp': False}\n        )\n        \n        # Evaluate the result of the current start\n        pts_res = res.x[:-1].reshape((N, 3))\n        diffs_res = pts_res[idx_i] - pts_res[idx_j]\n        d2_res = (diffs_res * diffs_res).sum(axis=1)\n        score = np.min(d2_res) / np.max(d2_res)\n        \n        # Update the best points found so far\n        if score > best_score:\n            best_score = score\n            best_pts = pts_res\n        count += 1\n            \n    # Final refinement of the best configuration found\n    x0_final = np.concatenate([best_pts.flatten(), [best_score]])\n    res_final = minimize(\n        objective, \n        x0_final, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 150, 'disp': False}\n    )\n    \n    # Extract and normalize the final set of points\n    best_pts = res_final.x[:-1].reshape((N, 3))\n    diffs_final = best_pts[idx_i] - best_pts[idx_j]\n    max_d_final = np.sqrt(np.max((diffs_final * diffs_final).sum(axis=1)))\n    \n    return best_pts / max_d_final",
  "metrics": {
    "valid": true,
    "score": 1.0000159135221345,
    "min_max_ratio": 0.24005088264195548,
    "min_distance": 0.48994987768337633,
    "max_distance": 0.9999999999999999,
    "eval_time": 50.29188299179077,
    "error": null
  },
  "prompt": "Perform a multi-start optimization (100+ starts) where each start is a slightly perturbed version of the 1-6-6-1 configuration. Use SLSQP to maximize the minimum distance while keeping the maximum distance capped at 1.0.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize (min_dist / max_dist)^2.\n    Uses a multi-start SLSQP optimization approach starting from perturbed\n    1-6-6-1 configurations (bicapped hexagonal antiprism).\n    \"\"\"\n    N = 14\n    idx_i, idx_j = np.triu_indices(N, k=1)\n\n    def get_base_pts():\n        # Generates a 1-6-6-1 configuration (bicapped hexagonal antiprism)\n        pts = []\n        pts.append([0, 0, 0.5])  # Top cap\n        h = 0.22  # Approximate height of the rings for a sphere of radius 0.5\n        r = np.sqrt(0.5**2 - h**2)\n        for i in range(6):\n            a = np.deg2rad(i * 60)\n            pts.append([r * np.cos(a), r * np.sin(a), h])\n        for i in range(6):\n            a = np.deg2rad(i * 60 + 30)  # 30-degree offset for antiprism\n            pts.append([r * np.cos(a), r * np.sin(a), -h])\n        pts.append([0, 0, -0.5])  # Bottom cap\n        return np.array(pts)\n\n    def objective(vars):\n        # Maximize the slack variable s (min distance squared)\n        return -vars[-1]\n\n    def constraints(vars):\n        # vars contains 14 * 3 coordinates + slack variable s\n        pts = vars[:-1].reshape((N, 3))\n        s = vars[-1]\n        diffs = pts[idx_i] - pts[idx_j]\n        d2 = (diffs * diffs).sum(axis=1)\n        # All pairwise distances squared must be >= s and <= 1.0\n        # This ensures min_dist^2 >= s and max_dist^2 <= 1.0\n        return np.concatenate([d2 - s, 1.0 - d2])\n\n    base_pts = get_base_pts()\n    best_pts = base_pts\n    # Initialize best score based on the starting configuration\n    diffs = base_pts[idx_i] - base_pts[idx_j]\n    d2 = (diffs * diffs).sum(axis=1)\n    best_score = np.min(d2) / np.max(d2)\n\n    start_time = time.time()\n    count = 0\n    # Multi-start optimization loop\n    while True:\n        elapsed = time.time() - start_time\n        if elapsed > 55:  # Time limit constraint\n            break\n        # Aim for at least 100 starts if time permits\n        if count >= 120 and elapsed > 50:\n            break\n        \n        if count == 0:\n            # Start with the exact 1-6-6-1 configuration\n            pts = base_pts.copy()\n        elif count % 15 == 0:\n            # Occasionally use a purely random start to escape local optima\n            pts = np.random.uniform(-0.5, 0.5, (N, 3))\n        else:\n            # Slightly perturbed version of the 1-6-6-1 configuration\n            pts = base_pts + np.random.normal(0, 0.05, (N, 3))\n        \n        # Scale the initial points so that the maximum pairwise distance is 1.0\n        diffs_init = pts[idx_i] - pts[idx_j]\n        d2_init = (diffs_init * diffs_init).sum(axis=1)\n        max_d = np.sqrt(np.max(d2_init))\n        pts = pts / max_d\n        \n        # Initialize the slack variable s to the minimum distance squared\n        d2_scaled = (diffs_init * diffs_init).sum(axis=1) / (max_d**2)\n        s_init = np.min(d2_scaled)\n        \n        # Prepare the optimization variable vector\n        x0 = np.concatenate([pts.flatten(), [s_init]])\n        \n        # Perform SLSQP optimization to maximize the minimum distance\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            constraints={'type': 'ineq', 'fun': constraints},\n            options={'maxiter': 40, 'disp': False}\n        )\n        \n        # Evaluate the result of the current start\n        pts_res = res.x[:-1].reshape((N, 3))\n        diffs_res = pts_res[idx_i] - pts_res[idx_j]\n        d2_res = (diffs_res * diffs_res).sum(axis=1)\n        score = np.min(d2_res) / np.max(d2_res)\n        \n        # Update the best points found so far\n        if score > best_score:\n            best_score = score\n            best_pts = pts_res\n        count += 1\n            \n    # Final refinement of the best configuration found\n    x0_final = np.concatenate([best_pts.flatten(), [best_score]])\n    res_final = minimize(\n        objective, \n        x0_final, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 150, 'disp': False}\n    )\n    \n    # Extract and normalize the final set of points\n    best_pts = res_final.x[:-1].reshape((N, 3))\n    diffs_final = best_pts[idx_i] - best_pts[idx_j]\n    max_d_final = np.sqrt(np.max((diffs_final * diffs_final).sum(axis=1)))\n    \n    return best_pts / max_d_final\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:55:35.509469",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 225,
        "candidates_token_count": 1465,
        "thoughts_token_count": 20763
      },
      "response_text_len": 4419
    }
  }
}