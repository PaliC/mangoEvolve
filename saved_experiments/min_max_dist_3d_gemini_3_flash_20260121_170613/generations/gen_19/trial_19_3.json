{
  "trial_id": "trial_19_3",
  "generation": 19,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min distance / max distance)^2.\n    Uses the Basin-hopping algorithm with a slack variable formulation and analytical Jacobians.\n    Initializes with a 1-6-6-1 layered structure (Bicapped Hexagonal Antiprism).\n    \"\"\"\n    # Precompute indices for all pairwise distances (91 pairs for 14 points)\n    I_UPPER = np.triu_indices(14, k=1)\n\n    def get_initial_points():\n        \"\"\"Creates a 1-6-6-1 bicapped hexagonal antiprism structure.\"\"\"\n        pts = np.zeros((14, 3))\n        # Top cap\n        pts[0] = [0.0, 0.0, 1.0]\n        # First hexagonal layer\n        for i in range(6):\n            theta = i * 2.0 * np.pi / 6.0\n            pts[i+1] = [0.7 * np.cos(theta), 0.7 * np.sin(theta), 0.4]\n        # Second hexagonal layer (rotated by 30 degrees for antiprism)\n        for i in range(6):\n            theta = (i * 2.0 * np.pi / 6.0) + (np.pi / 6.0)\n            pts[i+7] = [0.7 * np.cos(theta), 0.7 * np.sin(theta), -0.4]\n        # Bottom cap\n        pts[13] = [0.0, 0.0, -1.0]\n        return pts\n\n    # Initial setup\n    pts = get_initial_points()\n    \n    # Scale points so the initial maximum pairwise distance squared is 1.0\n    diffs = pts[I_UPPER[0]] - pts[I_UPPER[1]]\n    d_max_sq = np.max(np.sum(diffs**2, axis=1))\n    pts = pts / np.sqrt(d_max_sq)\n    \n    # Initial minimum distance squared (rho)\n    diffs = pts[I_UPPER[0]] - pts[I_UPPER[1]]\n    rho_init = np.min(np.sum(diffs**2, axis=1))\n    \n    # Variables: 42 coordinates + 1 slack variable (rho)\n    x0 = np.zeros(43)\n    x0[:42] = pts.flatten()\n    x0[42] = rho_init\n    \n    def objective(x):\n        \"\"\"Maximize rho by minimizing -rho.\"\"\"\n        return -x[42]\n    \n    def jac_objective(x):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(43)\n        j[42] = -1.0\n        return j\n    \n    def constraints(x):\n        \"\"\"\n        Constraints for SLSQP:\n        1. All pairwise distances squared >= rho\n        2. All pairwise distances squared <= 1.0\n        \"\"\"\n        pts_curr = x[:42].reshape((14, 3))\n        rho_curr = x[42]\n        diffs_curr = pts_curr[I_UPPER[0]] - pts_curr[I_UPPER[1]]\n        tri_dists_sq = np.sum(diffs_curr**2, axis=1)\n        # Returns an array where each element >= 0 for feasibility\n        return np.concatenate([tri_dists_sq - rho_curr, 1.0 - tri_dists_sq])\n    \n    def jac_constraints(x):\n        \"\"\"Analytical Jacobian of the 182 distance constraints.\"\"\"\n        pts_curr = x[:42].reshape((14, 3))\n        jac = np.zeros((182, 43))\n        diffs_curr = pts_curr[I_UPPER[0]] - pts_curr[I_UPPER[1]]\n        for k, (i, j) in enumerate(zip(I_UPPER[0], I_UPPER[1])):\n            d = diffs_curr[k]\n            # Constraint k: dist(i,j)^2 - rho >= 0\n            jac[k, 3*i:3*i+3] = 2.0 * d\n            jac[k, 3*j:3*j+3] = -2.0 * d\n            jac[k, 42] = -1.0\n            # Constraint k+91: 1.0 - dist(i,j)^2 >= 0\n            jac[k+91, 3*i:3*i+3] = -2.0 * d\n            jac[k+91, 3*j:3*j+3] = 2.0 * d\n        return jac\n\n    class MyStep:\n        \"\"\"Custom step function for Basin-hopping with a small step size.\"\"\"\n        def __init__(self, stepsize=0.001):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            x += np.random.uniform(-self.stepsize, self.stepsize, x.shape)\n            return x\n\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'jac': jac_objective,\n        'constraints': {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n        'options': {'maxiter': 100, 'disp': False}\n    }\n    \n    # Basin-hopping global optimization\n    # Small niter to ensure execution within the 60s time limit\n    res = basinhopping(\n        objective, \n        x0, \n        minimizer_kwargs=minimizer_kwargs, \n        niter=10, \n        T=0.0001,\n        take_step=MyStep(0.001),\n        disp=False\n    )\n    \n    # Extract and return the optimized 14 points\n    optimized_pts = res.x[:42].reshape((14, 3))\n    return optimized_pts",
  "metrics": {
    "valid": true,
    "score": 0.9331888283623282,
    "min_max_ratio": 0.22400923714403553,
    "min_distance": 0.47329614198808817,
    "max_distance": 1.000000001957002,
    "eval_time": 0.30035877227783203,
    "error": null
  },
  "prompt": "Use Basin-hopping with a very small step size (0.001) and the slack variable formulation. Initialize with a 1-6-6-1 layered structure (Bicapped Hexagonal Antiprism). Ensure analytical Jacobians are used for all 91 distance constraints.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min distance / max distance)^2.\n    Uses the Basin-hopping algorithm with a slack variable formulation and analytical Jacobians.\n    Initializes with a 1-6-6-1 layered structure (Bicapped Hexagonal Antiprism).\n    \"\"\"\n    # Precompute indices for all pairwise distances (91 pairs for 14 points)\n    I_UPPER = np.triu_indices(14, k=1)\n\n    def get_initial_points():\n        \"\"\"Creates a 1-6-6-1 bicapped hexagonal antiprism structure.\"\"\"\n        pts = np.zeros((14, 3))\n        # Top cap\n        pts[0] = [0.0, 0.0, 1.0]\n        # First hexagonal layer\n        for i in range(6):\n            theta = i * 2.0 * np.pi / 6.0\n            pts[i+1] = [0.7 * np.cos(theta), 0.7 * np.sin(theta), 0.4]\n        # Second hexagonal layer (rotated by 30 degrees for antiprism)\n        for i in range(6):\n            theta = (i * 2.0 * np.pi / 6.0) + (np.pi / 6.0)\n            pts[i+7] = [0.7 * np.cos(theta), 0.7 * np.sin(theta), -0.4]\n        # Bottom cap\n        pts[13] = [0.0, 0.0, -1.0]\n        return pts\n\n    # Initial setup\n    pts = get_initial_points()\n    \n    # Scale points so the initial maximum pairwise distance squared is 1.0\n    diffs = pts[I_UPPER[0]] - pts[I_UPPER[1]]\n    d_max_sq = np.max(np.sum(diffs**2, axis=1))\n    pts = pts / np.sqrt(d_max_sq)\n    \n    # Initial minimum distance squared (rho)\n    diffs = pts[I_UPPER[0]] - pts[I_UPPER[1]]\n    rho_init = np.min(np.sum(diffs**2, axis=1))\n    \n    # Variables: 42 coordinates + 1 slack variable (rho)\n    x0 = np.zeros(43)\n    x0[:42] = pts.flatten()\n    x0[42] = rho_init\n    \n    def objective(x):\n        \"\"\"Maximize rho by minimizing -rho.\"\"\"\n        return -x[42]\n    \n    def jac_objective(x):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(43)\n        j[42] = -1.0\n        return j\n    \n    def constraints(x):\n        \"\"\"\n        Constraints for SLSQP:\n        1. All pairwise distances squared >= rho\n        2. All pairwise distances squared <= 1.0\n        \"\"\"\n        pts_curr = x[:42].reshape((14, 3))\n        rho_curr = x[42]\n        diffs_curr = pts_curr[I_UPPER[0]] - pts_curr[I_UPPER[1]]\n        tri_dists_sq = np.sum(diffs_curr**2, axis=1)\n        # Returns an array where each element >= 0 for feasibility\n        return np.concatenate([tri_dists_sq - rho_curr, 1.0 - tri_dists_sq])\n    \n    def jac_constraints(x):\n        \"\"\"Analytical Jacobian of the 182 distance constraints.\"\"\"\n        pts_curr = x[:42].reshape((14, 3))\n        jac = np.zeros((182, 43))\n        diffs_curr = pts_curr[I_UPPER[0]] - pts_curr[I_UPPER[1]]\n        for k, (i, j) in enumerate(zip(I_UPPER[0], I_UPPER[1])):\n            d = diffs_curr[k]\n            # Constraint k: dist(i,j)^2 - rho >= 0\n            jac[k, 3*i:3*i+3] = 2.0 * d\n            jac[k, 3*j:3*j+3] = -2.0 * d\n            jac[k, 42] = -1.0\n            # Constraint k+91: 1.0 - dist(i,j)^2 >= 0\n            jac[k+91, 3*i:3*i+3] = -2.0 * d\n            jac[k+91, 3*j:3*j+3] = 2.0 * d\n        return jac\n\n    class MyStep:\n        \"\"\"Custom step function for Basin-hopping with a small step size.\"\"\"\n        def __init__(self, stepsize=0.001):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            x += np.random.uniform(-self.stepsize, self.stepsize, x.shape)\n            return x\n\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'jac': jac_objective,\n        'constraints': {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n        'options': {'maxiter': 100, 'disp': False}\n    }\n    \n    # Basin-hopping global optimization\n    # Small niter to ensure execution within the 60s time limit\n    res = basinhopping(\n        objective, \n        x0, \n        minimizer_kwargs=minimizer_kwargs, \n        niter=10, \n        T=0.0001,\n        take_step=MyStep(0.001),\n        disp=False\n    )\n    \n    # Extract and return the optimized 14 points\n    optimized_pts = res.x[:42].reshape((14, 3))\n    return optimized_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:54:31.645289",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 232,
        "candidates_token_count": 1477,
        "thoughts_token_count": 17411
      },
      "response_text_len": 4090
    }
  }
}