{
  "trial_id": "trial_2_2",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space to maximize the squared ratio \n    (min pairwise distance / max pairwise distance)^2.\n    \n    The algorithm uses an initial configuration based on a golden-section sphere distribution,\n    followed by a force-directed-like energy minimization using basinhopping.\n    The energy function is based on a 1/r^p potential (p=12), normalized by the maximum \n    pairwise distance, which aligns with the objective of maximizing the min/max ratio.\n    \"\"\"\n    n = 14\n    dim = 3\n    p = 12\n    \n    # 1. Initial Configuration: Golden-section sphere points\n    # This provides a uniformly distributed set of points on a sphere, which is\n    # a strong starting point for maximizing minimum pairwise distances.\n    phi = np.pi * (3. - np.sqrt(5.))  # Golden angle in radians\n    X_init = []\n    for i in range(n):\n        y = 1 - (i / float(n - 1)) * 2  # y goes from 1 to -1\n        radius = np.sqrt(abs(1 - y * y))  # radius at y\n        theta = phi * i  # golden angle increment\n        X_init.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n    X = np.array(X_init)\n    \n    # Add a small amount of random noise to the initial configuration to break \n    # symmetry and allow for exploration during the optimization.\n    np.random.seed(42)\n    X += np.random.normal(0, 0.05, X.shape)\n    \n    # 2. Objective Function\n    # We define an energy function based on the repulsive force 1/r^p (p=12).\n    # To maximize the ratio (min distance / max distance), we normalize the \n    # squared distances by the maximum squared distance in each step.\n    def get_energy(flat_X):\n        X_curr = flat_X.reshape((n, dim))\n        \n        # Centering the points helps maintain numerical stability\n        X_curr = X_curr - np.mean(X_curr, axis=0)\n        \n        # Compute pairwise squared distances\n        diff = X_curr[:, np.newaxis, :] - X_curr[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        \n        # Maximize the ratio: normalize all distances by the maximum distance\n        max_d2 = np.max(dist_sq)\n        if max_d2 < 1e-9:\n            return 1e10\n            \n        # Extract only the off-diagonal elements to compute the energy\n        mask = ~np.eye(n, dtype=bool)\n        dist_sq_off = dist_sq[mask]\n        \n        # Energy is the sum of (1/r)^p. Minimizing this pushes points apart relative to max_d.\n        # This is equivalent to maximizing the minimum distance.\n        energy = np.sum((dist_sq_off / max_d2)**(-p/2))\n        return energy\n\n    # 3. Optimization using Basinhopping\n    # Basinhopping is a global optimization technique that performs a series of local \n    # minimizations (L-BFGS-B) interspersed with random jumps to explore the energy landscape.\n    # T=0.01 is used as a low temperature for refinement.\n    minimizer_kwargs = {\"method\": \"L-BFGS-B\"}\n    res = basinhopping(\n        get_energy, \n        X.flatten(), \n        niter=50, \n        T=0.01, \n        minimizer_kwargs=minimizer_kwargs\n    )\n    \n    # Reshape the flattened result back into (14, 3)\n    X_final = res.x.reshape((n, dim))\n    \n    return X_final",
  "metrics": {
    "valid": true,
    "score": 0.916948070974391,
    "min_max_ratio": 0.2201106910378871,
    "min_distance": 1.3525563256482287,
    "max_distance": 2.8829346051821156,
    "eval_time": 12.065608978271484,
    "error": null
  },
  "prompt": "Use a force-directed layout (repulsive forces proportional to 1/r^p where p=12) to find an initial configuration for 14 points. Then, refine this configuration using 'scipy.optimize.basinhopping' with a low temperature to find the local maximum of the minimum distance.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space to maximize the squared ratio \n    (min pairwise distance / max pairwise distance)^2.\n    \n    The algorithm uses an initial configuration based on a golden-section sphere distribution,\n    followed by a force-directed-like energy minimization using basinhopping.\n    The energy function is based on a 1/r^p potential (p=12), normalized by the maximum \n    pairwise distance, which aligns with the objective of maximizing the min/max ratio.\n    \"\"\"\n    n = 14\n    dim = 3\n    p = 12\n    \n    # 1. Initial Configuration: Golden-section sphere points\n    # This provides a uniformly distributed set of points on a sphere, which is\n    # a strong starting point for maximizing minimum pairwise distances.\n    phi = np.pi * (3. - np.sqrt(5.))  # Golden angle in radians\n    X_init = []\n    for i in range(n):\n        y = 1 - (i / float(n - 1)) * 2  # y goes from 1 to -1\n        radius = np.sqrt(abs(1 - y * y))  # radius at y\n        theta = phi * i  # golden angle increment\n        X_init.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n    X = np.array(X_init)\n    \n    # Add a small amount of random noise to the initial configuration to break \n    # symmetry and allow for exploration during the optimization.\n    np.random.seed(42)\n    X += np.random.normal(0, 0.05, X.shape)\n    \n    # 2. Objective Function\n    # We define an energy function based on the repulsive force 1/r^p (p=12).\n    # To maximize the ratio (min distance / max distance), we normalize the \n    # squared distances by the maximum squared distance in each step.\n    def get_energy(flat_X):\n        X_curr = flat_X.reshape((n, dim))\n        \n        # Centering the points helps maintain numerical stability\n        X_curr = X_curr - np.mean(X_curr, axis=0)\n        \n        # Compute pairwise squared distances\n        diff = X_curr[:, np.newaxis, :] - X_curr[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        \n        # Maximize the ratio: normalize all distances by the maximum distance\n        max_d2 = np.max(dist_sq)\n        if max_d2 < 1e-9:\n            return 1e10\n            \n        # Extract only the off-diagonal elements to compute the energy\n        mask = ~np.eye(n, dtype=bool)\n        dist_sq_off = dist_sq[mask]\n        \n        # Energy is the sum of (1/r)^p. Minimizing this pushes points apart relative to max_d.\n        # This is equivalent to maximizing the minimum distance.\n        energy = np.sum((dist_sq_off / max_d2)**(-p/2))\n        return energy\n\n    # 3. Optimization using Basinhopping\n    # Basinhopping is a global optimization technique that performs a series of local \n    # minimizations (L-BFGS-B) interspersed with random jumps to explore the energy landscape.\n    # T=0.01 is used as a low temperature for refinement.\n    minimizer_kwargs = {\"method\": \"L-BFGS-B\"}\n    res = basinhopping(\n        get_energy, \n        X.flatten(), \n        niter=50, \n        T=0.01, \n        minimizer_kwargs=minimizer_kwargs\n    )\n    \n    # Reshape the flattened result back into (14, 3)\n    X_final = res.x.reshape((n, dim))\n    \n    return X_final\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:21:37.333335",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 237,
        "candidates_token_count": 962,
        "thoughts_token_count": 17454
      },
      "response_text_len": 3243
    }
  }
}