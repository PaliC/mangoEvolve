{
  "trial_id": "trial_2_8",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance).\n    Uses a simulated annealing approach with multiple restarts and local refinement.\n    \"\"\"\n    start_time = time.time()\n    n_pts = 14\n    \n    def get_score(p):\n        \"\"\"Calculates the ratio of minimum pairwise distance to maximum pairwise distance.\"\"\"\n        dists = pdist(p)\n        if len(dists) == 0:\n            return 0\n        d_min = np.min(dists)\n        d_max = np.max(dists)\n        if d_max == 0:\n            return 0\n        return d_min / d_max\n\n    # Initialize with a random configuration\n    best_pts = np.random.randn(n_pts, 3)\n    best_score = get_score(best_pts)\n    \n    # Global search loop with multiple restarts\n    while time.time() - start_time < 45:\n        # Start with points on a unit sphere as a promising initial state\n        pts = np.random.randn(n_pts, 3)\n        pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        \n        curr_score = get_score(pts)\n        \n        # Simulated Annealing schedule\n        T = 0.1\n        for i in range(15000):\n            # Pick a random point to perturb\n            idx = np.random.randint(n_pts)\n            old_p = pts[idx].copy()\n            \n            # Move point by a small random vector proportional to temperature\n            pts[idx] += np.random.normal(0, T, 3)\n            \n            new_score = get_score(pts)\n            \n            # Acceptance criteria (Metropolis-Hastings)\n            if new_score > curr_score:\n                curr_score = new_score\n                if curr_score > best_score:\n                    best_score = curr_score\n                    best_pts = pts.copy()\n            elif T > 1e-9 and np.random.rand() < np.exp((new_score - curr_score) / T):\n                curr_score = new_score\n            else:\n                pts[idx] = old_p\n            \n            # Cooling\n            if i % 400 == 0:\n                T *= 0.92\n                if T < 1e-8:\n                    break\n        \n        # Periodic greedy refinement on the current best candidate\n        refine_pts = best_pts.copy()\n        refine_score = best_score\n        T_refine = 1e-4\n        for i in range(3000):\n            idx = np.random.randint(n_pts)\n            old_p = refine_pts[idx].copy()\n            refine_pts[idx] += np.random.normal(0, T_refine, 3)\n            new_score = get_score(refine_pts)\n            if new_score > refine_score:\n                refine_score = new_score\n                if refine_score > best_score:\n                    best_score = refine_score\n                    best_pts = refine_pts.copy()\n            else:\n                refine_pts[idx] = old_p\n            if i % 1000 == 0:\n                T_refine *= 0.5\n\n    # Final polish of the absolute best configuration found\n    for _ in range(3):\n        T_final = 1e-5\n        for i in range(10000):\n            idx = np.random.randint(n_pts)\n            old_p = best_pts[idx].copy()\n            best_pts[idx] += np.random.normal(0, T_final, 3)\n            new_score = get_score(best_pts)\n            if new_score > best_score:\n                best_score = new_score\n            else:\n                best_pts[idx] = old_p\n            if i % 2000 == 0:\n                T_final *= 0.5\n                \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.5265092893368767,
    "min_max_ratio": 0.12638700836205088,
    "min_distance": 0.9656567821709882,
    "max_distance": 2.7162615000775303,
    "eval_time": 45.68974184989929,
    "error": null
  },
  "prompt": "Try a 'simulated annealing' approach from scratch. Start with 14 points on a sphere. In each step, move a point slightly and accept the move if the minimum distance increases, or with a probability if it decreases. Gradually decrease the step size.",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance).\n    Uses a simulated annealing approach with multiple restarts and local refinement.\n    \"\"\"\n    start_time = time.time()\n    n_pts = 14\n    \n    def get_score(p):\n        \"\"\"Calculates the ratio of minimum pairwise distance to maximum pairwise distance.\"\"\"\n        dists = pdist(p)\n        if len(dists) == 0:\n            return 0\n        d_min = np.min(dists)\n        d_max = np.max(dists)\n        if d_max == 0:\n            return 0\n        return d_min / d_max\n\n    # Initialize with a random configuration\n    best_pts = np.random.randn(n_pts, 3)\n    best_score = get_score(best_pts)\n    \n    # Global search loop with multiple restarts\n    while time.time() - start_time < 45:\n        # Start with points on a unit sphere as a promising initial state\n        pts = np.random.randn(n_pts, 3)\n        pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        \n        curr_score = get_score(pts)\n        \n        # Simulated Annealing schedule\n        T = 0.1\n        for i in range(15000):\n            # Pick a random point to perturb\n            idx = np.random.randint(n_pts)\n            old_p = pts[idx].copy()\n            \n            # Move point by a small random vector proportional to temperature\n            pts[idx] += np.random.normal(0, T, 3)\n            \n            new_score = get_score(pts)\n            \n            # Acceptance criteria (Metropolis-Hastings)\n            if new_score > curr_score:\n                curr_score = new_score\n                if curr_score > best_score:\n                    best_score = curr_score\n                    best_pts = pts.copy()\n            elif T > 1e-9 and np.random.rand() < np.exp((new_score - curr_score) / T):\n                curr_score = new_score\n            else:\n                pts[idx] = old_p\n            \n            # Cooling\n            if i % 400 == 0:\n                T *= 0.92\n                if T < 1e-8:\n                    break\n        \n        # Periodic greedy refinement on the current best candidate\n        refine_pts = best_pts.copy()\n        refine_score = best_score\n        T_refine = 1e-4\n        for i in range(3000):\n            idx = np.random.randint(n_pts)\n            old_p = refine_pts[idx].copy()\n            refine_pts[idx] += np.random.normal(0, T_refine, 3)\n            new_score = get_score(refine_pts)\n            if new_score > refine_score:\n                refine_score = new_score\n                if refine_score > best_score:\n                    best_score = refine_score\n                    best_pts = refine_pts.copy()\n            else:\n                refine_pts[idx] = old_p\n            if i % 1000 == 0:\n                T_refine *= 0.5\n\n    # Final polish of the absolute best configuration found\n    for _ in range(3):\n        T_final = 1e-5\n        for i in range(10000):\n            idx = np.random.randint(n_pts)\n            old_p = best_pts[idx].copy()\n            best_pts[idx] += np.random.normal(0, T_final, 3)\n            new_score = get_score(best_pts)\n            if new_score > best_score:\n                best_score = new_score\n            else:\n                best_pts[idx] = old_p\n            if i % 2000 == 0:\n                T_final *= 0.5\n                \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:22:42.053458",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 225,
        "candidates_token_count": 1017,
        "thoughts_token_count": 20475
      },
      "response_text_len": 3437
    }
  }
}