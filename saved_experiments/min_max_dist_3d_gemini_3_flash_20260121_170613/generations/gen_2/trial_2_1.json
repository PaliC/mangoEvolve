{
  "trial_id": "trial_2_1",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance).\n    The approach uses a multi-start optimization with a repulsive potential followed by \n    SLSQP polishing to refine the best configurations.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    # Objective function for the initial search (repulsive potential)\n    # Using a high power (d^-16) helps in maximizing the minimum distance.\n    def objective(coords_flat):\n        coords = coords_flat.reshape((N, dim))\n        dists_sq = pdist(coords, 'sqeuclidean')\n        return np.sum(1.0 / (dists_sq**8 + 1e-12))\n\n    results = []\n    \n    # Multi-start approach: 50 random initial configurations\n    for i in range(50):\n        # Mix of random initialization strategies: cube and sphere\n        if i < 25:\n            # Random points in a unit cube\n            p0 = np.random.uniform(-0.5, 0.5, (N, dim))\n        else:\n            # Random points on a sphere\n            p0 = np.random.normal(0, 1, (N, dim))\n            norms = np.linalg.norm(p0, axis=1)[:, np.newaxis]\n            p0 = (p0 / (norms + 1e-12)) * 0.5\n            \n        # Fast optimization using L-BFGS-B\n        res = minimize(objective, p0.ravel(), method='L-BFGS-B', tol=1e-7)\n        \n        if res.success or True:  # Use the result even if it didn't strictly converge\n            pts = res.x.reshape((N, dim))\n            dists = pdist(pts)\n            if len(dists) > 0:\n                d_min = np.min(dists)\n                d_max = np.max(dists)\n                if d_max > 1e-8:\n                    score = (d_min / d_max)**2\n                    results.append((score, pts))\n    \n    # If no results found (unlikely), return random points\n    if not results:\n        return np.random.uniform(-0.5, 0.5, (N, dim))\n\n    # Sort results to find the most promising candidates for polishing\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_pts = results[0][1]\n    best_score = results[0][0]\n    \n    # Polishing step: directly maximize the minimum distance\n    # Variables: 14 * 3 coordinates + 1 slack variable (min distance squared)\n    def polish_objective(x):\n        return -x[-1]\n\n    def polish_constraints(x):\n        p = x[:-1].reshape((N, dim))\n        dists_sq = pdist(p, 'sqeuclidean')\n        # All dists^2 >= d_min_sq, and all dists^2 <= 1.0 (to fix max distance)\n        c_min = dists_sq - x[-1]\n        c_max = 1.0 - dists_sq\n        return np.concatenate([c_min, c_max])\n\n    # Refine the top 5 candidates using SLSQP\n    for i in range(min(5, len(results))):\n        pts = results[i][1]\n        d_max = np.max(pdist(pts))\n        pts = pts / d_max\n        \n        # Initial guess for x: coordinates and the current min squared distance\n        x0 = np.concatenate([pts.ravel(), [np.min(pdist(pts, 'sqeuclidean'))]])\n        \n        res_polish = minimize(polish_objective, x0, method='SLSQP',\n                              constraints={'type': 'ineq', 'fun': polish_constraints},\n                              options={'maxiter': 100})\n        \n        if res_polish.success:\n            pts_p = res_polish.x[:-1].reshape((N, dim))\n            dists_p = pdist(pts_p)\n            d_min_p = np.min(dists_p)\n            d_max_p = np.max(dists_p)\n            if d_max_p > 1e-8:\n                score_p = (d_min_p / d_max_p)**2\n                if score_p > best_score:\n                    best_score = score_p\n                    best_pts = pts_p / d_max_p\n        else:\n            # Check if the result is still an improvement even if SLSQP didn't reach success\n            pts_p = res_polish.x[:-1].reshape((N, dim))\n            dists_p = pdist(pts_p)\n            d_min_p = np.min(dists_p)\n            d_max_p = np.max(dists_p)\n            if d_max_p > 1e-8:\n                score_p = (d_min_p / d_max_p)**2\n                if score_p > best_score:\n                    best_score = score_p\n                    best_pts = pts_p / d_max_p\n                    \n    # Ensure final normalization\n    d_max = np.max(pdist(best_pts))\n    return best_pts / d_max",
  "metrics": {
    "valid": true,
    "score": 0.9994306985930083,
    "min_max_ratio": 0.2399104035172011,
    "min_distance": 0.4898064959932658,
    "max_distance": 1.0,
    "eval_time": 2.4202380180358887,
    "error": null
  },
  "prompt": "Try a multi-start optimization approach using 'scipy.optimize.minimize' with the 'SLSQP' method. Generate 50 random initial configurations of 14 points in a unit cube, optimize each to maximize the minimum pairwise distance, and return the best result. Normalize the final coordinates so the max distance is 1.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance).\n    The approach uses a multi-start optimization with a repulsive potential followed by \n    SLSQP polishing to refine the best configurations.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    # Objective function for the initial search (repulsive potential)\n    # Using a high power (d^-16) helps in maximizing the minimum distance.\n    def objective(coords_flat):\n        coords = coords_flat.reshape((N, dim))\n        dists_sq = pdist(coords, 'sqeuclidean')\n        return np.sum(1.0 / (dists_sq**8 + 1e-12))\n\n    results = []\n    \n    # Multi-start approach: 50 random initial configurations\n    for i in range(50):\n        # Mix of random initialization strategies: cube and sphere\n        if i < 25:\n            # Random points in a unit cube\n            p0 = np.random.uniform(-0.5, 0.5, (N, dim))\n        else:\n            # Random points on a sphere\n            p0 = np.random.normal(0, 1, (N, dim))\n            norms = np.linalg.norm(p0, axis=1)[:, np.newaxis]\n            p0 = (p0 / (norms + 1e-12)) * 0.5\n            \n        # Fast optimization using L-BFGS-B\n        res = minimize(objective, p0.ravel(), method='L-BFGS-B', tol=1e-7)\n        \n        if res.success or True:  # Use the result even if it didn't strictly converge\n            pts = res.x.reshape((N, dim))\n            dists = pdist(pts)\n            if len(dists) > 0:\n                d_min = np.min(dists)\n                d_max = np.max(dists)\n                if d_max > 1e-8:\n                    score = (d_min / d_max)**2\n                    results.append((score, pts))\n    \n    # If no results found (unlikely), return random points\n    if not results:\n        return np.random.uniform(-0.5, 0.5, (N, dim))\n\n    # Sort results to find the most promising candidates for polishing\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_pts = results[0][1]\n    best_score = results[0][0]\n    \n    # Polishing step: directly maximize the minimum distance\n    # Variables: 14 * 3 coordinates + 1 slack variable (min distance squared)\n    def polish_objective(x):\n        return -x[-1]\n\n    def polish_constraints(x):\n        p = x[:-1].reshape((N, dim))\n        dists_sq = pdist(p, 'sqeuclidean')\n        # All dists^2 >= d_min_sq, and all dists^2 <= 1.0 (to fix max distance)\n        c_min = dists_sq - x[-1]\n        c_max = 1.0 - dists_sq\n        return np.concatenate([c_min, c_max])\n\n    # Refine the top 5 candidates using SLSQP\n    for i in range(min(5, len(results))):\n        pts = results[i][1]\n        d_max = np.max(pdist(pts))\n        pts = pts / d_max\n        \n        # Initial guess for x: coordinates and the current min squared distance\n        x0 = np.concatenate([pts.ravel(), [np.min(pdist(pts, 'sqeuclidean'))]])\n        \n        res_polish = minimize(polish_objective, x0, method='SLSQP',\n                              constraints={'type': 'ineq', 'fun': polish_constraints},\n                              options={'maxiter': 100})\n        \n        if res_polish.success:\n            pts_p = res_polish.x[:-1].reshape((N, dim))\n            dists_p = pdist(pts_p)\n            d_min_p = np.min(dists_p)\n            d_max_p = np.max(dists_p)\n            if d_max_p > 1e-8:\n                score_p = (d_min_p / d_max_p)**2\n                if score_p > best_score:\n                    best_score = score_p\n                    best_pts = pts_p / d_max_p\n        else:\n            # Check if the result is still an improvement even if SLSQP didn't reach success\n            pts_p = res_polish.x[:-1].reshape((N, dim))\n            dists_p = pdist(pts_p)\n            d_min_p = np.min(dists_p)\n            d_max_p = np.max(dists_p)\n            if d_max_p > 1e-8:\n                score_p = (d_min_p / d_max_p)**2\n                if score_p > best_score:\n                    best_score = score_p\n                    best_pts = pts_p / d_max_p\n                    \n    # Ensure final normalization\n    d_max = np.max(pdist(best_pts))\n    return best_pts / d_max\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:21:41.418867",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 241,
        "candidates_token_count": 1326,
        "thoughts_token_count": 17557
      },
      "response_text_len": 4201
    }
  }
}