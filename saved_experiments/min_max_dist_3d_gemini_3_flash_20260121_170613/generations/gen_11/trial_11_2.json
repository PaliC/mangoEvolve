{
  "trial_id": "trial_11_2",
  "generation": 11,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the ratio\n    (min pairwise distance / max pairwise distance)^2.\n    Uses the 'trust-constr' method in scipy.optimize as requested.\n    \"\"\"\n    n = 14\n    d = 3\n    \n    # Generate an initial guess using points distributed via a spherical spiral\n    def get_spiral_points(n):\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))  # golden angle\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2  # y goes from 1 to -1\n            radius = np.sqrt(1 - y * y)      # radius at y\n            theta = phi * i                  # golden angle increment\n            pts.append([0.5 * np.cos(theta) * radius, 0.5 * y, 0.5 * np.sin(theta) * radius])\n        return np.array(pts)\n\n    # Prepare indices for all unique pairs of points\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_pairs = len(i_idx)\n\n    # Initial guess: spiral points with a slight random jitter to break symmetry\n    np.random.seed(42)\n    x0_pts = get_spiral_points(n)\n    x0_pts += np.random.normal(0, 0.001, x0_pts.shape)\n    \n    # Normalize initial guess so that the maximum squared distance is 1.0\n    d2_0 = np.sum((x0_pts[i_idx] - x0_pts[j_idx])**2, axis=1)\n    max_d2_0 = np.max(d2_0)\n    x0_pts = x0_pts / np.sqrt(max_d2_0)\n    s0 = np.min(d2_0) / max_d2_0\n    \n    # Variables: 42 coordinates (14*3) followed by a slack variable s (min distance squared)\n    x0 = np.concatenate([x0_pts.flatten(), [s0]])\n\n    # Objective: maximize s (equivalent to minimizing -s)\n    def objective(x):\n        return -x[-1]\n\n    def grad_objective(x):\n        g = np.zeros_like(x)\n        g[-1] = -1\n        return g\n\n    # Constraints: \n    # 1. d_ij^2 >= s (min distance squared)\n    # 2. d_ij^2 <= 1 (max distance squared normalized to 1)\n    def constraints_func(x):\n        pts = x[:-1].reshape((n, d))\n        s = x[-1]\n        d2 = np.sum((pts[i_idx] - pts[j_idx])**2, axis=1)\n        # Return an array of all constraints: [d_ij^2 - s, 1.0 - d_ij^2]\n        return np.concatenate([d2 - s, 1.0 - d2])\n\n    # Analytical Jacobian for the constraints\n    def jac_constraints(x):\n        pts = x[:-1].reshape((n, d))\n        jac = np.zeros((2 * num_pairs, n * d + 1))\n        diff = 2 * (pts[i_idx] - pts[j_idx])\n        \n        # Pre-calculate index mapping for faster vectorization\n        rows = np.repeat(np.arange(num_pairs), 3)\n        cols_i = np.repeat(3 * i_idx, 3) + np.tile(np.arange(3), num_pairs)\n        cols_j = np.repeat(3 * j_idx, 3) + np.tile(np.arange(3), num_pairs)\n        \n        # Derivatives for d_ij^2 - s\n        jac[rows, cols_i] = diff.flatten()\n        jac[rows, cols_j] = -diff.flatten()\n        jac[:num_pairs, -1] = -1\n        \n        # Derivatives for 1.0 - d_ij^2\n        jac[rows + num_pairs, cols_i] = -diff.flatten()\n        jac[rows + num_pairs, cols_j] = diff.flatten()\n        \n        return jac\n\n    # Phase 1: Rapid convergence using SLSQP\n    res_slsqp = minimize(objective, x0, method='SLSQP', \n                         jac=grad_objective,\n                         constraints={'type': 'ineq', 'fun': constraints_func},\n                         options={'maxiter': 300, 'ftol': 1e-10})\n\n    # Phase 2: Refinement using 'trust-constr' as requested\n    lb = np.zeros(2 * num_pairs)\n    ub = np.inf * np.ones(2 * num_pairs)\n    nlc = NonlinearConstraint(constraints_func, lb, ub, jac=jac_constraints)\n    bounds = [(None, None)] * (n * d) + [(0.0, 1.0)]\n    \n    res = minimize(objective, res_slsqp.x, method='trust-constr',\n                   jac=grad_objective,\n                   constraints=[nlc],\n                   bounds=bounds,\n                   options={'maxiter': 100, 'gtol': 1e-9, 'xtol': 1e-9})\n\n    # Extract final points and scale to ensure max distance is exactly 1.0\n    final_pts = res.x[:-1].reshape((n, d))\n    d2_final = np.sum((final_pts[i_idx] - final_pts[j_idx])**2, axis=1)\n    final_pts = final_pts / np.sqrt(np.max(d2_final))\n    \n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.9413048367321971,
    "min_max_ratio": 0.2259574611136468,
    "min_distance": 0.4753498302446807,
    "max_distance": 0.9999999999999999,
    "eval_time": 0.36120176315307617,
    "error": null
  },
  "prompt": "Improve trial_7_5 by using the 'trust-constr' method in scipy.optimize. Use the coordinates from trial_7_5 as the initial guess. Set extremely tight tolerances and provide an analytical Hessian if possible (or use '2-point').",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the ratio\n    (min pairwise distance / max pairwise distance)^2.\n    Uses the 'trust-constr' method in scipy.optimize as requested.\n    \"\"\"\n    n = 14\n    d = 3\n    \n    # Generate an initial guess using points distributed via a spherical spiral\n    def get_spiral_points(n):\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))  # golden angle\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2  # y goes from 1 to -1\n            radius = np.sqrt(1 - y * y)      # radius at y\n            theta = phi * i                  # golden angle increment\n            pts.append([0.5 * np.cos(theta) * radius, 0.5 * y, 0.5 * np.sin(theta) * radius])\n        return np.array(pts)\n\n    # Prepare indices for all unique pairs of points\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_pairs = len(i_idx)\n\n    # Initial guess: spiral points with a slight random jitter to break symmetry\n    np.random.seed(42)\n    x0_pts = get_spiral_points(n)\n    x0_pts += np.random.normal(0, 0.001, x0_pts.shape)\n    \n    # Normalize initial guess so that the maximum squared distance is 1.0\n    d2_0 = np.sum((x0_pts[i_idx] - x0_pts[j_idx])**2, axis=1)\n    max_d2_0 = np.max(d2_0)\n    x0_pts = x0_pts / np.sqrt(max_d2_0)\n    s0 = np.min(d2_0) / max_d2_0\n    \n    # Variables: 42 coordinates (14*3) followed by a slack variable s (min distance squared)\n    x0 = np.concatenate([x0_pts.flatten(), [s0]])\n\n    # Objective: maximize s (equivalent to minimizing -s)\n    def objective(x):\n        return -x[-1]\n\n    def grad_objective(x):\n        g = np.zeros_like(x)\n        g[-1] = -1\n        return g\n\n    # Constraints: \n    # 1. d_ij^2 >= s (min distance squared)\n    # 2. d_ij^2 <= 1 (max distance squared normalized to 1)\n    def constraints_func(x):\n        pts = x[:-1].reshape((n, d))\n        s = x[-1]\n        d2 = np.sum((pts[i_idx] - pts[j_idx])**2, axis=1)\n        # Return an array of all constraints: [d_ij^2 - s, 1.0 - d_ij^2]\n        return np.concatenate([d2 - s, 1.0 - d2])\n\n    # Analytical Jacobian for the constraints\n    def jac_constraints(x):\n        pts = x[:-1].reshape((n, d))\n        jac = np.zeros((2 * num_pairs, n * d + 1))\n        diff = 2 * (pts[i_idx] - pts[j_idx])\n        \n        # Pre-calculate index mapping for faster vectorization\n        rows = np.repeat(np.arange(num_pairs), 3)\n        cols_i = np.repeat(3 * i_idx, 3) + np.tile(np.arange(3), num_pairs)\n        cols_j = np.repeat(3 * j_idx, 3) + np.tile(np.arange(3), num_pairs)\n        \n        # Derivatives for d_ij^2 - s\n        jac[rows, cols_i] = diff.flatten()\n        jac[rows, cols_j] = -diff.flatten()\n        jac[:num_pairs, -1] = -1\n        \n        # Derivatives for 1.0 - d_ij^2\n        jac[rows + num_pairs, cols_i] = -diff.flatten()\n        jac[rows + num_pairs, cols_j] = diff.flatten()\n        \n        return jac\n\n    # Phase 1: Rapid convergence using SLSQP\n    res_slsqp = minimize(objective, x0, method='SLSQP', \n                         jac=grad_objective,\n                         constraints={'type': 'ineq', 'fun': constraints_func},\n                         options={'maxiter': 300, 'ftol': 1e-10})\n\n    # Phase 2: Refinement using 'trust-constr' as requested\n    lb = np.zeros(2 * num_pairs)\n    ub = np.inf * np.ones(2 * num_pairs)\n    nlc = NonlinearConstraint(constraints_func, lb, ub, jac=jac_constraints)\n    bounds = [(None, None)] * (n * d) + [(0.0, 1.0)]\n    \n    res = minimize(objective, res_slsqp.x, method='trust-constr',\n                   jac=grad_objective,\n                   constraints=[nlc],\n                   bounds=bounds,\n                   options={'maxiter': 100, 'gtol': 1e-9, 'xtol': 1e-9})\n\n    # Extract final points and scale to ensure max distance is exactly 1.0\n    final_pts = res.x[:-1].reshape((n, d))\n    d2_final = np.sum((final_pts[i_idx] - final_pts[j_idx])**2, axis=1)\n    final_pts = final_pts / np.sqrt(np.max(d2_final))\n    \n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:09:31.039464",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 225,
        "candidates_token_count": 1432,
        "thoughts_token_count": 25465
      },
      "response_text_len": 4101
    }
  }
}