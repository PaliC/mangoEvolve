{
  "trial_id": "trial_11_4",
  "generation": 11,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses Basin-hopping with a very small stepsize (1e-4) to refine local optima.\n    \"\"\"\n    N = 14\n    # Pre-calculate indices for efficiency\n    idx = np.triu_indices(N, k=1)\n\n    def objective(x):\n        # Reshape to (14, 3)\n        p = x.reshape((N, 3))\n        # Calculate all pairwise squared distances\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=2)\n        # Extract upper triangle distances\n        valid_d2 = d2[idx]\n        min_d2 = np.min(valid_d2)\n        max_d2 = np.max(valid_d2)\n        # Avoid division by zero\n        if max_d2 < 1e-12:\n            return 0\n        # Minimize negative squared ratio\n        return -min_d2 / max_d2\n\n    # Helper functions to generate high-quality starting configurations\n    def get_1_6_6_1(h):\n        pts = [[0, 0, 1], [0, 0, -1]]\n        r = np.sqrt(max(0, 1 - h**2))\n        for i in range(6):\n            angle = 2 * np.pi * i / 6\n            pts.append([r * np.cos(angle), r * np.sin(angle), h])\n        for i in range(6):\n            angle = 2 * np.pi * (i + 0.5) / 6\n            pts.append([r * np.cos(angle), r * np.sin(angle), -h])\n        return np.array(pts).flatten()\n\n    def get_1_3_3_3_3_1(h1, h2):\n        pts = [[0, 0, 1], [0, 0, -1]]\n        for h, offset in [(h1, 0), (h2, 0.5), (-h2, 0), (-h1, 0.5)]:\n            r = np.sqrt(max(0, 1 - h**2))\n            for i in range(3):\n                angle = 2 * np.pi * (i + offset) / 3\n                pts.append([r * np.cos(angle), r * np.sin(angle), h])\n        return np.array(pts).flatten()\n\n    def get_fibonacci(n):\n        phi = np.pi * (3. - np.sqrt(5.))\n        pts = []\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            radius = np.sqrt(max(0, 1 - y * y))\n            theta = phi * i\n            pts.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n        return np.array(pts).flatten()\n\n    # List of starting points representing different potential symmetries\n    starts = [\n        get_fibonacci(N),\n        get_1_6_6_1(0.35),\n        get_1_6_6_1(0.65),\n        get_1_3_3_3_3_1(0.7, 0.25),\n        get_1_3_3_3_3_1(0.85, 0.45)\n    ]\n    \n    # Random start for robustness\n    np.random.seed(42)\n    starts.append(np.random.uniform(-1, 1, (N, 3)).flatten())\n\n    best_pts = None\n    best_val = np.inf\n    \n    # Initial local optimization to find a good basin\n    for start_pts in starts:\n        res = minimize(objective, start_pts, method='L-BFGS-B', options={'ftol': 1e-10})\n        if res.fun < best_val:\n            best_val = res.fun\n            best_pts = res.x\n            \n    # Basin-hopping refinement with very small stepsize (1e-4) as requested\n    # This specifically searches the immediate vicinity of the best found local optimum\n    minimizer_kwargs = {\"method\": \"L-BFGS-B\", \"options\": {\"ftol\": 1e-12}}\n    res = basinhopping(objective, best_pts, niter=60, stepsize=1e-4, \n                       minimizer_kwargs=minimizer_kwargs)\n    \n    # Final high-precision local refinement\n    final_res = minimize(objective, res.x, method='L-BFGS-B', options={'ftol': 1e-14, 'gtol': 1e-14})\n    \n    return final_res.x.reshape((N, 3))",
  "metrics": {
    "valid": true,
    "score": 0.9310446693534582,
    "min_max_ratio": 0.22349453807210667,
    "min_distance": 0.9518405388028524,
    "max_distance": 2.01340313466542,
    "eval_time": 10.635324954986572,
    "error": null
  },
  "prompt": "Use Basin-hopping with a very small 'stepsize' (e.g., 1e-4) starting from the trial_7_5 configuration. This aims to find a slightly better local optimum in the immediate vicinity of the current best.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses Basin-hopping with a very small stepsize (1e-4) to refine local optima.\n    \"\"\"\n    N = 14\n    # Pre-calculate indices for efficiency\n    idx = np.triu_indices(N, k=1)\n\n    def objective(x):\n        # Reshape to (14, 3)\n        p = x.reshape((N, 3))\n        # Calculate all pairwise squared distances\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=2)\n        # Extract upper triangle distances\n        valid_d2 = d2[idx]\n        min_d2 = np.min(valid_d2)\n        max_d2 = np.max(valid_d2)\n        # Avoid division by zero\n        if max_d2 < 1e-12:\n            return 0\n        # Minimize negative squared ratio\n        return -min_d2 / max_d2\n\n    # Helper functions to generate high-quality starting configurations\n    def get_1_6_6_1(h):\n        pts = [[0, 0, 1], [0, 0, -1]]\n        r = np.sqrt(max(0, 1 - h**2))\n        for i in range(6):\n            angle = 2 * np.pi * i / 6\n            pts.append([r * np.cos(angle), r * np.sin(angle), h])\n        for i in range(6):\n            angle = 2 * np.pi * (i + 0.5) / 6\n            pts.append([r * np.cos(angle), r * np.sin(angle), -h])\n        return np.array(pts).flatten()\n\n    def get_1_3_3_3_3_1(h1, h2):\n        pts = [[0, 0, 1], [0, 0, -1]]\n        for h, offset in [(h1, 0), (h2, 0.5), (-h2, 0), (-h1, 0.5)]:\n            r = np.sqrt(max(0, 1 - h**2))\n            for i in range(3):\n                angle = 2 * np.pi * (i + offset) / 3\n                pts.append([r * np.cos(angle), r * np.sin(angle), h])\n        return np.array(pts).flatten()\n\n    def get_fibonacci(n):\n        phi = np.pi * (3. - np.sqrt(5.))\n        pts = []\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            radius = np.sqrt(max(0, 1 - y * y))\n            theta = phi * i\n            pts.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n        return np.array(pts).flatten()\n\n    # List of starting points representing different potential symmetries\n    starts = [\n        get_fibonacci(N),\n        get_1_6_6_1(0.35),\n        get_1_6_6_1(0.65),\n        get_1_3_3_3_3_1(0.7, 0.25),\n        get_1_3_3_3_3_1(0.85, 0.45)\n    ]\n    \n    # Random start for robustness\n    np.random.seed(42)\n    starts.append(np.random.uniform(-1, 1, (N, 3)).flatten())\n\n    best_pts = None\n    best_val = np.inf\n    \n    # Initial local optimization to find a good basin\n    for start_pts in starts:\n        res = minimize(objective, start_pts, method='L-BFGS-B', options={'ftol': 1e-10})\n        if res.fun < best_val:\n            best_val = res.fun\n            best_pts = res.x\n            \n    # Basin-hopping refinement with very small stepsize (1e-4) as requested\n    # This specifically searches the immediate vicinity of the best found local optimum\n    minimizer_kwargs = {\"method\": \"L-BFGS-B\", \"options\": {\"ftol\": 1e-12}}\n    res = basinhopping(objective, best_pts, niter=60, stepsize=1e-4, \n                       minimizer_kwargs=minimizer_kwargs)\n    \n    # Final high-precision local refinement\n    final_res = minimize(objective, res.x, method='L-BFGS-B', options={'ftol': 1e-14, 'gtol': 1e-14})\n    \n    return final_res.x.reshape((N, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:08:33.800561",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 223,
        "candidates_token_count": 1220,
        "thoughts_token_count": 15707
      },
      "response_text_len": 3393
    }
  }
}