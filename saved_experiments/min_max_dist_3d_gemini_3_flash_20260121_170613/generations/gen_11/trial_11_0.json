{
  "trial_id": "trial_11_0",
  "generation": 11,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses multi-start SLSQP with a slack variable formulation to refine the solution.\n    \"\"\"\n    N = 14\n\n    def get_initial_points(seed):\n        \"\"\"Generates various starting configurations for the optimization.\"\"\"\n        if seed == 0:\n            # 1-6-6-1 configuration (two poles and two hexagonal rings)\n            pts = [[0, 0, 0.5], [0, 0, -0.5]]\n            h = 0.2\n            r = np.sqrt(max(0, 0.5**2 - h**2))\n            for i in range(6):\n                theta = 2 * np.pi * i / 6\n                pts.append([r * np.cos(theta), r * np.sin(theta), h])\n                pts.append([r * np.cos(theta + np.pi / 6), r * np.sin(theta + np.pi / 6), -h])\n            return np.array(pts)\n        elif seed == 1:\n            # 1-4-4-4-1 configuration (two poles and three rings of four)\n            pts = [[0, 0, 0.5], [0, 0, -0.5]]\n            for i in range(4):\n                t1 = 2 * np.pi * i / 4\n                t2 = 2 * np.pi * (i + 0.5) / 4\n                pts.append([0.4 * np.cos(t1), 0.4 * np.sin(t1), 0.25])\n                pts.append([0.5 * np.cos(t2), 0.5 * np.sin(t2), 0.0])\n                pts.append([0.4 * np.cos(t1), 0.4 * np.sin(t1), -0.25])\n            return np.array(pts)\n        elif seed == 2:\n            # Fibonacci sphere configuration\n            pts = []\n            golden_angle = np.pi * (3 - np.sqrt(5))\n            for i in range(N):\n                z = 1 - (2 * i + 1) / N\n                r = np.sqrt(max(0, 1 - z * z))\n                theta = i * golden_angle\n                pts.append([r * np.cos(theta), r * np.sin(theta), z])\n            return np.array(pts) * 0.5\n        else:\n            # Random distribution on a sphere\n            np.random.seed(seed)\n            pts = np.random.normal(0, 1, (N, 3))\n            pts /= (2 * np.linalg.norm(pts, axis=1)[:, np.newaxis])\n            return pts\n\n    def objective(x):\n        \"\"\"Maximize the slack variable s.\"\"\"\n        return -x[-1]\n\n    def constraints(x):\n        \"\"\"Constraints: d_ij^2 >= s and d_ij^2 <= 1.0.\"\"\"\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        # Calculate pairwise differences and squared distances\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        # Use upper triangle indices to avoid duplicate pairs and self-distances\n        idx = np.triu_indices(N, k=1)\n        d2_tri = d2[idx]\n        # Constraints: d2_tri - s >= 0 and 1.0 - d2_tri >= 0\n        return np.concatenate([d2_tri - s, 1.0 - d2_tri])\n\n    best_x = None\n    best_val = float('inf')\n    # Bounds for coordinates and the squared distance ratio slack variable\n    bounds = [(-1.0, 1.0)] * (3 * N) + [(0.0, 1.0)]\n\n    # Multi-start optimization with a quick initial search\n    for seed in range(6):\n        pts_init = get_initial_points(seed)\n        diff = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2_all = np.sum(diff**2, axis=-1)\n        s0 = np.min(d2_all[np.triu_indices(N, k=1)])\n        x0 = np.hstack([pts_init.flatten(), [s0]])\n        \n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       bounds=bounds,\n                       tol=1e-9, options={'maxiter': 200})\n        \n        if res.fun < best_val:\n            best_val = res.fun\n            best_x = res.x\n\n    # Final high-precision polish of the best candidate\n    res_final = minimize(objective, best_x, method='SLSQP', \n                         constraints={'type': 'ineq', 'fun': constraints},\n                         bounds=bounds,\n                         tol=1e-15, options={'maxiter': 2000})\n    \n    # Reshape the output to (14, 3)\n    final_points = res_final.x[:-1].reshape((N, 3))\n    return final_points",
  "metrics": {
    "valid": true,
    "score": 0.9471911259086763,
    "min_max_ratio": 0.22737044754035565,
    "min_distance": 0.4768337734896257,
    "max_distance": 1.0,
    "eval_time": 0.4232137203216553,
    "error": null
  },
  "prompt": "Refine the solution in trial_7_5 (score 1.00001591). Use the coordinates from trial_7_5 as the starting point. Apply a very high-precision SLSQP polish with tol=1e-15 and maxiter=2000. Ensure the slack variable formulation is used: maximize s s.t. d_ij^2 >= s and d_ij^2 <= 1.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses multi-start SLSQP with a slack variable formulation to refine the solution.\n    \"\"\"\n    N = 14\n\n    def get_initial_points(seed):\n        \"\"\"Generates various starting configurations for the optimization.\"\"\"\n        if seed == 0:\n            # 1-6-6-1 configuration (two poles and two hexagonal rings)\n            pts = [[0, 0, 0.5], [0, 0, -0.5]]\n            h = 0.2\n            r = np.sqrt(max(0, 0.5**2 - h**2))\n            for i in range(6):\n                theta = 2 * np.pi * i / 6\n                pts.append([r * np.cos(theta), r * np.sin(theta), h])\n                pts.append([r * np.cos(theta + np.pi / 6), r * np.sin(theta + np.pi / 6), -h])\n            return np.array(pts)\n        elif seed == 1:\n            # 1-4-4-4-1 configuration (two poles and three rings of four)\n            pts = [[0, 0, 0.5], [0, 0, -0.5]]\n            for i in range(4):\n                t1 = 2 * np.pi * i / 4\n                t2 = 2 * np.pi * (i + 0.5) / 4\n                pts.append([0.4 * np.cos(t1), 0.4 * np.sin(t1), 0.25])\n                pts.append([0.5 * np.cos(t2), 0.5 * np.sin(t2), 0.0])\n                pts.append([0.4 * np.cos(t1), 0.4 * np.sin(t1), -0.25])\n            return np.array(pts)\n        elif seed == 2:\n            # Fibonacci sphere configuration\n            pts = []\n            golden_angle = np.pi * (3 - np.sqrt(5))\n            for i in range(N):\n                z = 1 - (2 * i + 1) / N\n                r = np.sqrt(max(0, 1 - z * z))\n                theta = i * golden_angle\n                pts.append([r * np.cos(theta), r * np.sin(theta), z])\n            return np.array(pts) * 0.5\n        else:\n            # Random distribution on a sphere\n            np.random.seed(seed)\n            pts = np.random.normal(0, 1, (N, 3))\n            pts /= (2 * np.linalg.norm(pts, axis=1)[:, np.newaxis])\n            return pts\n\n    def objective(x):\n        \"\"\"Maximize the slack variable s.\"\"\"\n        return -x[-1]\n\n    def constraints(x):\n        \"\"\"Constraints: d_ij^2 >= s and d_ij^2 <= 1.0.\"\"\"\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        # Calculate pairwise differences and squared distances\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=-1)\n        # Use upper triangle indices to avoid duplicate pairs and self-distances\n        idx = np.triu_indices(N, k=1)\n        d2_tri = d2[idx]\n        # Constraints: d2_tri - s >= 0 and 1.0 - d2_tri >= 0\n        return np.concatenate([d2_tri - s, 1.0 - d2_tri])\n\n    best_x = None\n    best_val = float('inf')\n    # Bounds for coordinates and the squared distance ratio slack variable\n    bounds = [(-1.0, 1.0)] * (3 * N) + [(0.0, 1.0)]\n\n    # Multi-start optimization with a quick initial search\n    for seed in range(6):\n        pts_init = get_initial_points(seed)\n        diff = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2_all = np.sum(diff**2, axis=-1)\n        s0 = np.min(d2_all[np.triu_indices(N, k=1)])\n        x0 = np.hstack([pts_init.flatten(), [s0]])\n        \n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       bounds=bounds,\n                       tol=1e-9, options={'maxiter': 200})\n        \n        if res.fun < best_val:\n            best_val = res.fun\n            best_x = res.x\n\n    # Final high-precision polish of the best candidate\n    res_final = minimize(objective, best_x, method='SLSQP', \n                         constraints={'type': 'ineq', 'fun': constraints},\n                         bounds=bounds,\n                         tol=1e-15, options={'maxiter': 2000})\n    \n    # Reshape the output to (14, 3)\n    final_points = res_final.x[:-1].reshape((N, 3))\n    return final_points\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:08:24.637130",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 267,
        "candidates_token_count": 1331,
        "thoughts_token_count": 17045
      },
      "response_text_len": 3984
    }
  }
}