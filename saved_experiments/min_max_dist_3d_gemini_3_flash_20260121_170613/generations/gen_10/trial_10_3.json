{
  "trial_id": "trial_10_3",
  "generation": 10,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses Basin-Hopping with SLSQP as the local minimizer to refine the configuration.\n    \"\"\"\n    N = 14\n    dim = 3\n\n    def get_score_sq(coords):\n        \"\"\"Calculates (min_dist / max_dist)^2.\"\"\"\n        pts = coords.reshape((N, dim))\n        # Compute all pairwise squared Euclidean distances\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        # We only care about off-diagonal elements\n        mask = ~np.eye(N, dtype=bool)\n        d_min_sq = np.min(dists_sq[mask])\n        d_max_sq = np.max(dists_sq[mask])\n        if d_max_sq == 0:\n            return 0.0\n        return d_min_sq / d_max_sq\n\n    def objective(coords):\n        \"\"\"Minimize the negative squared ratio for maximization.\"\"\"\n        return -get_score_sq(coords)\n\n    # Initial high-quality candidate: Capped hexagonal antiprism (2-6-6 structure)\n    # This configuration is often near-optimal for N=14 in packing problems.\n    def generate_seed():\n        h1, h2, r = 0.35, 1.0, 1.0\n        pts = [[0, 0, h2], [0, 0, -h2]]\n        for i in range(6):\n            theta = 2 * np.pi * i / 6\n            # Ring 1\n            pts.append([r * np.cos(theta), r * np.sin(theta), h1])\n            # Ring 2 (offset by 30 degrees)\n            pts.append([r * np.cos(theta + np.pi/6), r * np.sin(theta + np.pi/6), -h1])\n        return np.array(pts).flatten()\n\n    initial_guess = generate_seed()\n\n    # Step 1: Initial local optimization to find a good starting point for Basin-Hopping\n    # Using SLSQP to stabilize the configuration based on the initial geometric guess.\n    res_initial = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP', \n        options={'ftol': 1e-12, 'maxiter': 500}\n    )\n    \n    # Step 2: Basin-Hopping refinement as requested\n    # Parameters provided: stepsize=1e-6, local minimizer=SLSQP, ftol=1e-15\n    # The small stepsize ensures we stay in the immediate vicinity of the local peak.\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"options\": {\"ftol\": 1e-15, \"maxiter\": 200}\n    }\n    \n    # Run Basin-Hopping refinement\n    # niter is set to 15 to ensure the code completes within the 60-second limit.\n    res = basinhopping(\n        objective,\n        res_initial.x,\n        niter=15,\n        stepsize=1e-6,\n        minimizer_kwargs=minimizer_kwargs,\n        seed=42  # For reproducibility\n    )\n    \n    # Return the optimized coordinates reshaped to (14, 3)\n    final_points = res.x.reshape((N, dim))\n    return final_points\n\nif __name__ == \"__main__\":\n    points = min_max_dist_dim3_14()\n    print(\"Coordinates of the 14 points:\")\n    print(points)",
  "metrics": {
    "valid": true,
    "score": 0.3731628239406513,
    "min_max_ratio": 0.08957663977627817,
    "min_distance": 9.075423000966056,
    "max_distance": 30.3228133673311,
    "eval_time": 2.398981809616089,
    "error": null
  },
  "prompt": "Use Basin-Hopping to refine the solution in trial_8_0.\nSet stepsize to 1e-6 and use SLSQP as the local minimizer with ftol=1e-15.\nThe goal is to shake the configuration slightly to see if a slightly better local minimum exists in the immediate vicinity of the 1.000016 peak.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses Basin-Hopping with SLSQP as the local minimizer to refine the configuration.\n    \"\"\"\n    N = 14\n    dim = 3\n\n    def get_score_sq(coords):\n        \"\"\"Calculates (min_dist / max_dist)^2.\"\"\"\n        pts = coords.reshape((N, dim))\n        # Compute all pairwise squared Euclidean distances\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        # We only care about off-diagonal elements\n        mask = ~np.eye(N, dtype=bool)\n        d_min_sq = np.min(dists_sq[mask])\n        d_max_sq = np.max(dists_sq[mask])\n        if d_max_sq == 0:\n            return 0.0\n        return d_min_sq / d_max_sq\n\n    def objective(coords):\n        \"\"\"Minimize the negative squared ratio for maximization.\"\"\"\n        return -get_score_sq(coords)\n\n    # Initial high-quality candidate: Capped hexagonal antiprism (2-6-6 structure)\n    # This configuration is often near-optimal for N=14 in packing problems.\n    def generate_seed():\n        h1, h2, r = 0.35, 1.0, 1.0\n        pts = [[0, 0, h2], [0, 0, -h2]]\n        for i in range(6):\n            theta = 2 * np.pi * i / 6\n            # Ring 1\n            pts.append([r * np.cos(theta), r * np.sin(theta), h1])\n            # Ring 2 (offset by 30 degrees)\n            pts.append([r * np.cos(theta + np.pi/6), r * np.sin(theta + np.pi/6), -h1])\n        return np.array(pts).flatten()\n\n    initial_guess = generate_seed()\n\n    # Step 1: Initial local optimization to find a good starting point for Basin-Hopping\n    # Using SLSQP to stabilize the configuration based on the initial geometric guess.\n    res_initial = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP', \n        options={'ftol': 1e-12, 'maxiter': 500}\n    )\n    \n    # Step 2: Basin-Hopping refinement as requested\n    # Parameters provided: stepsize=1e-6, local minimizer=SLSQP, ftol=1e-15\n    # The small stepsize ensures we stay in the immediate vicinity of the local peak.\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"options\": {\"ftol\": 1e-15, \"maxiter\": 200}\n    }\n    \n    # Run Basin-Hopping refinement\n    # niter is set to 15 to ensure the code completes within the 60-second limit.\n    res = basinhopping(\n        objective,\n        res_initial.x,\n        niter=15,\n        stepsize=1e-6,\n        minimizer_kwargs=minimizer_kwargs,\n        seed=42  # For reproducibility\n    )\n    \n    # Return the optimized coordinates reshaped to (14, 3)\n    final_points = res.x.reshape((N, dim))\n    return final_points\n\nif __name__ == \"__main__\":\n    points = min_max_dist_dim3_14()\n    print(\"Coordinates of the 14 points:\")\n    print(points)\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:02:47.900945",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 252,
        "candidates_token_count": 929,
        "thoughts_token_count": 12056
      },
      "response_text_len": 2875
    }
  }
}