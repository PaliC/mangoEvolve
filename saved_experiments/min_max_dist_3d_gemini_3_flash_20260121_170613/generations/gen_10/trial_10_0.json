{
  "trial_id": "trial_10_0",
  "generation": 10,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Returns 14 points in 3D that maximize the squared ratio (min_dist / max_dist)^2.\n    The configuration is constrained to a Bicapped Hexagonal Antiprism (D6d symmetry).\n    Optimizes parameters H and Z with fixed R=1.\n    \"\"\"\n    \n    # Function to generate coordinates based on parameters H and Z\n    # R is fixed to 1.0 to resolve scale invariance.\n    def get_coords(params):\n        h, z = params\n        r = 1.0\n        \n        coords = []\n        # Two caps at (0, 0, +/- H)\n        coords.append([0.0, 0.0, h])\n        coords.append([0.0, 0.0, -h])\n        \n        # Upper ring at Z (angles 0, 60, 120...)\n        for i in range(6):\n            theta = i * np.pi / 3.0\n            coords.append([r * np.cos(theta), r * np.sin(theta), z])\n            \n        # Lower ring at -Z (angles 30, 90, 150...) - Twisted by 30 deg (pi/6)\n        for i in range(6):\n            theta = i * np.pi / 3.0 + np.pi / 6.0\n            coords.append([r * np.cos(theta), r * np.sin(theta), -z])\n            \n        return np.array(coords)\n\n    # Objective function: minimize negative ratio\n    def objective(params):\n        h, z = params\n        \n        # Geometric constraints: H and Z must be positive\n        if h < 1e-4 or z < 0:\n            return 0.0\n            \n        points = get_coords(params)\n        dists = pdist(points)\n        \n        if dists.size == 0:\n            return 0.0\n            \n        d_min = np.min(dists)\n        d_max = np.max(dists)\n        \n        if d_max < 1e-12:\n            return 0.0\n            \n        # Maximize d_min/d_max => Minimize -(d_min/d_max)\n        return -(d_min / d_max)\n\n    # 1. Grid Search to find the best starting geometry\n    # Scans plausible ranges for H and Z to avoid local optima\n    best_x0 = [1.0, 0.5]\n    best_val = 0.0\n    \n    h_grid = np.linspace(0.5, 2.5, 15)\n    z_grid = np.linspace(0.1, 1.2, 15)\n    \n    for h in h_grid:\n        for z in z_grid:\n            val = objective([h, z])\n            if val < best_val: # val is negative\n                best_val = val\n                best_x0 = [h, z]\n\n    # 2. Fine-tuning Optimization\n    # Nelder-Mead is robust for non-smooth functions (min/max)\n    res = minimize(\n        objective, \n        best_x0, \n        method='Nelder-Mead', \n        options={'xatol': 1e-16, 'fatol': 1e-16, 'maxiter': 5000}\n    )\n    \n    # 3. Generate and return final coordinates\n    h_opt, z_opt = res.x\n    final_points = get_coords([h_opt, z_opt])\n    \n    return final_points",
  "metrics": {
    "valid": true,
    "score": 0.9331888308441753,
    "min_max_ratio": 0.22400923773979564,
    "min_distance": 0.9999999999999996,
    "max_distance": 2.112842070562245,
    "eval_time": 0.29805898666381836,
    "error": null
  },
  "prompt": "The best known configuration for 14 points in 3D is likely a Bicapped Hexagonal Antiprism (D6d symmetry).\nImplement an optimizer that explicitly enforces D6d symmetry:\n- Points: (0, 0, +/-H), (R*cos(phi_i), R*sin(phi_i), Z), (R*cos(phi_i + pi/6), R*sin(phi_i + pi/6), -Z)\n- Use scipy.optimize.minimize to find H, R, Z that maximize the min-dist/max-dist ratio.\n- Start from the geometry of trial_8_0.\n- Use extremely tight tolerances (ftol=1e-16).",
  "response": "Here is the implementation of the optimizer for the Bicapped Hexagonal Antiprism configuration.\n\nThe solution fixes the radial scale $R=1$ to handle scale invariance and optimizes the height parameters $H$ (cap height) and $Z$ (ring height) using `scipy.optimize.minimize` with the Nelder-Mead method and tight tolerances. A preliminary grid search is performed to ensure the optimizer starts from a valid basin of attraction.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Returns 14 points in 3D that maximize the squared ratio (min_dist / max_dist)^2.\n    The configuration is constrained to a Bicapped Hexagonal Antiprism (D6d symmetry).\n    Optimizes parameters H and Z with fixed R=1.\n    \"\"\"\n    \n    # Function to generate coordinates based on parameters H and Z\n    # R is fixed to 1.0 to resolve scale invariance.\n    def get_coords(params):\n        h, z = params\n        r = 1.0\n        \n        coords = []\n        # Two caps at (0, 0, +/- H)\n        coords.append([0.0, 0.0, h])\n        coords.append([0.0, 0.0, -h])\n        \n        # Upper ring at Z (angles 0, 60, 120...)\n        for i in range(6):\n            theta = i * np.pi / 3.0\n            coords.append([r * np.cos(theta), r * np.sin(theta), z])\n            \n        # Lower ring at -Z (angles 30, 90, 150...) - Twisted by 30 deg (pi/6)\n        for i in range(6):\n            theta = i * np.pi / 3.0 + np.pi / 6.0\n            coords.append([r * np.cos(theta), r * np.sin(theta), -z])\n            \n        return np.array(coords)\n\n    # Objective function: minimize negative ratio\n    def objective(params):\n        h, z = params\n        \n        # Geometric constraints: H and Z must be positive\n        if h < 1e-4 or z < 0:\n            return 0.0\n            \n        points = get_coords(params)\n        dists = pdist(points)\n        \n        if dists.size == 0:\n            return 0.0\n            \n        d_min = np.min(dists)\n        d_max = np.max(dists)\n        \n        if d_max < 1e-12:\n            return 0.0\n            \n        # Maximize d_min/d_max => Minimize -(d_min/d_max)\n        return -(d_min / d_max)\n\n    # 1. Grid Search to find the best starting geometry\n    # Scans plausible ranges for H and Z to avoid local optima\n    best_x0 = [1.0, 0.5]\n    best_val = 0.0\n    \n    h_grid = np.linspace(0.5, 2.5, 15)\n    z_grid = np.linspace(0.1, 1.2, 15)\n    \n    for h in h_grid:\n        for z in z_grid:\n            val = objective([h, z])\n            if val < best_val: # val is negative\n                best_val = val\n                best_x0 = [h, z]\n\n    # 2. Fine-tuning Optimization\n    # Nelder-Mead is robust for non-smooth functions (min/max)\n    res = minimize(\n        objective, \n        best_x0, \n        method='Nelder-Mead', \n        options={'xatol': 1e-16, 'fatol': 1e-16, 'maxiter': 5000}\n    )\n    \n    # 3. Generate and return final coordinates\n    h_opt, z_opt = res.x\n    final_points = get_coords([h_opt, z_opt])\n    \n    return final_points\n```",
  "reasoning": "Here is the implementation of the optimizer for the Bicapped Hexagonal Antiprism configuration.\n\nThe solution fixes the radial scale $R=1$ to handle scale invariance and optimizes the height parameters $H$ (cap height) and $Z$ (ring height) using `scipy.optimize.minimize` with the Nelder-Mead method and tight tolerances. A preliminary grid search is performed to ensure the optimizer starts from a valid basin of attraction.",
  "timestamp": "2026-01-21T18:03:27.901765",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 329,
        "candidates_token_count": 992,
        "thoughts_token_count": 12051
      },
      "response_text_len": 3058
    }
  }
}