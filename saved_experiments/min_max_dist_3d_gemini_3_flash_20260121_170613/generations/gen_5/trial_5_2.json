{
  "trial_id": "trial_5_2",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D that maximizes the ratio (min distance / max distance)^2.\n    The approach uses multiple symmetric and random initializations followed by \n    L-BFGS-B optimization with a smooth approximation of the min-max ratio.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    def get_dists_sq(pts):\n        # Efficiently compute all-pairs squared distances\n        dist_matrix_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        # Return only the upper triangle to avoid duplicates and self-distances\n        return dist_matrix_sq[np.triu_indices(N, k=1)]\n\n    def objective_with_grad(x, p, N, dim):\n        # Soft-max/soft-min objective using log-sum-exp trick for stability\n        pts = x.reshape((N, dim))\n        iu = np.triu_indices(N, k=1)\n        \n        # Compute differences and squared distances\n        diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dists_sq_mat = np.sum(diffs**2, axis=-1)\n        D = dists_sq_mat[iu]\n        \n        max_D = np.max(D)\n        min_D = np.min(D)\n        \n        # Soft-max using log-sum-exp\n        exp_pD = np.exp(p * (D - max_D))\n        sum_exp_pD = np.sum(exp_pD)\n        soft_max = max_D + np.log(sum_exp_pD) / p\n        w_max = exp_pD / sum_exp_pD\n        \n        # Soft-min using log-sum-exp\n        exp_neg_pD = np.exp(-p * (D - min_D))\n        sum_exp_neg_pD = np.sum(exp_neg_pD)\n        soft_min = min_D - np.log(sum_exp_neg_pD) / p\n        w_min = exp_neg_pD / sum_exp_neg_pD\n        \n        obj = soft_max / soft_min\n        \n        # Gradient of the objective with respect to the squared distances D_ij\n        # d(obj)/dD_ij = (soft_min * d(soft_max)/dD_ij - soft_max * d(soft_min)/dD_ij) / soft_min^2\n        dobj_dD = (soft_min * w_max - soft_max * w_min) / (soft_min**2)\n        \n        # Gradient with respect to the point coordinates\n        grad = np.zeros((N, dim))\n        for idx, (i, j) in enumerate(zip(iu[0], iu[1])):\n            # Gradient of D_ij = ||x_i - x_j||^2 with respect to x_i is 2*(x_i - x_j)\n            grad_D_ij = 2 * (pts[i] - pts[j])\n            grad[i] += dobj_dD[idx] * grad_D_ij\n            grad[j] -= dobj_dD[idx] * grad_D_ij\n            \n        return obj, grad.flatten()\n\n    best_pts = None\n    best_ratio = -1\n    \n    inits = []\n    # Initialization 1: Bicapped hexagonal antiprism (1+6+6+1)\n    for h in [0.4, 0.7]:\n        pts_hex = [[0, 0, 1.2], [0, 0, -1.2]]\n        for i in range(6):\n            theta = 2 * np.pi * i / 6\n            pts_hex.append([np.cos(theta), np.sin(theta), h])\n            pts_hex.append([np.cos(theta + np.pi/6), np.sin(theta + np.pi/6), -h])\n        inits.append(np.array(pts_hex))\n    \n    # Initialization 2: Rhombic dodecahedron vertices (8 cube vertices + 6 face-extension points)\n    pts_rd = []\n    for i in [-1, 1]:\n        for j in [-1, 1]:\n            for k in [-1, 1]:\n                pts_rd.append([i, j, k])\n    pts_rd.extend([[1.6,0,0], [-1.6,0,0], [0,1.6,0], [0,-1.6,0], [0,0,1.6], [0,0,-1.6]])\n    inits.append(np.array(pts_rd))\n    \n    # Initialization 3: 1+3+3+3+3+1 layered configuration\n    pts_3333 = [[0, 0, 1.5], [0, 0, -1.5]]\n    for i, h in enumerate([0.9, 0.3, -0.3, -0.9]):\n        for k in range(3):\n            theta = 2 * np.pi * k / 3 + (i % 2) * np.pi / 6\n            pts_3333.append([np.cos(theta), np.sin(theta), h])\n    inits.append(np.array(pts_3333))\n    \n    # Initialization 4: Random points on a sphere\n    for _ in range(5):\n        pts_rand = np.random.normal(0, 1, (N, dim))\n        pts_rand /= np.linalg.norm(pts_rand, axis=1)[:, np.newaxis]\n        inits.append(pts_rand)\n\n    # Optimization loop over different starting points\n    for pts_init in inits:\n        # Stage 1: Fast convergence with lower precision\n        res = minimize(objective_with_grad, pts_init.flatten(), args=(20, N, dim), \n                       method='L-BFGS-B', jac=True, options={'maxiter': 200})\n        # Stage 2: Refinement with higher penalty for min/max deviation\n        res = minimize(objective_with_grad, res.x, args=(100, N, dim), \n                       method='L-BFGS-B', jac=True, options={'maxiter': 400})\n        \n        pts_opt = res.x.reshape((N, dim))\n        dsq = get_dists_sq(pts_opt)\n        ratio = np.min(dsq) / np.max(dsq)\n        \n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_opt\n            \n    # Final normalization to ensure the maximum pairwise distance is exactly 1.0\n    dsq = get_dists_sq(best_pts)\n    best_pts /= np.sqrt(np.max(dsq))\n    \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9419566537148402,
    "min_max_ratio": 0.22611392786571416,
    "min_distance": 0.47551438239627847,
    "max_distance": 1.0,
    "eval_time": 1.451258897781372,
    "error": null
  },
  "prompt": "For 14 points in 3D, the optimal max-min configuration often has high symmetry (like a bicapped hexagonal antiprism). Try to initialize the points using a hexagonal antiprism with two caps, then use SLSQP with analytical gradients to refine. Also try variations where the points are slightly moved off the sphere.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D that maximizes the ratio (min distance / max distance)^2.\n    The approach uses multiple symmetric and random initializations followed by \n    L-BFGS-B optimization with a smooth approximation of the min-max ratio.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    def get_dists_sq(pts):\n        # Efficiently compute all-pairs squared distances\n        dist_matrix_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        # Return only the upper triangle to avoid duplicates and self-distances\n        return dist_matrix_sq[np.triu_indices(N, k=1)]\n\n    def objective_with_grad(x, p, N, dim):\n        # Soft-max/soft-min objective using log-sum-exp trick for stability\n        pts = x.reshape((N, dim))\n        iu = np.triu_indices(N, k=1)\n        \n        # Compute differences and squared distances\n        diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dists_sq_mat = np.sum(diffs**2, axis=-1)\n        D = dists_sq_mat[iu]\n        \n        max_D = np.max(D)\n        min_D = np.min(D)\n        \n        # Soft-max using log-sum-exp\n        exp_pD = np.exp(p * (D - max_D))\n        sum_exp_pD = np.sum(exp_pD)\n        soft_max = max_D + np.log(sum_exp_pD) / p\n        w_max = exp_pD / sum_exp_pD\n        \n        # Soft-min using log-sum-exp\n        exp_neg_pD = np.exp(-p * (D - min_D))\n        sum_exp_neg_pD = np.sum(exp_neg_pD)\n        soft_min = min_D - np.log(sum_exp_neg_pD) / p\n        w_min = exp_neg_pD / sum_exp_neg_pD\n        \n        obj = soft_max / soft_min\n        \n        # Gradient of the objective with respect to the squared distances D_ij\n        # d(obj)/dD_ij = (soft_min * d(soft_max)/dD_ij - soft_max * d(soft_min)/dD_ij) / soft_min^2\n        dobj_dD = (soft_min * w_max - soft_max * w_min) / (soft_min**2)\n        \n        # Gradient with respect to the point coordinates\n        grad = np.zeros((N, dim))\n        for idx, (i, j) in enumerate(zip(iu[0], iu[1])):\n            # Gradient of D_ij = ||x_i - x_j||^2 with respect to x_i is 2*(x_i - x_j)\n            grad_D_ij = 2 * (pts[i] - pts[j])\n            grad[i] += dobj_dD[idx] * grad_D_ij\n            grad[j] -= dobj_dD[idx] * grad_D_ij\n            \n        return obj, grad.flatten()\n\n    best_pts = None\n    best_ratio = -1\n    \n    inits = []\n    # Initialization 1: Bicapped hexagonal antiprism (1+6+6+1)\n    for h in [0.4, 0.7]:\n        pts_hex = [[0, 0, 1.2], [0, 0, -1.2]]\n        for i in range(6):\n            theta = 2 * np.pi * i / 6\n            pts_hex.append([np.cos(theta), np.sin(theta), h])\n            pts_hex.append([np.cos(theta + np.pi/6), np.sin(theta + np.pi/6), -h])\n        inits.append(np.array(pts_hex))\n    \n    # Initialization 2: Rhombic dodecahedron vertices (8 cube vertices + 6 face-extension points)\n    pts_rd = []\n    for i in [-1, 1]:\n        for j in [-1, 1]:\n            for k in [-1, 1]:\n                pts_rd.append([i, j, k])\n    pts_rd.extend([[1.6,0,0], [-1.6,0,0], [0,1.6,0], [0,-1.6,0], [0,0,1.6], [0,0,-1.6]])\n    inits.append(np.array(pts_rd))\n    \n    # Initialization 3: 1+3+3+3+3+1 layered configuration\n    pts_3333 = [[0, 0, 1.5], [0, 0, -1.5]]\n    for i, h in enumerate([0.9, 0.3, -0.3, -0.9]):\n        for k in range(3):\n            theta = 2 * np.pi * k / 3 + (i % 2) * np.pi / 6\n            pts_3333.append([np.cos(theta), np.sin(theta), h])\n    inits.append(np.array(pts_3333))\n    \n    # Initialization 4: Random points on a sphere\n    for _ in range(5):\n        pts_rand = np.random.normal(0, 1, (N, dim))\n        pts_rand /= np.linalg.norm(pts_rand, axis=1)[:, np.newaxis]\n        inits.append(pts_rand)\n\n    # Optimization loop over different starting points\n    for pts_init in inits:\n        # Stage 1: Fast convergence with lower precision\n        res = minimize(objective_with_grad, pts_init.flatten(), args=(20, N, dim), \n                       method='L-BFGS-B', jac=True, options={'maxiter': 200})\n        # Stage 2: Refinement with higher penalty for min/max deviation\n        res = minimize(objective_with_grad, res.x, args=(100, N, dim), \n                       method='L-BFGS-B', jac=True, options={'maxiter': 400})\n        \n        pts_opt = res.x.reshape((N, dim))\n        dsq = get_dists_sq(pts_opt)\n        ratio = np.min(dsq) / np.max(dsq)\n        \n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_opt\n            \n    # Final normalization to ensure the maximum pairwise distance is exactly 1.0\n    dsq = get_dists_sq(best_pts)\n    best_pts /= np.sqrt(np.max(dsq))\n    \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:38:27.775491",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 240,
        "candidates_token_count": 1717,
        "thoughts_token_count": 22777
      },
      "response_text_len": 4671
    }
  }
}