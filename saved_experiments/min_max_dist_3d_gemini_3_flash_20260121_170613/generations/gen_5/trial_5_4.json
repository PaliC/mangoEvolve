{
  "trial_id": "trial_5_4",
  "generation": 5,
  "parent_id": "trial_3_6",
  "code": "import numpy as np\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio of the minimum pairwise distance \n    to the maximum pairwise distance.\n    \n    The algorithm uses gradient ascent on a smooth approximation of the minimum distance,\n    while constraining the diameter of the point set to 1.0 by rescaling at each step.\n    It starts with multiple initializations, including a Fibonacci sphere and random configurations,\n    and uses an annealing-like schedule for the repulsive force power to refine the solution.\n    \"\"\"\n    N = 14\n    \n    def get_ratio_sq(p):\n        \"\"\"Calculates the squared ratio (d_min / d_max)^2 for a set of points.\"\"\"\n        diff = p[:, None, :] - p[None, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        d_max_sq = np.max(dists_sq)\n        if d_max_sq == 0:\n            return 0.0\n        # Set diagonal to a large value to find the minimum distance between distinct points\n        dists_sq_diag = dists_sq + np.eye(N) * (d_max_sq + 1.0)\n        d_min_sq = np.min(dists_sq_diag)\n        return d_min_sq / d_max_sq\n\n    best_pts = None\n    best_ratio_sq = -1.0\n    \n    # Run optimization from multiple initial configurations (seeds)\n    for seed in range(12):\n        np.random.seed(seed)\n        if seed == 0:\n            # Seed with Fibonacci sphere for a uniformly distributed initial state\n            phi = np.pi * (3.0 - np.sqrt(5.0))\n            pts = []\n            for i in range(N):\n                y = 1.0 - (i / float(N - 1)) * 2.0\n                radius = np.sqrt(max(0.0, 1.0 - y * y))\n                theta = phi * i\n                pts.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n            pts = np.array(pts, dtype=np.float64)\n        else:\n            # Seed with random points on a unit sphere\n            pts = np.random.normal(0.0, 1.0, (N, 3)).astype(np.float64)\n            norms = np.linalg.norm(pts, axis=1, keepdims=True)\n            pts /= np.where(norms > 0, norms, 1.0)\n            \n        # Initial normalization to ensure diameter is exactly 1.0\n        diff = pts[:, None, :] - pts[None, :, :]\n        d_max = np.sqrt(np.max(np.sum(diff**2, axis=-1)))\n        if d_max > 0:\n            pts /= d_max\n\n        # Optimization schedule using increasing powers k for the repulsive force\n        # This helps in global exploration first and local refinement later\n        for k in [4, 10, 20, 40]:\n            lr = 0.02\n            # Apply a small jitter when transitioning to a higher power k\n            if k > 4:\n                pts += np.random.normal(0.0, 1e-4, (N, 3))\n            \n            for i in range(1500):\n                # Calculate all pairwise vectors and squared distances\n                diff = pts[:, None, :] - pts[None, :, :]\n                dists_sq = np.sum(diff**2, axis=-1)\n                \n                # Use a small diagonal offset to prevent division by zero\n                dists_diag = dists_sq + np.eye(N)\n                \n                # Repulsive force magnitude: F ~ 1 / d^(k+1)\n                # This force pushes points away from their nearest neighbors\n                force_mag = 1.0 / (dists_diag**((k + 1) / 2.0))\n                np.fill_diagonal(force_mag, 0.0)\n                forces = (diff * force_mag[:, :, None]).sum(axis=1)\n                \n                # Normalize the update step based on the maximum force vector\n                f_norm = np.linalg.norm(forces, axis=1, keepdims=True)\n                max_f = np.max(f_norm)\n                if max_f > 0:\n                    pts += lr * (forces / max_f)\n                \n                # Rescale the point set to satisfy the diameter constraint d_max <= 1.0\n                diff = pts[:, None, :] - pts[None, :, :]\n                d_max = np.sqrt(np.max(np.sum(diff**2, axis=-1)))\n                if d_max > 0:\n                    pts /= d_max\n                \n                # Gradually decay the learning rate for convergence\n                lr *= 0.9985\n        \n        # Evaluate the resulting configuration and update the global best\n        current_ratio_sq = get_ratio_sq(pts)\n        if current_ratio_sq > best_ratio_sq:\n            best_ratio_sq = current_ratio_sq\n            best_pts = pts.copy()\n            \n    return best_pts.reshape(14, 3)",
  "metrics": {
    "valid": true,
    "score": 0.916458221265153,
    "min_max_ratio": 0.21999310405404568,
    "min_distance": 0.4690342248216495,
    "max_distance": 1.0,
    "eval_time": 1.7969870567321777,
    "error": null
  },
  "prompt": "Implement a 'Min-Max' optimizer from scratch using a simple gradient ascent on the minimum distance while projecting onto the constraint d_max <= 1. Use a very small learning rate and high precision. Seed it with the Fibonacci sphere and the best known positions.",
  "response": "```python\nimport numpy as np\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio of the minimum pairwise distance \n    to the maximum pairwise distance.\n    \n    The algorithm uses gradient ascent on a smooth approximation of the minimum distance,\n    while constraining the diameter of the point set to 1.0 by rescaling at each step.\n    It starts with multiple initializations, including a Fibonacci sphere and random configurations,\n    and uses an annealing-like schedule for the repulsive force power to refine the solution.\n    \"\"\"\n    N = 14\n    \n    def get_ratio_sq(p):\n        \"\"\"Calculates the squared ratio (d_min / d_max)^2 for a set of points.\"\"\"\n        diff = p[:, None, :] - p[None, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        d_max_sq = np.max(dists_sq)\n        if d_max_sq == 0:\n            return 0.0\n        # Set diagonal to a large value to find the minimum distance between distinct points\n        dists_sq_diag = dists_sq + np.eye(N) * (d_max_sq + 1.0)\n        d_min_sq = np.min(dists_sq_diag)\n        return d_min_sq / d_max_sq\n\n    best_pts = None\n    best_ratio_sq = -1.0\n    \n    # Run optimization from multiple initial configurations (seeds)\n    for seed in range(12):\n        np.random.seed(seed)\n        if seed == 0:\n            # Seed with Fibonacci sphere for a uniformly distributed initial state\n            phi = np.pi * (3.0 - np.sqrt(5.0))\n            pts = []\n            for i in range(N):\n                y = 1.0 - (i / float(N - 1)) * 2.0\n                radius = np.sqrt(max(0.0, 1.0 - y * y))\n                theta = phi * i\n                pts.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n            pts = np.array(pts, dtype=np.float64)\n        else:\n            # Seed with random points on a unit sphere\n            pts = np.random.normal(0.0, 1.0, (N, 3)).astype(np.float64)\n            norms = np.linalg.norm(pts, axis=1, keepdims=True)\n            pts /= np.where(norms > 0, norms, 1.0)\n            \n        # Initial normalization to ensure diameter is exactly 1.0\n        diff = pts[:, None, :] - pts[None, :, :]\n        d_max = np.sqrt(np.max(np.sum(diff**2, axis=-1)))\n        if d_max > 0:\n            pts /= d_max\n\n        # Optimization schedule using increasing powers k for the repulsive force\n        # This helps in global exploration first and local refinement later\n        for k in [4, 10, 20, 40]:\n            lr = 0.02\n            # Apply a small jitter when transitioning to a higher power k\n            if k > 4:\n                pts += np.random.normal(0.0, 1e-4, (N, 3))\n            \n            for i in range(1500):\n                # Calculate all pairwise vectors and squared distances\n                diff = pts[:, None, :] - pts[None, :, :]\n                dists_sq = np.sum(diff**2, axis=-1)\n                \n                # Use a small diagonal offset to prevent division by zero\n                dists_diag = dists_sq + np.eye(N)\n                \n                # Repulsive force magnitude: F ~ 1 / d^(k+1)\n                # This force pushes points away from their nearest neighbors\n                force_mag = 1.0 / (dists_diag**((k + 1) / 2.0))\n                np.fill_diagonal(force_mag, 0.0)\n                forces = (diff * force_mag[:, :, None]).sum(axis=1)\n                \n                # Normalize the update step based on the maximum force vector\n                f_norm = np.linalg.norm(forces, axis=1, keepdims=True)\n                max_f = np.max(f_norm)\n                if max_f > 0:\n                    pts += lr * (forces / max_f)\n                \n                # Rescale the point set to satisfy the diameter constraint d_max <= 1.0\n                diff = pts[:, None, :] - pts[None, :, :]\n                d_max = np.sqrt(np.max(np.sum(diff**2, axis=-1)))\n                if d_max > 0:\n                    pts /= d_max\n                \n                # Gradually decay the learning rate for convergence\n                lr *= 0.9985\n        \n        # Evaluate the resulting configuration and update the global best\n        current_ratio_sq = get_ratio_sq(pts)\n        if current_ratio_sq > best_ratio_sq:\n            best_ratio_sq = current_ratio_sq\n            best_pts = pts.copy()\n            \n    return best_pts.reshape(14, 3)\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:38:10.697143",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 225,
        "candidates_token_count": 1260,
        "thoughts_token_count": 19558
      },
      "response_text_len": 4311
    }
  }
}