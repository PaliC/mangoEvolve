{
  "trial_id": "trial_5_0",
  "generation": 5,
  "parent_id": "trial_3_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space that maximize the squared ratio (min_dist / max_dist)^2.\n    Uses SLSQP with analytical Jacobian and multiple restarts, including perturbations\n    around the best found solutions.\n    \"\"\"\n    N = 14\n    n_pairs = N * (N - 1) // 2\n    \n    # Precompute pair indices\n    idx_i = []\n    idx_j = []\n    k = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n    \n    # Objective: Minimize S (which represents d_max^2 given d_min >= 1)\n    # Variables: x (N*3 coords) + S (1 slack) = 3*N + 1\n    \n    def objective(x):\n        return x[-1]\n\n    def obj_grad(x):\n        grad = np.zeros_like(x)\n        grad[-1] = 1.0\n        return grad\n\n    # Constraints\n    # 1. dist_sq(i, j) >= 1  -> dist_sq - 1 >= 0\n    # 2. dist_sq(i, j) <= S  -> S - dist_sq >= 0\n    # 3. Center of mass at origin (optional but helps stability) -> sum(coords) = 0\n    \n    # We formulate constraints for SLSQP\n    # The constraints function returns a vector where each element must be >= 0 (ineq) or == 0 (eq)\n    \n    def constraints(x):\n        pts = x[:-1].reshape((N, 3))\n        S = x[-1]\n        \n        diff = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        \n        # Ineq constraints:\n        # First n_pairs: d2 - 1 >= 0\n        # Next n_pairs: S - d2 >= 0\n        c_min = d2 - 1.0\n        c_max = S - d2\n        \n        return np.concatenate([c_min, c_max])\n\n    def constraints_jac(x):\n        pts = x[:-1].reshape((N, 3))\n        # S = x[-1]\n        \n        diff = pts[idx_i] - pts[idx_j] # Shape (n_pairs, 3)\n        \n        # We need to build a sparse-like jacobian matrix (2*n_pairs, 3*N + 1)\n        # But for SLSQP in scipy, dense return is fine for this size (182x43)\n        \n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        # Derivatives for d2 - 1 >= 0\n        # d(d2)/dx_i = 2*(xi - xj)\n        # d(d2)/dx_j = -2*(xi - xj)\n        \n        # We can fill this efficiently\n        # Rows 0 to n_pairs-1\n        row_indices = np.arange(n_pairs)\n        \n        # Factors\n        f_i = 2 * diff # Shape (n_pairs, 3)\n        f_j = -2 * diff\n        \n        # Fill jacobian\n        # This is the slow part if looped. Vectorize assignment.\n        # x indices:\n        # point i corresponds to cols 3*i, 3*i+1, 3*i+2\n        \n        # Flattening the assignments\n        for k in range(n_pairs):\n            i = idx_i[k]\n            j = idx_j[k]\n            \n            # Constraint 1: d2 >= 1\n            jac[k, 3*i:3*i+3] = f_i[k]\n            jac[k, 3*j:3*j+3] = f_j[k]\n            # S col is 0\n            \n            # Constraint 2: S >= d2  => S - d2 >= 0\n            # derivs are negative of above\n            jac[n_pairs + k, 3*i:3*i+3] = -f_i[k]\n            jac[n_pairs + k, 3*j:3*j+3] = -f_j[k]\n            jac[n_pairs + k, -1] = 1.0\n            \n        return jac\n    \n    # Center of mass constraint\n    def com_constraint(x):\n        pts = x[:-1].reshape((N, 3))\n        return np.sum(pts, axis=0) # Should be 0\n    \n    def com_jac(x):\n        jac = np.zeros((3, 3*N + 1))\n        for i in range(N):\n            jac[0, 3*i] = 1.0\n            jac[1, 3*i+1] = 1.0\n            jac[2, 3*i+2] = 1.0\n        return jac\n\n    # Define constraint dictionaries\n    cons = [\n        {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n        {'type': 'eq', 'fun': com_constraint, 'jac': com_jac}\n    ]\n\n    # Initial Candidates Generation\n    candidates = []\n    \n    # 1. Rhombic Dodecahedron vertices (projected to sphere)\n    # 6 points at (+-1, 0, 0) perms, 8 points at (+-0.5, +-0.5, +-0.5)\n    # Note: Rhombic dodecahedron vertices are (\u00b11, \u00b11, \u00b11) [cube] and (\u00b12, 0, 0) perms?\n    # Actually, the 14 vertices are 6 type A and 8 type B.\n    # Type A: (\u00b11, 0, 0), (0, \u00b11, 0), (0, 0, \u00b11)\n    # Type B: (\u00b10.5, \u00b10.5, \u00b10.5)\n    # Let's project them to unit sphere.\n    rd_pts = []\n    for i in [-1, 1]:\n        rd_pts.append([i, 0, 0])\n        rd_pts.append([0, i, 0])\n        rd_pts.append([0, 0, i])\n    for x in [-1, 1]:\n        for y in [-1, 1]:\n            for z in [-1, 1]:\n                rd_pts.append([x*0.577, y*0.577, z*0.577]) # normalized approx\n    rd_pts = np.array(rd_pts)\n    rd_pts = rd_pts / np.linalg.norm(rd_pts, axis=1)[:, None]\n    candidates.append(rd_pts)\n\n    # 2. Capped Hexagonal Antiprism approximation\n    # Poles\n    cha_pts = [[0,0,1], [0,0,-1]]\n    # Rings\n    h = 0.5\n    r = np.sqrt(1 - h**2)\n    for i in range(6):\n        theta = i * np.pi / 3\n        cha_pts.append([r*np.cos(theta), r*np.sin(theta), h])\n    for i in range(6):\n        theta = i * np.pi / 3 + np.pi/6\n        cha_pts.append([r*np.cos(theta), r*np.sin(theta), -h])\n    candidates.append(np.array(cha_pts))\n    \n    # 3. Random restarts\n    np.random.seed(42)\n    for _ in range(15):\n        pts = np.random.randn(N, 3)\n        pts = pts / np.linalg.norm(pts, axis=1)[:, None]\n        candidates.append(pts)\n\n    best_score = -1.0\n    best_x = None\n    \n    # Time management\n    start_time = time.time()\n    \n    # Helper to run optimization\n    def run_optimization(init_pts, tol=1e-15, maxiter=200):\n        # Scale initial points to satisfy min_dist approx 1\n        # Calculate current min dist\n        diff = init_pts[idx_i] - init_pts[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        min_d = np.sqrt(np.min(d2))\n        if min_d < 1e-6:\n            min_d = 1e-6\n        \n        # Scale so min_dist is slightly > 1 to be feasible\n        pts_scaled = init_pts / min_d * 1.01\n        \n        # Calculate initial S\n        diff = pts_scaled[idx_i] - pts_scaled[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        S_init = np.max(d2) * 1.01\n        \n        x0 = np.concatenate([pts_scaled.flatten(), [S_init]])\n        \n        res = minimize(objective, x0, method='SLSQP', jac=obj_grad, \n                       constraints=cons, tol=tol, \n                       options={'maxiter': maxiter, 'disp': False})\n        return res\n\n    # Phase 1: Try candidates\n    for i, pts in enumerate(candidates):\n        if time.time() - start_time > 40: # Leave time for refinement\n            break\n            \n        res = run_optimization(pts, tol=1e-6, maxiter=100)\n        \n        if res.success or res.message == 'Iteration limit reached':\n            S_res = res.x[-1]\n            score = 1.0 / S_res\n            if score > best_score:\n                best_score = score\n                best_x = res.x\n\n    # Phase 2: Perturbation and Refinement\n    # Perturb the best solution found so far and re-optimize with high precision\n    if best_x is not None:\n        best_pts = best_x[:-1].reshape((N, 3))\n        \n        # Number of refinement steps\n        n_refine = 50\n        \n        for k in range(n_refine):\n            if time.time() - start_time > 58:\n                break\n                \n            # Perturb\n            perturbation = np.random.normal(0, 1e-3, (N, 3))\n            # Decay perturbation magnitude\n            if k > 20: perturbation *= 0.1\n            if k > 40: perturbation *= 0.01\n            \n            pts_perturbed = best_pts + perturbation\n            \n            # Run with high precision\n            res = run_optimization(pts_perturbed, tol=1e-15, maxiter=500)\n            \n            if res.success or res.status == 8: # 8 is positive directional derivative\n                S_res = res.x[-1]\n                score = 1.0 / S_res # Score is ratio squared (if min dist fixed at 1)\n                \n                # Check actual ratio to be safe\n                final_pts = res.x[:-1].reshape((N, 3))\n                diff = final_pts[idx_i] - final_pts[idx_j]\n                dists = np.sqrt(np.sum(diff**2, axis=1))\n                d_min = np.min(dists)\n                d_max = np.max(dists)\n                actual_ratio_sq = (d_min / d_max)**2\n                \n                if actual_ratio_sq > best_score:\n                    best_score = actual_ratio_sq\n                    best_x = res.x\n                    best_pts = final_pts\n\n    # Extract final points\n    if best_x is not None:\n        final_pts = best_x[:-1].reshape((N, 3))\n    else:\n        # Fallback\n        final_pts = candidates[0]\n        \n    return final_pts\n\n# To use:\n# points = min_max_dist_dim3_14()",
  "metrics": {
    "valid": true,
    "score": 0.9948200769610471,
    "min_max_ratio": 0.23880363733746884,
    "min_distance": 0.9999999999999994,
    "max_distance": 2.0463481880214687,
    "eval_time": 1.5326988697052002,
    "error": null
  },
  "prompt": "Improve upon the best solution trial_3_6 (score=1.0000159135539157). This solution uses a Fibonacci sphere initialization and SLSQP with a slack variable and analytical Jacobian. Try to run the optimization with even more random restarts (at least 50-100) using very small perturbations around the best known coordinates. Ensure the analytical Jacobian is perfectly implemented. Use a tolerance of 1e-15 for the optimizer.",
  "response": "An implementation of the algorithm to maximize the squared min-max distance ratio for 14 points in 3D space.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space that maximize the squared ratio (min_dist / max_dist)^2.\n    Uses SLSQP with analytical Jacobian and multiple restarts, including perturbations\n    around the best found solutions.\n    \"\"\"\n    N = 14\n    n_pairs = N * (N - 1) // 2\n    \n    # Precompute pair indices\n    idx_i = []\n    idx_j = []\n    k = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n    \n    # Objective: Minimize S (which represents d_max^2 given d_min >= 1)\n    # Variables: x (N*3 coords) + S (1 slack) = 3*N + 1\n    \n    def objective(x):\n        return x[-1]\n\n    def obj_grad(x):\n        grad = np.zeros_like(x)\n        grad[-1] = 1.0\n        return grad\n\n    # Constraints\n    # 1. dist_sq(i, j) >= 1  -> dist_sq - 1 >= 0\n    # 2. dist_sq(i, j) <= S  -> S - dist_sq >= 0\n    # 3. Center of mass at origin (optional but helps stability) -> sum(coords) = 0\n    \n    # We formulate constraints for SLSQP\n    # The constraints function returns a vector where each element must be >= 0 (ineq) or == 0 (eq)\n    \n    def constraints(x):\n        pts = x[:-1].reshape((N, 3))\n        S = x[-1]\n        \n        diff = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        \n        # Ineq constraints:\n        # First n_pairs: d2 - 1 >= 0\n        # Next n_pairs: S - d2 >= 0\n        c_min = d2 - 1.0\n        c_max = S - d2\n        \n        return np.concatenate([c_min, c_max])\n\n    def constraints_jac(x):\n        pts = x[:-1].reshape((N, 3))\n        # S = x[-1]\n        \n        diff = pts[idx_i] - pts[idx_j] # Shape (n_pairs, 3)\n        \n        # We need to build a sparse-like jacobian matrix (2*n_pairs, 3*N + 1)\n        # But for SLSQP in scipy, dense return is fine for this size (182x43)\n        \n        jac = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        # Derivatives for d2 - 1 >= 0\n        # d(d2)/dx_i = 2*(xi - xj)\n        # d(d2)/dx_j = -2*(xi - xj)\n        \n        # We can fill this efficiently\n        # Rows 0 to n_pairs-1\n        row_indices = np.arange(n_pairs)\n        \n        # Factors\n        f_i = 2 * diff # Shape (n_pairs, 3)\n        f_j = -2 * diff\n        \n        # Fill jacobian\n        # This is the slow part if looped. Vectorize assignment.\n        # x indices:\n        # point i corresponds to cols 3*i, 3*i+1, 3*i+2\n        \n        # Flattening the assignments\n        for k in range(n_pairs):\n            i = idx_i[k]\n            j = idx_j[k]\n            \n            # Constraint 1: d2 >= 1\n            jac[k, 3*i:3*i+3] = f_i[k]\n            jac[k, 3*j:3*j+3] = f_j[k]\n            # S col is 0\n            \n            # Constraint 2: S >= d2  => S - d2 >= 0\n            # derivs are negative of above\n            jac[n_pairs + k, 3*i:3*i+3] = -f_i[k]\n            jac[n_pairs + k, 3*j:3*j+3] = -f_j[k]\n            jac[n_pairs + k, -1] = 1.0\n            \n        return jac\n    \n    # Center of mass constraint\n    def com_constraint(x):\n        pts = x[:-1].reshape((N, 3))\n        return np.sum(pts, axis=0) # Should be 0\n    \n    def com_jac(x):\n        jac = np.zeros((3, 3*N + 1))\n        for i in range(N):\n            jac[0, 3*i] = 1.0\n            jac[1, 3*i+1] = 1.0\n            jac[2, 3*i+2] = 1.0\n        return jac\n\n    # Define constraint dictionaries\n    cons = [\n        {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n        {'type': 'eq', 'fun': com_constraint, 'jac': com_jac}\n    ]\n\n    # Initial Candidates Generation\n    candidates = []\n    \n    # 1. Rhombic Dodecahedron vertices (projected to sphere)\n    # 6 points at (+-1, 0, 0) perms, 8 points at (+-0.5, +-0.5, +-0.5)\n    # Note: Rhombic dodecahedron vertices are (\u00b11, \u00b11, \u00b11) [cube] and (\u00b12, 0, 0) perms?\n    # Actually, the 14 vertices are 6 type A and 8 type B.\n    # Type A: (\u00b11, 0, 0), (0, \u00b11, 0), (0, 0, \u00b11)\n    # Type B: (\u00b10.5, \u00b10.5, \u00b10.5)\n    # Let's project them to unit sphere.\n    rd_pts = []\n    for i in [-1, 1]:\n        rd_pts.append([i, 0, 0])\n        rd_pts.append([0, i, 0])\n        rd_pts.append([0, 0, i])\n    for x in [-1, 1]:\n        for y in [-1, 1]:\n            for z in [-1, 1]:\n                rd_pts.append([x*0.577, y*0.577, z*0.577]) # normalized approx\n    rd_pts = np.array(rd_pts)\n    rd_pts = rd_pts / np.linalg.norm(rd_pts, axis=1)[:, None]\n    candidates.append(rd_pts)\n\n    # 2. Capped Hexagonal Antiprism approximation\n    # Poles\n    cha_pts = [[0,0,1], [0,0,-1]]\n    # Rings\n    h = 0.5\n    r = np.sqrt(1 - h**2)\n    for i in range(6):\n        theta = i * np.pi / 3\n        cha_pts.append([r*np.cos(theta), r*np.sin(theta), h])\n    for i in range(6):\n        theta = i * np.pi / 3 + np.pi/6\n        cha_pts.append([r*np.cos(theta), r*np.sin(theta), -h])\n    candidates.append(np.array(cha_pts))\n    \n    # 3. Random restarts\n    np.random.seed(42)\n    for _ in range(15):\n        pts = np.random.randn(N, 3)\n        pts = pts / np.linalg.norm(pts, axis=1)[:, None]\n        candidates.append(pts)\n\n    best_score = -1.0\n    best_x = None\n    \n    # Time management\n    start_time = time.time()\n    \n    # Helper to run optimization\n    def run_optimization(init_pts, tol=1e-15, maxiter=200):\n        # Scale initial points to satisfy min_dist approx 1\n        # Calculate current min dist\n        diff = init_pts[idx_i] - init_pts[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        min_d = np.sqrt(np.min(d2))\n        if min_d < 1e-6:\n            min_d = 1e-6\n        \n        # Scale so min_dist is slightly > 1 to be feasible\n        pts_scaled = init_pts / min_d * 1.01\n        \n        # Calculate initial S\n        diff = pts_scaled[idx_i] - pts_scaled[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        S_init = np.max(d2) * 1.01\n        \n        x0 = np.concatenate([pts_scaled.flatten(), [S_init]])\n        \n        res = minimize(objective, x0, method='SLSQP', jac=obj_grad, \n                       constraints=cons, tol=tol, \n                       options={'maxiter': maxiter, 'disp': False})\n        return res\n\n    # Phase 1: Try candidates\n    for i, pts in enumerate(candidates):\n        if time.time() - start_time > 40: # Leave time for refinement\n            break\n            \n        res = run_optimization(pts, tol=1e-6, maxiter=100)\n        \n        if res.success or res.message == 'Iteration limit reached':\n            S_res = res.x[-1]\n            score = 1.0 / S_res\n            if score > best_score:\n                best_score = score\n                best_x = res.x\n\n    # Phase 2: Perturbation and Refinement\n    # Perturb the best solution found so far and re-optimize with high precision\n    if best_x is not None:\n        best_pts = best_x[:-1].reshape((N, 3))\n        \n        # Number of refinement steps\n        n_refine = 50\n        \n        for k in range(n_refine):\n            if time.time() - start_time > 58:\n                break\n                \n            # Perturb\n            perturbation = np.random.normal(0, 1e-3, (N, 3))\n            # Decay perturbation magnitude\n            if k > 20: perturbation *= 0.1\n            if k > 40: perturbation *= 0.01\n            \n            pts_perturbed = best_pts + perturbation\n            \n            # Run with high precision\n            res = run_optimization(pts_perturbed, tol=1e-15, maxiter=500)\n            \n            if res.success or res.status == 8: # 8 is positive directional derivative\n                S_res = res.x[-1]\n                score = 1.0 / S_res # Score is ratio squared (if min dist fixed at 1)\n                \n                # Check actual ratio to be safe\n                final_pts = res.x[:-1].reshape((N, 3))\n                diff = final_pts[idx_i] - final_pts[idx_j]\n                dists = np.sqrt(np.sum(diff**2, axis=1))\n                d_min = np.min(dists)\n                d_max = np.max(dists)\n                actual_ratio_sq = (d_min / d_max)**2\n                \n                if actual_ratio_sq > best_score:\n                    best_score = actual_ratio_sq\n                    best_x = res.x\n                    best_pts = final_pts\n\n    # Extract final points\n    if best_x is not None:\n        final_pts = best_x[:-1].reshape((N, 3))\n    else:\n        # Fallback\n        final_pts = candidates[0]\n        \n    return final_pts\n\n# To use:\n# points = min_max_dist_dim3_14()\n```",
  "reasoning": "An implementation of the algorithm to maximize the squared min-max distance ratio for 14 points in 3D space.",
  "timestamp": "2026-01-21T17:38:48.375900",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 275,
        "candidates_token_count": 3013,
        "thoughts_token_count": 6073
      },
      "response_text_len": 8551
    }
  }
}