{
  "trial_id": "trial_5_6",
  "generation": 5,
  "parent_id": "trial_3_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a set of 14 points in 3D space that maximizes the squared ratio \n    of the minimum pairwise distance to the maximum pairwise distance.\n    \n    Strategy:\n    - Formulate as a constrained optimization problem:\n      Maximize t\n      Subject to:\n        dist_sq(i, j) >= t\n        dist_sq(i, j) <= 1\n    - Use Sequential Least Squares Programming (SLSQP) to handle constraints.\n    - Provide analytical Jacobian for performance.\n    - Use multi-start with random spherical initializations to avoid local optima.\n    \"\"\"\n    \n    N = 14\n    dim = 3\n    \n    # Precompute pair indices to avoid repeated looping\n    pairs = np.array([(i, j) for i in range(N) for j in range(i + 1, N)])\n    num_pairs = len(pairs)\n    idx_i = pairs[:, 0]\n    idx_j = pairs[:, 1]\n    \n    # The state vector x_aug contains [x_0, y_0, z_0, ..., x_13, y_13, z_13, t]\n    # Total variables: 14*3 + 1 = 43\n    \n    def objective(x_aug):\n        # We want to maximize t, so minimize -t\n        return -x_aug[-1]\n\n    def jac_obj(x_aug):\n        # Gradient of objective wrt [coords..., t]\n        g = np.zeros_like(x_aug)\n        g[-1] = -1.0\n        return g\n\n    def constraints(x_aug):\n        pts = x_aug[:-1].reshape((N, dim))\n        t = x_aug[-1]\n        \n        # Vectorized distance calculation\n        p_i = pts[idx_i]\n        p_j = pts[idx_j]\n        diff = p_i - p_j\n        d2 = np.sum(diff**2, axis=1)\n        \n        # Constraints formulation (c >= 0)\n        # 1. d^2 >= t  =>  d^2 - t >= 0\n        # 2. d^2 <= 1  =>  1 - d^2 >= 0\n        return np.concatenate([d2 - t, 1.0 - d2])\n\n    def jac_constraints(x_aug):\n        pts = x_aug[:-1].reshape((N, dim))\n        \n        p_i = pts[idx_i]\n        p_j = pts[idx_j]\n        diff = p_i - p_j\n        two_diff = 2 * diff\n        \n        # Jacobian matrix shape: (2 * num_pairs, 3 * N + 1)\n        jac = np.zeros((2 * num_pairs, 3 * N + 1))\n        \n        # Fill gradients for constraint set 1: d^2 - t >= 0\n        # d(d^2)/dx_i = 2(x_i - x_j)\n        # d(d^2)/dx_j = -2(x_i - x_j)\n        # d(-t)/dt = -1\n        \n        # We iterate over pairs to fill the sparse structure efficiently enough for N=14\n        for k in range(num_pairs):\n            u, v = pairs[k]\n            # Gradient with respect to point u\n            jac[k, 3*u : 3*u+3] = two_diff[k]\n            # Gradient with respect to point v\n            jac[k, 3*v : 3*v+3] = -two_diff[k]\n        \n        # Derivative w.r.t t is -1 for the first set of constraints\n        jac[:num_pairs, -1] = -1.0\n        \n        # Fill gradients for constraint set 2: 1 - d^2 >= 0\n        # Derivatives are simply the negative of the spatial derivatives of set 1\n        # Derivative w.r.t t is 0\n        jac[num_pairs:, :-1] = -jac[:num_pairs, :-1]\n        \n        return jac\n\n    best_ratio = -1.0\n    best_pts = np.random.rand(N, dim)\n    \n    t_start = time.time()\n    \n    # Run optimization loop for ~55 seconds\n    while time.time() - t_start < 55:\n        # Initialization: Random points on a unit sphere\n        # This is generally a good basin of attraction for this type of packing problem\n        p0 = np.random.normal(0, 1, (N, dim))\n        p0 /= np.linalg.norm(p0, axis=1, keepdims=True)\n        \n        # Pre-scale to satisfy d_max <= 1 approximately\n        d0 = p0[:, None, :] - p0[None, :, :]\n        d0_sq = np.sum(d0**2, axis=-1)\n        np.fill_diagonal(d0_sq, 0)\n        max_d2 = np.max(d0_sq)\n        if max_d2 > 1e-9:\n            p0 /= np.sqrt(max_d2)\n            \n        # Initial guess for t (min squared distance)\n        d0_sq[d0_sq < 1e-9] = np.inf\n        t0 = 0.8 * np.min(d0_sq) # Start conservatively feasible\n        \n        x0 = np.concatenate([p0.flatten(), [t0]])\n        \n        try:\n            res = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                jac=jac_obj,\n                constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                options={'maxiter': 500, 'ftol': 1e-6}\n            )\n            \n            # Extract points\n            pts_res = res.x[:-1].reshape((N, dim))\n            \n            # Calculate actual score\n            d = pts_res[:, None, :] - pts_res[None, :, :]\n            d2 = np.sum(d**2, axis=-1)\n            np.fill_diagonal(d2, np.nan)\n            \n            mn = np.nanmin(d2)\n            mx = np.nanmax(d2)\n            \n            if mx > 1e-9:\n                # The objective is (min_dist / max_dist)^2 = min_sq / max_sq\n                ratio = mn / mx\n                if ratio > best_ratio:\n                    best_ratio = ratio\n                    best_pts = pts_res\n        except Exception:\n            continue\n\n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 1.000015913552411,
    "min_max_ratio": 0.24005088264922325,
    "min_distance": 0.4899498776909178,
    "max_distance": 1.0000000000002542,
    "eval_time": 55.32627201080322,
    "error": null
  },
  "prompt": "Refine the best solution trial_3_6 by focusing on the 'active' constraints. Identify which pairs of points are at the minimum distance and which are at the maximum. Try to perturb the points in a way that 'loosens' the tightest constraints while maintaining the others.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a set of 14 points in 3D space that maximizes the squared ratio \n    of the minimum pairwise distance to the maximum pairwise distance.\n    \n    Strategy:\n    - Formulate as a constrained optimization problem:\n      Maximize t\n      Subject to:\n        dist_sq(i, j) >= t\n        dist_sq(i, j) <= 1\n    - Use Sequential Least Squares Programming (SLSQP) to handle constraints.\n    - Provide analytical Jacobian for performance.\n    - Use multi-start with random spherical initializations to avoid local optima.\n    \"\"\"\n    \n    N = 14\n    dim = 3\n    \n    # Precompute pair indices to avoid repeated looping\n    pairs = np.array([(i, j) for i in range(N) for j in range(i + 1, N)])\n    num_pairs = len(pairs)\n    idx_i = pairs[:, 0]\n    idx_j = pairs[:, 1]\n    \n    # The state vector x_aug contains [x_0, y_0, z_0, ..., x_13, y_13, z_13, t]\n    # Total variables: 14*3 + 1 = 43\n    \n    def objective(x_aug):\n        # We want to maximize t, so minimize -t\n        return -x_aug[-1]\n\n    def jac_obj(x_aug):\n        # Gradient of objective wrt [coords..., t]\n        g = np.zeros_like(x_aug)\n        g[-1] = -1.0\n        return g\n\n    def constraints(x_aug):\n        pts = x_aug[:-1].reshape((N, dim))\n        t = x_aug[-1]\n        \n        # Vectorized distance calculation\n        p_i = pts[idx_i]\n        p_j = pts[idx_j]\n        diff = p_i - p_j\n        d2 = np.sum(diff**2, axis=1)\n        \n        # Constraints formulation (c >= 0)\n        # 1. d^2 >= t  =>  d^2 - t >= 0\n        # 2. d^2 <= 1  =>  1 - d^2 >= 0\n        return np.concatenate([d2 - t, 1.0 - d2])\n\n    def jac_constraints(x_aug):\n        pts = x_aug[:-1].reshape((N, dim))\n        \n        p_i = pts[idx_i]\n        p_j = pts[idx_j]\n        diff = p_i - p_j\n        two_diff = 2 * diff\n        \n        # Jacobian matrix shape: (2 * num_pairs, 3 * N + 1)\n        jac = np.zeros((2 * num_pairs, 3 * N + 1))\n        \n        # Fill gradients for constraint set 1: d^2 - t >= 0\n        # d(d^2)/dx_i = 2(x_i - x_j)\n        # d(d^2)/dx_j = -2(x_i - x_j)\n        # d(-t)/dt = -1\n        \n        # We iterate over pairs to fill the sparse structure efficiently enough for N=14\n        for k in range(num_pairs):\n            u, v = pairs[k]\n            # Gradient with respect to point u\n            jac[k, 3*u : 3*u+3] = two_diff[k]\n            # Gradient with respect to point v\n            jac[k, 3*v : 3*v+3] = -two_diff[k]\n        \n        # Derivative w.r.t t is -1 for the first set of constraints\n        jac[:num_pairs, -1] = -1.0\n        \n        # Fill gradients for constraint set 2: 1 - d^2 >= 0\n        # Derivatives are simply the negative of the spatial derivatives of set 1\n        # Derivative w.r.t t is 0\n        jac[num_pairs:, :-1] = -jac[:num_pairs, :-1]\n        \n        return jac\n\n    best_ratio = -1.0\n    best_pts = np.random.rand(N, dim)\n    \n    t_start = time.time()\n    \n    # Run optimization loop for ~55 seconds\n    while time.time() - t_start < 55:\n        # Initialization: Random points on a unit sphere\n        # This is generally a good basin of attraction for this type of packing problem\n        p0 = np.random.normal(0, 1, (N, dim))\n        p0 /= np.linalg.norm(p0, axis=1, keepdims=True)\n        \n        # Pre-scale to satisfy d_max <= 1 approximately\n        d0 = p0[:, None, :] - p0[None, :, :]\n        d0_sq = np.sum(d0**2, axis=-1)\n        np.fill_diagonal(d0_sq, 0)\n        max_d2 = np.max(d0_sq)\n        if max_d2 > 1e-9:\n            p0 /= np.sqrt(max_d2)\n            \n        # Initial guess for t (min squared distance)\n        d0_sq[d0_sq < 1e-9] = np.inf\n        t0 = 0.8 * np.min(d0_sq) # Start conservatively feasible\n        \n        x0 = np.concatenate([p0.flatten(), [t0]])\n        \n        try:\n            res = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                jac=jac_obj,\n                constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                options={'maxiter': 500, 'ftol': 1e-6}\n            )\n            \n            # Extract points\n            pts_res = res.x[:-1].reshape((N, dim))\n            \n            # Calculate actual score\n            d = pts_res[:, None, :] - pts_res[None, :, :]\n            d2 = np.sum(d**2, axis=-1)\n            np.fill_diagonal(d2, np.nan)\n            \n            mn = np.nanmin(d2)\n            mx = np.nanmax(d2)\n            \n            if mx > 1e-9:\n                # The objective is (min_dist / max_dist)^2 = min_sq / max_sq\n                ratio = mn / mx\n                if ratio > best_ratio:\n                    best_ratio = ratio\n                    best_pts = pts_res\n        except Exception:\n            continue\n\n    return best_pts\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:39:21.339572",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 230,
        "candidates_token_count": 1620,
        "thoughts_token_count": 12273
      },
      "response_text_len": 4833
    }
  }
}