{
  "trial_id": "trial_14_1",
  "generation": 14,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses SLSQP with analytical gradients and a slack variable formulation.\n    \"\"\"\n    N = 14\n    M = N * (N - 1) // 2  # Number of pairs (91)\n    \n    # Precompute indices for vectorization of the Jacobian\n    # pdist returns distances in the order corresponding to triu_indices(N, k=1)\n    triu_rows, triu_cols = np.triu_indices(N, k=1)\n    \n    # Column indices in the Jacobian matrix for the coordinates of points i and j\n    col_idx_i = 3 * triu_rows\n    col_idx_j = 3 * triu_cols\n    \n    def get_ratio_sq(pts):\n        \"\"\"Helper to calculate the score.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if dists_sq.size == 0: return 0.0\n        mn, mx = np.min(dists_sq), np.max(dists_sq)\n        if mx < 1e-16: return 0.0\n        return mn / mx\n\n    # --- Optimization Definition ---\n    # Variables x: [p1_x, p1_y, p1_z, ..., pN_z, s] (Size 3*14 + 1 = 43)\n    # Objective: Minimize -s (Maximize slack variable s)\n    # Constraints: \n    #   1. d_ij^2 - s >= 0  (Ensures s <= all squared distances)\n    #   2. 1 - d_ij^2 >= 0  (Ensures all squared distances <= 1)\n    \n    def objective(x):\n        return -x[-1]\n\n    def obj_jac(x):\n        # Gradient of objective -s is [0, ..., 0, -1]\n        grad = np.zeros(len(x))\n        grad[-1] = -1.0\n        return grad\n\n    def constraints(x):\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        # Calculate squared distances (matches triu order)\n        d_sq = pdist(pts, 'sqeuclidean')\n        # Concatenate constraint residuals (must be >= 0)\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def constraints_jac(x):\n        pts = x[:-1].reshape((N, 3))\n        \n        # Calculate displacement vectors for all pairs: p_i - p_j\n        # Shape (M, 3)\n        diffs = pts[triu_rows] - pts[triu_cols]\n        \n        # Gradient of d_ij^2 w.r.t p_i is  2 * (p_i - p_j)\n        # Gradient of d_ij^2 w.r.t p_j is -2 * (p_i - p_j)\n        grad_d_sq = 2.0 * diffs \n        \n        # Initialize Jacobian matrix (2M constraints x 3N+1 variables)\n        jac = np.zeros((2 * M, 3 * N + 1))\n        \n        # Fill Jacobian using a loop over pairs (M=91 is small enough)\n        for k in range(M):\n            # Indices of coordinate variables in x\n            idx_p_i = col_idx_i[k]\n            idx_p_j = col_idx_j[k]\n            g = grad_d_sq[k]\n            \n            # Constraint 1 Row k: d_ij^2 - s >= 0\n            jac[k, idx_p_i : idx_p_i + 3] = g\n            jac[k, idx_p_j : idx_p_j + 3] = -g\n            jac[k, -1] = -1.0\n            \n            # Constraint 2 Row M+k: 1 - d_ij^2 >= 0\n            # Gradients are negated relative to d_ij^2\n            jac[M + k, idx_p_i : idx_p_i + 3] = -g\n            jac[M + k, idx_p_j : idx_p_j + 3] = g\n            # s term is 0\n            \n        return jac\n\n    def solve(pts_init):\n        # Normalize initialization to satisfy max dist constraint\n        d_sq = pdist(pts_init, 'sqeuclidean')\n        if d_sq.size > 0:\n            mx = np.max(d_sq)\n            if mx > 1e-16:\n                pts_init = pts_init / np.sqrt(mx)\n        \n        # Initialize slack s to the current minimum squared distance\n        d_sq = pdist(pts_init, 'sqeuclidean')\n        s_init = np.min(d_sq) if d_sq.size > 0 else 0.01\n        \n        # Construct variable vector\n        x0 = np.concatenate([pts_init.flatten(), [s_init]])\n        \n        # Define constraints dictionary\n        cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n        \n        # Solver options for high precision\n        opts = {\n            'maxiter': 1000,\n            'ftol': 1e-15,\n            'disp': False\n        }\n        \n        try:\n            res = minimize(objective, x0, method='SLSQP', jac=obj_jac, \n                           constraints=cons, options=opts, tol=1e-15)\n            return res.x[:-1].reshape((N, 3))\n        except Exception:\n            return pts_init\n\n    # --- 1. Initialization: Fibonacci Sphere ---\n    phi = (1.0 + 5.0**0.5) / 2.0\n    idx = np.arange(N) + 0.5\n    z = 1.0 - 2.0 * idx / N\n    r = np.sqrt(np.maximum(0, 1.0 - z*z))\n    theta = 2.0 * np.pi * idx / phi\n    pts_fib = np.stack([r * np.cos(theta), r * np.sin(theta), z], axis=1)\n    \n    best_pts = pts_fib\n    best_ratio = get_ratio_sq(best_pts)\n    \n    # Polish the Fibonacci start\n    pts_polished = solve(pts_fib)\n    ratio_polished = get_ratio_sq(pts_polished)\n    if ratio_polished > best_ratio:\n        best_pts = pts_polished\n        best_ratio = ratio_polished\n\n    # --- 2. Basin Hopping Search ---\n    start_time = time.time()\n    # Run for up to 55 seconds to ensure we return within 60s\n    while time.time() - start_time < 55:\n        # Perturbation Strategy\n        r_val = np.random.rand()\n        \n        if r_val < 0.15:\n            # Random restart\n            pts_perturb = np.random.uniform(-1, 1, (N, 3))\n        else:\n            # Perturb current best\n            scale = np.random.choice([0.05, 0.1, 0.2])\n            pts_perturb = best_pts + np.random.normal(0, scale, (N, 3))\n        \n        # Local Optimization\n        pts_new = solve(pts_perturb)\n        ratio_new = get_ratio_sq(pts_new)\n        \n        # Update best\n        if ratio_new > best_ratio:\n            best_pts = pts_new\n            best_ratio = ratio_new\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539168,
    "min_max_ratio": 0.2400508826495847,
    "min_distance": 0.4899498776911621,
    "max_distance": 1.0,
    "eval_time": 55.29482126235962,
    "error": null
  },
  "prompt": "The best performing code is trial_7_5. It uses Basin-hopping with SLSQP.\nImprove it by:\n1. Increasing the precision of the SLSQP solver (tol=1e-15, ftol=1e-15).\n2. Implementing an analytical Jacobian for the slack variable formulation.\n3. Using the coordinates from trial_7_5 (if you can infer them) or a Fibonacci sphere as a seed.\n4. Focus on the 'slack variable' approach: Maximize s subject to dist_ij^2 >= s and dist_ij^2 <= 1.\nCode:\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a high-restart Basin-hopping search with SLSQP local optimization and a slack variable.\n    Initializes with a Fibonacci sphere using the specified golden ratio.\n    \"\"\"\n    N = 14\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates the squared ratio of min distance to max distance.\"\"\"\n        if pts.shape[0] < 2:\n            return 0.0\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0:\n            return 0.0\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def solve_with_init(pts_init):\n        \"\"\"\n        Local optimization using SLSQP with a slack variable.\n        Maximizes s subject to d_min^2 >= s and d_max^2 <= 1.\n        \"\"\"\n        def objective(vars):\n            # Maximize the slack variable s\n            return -vars[-1]\n\n        def constraints(vars):\n            pts = vars[:-1].reshape((N, 3))\n            s = vars[-1]\n            d_sq = pdist(pts, 'sqeuclidean')\n            # Constraints: d_ij^2 - s >= 0 (min distance) and 1.0 - d_ij^2 >= 0 (max distance)\n            return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n        # Normalize the initial points so that the maximum distance is 1.0\n        dists_sq_init = pdist(pts_init, 'sqeuclidean')\n        d_max_sq_init = np.max(dists_sq_init)\n        pts_init_norm = pts_init / np.sqrt(d_max_sq_init)\n        \n        # Initial slack variable is the minimum squared distance of the normalized set\n        s_init = np.min(pdist(pts_init_norm, 'sqeuclidean'))\n        \n        # Flattened points + slack variable s\n        vars_init = np.concatenate([pts_init_norm.flatten(), [s_init]])\n        \n        # Run SLSQP\n        res = minimize(objective, vars_init, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints},\n                       options={'maxiter': 400, 'ftol': 1e-8})\n        return res\n\n    # 1. Fibonacci Sphere Initialization\n    # Use the golden ratio specified: (1 + sqrt(5)) / 2 + 0.0\n    phi = (1.0 + 5.0**0.5) / 2.0 + 0.0\n    indices = np.arange(N) + 0.5\n    z = 1.0 - 2.0 * indices / N\n    radius = np.sqrt(np.maximum(0, 1.0 - z * z))\n    theta = 2.0 * np.pi * indices / phi\n    pts_fib = np.stack([radius * np.cos(theta), radius * np.sin(theta), z], axis=1)\n    \n    # Polish the Fibonacci initialization\n    best_pts = pts_fib\n    best_ratio = get_ratio_sq(pts_fib)\n    \n    res = solve_with_init(pts_fib)\n    pts_out = res.x[:-1].reshape((N, 3))\n    ratio = get_ratio_sq(pts_out)\n    if ratio > best_ratio:\n        best_ratio = ratio\n        best_pts = pts_out\n    \n    # 2. High-Restart Basin-Hopping Search\n    start_time = time.time()\n    # Search for up to 50 seconds to ensure completion within the 60s limit\n    while time.time() - start_time < 50:\n        # Strategy A: Perturb the current best solution (Basin-hopping step)\n        scale = np.random.choice([0.02, 0.05, 0.1, 0.15])\n        pts_perturbed = best_pts + np.random.normal(0, scale, best_pts.shape)\n        res = solve_with_init(pts_perturbed)\n        pts_out = res.x[:-1].reshape((N, 3))\n        ratio = get_ratio_sq(pts_out)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_out\n        \n        # Strategy B: Random restart from a uniform distribution occasionally\n        if np.random.rand() < 0.25:\n            pts_rand = np.random.uniform(-0.5, 0.5, (N, 3))\n            res = solve_with_init(pts_rand)\n            pts_out = res.x[:-1].reshape((N, 3))\n            ratio = get_ratio_sq(pts_out)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_pts = pts_out\n                \n    # Return the best point configuration found\n    return best_pts.reshape((14, 3))\n",
  "response": "Here is the improved Python solution. It implements the slack variable optimization with an analytical Jacobian for the SLSQP solver, uses high-precision tolerances, and employs a Fibonacci sphere initialization followed by a Basin-hopping search.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses SLSQP with analytical gradients and a slack variable formulation.\n    \"\"\"\n    N = 14\n    M = N * (N - 1) // 2  # Number of pairs (91)\n    \n    # Precompute indices for vectorization of the Jacobian\n    # pdist returns distances in the order corresponding to triu_indices(N, k=1)\n    triu_rows, triu_cols = np.triu_indices(N, k=1)\n    \n    # Column indices in the Jacobian matrix for the coordinates of points i and j\n    col_idx_i = 3 * triu_rows\n    col_idx_j = 3 * triu_cols\n    \n    def get_ratio_sq(pts):\n        \"\"\"Helper to calculate the score.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if dists_sq.size == 0: return 0.0\n        mn, mx = np.min(dists_sq), np.max(dists_sq)\n        if mx < 1e-16: return 0.0\n        return mn / mx\n\n    # --- Optimization Definition ---\n    # Variables x: [p1_x, p1_y, p1_z, ..., pN_z, s] (Size 3*14 + 1 = 43)\n    # Objective: Minimize -s (Maximize slack variable s)\n    # Constraints: \n    #   1. d_ij^2 - s >= 0  (Ensures s <= all squared distances)\n    #   2. 1 - d_ij^2 >= 0  (Ensures all squared distances <= 1)\n    \n    def objective(x):\n        return -x[-1]\n\n    def obj_jac(x):\n        # Gradient of objective -s is [0, ..., 0, -1]\n        grad = np.zeros(len(x))\n        grad[-1] = -1.0\n        return grad\n\n    def constraints(x):\n        pts = x[:-1].reshape((N, 3))\n        s = x[-1]\n        # Calculate squared distances (matches triu order)\n        d_sq = pdist(pts, 'sqeuclidean')\n        # Concatenate constraint residuals (must be >= 0)\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def constraints_jac(x):\n        pts = x[:-1].reshape((N, 3))\n        \n        # Calculate displacement vectors for all pairs: p_i - p_j\n        # Shape (M, 3)\n        diffs = pts[triu_rows] - pts[triu_cols]\n        \n        # Gradient of d_ij^2 w.r.t p_i is  2 * (p_i - p_j)\n        # Gradient of d_ij^2 w.r.t p_j is -2 * (p_i - p_j)\n        grad_d_sq = 2.0 * diffs \n        \n        # Initialize Jacobian matrix (2M constraints x 3N+1 variables)\n        jac = np.zeros((2 * M, 3 * N + 1))\n        \n        # Fill Jacobian using a loop over pairs (M=91 is small enough)\n        for k in range(M):\n            # Indices of coordinate variables in x\n            idx_p_i = col_idx_i[k]\n            idx_p_j = col_idx_j[k]\n            g = grad_d_sq[k]\n            \n            # Constraint 1 Row k: d_ij^2 - s >= 0\n            jac[k, idx_p_i : idx_p_i + 3] = g\n            jac[k, idx_p_j : idx_p_j + 3] = -g\n            jac[k, -1] = -1.0\n            \n            # Constraint 2 Row M+k: 1 - d_ij^2 >= 0\n            # Gradients are negated relative to d_ij^2\n            jac[M + k, idx_p_i : idx_p_i + 3] = -g\n            jac[M + k, idx_p_j : idx_p_j + 3] = g\n            # s term is 0\n            \n        return jac\n\n    def solve(pts_init):\n        # Normalize initialization to satisfy max dist constraint\n        d_sq = pdist(pts_init, 'sqeuclidean')\n        if d_sq.size > 0:\n            mx = np.max(d_sq)\n            if mx > 1e-16:\n                pts_init = pts_init / np.sqrt(mx)\n        \n        # Initialize slack s to the current minimum squared distance\n        d_sq = pdist(pts_init, 'sqeuclidean')\n        s_init = np.min(d_sq) if d_sq.size > 0 else 0.01\n        \n        # Construct variable vector\n        x0 = np.concatenate([pts_init.flatten(), [s_init]])\n        \n        # Define constraints dictionary\n        cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n        \n        # Solver options for high precision\n        opts = {\n            'maxiter': 1000,\n            'ftol': 1e-15,\n            'disp': False\n        }\n        \n        try:\n            res = minimize(objective, x0, method='SLSQP', jac=obj_jac, \n                           constraints=cons, options=opts, tol=1e-15)\n            return res.x[:-1].reshape((N, 3))\n        except Exception:\n            return pts_init\n\n    # --- 1. Initialization: Fibonacci Sphere ---\n    phi = (1.0 + 5.0**0.5) / 2.0\n    idx = np.arange(N) + 0.5\n    z = 1.0 - 2.0 * idx / N\n    r = np.sqrt(np.maximum(0, 1.0 - z*z))\n    theta = 2.0 * np.pi * idx / phi\n    pts_fib = np.stack([r * np.cos(theta), r * np.sin(theta), z], axis=1)\n    \n    best_pts = pts_fib\n    best_ratio = get_ratio_sq(best_pts)\n    \n    # Polish the Fibonacci start\n    pts_polished = solve(pts_fib)\n    ratio_polished = get_ratio_sq(pts_polished)\n    if ratio_polished > best_ratio:\n        best_pts = pts_polished\n        best_ratio = ratio_polished\n\n    # --- 2. Basin Hopping Search ---\n    start_time = time.time()\n    # Run for up to 55 seconds to ensure we return within 60s\n    while time.time() - start_time < 55:\n        # Perturbation Strategy\n        r_val = np.random.rand()\n        \n        if r_val < 0.15:\n            # Random restart\n            pts_perturb = np.random.uniform(-1, 1, (N, 3))\n        else:\n            # Perturb current best\n            scale = np.random.choice([0.05, 0.1, 0.2])\n            pts_perturb = best_pts + np.random.normal(0, scale, (N, 3))\n        \n        # Local Optimization\n        pts_new = solve(pts_perturb)\n        ratio_new = get_ratio_sq(pts_new)\n        \n        # Update best\n        if ratio_new > best_ratio:\n            best_pts = pts_new\n            best_ratio = ratio_new\n            \n    return best_pts\n```",
  "reasoning": "Here is the improved Python solution. It implements the slack variable optimization with an analytical Jacobian for the SLSQP solver, uses high-precision tolerances, and employs a Fibonacci sphere initialization followed by a Basin-hopping search.",
  "timestamp": "2026-01-21T18:28:38.360939",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 1577,
        "candidates_token_count": 1958,
        "thoughts_token_count": 8217
      },
      "response_text_len": 5817
    }
  }
}