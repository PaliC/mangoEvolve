{
  "trial_id": "trial_14_2",
  "generation": 14,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimize the 14-point configuration in 3D to maximize the squared ratio (min_dist / max_dist)^2.\n    Starting from a highly symmetric Oh configuration (Rhombic Dodecahedron), \n    the configuration is then refined using SLSQP to find a potential local optimum.\n    \"\"\"\n    \n    # Step 1: Initialize the configuration with Oh symmetry (Tetrakis Hexahedron).\n    # This involves 6 vertices of an octahedron and 8 vertices of a cube.\n    # The ratio b/a = 1/sqrt(3) places all points on a sphere of radius 'a'.\n    a = 1.0\n    b = 1.0 / np.sqrt(3)\n    \n    # 6 Octahedron vertices: (+-a, 0, 0), (0, +-a, 0), (0, 0, +-a)\n    # 8 Cube vertices: (+-b, +-b, +-b)\n    pts = np.array([\n        [a, 0, 0], [-a, 0, 0], [0, a, 0], [0, -a, 0], [0, 0, a], [0, 0, -a],\n        [b, b, b], [b, b, -b], [b, -b, b], [b, -b, -b],\n        [-b, b, b], [-b, b, -b], [-b, -b, b], [-b, -b, -b]\n    ])\n    \n    def objective(flat_pts):\n        \"\"\"\n        Calculates the negative of (min_dist / max_dist)^2.\n        Using squared distances avoids unnecessary square root computations.\n        \"\"\"\n        p = flat_pts.reshape((14, 3))\n        \n        # Calculate all-pairs squared Euclidean distances\n        # Vectorized calculation: (N, 1, 3) - (1, N, 3) -> (N, N, 3)\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        d2_matrix = np.sum(diff**2, axis=-1)\n        \n        # Extract the upper triangle of the distance matrix to get unique pairs\n        indices = np.triu_indices(14, k=1)\n        d2_unique = d2_matrix[indices]\n        \n        min_d2 = np.min(d2_unique)\n        max_d2 = np.max(d2_unique)\n        \n        # Maximize the ratio min_d2 / max_d2\n        # We minimize the negative to fit the 'minimize' function signature\n        return -min_d2 / max_d2\n\n    # Step 2: Refine the Oh configuration using SLSQP.\n    # SLSQP can handle the non-smooth min/max objective reasonably well\n    # for this problem size.\n    res = minimize(\n        objective, \n        pts.flatten(), \n        method='SLSQP', \n        tol=1e-12, \n        options={'maxiter': 1000, 'disp': False}\n    )\n    \n    # Extract optimized coordinates\n    optimized_pts = res.x.reshape((14, 3))\n    \n    return optimized_pts",
  "metrics": {
    "valid": true,
    "score": 0.7344286922715593,
    "min_max_ratio": 0.17629745030398722,
    "min_distance": 9.169549526028595,
    "max_distance": 21.838609609477317,
    "eval_time": 0.6793777942657471,
    "error": null
  },
  "prompt": "Optimize the 14-point configuration assuming Oh symmetry (Rhombic Dodecahedron).\nThe 14 points are:\n- 6 points: (+/- a, 0, 0), (0, +/- a, 0), (0, 0, +/- a)\n- 8 points: (+/- b, +/- b, +/- b)\nOptimize 'a' and 'b' to maximize (min_dist/max_dist)^2.\nThen, allow the points to slightly deviate from this symmetry to see if a nearby local optimum is better.\nUse SLSQP with high precision.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimize the 14-point configuration in 3D to maximize the squared ratio (min_dist / max_dist)^2.\n    Starting from a highly symmetric Oh configuration (Rhombic Dodecahedron), \n    the configuration is then refined using SLSQP to find a potential local optimum.\n    \"\"\"\n    \n    # Step 1: Initialize the configuration with Oh symmetry (Tetrakis Hexahedron).\n    # This involves 6 vertices of an octahedron and 8 vertices of a cube.\n    # The ratio b/a = 1/sqrt(3) places all points on a sphere of radius 'a'.\n    a = 1.0\n    b = 1.0 / np.sqrt(3)\n    \n    # 6 Octahedron vertices: (+-a, 0, 0), (0, +-a, 0), (0, 0, +-a)\n    # 8 Cube vertices: (+-b, +-b, +-b)\n    pts = np.array([\n        [a, 0, 0], [-a, 0, 0], [0, a, 0], [0, -a, 0], [0, 0, a], [0, 0, -a],\n        [b, b, b], [b, b, -b], [b, -b, b], [b, -b, -b],\n        [-b, b, b], [-b, b, -b], [-b, -b, b], [-b, -b, -b]\n    ])\n    \n    def objective(flat_pts):\n        \"\"\"\n        Calculates the negative of (min_dist / max_dist)^2.\n        Using squared distances avoids unnecessary square root computations.\n        \"\"\"\n        p = flat_pts.reshape((14, 3))\n        \n        # Calculate all-pairs squared Euclidean distances\n        # Vectorized calculation: (N, 1, 3) - (1, N, 3) -> (N, N, 3)\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        d2_matrix = np.sum(diff**2, axis=-1)\n        \n        # Extract the upper triangle of the distance matrix to get unique pairs\n        indices = np.triu_indices(14, k=1)\n        d2_unique = d2_matrix[indices]\n        \n        min_d2 = np.min(d2_unique)\n        max_d2 = np.max(d2_unique)\n        \n        # Maximize the ratio min_d2 / max_d2\n        # We minimize the negative to fit the 'minimize' function signature\n        return -min_d2 / max_d2\n\n    # Step 2: Refine the Oh configuration using SLSQP.\n    # SLSQP can handle the non-smooth min/max objective reasonably well\n    # for this problem size.\n    res = minimize(\n        objective, \n        pts.flatten(), \n        method='SLSQP', \n        tol=1e-12, \n        options={'maxiter': 1000, 'disp': False}\n    )\n    \n    # Extract optimized coordinates\n    optimized_pts = res.x.reshape((14, 3))\n    \n    return optimized_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:29:53.822123",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 301,
        "candidates_token_count": 797,
        "thoughts_token_count": 33485
      },
      "response_text_len": 2304
    }
  }
}