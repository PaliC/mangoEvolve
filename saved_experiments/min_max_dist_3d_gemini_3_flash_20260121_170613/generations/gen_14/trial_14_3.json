{
  "trial_id": "trial_14_3",
  "generation": 14,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds the configuration of 14 points in 3D space that maximizes the squared ratio\n    (min_dist / max_dist)^2 using Micro-Basin-Hopping with SLSQP and analytical Jacobians.\n    \"\"\"\n    # Parameters\n    N = 14\n    stepsize = 0.01  # Micro-step for basin hopping\n    target_iters = 500\n    time_limit = 58.0  # Seconds\n    \n    # 1. Initialization: Fibonacci Sphere\n    # Generate points on a unit sphere\n    indices = np.arange(0, N, dtype=float) + 0.5\n    phi = np.arccos(1 - 2*indices/N)\n    theta = np.pi * (1 + 5**0.5) * indices\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    points = np.column_stack((x, y, z))\n    \n    # Scale to have diameter approx 1 (Fib sphere has radius 1, diam 2)\n    points *= 0.5\n    \n    # State vector: coordinates + slack variable s\n    # We maximize s subject to d_ij^2 >= s and d_ij^2 <= 1\n    # This maximizes d_min^2 given d_max <= 1, equivalent to maximizing (d_min/d_max)^2\n    s0 = 0.1\n    x0 = np.concatenate([points.flatten(), [s0]])\n    \n    # Constraint indices (upper triangle of distance matrix)\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_pairs = len(idx_i)\n    \n    # Precompute indices for efficient Jacobian construction\n    rows_c1 = np.arange(num_pairs)\n    rows_c2 = rows_c1 + num_pairs\n    \n    # Column indices for coordinates of point i and j in the flattened array\n    cols_ix = 3 * idx_i\n    cols_iy = 3 * idx_i + 1\n    cols_iz = 3 * idx_i + 2\n    \n    cols_jx = 3 * idx_j\n    cols_jy = 3 * idx_j + 1\n    cols_jz = 3 * idx_j + 2\n    \n    # Objective function: Minimize -s (Maximize s)\n    def obj(var):\n        return -var[-1]\n    \n    def obj_jac(var):\n        g = np.zeros_like(var)\n        g[-1] = -1.0\n        return g\n    \n    # Constraints function\n    def constraints(var):\n        pts = var[:-1].reshape((N, 3))\n        s = var[-1]\n        \n        # Calculate squared distances\n        diff = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        \n        # c1: d^2 >= s  => d^2 - s >= 0\n        c1 = d2 - s\n        # c2: d^2 <= 1  => 1 - d^2 >= 0\n        c2 = 1.0 - d2\n        \n        return np.concatenate([c1, c2])\n    \n    # Analytical Jacobian of constraints\n    def con_jac(var):\n        pts = var[:-1].reshape((N, 3))\n        # s = var[-1]\n        \n        diff = pts[idx_i] - pts[idx_j]\n        # Gradient of d^2 w.r.t pts_i is 2*(pi - pj)\n        grad = 2 * diff # Shape (num_pairs, 3)\n        \n        # Initialize sparse-like dense jacobian\n        jac = np.zeros((2 * num_pairs, len(var)))\n        \n        # --- c1 constraints: d^2 - s >= 0 ---\n        # w.r.t s\n        jac[rows_c1, -1] = -1.0\n        \n        # w.r.t coordinates of i\n        jac[rows_c1, cols_ix] = grad[:, 0]\n        jac[rows_c1, cols_iy] = grad[:, 1]\n        jac[rows_c1, cols_iz] = grad[:, 2]\n        \n        # w.r.t coordinates of j (chain rule gives minus)\n        jac[rows_c1, cols_jx] = -grad[:, 0]\n        jac[rows_c1, cols_jy] = -grad[:, 1]\n        jac[rows_c1, cols_jz] = -grad[:, 2]\n        \n        # --- c2 constraints: 1 - d^2 >= 0 ---\n        # w.r.t s is 0\n        # w.r.t coordinates is negative of d^2 gradient\n        jac[rows_c2, cols_ix] = -grad[:, 0]\n        jac[rows_c2, cols_iy] = -grad[:, 1]\n        jac[rows_c2, cols_iz] = -grad[:, 2]\n        \n        jac[rows_c2, cols_jx] = grad[:, 0]\n        jac[rows_c2, cols_jy] = grad[:, 1]\n        jac[rows_c2, cols_jz] = grad[:, 2]\n        \n        return jac\n    \n    cons = {'type': 'ineq', 'fun': constraints, 'jac': con_jac}\n    \n    # Perturbation step\n    def take_step(x):\n        coords = x[:-1].reshape((N, 3))\n        \n        # Random displacement\n        pert = np.random.uniform(-stepsize, stepsize, size=coords.shape)\n        coords += pert\n        \n        # Re-center to prevent drift\n        coords -= np.mean(coords, axis=0)\n        \n        # Estimate a feasible s for the new configuration to help optimizer\n        diff = coords[idx_i] - coords[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        min_d2 = np.min(d2) if len(d2) > 0 else 0.0\n        \n        # Set s slightly below min dist\n        s_new = max(1e-6, min_d2 - 1e-4)\n        \n        return np.concatenate([coords.flatten(), [s_new]])\n\n    # Start optimization loop\n    start_time = time.time()\n    \n    # Initial local minimization\n    res = minimize(obj, x0, jac=obj_jac, method='SLSQP', constraints=cons, \n                   options={'maxiter': 200, 'ftol': 1e-6})\n    \n    best_x = res.x\n    best_fun = res.fun\n    \n    current_x = best_x\n    current_fun = best_fun\n    \n    T = 0.001 # Temperature for Metropolis\n    \n    for i in range(target_iters):\n        if time.time() - start_time > time_limit:\n            break\n            \n        # 3. Basin-hopping step\n        cand_x_start = take_step(current_x)\n        \n        # Local Minimization\n        # Reduced maxiter for speed inside loop\n        res = minimize(obj, cand_x_start, jac=obj_jac, method='SLSQP', constraints=cons, \n                       options={'maxiter': 50, 'ftol': 1e-4})\n        \n        cand_x = res.x\n        cand_fun = res.fun\n        \n        # Metropolis Acceptance\n        # We are minimizing -s, so lower is better\n        if cand_fun < current_fun:\n            current_x = cand_x\n            current_fun = cand_fun\n            if cand_fun < best_fun:\n                best_fun = cand_fun\n                best_x = cand_x\n        else:\n            delta = cand_fun - current_fun\n            if np.random.rand() < np.exp(-delta / T):\n                current_x = cand_x\n                current_fun = cand_fun\n                \n    # Return best points found\n    final_points = best_x[:-1].reshape((N, 3))\n    return final_points",
  "metrics": {
    "valid": true,
    "score": 0.8419873950870402,
    "min_max_ratio": 0.20211660097704148,
    "min_distance": 0.45647239229180253,
    "max_distance": 1.015344739946384,
    "eval_time": 1.1121108531951904,
    "error": null
  },
  "prompt": "Perform 'Micro-Basin-Hopping' on the best known configuration for 14 points.\n1. Start with a Fibonacci sphere initialization.\n2. Use the slack variable formulation (maximize s, constraints d_ij^2 >= s, d_ij^2 <= 1).\n3. In the Basin-hopping step, use a very small 'stepsize' (e.g., 0.01) to explore the immediate neighborhood of the best local optimum.\n4. Use a large number of iterations (e.g., 500) within the 60s time limit.\nEnsure analytical Jacobians are used for the constraints.",
  "response": "An implementation of the Micro-Basin-Hopping algorithm to find the optimal configuration for 14 points in 3D space, maximizing the minimum pairwise distance ratio.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds the configuration of 14 points in 3D space that maximizes the squared ratio\n    (min_dist / max_dist)^2 using Micro-Basin-Hopping with SLSQP and analytical Jacobians.\n    \"\"\"\n    # Parameters\n    N = 14\n    stepsize = 0.01  # Micro-step for basin hopping\n    target_iters = 500\n    time_limit = 58.0  # Seconds\n    \n    # 1. Initialization: Fibonacci Sphere\n    # Generate points on a unit sphere\n    indices = np.arange(0, N, dtype=float) + 0.5\n    phi = np.arccos(1 - 2*indices/N)\n    theta = np.pi * (1 + 5**0.5) * indices\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    points = np.column_stack((x, y, z))\n    \n    # Scale to have diameter approx 1 (Fib sphere has radius 1, diam 2)\n    points *= 0.5\n    \n    # State vector: coordinates + slack variable s\n    # We maximize s subject to d_ij^2 >= s and d_ij^2 <= 1\n    # This maximizes d_min^2 given d_max <= 1, equivalent to maximizing (d_min/d_max)^2\n    s0 = 0.1\n    x0 = np.concatenate([points.flatten(), [s0]])\n    \n    # Constraint indices (upper triangle of distance matrix)\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_pairs = len(idx_i)\n    \n    # Precompute indices for efficient Jacobian construction\n    rows_c1 = np.arange(num_pairs)\n    rows_c2 = rows_c1 + num_pairs\n    \n    # Column indices for coordinates of point i and j in the flattened array\n    cols_ix = 3 * idx_i\n    cols_iy = 3 * idx_i + 1\n    cols_iz = 3 * idx_i + 2\n    \n    cols_jx = 3 * idx_j\n    cols_jy = 3 * idx_j + 1\n    cols_jz = 3 * idx_j + 2\n    \n    # Objective function: Minimize -s (Maximize s)\n    def obj(var):\n        return -var[-1]\n    \n    def obj_jac(var):\n        g = np.zeros_like(var)\n        g[-1] = -1.0\n        return g\n    \n    # Constraints function\n    def constraints(var):\n        pts = var[:-1].reshape((N, 3))\n        s = var[-1]\n        \n        # Calculate squared distances\n        diff = pts[idx_i] - pts[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        \n        # c1: d^2 >= s  => d^2 - s >= 0\n        c1 = d2 - s\n        # c2: d^2 <= 1  => 1 - d^2 >= 0\n        c2 = 1.0 - d2\n        \n        return np.concatenate([c1, c2])\n    \n    # Analytical Jacobian of constraints\n    def con_jac(var):\n        pts = var[:-1].reshape((N, 3))\n        # s = var[-1]\n        \n        diff = pts[idx_i] - pts[idx_j]\n        # Gradient of d^2 w.r.t pts_i is 2*(pi - pj)\n        grad = 2 * diff # Shape (num_pairs, 3)\n        \n        # Initialize sparse-like dense jacobian\n        jac = np.zeros((2 * num_pairs, len(var)))\n        \n        # --- c1 constraints: d^2 - s >= 0 ---\n        # w.r.t s\n        jac[rows_c1, -1] = -1.0\n        \n        # w.r.t coordinates of i\n        jac[rows_c1, cols_ix] = grad[:, 0]\n        jac[rows_c1, cols_iy] = grad[:, 1]\n        jac[rows_c1, cols_iz] = grad[:, 2]\n        \n        # w.r.t coordinates of j (chain rule gives minus)\n        jac[rows_c1, cols_jx] = -grad[:, 0]\n        jac[rows_c1, cols_jy] = -grad[:, 1]\n        jac[rows_c1, cols_jz] = -grad[:, 2]\n        \n        # --- c2 constraints: 1 - d^2 >= 0 ---\n        # w.r.t s is 0\n        # w.r.t coordinates is negative of d^2 gradient\n        jac[rows_c2, cols_ix] = -grad[:, 0]\n        jac[rows_c2, cols_iy] = -grad[:, 1]\n        jac[rows_c2, cols_iz] = -grad[:, 2]\n        \n        jac[rows_c2, cols_jx] = grad[:, 0]\n        jac[rows_c2, cols_jy] = grad[:, 1]\n        jac[rows_c2, cols_jz] = grad[:, 2]\n        \n        return jac\n    \n    cons = {'type': 'ineq', 'fun': constraints, 'jac': con_jac}\n    \n    # Perturbation step\n    def take_step(x):\n        coords = x[:-1].reshape((N, 3))\n        \n        # Random displacement\n        pert = np.random.uniform(-stepsize, stepsize, size=coords.shape)\n        coords += pert\n        \n        # Re-center to prevent drift\n        coords -= np.mean(coords, axis=0)\n        \n        # Estimate a feasible s for the new configuration to help optimizer\n        diff = coords[idx_i] - coords[idx_j]\n        d2 = np.sum(diff**2, axis=1)\n        min_d2 = np.min(d2) if len(d2) > 0 else 0.0\n        \n        # Set s slightly below min dist\n        s_new = max(1e-6, min_d2 - 1e-4)\n        \n        return np.concatenate([coords.flatten(), [s_new]])\n\n    # Start optimization loop\n    start_time = time.time()\n    \n    # Initial local minimization\n    res = minimize(obj, x0, jac=obj_jac, method='SLSQP', constraints=cons, \n                   options={'maxiter': 200, 'ftol': 1e-6})\n    \n    best_x = res.x\n    best_fun = res.fun\n    \n    current_x = best_x\n    current_fun = best_fun\n    \n    T = 0.001 # Temperature for Metropolis\n    \n    for i in range(target_iters):\n        if time.time() - start_time > time_limit:\n            break\n            \n        # 3. Basin-hopping step\n        cand_x_start = take_step(current_x)\n        \n        # Local Minimization\n        # Reduced maxiter for speed inside loop\n        res = minimize(obj, cand_x_start, jac=obj_jac, method='SLSQP', constraints=cons, \n                       options={'maxiter': 50, 'ftol': 1e-4})\n        \n        cand_x = res.x\n        cand_fun = res.fun\n        \n        # Metropolis Acceptance\n        # We are minimizing -s, so lower is better\n        if cand_fun < current_fun:\n            current_x = cand_x\n            current_fun = cand_fun\n            if cand_fun < best_fun:\n                best_fun = cand_fun\n                best_x = cand_x\n        else:\n            delta = cand_fun - current_fun\n            if np.random.rand() < np.exp(-delta / T):\n                current_x = cand_x\n                current_fun = cand_fun\n                \n    # Return best points found\n    final_points = best_x[:-1].reshape((N, 3))\n    return final_points\n```",
  "reasoning": "An implementation of the Micro-Basin-Hopping algorithm to find the optimal configuration for 14 points in 3D space, maximizing the minimum pairwise distance ratio.",
  "timestamp": "2026-01-21T18:28:40.011628",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 312,
        "candidates_token_count": 2056,
        "thoughts_token_count": 12859
      },
      "response_text_len": 5973
    }
  }
}