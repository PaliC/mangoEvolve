{
  "trial_id": "trial_17_2",
  "generation": 17,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximizes the minimum pairwise distance between 14 points in 3D space,\n    given a fixed diameter (max pairwise distance) of 1.\n    The goal is to maximize the squared ratio (min distance / max distance)^2.\n    Uses Basin-hopping with SLSQP and a custom step-take function.\n    \"\"\"\n    n_points = 14\n    dim = 3\n    n_vars = n_points * dim + 1  # 42 coordinates + 1 slack variable s\n\n    def get_initial_points():\n        # Initialize points randomly within a sphere of diameter 1\n        pts = np.random.normal(0, 1, (n_points, dim))\n        pts -= np.mean(pts, axis=0)\n        # Rescale so the initial diameter is exactly 1\n        dists = np.linalg.norm(pts[:, None, :] - pts[None, :, :], axis=-1)\n        max_d = np.max(dists)\n        if max_d > 0:\n            pts /= max_d\n        else:\n            # Fallback if points are all at the origin\n            pts = np.random.normal(0, 0.1, (n_points, dim))\n            max_d = np.max(np.linalg.norm(pts[:, None, :] - pts[None, :, :], axis=-1))\n            pts /= max_d\n            \n        # Initial slack variable s (minimum squared distance)\n        diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dist_sq = np.sum(diffs**2, axis=-1)\n        s = np.min(dist_sq[np.triu_indices(n_points, 1)])\n        return np.concatenate([pts.flatten(), [s]])\n\n    def objective(u):\n        # Slack variable s represents min_dist^2. Maximize s => Minimize -s.\n        return -u[-1]\n\n    def objective_grad(u):\n        # Analytical gradient of the objective function\n        grad = np.zeros(n_vars)\n        grad[-1] = -1.0\n        return grad\n\n    def constraints(u):\n        # Points are derived from the first 42 variables\n        pts = u[:-1].reshape((n_points, dim))\n        s = u[-1]\n        idx_i, idx_j = np.triu_indices(n_points, 1)\n        diffs = pts[idx_i] - pts[idx_j]\n        d_sq = np.sum(diffs**2, axis=1)\n        # c1: d_sq[i,j] - s >= 0 (minimum distance constraint)\n        # c2: 1.0 - d_sq[i,j] >= 0 (diameter constraint)\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def jacobian(u):\n        # Analytical Jacobian for the SLSQP constraints\n        pts = u[:-1].reshape((n_points, dim))\n        idx_i, idx_j = np.triu_indices(n_points, 1)\n        n_pairs = len(idx_i)\n        diffs = pts[idx_i] - pts[idx_j]\n        \n        jac_c1 = np.zeros((n_pairs, n_vars))\n        jac_c2 = np.zeros((n_pairs, n_vars))\n        \n        row_idx = np.arange(n_pairs)\n        for d in range(dim):\n            # Derivative of squared distance d_ij^2 with respect to coordinates\n            val = 2.0 * diffs[:, d]\n            jac_c1[row_idx, dim * idx_i + d] = val\n            jac_c1[row_idx, dim * idx_j + d] = -val\n            jac_c2[row_idx, dim * idx_i + d] = -val\n            jac_c2[row_idx, dim * idx_j + d] = val\n            \n        # Derivative of (d_sq - s) with respect to s is -1\n        jac_c1[:, -1] = -1.0\n        # Derivative of (1 - d_sq) with respect to s is 0\n        return np.vstack([jac_c1, jac_c2])\n\n    class MyStep:\n        \"\"\"Custom perturbation function that projects points back to diameter 1.\"\"\"\n        def __init__(self, stepsize=0.04):\n            self.stepsize = stepsize\n        def __call__(self, u):\n            u_new = u.copy()\n            # Perturb point coordinates\n            u_new[:-1] += np.random.normal(0, self.stepsize, n_points * dim)\n            pts = u_new[:-1].reshape((n_points, dim))\n            # Center points to remove translation invariance\n            pts -= np.mean(pts, axis=0)\n            # Find current max pairwise distance and rescale to 1\n            dists = np.linalg.norm(pts[:, None, :] - pts[None, :, :], axis=-1)\n            max_d = np.max(dists)\n            if max_d > 0:\n                pts /= max_d\n                u_new[:-1] = pts.flatten()\n                # Update s based on the new configuration\n                dist_sq_scaled = (dists / max_d)**2\n                u_new[-1] = np.min(dist_sq_scaled[np.triu_indices(n_points, 1)])\n            return u_new\n\n    # Initialize starting point\n    u0 = get_initial_points()\n\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"jac\": objective_grad,\n        \"constraints\": {\"type\": \"ineq\", \"fun\": constraints, \"jac\": jacobian},\n        \"options\": {\"maxiter\": 200, \"ftol\": 1e-10}\n    }\n\n    # Global optimization using Basin-hopping\n    res = basinhopping(\n        objective, \n        u0, \n        minimizer_kwargs=minimizer_kwargs,\n        niter=30, \n        T=0.02,\n        take_step=MyStep(0.04)\n    )\n\n    # Return the coordinates of the 14 points\n    final_pts = res.x[:-1].reshape((n_points, dim))\n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 1.0000159135419195,
    "min_max_ratio": 0.2400508826467048,
    "min_distance": 0.48994987768912696,
    "max_distance": 1.0000000000018447,
    "eval_time": 0.4736950397491455,
    "error": null
  },
  "prompt": "Implement a Basin-hopping approach for 14 points in 3D that uses a custom 'step-take' function. The step-take function should project the points back onto the 'max_dist=1' manifold after each perturbation. Use SLSQP as the local minimizer with analytical Jacobians for the slack variable constraints. Aim for the 1.0000159135539168 score plateau.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximizes the minimum pairwise distance between 14 points in 3D space,\n    given a fixed diameter (max pairwise distance) of 1.\n    The goal is to maximize the squared ratio (min distance / max distance)^2.\n    Uses Basin-hopping with SLSQP and a custom step-take function.\n    \"\"\"\n    n_points = 14\n    dim = 3\n    n_vars = n_points * dim + 1  # 42 coordinates + 1 slack variable s\n\n    def get_initial_points():\n        # Initialize points randomly within a sphere of diameter 1\n        pts = np.random.normal(0, 1, (n_points, dim))\n        pts -= np.mean(pts, axis=0)\n        # Rescale so the initial diameter is exactly 1\n        dists = np.linalg.norm(pts[:, None, :] - pts[None, :, :], axis=-1)\n        max_d = np.max(dists)\n        if max_d > 0:\n            pts /= max_d\n        else:\n            # Fallback if points are all at the origin\n            pts = np.random.normal(0, 0.1, (n_points, dim))\n            max_d = np.max(np.linalg.norm(pts[:, None, :] - pts[None, :, :], axis=-1))\n            pts /= max_d\n            \n        # Initial slack variable s (minimum squared distance)\n        diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dist_sq = np.sum(diffs**2, axis=-1)\n        s = np.min(dist_sq[np.triu_indices(n_points, 1)])\n        return np.concatenate([pts.flatten(), [s]])\n\n    def objective(u):\n        # Slack variable s represents min_dist^2. Maximize s => Minimize -s.\n        return -u[-1]\n\n    def objective_grad(u):\n        # Analytical gradient of the objective function\n        grad = np.zeros(n_vars)\n        grad[-1] = -1.0\n        return grad\n\n    def constraints(u):\n        # Points are derived from the first 42 variables\n        pts = u[:-1].reshape((n_points, dim))\n        s = u[-1]\n        idx_i, idx_j = np.triu_indices(n_points, 1)\n        diffs = pts[idx_i] - pts[idx_j]\n        d_sq = np.sum(diffs**2, axis=1)\n        # c1: d_sq[i,j] - s >= 0 (minimum distance constraint)\n        # c2: 1.0 - d_sq[i,j] >= 0 (diameter constraint)\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def jacobian(u):\n        # Analytical Jacobian for the SLSQP constraints\n        pts = u[:-1].reshape((n_points, dim))\n        idx_i, idx_j = np.triu_indices(n_points, 1)\n        n_pairs = len(idx_i)\n        diffs = pts[idx_i] - pts[idx_j]\n        \n        jac_c1 = np.zeros((n_pairs, n_vars))\n        jac_c2 = np.zeros((n_pairs, n_vars))\n        \n        row_idx = np.arange(n_pairs)\n        for d in range(dim):\n            # Derivative of squared distance d_ij^2 with respect to coordinates\n            val = 2.0 * diffs[:, d]\n            jac_c1[row_idx, dim * idx_i + d] = val\n            jac_c1[row_idx, dim * idx_j + d] = -val\n            jac_c2[row_idx, dim * idx_i + d] = -val\n            jac_c2[row_idx, dim * idx_j + d] = val\n            \n        # Derivative of (d_sq - s) with respect to s is -1\n        jac_c1[:, -1] = -1.0\n        # Derivative of (1 - d_sq) with respect to s is 0\n        return np.vstack([jac_c1, jac_c2])\n\n    class MyStep:\n        \"\"\"Custom perturbation function that projects points back to diameter 1.\"\"\"\n        def __init__(self, stepsize=0.04):\n            self.stepsize = stepsize\n        def __call__(self, u):\n            u_new = u.copy()\n            # Perturb point coordinates\n            u_new[:-1] += np.random.normal(0, self.stepsize, n_points * dim)\n            pts = u_new[:-1].reshape((n_points, dim))\n            # Center points to remove translation invariance\n            pts -= np.mean(pts, axis=0)\n            # Find current max pairwise distance and rescale to 1\n            dists = np.linalg.norm(pts[:, None, :] - pts[None, :, :], axis=-1)\n            max_d = np.max(dists)\n            if max_d > 0:\n                pts /= max_d\n                u_new[:-1] = pts.flatten()\n                # Update s based on the new configuration\n                dist_sq_scaled = (dists / max_d)**2\n                u_new[-1] = np.min(dist_sq_scaled[np.triu_indices(n_points, 1)])\n            return u_new\n\n    # Initialize starting point\n    u0 = get_initial_points()\n\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"jac\": objective_grad,\n        \"constraints\": {\"type\": \"ineq\", \"fun\": constraints, \"jac\": jacobian},\n        \"options\": {\"maxiter\": 200, \"ftol\": 1e-10}\n    }\n\n    # Global optimization using Basin-hopping\n    res = basinhopping(\n        objective, \n        u0, \n        minimizer_kwargs=minimizer_kwargs,\n        niter=30, \n        T=0.02,\n        take_step=MyStep(0.04)\n    )\n\n    # Return the coordinates of the 14 points\n    final_pts = res.x[:-1].reshape((n_points, dim))\n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:44:47.866077",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 265,
        "candidates_token_count": 1556,
        "thoughts_token_count": 19493
      },
      "response_text_len": 4740
    }
  }
}