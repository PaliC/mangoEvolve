{
  "trial_id": "trial_17_1",
  "generation": 17,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Generates 14 points in 3D space to maximize the squared ratio (min_dist / max_dist)^2.\n    Starts with a Rhombic Dodecahedron (Oh symmetry) configuration, optimizes parameters 'a' and 'b',\n    and then refines the result using SLSQP optimization.\n    \"\"\"\n    N = 14\n    \n    # --- Step 1: Optimize Rhombic Dodecahedron parameters (a, b) ---\n    \n    def get_rd_points(a, b):\n        \"\"\"\n        Generate vertices of a Rhombic Dodecahedron.\n        6 points on Octahedron: (+-a, 0, 0) permutations\n        8 points on Cube: (+-b, +-b, +-b)\n        \"\"\"\n        # Octahedron vertices\n        oct_pts = np.zeros((6, 3))\n        oct_pts[0] = [a, 0, 0]\n        oct_pts[1] = [-a, 0, 0]\n        oct_pts[2] = [0, a, 0]\n        oct_pts[3] = [0, -a, 0]\n        oct_pts[4] = [0, 0, a]\n        oct_pts[5] = [0, 0, -a]\n        \n        # Cube vertices\n        cube_pts = np.zeros((8, 3))\n        idx = 0\n        for x in [-b, b]:\n            for y in [-b, b]:\n                for z in [-b, b]:\n                    cube_pts[idx] = [x, y, z]\n                    idx += 1\n                    \n        return np.vstack([oct_pts, cube_pts])\n\n    def neg_ratio_ab(params):\n        \"\"\"Objective for scalar optimization of a and b\"\"\"\n        a, b = params\n        # Prevent non-physical parameters\n        if a < 1e-6 or b < 1e-6: return 1e9\n        \n        pts = get_rd_points(a, b)\n        d = pdist(pts)\n        \n        if d.size == 0: return 1e9\n        dmin = np.min(d)\n        dmax = np.max(d)\n        \n        if dmax < 1e-9: return 1e9\n        # We want to maximize ratio, so minimize negative ratio\n        return -(dmin / dmax)**2\n\n    # Initial guess: Analytical optimum for cospherical RD is a = sqrt(3)*b\n    # a ~ 1.732, b = 1.0\n    res_ab = minimize(neg_ratio_ab, [1.732, 1.0], method='Nelder-Mead', tol=1e-5)\n    best_a, best_b = res_ab.x\n    \n    # --- Step 2: Full SLSQP Optimization ---\n    \n    # Generate seed points\n    pts_init = get_rd_points(best_a, best_b)\n    \n    # Normalize max distance to 1.0 for numerical stability\n    d_init = pdist(pts_init)\n    scale = np.max(d_init)\n    pts_init /= scale\n    \n    # Initial s (squared min distance)\n    s_init = np.min(pdist(pts_init))**2\n    \n    # Precompute indices for pairwise distances to speed up Jacobian\n    # Order matches pdist: (0,1), (0,2)...\n    idx_i = []\n    idx_j = []\n    for i in range(N):\n        for j in range(i+1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n    num_pairs = len(idx_i) # 91 for N=14\n    \n    # Indices for vectorized Jacobian assignment\n    # Rows for constraint c1 (d^2 >= s)\n    r_c1 = np.arange(num_pairs).repeat(3)\n    # Rows for constraint c2 (d^2 <= 1)\n    r_c2 = r_c1 + num_pairs\n    \n    # Column indices for P_i and P_j coordinates\n    c_i = (3 * idx_i[:, None] + np.arange(3)).flatten()\n    c_j = (3 * idx_j[:, None] + np.arange(3)).flatten()\n    \n    # Optimization variables: Z = [x0, y0, z0, ..., x13, y13, z13, s]\n    # Length = 14*3 + 1 = 43\n    \n    def objective(z):\n        # Maximize s (minimize -s)\n        return -z[-1]\n    \n    def jac_obj(z):\n        j = np.zeros(len(z))\n        j[-1] = -1.0\n        return j\n    \n    def constraints(z):\n        coords = z[:-1].reshape((N, 3))\n        s = z[-1]\n        \n        # Vectorized distance calculation\n        vecs = coords[idx_i] - coords[idx_j]\n        d2 = np.sum(vecs**2, axis=1)\n        \n        # Constraint 1: d_ij^2 >= s  =>  d_ij^2 - s >= 0\n        c1 = d2 - s\n        # Constraint 2: d_ij^2 <= 1  =>  1 - d_ij^2 >= 0\n        c2 = 1.0 - d2\n        \n        return np.concatenate([c1, c2])\n        \n    def jac_con(z):\n        coords = z[:-1].reshape((N, 3))\n        # No need for s in derivative of coords, but needed for shape\n        \n        vecs = coords[idx_i] - coords[idx_j]\n        diff = 2 * vecs # Derivative of (xi-xj)^2 is 2(xi-xj)\n        v_diff = diff.flatten()\n        \n        jac = np.zeros((2 * num_pairs, 3 * N + 1))\n        \n        # Fill Jacobian for c1: d^2 - s >= 0\n        # d(c1)/dPi = 2(Pi-Pj), d(c1)/dPj = -2(Pi-Pj), d(c1)/ds = -1\n        jac[r_c1, c_i] = v_diff\n        jac[r_c1, c_j] = -v_diff\n        jac[:num_pairs, -1] = -1.0\n        \n        # Fill Jacobian for c2: 1 - d^2 >= 0\n        # Gradients are negative of d^2 gradients, ds is 0\n        jac[r_c2, c_i] = -v_diff\n        jac[r_c2, c_j] = v_diff\n        \n        return jac\n\n    # Setup optimization\n    x0 = np.hstack([pts_init.flatten(), [s_init]])\n    \n    cons = {'type': 'ineq', 'fun': constraints, 'jac': jac_con}\n    options = {'maxiter': 1000, 'ftol': 1e-9, 'disp': False}\n    \n    # Run SLSQP\n    res = minimize(objective, x0, method='SLSQP', jac=jac_obj, constraints=cons, options=options)\n    \n    # Extract coordinates\n    final_pts = res.x[:-1].reshape((N, 3))\n    \n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.8803476413094811,
    "min_max_ratio": 0.21132486540518133,
    "min_distance": 0.4597008433809768,
    "max_distance": 1.0,
    "eval_time": 0.2887840270996094,
    "error": null
  },
  "prompt": "Using the Rhombic Dodecahedron (Oh symmetry) as a basis, optimize the 14 points. The Rhombic Dodecahedron consists of 6 points on an octahedron and 8 points on a cube. Start with coordinates like (+-a, 0, 0) and (+-b, +-b, +-b). First, optimize 'a' and 'b' to maximize the min-dist ratio. Then, use that result as a seed for a full 42-variable SLSQP optimization with analytical Jacobians. Reference trial: trial_8_0.",
  "response": "Here is the Python solution maximizing the Min-Max distance ratio for 14 points in 3D space, starting from a Rhombic Dodecahedron configuration.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Generates 14 points in 3D space to maximize the squared ratio (min_dist / max_dist)^2.\n    Starts with a Rhombic Dodecahedron (Oh symmetry) configuration, optimizes parameters 'a' and 'b',\n    and then refines the result using SLSQP optimization.\n    \"\"\"\n    N = 14\n    \n    # --- Step 1: Optimize Rhombic Dodecahedron parameters (a, b) ---\n    \n    def get_rd_points(a, b):\n        \"\"\"\n        Generate vertices of a Rhombic Dodecahedron.\n        6 points on Octahedron: (+-a, 0, 0) permutations\n        8 points on Cube: (+-b, +-b, +-b)\n        \"\"\"\n        # Octahedron vertices\n        oct_pts = np.zeros((6, 3))\n        oct_pts[0] = [a, 0, 0]\n        oct_pts[1] = [-a, 0, 0]\n        oct_pts[2] = [0, a, 0]\n        oct_pts[3] = [0, -a, 0]\n        oct_pts[4] = [0, 0, a]\n        oct_pts[5] = [0, 0, -a]\n        \n        # Cube vertices\n        cube_pts = np.zeros((8, 3))\n        idx = 0\n        for x in [-b, b]:\n            for y in [-b, b]:\n                for z in [-b, b]:\n                    cube_pts[idx] = [x, y, z]\n                    idx += 1\n                    \n        return np.vstack([oct_pts, cube_pts])\n\n    def neg_ratio_ab(params):\n        \"\"\"Objective for scalar optimization of a and b\"\"\"\n        a, b = params\n        # Prevent non-physical parameters\n        if a < 1e-6 or b < 1e-6: return 1e9\n        \n        pts = get_rd_points(a, b)\n        d = pdist(pts)\n        \n        if d.size == 0: return 1e9\n        dmin = np.min(d)\n        dmax = np.max(d)\n        \n        if dmax < 1e-9: return 1e9\n        # We want to maximize ratio, so minimize negative ratio\n        return -(dmin / dmax)**2\n\n    # Initial guess: Analytical optimum for cospherical RD is a = sqrt(3)*b\n    # a ~ 1.732, b = 1.0\n    res_ab = minimize(neg_ratio_ab, [1.732, 1.0], method='Nelder-Mead', tol=1e-5)\n    best_a, best_b = res_ab.x\n    \n    # --- Step 2: Full SLSQP Optimization ---\n    \n    # Generate seed points\n    pts_init = get_rd_points(best_a, best_b)\n    \n    # Normalize max distance to 1.0 for numerical stability\n    d_init = pdist(pts_init)\n    scale = np.max(d_init)\n    pts_init /= scale\n    \n    # Initial s (squared min distance)\n    s_init = np.min(pdist(pts_init))**2\n    \n    # Precompute indices for pairwise distances to speed up Jacobian\n    # Order matches pdist: (0,1), (0,2)...\n    idx_i = []\n    idx_j = []\n    for i in range(N):\n        for j in range(i+1, N):\n            idx_i.append(i)\n            idx_j.append(j)\n    idx_i = np.array(idx_i)\n    idx_j = np.array(idx_j)\n    num_pairs = len(idx_i) # 91 for N=14\n    \n    # Indices for vectorized Jacobian assignment\n    # Rows for constraint c1 (d^2 >= s)\n    r_c1 = np.arange(num_pairs).repeat(3)\n    # Rows for constraint c2 (d^2 <= 1)\n    r_c2 = r_c1 + num_pairs\n    \n    # Column indices for P_i and P_j coordinates\n    c_i = (3 * idx_i[:, None] + np.arange(3)).flatten()\n    c_j = (3 * idx_j[:, None] + np.arange(3)).flatten()\n    \n    # Optimization variables: Z = [x0, y0, z0, ..., x13, y13, z13, s]\n    # Length = 14*3 + 1 = 43\n    \n    def objective(z):\n        # Maximize s (minimize -s)\n        return -z[-1]\n    \n    def jac_obj(z):\n        j = np.zeros(len(z))\n        j[-1] = -1.0\n        return j\n    \n    def constraints(z):\n        coords = z[:-1].reshape((N, 3))\n        s = z[-1]\n        \n        # Vectorized distance calculation\n        vecs = coords[idx_i] - coords[idx_j]\n        d2 = np.sum(vecs**2, axis=1)\n        \n        # Constraint 1: d_ij^2 >= s  =>  d_ij^2 - s >= 0\n        c1 = d2 - s\n        # Constraint 2: d_ij^2 <= 1  =>  1 - d_ij^2 >= 0\n        c2 = 1.0 - d2\n        \n        return np.concatenate([c1, c2])\n        \n    def jac_con(z):\n        coords = z[:-1].reshape((N, 3))\n        # No need for s in derivative of coords, but needed for shape\n        \n        vecs = coords[idx_i] - coords[idx_j]\n        diff = 2 * vecs # Derivative of (xi-xj)^2 is 2(xi-xj)\n        v_diff = diff.flatten()\n        \n        jac = np.zeros((2 * num_pairs, 3 * N + 1))\n        \n        # Fill Jacobian for c1: d^2 - s >= 0\n        # d(c1)/dPi = 2(Pi-Pj), d(c1)/dPj = -2(Pi-Pj), d(c1)/ds = -1\n        jac[r_c1, c_i] = v_diff\n        jac[r_c1, c_j] = -v_diff\n        jac[:num_pairs, -1] = -1.0\n        \n        # Fill Jacobian for c2: 1 - d^2 >= 0\n        # Gradients are negative of d^2 gradients, ds is 0\n        jac[r_c2, c_i] = -v_diff\n        jac[r_c2, c_j] = v_diff\n        \n        return jac\n\n    # Setup optimization\n    x0 = np.hstack([pts_init.flatten(), [s_init]])\n    \n    cons = {'type': 'ineq', 'fun': constraints, 'jac': jac_con}\n    options = {'maxiter': 1000, 'ftol': 1e-9, 'disp': False}\n    \n    # Run SLSQP\n    res = minimize(objective, x0, method='SLSQP', jac=jac_obj, constraints=cons, options=options)\n    \n    # Extract coordinates\n    final_pts = res.x[:-1].reshape((N, 3))\n    \n    return final_pts\n```",
  "reasoning": "Here is the Python solution maximizing the Min-Max distance ratio for 14 points in 3D space, starting from a Rhombic Dodecahedron configuration.",
  "timestamp": "2026-01-21T18:45:23.974200",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 295,
        "candidates_token_count": 1892,
        "thoughts_token_count": 14930
      },
      "response_text_len": 5127
    }
  }
}