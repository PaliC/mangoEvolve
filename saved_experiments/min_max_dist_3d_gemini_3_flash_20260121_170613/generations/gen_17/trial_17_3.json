{
  "trial_id": "trial_17_3",
  "generation": 17,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize \n    the squared ratio (min pairwise distance / max pairwise distance)^2.\n    \"\"\"\n    N = 14\n    dim = 3\n\n    def get_ratio_sq(pts):\n        # Reshape to (N, 3) to calculate pairwise distances\n        pts = pts.reshape((N, dim))\n        dists_sq = pdist(pts)**2\n        if len(dists_sq) == 0:\n            return 0\n        mx = np.max(dists_sq)\n        if mx == 0:\n            return 0\n        return np.min(dists_sq) / mx\n\n    def objective(x):\n        # Minimize the negative ratio to maximize the ratio\n        return -get_ratio_sq(x)\n\n    def fibonacci_sphere(n):\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            radius = np.sqrt(1 - y * y)\n            theta = phi * i\n            x = np.cos(theta) * radius\n            z = np.sin(theta) * radius\n            pts.append([x, y, z])\n        return np.array(pts)\n\n    def prism_start():\n        # Bicapped hexagonal antiprism configuration\n        h = 0.4\n        r = np.sqrt(1 - h**2)\n        ring1 = [[r*np.cos(i*np.pi/3), r*np.sin(i*np.pi/3), h] for i in range(6)]\n        ring2 = [[r*np.cos(i*np.pi/3 + np.pi/6), r*np.sin(i*np.pi/3 + np.pi/6), -h] for i in range(6)]\n        return np.vstack([np.array(ring1), np.array(ring2), np.array([[0, 0, 1], [0, 0, -1]])])\n\n    def rhombic_start():\n        # Cube (8) + Face Centers (6)\n        cube = np.array([[i, j, k] for i in [-1, 1] for j in [-1, 1] for k in [-1, 1]])\n        face_centers = np.array([[1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]])\n        return np.vstack([cube, face_centers])\n\n    best_pts = None\n    best_ratio = -1\n\n    # Multi-start strategy using different initial configurations\n    starts = [\n        fibonacci_sphere(N),\n        prism_start(),\n        rhombic_start(),\n        fibonacci_sphere(N) + np.random.normal(0, 0.05, (N, dim)),\n        np.random.normal(0, 1, (N, dim)),\n        np.random.normal(0, 1, (N, dim))\n    ]\n\n    for start_pts in starts:\n        res = minimize(objective, start_pts.flatten(), method='SLSQP', \n                       options={'maxiter': 50, 'ftol': 1e-8})\n        \n        pts = res.x.reshape((N, dim))\n        ratio = get_ratio_sq(pts)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts\n\n    # Refine the best configuration using Coordinate Descent (Pattern Search)\n    curr_pts = best_pts.copy()\n    curr_ratio = best_ratio\n    \n    # Iterate through decreasing step sizes for refinement\n    for eps in [1e-3, 1e-4, 1e-5, 1e-6, 1e-7, 1e-8]:\n        for pass_idx in range(20):\n            improved_any_pass = False\n            # Randomize order of points to avoid directional bias\n            indices = np.arange(N)\n            np.random.shuffle(indices)\n            for i in indices:\n                for j in range(dim):\n                    old_val = curr_pts[i, j]\n                    \n                    # Try moving the coordinate in two directions\n                    curr_pts[i, j] = old_val + eps\n                    r_plus = get_ratio_sq(curr_pts)\n                    \n                    curr_pts[i, j] = old_val - eps\n                    r_minus = get_ratio_sq(curr_pts)\n                    \n                    # Keep the best move if it improves the ratio\n                    if r_plus > curr_ratio and r_plus >= r_minus:\n                        curr_ratio = r_plus\n                        curr_pts[i, j] = old_val + eps\n                        improved_any_pass = True\n                    elif r_minus > curr_ratio:\n                        curr_ratio = r_minus\n                        curr_pts[i, j] = old_val - eps\n                        improved_any_pass = True\n                    else:\n                        # Revert if no improvement\n                        curr_pts[i, j] = old_val\n            \n            # If no coordinate moves improved the ratio, move to the next epsilon\n            if not improved_any_pass:\n                break\n                \n    return curr_pts.reshape((N, dim))",
  "metrics": {
    "valid": true,
    "score": 0.9304090467734489,
    "min_max_ratio": 0.2233419587388229,
    "min_distance": 0.9330720248841672,
    "max_distance": 1.9743766600488686,
    "eval_time": 0.4805638790130615,
    "error": null
  },
  "prompt": "Take the best coordinates from trial_8_0 and perform a 'Coordinate Descent' or 'Pattern Search' refinement. Since SLSQP might be limited by gradient precision, try moving each coordinate by a tiny epsilon and keeping the move if the ratio improves. This might bypass numerical noise in the Jacobian calculation near the optimum.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize \n    the squared ratio (min pairwise distance / max pairwise distance)^2.\n    \"\"\"\n    N = 14\n    dim = 3\n\n    def get_ratio_sq(pts):\n        # Reshape to (N, 3) to calculate pairwise distances\n        pts = pts.reshape((N, dim))\n        dists_sq = pdist(pts)**2\n        if len(dists_sq) == 0:\n            return 0\n        mx = np.max(dists_sq)\n        if mx == 0:\n            return 0\n        return np.min(dists_sq) / mx\n\n    def objective(x):\n        # Minimize the negative ratio to maximize the ratio\n        return -get_ratio_sq(x)\n\n    def fibonacci_sphere(n):\n        pts = []\n        phi = np.pi * (3. - np.sqrt(5.))\n        for i in range(n):\n            y = 1 - (i / float(n - 1)) * 2\n            radius = np.sqrt(1 - y * y)\n            theta = phi * i\n            x = np.cos(theta) * radius\n            z = np.sin(theta) * radius\n            pts.append([x, y, z])\n        return np.array(pts)\n\n    def prism_start():\n        # Bicapped hexagonal antiprism configuration\n        h = 0.4\n        r = np.sqrt(1 - h**2)\n        ring1 = [[r*np.cos(i*np.pi/3), r*np.sin(i*np.pi/3), h] for i in range(6)]\n        ring2 = [[r*np.cos(i*np.pi/3 + np.pi/6), r*np.sin(i*np.pi/3 + np.pi/6), -h] for i in range(6)]\n        return np.vstack([np.array(ring1), np.array(ring2), np.array([[0, 0, 1], [0, 0, -1]])])\n\n    def rhombic_start():\n        # Cube (8) + Face Centers (6)\n        cube = np.array([[i, j, k] for i in [-1, 1] for j in [-1, 1] for k in [-1, 1]])\n        face_centers = np.array([[1.5, 0, 0], [-1.5, 0, 0], [0, 1.5, 0], [0, -1.5, 0], [0, 0, 1.5], [0, 0, -1.5]])\n        return np.vstack([cube, face_centers])\n\n    best_pts = None\n    best_ratio = -1\n\n    # Multi-start strategy using different initial configurations\n    starts = [\n        fibonacci_sphere(N),\n        prism_start(),\n        rhombic_start(),\n        fibonacci_sphere(N) + np.random.normal(0, 0.05, (N, dim)),\n        np.random.normal(0, 1, (N, dim)),\n        np.random.normal(0, 1, (N, dim))\n    ]\n\n    for start_pts in starts:\n        res = minimize(objective, start_pts.flatten(), method='SLSQP', \n                       options={'maxiter': 50, 'ftol': 1e-8})\n        \n        pts = res.x.reshape((N, dim))\n        ratio = get_ratio_sq(pts)\n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts\n\n    # Refine the best configuration using Coordinate Descent (Pattern Search)\n    curr_pts = best_pts.copy()\n    curr_ratio = best_ratio\n    \n    # Iterate through decreasing step sizes for refinement\n    for eps in [1e-3, 1e-4, 1e-5, 1e-6, 1e-7, 1e-8]:\n        for pass_idx in range(20):\n            improved_any_pass = False\n            # Randomize order of points to avoid directional bias\n            indices = np.arange(N)\n            np.random.shuffle(indices)\n            for i in indices:\n                for j in range(dim):\n                    old_val = curr_pts[i, j]\n                    \n                    # Try moving the coordinate in two directions\n                    curr_pts[i, j] = old_val + eps\n                    r_plus = get_ratio_sq(curr_pts)\n                    \n                    curr_pts[i, j] = old_val - eps\n                    r_minus = get_ratio_sq(curr_pts)\n                    \n                    # Keep the best move if it improves the ratio\n                    if r_plus > curr_ratio and r_plus >= r_minus:\n                        curr_ratio = r_plus\n                        curr_pts[i, j] = old_val + eps\n                        improved_any_pass = True\n                    elif r_minus > curr_ratio:\n                        curr_ratio = r_minus\n                        curr_pts[i, j] = old_val - eps\n                        improved_any_pass = True\n                    else:\n                        # Revert if no improvement\n                        curr_pts[i, j] = old_val\n            \n            # If no coordinate moves improved the ratio, move to the next epsilon\n            if not improved_any_pass:\n                break\n                \n    return curr_pts.reshape((N, dim))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:44:56.505342",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 236,
        "candidates_token_count": 1352,
        "thoughts_token_count": 20290
      },
      "response_text_len": 4252
    }
  }
}