{
  "trial_id": "trial_12_5",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The algorithm starts with a heptagonal antiprism-like configuration, refines it using \n    coordinate descent, and finishes with a global SLSQP polish.\n    \"\"\"\n    \n    # 1. Initialization: Heptagonal Antiprism structure\n    # This is a highly symmetric and competitive configuration for 14 points.\n    pts = []\n    h = 0.7  # Initial height offset for the two rings\n    for i in range(7):\n        # Ring 1 (Top)\n        pts.append([np.cos(2*np.pi*i/7), np.sin(2*np.pi*i/7), h])\n        # Ring 2 (Bottom), rotated by pi/7 to create an antiprism\n        pts.append([np.cos(2*np.pi*i/7 + np.pi/7), np.sin(2*np.pi*i/7 + np.pi/7), -h])\n    pts = np.array(pts)\n\n    def get_dmax_sq(p):\n        \"\"\"Computes the maximum squared pairwise distance in the set p.\"\"\"\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        return np.max(np.sum(diff**2, axis=-1))\n\n    def get_dmin_sq(p):\n        \"\"\"Computes the minimum squared pairwise distance in the set p.\"\"\"\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        # Use upper triangle to avoid zero diagonal and duplicate pairs\n        iu = np.triu_indices(len(p), k=1)\n        return np.min(np.sum(diff[iu]**2, axis=-1))\n\n    # 2. Coordinate Descent Refiner\n    # Pick one point at a time and move it in the direction that maximizes its \n    # distance to its nearest neighbor while ensuring the overall max_distance \n    # does not increase.\n    \n    current_pts = pts.copy()\n    for _ in range(15): # Up to 15 full passes of coordinate descent\n        changed = False\n        for i in range(14):\n            # Calculate current global max distance squared to use as a constraint\n            dmax_sq = get_dmax_sq(current_pts)\n            others = np.delete(current_pts, i, axis=0)\n            \n            # Local optimization for point i:\n            # Objective: Maximize distance to the nearest neighbor (s)\n            # Variables: [x, y, z, s]\n            def local_obj(v):\n                return -v[3]\n            \n            def local_cons(v):\n                p_i = v[:3]\n                s = v[3]\n                dist_sqs = np.sum((others - p_i)**2, axis=1)\n                # Ensure distance to all others is >= s (min distance)\n                # Ensure distance to all others is <= dmax_sq (max distance constraint)\n                c = np.empty(26)\n                c[:13] = dist_sqs - s\n                c[13:] = dmax_sq - dist_sqs\n                return c\n\n            p_i_start = current_pts[i]\n            s_start = np.min(np.sum((others - p_i_start)**2, axis=1))\n            \n            res = minimize(local_obj, np.append(p_i_start, s_start),\n                           constraints={'type': 'ineq', 'fun': local_cons},\n                           method='SLSQP', options={'maxiter': 20, 'disp': False})\n            \n            if res.success and res.x[3] > s_start + 1e-10:\n                current_pts[i] = res.x[:3]\n                changed = True\n        if not changed:\n            break\n\n    # 3. Global SLSQP Polish\n    # Maximize s (min_dist^2) subject to all pairwise distances <= 1.0 (max_dist^2)\n    def global_obj(v):\n        return -v[-1] # maximize s\n\n    def global_cons(v):\n        p = v[:-1].reshape((14, 3))\n        s = v[-1]\n        \n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        iu = np.triu_indices(14, k=1)\n        dists_sq = np.sum(diff[iu]**2, axis=-1)\n        \n        # All 91 pairs must satisfy: dist^2 >= s and dist^2 <= 1.0\n        c = np.empty(182)\n        c[:91] = dists_sq - s\n        c[91:] = 1.0 - dists_sq\n        return c\n\n    # Normalize current configuration so that the max distance is exactly 1.0\n    dmax = np.sqrt(get_dmax_sq(current_pts))\n    initial_pts = current_pts / dmax\n    s_start = get_dmin_sq(initial_pts)\n    \n    # Pack variables for scipy: 42 coordinates + 1 min_dist_squared\n    x0 = np.append(initial_pts.flatten(), s_start)\n    \n    # Polish with high precision\n    res = minimize(global_obj, x0, \n                   constraints={'type': 'ineq', 'fun': global_cons},\n                   method='SLSQP', tol=1e-15, options={'maxiter': 200, 'disp': False})\n    \n    if res.success:\n        final_pts = res.x[:-1].reshape((14, 3))\n    else:\n        final_pts = initial_pts\n\n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.947191125908676,
    "min_max_ratio": 0.2273704475403556,
    "min_distance": 0.47683377348962563,
    "max_distance": 1.0,
    "eval_time": 0.5230059623718262,
    "error": null
  },
  "prompt": "Implement a 'Coordinate Descent' refiner. Starting from the coordinates in trial_7_5, pick one point at a time and move it in the direction that maximizes its distance to its nearest neighbor while ensuring the overall max_distance does not increase. Perform this in a loop until convergence, then finish with a global SLSQP polish at 1e-15 tolerance.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The algorithm starts with a heptagonal antiprism-like configuration, refines it using \n    coordinate descent, and finishes with a global SLSQP polish.\n    \"\"\"\n    \n    # 1. Initialization: Heptagonal Antiprism structure\n    # This is a highly symmetric and competitive configuration for 14 points.\n    pts = []\n    h = 0.7  # Initial height offset for the two rings\n    for i in range(7):\n        # Ring 1 (Top)\n        pts.append([np.cos(2*np.pi*i/7), np.sin(2*np.pi*i/7), h])\n        # Ring 2 (Bottom), rotated by pi/7 to create an antiprism\n        pts.append([np.cos(2*np.pi*i/7 + np.pi/7), np.sin(2*np.pi*i/7 + np.pi/7), -h])\n    pts = np.array(pts)\n\n    def get_dmax_sq(p):\n        \"\"\"Computes the maximum squared pairwise distance in the set p.\"\"\"\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        return np.max(np.sum(diff**2, axis=-1))\n\n    def get_dmin_sq(p):\n        \"\"\"Computes the minimum squared pairwise distance in the set p.\"\"\"\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        # Use upper triangle to avoid zero diagonal and duplicate pairs\n        iu = np.triu_indices(len(p), k=1)\n        return np.min(np.sum(diff[iu]**2, axis=-1))\n\n    # 2. Coordinate Descent Refiner\n    # Pick one point at a time and move it in the direction that maximizes its \n    # distance to its nearest neighbor while ensuring the overall max_distance \n    # does not increase.\n    \n    current_pts = pts.copy()\n    for _ in range(15): # Up to 15 full passes of coordinate descent\n        changed = False\n        for i in range(14):\n            # Calculate current global max distance squared to use as a constraint\n            dmax_sq = get_dmax_sq(current_pts)\n            others = np.delete(current_pts, i, axis=0)\n            \n            # Local optimization for point i:\n            # Objective: Maximize distance to the nearest neighbor (s)\n            # Variables: [x, y, z, s]\n            def local_obj(v):\n                return -v[3]\n            \n            def local_cons(v):\n                p_i = v[:3]\n                s = v[3]\n                dist_sqs = np.sum((others - p_i)**2, axis=1)\n                # Ensure distance to all others is >= s (min distance)\n                # Ensure distance to all others is <= dmax_sq (max distance constraint)\n                c = np.empty(26)\n                c[:13] = dist_sqs - s\n                c[13:] = dmax_sq - dist_sqs\n                return c\n\n            p_i_start = current_pts[i]\n            s_start = np.min(np.sum((others - p_i_start)**2, axis=1))\n            \n            res = minimize(local_obj, np.append(p_i_start, s_start),\n                           constraints={'type': 'ineq', 'fun': local_cons},\n                           method='SLSQP', options={'maxiter': 20, 'disp': False})\n            \n            if res.success and res.x[3] > s_start + 1e-10:\n                current_pts[i] = res.x[:3]\n                changed = True\n        if not changed:\n            break\n\n    # 3. Global SLSQP Polish\n    # Maximize s (min_dist^2) subject to all pairwise distances <= 1.0 (max_dist^2)\n    def global_obj(v):\n        return -v[-1] # maximize s\n\n    def global_cons(v):\n        p = v[:-1].reshape((14, 3))\n        s = v[-1]\n        \n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        iu = np.triu_indices(14, k=1)\n        dists_sq = np.sum(diff[iu]**2, axis=-1)\n        \n        # All 91 pairs must satisfy: dist^2 >= s and dist^2 <= 1.0\n        c = np.empty(182)\n        c[:91] = dists_sq - s\n        c[91:] = 1.0 - dists_sq\n        return c\n\n    # Normalize current configuration so that the max distance is exactly 1.0\n    dmax = np.sqrt(get_dmax_sq(current_pts))\n    initial_pts = current_pts / dmax\n    s_start = get_dmin_sq(initial_pts)\n    \n    # Pack variables for scipy: 42 coordinates + 1 min_dist_squared\n    x0 = np.append(initial_pts.flatten(), s_start)\n    \n    # Polish with high precision\n    res = minimize(global_obj, x0, \n                   constraints={'type': 'ineq', 'fun': global_cons},\n                   method='SLSQP', tol=1e-15, options={'maxiter': 200, 'disp': False})\n    \n    if res.success:\n        final_pts = res.x[:-1].reshape((14, 3))\n    else:\n        final_pts = initial_pts\n\n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:12:32.501624",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 248,
        "candidates_token_count": 1418,
        "thoughts_token_count": 15807
      },
      "response_text_len": 4468
    }
  }
}