{
  "trial_id": "trial_12_10",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximizes the squared ratio (min pairwise distance / max pairwise distance)^2\n    for 14 points in 3D space using a basin-hopping approach with SLSQP optimization.\n    \"\"\"\n    start_time = time.time()\n    N = 14\n    dim = 3\n    num_pairs = N * (N - 1) // 2\n    \n    # Use the requested seed (interpreted as 75)\n    rng = np.random.RandomState(75)\n    \n    def get_dists_sq(pts):\n        \"\"\"Calculates all pairwise squared distances for the given points.\"\"\"\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        return np.sum((pts[idx_i] - pts[idx_j])**2, axis=-1)\n\n    def objective(x):\n        \"\"\"Minimize -s to maximize the minimum squared distance s.\"\"\"\n        return -x[-1]\n\n    def jac_objective(x):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros(N * dim + 1)\n        grad[-1] = -1\n        return grad\n\n    def constraints_fn(x):\n        \"\"\"\n        Constraints:\n        1. All pairwise distances squared must be at least s (slack variable).\n        2. All pairwise distances squared must be at most 1.0 (normalization).\n        \"\"\"\n        pts = x[:-1].reshape((N, dim))\n        s = x[-1]\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        # Vectorized pairwise distance calculation\n        d_sq = np.sum((pts[idx_i] - pts[idx_j])**2, axis=-1)\n        \n        # We need to return an array where each element >= 0\n        res = np.empty(2 * num_pairs)\n        res[:num_pairs] = d_sq - s\n        res[num_pairs:] = 1.0 - d_sq\n        return res\n\n    def jac_constraints_fn(x):\n        \"\"\"Jacobian of the constraints function.\"\"\"\n        pts = x[:-1].reshape((N, dim))\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        diffs = 2 * (pts[idx_i] - pts[idx_j])\n        \n        jac = np.zeros((2 * num_pairs, N * dim + 1))\n        rows = np.arange(num_pairs)\n        \n        # Fill derivatives for each dimension (x, y, z)\n        for d in range(dim):\n            # For d_ij^2 - s >= 0\n            jac[rows, idx_i * dim + d] = diffs[:, d]\n            jac[rows, idx_j * dim + d] = -diffs[:, d]\n            # For 1.0 - d_ij^2 >= 0\n            jac[rows + num_pairs, idx_i * dim + d] = -diffs[:, d]\n            jac[rows + num_pairs, idx_j * dim + d] = diffs[:, d]\n        \n        # Derivative with respect to the slack variable s\n        jac[:num_pairs, -1] = -1\n        return jac\n\n    # Initialize with a random configuration on a sphere\n    best_pts = rng.normal(0, 1, (N, dim))\n    d_sq_init = get_dists_sq(best_pts)\n    best_pts /= np.sqrt(np.max(d_sq_init))\n    best_ratio_sq = np.min(d_sq_init) / np.max(d_sq_init)\n    \n    pts = best_pts.copy()\n    \n    # Basin-hopping loop for high-intensity exploration within the 60s limit\n    while time.time() - start_time < 57:\n        # Pre-normalize current points to satisfy d_max <= 1 and initialize s\n        d_sq = get_dists_sq(pts)\n        d_max = np.sqrt(np.max(d_sq))\n        pts /= d_max\n        s_start = np.min(get_dists_sq(pts))\n        \n        # Flatten points and append the slack variable s\n        x0 = np.concatenate([pts.flatten(), [s_start]])\n        \n        # Local optimization using SLSQP with the provided Jacobian\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints_fn, 'jac': jac_constraints_fn},\n            tol=1e-12,\n            options={'maxiter': 200}\n        )\n        \n        # Extract optimized points and update best solution if improved\n        if res.success or res.status == 0:\n            pts_opt = res.x[:-1].reshape((N, dim))\n            d_sq_opt = get_dists_sq(pts_opt)\n            ratio_sq = np.min(d_sq_opt) / np.max(d_sq_opt)\n            \n            if ratio_sq > best_ratio_sq:\n                best_ratio_sq = ratio_sq\n                best_pts = pts_opt.copy()\n        \n        # Perturbation step: mix of large jumps and tiny Gaussian perturbations\n        r = rng.rand()\n        if r < 0.15:\n            # Large jump: new random configuration\n            pts = rng.normal(0, 1, (N, dim))\n        elif r < 0.4:\n            # Medium perturbation\n            pts = best_pts + rng.normal(0, 0.1, (N, dim))\n        else:\n            # Tiny Gaussian perturbation\n            pts = best_pts + rng.normal(0, 0.01, (N, dim))\n        \n        # Center points to prevent drifting\n        pts -= np.mean(pts, axis=0)\n                \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539168,
    "min_max_ratio": 0.2400508826495847,
    "min_distance": 0.4899498776911621,
    "max_distance": 1.0,
    "eval_time": 57.38224792480469,
    "error": null
  },
  "prompt": "Perform a high-intensity Basin-hopping search for 14 points. Use the slack variable formulation. For the 'step' function, use a mix of large jumps and tiny Gaussian perturbations. Optimize each step with SLSQP and a tolerance of 1e-12. Ensure the code runs for nearly the full 60 seconds to maximize exploration. Seed with trial_7_5.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximizes the squared ratio (min pairwise distance / max pairwise distance)^2\n    for 14 points in 3D space using a basin-hopping approach with SLSQP optimization.\n    \"\"\"\n    start_time = time.time()\n    N = 14\n    dim = 3\n    num_pairs = N * (N - 1) // 2\n    \n    # Use the requested seed (interpreted as 75)\n    rng = np.random.RandomState(75)\n    \n    def get_dists_sq(pts):\n        \"\"\"Calculates all pairwise squared distances for the given points.\"\"\"\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        return np.sum((pts[idx_i] - pts[idx_j])**2, axis=-1)\n\n    def objective(x):\n        \"\"\"Minimize -s to maximize the minimum squared distance s.\"\"\"\n        return -x[-1]\n\n    def jac_objective(x):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros(N * dim + 1)\n        grad[-1] = -1\n        return grad\n\n    def constraints_fn(x):\n        \"\"\"\n        Constraints:\n        1. All pairwise distances squared must be at least s (slack variable).\n        2. All pairwise distances squared must be at most 1.0 (normalization).\n        \"\"\"\n        pts = x[:-1].reshape((N, dim))\n        s = x[-1]\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        # Vectorized pairwise distance calculation\n        d_sq = np.sum((pts[idx_i] - pts[idx_j])**2, axis=-1)\n        \n        # We need to return an array where each element >= 0\n        res = np.empty(2 * num_pairs)\n        res[:num_pairs] = d_sq - s\n        res[num_pairs:] = 1.0 - d_sq\n        return res\n\n    def jac_constraints_fn(x):\n        \"\"\"Jacobian of the constraints function.\"\"\"\n        pts = x[:-1].reshape((N, dim))\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        diffs = 2 * (pts[idx_i] - pts[idx_j])\n        \n        jac = np.zeros((2 * num_pairs, N * dim + 1))\n        rows = np.arange(num_pairs)\n        \n        # Fill derivatives for each dimension (x, y, z)\n        for d in range(dim):\n            # For d_ij^2 - s >= 0\n            jac[rows, idx_i * dim + d] = diffs[:, d]\n            jac[rows, idx_j * dim + d] = -diffs[:, d]\n            # For 1.0 - d_ij^2 >= 0\n            jac[rows + num_pairs, idx_i * dim + d] = -diffs[:, d]\n            jac[rows + num_pairs, idx_j * dim + d] = diffs[:, d]\n        \n        # Derivative with respect to the slack variable s\n        jac[:num_pairs, -1] = -1\n        return jac\n\n    # Initialize with a random configuration on a sphere\n    best_pts = rng.normal(0, 1, (N, dim))\n    d_sq_init = get_dists_sq(best_pts)\n    best_pts /= np.sqrt(np.max(d_sq_init))\n    best_ratio_sq = np.min(d_sq_init) / np.max(d_sq_init)\n    \n    pts = best_pts.copy()\n    \n    # Basin-hopping loop for high-intensity exploration within the 60s limit\n    while time.time() - start_time < 57:\n        # Pre-normalize current points to satisfy d_max <= 1 and initialize s\n        d_sq = get_dists_sq(pts)\n        d_max = np.sqrt(np.max(d_sq))\n        pts /= d_max\n        s_start = np.min(get_dists_sq(pts))\n        \n        # Flatten points and append the slack variable s\n        x0 = np.concatenate([pts.flatten(), [s_start]])\n        \n        # Local optimization using SLSQP with the provided Jacobian\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints_fn, 'jac': jac_constraints_fn},\n            tol=1e-12,\n            options={'maxiter': 200}\n        )\n        \n        # Extract optimized points and update best solution if improved\n        if res.success or res.status == 0:\n            pts_opt = res.x[:-1].reshape((N, dim))\n            d_sq_opt = get_dists_sq(pts_opt)\n            ratio_sq = np.min(d_sq_opt) / np.max(d_sq_opt)\n            \n            if ratio_sq > best_ratio_sq:\n                best_ratio_sq = ratio_sq\n                best_pts = pts_opt.copy()\n        \n        # Perturbation step: mix of large jumps and tiny Gaussian perturbations\n        r = rng.rand()\n        if r < 0.15:\n            # Large jump: new random configuration\n            pts = rng.normal(0, 1, (N, dim))\n        elif r < 0.4:\n            # Medium perturbation\n            pts = best_pts + rng.normal(0, 0.1, (N, dim))\n        else:\n            # Tiny Gaussian perturbation\n            pts = best_pts + rng.normal(0, 0.01, (N, dim))\n        \n        # Center points to prevent drifting\n        pts -= np.mean(pts, axis=0)\n                \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:14:06.306475",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 252,
        "candidates_token_count": 1451,
        "thoughts_token_count": 21838
      },
      "response_text_len": 4529
    }
  }
}