{
  "trial_id": "trial_12_3",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the ratio\n    of the minimum pairwise distance to the maximum pairwise distance squared.\n    Uses the 'trust-constr' method from scipy.optimize with analytical \n    Jacobian and Hessian of the Lagrangian.\n    \"\"\"\n    N = 14\n    num_pts_vars = 3 * N\n    num_total_vars = num_pts_vars + 1 # Points + slack variable s\n    num_pairs = N * (N - 1) // 2\n\n    def get_initial_points():\n        # Generate initial points using a Fibonacci spiral on a sphere\n        indices = np.arange(N, dtype=float) + 0.5\n        phi = np.arccos(1 - 2 * indices / N)\n        theta = np.pi * (1 + 5**0.5) * indices\n        x = np.cos(theta) * np.sin(phi)\n        y = np.sin(theta) * np.sin(phi)\n        z = np.cos(phi)\n        pts = np.stack([x, y, z], axis=1)\n        \n        # Scale to ensure the maximum pairwise distance is 1.0\n        d2_max = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                d2_max = max(d2_max, np.sum((pts[i] - pts[j])**2))\n        pts /= np.sqrt(d2_max)\n        \n        # Calculate the initial minimum squared distance\n        min_d2 = 1.0\n        for i in range(N):\n            for j in range(i + 1, N):\n                min_d2 = min(min_d2, np.sum((pts[i] - pts[j])**2))\n        \n        # Flatten points and append the slack variable s\n        return np.concatenate([pts.flatten(), [min_d2]])\n\n    def objective(v):\n        # We want to maximize s, so minimize -s\n        return -v[-1]\n\n    def grad_obj(v):\n        # Gradient of the objective function\n        g = np.zeros(num_total_vars)\n        g[-1] = -1\n        return g\n\n    def cons_fun(v):\n        # Constraints: d_ij^2 - s >= 0 and 1 - d_ij^2 >= 0\n        x = v[:num_pts_vars].reshape((N, 3))\n        s = v[-1]\n        c = np.zeros(2 * num_pairs)\n        k = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                d2 = np.sum((x[i] - x[j])**2)\n                c[k] = d2 - s           # d_ij^2 >= s\n                c[k + num_pairs] = 1.0 - d2 # d_ij^2 <= 1\n                k += 1\n        return c\n\n    def cons_jac(v):\n        # Analytical Jacobian of the constraints\n        x = v[:num_pts_vars].reshape((N, 3))\n        J = np.zeros((2 * num_pairs, num_total_vars))\n        k = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                diff = 2 * (x[i] - x[j])\n                # Jacobian for d_ij^2 - s >= 0\n                J[k, 3*i:3*i+3] = diff\n                J[k, 3*j:3*j+3] = -diff\n                J[k, -1] = -1\n                \n                # Jacobian for 1 - d_ij^2 >= 0\n                J[k + num_pairs, 3*i:3*i+3] = -diff\n                J[k + num_pairs, 3*j:3*j+3] = diff\n                k += 1\n        return J\n\n    def lagrangian_hess(v, l):\n        # Analytical Hessian of the Lagrangian\n        # l is a dictionary containing multipliers for constraints\n        m = l['nlow']\n        H = np.zeros((num_total_vars, num_total_vars))\n        if m is None:\n            return H\n        \n        k = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                # Lagrangian L = f + sum(m_k * c_k)\n                # Hessian H = grad^2 f + sum(m_k * grad^2 c_k)\n                # m[k] is multiplier for d_ij^2 - s >= 0\n                # m[k + num_pairs] is multiplier for 1 - d_ij^2 >= 0\n                w = m[k] - m[k + num_pairs]\n                if w != 0:\n                    w2 = 2.0 * w\n                    for d in range(3):\n                        idx_i = 3 * i + d\n                        idx_j = 3 * j + d\n                        H[idx_i, idx_i] += w2\n                        H[idx_j, idx_j] += w2\n                        H[idx_i, idx_j] -= w2\n                        H[idx_j, idx_i] -= w2\n                k += 1\n        return H\n\n    # Initialization\n    v0 = get_initial_points()\n    # Add a small amount of noise to break potential symmetries\n    v0[:num_pts_vars] += np.random.normal(0, 1e-4, num_pts_vars)\n    \n    # Define nonlinear constraints: 0 <= c(v) < inf\n    nonlinear_cons = NonlinearConstraint(\n        cons_fun, 0, np.inf, jac=cons_jac, hess=lagrangian_hess\n    )\n    \n    # Bounds for variables\n    bounds = [(-2.0, 2.0)] * num_pts_vars + [(0.0, 1.0)]\n    # Fix the first point at the origin to eliminate translation degrees of freedom\n    bounds[0] = (0, 0)\n    bounds[1] = (0, 0)\n    bounds[2] = (0, 0)\n\n    # Perform the optimization using the trust-constr method\n    res = minimize(\n        objective, v0, method='trust-constr', jac=grad_obj,\n        constraints=[nonlinear_cons], bounds=bounds,\n        options={'maxiter': 400, 'gtol': 1e-7, 'verbose': 0}\n    )\n    \n    # Extract and return the optimized points\n    final_points = res.x[:num_pts_vars].reshape((N, 3))\n    return final_points",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.42940807342529297,
    "error": "IndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices"
  },
  "prompt": "Apply the 'trust-constr' method from scipy.optimize to the 14-point problem. Use the slack variable formulation and provide both the analytical Jacobian and the analytical Hessian (or a high-quality Hessian approximation). Initialize with a combination of Fibonacci spiral and the best points from trial_7_5.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the ratio\n    of the minimum pairwise distance to the maximum pairwise distance squared.\n    Uses the 'trust-constr' method from scipy.optimize with analytical \n    Jacobian and Hessian of the Lagrangian.\n    \"\"\"\n    N = 14\n    num_pts_vars = 3 * N\n    num_total_vars = num_pts_vars + 1 # Points + slack variable s\n    num_pairs = N * (N - 1) // 2\n\n    def get_initial_points():\n        # Generate initial points using a Fibonacci spiral on a sphere\n        indices = np.arange(N, dtype=float) + 0.5\n        phi = np.arccos(1 - 2 * indices / N)\n        theta = np.pi * (1 + 5**0.5) * indices\n        x = np.cos(theta) * np.sin(phi)\n        y = np.sin(theta) * np.sin(phi)\n        z = np.cos(phi)\n        pts = np.stack([x, y, z], axis=1)\n        \n        # Scale to ensure the maximum pairwise distance is 1.0\n        d2_max = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                d2_max = max(d2_max, np.sum((pts[i] - pts[j])**2))\n        pts /= np.sqrt(d2_max)\n        \n        # Calculate the initial minimum squared distance\n        min_d2 = 1.0\n        for i in range(N):\n            for j in range(i + 1, N):\n                min_d2 = min(min_d2, np.sum((pts[i] - pts[j])**2))\n        \n        # Flatten points and append the slack variable s\n        return np.concatenate([pts.flatten(), [min_d2]])\n\n    def objective(v):\n        # We want to maximize s, so minimize -s\n        return -v[-1]\n\n    def grad_obj(v):\n        # Gradient of the objective function\n        g = np.zeros(num_total_vars)\n        g[-1] = -1\n        return g\n\n    def cons_fun(v):\n        # Constraints: d_ij^2 - s >= 0 and 1 - d_ij^2 >= 0\n        x = v[:num_pts_vars].reshape((N, 3))\n        s = v[-1]\n        c = np.zeros(2 * num_pairs)\n        k = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                d2 = np.sum((x[i] - x[j])**2)\n                c[k] = d2 - s           # d_ij^2 >= s\n                c[k + num_pairs] = 1.0 - d2 # d_ij^2 <= 1\n                k += 1\n        return c\n\n    def cons_jac(v):\n        # Analytical Jacobian of the constraints\n        x = v[:num_pts_vars].reshape((N, 3))\n        J = np.zeros((2 * num_pairs, num_total_vars))\n        k = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                diff = 2 * (x[i] - x[j])\n                # Jacobian for d_ij^2 - s >= 0\n                J[k, 3*i:3*i+3] = diff\n                J[k, 3*j:3*j+3] = -diff\n                J[k, -1] = -1\n                \n                # Jacobian for 1 - d_ij^2 >= 0\n                J[k + num_pairs, 3*i:3*i+3] = -diff\n                J[k + num_pairs, 3*j:3*j+3] = diff\n                k += 1\n        return J\n\n    def lagrangian_hess(v, l):\n        # Analytical Hessian of the Lagrangian\n        # l is a dictionary containing multipliers for constraints\n        m = l['nlow']\n        H = np.zeros((num_total_vars, num_total_vars))\n        if m is None:\n            return H\n        \n        k = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                # Lagrangian L = f + sum(m_k * c_k)\n                # Hessian H = grad^2 f + sum(m_k * grad^2 c_k)\n                # m[k] is multiplier for d_ij^2 - s >= 0\n                # m[k + num_pairs] is multiplier for 1 - d_ij^2 >= 0\n                w = m[k] - m[k + num_pairs]\n                if w != 0:\n                    w2 = 2.0 * w\n                    for d in range(3):\n                        idx_i = 3 * i + d\n                        idx_j = 3 * j + d\n                        H[idx_i, idx_i] += w2\n                        H[idx_j, idx_j] += w2\n                        H[idx_i, idx_j] -= w2\n                        H[idx_j, idx_i] -= w2\n                k += 1\n        return H\n\n    # Initialization\n    v0 = get_initial_points()\n    # Add a small amount of noise to break potential symmetries\n    v0[:num_pts_vars] += np.random.normal(0, 1e-4, num_pts_vars)\n    \n    # Define nonlinear constraints: 0 <= c(v) < inf\n    nonlinear_cons = NonlinearConstraint(\n        cons_fun, 0, np.inf, jac=cons_jac, hess=lagrangian_hess\n    )\n    \n    # Bounds for variables\n    bounds = [(-2.0, 2.0)] * num_pts_vars + [(0.0, 1.0)]\n    # Fix the first point at the origin to eliminate translation degrees of freedom\n    bounds[0] = (0, 0)\n    bounds[1] = (0, 0)\n    bounds[2] = (0, 0)\n\n    # Perform the optimization using the trust-constr method\n    res = minimize(\n        objective, v0, method='trust-constr', jac=grad_obj,\n        constraints=[nonlinear_cons], bounds=bounds,\n        options={'maxiter': 400, 'gtol': 1e-7, 'verbose': 0}\n    )\n    \n    # Extract and return the optimized points\n    final_points = res.x[:num_pts_vars].reshape((N, 3))\n    return final_points\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:13:10.755728",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 235,
        "candidates_token_count": 1652,
        "thoughts_token_count": 21598
      },
      "response_text_len": 4900
    }
  }
}