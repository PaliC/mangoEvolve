{
  "trial_id": "trial_12_8",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport random\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance)^2.\n    Uses basin-hopping with SLSQP and a slack variable formulation.\n    \"\"\"\n    start_time = time.time()\n    \n    # Literal interpretation of the suggested seed \"trial_7_5\"\n    random.seed(7)\n    np.random.seed(5)\n    \n    N = 14\n\n    def get_dists_sq(pts):\n        \"\"\"\n        Calculate all pairwise squared distances for N points.\n        \"\"\"\n        # Efficiently calculate all pairwise squared distances (N, 3) -> (N, N)\n        dist_matrix_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=2)\n        # We only need the upper triangle (n*(n-1)/2 pairs)\n        idx = np.triu_indices(N, k=1)\n        return dist_matrix_sq[idx]\n\n    def objective(x):\n        \"\"\"\n        Maximize the slack variable s, which represents the minimum squared distance.\n        \"\"\"\n        return -x[-1]\n\n    def constraints(x, N_pts):\n        \"\"\"\n        Constraints:\n        1. All pairwise squared distances must be at least s (slack variable).\n        2. All pairwise squared distances must be at most 1 (normalizing max distance).\n        \"\"\"\n        pts = x[:-1].reshape((N_pts, 3))\n        s = x[-1]\n        d2 = get_dists_sq(pts)\n        # d2 - s >= 0  AND  1.0 - d2 >= 0\n        return np.concatenate([d2 - s, 1.0 - d2])\n\n    def initial_pts():\n        \"\"\"\n        Generates an initial configuration of points on a sphere of diameter 1.\n        \"\"\"\n        pts = []\n        for i in range(N):\n            phi = np.arccos(-1 + 2 * i / (N - 1))\n            theta = np.sqrt(N * np.pi) * phi\n            # Sphere radius 0.5 ensures diameter is at most 1\n            pts.append([0.5 * np.cos(theta) * np.sin(phi), \n                        0.5 * np.sin(theta) * np.sin(phi), \n                        0.5 * np.cos(phi)])\n        return np.array(pts) + np.random.normal(0, 0.05, (N, 3))\n\n    # Initialize search\n    best_pts = initial_pts()\n    d2 = get_dists_sq(best_pts)\n    max_d2 = np.max(d2)\n    best_pts /= np.sqrt(max_d2)\n    best_score = np.min(d2) / max_d2\n    current_pts = best_pts.copy()\n\n    # Basin-hopping loop for nearly 60 seconds\n    while time.time() - start_time < 56:\n        # Step: Mixed perturbations\n        r = random.random()\n        if r < 0.1:\n            # Global jump: Reset to a new random configuration\n            pts_perturbed = initial_pts()\n        elif r < 0.35:\n            # Large perturbation: Explore broader local region\n            pts_perturbed = current_pts + np.random.normal(0, 0.15, current_pts.shape)\n        else:\n            # Tiny perturbation: Fine-tune current local minimum\n            pts_perturbed = current_pts + np.random.normal(0, 0.015, current_pts.shape)\n        \n        # Pre-normalize to satisfy d_max <= 1 before starting local optimization\n        d2_p = get_dists_sq(pts_perturbed)\n        max_d2_p = np.max(d2_p)\n        if max_d2_p > 1e-9:\n            pts_perturbed /= np.sqrt(max_d2_p)\n            s_p = np.min(d2_p) / max_d2_p\n        else:\n            # Fallback if points collapsed\n            pts_perturbed = initial_pts()\n            d2_p = get_dists_sq(pts_perturbed)\n            max_d2_p = np.max(d2_p)\n            pts_perturbed /= np.sqrt(max_d2_p)\n            s_p = np.min(d2_p) / max_d2_p\n        \n        # Prepare variables for SLSQP (42 coordinates + 1 slack variable)\n        x0 = np.zeros(N * 3 + 1)\n        x0[:N*3] = pts_perturbed.flatten()\n        x0[-1] = s_p\n        \n        # Local optimization with SLSQP\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            constraints={'type': 'ineq', 'fun': constraints, 'args': (N,)},\n            options={'maxiter': 120, 'ftol': 1e-12}\n        )\n        \n        # Extract results if optimization was somewhat successful\n        if res.success or res.status == 8: # 8 is iteration limit reached\n            new_pts = res.x[:-1].reshape((N, 3))\n            new_d2 = get_dists_sq(new_pts)\n            new_max_d2 = np.max(new_d2)\n            \n            if new_max_d2 > 1e-9:\n                # Calculate ratio (min_dist/max_dist)^2\n                new_score = np.min(new_d2) / new_max_d2\n                \n                # Acceptance criteria\n                if new_score > best_score:\n                    best_score = new_score\n                    best_pts = new_pts / np.sqrt(new_max_d2)\n                    current_pts = best_pts.copy()\n                elif random.random() < 0.15: # Probabilistic acceptance to escape minima\n                    current_pts = new_pts / np.sqrt(new_max_d2)\n\n    # Final cleanup: ensure max distance is exactly 1\n    final_d2 = get_dists_sq(best_pts)\n    best_pts /= np.sqrt(np.max(final_d2))\n    \n    return best_pts.reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539162,
    "min_max_ratio": 0.24005088264958455,
    "min_distance": 0.48994987769116194,
    "max_distance": 1.0,
    "eval_time": 56.36735272407532,
    "error": null
  },
  "prompt": "Perform a high-intensity Basin-hopping search for 14 points. Use the slack variable formulation. For the 'step' function, use a mix of large jumps and tiny Gaussian perturbations. Optimize each step with SLSQP and a tolerance of 1e-12. Ensure the code runs for nearly the full 60 seconds to maximize exploration. Seed with trial_7_5.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport random\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance)^2.\n    Uses basin-hopping with SLSQP and a slack variable formulation.\n    \"\"\"\n    start_time = time.time()\n    \n    # Literal interpretation of the suggested seed \"trial_7_5\"\n    random.seed(7)\n    np.random.seed(5)\n    \n    N = 14\n\n    def get_dists_sq(pts):\n        \"\"\"\n        Calculate all pairwise squared distances for N points.\n        \"\"\"\n        # Efficiently calculate all pairwise squared distances (N, 3) -> (N, N)\n        dist_matrix_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=2)\n        # We only need the upper triangle (n*(n-1)/2 pairs)\n        idx = np.triu_indices(N, k=1)\n        return dist_matrix_sq[idx]\n\n    def objective(x):\n        \"\"\"\n        Maximize the slack variable s, which represents the minimum squared distance.\n        \"\"\"\n        return -x[-1]\n\n    def constraints(x, N_pts):\n        \"\"\"\n        Constraints:\n        1. All pairwise squared distances must be at least s (slack variable).\n        2. All pairwise squared distances must be at most 1 (normalizing max distance).\n        \"\"\"\n        pts = x[:-1].reshape((N_pts, 3))\n        s = x[-1]\n        d2 = get_dists_sq(pts)\n        # d2 - s >= 0  AND  1.0 - d2 >= 0\n        return np.concatenate([d2 - s, 1.0 - d2])\n\n    def initial_pts():\n        \"\"\"\n        Generates an initial configuration of points on a sphere of diameter 1.\n        \"\"\"\n        pts = []\n        for i in range(N):\n            phi = np.arccos(-1 + 2 * i / (N - 1))\n            theta = np.sqrt(N * np.pi) * phi\n            # Sphere radius 0.5 ensures diameter is at most 1\n            pts.append([0.5 * np.cos(theta) * np.sin(phi), \n                        0.5 * np.sin(theta) * np.sin(phi), \n                        0.5 * np.cos(phi)])\n        return np.array(pts) + np.random.normal(0, 0.05, (N, 3))\n\n    # Initialize search\n    best_pts = initial_pts()\n    d2 = get_dists_sq(best_pts)\n    max_d2 = np.max(d2)\n    best_pts /= np.sqrt(max_d2)\n    best_score = np.min(d2) / max_d2\n    current_pts = best_pts.copy()\n\n    # Basin-hopping loop for nearly 60 seconds\n    while time.time() - start_time < 56:\n        # Step: Mixed perturbations\n        r = random.random()\n        if r < 0.1:\n            # Global jump: Reset to a new random configuration\n            pts_perturbed = initial_pts()\n        elif r < 0.35:\n            # Large perturbation: Explore broader local region\n            pts_perturbed = current_pts + np.random.normal(0, 0.15, current_pts.shape)\n        else:\n            # Tiny perturbation: Fine-tune current local minimum\n            pts_perturbed = current_pts + np.random.normal(0, 0.015, current_pts.shape)\n        \n        # Pre-normalize to satisfy d_max <= 1 before starting local optimization\n        d2_p = get_dists_sq(pts_perturbed)\n        max_d2_p = np.max(d2_p)\n        if max_d2_p > 1e-9:\n            pts_perturbed /= np.sqrt(max_d2_p)\n            s_p = np.min(d2_p) / max_d2_p\n        else:\n            # Fallback if points collapsed\n            pts_perturbed = initial_pts()\n            d2_p = get_dists_sq(pts_perturbed)\n            max_d2_p = np.max(d2_p)\n            pts_perturbed /= np.sqrt(max_d2_p)\n            s_p = np.min(d2_p) / max_d2_p\n        \n        # Prepare variables for SLSQP (42 coordinates + 1 slack variable)\n        x0 = np.zeros(N * 3 + 1)\n        x0[:N*3] = pts_perturbed.flatten()\n        x0[-1] = s_p\n        \n        # Local optimization with SLSQP\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            constraints={'type': 'ineq', 'fun': constraints, 'args': (N,)},\n            options={'maxiter': 120, 'ftol': 1e-12}\n        )\n        \n        # Extract results if optimization was somewhat successful\n        if res.success or res.status == 8: # 8 is iteration limit reached\n            new_pts = res.x[:-1].reshape((N, 3))\n            new_d2 = get_dists_sq(new_pts)\n            new_max_d2 = np.max(new_d2)\n            \n            if new_max_d2 > 1e-9:\n                # Calculate ratio (min_dist/max_dist)^2\n                new_score = np.min(new_d2) / new_max_d2\n                \n                # Acceptance criteria\n                if new_score > best_score:\n                    best_score = new_score\n                    best_pts = new_pts / np.sqrt(new_max_d2)\n                    current_pts = best_pts.copy()\n                elif random.random() < 0.15: # Probabilistic acceptance to escape minima\n                    current_pts = new_pts / np.sqrt(new_max_d2)\n\n    # Final cleanup: ensure max distance is exactly 1\n    final_d2 = get_dists_sq(best_pts)\n    best_pts /= np.sqrt(np.max(final_d2))\n    \n    return best_pts.reshape((14, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:13:13.545985",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 252,
        "candidates_token_count": 1565,
        "thoughts_token_count": 16350
      },
      "response_text_len": 4894
    }
  }
}