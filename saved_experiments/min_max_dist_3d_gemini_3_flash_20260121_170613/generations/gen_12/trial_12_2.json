{
  "trial_id": "trial_12_2",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a 'Squeezing' optimization strategy: iteratively increasing a required minimum distance d_min\n    and using SLSQP to find a feasible configuration within a bounding sphere of diameter 1.0.\n    Analytical gradients are used for all constraints.\n    \"\"\"\n    n_points = 14\n    \n    def get_initial_points():\n        # Rhombic Dodecahedron vertices: Cube + Octahedron\n        # This is a highly symmetric configuration for 14 points.\n        s = 0.5 / np.sqrt(3)\n        cube = np.array([[i, j, k] for i in [-s, s] for j in [-s, s] for k in [-s, s]])\n        h = 0.5\n        octa = np.array([\n            [h, 0, 0], [-h, 0, 0], [0, h, 0], [0, -h, 0], [0, 0, h], [0, 0, -h]\n        ])\n        return np.vstack([cube, octa])\n\n    def get_dmin_sq(pts):\n        # Calculate minimum squared pairwise distance\n        dist_matrix = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n_points, k=1)\n        return np.min(dist_matrix[i, j])\n\n    # Feasibility constraints for the squeezing phase\n    def constraint_dist(x, d_min_sq):\n        pts = x.reshape((n_points, 3))\n        dist_matrix = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n_points, k=1)\n        return dist_matrix[i, j] - d_min_sq\n\n    def constraint_dist_jac(x, d_min_sq):\n        pts = x.reshape((n_points, 3))\n        jac = np.zeros((n_points * (n_points - 1) // 2, n_points * 3))\n        idx = 0\n        for i in range(n_points):\n            for j in range(i + 1, n_points):\n                jac[idx, i*3:i*3+3] = 2 * (pts[i] - pts[j])\n                jac[idx, j*3:j*3+3] = -2 * (pts[i] - pts[j])\n                idx += 1\n        return jac\n\n    def constraint_sphere(x):\n        # Points must stay within a sphere of radius 0.5 (diameter 1.0)\n        pts = x.reshape((n_points, 3))\n        return 0.25 - np.sum(pts**2, axis=1)\n\n    def constraint_sphere_jac(x):\n        pts = x.reshape((n_points, 3))\n        jac = np.zeros((n_points, n_points * 3))\n        for i in range(n_points):\n            jac[i, i*3:i*3+3] = -2 * pts[i]\n        return jac\n\n    # Initialization\n    pts = get_initial_points()\n    # Add minor noise to break initial symmetry and allow the optimizer to explore\n    np.random.seed(42)\n    pts += np.random.normal(0, 0.001, pts.shape)\n    current_x = pts.flatten()\n    d_min_sq = get_dmin_sq(pts)\n    \n    # Squeezing strategy: iteratively increase d_min_sq and find a feasible point set\n    step = 0.001\n    for _ in range(40):\n        target_d_min_sq = d_min_sq + step\n        res = minimize(\n            lambda x: 0, # Dummy objective for feasibility search\n            current_x,\n            method='SLSQP',\n            jac=lambda x: np.zeros_like(x),\n            constraints=[\n                {'type': 'ineq', 'fun': constraint_dist, 'jac': constraint_dist_jac, 'args': (target_d_min_sq,)},\n                {'type': 'ineq', 'fun': constraint_sphere, 'jac': constraint_sphere_jac}\n            ],\n            options={'maxiter': 50, 'ftol': 1e-7}\n        )\n        if res.success:\n            current_x = res.x\n            d_min_sq = target_d_min_sq\n            step *= 1.1\n        else:\n            # If step fails, reduce step size and try again\n            step *= 0.5\n            if step < 1e-8:\n                break\n\n    # Final refinement phase: Maximize d_min_sq directly using SLSQP\n    def objective_final(x_with_d):\n        return -x_with_d[-1] # Minimize negative d_min_sq\n    \n    def constraint_dist_final(x_with_d):\n        pts = x_with_d[:-1].reshape((n_points, 3))\n        d_m_sq = x_with_d[-1]\n        dist_matrix = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n_points, k=1)\n        return dist_matrix[i, j] - d_m_sq\n\n    def constraint_dist_final_jac(x_with_d):\n        pts = x_with_d[:-1].reshape((n_points, 3))\n        n_dist = n_points * (n_points - 1) // 2\n        jac = np.zeros((n_dist, n_points * 3 + 1))\n        idx = 0\n        for i in range(n_points):\n            for j in range(i + 1, n_points):\n                jac[idx, i*3:i*3+3] = 2 * (pts[i] - pts[j])\n                jac[idx, j*3:j*3+3] = -2 * (pts[i] - pts[j])\n                jac[idx, -1] = -1 # Derivative wrt d_min_sq\n                idx += 1\n        return jac\n\n    def constraint_sphere_final(x_with_d):\n        pts = x_with_d[:-1].reshape((n_points, 3))\n        return 0.25 - np.sum(pts**2, axis=1)\n\n    def constraint_sphere_final_jac(x_with_d):\n        pts = x_with_d[:-1].reshape((n_points, 3))\n        jac = np.zeros((n_points, n_points * 3 + 1))\n        for i in range(n_points):\n            jac[i, i*3:i*3+3] = -2 * pts[i]\n            jac[i, -1] = 0\n        return jac\n\n    initial_x_with_d = np.concatenate([current_x, [d_min_sq]])\n    res_final = minimize(\n        objective_final,\n        initial_x_with_d,\n        method='SLSQP',\n        jac=lambda x: np.concatenate([np.zeros(n_points * 3), [-1.0]]),\n        constraints=[\n            {'type': 'ineq', 'fun': constraint_dist_final, 'jac': constraint_dist_final_jac},\n            {'type': 'ineq', 'fun': constraint_sphere_final, 'jac': constraint_sphere_final_jac}\n        ],\n        options={'maxiter': 200, 'ftol': 1e-9}\n    )\n    \n    if res_final.success:\n        final_pts = res_final.x[:-1].reshape((n_points, 3))\n    else:\n        final_pts = current_x.reshape((n_points, 3))\n        \n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.9559602516283714,
    "min_max_ratio": 0.22947545041135695,
    "min_distance": 0.47678946152383556,
    "max_distance": 0.9953103773408472,
    "eval_time": 1.030486822128296,
    "error": null
  },
  "prompt": "Use a 'Squeezing' optimization strategy. Start with the points from trial_7_5. Iteratively increase a required minimum distance d_min and use SLSQP to find a feasible configuration where all d_ij >= d_min and all points stay within a bounding sphere of diameter 1.0. If feasible, increase d_min and repeat. Use analytical gradients for the distance constraints.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a 'Squeezing' optimization strategy: iteratively increasing a required minimum distance d_min\n    and using SLSQP to find a feasible configuration within a bounding sphere of diameter 1.0.\n    Analytical gradients are used for all constraints.\n    \"\"\"\n    n_points = 14\n    \n    def get_initial_points():\n        # Rhombic Dodecahedron vertices: Cube + Octahedron\n        # This is a highly symmetric configuration for 14 points.\n        s = 0.5 / np.sqrt(3)\n        cube = np.array([[i, j, k] for i in [-s, s] for j in [-s, s] for k in [-s, s]])\n        h = 0.5\n        octa = np.array([\n            [h, 0, 0], [-h, 0, 0], [0, h, 0], [0, -h, 0], [0, 0, h], [0, 0, -h]\n        ])\n        return np.vstack([cube, octa])\n\n    def get_dmin_sq(pts):\n        # Calculate minimum squared pairwise distance\n        dist_matrix = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n_points, k=1)\n        return np.min(dist_matrix[i, j])\n\n    # Feasibility constraints for the squeezing phase\n    def constraint_dist(x, d_min_sq):\n        pts = x.reshape((n_points, 3))\n        dist_matrix = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n_points, k=1)\n        return dist_matrix[i, j] - d_min_sq\n\n    def constraint_dist_jac(x, d_min_sq):\n        pts = x.reshape((n_points, 3))\n        jac = np.zeros((n_points * (n_points - 1) // 2, n_points * 3))\n        idx = 0\n        for i in range(n_points):\n            for j in range(i + 1, n_points):\n                jac[idx, i*3:i*3+3] = 2 * (pts[i] - pts[j])\n                jac[idx, j*3:j*3+3] = -2 * (pts[i] - pts[j])\n                idx += 1\n        return jac\n\n    def constraint_sphere(x):\n        # Points must stay within a sphere of radius 0.5 (diameter 1.0)\n        pts = x.reshape((n_points, 3))\n        return 0.25 - np.sum(pts**2, axis=1)\n\n    def constraint_sphere_jac(x):\n        pts = x.reshape((n_points, 3))\n        jac = np.zeros((n_points, n_points * 3))\n        for i in range(n_points):\n            jac[i, i*3:i*3+3] = -2 * pts[i]\n        return jac\n\n    # Initialization\n    pts = get_initial_points()\n    # Add minor noise to break initial symmetry and allow the optimizer to explore\n    np.random.seed(42)\n    pts += np.random.normal(0, 0.001, pts.shape)\n    current_x = pts.flatten()\n    d_min_sq = get_dmin_sq(pts)\n    \n    # Squeezing strategy: iteratively increase d_min_sq and find a feasible point set\n    step = 0.001\n    for _ in range(40):\n        target_d_min_sq = d_min_sq + step\n        res = minimize(\n            lambda x: 0, # Dummy objective for feasibility search\n            current_x,\n            method='SLSQP',\n            jac=lambda x: np.zeros_like(x),\n            constraints=[\n                {'type': 'ineq', 'fun': constraint_dist, 'jac': constraint_dist_jac, 'args': (target_d_min_sq,)},\n                {'type': 'ineq', 'fun': constraint_sphere, 'jac': constraint_sphere_jac}\n            ],\n            options={'maxiter': 50, 'ftol': 1e-7}\n        )\n        if res.success:\n            current_x = res.x\n            d_min_sq = target_d_min_sq\n            step *= 1.1\n        else:\n            # If step fails, reduce step size and try again\n            step *= 0.5\n            if step < 1e-8:\n                break\n\n    # Final refinement phase: Maximize d_min_sq directly using SLSQP\n    def objective_final(x_with_d):\n        return -x_with_d[-1] # Minimize negative d_min_sq\n    \n    def constraint_dist_final(x_with_d):\n        pts = x_with_d[:-1].reshape((n_points, 3))\n        d_m_sq = x_with_d[-1]\n        dist_matrix = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n_points, k=1)\n        return dist_matrix[i, j] - d_m_sq\n\n    def constraint_dist_final_jac(x_with_d):\n        pts = x_with_d[:-1].reshape((n_points, 3))\n        n_dist = n_points * (n_points - 1) // 2\n        jac = np.zeros((n_dist, n_points * 3 + 1))\n        idx = 0\n        for i in range(n_points):\n            for j in range(i + 1, n_points):\n                jac[idx, i*3:i*3+3] = 2 * (pts[i] - pts[j])\n                jac[idx, j*3:j*3+3] = -2 * (pts[i] - pts[j])\n                jac[idx, -1] = -1 # Derivative wrt d_min_sq\n                idx += 1\n        return jac\n\n    def constraint_sphere_final(x_with_d):\n        pts = x_with_d[:-1].reshape((n_points, 3))\n        return 0.25 - np.sum(pts**2, axis=1)\n\n    def constraint_sphere_final_jac(x_with_d):\n        pts = x_with_d[:-1].reshape((n_points, 3))\n        jac = np.zeros((n_points, n_points * 3 + 1))\n        for i in range(n_points):\n            jac[i, i*3:i*3+3] = -2 * pts[i]\n            jac[i, -1] = 0\n        return jac\n\n    initial_x_with_d = np.concatenate([current_x, [d_min_sq]])\n    res_final = minimize(\n        objective_final,\n        initial_x_with_d,\n        method='SLSQP',\n        jac=lambda x: np.concatenate([np.zeros(n_points * 3), [-1.0]]),\n        constraints=[\n            {'type': 'ineq', 'fun': constraint_dist_final, 'jac': constraint_dist_final_jac},\n            {'type': 'ineq', 'fun': constraint_sphere_final, 'jac': constraint_sphere_final_jac}\n        ],\n        options={'maxiter': 200, 'ftol': 1e-9}\n    )\n    \n    if res_final.success:\n        final_pts = res_final.x[:-1].reshape((n_points, 3))\n    else:\n        final_pts = current_x.reshape((n_points, 3))\n        \n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:13:32.828920",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 254,
        "candidates_token_count": 1991,
        "thoughts_token_count": 26712
      },
      "response_text_len": 5626
    }
  }
}