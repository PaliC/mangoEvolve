{
  "trial_id": "trial_12_6",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a Basin-hopping search with SLSQP and a slack variable formulation.\n    \"\"\"\n    start_time = time.time()\n    N = 14\n    dim = 3\n    triu_idx = np.triu_indices(N, k=1)\n    num_pairs = N * (N - 1) // 2\n\n    def get_dists_sq(pts):\n        \"\"\"Vectorized computation of all pairwise squared distances.\"\"\"\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        return np.sum(diff**2, axis=-1)\n\n    def objective(x):\n        \"\"\"Maximize the slack variable s, which represents the squared minimum distance.\"\"\"\n        return -x[-1]\n\n    def jac_objective(x):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(N * dim + 1)\n        j[-1] = -1\n        return j\n\n    def constraints(x):\n        \"\"\"\n        Constraints for the slack variable formulation:\n        1. All pairwise distances squared >= s\n        2. All pairwise distances squared <= 1.0 (forces max distance to be at most 1)\n        \"\"\"\n        pts = x[:-1].reshape((N, dim))\n        s = x[-1]\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        d_sq = dists_sq[triu_idx]\n        # Return concatenated constraints: d_sq - s >= 0 and 1.0 - d_sq >= 0\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def jac_constraints(x):\n        \"\"\"Jacobian of the constraints function.\"\"\"\n        pts = x[:-1].reshape((N, dim))\n        i_idx, j_idx = triu_idx\n        diffs = pts[i_idx] - pts[j_idx] # Shape (91, 3)\n        \n        # jac_min for constraints: d_sq - s >= 0\n        jac_min = np.zeros((num_pairs, N * dim + 1))\n        rows = np.arange(num_pairs)[:, np.newaxis]\n        cols_i = np.stack([i_idx*3, i_idx*3+1, i_idx*3+2], axis=1)\n        cols_j = np.stack([j_idx*3, j_idx*3+1, j_idx*3+2], axis=1)\n        \n        jac_min[rows, cols_i] = 2 * diffs\n        jac_min[rows, cols_j] = -2 * diffs\n        jac_min[:, N * dim] = -1\n        \n        # jac_max for constraints: 1.0 - d_sq >= 0\n        jac_max = np.zeros((num_pairs, N * dim + 1))\n        jac_max[rows, cols_i] = -2 * diffs\n        jac_max[rows, cols_j] = 2 * diffs\n        # jac_max[:, N * dim] remains 0\n        \n        return np.vstack([jac_min, jac_max])\n\n    def get_initial_x():\n        \"\"\"Generates an initial guess using random points or a golden spiral on a sphere.\"\"\"\n        if np.random.rand() < 0.5:\n            pts = np.random.uniform(-0.5, 0.5, (N, dim))\n        else:\n            phi = np.pi * (3. - np.sqrt(5.))\n            pts = []\n            for i in range(N):\n                y = 1 - (i / float(N - 1)) * 2\n                radius = np.sqrt(1 - y * y)\n                theta = phi * i\n                pts.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n            pts = np.array(pts)\n        \n        # Normalize so that max distance is 1.0\n        dists_sq = get_dists_sq(pts)\n        max_d2 = np.max(dists_sq[triu_idx])\n        pts = pts / np.sqrt(max_d2)\n        s = np.min(get_dists_sq(pts)[triu_idx])\n        return np.concatenate([pts.ravel(), [s * 0.999]])\n\n    def perturb(x, scale):\n        \"\"\"Perturbs the current best solution for Basin-hopping.\"\"\"\n        pts = x[:-1].reshape((N, dim)).copy()\n        if np.random.rand() < 0.1:\n            # Occasional large jump: replace a few points\n            idx = np.random.choice(N, 4, replace=False)\n            pts[idx] = np.random.uniform(-0.5, 0.5, (4, 3))\n        else:\n            # Small Gaussian perturbation\n            pts += np.random.normal(0, scale, pts.shape)\n        \n        # Normalize and compute initial slack s\n        dists_sq = get_dists_sq(pts)\n        max_d2 = np.max(dists_sq[triu_idx])\n        pts = pts / np.sqrt(max_d2)\n        s = np.min(get_dists_sq(pts)[triu_idx])\n        return np.concatenate([pts.ravel(), [s * 0.999]])\n\n    # Seed for reproducibility (referencing user's trial_7_5 hint)\n    np.random.seed(75)\n    \n    x_best = get_initial_x()\n    best_s = -1.0\n    \n    # Run the Basin-hopping search for nearly the full 60 seconds\n    while time.time() - start_time < 55:\n        if best_s < 0:\n            x_step = get_initial_x()\n        else:\n            # Mix of larger and smaller steps\n            scale = 0.05 if np.random.rand() < 0.2 else 0.005\n            x_step = perturb(x_best, scale)\n        \n        # Local optimization with SLSQP\n        res = minimize(objective, x_step, jac=jac_objective,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       method='SLSQP', tol=1e-12, options={'maxiter': 150})\n        \n        # Update global best if a better feasible solution is found\n        if -res.fun > best_s:\n            # Check feasibility with a small tolerance\n            c_val = constraints(res.x)\n            if np.all(c_val >= -1e-7):\n                best_s = -res.fun\n                x_best = res.x\n\n    # Return the optimized 14 points in 3D\n    return x_best[:-1].reshape((N, dim))",
  "metrics": {
    "valid": true,
    "score": 1.000015913553397,
    "min_max_ratio": 0.24005088264945992,
    "min_distance": 0.4899498776910392,
    "max_distance": 1.000000000000009,
    "eval_time": 55.24966883659363,
    "error": null
  },
  "prompt": "Perform a high-intensity Basin-hopping search for 14 points. Use the slack variable formulation. For the 'step' function, use a mix of large jumps and tiny Gaussian perturbations. Optimize each step with SLSQP and a tolerance of 1e-12. Ensure the code runs for nearly the full 60 seconds to maximize exploration. Seed with trial_7_5.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a Basin-hopping search with SLSQP and a slack variable formulation.\n    \"\"\"\n    start_time = time.time()\n    N = 14\n    dim = 3\n    triu_idx = np.triu_indices(N, k=1)\n    num_pairs = N * (N - 1) // 2\n\n    def get_dists_sq(pts):\n        \"\"\"Vectorized computation of all pairwise squared distances.\"\"\"\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        return np.sum(diff**2, axis=-1)\n\n    def objective(x):\n        \"\"\"Maximize the slack variable s, which represents the squared minimum distance.\"\"\"\n        return -x[-1]\n\n    def jac_objective(x):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(N * dim + 1)\n        j[-1] = -1\n        return j\n\n    def constraints(x):\n        \"\"\"\n        Constraints for the slack variable formulation:\n        1. All pairwise distances squared >= s\n        2. All pairwise distances squared <= 1.0 (forces max distance to be at most 1)\n        \"\"\"\n        pts = x[:-1].reshape((N, dim))\n        s = x[-1]\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dists_sq = np.sum(diff**2, axis=-1)\n        d_sq = dists_sq[triu_idx]\n        # Return concatenated constraints: d_sq - s >= 0 and 1.0 - d_sq >= 0\n        return np.concatenate([d_sq - s, 1.0 - d_sq])\n\n    def jac_constraints(x):\n        \"\"\"Jacobian of the constraints function.\"\"\"\n        pts = x[:-1].reshape((N, dim))\n        i_idx, j_idx = triu_idx\n        diffs = pts[i_idx] - pts[j_idx] # Shape (91, 3)\n        \n        # jac_min for constraints: d_sq - s >= 0\n        jac_min = np.zeros((num_pairs, N * dim + 1))\n        rows = np.arange(num_pairs)[:, np.newaxis]\n        cols_i = np.stack([i_idx*3, i_idx*3+1, i_idx*3+2], axis=1)\n        cols_j = np.stack([j_idx*3, j_idx*3+1, j_idx*3+2], axis=1)\n        \n        jac_min[rows, cols_i] = 2 * diffs\n        jac_min[rows, cols_j] = -2 * diffs\n        jac_min[:, N * dim] = -1\n        \n        # jac_max for constraints: 1.0 - d_sq >= 0\n        jac_max = np.zeros((num_pairs, N * dim + 1))\n        jac_max[rows, cols_i] = -2 * diffs\n        jac_max[rows, cols_j] = 2 * diffs\n        # jac_max[:, N * dim] remains 0\n        \n        return np.vstack([jac_min, jac_max])\n\n    def get_initial_x():\n        \"\"\"Generates an initial guess using random points or a golden spiral on a sphere.\"\"\"\n        if np.random.rand() < 0.5:\n            pts = np.random.uniform(-0.5, 0.5, (N, dim))\n        else:\n            phi = np.pi * (3. - np.sqrt(5.))\n            pts = []\n            for i in range(N):\n                y = 1 - (i / float(N - 1)) * 2\n                radius = np.sqrt(1 - y * y)\n                theta = phi * i\n                pts.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n            pts = np.array(pts)\n        \n        # Normalize so that max distance is 1.0\n        dists_sq = get_dists_sq(pts)\n        max_d2 = np.max(dists_sq[triu_idx])\n        pts = pts / np.sqrt(max_d2)\n        s = np.min(get_dists_sq(pts)[triu_idx])\n        return np.concatenate([pts.ravel(), [s * 0.999]])\n\n    def perturb(x, scale):\n        \"\"\"Perturbs the current best solution for Basin-hopping.\"\"\"\n        pts = x[:-1].reshape((N, dim)).copy()\n        if np.random.rand() < 0.1:\n            # Occasional large jump: replace a few points\n            idx = np.random.choice(N, 4, replace=False)\n            pts[idx] = np.random.uniform(-0.5, 0.5, (4, 3))\n        else:\n            # Small Gaussian perturbation\n            pts += np.random.normal(0, scale, pts.shape)\n        \n        # Normalize and compute initial slack s\n        dists_sq = get_dists_sq(pts)\n        max_d2 = np.max(dists_sq[triu_idx])\n        pts = pts / np.sqrt(max_d2)\n        s = np.min(get_dists_sq(pts)[triu_idx])\n        return np.concatenate([pts.ravel(), [s * 0.999]])\n\n    # Seed for reproducibility (referencing user's trial_7_5 hint)\n    np.random.seed(75)\n    \n    x_best = get_initial_x()\n    best_s = -1.0\n    \n    # Run the Basin-hopping search for nearly the full 60 seconds\n    while time.time() - start_time < 55:\n        if best_s < 0:\n            x_step = get_initial_x()\n        else:\n            # Mix of larger and smaller steps\n            scale = 0.05 if np.random.rand() < 0.2 else 0.005\n            x_step = perturb(x_best, scale)\n        \n        # Local optimization with SLSQP\n        res = minimize(objective, x_step, jac=jac_objective,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       method='SLSQP', tol=1e-12, options={'maxiter': 150})\n        \n        # Update global best if a better feasible solution is found\n        if -res.fun > best_s:\n            # Check feasibility with a small tolerance\n            c_val = constraints(res.x)\n            if np.all(c_val >= -1e-7):\n                best_s = -res.fun\n                x_best = res.x\n\n    # Return the optimized 14 points in 3D\n    return x_best[:-1].reshape((N, dim))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:13:21.948732",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 252,
        "candidates_token_count": 1723,
        "thoughts_token_count": 16459
      },
      "response_text_len": 5150
    }
  }
}