{
  "trial_id": "trial_12_4",
  "generation": 12,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses the Rhombic Dodecahedron and Capped Hexagonal Antiprism configurations as initializations.\n    Refines the points using SLSQP with a slack-variable approach and analytical Jacobians.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    def get_score(pts_flat):\n        p = pts_flat.reshape((N, dim))\n        # Pairwise distances squared\n        d2 = pdist(p)**2\n        return np.min(d2) / np.max(d2)\n\n    # Initial Configurations\n    starts = []\n    \n    # 1. Rhombic Dodecahedron (RD) vertices\n    # Vertices: (\u00b11, \u00b11, \u00b11) and (\u00b12, 0, 0), (0, \u00b12, 0), (0, 0, \u00b12)\n    rd = np.array([\n        [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],\n        [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],\n        [2, 0, 0], [-2, 0, 0], [0, 2, 0], [0, -2, 0], [0, 0, 2], [0, 0, -2]\n    ], dtype=float)\n    starts.append(rd)\n    \n    # 2. Capped Hexagonal Antiprism (CHA)\n    # A known high-efficiency configuration for 14 points on a sphere.\n    h = 0.4\n    cha = []\n    for i in range(6):\n        theta = 2 * np.pi * i / 6\n        cha.append([np.cos(theta), np.sin(theta), h])\n        cha.append([np.cos(theta + np.pi/6), np.sin(theta + np.pi/6), -h])\n    cha.append([0, 0, 1.0])\n    cha.append([0, 0, -1.0])\n    cha = np.array(cha)\n    starts.append(cha)\n\n    best_pts = None\n    best_score = -1\n\n    for start_pts in starts:\n        # Normalize initial points so max distance squared is 1.0\n        d2_init = pdist(start_pts)**2\n        start_pts = start_pts / np.sqrt(np.max(d2_init))\n        \n        # Slack variable approach for SLSQP\n        # Variables: [x1, y1, z1, ..., x14, y14, z14, t]\n        # Objective: Maximize t, where t <= min(d_ij^2)\n        x0 = np.zeros(N * dim + 1)\n        x0[:-1] = start_pts.flatten()\n        x0[-1] = np.min(pdist(start_pts)**2)\n\n        def objective(x):\n            return -x[-1]\n\n        def grad_objective(x):\n            g = np.zeros_like(x)\n            g[-1] = -1\n            return g\n\n        def constraints(x):\n            p = x[:-1].reshape((N, dim))\n            t = x[-1]\n            d2 = pdist(p)**2\n            # Constraints: d2_ij >= t and d2_ij <= 1.0\n            return np.concatenate([d2 - t, 1.0 - d2])\n\n        def jac_constraints(x):\n            p = x[:-1].reshape((N, dim))\n            num_pairs = N * (N - 1) // 2\n            jac = np.zeros((2 * num_pairs, N * dim + 1))\n            \n            idx = 0\n            for i in range(N):\n                for j in range(i + 1, N):\n                    diff = p[i] - p[j]\n                    # Derivative of distance squared d2 = sum((p_i - p_j)**2)\n                    # d(d2)/d(p_i) = 2*(p_i - p_j), d(d2)/d(p_j) = -2*(p_i - p_j)\n                    \n                    # min dist constraint: d2 - t >= 0\n                    jac[idx, i*dim : i*dim + dim] = 2 * diff\n                    jac[idx, j*dim : j*dim + dim] = -2 * diff\n                    jac[idx, -1] = -1\n                    \n                    # max dist constraint: 1.0 - d2 >= 0\n                    jac[idx + num_pairs, i*dim : i*dim + dim] = -2 * diff\n                    jac[idx + num_pairs, j*dim : j*dim + dim] = 2 * diff\n                    # jac[idx + num_pairs, -1] = 0\n                    idx += 1\n            return jac\n\n        # Optimization using SLSQP\n        res = minimize(\n            objective, x0, method='SLSQP', jac=grad_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            options={'maxiter': 200, 'ftol': 1e-8}\n        )\n        \n        # Evaluate candidate points\n        if res.success or True:\n            candidate_pts = res.x[:-1].reshape((N, dim))\n            score = get_score(res.x)\n            if score > best_score:\n                best_score = score\n                best_pts = candidate_pts\n    \n    return best_pts",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.2878568172454834,
    "error": "ValueError: cannot reshape array of size 43 into shape (14,3)"
  },
  "prompt": "Explore the Rhombic Dodecahedron configuration for N=14. The vertices are (\u00b11, \u00b11, \u00b11) and (\u00b12, 0, 0), (0, \u00b12, 0), (0, 0, \u00b12). Scale these and add them to your multi-start initializations. Use the slack-variable SLSQP approach with analytical Jacobians to refine these starts. This configuration is known to be very efficient for 14 points.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses the Rhombic Dodecahedron and Capped Hexagonal Antiprism configurations as initializations.\n    Refines the points using SLSQP with a slack-variable approach and analytical Jacobians.\n    \"\"\"\n    N = 14\n    dim = 3\n    \n    def get_score(pts_flat):\n        p = pts_flat.reshape((N, dim))\n        # Pairwise distances squared\n        d2 = pdist(p)**2\n        return np.min(d2) / np.max(d2)\n\n    # Initial Configurations\n    starts = []\n    \n    # 1. Rhombic Dodecahedron (RD) vertices\n    # Vertices: (\u00b11, \u00b11, \u00b11) and (\u00b12, 0, 0), (0, \u00b12, 0), (0, 0, \u00b12)\n    rd = np.array([\n        [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],\n        [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],\n        [2, 0, 0], [-2, 0, 0], [0, 2, 0], [0, -2, 0], [0, 0, 2], [0, 0, -2]\n    ], dtype=float)\n    starts.append(rd)\n    \n    # 2. Capped Hexagonal Antiprism (CHA)\n    # A known high-efficiency configuration for 14 points on a sphere.\n    h = 0.4\n    cha = []\n    for i in range(6):\n        theta = 2 * np.pi * i / 6\n        cha.append([np.cos(theta), np.sin(theta), h])\n        cha.append([np.cos(theta + np.pi/6), np.sin(theta + np.pi/6), -h])\n    cha.append([0, 0, 1.0])\n    cha.append([0, 0, -1.0])\n    cha = np.array(cha)\n    starts.append(cha)\n\n    best_pts = None\n    best_score = -1\n\n    for start_pts in starts:\n        # Normalize initial points so max distance squared is 1.0\n        d2_init = pdist(start_pts)**2\n        start_pts = start_pts / np.sqrt(np.max(d2_init))\n        \n        # Slack variable approach for SLSQP\n        # Variables: [x1, y1, z1, ..., x14, y14, z14, t]\n        # Objective: Maximize t, where t <= min(d_ij^2)\n        x0 = np.zeros(N * dim + 1)\n        x0[:-1] = start_pts.flatten()\n        x0[-1] = np.min(pdist(start_pts)**2)\n\n        def objective(x):\n            return -x[-1]\n\n        def grad_objective(x):\n            g = np.zeros_like(x)\n            g[-1] = -1\n            return g\n\n        def constraints(x):\n            p = x[:-1].reshape((N, dim))\n            t = x[-1]\n            d2 = pdist(p)**2\n            # Constraints: d2_ij >= t and d2_ij <= 1.0\n            return np.concatenate([d2 - t, 1.0 - d2])\n\n        def jac_constraints(x):\n            p = x[:-1].reshape((N, dim))\n            num_pairs = N * (N - 1) // 2\n            jac = np.zeros((2 * num_pairs, N * dim + 1))\n            \n            idx = 0\n            for i in range(N):\n                for j in range(i + 1, N):\n                    diff = p[i] - p[j]\n                    # Derivative of distance squared d2 = sum((p_i - p_j)**2)\n                    # d(d2)/d(p_i) = 2*(p_i - p_j), d(d2)/d(p_j) = -2*(p_i - p_j)\n                    \n                    # min dist constraint: d2 - t >= 0\n                    jac[idx, i*dim : i*dim + dim] = 2 * diff\n                    jac[idx, j*dim : j*dim + dim] = -2 * diff\n                    jac[idx, -1] = -1\n                    \n                    # max dist constraint: 1.0 - d2 >= 0\n                    jac[idx + num_pairs, i*dim : i*dim + dim] = -2 * diff\n                    jac[idx + num_pairs, j*dim : j*dim + dim] = 2 * diff\n                    # jac[idx + num_pairs, -1] = 0\n                    idx += 1\n            return jac\n\n        # Optimization using SLSQP\n        res = minimize(\n            objective, x0, method='SLSQP', jac=grad_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            options={'maxiter': 200, 'ftol': 1e-8}\n        )\n        \n        # Evaluate candidate points\n        if res.success or True:\n            candidate_pts = res.x[:-1].reshape((N, dim))\n            score = get_score(res.x)\n            if score > best_score:\n                best_score = score\n                best_pts = candidate_pts\n    \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:13:21.662876",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 273,
        "candidates_token_count": 1417,
        "thoughts_token_count": 24431
      },
      "response_text_len": 4034
    }
  }
}