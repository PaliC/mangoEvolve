{
  "trial_id": "trial_12_15",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximizes the squared ratio (min pairwise distance / max pairwise distance)^2\n    for 14 points in 3D space.\n    \n    The problem is formulated using a slack variable 's' to represent the minimum\n    squared distance, with the constraint that the maximum squared distance is 1.0.\n    \"\"\"\n    N = 14\n    dim = 3\n    # Interpretation of \"trial_7_5\" as a potential random seed\n    np.random.seed(75)\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates (d_min / d_max)^2 for a set of points.\"\"\"\n        pts = pts.reshape((N, dim))\n        # Compute all pairwise squared distances\n        dists_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        i, j = np.triu_indices(N, k=1)\n        d_ij_sq = dists_sq[i, j]\n        d_min_sq = np.min(d_ij_sq)\n        d_max_sq = np.max(d_ij_sq)\n        if d_max_sq == 0:\n            return 0\n        return d_min_sq / d_max_sq\n\n    # Pre-calculate indices for the upper triangle of the distance matrix\n    i_triu, j_triu = np.triu_indices(N, k=1)\n    \n    def objective(vars):\n        \"\"\"Slack variable formulation: maximize s (minimize -s).\"\"\"\n        return -vars[-1]\n\n    def constraints(vars):\n        \"\"\"\n        Constraints for the slack variable formulation:\n        1. d_ij^2 >= s (all pairwise distances are at least s)\n        2. d_ij^2 <= 1 (the diameter of the set is at most 1)\n        \"\"\"\n        pts = vars[:-1].reshape((N, dim))\n        s = vars[-1]\n        dists_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        d_ij_sq = dists_sq[i_triu, j_triu]\n        # In SLSQP, 'ineq' constraints are functions that must be >= 0\n        return np.concatenate([d_ij_sq - s, 1.0 - d_ij_sq])\n\n    # Bounds for the slack variable s: 0 <= s <= 1\n    bounds = [(None, None)] * (N * dim) + [(0.0, 1.0)]\n\n    # Initial guess and various structured initializations to explore the space\n    best_pts = np.random.uniform(-0.5, 0.5, (N, dim))\n    dists_sq_init = np.sum((best_pts[:, np.newaxis, :] - best_pts[np.newaxis, :, :])**2, axis=-1)\n    best_pts /= np.sqrt(np.max(dists_sq_init))\n    best_score = get_ratio_sq(best_pts)\n    \n    start_time = time.time()\n    \n    # Generate a variety of initial configurations\n    initial_configs = []\n    # 1. Random in a box\n    initial_configs.append(np.random.uniform(-0.5, 0.5, (N, dim)))\n    # 2. Random on a sphere\n    pts_sphere = np.random.normal(0, 1, (N, dim))\n    pts_sphere /= np.linalg.norm(pts_sphere, axis=1)[:, np.newaxis]\n    initial_configs.append(pts_sphere)\n    # 3. Tammes-style structure (approximate poles and rings)\n    pts_tammes = [[0, 0, 0.5], [0, 0, -0.5]]\n    for i in range(6):\n        theta = 2 * np.pi * i / 6\n        pts_tammes.append([0.5 * np.cos(theta), 0.5 * np.sin(theta), 0.2])\n        pts_tammes.append([0.5 * np.cos(theta + np.pi/6), 0.5 * np.sin(theta + np.pi/6), -0.2])\n    initial_configs.append(np.array(pts_tammes))\n\n    # Evaluate and optimize initial configurations\n    for pts_init in initial_configs:\n        dists_sq = np.sum((pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :])**2, axis=-1)\n        d_max = np.sqrt(np.max(dists_sq))\n        if d_max > 0:\n            pts_init /= d_max\n        dists_sq = np.sum((pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :])**2, axis=-1)\n        s_init = np.min(dists_sq[i_triu, j_triu])\n        \n        try:\n            res = minimize(objective, np.concatenate([pts_init.flatten(), [s_init]]),\n                           method='SLSQP', bounds=bounds,\n                           constraints={'type': 'ineq', 'fun': constraints},\n                           options={'maxiter': 100, 'ftol': 1e-9})\n            if res.success:\n                score = get_ratio_sq(res.x[:-1])\n                if score > best_score:\n                    best_score = score\n                    best_pts = res.x[:-1].reshape((N, dim))\n        except:\n            continue\n\n    # High-intensity Basin-hopping search\n    # Run for nearly the full 60 seconds as requested\n    while time.time() - start_time < 54:\n        # Step function: mix of large jumps and tiny Gaussian perturbations\n        rand = np.random.rand()\n        if rand < 0.15:\n            # Large jump: complete randomization\n            pts_init = np.random.uniform(-0.5, 0.5, (N, dim))\n        elif rand < 0.45:\n            # Medium jump: standard normal perturbation\n            pts_init = best_pts + np.random.normal(0, 0.1, (N, dim))\n        else:\n            # Tiny perturbation: fine-tuning\n            pts_init = best_pts + np.random.normal(0, 0.01, (N, dim))\n        \n        # Scale current perturbation to satisfy diameter <= 1\n        dists_sq = np.sum((pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :])**2, axis=-1)\n        d_max = np.sqrt(np.max(dists_sq))\n        if d_max > 0:\n            pts_init /= d_max\n        dists_sq = np.sum((pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :])**2, axis=-1)\n        s_init = np.min(dists_sq[i_triu, j_triu])\n        \n        try:\n            # Local optimization with SLSQP and strict tolerance\n            res = minimize(objective, np.concatenate([pts_init.flatten(), [s_init]]),\n                           method='SLSQP', bounds=bounds,\n                           constraints={'type': 'ineq', 'fun': constraints},\n                           options={'maxiter': 100, 'ftol': 1e-12})\n            if res.success:\n                score = get_ratio_sq(res.x[:-1])\n                if score > best_score:\n                    best_score = score\n                    best_pts = res.x[:-1].reshape((N, dim))\n        except:\n            continue\n            \n    # Final polishing of the best configuration found\n    res = minimize(objective, np.concatenate([best_pts.flatten(), [best_score]]),\n                   method='SLSQP', bounds=bounds,\n                   constraints={'type': 'ineq', 'fun': constraints},\n                   options={'maxiter': 200, 'ftol': 1e-13})\n    if res.success:\n        best_pts = res.x[:-1].reshape((N, dim))\n        \n    # Ensure the returned points are normalized such that the maximum distance is exactly 1\n    dists_sq = np.sum((best_pts[:, np.newaxis, :] - best_pts[np.newaxis, :, :])**2, axis=-1)\n    best_pts /= np.sqrt(np.max(dists_sq))\n    \n    return best_pts.reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539164,
    "min_max_ratio": 0.2400508826495846,
    "min_distance": 0.489949877691162,
    "max_distance": 1.0,
    "eval_time": 54.28040814399719,
    "error": null
  },
  "prompt": "Perform a high-intensity Basin-hopping search for 14 points. Use the slack variable formulation. For the 'step' function, use a mix of large jumps and tiny Gaussian perturbations. Optimize each step with SLSQP and a tolerance of 1e-12. Ensure the code runs for nearly the full 60 seconds to maximize exploration. Seed with trial_7_5.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximizes the squared ratio (min pairwise distance / max pairwise distance)^2\n    for 14 points in 3D space.\n    \n    The problem is formulated using a slack variable 's' to represent the minimum\n    squared distance, with the constraint that the maximum squared distance is 1.0.\n    \"\"\"\n    N = 14\n    dim = 3\n    # Interpretation of \"trial_7_5\" as a potential random seed\n    np.random.seed(75)\n    \n    def get_ratio_sq(pts):\n        \"\"\"Calculates (d_min / d_max)^2 for a set of points.\"\"\"\n        pts = pts.reshape((N, dim))\n        # Compute all pairwise squared distances\n        dists_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        i, j = np.triu_indices(N, k=1)\n        d_ij_sq = dists_sq[i, j]\n        d_min_sq = np.min(d_ij_sq)\n        d_max_sq = np.max(d_ij_sq)\n        if d_max_sq == 0:\n            return 0\n        return d_min_sq / d_max_sq\n\n    # Pre-calculate indices for the upper triangle of the distance matrix\n    i_triu, j_triu = np.triu_indices(N, k=1)\n    \n    def objective(vars):\n        \"\"\"Slack variable formulation: maximize s (minimize -s).\"\"\"\n        return -vars[-1]\n\n    def constraints(vars):\n        \"\"\"\n        Constraints for the slack variable formulation:\n        1. d_ij^2 >= s (all pairwise distances are at least s)\n        2. d_ij^2 <= 1 (the diameter of the set is at most 1)\n        \"\"\"\n        pts = vars[:-1].reshape((N, dim))\n        s = vars[-1]\n        dists_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        d_ij_sq = dists_sq[i_triu, j_triu]\n        # In SLSQP, 'ineq' constraints are functions that must be >= 0\n        return np.concatenate([d_ij_sq - s, 1.0 - d_ij_sq])\n\n    # Bounds for the slack variable s: 0 <= s <= 1\n    bounds = [(None, None)] * (N * dim) + [(0.0, 1.0)]\n\n    # Initial guess and various structured initializations to explore the space\n    best_pts = np.random.uniform(-0.5, 0.5, (N, dim))\n    dists_sq_init = np.sum((best_pts[:, np.newaxis, :] - best_pts[np.newaxis, :, :])**2, axis=-1)\n    best_pts /= np.sqrt(np.max(dists_sq_init))\n    best_score = get_ratio_sq(best_pts)\n    \n    start_time = time.time()\n    \n    # Generate a variety of initial configurations\n    initial_configs = []\n    # 1. Random in a box\n    initial_configs.append(np.random.uniform(-0.5, 0.5, (N, dim)))\n    # 2. Random on a sphere\n    pts_sphere = np.random.normal(0, 1, (N, dim))\n    pts_sphere /= np.linalg.norm(pts_sphere, axis=1)[:, np.newaxis]\n    initial_configs.append(pts_sphere)\n    # 3. Tammes-style structure (approximate poles and rings)\n    pts_tammes = [[0, 0, 0.5], [0, 0, -0.5]]\n    for i in range(6):\n        theta = 2 * np.pi * i / 6\n        pts_tammes.append([0.5 * np.cos(theta), 0.5 * np.sin(theta), 0.2])\n        pts_tammes.append([0.5 * np.cos(theta + np.pi/6), 0.5 * np.sin(theta + np.pi/6), -0.2])\n    initial_configs.append(np.array(pts_tammes))\n\n    # Evaluate and optimize initial configurations\n    for pts_init in initial_configs:\n        dists_sq = np.sum((pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :])**2, axis=-1)\n        d_max = np.sqrt(np.max(dists_sq))\n        if d_max > 0:\n            pts_init /= d_max\n        dists_sq = np.sum((pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :])**2, axis=-1)\n        s_init = np.min(dists_sq[i_triu, j_triu])\n        \n        try:\n            res = minimize(objective, np.concatenate([pts_init.flatten(), [s_init]]),\n                           method='SLSQP', bounds=bounds,\n                           constraints={'type': 'ineq', 'fun': constraints},\n                           options={'maxiter': 100, 'ftol': 1e-9})\n            if res.success:\n                score = get_ratio_sq(res.x[:-1])\n                if score > best_score:\n                    best_score = score\n                    best_pts = res.x[:-1].reshape((N, dim))\n        except:\n            continue\n\n    # High-intensity Basin-hopping search\n    # Run for nearly the full 60 seconds as requested\n    while time.time() - start_time < 54:\n        # Step function: mix of large jumps and tiny Gaussian perturbations\n        rand = np.random.rand()\n        if rand < 0.15:\n            # Large jump: complete randomization\n            pts_init = np.random.uniform(-0.5, 0.5, (N, dim))\n        elif rand < 0.45:\n            # Medium jump: standard normal perturbation\n            pts_init = best_pts + np.random.normal(0, 0.1, (N, dim))\n        else:\n            # Tiny perturbation: fine-tuning\n            pts_init = best_pts + np.random.normal(0, 0.01, (N, dim))\n        \n        # Scale current perturbation to satisfy diameter <= 1\n        dists_sq = np.sum((pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :])**2, axis=-1)\n        d_max = np.sqrt(np.max(dists_sq))\n        if d_max > 0:\n            pts_init /= d_max\n        dists_sq = np.sum((pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :])**2, axis=-1)\n        s_init = np.min(dists_sq[i_triu, j_triu])\n        \n        try:\n            # Local optimization with SLSQP and strict tolerance\n            res = minimize(objective, np.concatenate([pts_init.flatten(), [s_init]]),\n                           method='SLSQP', bounds=bounds,\n                           constraints={'type': 'ineq', 'fun': constraints},\n                           options={'maxiter': 100, 'ftol': 1e-12})\n            if res.success:\n                score = get_ratio_sq(res.x[:-1])\n                if score > best_score:\n                    best_score = score\n                    best_pts = res.x[:-1].reshape((N, dim))\n        except:\n            continue\n            \n    # Final polishing of the best configuration found\n    res = minimize(objective, np.concatenate([best_pts.flatten(), [best_score]]),\n                   method='SLSQP', bounds=bounds,\n                   constraints={'type': 'ineq', 'fun': constraints},\n                   options={'maxiter': 200, 'ftol': 1e-13})\n    if res.success:\n        best_pts = res.x[:-1].reshape((N, dim))\n        \n    # Ensure the returned points are normalized such that the maximum distance is exactly 1\n    dists_sq = np.sum((best_pts[:, np.newaxis, :] - best_pts[np.newaxis, :, :])**2, axis=-1)\n    best_pts /= np.sqrt(np.max(dists_sq))\n    \n    return best_pts.reshape((14, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:16:21.776527",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 252,
        "candidates_token_count": 2103,
        "thoughts_token_count": 18267
      },
      "response_text_len": 6375
    }
  }
}