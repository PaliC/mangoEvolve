{
  "trial_id": "trial_12_11",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximizes the squared ratio (min pairwise distance / max pairwise distance)^2 \n    for 14 points in 3D space using Basin-hopping with SLSQP.\n    \"\"\"\n    N = 14\n    dim = 3\n    start_time = time.time()\n    \n    # Precompute indices for pairs for efficient distance and Jacobian calculations\n    pairs_i, pairs_j = np.triu_indices(N, k=1)\n    num_pairs = N * (N - 1) // 2\n    \n    def get_score(pts):\n        \"\"\"Calculates the squared ratio (min dist / max dist)^2.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def objective(x):\n        \"\"\"Minimize the negative of the slack variable t (t = squared min distance).\"\"\"\n        return -x[-1]\n\n    def constraints(x):\n        \"\"\"\n        Constraints:\n        1. Squared distances must be at least t.\n        2. Squared distances must be at most 1.0 (fixing diameter to 1).\n        \"\"\"\n        pts = np.zeros((N, dim))\n        pts[1:] = x[:-1].reshape((N - 1, dim))\n        t = x[-1]\n        dists_sq = pdist(pts, 'sqeuclidean')\n        # g(x) >= 0 for SLSQP\n        c_min = dists_sq - t\n        c_max = 1.0 - dists_sq\n        return np.concatenate([c_min, c_max])\n\n    def jac_constraints(x):\n        \"\"\"Vectorized Jacobian of the constraints.\"\"\"\n        pts = np.zeros((N, dim))\n        pts[1:] = x[:-1].reshape((N - 1, dim))\n        # Total variables: (N-1)*dim points + 1 slack variable t = 40\n        num_vars = (N - 1) * dim + 1\n        jac = np.zeros((2 * num_pairs, num_vars))\n        \n        diffs = pts[pairs_i] - pts[pairs_j]\n        \n        # Point derivatives for dists_sq - t\n        for d in range(dim):\n            mask_i = (pairs_i > 0)\n            jac[np.where(mask_i)[0], 3 * (pairs_i[mask_i] - 1) + d] = 2 * diffs[mask_i, d]\n            mask_j = (pairs_j > 0)\n            jac[np.where(mask_j)[0], 3 * (pairs_j[mask_j] - 1) + d] = -2 * diffs[mask_j, d]\n        \n        # Point derivatives for 1.0 - dists_sq are the negative of the above\n        jac[num_pairs:, :-1] = -jac[:num_pairs, :-1]\n        \n        # Slack variable derivative for dists_sq - t >= 0\n        jac[:num_pairs, -1] = -1\n        # Slack variable derivative for 1.0 - dists_sq >= 0 is 0\n        \n        return jac\n\n    # Initialize search parameters\n    np.random.seed(75)  # Seed based on 'trial_7_5'\n    best_pts = None\n    best_score = -1\n    \n    # Run the Basin-hopping search for nearly 60 seconds\n    while time.time() - start_time < 55:\n        if best_pts is None or np.random.rand() < 0.2:\n            # Global jump: Random initialization\n            pts = np.random.uniform(-0.5, 0.5, (N, dim))\n        else:\n            # Local perturbation: Small or tiny Gaussian jumps\n            jump_scale = 0.1 if np.random.rand() < 0.5 else 0.01\n            pts = best_pts + np.random.normal(0, jump_scale, (N, dim))\n        \n        # Normalize initial points to have a max diameter of 1\n        dists_sq = pdist(pts, 'sqeuclidean')\n        max_d_sq = np.max(dists_sq)\n        pts = (pts - pts[0]) / np.sqrt(max_d_sq) if max_d_sq > 0 else pts\n        \n        # Starting slack variable t\n        t_init = np.min(pdist(pts, 'sqeuclidean'))\n        \n        # Formulate initial vector x0: 13 points (p0 fixed at origin) + slack t\n        x0 = np.concatenate([pts[1:].flatten(), [t_init]])\n        \n        # SLSQP optimization\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP',\n            jac=lambda x: np.array([0.0] * ((N - 1) * dim) + [-1.0]),\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            tol=1e-12,\n            options={'maxiter': 200}\n        )\n        \n        # Reconstruct full 14-point set\n        pts_res = np.zeros((N, dim))\n        pts_res[1:] = res.x[:-1].reshape((N - 1, dim))\n        \n        # Evaluate and update best configuration found\n        current_score = get_score(pts_res)\n        if current_score > best_score:\n            best_score = current_score\n            best_pts = pts_res\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539164,
    "min_max_ratio": 0.2400508826495846,
    "min_distance": 0.4899498776911621,
    "max_distance": 1.0000000000000002,
    "eval_time": 55.280531883239746,
    "error": null
  },
  "prompt": "Perform a high-intensity Basin-hopping search for 14 points. Use the slack variable formulation. For the 'step' function, use a mix of large jumps and tiny Gaussian perturbations. Optimize each step with SLSQP and a tolerance of 1e-12. Ensure the code runs for nearly the full 60 seconds to maximize exploration. Seed with trial_7_5.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximizes the squared ratio (min pairwise distance / max pairwise distance)^2 \n    for 14 points in 3D space using Basin-hopping with SLSQP.\n    \"\"\"\n    N = 14\n    dim = 3\n    start_time = time.time()\n    \n    # Precompute indices for pairs for efficient distance and Jacobian calculations\n    pairs_i, pairs_j = np.triu_indices(N, k=1)\n    num_pairs = N * (N - 1) // 2\n    \n    def get_score(pts):\n        \"\"\"Calculates the squared ratio (min dist / max dist)^2.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def objective(x):\n        \"\"\"Minimize the negative of the slack variable t (t = squared min distance).\"\"\"\n        return -x[-1]\n\n    def constraints(x):\n        \"\"\"\n        Constraints:\n        1. Squared distances must be at least t.\n        2. Squared distances must be at most 1.0 (fixing diameter to 1).\n        \"\"\"\n        pts = np.zeros((N, dim))\n        pts[1:] = x[:-1].reshape((N - 1, dim))\n        t = x[-1]\n        dists_sq = pdist(pts, 'sqeuclidean')\n        # g(x) >= 0 for SLSQP\n        c_min = dists_sq - t\n        c_max = 1.0 - dists_sq\n        return np.concatenate([c_min, c_max])\n\n    def jac_constraints(x):\n        \"\"\"Vectorized Jacobian of the constraints.\"\"\"\n        pts = np.zeros((N, dim))\n        pts[1:] = x[:-1].reshape((N - 1, dim))\n        # Total variables: (N-1)*dim points + 1 slack variable t = 40\n        num_vars = (N - 1) * dim + 1\n        jac = np.zeros((2 * num_pairs, num_vars))\n        \n        diffs = pts[pairs_i] - pts[pairs_j]\n        \n        # Point derivatives for dists_sq - t\n        for d in range(dim):\n            mask_i = (pairs_i > 0)\n            jac[np.where(mask_i)[0], 3 * (pairs_i[mask_i] - 1) + d] = 2 * diffs[mask_i, d]\n            mask_j = (pairs_j > 0)\n            jac[np.where(mask_j)[0], 3 * (pairs_j[mask_j] - 1) + d] = -2 * diffs[mask_j, d]\n        \n        # Point derivatives for 1.0 - dists_sq are the negative of the above\n        jac[num_pairs:, :-1] = -jac[:num_pairs, :-1]\n        \n        # Slack variable derivative for dists_sq - t >= 0\n        jac[:num_pairs, -1] = -1\n        # Slack variable derivative for 1.0 - dists_sq >= 0 is 0\n        \n        return jac\n\n    # Initialize search parameters\n    np.random.seed(75)  # Seed based on 'trial_7_5'\n    best_pts = None\n    best_score = -1\n    \n    # Run the Basin-hopping search for nearly 60 seconds\n    while time.time() - start_time < 55:\n        if best_pts is None or np.random.rand() < 0.2:\n            # Global jump: Random initialization\n            pts = np.random.uniform(-0.5, 0.5, (N, dim))\n        else:\n            # Local perturbation: Small or tiny Gaussian jumps\n            jump_scale = 0.1 if np.random.rand() < 0.5 else 0.01\n            pts = best_pts + np.random.normal(0, jump_scale, (N, dim))\n        \n        # Normalize initial points to have a max diameter of 1\n        dists_sq = pdist(pts, 'sqeuclidean')\n        max_d_sq = np.max(dists_sq)\n        pts = (pts - pts[0]) / np.sqrt(max_d_sq) if max_d_sq > 0 else pts\n        \n        # Starting slack variable t\n        t_init = np.min(pdist(pts, 'sqeuclidean'))\n        \n        # Formulate initial vector x0: 13 points (p0 fixed at origin) + slack t\n        x0 = np.concatenate([pts[1:].flatten(), [t_init]])\n        \n        # SLSQP optimization\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP',\n            jac=lambda x: np.array([0.0] * ((N - 1) * dim) + [-1.0]),\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            tol=1e-12,\n            options={'maxiter': 200}\n        )\n        \n        # Reconstruct full 14-point set\n        pts_res = np.zeros((N, dim))\n        pts_res[1:] = res.x[:-1].reshape((N - 1, dim))\n        \n        # Evaluate and update best configuration found\n        current_score = get_score(pts_res)\n        if current_score > best_score:\n            best_score = current_score\n            best_pts = pts_res\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:13:53.896972",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 252,
        "candidates_token_count": 1387,
        "thoughts_token_count": 20921
      },
      "response_text_len": 4194
    }
  }
}