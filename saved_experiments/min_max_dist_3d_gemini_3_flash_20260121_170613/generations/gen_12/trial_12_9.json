{
  "trial_id": "trial_12_9",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the squared ratio \n    (min pairwise distance / max pairwise distance)^2.\n    Uses Basin-hopping with SLSQP and a slack variable formulation.\n    \"\"\"\n    start_time = time.time()\n    N = 14\n    dim = 3\n    \n    def get_initial_points():\n        # A rhombic dodecahedron-like vertex configuration as a starting point.\n        # It contains 8 vertices of a cube and 6 vertices of an octahedron.\n        pts = np.array([\n            [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],\n            [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],\n            [1.732, 0, 0], [-1.732, 0, 0], [0, 1.732, 0], [0, -1.732, 0], [0, 0, 1.732], [0, 0, -1.732]\n        ], dtype=float)\n        dists = pdist(pts)\n        return pts / np.max(dists)\n\n    def objective(p):\n        # Slack variable s is the last element. We want to maximize s, so minimize -s.\n        return -p[42]\n\n    def jac_objective(p):\n        # Gradient of the objective function.\n        j = np.zeros(43)\n        j[42] = -1\n        return j\n\n    def constraints(p):\n        # All-pairs constraints: dist_sq >= s and dist_sq <= 1.0\n        pts = p[:42].reshape((N, dim))\n        s = p[42]\n        dists_sq = pdist(pts, 'sqeuclidean')\n        # We need 91 constraints of dists_sq - s >= 0 \n        # and 91 constraints of 1.0 - dists_sq >= 0.\n        return np.concatenate([dists_sq - s, 1.0 - dists_sq])\n\n    def jac_constraints(p):\n        # Jacobian of the constraints matrix (182, 43).\n        pts = p[:42].reshape((N, dim))\n        jac = np.zeros((182, 43))\n        k = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                diff = pts[i] - pts[j]\n                # Grad of dists_sq - s >= 0\n                # d/dxi = 2(xi-xj), d/dxj = -2(xi-xj), d/ds = -1\n                jac[k, 3*i:3*i+3] = 2 * diff\n                jac[k, 3*j:3*j+3] = -2 * diff\n                jac[k, 42] = -1\n                # Grad of 1.0 - dists_sq >= 0\n                # d/dxi = -2(xi-xj), d/dxj = 2(xi-xj), d/ds = 0\n                jac[k+91, 3*i:3*i+3] = -2 * diff\n                jac[k+91, 3*j:3*j+3] = 2 * diff\n                k += 1\n        return jac\n\n    # Seed with interpretation of 'trial_7_5'\n    np.random.seed(75)\n    \n    # Initialize points and slack variable\n    pts = get_initial_points()\n    dists_sq = pdist(pts, 'sqeuclidean')\n    s_init = np.min(dists_sq)\n    p_best = np.concatenate([pts.flatten(), [s_init]])\n    best_obj = s_init\n\n    # Basin-hopping Loop\n    while time.time() - start_time < 55:\n        p_current = p_best.copy()\n        \n        # Apply perturbation (mix of large jumps and tiny Gaussian perturbations)\n        if time.time() - start_time > 0.1:\n            if np.random.rand() > 0.3:\n                # Small Gaussian perturbation\n                p_current[:42] += np.random.normal(0, 0.05, size=42)\n            else:\n                # Larger uniform jump\n                p_current[:42] += np.random.uniform(-0.3, 0.3, size=42)\n            \n            # Reset slack variable s to the actual min distance of the new configuration\n            pts_temp = p_current[:42].reshape((N, dim))\n            dists_sq_temp = pdist(pts_temp, 'sqeuclidean')\n            p_current[42] = np.min(dists_sq_temp)\n        \n        # Local Optimization with SLSQP\n        res = minimize(\n            objective,\n            p_current,\n            method='SLSQP',\n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            tol=1e-12,\n            options={'maxiter': 200}\n        )\n        \n        # Update the best solution found if the current local optimum is better\n        if -res.fun > best_obj:\n            best_obj = -res.fun\n            p_best = res.x\n\n    # Return the points in the required shape (14, 3)\n    final_pts = p_best[:42].reshape((N, dim))\n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 1.0000159135533917,
    "min_max_ratio": 0.24005088264945867,
    "min_distance": 0.4899498776910486,
    "max_distance": 1.0000000000000309,
    "eval_time": 55.25730013847351,
    "error": null
  },
  "prompt": "Perform a high-intensity Basin-hopping search for 14 points. Use the slack variable formulation. For the 'step' function, use a mix of large jumps and tiny Gaussian perturbations. Optimize each step with SLSQP and a tolerance of 1e-12. Ensure the code runs for nearly the full 60 seconds to maximize exploration. Seed with trial_7_5.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D space to maximize the squared ratio \n    (min pairwise distance / max pairwise distance)^2.\n    Uses Basin-hopping with SLSQP and a slack variable formulation.\n    \"\"\"\n    start_time = time.time()\n    N = 14\n    dim = 3\n    \n    def get_initial_points():\n        # A rhombic dodecahedron-like vertex configuration as a starting point.\n        # It contains 8 vertices of a cube and 6 vertices of an octahedron.\n        pts = np.array([\n            [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],\n            [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],\n            [1.732, 0, 0], [-1.732, 0, 0], [0, 1.732, 0], [0, -1.732, 0], [0, 0, 1.732], [0, 0, -1.732]\n        ], dtype=float)\n        dists = pdist(pts)\n        return pts / np.max(dists)\n\n    def objective(p):\n        # Slack variable s is the last element. We want to maximize s, so minimize -s.\n        return -p[42]\n\n    def jac_objective(p):\n        # Gradient of the objective function.\n        j = np.zeros(43)\n        j[42] = -1\n        return j\n\n    def constraints(p):\n        # All-pairs constraints: dist_sq >= s and dist_sq <= 1.0\n        pts = p[:42].reshape((N, dim))\n        s = p[42]\n        dists_sq = pdist(pts, 'sqeuclidean')\n        # We need 91 constraints of dists_sq - s >= 0 \n        # and 91 constraints of 1.0 - dists_sq >= 0.\n        return np.concatenate([dists_sq - s, 1.0 - dists_sq])\n\n    def jac_constraints(p):\n        # Jacobian of the constraints matrix (182, 43).\n        pts = p[:42].reshape((N, dim))\n        jac = np.zeros((182, 43))\n        k = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                diff = pts[i] - pts[j]\n                # Grad of dists_sq - s >= 0\n                # d/dxi = 2(xi-xj), d/dxj = -2(xi-xj), d/ds = -1\n                jac[k, 3*i:3*i+3] = 2 * diff\n                jac[k, 3*j:3*j+3] = -2 * diff\n                jac[k, 42] = -1\n                # Grad of 1.0 - dists_sq >= 0\n                # d/dxi = -2(xi-xj), d/dxj = 2(xi-xj), d/ds = 0\n                jac[k+91, 3*i:3*i+3] = -2 * diff\n                jac[k+91, 3*j:3*j+3] = 2 * diff\n                k += 1\n        return jac\n\n    # Seed with interpretation of 'trial_7_5'\n    np.random.seed(75)\n    \n    # Initialize points and slack variable\n    pts = get_initial_points()\n    dists_sq = pdist(pts, 'sqeuclidean')\n    s_init = np.min(dists_sq)\n    p_best = np.concatenate([pts.flatten(), [s_init]])\n    best_obj = s_init\n\n    # Basin-hopping Loop\n    while time.time() - start_time < 55:\n        p_current = p_best.copy()\n        \n        # Apply perturbation (mix of large jumps and tiny Gaussian perturbations)\n        if time.time() - start_time > 0.1:\n            if np.random.rand() > 0.3:\n                # Small Gaussian perturbation\n                p_current[:42] += np.random.normal(0, 0.05, size=42)\n            else:\n                # Larger uniform jump\n                p_current[:42] += np.random.uniform(-0.3, 0.3, size=42)\n            \n            # Reset slack variable s to the actual min distance of the new configuration\n            pts_temp = p_current[:42].reshape((N, dim))\n            dists_sq_temp = pdist(pts_temp, 'sqeuclidean')\n            p_current[42] = np.min(dists_sq_temp)\n        \n        # Local Optimization with SLSQP\n        res = minimize(\n            objective,\n            p_current,\n            method='SLSQP',\n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            tol=1e-12,\n            options={'maxiter': 200}\n        )\n        \n        # Update the best solution found if the current local optimum is better\n        if -res.fun > best_obj:\n            best_obj = -res.fun\n            p_best = res.x\n\n    # Return the points in the required shape (14, 3)\n    final_pts = p_best[:42].reshape((N, dim))\n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:13:18.562194",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 252,
        "candidates_token_count": 1416,
        "thoughts_token_count": 17728
      },
      "response_text_len": 4058
    }
  }
}