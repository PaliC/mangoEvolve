{
  "trial_id": "trial_12_1",
  "generation": 12,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the squared ratio\n    (min_dist / max_dist)^2 using symmetry-constrained optimization followed by\n    unconstrained polishing.\n    \"\"\"\n    \n    # ---------------------------------------------------------\n    # 1. Define Symmetry Generators\n    # ---------------------------------------------------------\n    \n    def get_d6d(params):\n        \"\"\"\n        Bicapped Hexagonal Antiprism (D6d symmetry).\n        params: [h_ring, h_cap]\n        Radius of rings is fixed at 1.0 (scale invariant).\n        \"\"\"\n        r = 1.0\n        h_ring, h_cap = params\n        points = []\n        \n        # Two caps at poles\n        points.append([0.0, 0.0, h_cap])\n        points.append([0.0, 0.0, -h_cap])\n        \n        # Ring 1: z = h_ring, theta = 0, 60, ...\n        for i in range(6):\n            theta = i * np.pi / 3.0\n            points.append([r * np.cos(theta), r * np.sin(theta), h_ring])\n            \n        # Ring 2: z = -h_ring, theta = 30, 90, ... (twisted by 30 deg)\n        for i in range(6):\n            theta = i * np.pi / 3.0 + np.pi / 6.0\n            points.append([r * np.cos(theta), r * np.sin(theta), -h_ring])\n            \n        return np.array(points)\n\n    def get_oh(params):\n        \"\"\"\n        Rhombic Dodecahedron-like (Oh symmetry).\n        params: [b]\n        6 points at +/- 1 on axes (Octahedron vertices).\n        8 points at +/- b on diagonals (Cube vertices).\n        \"\"\"\n        b = params[0]\n        points = []\n        \n        # Octahedron vertices (fixed scale 1.0)\n        # (\u00b11, 0, 0), (0, \u00b11, 0), (0, 0, \u00b11)\n        points.extend([\n            [1.0, 0.0, 0.0], [-1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0], [0.0, -1.0, 0.0],\n            [0.0, 0.0, 1.0], [0.0, 0.0, -1.0]\n        ])\n        \n        # Cube vertices at (\u00b1b, \u00b1b, \u00b1b)\n        for x in [-1, 1]:\n            for y in [-1, 1]:\n                for z in [-1, 1]:\n                    points.append(np.array([x, y, z]) * b)\n                    \n        return np.array(points)\n\n    def neg_sq_ratio(points):\n        \"\"\"\n        Returns negative of (min_dist / max_dist)^2.\n        Used for minimization.\n        \"\"\"\n        # Compute pairwise distance squared matrix\n        # (N, 1, 3) - (1, N, 3) -> (N, N, 3)\n        diffs = points[:, np.newaxis, :] - points[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=-1)\n        \n        # Mask diagonal for min calculation\n        np.fill_diagonal(d2, np.inf)\n        min_d2 = np.min(d2)\n        \n        # Mask diagonal for max calculation (0 is fine, but max ignores it anyway if N>1)\n        np.fill_diagonal(d2, 0.0)\n        max_d2 = np.max(d2)\n        \n        if max_d2 < 1e-9:\n            return 0.0\n            \n        # We maximize ratio, so minimize negative ratio\n        return -(min_d2 / max_d2)\n\n    # ---------------------------------------------------------\n    # 2. Optimize Symmetries\n    # ---------------------------------------------------------\n    \n    # Optimize D6d\n    # Initial guess: h_ring=0.5, h_cap=1.0 (approximate geometry)\n    res_d6d = minimize(lambda p: neg_sq_ratio(get_d6d(p)), [0.5, 1.0], \n                       method='Nelder-Mead', tol=1e-5)\n    best_d6d_pts = get_d6d(res_d6d.x)\n    score_d6d = -res_d6d.fun\n    \n    # Optimize Oh\n    # Initial guess: b=0.5\n    res_oh = minimize(lambda p: neg_sq_ratio(get_oh(p)), [0.5], \n                      method='Nelder-Mead', tol=1e-5)\n    best_oh_pts = get_oh(res_oh.x)\n    score_oh = -res_oh.fun\n    \n    # Select best seed\n    if score_d6d >= score_oh:\n        seed_pts = best_d6d_pts\n    else:\n        seed_pts = best_oh_pts\n\n    # ---------------------------------------------------------\n    # 3. Unconstrained Polish (SLSQP)\n    # ---------------------------------------------------------\n    \n    # Formulation:\n    # Maximize s (squared min dist)\n    # Subject to: \n    #   dist_ij^2 >= s\n    #   dist_ij^2 <= 1 (fix diameter to 1)\n    \n    n = 14\n    # Indices for upper triangle of distance matrix (pairs i < j)\n    idx_i, idx_j = np.triu_indices(n, k=1)\n    num_pairs = len(idx_i)\n    \n    # Prepare initial guess x0\n    x0_coords = seed_pts.flatten()\n    \n    # Normalize seed so max_dist = 1\n    current_diffs = seed_pts[idx_i] - seed_pts[idx_j]\n    current_d2 = np.sum(current_diffs**2, axis=1)\n    scale_factor = np.sqrt(np.max(current_d2))\n    if scale_factor > 1e-9:\n        x0_coords /= scale_factor\n        \n    # Initial s (min dist sq)\n    current_diffs = (x0_coords.reshape(n, 3)[idx_i] - x0_coords.reshape(n, 3)[idx_j])\n    current_d2 = np.sum(current_diffs**2, axis=1)\n    s0 = np.min(current_d2)\n    \n    # State vector: [x1_x, x1_y, x1_z, ..., x14_z, s]\n    x0 = np.append(x0_coords, s0)\n    \n    def objective(x):\n        return -x[-1] # maximize s\n        \n    def objective_grad(x):\n        g = np.zeros_like(x)\n        g[-1] = -1.0\n        return g\n    \n    def constraints_func(x):\n        coords = x[:-1].reshape(n, 3)\n        s = x[-1]\n        \n        diffs = coords[idx_i] - coords[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        \n        # Constraint 1: d2 >= s  ->  d2 - s >= 0\n        c1 = d2 - s\n        # Constraint 2: d2 <= 1  ->  1 - d2 >= 0\n        c2 = 1.0 - d2\n        \n        return np.concatenate([c1, c2])\n    \n    def constraints_jac(x):\n        coords = x[:-1].reshape(n, 3)\n        # s = x[-1]\n        \n        # Jacobian shape: (2 * num_pairs, 3 * n + 1)\n        jac = np.zeros((2 * num_pairs, 3 * n + 1))\n        \n        diffs = coords[idx_i] - coords[idx_j] # (M, 3)\n        grad_d2 = 2 * diffs # Gradient of d^2 w.r.t x_i is 2(xi-xj)\n        \n        # Fill Jacobian\n        # For each pair k corresponding to (i, j)\n        for k in range(num_pairs):\n            i = idx_i[k]\n            j = idx_j[k]\n            \n            g = grad_d2[k]\n            \n            # 1. d2 - s >= 0\n            # d(c1)/dxi = g, d(c1)/dxj = -g, d(c1)/ds = -1\n            jac[k, 3*i:3*i+3] = g\n            jac[k, 3*j:3*j+3] = -g\n            jac[k, -1] = -1.0\n            \n            # 2. 1 - d2 >= 0\n            # d(c2)/dxi = -g, d(c2)/dxj = g, d(c2)/ds = 0\n            jac[num_pairs+k, 3*i:3*i+3] = -g\n            jac[num_pairs+k, 3*j:3*j+3] = g\n            jac[num_pairs+k, -1] = 0.0\n            \n        return jac\n\n    # Run SLSQP\n    res = minimize(\n        objective, \n        x0, \n        method='SLSQP', \n        jac=objective_grad,\n        constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n        options={'maxiter': 500, 'ftol': 1e-7, 'disp': False}\n    )\n    \n    final_pts = res.x[:-1].reshape(n, 3)\n    \n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.9331888308441674,
    "min_max_ratio": 0.22400923773979375,
    "min_distance": 0.47329614169121825,
    "max_distance": 1.0,
    "eval_time": 0.28493499755859375,
    "error": null
  },
  "prompt": "Implement a symmetry-constrained optimization for N=14. Test two specific symmetries: 1) D6d (Bicapped Hexagonal Antiprism) and 2) Oh (Rhombic Dodecahedron: 6 points at +/-a, 8 points at +/-b). For each symmetry, define the points using minimal parameters (e.g., ring radius, height) and optimize those parameters to maximize the min/max distance ratio. Use the best result as a seed for a final unconstrained SLSQP polish.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D space that maximizes the squared ratio\n    (min_dist / max_dist)^2 using symmetry-constrained optimization followed by\n    unconstrained polishing.\n    \"\"\"\n    \n    # ---------------------------------------------------------\n    # 1. Define Symmetry Generators\n    # ---------------------------------------------------------\n    \n    def get_d6d(params):\n        \"\"\"\n        Bicapped Hexagonal Antiprism (D6d symmetry).\n        params: [h_ring, h_cap]\n        Radius of rings is fixed at 1.0 (scale invariant).\n        \"\"\"\n        r = 1.0\n        h_ring, h_cap = params\n        points = []\n        \n        # Two caps at poles\n        points.append([0.0, 0.0, h_cap])\n        points.append([0.0, 0.0, -h_cap])\n        \n        # Ring 1: z = h_ring, theta = 0, 60, ...\n        for i in range(6):\n            theta = i * np.pi / 3.0\n            points.append([r * np.cos(theta), r * np.sin(theta), h_ring])\n            \n        # Ring 2: z = -h_ring, theta = 30, 90, ... (twisted by 30 deg)\n        for i in range(6):\n            theta = i * np.pi / 3.0 + np.pi / 6.0\n            points.append([r * np.cos(theta), r * np.sin(theta), -h_ring])\n            \n        return np.array(points)\n\n    def get_oh(params):\n        \"\"\"\n        Rhombic Dodecahedron-like (Oh symmetry).\n        params: [b]\n        6 points at +/- 1 on axes (Octahedron vertices).\n        8 points at +/- b on diagonals (Cube vertices).\n        \"\"\"\n        b = params[0]\n        points = []\n        \n        # Octahedron vertices (fixed scale 1.0)\n        # (\u00b11, 0, 0), (0, \u00b11, 0), (0, 0, \u00b11)\n        points.extend([\n            [1.0, 0.0, 0.0], [-1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0], [0.0, -1.0, 0.0],\n            [0.0, 0.0, 1.0], [0.0, 0.0, -1.0]\n        ])\n        \n        # Cube vertices at (\u00b1b, \u00b1b, \u00b1b)\n        for x in [-1, 1]:\n            for y in [-1, 1]:\n                for z in [-1, 1]:\n                    points.append(np.array([x, y, z]) * b)\n                    \n        return np.array(points)\n\n    def neg_sq_ratio(points):\n        \"\"\"\n        Returns negative of (min_dist / max_dist)^2.\n        Used for minimization.\n        \"\"\"\n        # Compute pairwise distance squared matrix\n        # (N, 1, 3) - (1, N, 3) -> (N, N, 3)\n        diffs = points[:, np.newaxis, :] - points[np.newaxis, :, :]\n        d2 = np.sum(diffs**2, axis=-1)\n        \n        # Mask diagonal for min calculation\n        np.fill_diagonal(d2, np.inf)\n        min_d2 = np.min(d2)\n        \n        # Mask diagonal for max calculation (0 is fine, but max ignores it anyway if N>1)\n        np.fill_diagonal(d2, 0.0)\n        max_d2 = np.max(d2)\n        \n        if max_d2 < 1e-9:\n            return 0.0\n            \n        # We maximize ratio, so minimize negative ratio\n        return -(min_d2 / max_d2)\n\n    # ---------------------------------------------------------\n    # 2. Optimize Symmetries\n    # ---------------------------------------------------------\n    \n    # Optimize D6d\n    # Initial guess: h_ring=0.5, h_cap=1.0 (approximate geometry)\n    res_d6d = minimize(lambda p: neg_sq_ratio(get_d6d(p)), [0.5, 1.0], \n                       method='Nelder-Mead', tol=1e-5)\n    best_d6d_pts = get_d6d(res_d6d.x)\n    score_d6d = -res_d6d.fun\n    \n    # Optimize Oh\n    # Initial guess: b=0.5\n    res_oh = minimize(lambda p: neg_sq_ratio(get_oh(p)), [0.5], \n                      method='Nelder-Mead', tol=1e-5)\n    best_oh_pts = get_oh(res_oh.x)\n    score_oh = -res_oh.fun\n    \n    # Select best seed\n    if score_d6d >= score_oh:\n        seed_pts = best_d6d_pts\n    else:\n        seed_pts = best_oh_pts\n\n    # ---------------------------------------------------------\n    # 3. Unconstrained Polish (SLSQP)\n    # ---------------------------------------------------------\n    \n    # Formulation:\n    # Maximize s (squared min dist)\n    # Subject to: \n    #   dist_ij^2 >= s\n    #   dist_ij^2 <= 1 (fix diameter to 1)\n    \n    n = 14\n    # Indices for upper triangle of distance matrix (pairs i < j)\n    idx_i, idx_j = np.triu_indices(n, k=1)\n    num_pairs = len(idx_i)\n    \n    # Prepare initial guess x0\n    x0_coords = seed_pts.flatten()\n    \n    # Normalize seed so max_dist = 1\n    current_diffs = seed_pts[idx_i] - seed_pts[idx_j]\n    current_d2 = np.sum(current_diffs**2, axis=1)\n    scale_factor = np.sqrt(np.max(current_d2))\n    if scale_factor > 1e-9:\n        x0_coords /= scale_factor\n        \n    # Initial s (min dist sq)\n    current_diffs = (x0_coords.reshape(n, 3)[idx_i] - x0_coords.reshape(n, 3)[idx_j])\n    current_d2 = np.sum(current_diffs**2, axis=1)\n    s0 = np.min(current_d2)\n    \n    # State vector: [x1_x, x1_y, x1_z, ..., x14_z, s]\n    x0 = np.append(x0_coords, s0)\n    \n    def objective(x):\n        return -x[-1] # maximize s\n        \n    def objective_grad(x):\n        g = np.zeros_like(x)\n        g[-1] = -1.0\n        return g\n    \n    def constraints_func(x):\n        coords = x[:-1].reshape(n, 3)\n        s = x[-1]\n        \n        diffs = coords[idx_i] - coords[idx_j]\n        d2 = np.sum(diffs**2, axis=1)\n        \n        # Constraint 1: d2 >= s  ->  d2 - s >= 0\n        c1 = d2 - s\n        # Constraint 2: d2 <= 1  ->  1 - d2 >= 0\n        c2 = 1.0 - d2\n        \n        return np.concatenate([c1, c2])\n    \n    def constraints_jac(x):\n        coords = x[:-1].reshape(n, 3)\n        # s = x[-1]\n        \n        # Jacobian shape: (2 * num_pairs, 3 * n + 1)\n        jac = np.zeros((2 * num_pairs, 3 * n + 1))\n        \n        diffs = coords[idx_i] - coords[idx_j] # (M, 3)\n        grad_d2 = 2 * diffs # Gradient of d^2 w.r.t x_i is 2(xi-xj)\n        \n        # Fill Jacobian\n        # For each pair k corresponding to (i, j)\n        for k in range(num_pairs):\n            i = idx_i[k]\n            j = idx_j[k]\n            \n            g = grad_d2[k]\n            \n            # 1. d2 - s >= 0\n            # d(c1)/dxi = g, d(c1)/dxj = -g, d(c1)/ds = -1\n            jac[k, 3*i:3*i+3] = g\n            jac[k, 3*j:3*j+3] = -g\n            jac[k, -1] = -1.0\n            \n            # 2. 1 - d2 >= 0\n            # d(c2)/dxi = -g, d(c2)/dxj = g, d(c2)/ds = 0\n            jac[num_pairs+k, 3*i:3*i+3] = -g\n            jac[num_pairs+k, 3*j:3*j+3] = g\n            jac[num_pairs+k, -1] = 0.0\n            \n        return jac\n\n    # Run SLSQP\n    res = minimize(\n        objective, \n        x0, \n        method='SLSQP', \n        jac=objective_grad,\n        constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n        options={'maxiter': 500, 'ftol': 1e-7, 'disp': False}\n    )\n    \n    final_pts = res.x[:-1].reshape(n, 3)\n    \n    return final_pts\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:15:21.013678",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 281,
        "candidates_token_count": 2464,
        "thoughts_token_count": 10580
      },
      "response_text_len": 6709
    }
  }
}