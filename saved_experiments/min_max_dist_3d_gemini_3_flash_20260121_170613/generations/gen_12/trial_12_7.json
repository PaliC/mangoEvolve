{
  "trial_id": "trial_12_7",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space that maximize the ratio (min distance / max distance)^2.\n    The method uses Basin-hopping with SLSQP, employing a slack variable formulation.\n    \"\"\"\n    N = 14\n    D = 3\n    num_vars = N * D + 1  # 14 points * 3 dims + 1 slack variable 's'\n    \n    def get_dists_sq(pts):\n        \"\"\"Helper to get all pairwise squared distances.\"\"\"\n        dist_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        return dist_sq[np.triu_indices(N, k=1)]\n\n    def objective(v):\n        \"\"\"Maximize s is equivalent to minimizing -s.\"\"\"\n        return -v[-1]\n\n    def obj_jac(v):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(num_vars)\n        j[-1] = -1.0\n        return j\n\n    def constraints(v):\n        \"\"\"\n        Constraints:\n        1. All pairwise squared distances >= s\n        2. All pairwise squared distances <= 1.0\n        \"\"\"\n        pts = v[:-1].reshape((N, D))\n        s = v[-1]\n        d_ij_sq = get_dists_sq(pts)\n        # c >= 0 for SLSQP ineq constraints\n        return np.concatenate([d_ij_sq - s, 1.0 - d_ij_sq])\n\n    def constraints_jac(v):\n        \"\"\"Jacobian of the 182 constraints (91 for min, 91 for max).\"\"\"\n        pts = v[:-1].reshape((N, D))\n        rows, cols = np.triu_indices(N, k=1)\n        diffs = pts[rows] - pts[cols]\n        \n        jac_c1 = np.zeros((91, num_vars))\n        jac_c2 = np.zeros((91, num_vars))\n        \n        # Mapping 14 points into 3D variable indices\n        idx3_rows = np.stack([3*rows, 3*rows+1, 3*rows+2], axis=1)\n        idx3_cols = np.stack([3*cols, 3*cols+1, 3*cols+2], axis=1)\n        \n        row_indices = np.arange(91)[:, np.newaxis]\n        \n        # d_ij_sq = (xi-xj)^2 + (yi-yj)^2 + (zi-zj)^2\n        # d(d_ij_sq)/dxi = 2(xi-xj), d(d_ij_sq)/dxj = -2(xi-xj)\n        jac_c1[row_indices, idx3_rows] = 2 * diffs\n        jac_c1[row_indices, idx3_cols] = -2 * diffs\n        jac_c1[:, -1] = -1  # d(d_ij_sq - s)/ds = -1\n        \n        jac_c2[row_indices, idx3_rows] = -2 * diffs\n        jac_c2[row_indices, idx3_cols] = 2 * diffs\n        # d(1.0 - d_ij_sq)/ds = 0\n        \n        return np.vstack([jac_c1, jac_c2])\n\n    def get_initial_v(strategy='random'):\n        \"\"\"Generates various starting point configurations.\"\"\"\n        if strategy == 'sphere':\n            # Fibonacci Sphere distribution\n            indices = np.arange(0, N, dtype=float) + 0.5\n            phi = np.arccos(1 - 2*indices/N)\n            theta = np.pi * (1 + 5**0.5) * indices\n            pts = np.stack([np.cos(theta) * np.sin(phi), np.sin(theta) * np.sin(phi), np.cos(phi)], axis=1)\n        elif strategy == '7-7':\n            # Two rings of 7 points\n            pts = []\n            for i in range(7):\n                t = 2 * np.pi * i / 7\n                pts.append([0.5 * np.cos(t), 0.5 * np.sin(t), 0.25])\n                pts.append([0.5 * np.cos(t + np.pi/7), 0.5 * np.sin(t + np.pi/7), -0.25])\n            pts = np.array(pts)\n        elif strategy == '7-5-2':\n            # Ring of 7, ring of 5, and 2 poles\n            pts = []\n            for i in range(7):\n                t = 2 * np.pi * i / 7\n                pts.append([0.5 * np.cos(t), 0.5 * np.sin(t), 0.2])\n            for i in range(5):\n                t = 2 * np.pi * i / 5\n                pts.append([0.5 * np.cos(t), 0.5 * np.sin(t), -0.2])\n            pts.append([0, 0, 0.5])\n            pts.append([0, 0, -0.5])\n            pts = np.array(pts)\n        else:\n            pts = np.random.uniform(-0.5, 0.5, (N, D))\n            \n        d_ij_sq = get_dists_sq(pts)\n        max_d2 = np.max(d_ij_sq)\n        if max_d2 > 0:\n            pts = pts / np.sqrt(max_d2)\n            s = np.min(d_ij_sq) / max_d2\n        else:\n            s = 0.0\n        return np.concatenate([pts.flatten(), [s]])\n\n    # Start timer and set seed (interpreting 'trial_7_5' as 75)\n    start_time = time.time()\n    np.random.seed(75)\n    \n    best_ratio_sq = -1.0\n    best_pts = None\n    \n    strategies = ['sphere', '7-7', '7-5-2', 'random']\n    strategy_idx = 0\n    \n    # Run Basin-hopping for nearly 60 seconds\n    while time.time() - start_time < 57:\n        if strategy_idx < len(strategies):\n            v = get_initial_v(strategies[strategy_idx])\n            strategy_idx += 1\n        else:\n            # Perturb best found solution or start fresh\n            if best_pts is not None and np.random.random() < 0.8:\n                scale = np.random.choice([0.1, 0.01, 0.001])\n                pts = best_pts + np.random.normal(0, scale, (N, D))\n            else:\n                pts = np.random.uniform(-0.5, 0.5, (N, D))\n            \n            d_ij_sq = get_dists_sq(pts)\n            max_d2 = np.max(d_ij_sq)\n            if max_d2 > 0:\n                pts = pts / np.sqrt(max_d2)\n                s = np.min(d_ij_sq) / max_d2\n            else:\n                s = 0.0\n            v = np.concatenate([pts.flatten(), [s]])\n            \n        # Local optimization using SLSQP\n        res = minimize(\n            objective, v, jac=obj_jac,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n            options={'ftol': 1e-12, 'maxiter': 100}\n        )\n        \n        # Evaluate current result\n        pts_current = res.x[:-1].reshape((N, D))\n        d_ij_sq = get_dists_sq(pts_current)\n        max_d2 = np.max(d_ij_sq)\n        if max_d2 > 0:\n            current_ratio_sq = np.min(d_ij_sq) / max_d2\n        else:\n            current_ratio_sq = 0.0\n        \n        if current_ratio_sq > best_ratio_sq:\n            best_ratio_sq = current_ratio_sq\n            best_pts = pts_current\n            \n    return best_pts if best_pts is not None else v[:-1].reshape((N, D))",
  "metrics": {
    "valid": true,
    "score": 1.0000159135539168,
    "min_max_ratio": 0.2400508826495847,
    "min_distance": 0.4899498776911621,
    "max_distance": 1.0,
    "eval_time": 57.28981304168701,
    "error": null
  },
  "prompt": "Perform a high-intensity Basin-hopping search for 14 points. Use the slack variable formulation. For the 'step' function, use a mix of large jumps and tiny Gaussian perturbations. Optimize each step with SLSQP and a tolerance of 1e-12. Ensure the code runs for nearly the full 60 seconds to maximize exploration. Seed with trial_7_5.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space that maximize the ratio (min distance / max distance)^2.\n    The method uses Basin-hopping with SLSQP, employing a slack variable formulation.\n    \"\"\"\n    N = 14\n    D = 3\n    num_vars = N * D + 1  # 14 points * 3 dims + 1 slack variable 's'\n    \n    def get_dists_sq(pts):\n        \"\"\"Helper to get all pairwise squared distances.\"\"\"\n        dist_sq = np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=-1)\n        return dist_sq[np.triu_indices(N, k=1)]\n\n    def objective(v):\n        \"\"\"Maximize s is equivalent to minimizing -s.\"\"\"\n        return -v[-1]\n\n    def obj_jac(v):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(num_vars)\n        j[-1] = -1.0\n        return j\n\n    def constraints(v):\n        \"\"\"\n        Constraints:\n        1. All pairwise squared distances >= s\n        2. All pairwise squared distances <= 1.0\n        \"\"\"\n        pts = v[:-1].reshape((N, D))\n        s = v[-1]\n        d_ij_sq = get_dists_sq(pts)\n        # c >= 0 for SLSQP ineq constraints\n        return np.concatenate([d_ij_sq - s, 1.0 - d_ij_sq])\n\n    def constraints_jac(v):\n        \"\"\"Jacobian of the 182 constraints (91 for min, 91 for max).\"\"\"\n        pts = v[:-1].reshape((N, D))\n        rows, cols = np.triu_indices(N, k=1)\n        diffs = pts[rows] - pts[cols]\n        \n        jac_c1 = np.zeros((91, num_vars))\n        jac_c2 = np.zeros((91, num_vars))\n        \n        # Mapping 14 points into 3D variable indices\n        idx3_rows = np.stack([3*rows, 3*rows+1, 3*rows+2], axis=1)\n        idx3_cols = np.stack([3*cols, 3*cols+1, 3*cols+2], axis=1)\n        \n        row_indices = np.arange(91)[:, np.newaxis]\n        \n        # d_ij_sq = (xi-xj)^2 + (yi-yj)^2 + (zi-zj)^2\n        # d(d_ij_sq)/dxi = 2(xi-xj), d(d_ij_sq)/dxj = -2(xi-xj)\n        jac_c1[row_indices, idx3_rows] = 2 * diffs\n        jac_c1[row_indices, idx3_cols] = -2 * diffs\n        jac_c1[:, -1] = -1  # d(d_ij_sq - s)/ds = -1\n        \n        jac_c2[row_indices, idx3_rows] = -2 * diffs\n        jac_c2[row_indices, idx3_cols] = 2 * diffs\n        # d(1.0 - d_ij_sq)/ds = 0\n        \n        return np.vstack([jac_c1, jac_c2])\n\n    def get_initial_v(strategy='random'):\n        \"\"\"Generates various starting point configurations.\"\"\"\n        if strategy == 'sphere':\n            # Fibonacci Sphere distribution\n            indices = np.arange(0, N, dtype=float) + 0.5\n            phi = np.arccos(1 - 2*indices/N)\n            theta = np.pi * (1 + 5**0.5) * indices\n            pts = np.stack([np.cos(theta) * np.sin(phi), np.sin(theta) * np.sin(phi), np.cos(phi)], axis=1)\n        elif strategy == '7-7':\n            # Two rings of 7 points\n            pts = []\n            for i in range(7):\n                t = 2 * np.pi * i / 7\n                pts.append([0.5 * np.cos(t), 0.5 * np.sin(t), 0.25])\n                pts.append([0.5 * np.cos(t + np.pi/7), 0.5 * np.sin(t + np.pi/7), -0.25])\n            pts = np.array(pts)\n        elif strategy == '7-5-2':\n            # Ring of 7, ring of 5, and 2 poles\n            pts = []\n            for i in range(7):\n                t = 2 * np.pi * i / 7\n                pts.append([0.5 * np.cos(t), 0.5 * np.sin(t), 0.2])\n            for i in range(5):\n                t = 2 * np.pi * i / 5\n                pts.append([0.5 * np.cos(t), 0.5 * np.sin(t), -0.2])\n            pts.append([0, 0, 0.5])\n            pts.append([0, 0, -0.5])\n            pts = np.array(pts)\n        else:\n            pts = np.random.uniform(-0.5, 0.5, (N, D))\n            \n        d_ij_sq = get_dists_sq(pts)\n        max_d2 = np.max(d_ij_sq)\n        if max_d2 > 0:\n            pts = pts / np.sqrt(max_d2)\n            s = np.min(d_ij_sq) / max_d2\n        else:\n            s = 0.0\n        return np.concatenate([pts.flatten(), [s]])\n\n    # Start timer and set seed (interpreting 'trial_7_5' as 75)\n    start_time = time.time()\n    np.random.seed(75)\n    \n    best_ratio_sq = -1.0\n    best_pts = None\n    \n    strategies = ['sphere', '7-7', '7-5-2', 'random']\n    strategy_idx = 0\n    \n    # Run Basin-hopping for nearly 60 seconds\n    while time.time() - start_time < 57:\n        if strategy_idx < len(strategies):\n            v = get_initial_v(strategies[strategy_idx])\n            strategy_idx += 1\n        else:\n            # Perturb best found solution or start fresh\n            if best_pts is not None and np.random.random() < 0.8:\n                scale = np.random.choice([0.1, 0.01, 0.001])\n                pts = best_pts + np.random.normal(0, scale, (N, D))\n            else:\n                pts = np.random.uniform(-0.5, 0.5, (N, D))\n            \n            d_ij_sq = get_dists_sq(pts)\n            max_d2 = np.max(d_ij_sq)\n            if max_d2 > 0:\n                pts = pts / np.sqrt(max_d2)\n                s = np.min(d_ij_sq) / max_d2\n            else:\n                s = 0.0\n            v = np.concatenate([pts.flatten(), [s]])\n            \n        # Local optimization using SLSQP\n        res = minimize(\n            objective, v, jac=obj_jac,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n            options={'ftol': 1e-12, 'maxiter': 100}\n        )\n        \n        # Evaluate current result\n        pts_current = res.x[:-1].reshape((N, D))\n        d_ij_sq = get_dists_sq(pts_current)\n        max_d2 = np.max(d_ij_sq)\n        if max_d2 > 0:\n            current_ratio_sq = np.min(d_ij_sq) / max_d2\n        else:\n            current_ratio_sq = 0.0\n        \n        if current_ratio_sq > best_ratio_sq:\n            best_ratio_sq = current_ratio_sq\n            best_pts = pts_current\n            \n    return best_pts if best_pts is not None else v[:-1].reshape((N, D))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:13:45.350840",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 252,
        "candidates_token_count": 2090,
        "thoughts_token_count": 17954
      },
      "response_text_len": 5810
    }
  }
}