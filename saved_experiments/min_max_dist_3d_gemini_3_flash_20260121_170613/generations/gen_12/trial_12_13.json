{
  "trial_id": "trial_12_13",
  "generation": 12,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport random\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space that maximize the ratio (min_distance / max_distance)^2.\n    Uses a basin-hopping approach with SLSQP optimization and the slack variable formulation.\n    \"\"\"\n    # Seed for reproducibility as requested\n    np.random.seed(75)\n    random.seed(75)\n    \n    N = 14\n    D = 3\n    # Precompute indices for the upper triangle of the distance matrix\n    I_INDICES, J_INDICES = np.triu_indices(N, k=1)\n    \n    def get_dist_sq(pts):\n        \"\"\"Calculates squared pairwise distances between all points.\"\"\"\n        diff = pts[I_INDICES] - pts[J_INDICES]\n        return np.sum(diff**2, axis=1)\n    \n    def objective(x):\n        \"\"\"Minimize the negative of the slack variable s (maximizing s).\"\"\"\n        return -x[42]\n    \n    def objective_jac(x):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        j = np.zeros(43)\n        j[42] = -1.0\n        return j\n    \n    def constraints(x):\n        \"\"\"\n        Constraints for SLSQP:\n        1. dist_sq[i,j] - s >= 0 (min distance constraint)\n        2. 1.0 - dist_sq[i,j] >= 0 (max distance constraint)\n        \"\"\"\n        pts = x[:42].reshape((N, D))\n        s = x[42]\n        dists_sq = get_dist_sq(pts)\n        return np.concatenate([dists_sq - s, 1.0 - dists_sq])\n    \n    def constraints_jac(x):\n        \"\"\"Vectorized Jacobian of the constraints.\"\"\"\n        pts = x[:42].reshape((N, D))\n        diffs = pts[I_INDICES] - pts[J_INDICES]\n        \n        # 182 constraints (91 min-dist, 91 max-dist) and 43 variables\n        jac = np.zeros((182, 43))\n        \n        # Part 1: dists_sq - s >= 0\n        # Derivative w.r.t. p_i: 2*(p_i - p_j), w.r.t. p_j: -2*(p_i - p_j), w.r.t. s: -1\n        for k in range(D):\n            jac[np.arange(91), I_INDICES * 3 + k] = 2 * diffs[:, k]\n            jac[np.arange(91), J_INDICES * 3 + k] = -2 * diffs[:, k]\n        jac[np.arange(91), 42] = -1\n        \n        # Part 2: 1.0 - dists_sq >= 0\n        # Derivative w.r.t. p_i: -2*(p_i - p_j), w.r.t. p_j: 2*(p_i - p_j), w.r.t. s: 0\n        for k in range(D):\n            jac[np.arange(91, 182), I_INDICES * 3 + k] = -2 * diffs[:, k]\n            jac[np.arange(91, 182), J_INDICES * 3 + k] = 2 * diffs[:, k]\n            \n        return jac\n\n    def generate_random_pts():\n        \"\"\"Generates initial point configurations.\"\"\"\n        if random.random() < 0.8:\n            # Points on a sphere of diameter 1\n            pts = np.random.normal(0, 1, (N, D))\n            pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n            pts *= 0.5\n        else:\n            # Points in a cube\n            pts = np.random.uniform(-0.5, 0.5, (N, D))\n        return pts\n\n    # Initialize variables for the search\n    best_pts = generate_random_pts()\n    dists_sq_init = get_dist_sq(best_pts)\n    best_s = np.min(dists_sq_init) / np.max(dists_sq_init)\n    \n    start_time = time.perf_counter()\n    timeout = 55  # Leave a small buffer for finishing up\n    \n    # Basin-hopping loop\n    while time.perf_counter() - start_time < timeout:\n        # Perturbation step\n        if best_s == 0:\n            pts = generate_random_pts()\n        else:\n            rand_val = random.random()\n            if rand_val < 0.2: # Large jump\n                pts = best_pts + np.random.normal(0, 0.15, best_pts.shape)\n            elif rand_val < 0.5: # Medium jump\n                pts = best_pts + np.random.normal(0, 0.05, best_pts.shape)\n            else: # Tiny perturbation\n                pts = best_pts + np.random.normal(0, 0.005, best_pts.shape)\n        \n        # Normalization: ensure the diameter of the set is exactly 1\n        current_dists_sq = get_dist_sq(pts)\n        max_d = np.sqrt(np.max(current_dists_sq))\n        if max_d > 1e-9:\n            pts = pts / max_d\n        \n        # Initial slack variable value\n        s_init = np.min(get_dist_sq(pts))\n        x0 = np.append(pts.flatten(), s_init)\n        \n        # Local optimization with SLSQP\n        res = minimize(\n            objective, x0, jac=objective_jac,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n            method='SLSQP', \n            tol=1e-12, \n            options={'maxiter': 100, 'ftol': 1e-12}\n        )\n        \n        # Update global best if a better configuration is found\n        if res.success or -res.fun > best_s:\n            s_opt = -res.fun\n            if s_opt > best_s:\n                best_s = s_opt\n                best_pts = res.x[:42].reshape((N, D))\n                \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 1.0000159135527766,
    "min_max_ratio": 0.24005088264931104,
    "min_distance": 0.4899498776908909,
    "max_distance": 1.0000000000000164,
    "eval_time": 55.377821922302246,
    "error": null
  },
  "prompt": "Perform a high-intensity Basin-hopping search for 14 points. Use the slack variable formulation. For the 'step' function, use a mix of large jumps and tiny Gaussian perturbations. Optimize each step with SLSQP and a tolerance of 1e-12. Ensure the code runs for nearly the full 60 seconds to maximize exploration. Seed with trial_7_5.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport random\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space that maximize the ratio (min_distance / max_distance)^2.\n    Uses a basin-hopping approach with SLSQP optimization and the slack variable formulation.\n    \"\"\"\n    # Seed for reproducibility as requested\n    np.random.seed(75)\n    random.seed(75)\n    \n    N = 14\n    D = 3\n    # Precompute indices for the upper triangle of the distance matrix\n    I_INDICES, J_INDICES = np.triu_indices(N, k=1)\n    \n    def get_dist_sq(pts):\n        \"\"\"Calculates squared pairwise distances between all points.\"\"\"\n        diff = pts[I_INDICES] - pts[J_INDICES]\n        return np.sum(diff**2, axis=1)\n    \n    def objective(x):\n        \"\"\"Minimize the negative of the slack variable s (maximizing s).\"\"\"\n        return -x[42]\n    \n    def objective_jac(x):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        j = np.zeros(43)\n        j[42] = -1.0\n        return j\n    \n    def constraints(x):\n        \"\"\"\n        Constraints for SLSQP:\n        1. dist_sq[i,j] - s >= 0 (min distance constraint)\n        2. 1.0 - dist_sq[i,j] >= 0 (max distance constraint)\n        \"\"\"\n        pts = x[:42].reshape((N, D))\n        s = x[42]\n        dists_sq = get_dist_sq(pts)\n        return np.concatenate([dists_sq - s, 1.0 - dists_sq])\n    \n    def constraints_jac(x):\n        \"\"\"Vectorized Jacobian of the constraints.\"\"\"\n        pts = x[:42].reshape((N, D))\n        diffs = pts[I_INDICES] - pts[J_INDICES]\n        \n        # 182 constraints (91 min-dist, 91 max-dist) and 43 variables\n        jac = np.zeros((182, 43))\n        \n        # Part 1: dists_sq - s >= 0\n        # Derivative w.r.t. p_i: 2*(p_i - p_j), w.r.t. p_j: -2*(p_i - p_j), w.r.t. s: -1\n        for k in range(D):\n            jac[np.arange(91), I_INDICES * 3 + k] = 2 * diffs[:, k]\n            jac[np.arange(91), J_INDICES * 3 + k] = -2 * diffs[:, k]\n        jac[np.arange(91), 42] = -1\n        \n        # Part 2: 1.0 - dists_sq >= 0\n        # Derivative w.r.t. p_i: -2*(p_i - p_j), w.r.t. p_j: 2*(p_i - p_j), w.r.t. s: 0\n        for k in range(D):\n            jac[np.arange(91, 182), I_INDICES * 3 + k] = -2 * diffs[:, k]\n            jac[np.arange(91, 182), J_INDICES * 3 + k] = 2 * diffs[:, k]\n            \n        return jac\n\n    def generate_random_pts():\n        \"\"\"Generates initial point configurations.\"\"\"\n        if random.random() < 0.8:\n            # Points on a sphere of diameter 1\n            pts = np.random.normal(0, 1, (N, D))\n            pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n            pts *= 0.5\n        else:\n            # Points in a cube\n            pts = np.random.uniform(-0.5, 0.5, (N, D))\n        return pts\n\n    # Initialize variables for the search\n    best_pts = generate_random_pts()\n    dists_sq_init = get_dist_sq(best_pts)\n    best_s = np.min(dists_sq_init) / np.max(dists_sq_init)\n    \n    start_time = time.perf_counter()\n    timeout = 55  # Leave a small buffer for finishing up\n    \n    # Basin-hopping loop\n    while time.perf_counter() - start_time < timeout:\n        # Perturbation step\n        if best_s == 0:\n            pts = generate_random_pts()\n        else:\n            rand_val = random.random()\n            if rand_val < 0.2: # Large jump\n                pts = best_pts + np.random.normal(0, 0.15, best_pts.shape)\n            elif rand_val < 0.5: # Medium jump\n                pts = best_pts + np.random.normal(0, 0.05, best_pts.shape)\n            else: # Tiny perturbation\n                pts = best_pts + np.random.normal(0, 0.005, best_pts.shape)\n        \n        # Normalization: ensure the diameter of the set is exactly 1\n        current_dists_sq = get_dist_sq(pts)\n        max_d = np.sqrt(np.max(current_dists_sq))\n        if max_d > 1e-9:\n            pts = pts / max_d\n        \n        # Initial slack variable value\n        s_init = np.min(get_dist_sq(pts))\n        x0 = np.append(pts.flatten(), s_init)\n        \n        # Local optimization with SLSQP\n        res = minimize(\n            objective, x0, jac=objective_jac,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n            method='SLSQP', \n            tol=1e-12, \n            options={'maxiter': 100, 'ftol': 1e-12}\n        )\n        \n        # Update global best if a better configuration is found\n        if res.success or -res.fun > best_s:\n            s_opt = -res.fun\n            if s_opt > best_s:\n                best_s = s_opt\n                best_pts = res.x[:42].reshape((N, D))\n                \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:15:28.600591",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 252,
        "candidates_token_count": 1588,
        "thoughts_token_count": 18197
      },
      "response_text_len": 4601
    }
  }
}