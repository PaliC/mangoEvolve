{
  "trial_id": "trial_12_0",
  "generation": 12,
  "parent_id": "trial_8_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D to maximize the squared ratio \n    (min_dist / max_dist)^2.\n    \n    Uses a slack variable formulation:\n    Maximize s\n    Subject to:\n      dist_ij^2 >= s\n      dist_ij^2 <= 1\n      \n    Solved using SLSQP with analytical Jacobians and multi-start micro-perturbations.\n    \"\"\"\n    N = 14\n    DIM = 3\n    \n    # --- Pre-computation ---\n    # Indices for all pairwise interactions (upper triangle)\n    iu = np.triu_indices(N, 1)\n    idx1, idx2 = iu\n    n_pairs = len(idx1) # 91 for N=14\n    \n    # --- Seeding Strategy ---\n    # Since specific trial coordinates are not persistent, we generate a high-quality \n    # seed approximating the solution to the Thomson problem (min energy on sphere),\n    # which is known to be a very strong basin for the Tammes/Min-Max problem.\n    def generate_seed():\n        # 1. Fibonacci lattice on sphere for uniform distribution\n        indices = np.arange(0, N, dtype=float) + 0.5\n        phi = np.arccos(1 - 2*indices/N)\n        theta = np.pi * (1 + 5**0.5) * indices\n        x, y, z = np.cos(theta) * np.sin(phi), np.sin(theta) * np.sin(phi), np.cos(phi)\n        points = np.column_stack((x, y, z))\n        \n        # 2. Rapid relaxation to maximize min distance on sphere\n        # This aligns points into a \"spherical code\" configuration\n        def obj_repel(p_flat):\n            p = p_flat.reshape((N, DIM))\n            # Project to sphere\n            norm = np.linalg.norm(p, axis=1, keepdims=True) + 1e-10\n            p = p / norm\n            # Calculate pairwise squared distances\n            diff = p[idx1] - p[idx2]\n            d2 = np.sum(diff**2, axis=1)\n            # Maximize min distance => Minimize -min_dist\n            return -np.min(d2)\n\n        # Use L-BFGS-B for fast unconstrained (projected) optimization\n        res = minimize(obj_repel, points.flatten(), method='L-BFGS-B', options={'maxiter': 200})\n        p = res.x.reshape((N, DIM))\n        p = p / (np.linalg.norm(p, axis=1, keepdims=True) + 1e-10)\n        return p\n\n    points = generate_seed()\n    \n    # --- Initialization ---\n    # Scale points so max distance is exactly 1.0\n    diff = points[idx1] - points[idx2]\n    d2 = np.sum(diff**2, axis=1)\n    max_d2 = np.max(d2)\n    points = points / np.sqrt(max_d2)\n    \n    # Initialize slack variable s slightly below current min squared distance\n    diff = points[idx1] - points[idx2]\n    d2 = np.sum(diff**2, axis=1)\n    s_init = np.min(d2) * 0.99 \n    \n    # Optimization state vector: [x1, y1, z1, ..., xN, yN, zN, s]\n    x0 = np.concatenate([points.flatten(), [s_init]])\n\n    # --- Optimization Problem Definition ---\n    \n    # Objective: Maximize s => Minimize -s\n    def objective(x):\n        return -x[-1]\n\n    # Jacobian of objective\n    def obj_jac(x):\n        g = np.zeros_like(x)\n        g[-1] = -1.0\n        return g\n\n    # Constraints: \n    # Returns vector of shape (2 * n_pairs,)\n    # Part 1: d_ij^2 - s >= 0\n    # Part 2: 1 - d_ij^2 >= 0\n    def constraints(x):\n        p = x[:-1].reshape((N, DIM))\n        s = x[-1]\n        \n        vecs = p[idx1] - p[idx2]\n        d2 = np.sum(vecs**2, axis=1)\n        \n        return np.concatenate([d2 - s, 1.0 - d2])\n\n    # Analytical Jacobian for constraints\n    # Shape: (182, 43)\n    def constraints_jac(x):\n        p = x[:-1].reshape((N, DIM))\n        vecs = p[idx1] - p[idx2]\n        \n        J = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        rows = np.arange(n_pairs)\n        \n        # --- Part 1: d^2 - s >= 0 ---\n        # Derivatives w.r.t coordinates\n        # d(d^2)/dxi = 2*(xi - xj)\n        cols_i = 3 * idx1\n        J[rows, cols_i]   = 2 * vecs[:, 0]\n        J[rows, cols_i+1] = 2 * vecs[:, 1]\n        J[rows, cols_i+2] = 2 * vecs[:, 2]\n        \n        cols_j = 3 * idx2\n        J[rows, cols_j]   = -2 * vecs[:, 0]\n        J[rows, cols_j+1] = -2 * vecs[:, 1]\n        J[rows, cols_j+2] = -2 * vecs[:, 2]\n        \n        # Derivative w.r.t s is -1\n        J[rows, -1] = -1.0\n        \n        # --- Part 2: 1 - d^2 >= 0 ---\n        # Derivatives are negative of Part 1, s derivative is 0\n        J[n_pairs + rows, :-1] = -J[rows, :-1]\n        # s col remains 0\n        \n        return J\n\n    nlc = NonlinearConstraint(constraints, 0.0, np.inf, jac=constraints_jac)\n    \n    # --- Execution ---\n    \n    best_x = x0\n    best_s = s_init\n    \n    t_start = time.time()\n    time_limit = 55.0 # Seconds\n    \n    # Solver options\n    opts = {'ftol': 1e-15, 'maxiter': 2000, 'disp': False}\n    \n    # 1. Primary High-Precision Run\n    try:\n        res = minimize(objective, x0, method='SLSQP', jac=obj_jac, constraints=nlc, options=opts)\n        if res.success or res.message:\n            if res.x[-1] > best_s:\n                best_s = res.x[-1]\n                best_x = res.x\n    except Exception:\n        pass\n\n    # 2. Refinement loop with micro-perturbations\n    # Explore the immediate basin\n    perturbation_scales = [1e-7, 1e-7, 1e-8]\n    \n    for scale in perturbation_scales:\n        if time.time() - t_start > time_limit:\n            break\n            \n        # Perturb best solution found so far\n        x_start = best_x.copy()\n        noise = np.random.normal(0, scale, size=x_start.shape)\n        x_start[:-1] += noise[:-1]\n        \n        # Re-center and scale to ensure rough feasibility\n        p = x_start[:-1].reshape((N, DIM))\n        p -= np.mean(p, axis=0)\n        \n        diff = p[idx1] - p[idx2]\n        d2 = np.sum(diff**2, axis=1)\n        max_d = np.sqrt(np.max(d2))\n        p /= max_d\n        \n        # Reset slack\n        diff = p[idx1] - p[idx2]\n        d2 = np.sum(diff**2, axis=1)\n        s = np.min(d2) * 0.99\n        \n        x_start = np.concatenate([p.flatten(), [s]])\n        \n        try:\n            res = minimize(objective, x_start, method='SLSQP', jac=obj_jac, constraints=nlc, options=opts)\n            if res.x[-1] > best_s:\n                best_s = res.x[-1]\n                best_x = res.x\n        except Exception:\n            continue\n\n    # Extract final coordinates\n    final_points = best_x[:-1].reshape((N, DIM))\n    \n    # Center for cleanliness\n    final_points -= np.mean(final_points, axis=0)\n    \n    return final_points",
  "metrics": {
    "valid": true,
    "score": 0.9239026355008304,
    "min_max_ratio": 0.22178011382445287,
    "min_distance": 0.4709353605585939,
    "max_distance": 1.0,
    "eval_time": 0.49013304710388184,
    "error": null
  },
  "prompt": "Refine the best known solution from trial_8_0. Use the 'slack variable' formulation: maximize s such that d_ij^2 >= s and d_max^2 <= 1. Implement a high-precision multi-start SLSQP with analytical Jacobians. Use the coordinates from trial_8_0 as the primary seed, but add micro-perturbations (1e-7) to explore the immediate basin. Set ftol to 1e-15.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Optimizes the placement of 14 points in 3D to maximize the squared ratio \n    (min_dist / max_dist)^2.\n    \n    Uses a slack variable formulation:\n    Maximize s\n    Subject to:\n      dist_ij^2 >= s\n      dist_ij^2 <= 1\n      \n    Solved using SLSQP with analytical Jacobians and multi-start micro-perturbations.\n    \"\"\"\n    N = 14\n    DIM = 3\n    \n    # --- Pre-computation ---\n    # Indices for all pairwise interactions (upper triangle)\n    iu = np.triu_indices(N, 1)\n    idx1, idx2 = iu\n    n_pairs = len(idx1) # 91 for N=14\n    \n    # --- Seeding Strategy ---\n    # Since specific trial coordinates are not persistent, we generate a high-quality \n    # seed approximating the solution to the Thomson problem (min energy on sphere),\n    # which is known to be a very strong basin for the Tammes/Min-Max problem.\n    def generate_seed():\n        # 1. Fibonacci lattice on sphere for uniform distribution\n        indices = np.arange(0, N, dtype=float) + 0.5\n        phi = np.arccos(1 - 2*indices/N)\n        theta = np.pi * (1 + 5**0.5) * indices\n        x, y, z = np.cos(theta) * np.sin(phi), np.sin(theta) * np.sin(phi), np.cos(phi)\n        points = np.column_stack((x, y, z))\n        \n        # 2. Rapid relaxation to maximize min distance on sphere\n        # This aligns points into a \"spherical code\" configuration\n        def obj_repel(p_flat):\n            p = p_flat.reshape((N, DIM))\n            # Project to sphere\n            norm = np.linalg.norm(p, axis=1, keepdims=True) + 1e-10\n            p = p / norm\n            # Calculate pairwise squared distances\n            diff = p[idx1] - p[idx2]\n            d2 = np.sum(diff**2, axis=1)\n            # Maximize min distance => Minimize -min_dist\n            return -np.min(d2)\n\n        # Use L-BFGS-B for fast unconstrained (projected) optimization\n        res = minimize(obj_repel, points.flatten(), method='L-BFGS-B', options={'maxiter': 200})\n        p = res.x.reshape((N, DIM))\n        p = p / (np.linalg.norm(p, axis=1, keepdims=True) + 1e-10)\n        return p\n\n    points = generate_seed()\n    \n    # --- Initialization ---\n    # Scale points so max distance is exactly 1.0\n    diff = points[idx1] - points[idx2]\n    d2 = np.sum(diff**2, axis=1)\n    max_d2 = np.max(d2)\n    points = points / np.sqrt(max_d2)\n    \n    # Initialize slack variable s slightly below current min squared distance\n    diff = points[idx1] - points[idx2]\n    d2 = np.sum(diff**2, axis=1)\n    s_init = np.min(d2) * 0.99 \n    \n    # Optimization state vector: [x1, y1, z1, ..., xN, yN, zN, s]\n    x0 = np.concatenate([points.flatten(), [s_init]])\n\n    # --- Optimization Problem Definition ---\n    \n    # Objective: Maximize s => Minimize -s\n    def objective(x):\n        return -x[-1]\n\n    # Jacobian of objective\n    def obj_jac(x):\n        g = np.zeros_like(x)\n        g[-1] = -1.0\n        return g\n\n    # Constraints: \n    # Returns vector of shape (2 * n_pairs,)\n    # Part 1: d_ij^2 - s >= 0\n    # Part 2: 1 - d_ij^2 >= 0\n    def constraints(x):\n        p = x[:-1].reshape((N, DIM))\n        s = x[-1]\n        \n        vecs = p[idx1] - p[idx2]\n        d2 = np.sum(vecs**2, axis=1)\n        \n        return np.concatenate([d2 - s, 1.0 - d2])\n\n    # Analytical Jacobian for constraints\n    # Shape: (182, 43)\n    def constraints_jac(x):\n        p = x[:-1].reshape((N, DIM))\n        vecs = p[idx1] - p[idx2]\n        \n        J = np.zeros((2 * n_pairs, 3 * N + 1))\n        \n        rows = np.arange(n_pairs)\n        \n        # --- Part 1: d^2 - s >= 0 ---\n        # Derivatives w.r.t coordinates\n        # d(d^2)/dxi = 2*(xi - xj)\n        cols_i = 3 * idx1\n        J[rows, cols_i]   = 2 * vecs[:, 0]\n        J[rows, cols_i+1] = 2 * vecs[:, 1]\n        J[rows, cols_i+2] = 2 * vecs[:, 2]\n        \n        cols_j = 3 * idx2\n        J[rows, cols_j]   = -2 * vecs[:, 0]\n        J[rows, cols_j+1] = -2 * vecs[:, 1]\n        J[rows, cols_j+2] = -2 * vecs[:, 2]\n        \n        # Derivative w.r.t s is -1\n        J[rows, -1] = -1.0\n        \n        # --- Part 2: 1 - d^2 >= 0 ---\n        # Derivatives are negative of Part 1, s derivative is 0\n        J[n_pairs + rows, :-1] = -J[rows, :-1]\n        # s col remains 0\n        \n        return J\n\n    nlc = NonlinearConstraint(constraints, 0.0, np.inf, jac=constraints_jac)\n    \n    # --- Execution ---\n    \n    best_x = x0\n    best_s = s_init\n    \n    t_start = time.time()\n    time_limit = 55.0 # Seconds\n    \n    # Solver options\n    opts = {'ftol': 1e-15, 'maxiter': 2000, 'disp': False}\n    \n    # 1. Primary High-Precision Run\n    try:\n        res = minimize(objective, x0, method='SLSQP', jac=obj_jac, constraints=nlc, options=opts)\n        if res.success or res.message:\n            if res.x[-1] > best_s:\n                best_s = res.x[-1]\n                best_x = res.x\n    except Exception:\n        pass\n\n    # 2. Refinement loop with micro-perturbations\n    # Explore the immediate basin\n    perturbation_scales = [1e-7, 1e-7, 1e-8]\n    \n    for scale in perturbation_scales:\n        if time.time() - t_start > time_limit:\n            break\n            \n        # Perturb best solution found so far\n        x_start = best_x.copy()\n        noise = np.random.normal(0, scale, size=x_start.shape)\n        x_start[:-1] += noise[:-1]\n        \n        # Re-center and scale to ensure rough feasibility\n        p = x_start[:-1].reshape((N, DIM))\n        p -= np.mean(p, axis=0)\n        \n        diff = p[idx1] - p[idx2]\n        d2 = np.sum(diff**2, axis=1)\n        max_d = np.sqrt(np.max(d2))\n        p /= max_d\n        \n        # Reset slack\n        diff = p[idx1] - p[idx2]\n        d2 = np.sum(diff**2, axis=1)\n        s = np.min(d2) * 0.99\n        \n        x_start = np.concatenate([p.flatten(), [s]])\n        \n        try:\n            res = minimize(objective, x_start, method='SLSQP', jac=obj_jac, constraints=nlc, options=opts)\n            if res.x[-1] > best_s:\n                best_s = res.x[-1]\n                best_x = res.x\n        except Exception:\n            continue\n\n    # Extract final coordinates\n    final_points = best_x[:-1].reshape((N, DIM))\n    \n    # Center for cleanliness\n    final_points -= np.mean(final_points, axis=0)\n    \n    return final_points\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:15:10.058619",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 272,
        "candidates_token_count": 2177,
        "thoughts_token_count": 10352
      },
      "response_text_len": 6301
    }
  }
}