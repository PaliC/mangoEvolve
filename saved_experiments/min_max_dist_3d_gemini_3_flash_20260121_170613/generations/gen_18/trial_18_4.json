{
  "trial_id": "trial_18_4",
  "generation": 18,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a 1-6-6-1 shell structure as initialization and optimizes with high-precision SLSQP \n    with a slack variable for the minimum squared distance.\n    \"\"\"\n    \n    def get_initial_pts():\n        # Initialize with a 1-6-6-1 shell structure.\n        # This structure is common for 14-point packing problems.\n        pts = []\n        pts.append([0, 0, 1.0])  # 1 point at the top\n        for i in range(6):      # 6 points in the upper ring\n            a = 2 * np.pi * i / 6\n            pts.append([0.7 * np.cos(a), 0.7 * np.sin(a), 0.4])\n        for i in range(6):      # 6 points in the lower ring (staggered)\n            a = 2 * np.pi * i / 6 + np.pi / 6\n            pts.append([0.7 * np.cos(a), 0.7 * np.sin(a), -0.4])\n        pts.append([0, 0, -1.0]) # 1 point at the bottom\n        pts = np.array(pts)\n        \n        # Add small random noise to break symmetry and allow the optimizer to explore\n        np.random.seed(42)\n        pts += np.random.normal(0, 0.01, pts.shape)\n        \n        # Normalize so the initial max distance is 1.0\n        d2 = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n        pts /= np.sqrt(np.max(d2))\n        return pts\n\n    # Initial points and initial slack variable s (min distance squared)\n    pts = get_initial_pts()\n    d2 = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n    s_start = np.min(d2[d2 > 0])\n    \n    # x0 contains coordinates of 14 points (42 values) and the slack variable s\n    x0 = np.concatenate([pts.flatten(), [s_start]])\n\n    def objective(x):\n        # Maximize s, which is equivalent to minimizing -s\n        return -x[42]\n\n    def objective_jac(x):\n        j = np.zeros(43)\n        j[42] = -1\n        return j\n\n    def min_dists_fun(x):\n        # Constraint: dist_ij^2 >= s  =>  dist_ij^2 - s >= 0\n        p = x[:42].reshape((14, 3))\n        s = x[42]\n        d = []\n        for i in range(14):\n            for j in range(i + 1, 14):\n                d.append(np.sum((p[i] - p[j])**2) - s)\n        return np.array(d)\n\n    def min_dists_jac(x):\n        # Jacobian for the min-distance constraints\n        p = x[:42].reshape((14, 3))\n        j = np.zeros((91, 43))\n        r = 0\n        for i in range(14):\n            for j in range(i + 1, 14):\n                diff = p[i] - p[j]\n                j[r, 3*i : 3*i+3] = 2 * diff\n                j[r, 3*j : 3*j+3] = -2 * diff\n                j[r, 42] = -1\n                r += 1\n        return j\n\n    def max_dists_fun(x):\n        # Constraint: dist_ij^2 <= 1  =>  1 - dist_ij^2 >= 0\n        p = x[:42].reshape((14, 3))\n        d = []\n        for i in range(14):\n            for j in range(i + 1, 14):\n                d.append(1.0 - np.sum((p[i] - p[j])**2))\n        return np.array(d)\n\n    def max_dists_jac(x):\n        # Jacobian for the max-distance constraints\n        p = x[:42].reshape((14, 3))\n        j = np.zeros((91, 43))\n        r = 0\n        for i in range(14):\n            for j in range(i + 1, 14):\n                diff = p[i] - p[j]\n                j[r, 3*i : 3*i+3] = -2 * diff\n                j[r, 3*j : 3*j+3] = 2 * diff\n                r += 1\n        return j\n\n    # Define constraints for SLSQP\n    cons = [\n        {'type': 'ineq', 'fun': min_dists_fun, 'jac': min_dists_jac},\n        {'type': 'ineq', 'fun': max_dists_fun, 'jac': max_dists_jac}\n    ]\n\n    # Run high-precision SLSQP optimization\n    res = minimize(objective, x0, jac=objective_jac, constraints=cons, method='SLSQP', \n                   options={'maxiter': 500, 'ftol': 1e-10})\n    \n    # Extract final points and normalize to ensure max distance is exactly 1.0\n    final_pts = res.x[:42].reshape((14, 3))\n    d2_final = np.sum((final_pts[:, None, :] - final_pts[None, :, :])**2, axis=-1)\n    final_pts /= np.sqrt(np.max(d2_final))\n    \n    return final_pts",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.30201220512390137,
    "error": "TypeError: 'int' object does not support item assignment"
  },
  "prompt": "Try a different geometric initialization: the 1-6-6-1 shell structure. Optimize it with high-precision SLSQP and slack variables.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a 1-6-6-1 shell structure as initialization and optimizes with high-precision SLSQP \n    with a slack variable for the minimum squared distance.\n    \"\"\"\n    \n    def get_initial_pts():\n        # Initialize with a 1-6-6-1 shell structure.\n        # This structure is common for 14-point packing problems.\n        pts = []\n        pts.append([0, 0, 1.0])  # 1 point at the top\n        for i in range(6):      # 6 points in the upper ring\n            a = 2 * np.pi * i / 6\n            pts.append([0.7 * np.cos(a), 0.7 * np.sin(a), 0.4])\n        for i in range(6):      # 6 points in the lower ring (staggered)\n            a = 2 * np.pi * i / 6 + np.pi / 6\n            pts.append([0.7 * np.cos(a), 0.7 * np.sin(a), -0.4])\n        pts.append([0, 0, -1.0]) # 1 point at the bottom\n        pts = np.array(pts)\n        \n        # Add small random noise to break symmetry and allow the optimizer to explore\n        np.random.seed(42)\n        pts += np.random.normal(0, 0.01, pts.shape)\n        \n        # Normalize so the initial max distance is 1.0\n        d2 = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n        pts /= np.sqrt(np.max(d2))\n        return pts\n\n    # Initial points and initial slack variable s (min distance squared)\n    pts = get_initial_pts()\n    d2 = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n    s_start = np.min(d2[d2 > 0])\n    \n    # x0 contains coordinates of 14 points (42 values) and the slack variable s\n    x0 = np.concatenate([pts.flatten(), [s_start]])\n\n    def objective(x):\n        # Maximize s, which is equivalent to minimizing -s\n        return -x[42]\n\n    def objective_jac(x):\n        j = np.zeros(43)\n        j[42] = -1\n        return j\n\n    def min_dists_fun(x):\n        # Constraint: dist_ij^2 >= s  =>  dist_ij^2 - s >= 0\n        p = x[:42].reshape((14, 3))\n        s = x[42]\n        d = []\n        for i in range(14):\n            for j in range(i + 1, 14):\n                d.append(np.sum((p[i] - p[j])**2) - s)\n        return np.array(d)\n\n    def min_dists_jac(x):\n        # Jacobian for the min-distance constraints\n        p = x[:42].reshape((14, 3))\n        j = np.zeros((91, 43))\n        r = 0\n        for i in range(14):\n            for j in range(i + 1, 14):\n                diff = p[i] - p[j]\n                j[r, 3*i : 3*i+3] = 2 * diff\n                j[r, 3*j : 3*j+3] = -2 * diff\n                j[r, 42] = -1\n                r += 1\n        return j\n\n    def max_dists_fun(x):\n        # Constraint: dist_ij^2 <= 1  =>  1 - dist_ij^2 >= 0\n        p = x[:42].reshape((14, 3))\n        d = []\n        for i in range(14):\n            for j in range(i + 1, 14):\n                d.append(1.0 - np.sum((p[i] - p[j])**2))\n        return np.array(d)\n\n    def max_dists_jac(x):\n        # Jacobian for the max-distance constraints\n        p = x[:42].reshape((14, 3))\n        j = np.zeros((91, 43))\n        r = 0\n        for i in range(14):\n            for j in range(i + 1, 14):\n                diff = p[i] - p[j]\n                j[r, 3*i : 3*i+3] = -2 * diff\n                j[r, 3*j : 3*j+3] = 2 * diff\n                r += 1\n        return j\n\n    # Define constraints for SLSQP\n    cons = [\n        {'type': 'ineq', 'fun': min_dists_fun, 'jac': min_dists_jac},\n        {'type': 'ineq', 'fun': max_dists_fun, 'jac': max_dists_jac}\n    ]\n\n    # Run high-precision SLSQP optimization\n    res = minimize(objective, x0, jac=objective_jac, constraints=cons, method='SLSQP', \n                   options={'maxiter': 500, 'ftol': 1e-10})\n    \n    # Extract final points and normalize to ensure max distance is exactly 1.0\n    final_pts = res.x[:42].reshape((14, 3))\n    d2_final = np.sum((final_pts[:, None, :] - final_pts[None, :, :])**2, axis=-1)\n    final_pts /= np.sqrt(np.max(d2_final))\n    \n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T18:49:17.888508",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 202,
        "candidates_token_count": 1453,
        "thoughts_token_count": 23501
      },
      "response_text_len": 4001
    }
  }
}