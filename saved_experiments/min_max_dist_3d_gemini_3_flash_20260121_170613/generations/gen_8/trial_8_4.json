{
  "trial_id": "trial_8_4",
  "generation": 8,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min distance / max distance)^2.\n    The approach uses multiple initial configurations optimized with SLSQP and polished\n    with the trust-constr method for high precision.\n    \"\"\"\n    N = 14\n    dim = 3\n\n    def get_dist_sq_matrix(p):\n        \"\"\"Compute the squared distance matrix for a set of points.\"\"\"\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        return np.sum(diff**2, axis=-1)\n\n    def objective(x):\n        \"\"\"Objective function to minimize: the negative of the squared minimum distance.\"\"\"\n        # x is [pts.flatten(), t]\n        return -x[-1]\n\n    def constraints_fn(x):\n        \"\"\"Combined constraints: min distance >= t and max distance <= 1.0.\"\"\"\n        p = x[:-1].reshape((N, dim))\n        t = x[-1]\n        dist_sq = get_dist_sq_matrix(p)\n        indices = np.triu_indices(N, k=1)\n        dists = dist_sq[indices]\n        # dists - t >= 0 (min pairwise distance constraint)\n        # 1.0 - dists >= 0 (max pairwise distance constraint)\n        return np.concatenate([dists - t, 1.0 - dists])\n\n    best_x = None\n    best_val = -1\n\n    def get_1661():\n        \"\"\"Generates a structured 1-6-6-1 configuration on a sphere.\"\"\"\n        pts = []\n        pts.append([0, 0, 0.5])\n        for i in range(6):\n            phi = 2 * np.pi * i / 6\n            pts.append([0.4 * np.cos(phi), 0.4 * np.sin(phi), 0.25])\n        for i in range(6):\n            phi = 2 * np.pi * (i + 0.5) / 6\n            pts.append([0.4 * np.cos(phi), 0.4 * np.sin(phi), -0.25])\n        pts.append([0, 0, -0.5])\n        return np.array(pts)\n\n    # Initial starting configurations: one structured and several random\n    starts = [get_1661()]\n    for seed in [12, 42, 123]:\n        np.random.seed(seed)\n        starts.append(np.random.uniform(-0.5, 0.5, (N, dim)))\n\n    # Optimization Phase 1: Coarse search with SLSQP\n    for pts in starts:\n        dist_sq_init = get_dist_sq_matrix(pts)\n        # Initial guess for t (min squared distance)\n        t_init = np.min(dist_sq_init + np.eye(N) * 10)\n        x0 = np.concatenate([pts.flatten(), [t_init]])\n\n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints_fn},\n                       options={'maxiter': 300, 'ftol': 1e-8})\n        \n        if -res.fun > best_val:\n            best_val = -res.fun\n            best_x = res.x\n\n    # Optimization Phase 2: Refinement and Polishing\n    if best_x is not None:\n        # Further refine using SLSQP with tighter tolerance\n        res_slsqp = minimize(objective, best_x, method='SLSQP', \n                             constraints={'type': 'ineq', 'fun': constraints_fn},\n                             options={'maxiter': 500, 'ftol': 1e-12})\n        best_x = res_slsqp.x\n        best_val = -res_slsqp.fun\n        \n        # Final polishing with trust-constr for high precision boundaries\n        try:\n            nlc = NonlinearConstraint(constraints_fn, 0, np.inf)\n            res_tc = minimize(objective, best_x, method='trust-constr',\n                              constraints=nlc,\n                              options={'maxiter': 150, 'xtol': 1e-11, 'gtol': 1e-11, 'barrier_tol': 1e-11})\n            if -res_tc.fun > best_val:\n                best_x = res_tc.x\n        except Exception:\n            # If trust-constr fails, fallback to the best SLSQP result\n            pass\n\n    # Extract final points and normalize\n    final_pts = best_x[:-1].reshape((N, dim))\n    \n    # Scale to ensure the maximum pairwise distance is exactly 1.0\n    dist_sq = get_dist_sq_matrix(final_pts)\n    d_max_sq = np.max(dist_sq)\n    final_pts = final_pts / np.sqrt(d_max_sq)\n    \n    return final_pts",
  "metrics": {
    "valid": true,
    "score": 0.9994307202867223,
    "min_max_ratio": 0.23991040872471345,
    "min_distance": 0.48980650130915326,
    "max_distance": 1.0000000000000002,
    "eval_time": 0.828449010848999,
    "error": null
  },
  "prompt": "Try a different approach for the final 'polishing' phase. After reaching the 1.0000159 plateau with SLSQP, switch to the 'trust-constr' method in scipy with very tight barriers and tolerances. Sometimes different solvers can move further along the constraint boundary.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min distance / max distance)^2.\n    The approach uses multiple initial configurations optimized with SLSQP and polished\n    with the trust-constr method for high precision.\n    \"\"\"\n    N = 14\n    dim = 3\n\n    def get_dist_sq_matrix(p):\n        \"\"\"Compute the squared distance matrix for a set of points.\"\"\"\n        diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n        return np.sum(diff**2, axis=-1)\n\n    def objective(x):\n        \"\"\"Objective function to minimize: the negative of the squared minimum distance.\"\"\"\n        # x is [pts.flatten(), t]\n        return -x[-1]\n\n    def constraints_fn(x):\n        \"\"\"Combined constraints: min distance >= t and max distance <= 1.0.\"\"\"\n        p = x[:-1].reshape((N, dim))\n        t = x[-1]\n        dist_sq = get_dist_sq_matrix(p)\n        indices = np.triu_indices(N, k=1)\n        dists = dist_sq[indices]\n        # dists - t >= 0 (min pairwise distance constraint)\n        # 1.0 - dists >= 0 (max pairwise distance constraint)\n        return np.concatenate([dists - t, 1.0 - dists])\n\n    best_x = None\n    best_val = -1\n\n    def get_1661():\n        \"\"\"Generates a structured 1-6-6-1 configuration on a sphere.\"\"\"\n        pts = []\n        pts.append([0, 0, 0.5])\n        for i in range(6):\n            phi = 2 * np.pi * i / 6\n            pts.append([0.4 * np.cos(phi), 0.4 * np.sin(phi), 0.25])\n        for i in range(6):\n            phi = 2 * np.pi * (i + 0.5) / 6\n            pts.append([0.4 * np.cos(phi), 0.4 * np.sin(phi), -0.25])\n        pts.append([0, 0, -0.5])\n        return np.array(pts)\n\n    # Initial starting configurations: one structured and several random\n    starts = [get_1661()]\n    for seed in [12, 42, 123]:\n        np.random.seed(seed)\n        starts.append(np.random.uniform(-0.5, 0.5, (N, dim)))\n\n    # Optimization Phase 1: Coarse search with SLSQP\n    for pts in starts:\n        dist_sq_init = get_dist_sq_matrix(pts)\n        # Initial guess for t (min squared distance)\n        t_init = np.min(dist_sq_init + np.eye(N) * 10)\n        x0 = np.concatenate([pts.flatten(), [t_init]])\n\n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints_fn},\n                       options={'maxiter': 300, 'ftol': 1e-8})\n        \n        if -res.fun > best_val:\n            best_val = -res.fun\n            best_x = res.x\n\n    # Optimization Phase 2: Refinement and Polishing\n    if best_x is not None:\n        # Further refine using SLSQP with tighter tolerance\n        res_slsqp = minimize(objective, best_x, method='SLSQP', \n                             constraints={'type': 'ineq', 'fun': constraints_fn},\n                             options={'maxiter': 500, 'ftol': 1e-12})\n        best_x = res_slsqp.x\n        best_val = -res_slsqp.fun\n        \n        # Final polishing with trust-constr for high precision boundaries\n        try:\n            nlc = NonlinearConstraint(constraints_fn, 0, np.inf)\n            res_tc = minimize(objective, best_x, method='trust-constr',\n                              constraints=nlc,\n                              options={'maxiter': 150, 'xtol': 1e-11, 'gtol': 1e-11, 'barrier_tol': 1e-11})\n            if -res_tc.fun > best_val:\n                best_x = res_tc.x\n        except Exception:\n            # If trust-constr fails, fallback to the best SLSQP result\n            pass\n\n    # Extract final points and normalize\n    final_pts = best_x[:-1].reshape((N, dim))\n    \n    # Scale to ensure the maximum pairwise distance is exactly 1.0\n    dist_sq = get_dist_sq_matrix(final_pts)\n    d_max_sq = np.max(dist_sq)\n    final_pts = final_pts / np.sqrt(d_max_sq)\n    \n    return final_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:52:41.441975",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 232,
        "candidates_token_count": 1226,
        "thoughts_token_count": 15166
      },
      "response_text_len": 3841
    }
  }
}