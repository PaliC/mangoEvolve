{
  "trial_id": "trial_8_5",
  "generation": 8,
  "parent_id": "trial_4_8",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The strategy uses a LogSumExp approximation for the minimum and maximum squared distances\n    and optimizes the ratio using the L-BFGS-B algorithm.\n    \"\"\"\n    \n    def objective_and_grad(coords, k):\n        # Reshape coordinates to (14 points, 3 dimensions)\n        X = coords.reshape((14, 3))\n        \n        # Compute all pairwise squared distances\n        # diff shape: (14, 14, 3)\n        diff = X[:, np.newaxis, :] - X[np.newaxis, :, :]\n        # d2 shape: (14, 14)\n        d2 = np.sum(diff**2, axis=2)\n        \n        # Extract upper triangle indices for unique pairs\n        iu = np.triu_indices(14, k=1)\n        d2_flat = d2[iu]\n        \n        # LogSumExp approximation for minimum distance\n        min_val = np.min(d2_flat)\n        exp_min = np.exp(-k * (d2_flat - min_val))\n        sum_exp_min = np.sum(exp_min)\n        soft_min = min_val - (1.0 / k) * np.log(sum_exp_min)\n        \n        # LogSumExp approximation for maximum distance\n        max_val = np.max(d2_flat)\n        exp_max = np.exp(k * (d2_flat - max_val))\n        sum_exp_max = np.sum(exp_max)\n        soft_max = max_val + (1.0 / k) * np.log(sum_exp_max)\n        \n        # Smooth objective: minimize log(max_dist^2 / min_dist^2)\n        # This is equivalent to maximizing (min_dist / max_dist)^2\n        s_min = max(soft_min, 1e-12)\n        s_max = max(soft_max, 1e-12)\n        obj = np.log(s_max) - np.log(s_min)\n        \n        # Gradient computation\n        d_soft_max_d_d2_flat = exp_max / sum_exp_max\n        d_soft_min_d_d2_flat = exp_min / sum_exp_min\n        \n        # Derivative of objective with respect to each d_ij^2\n        d_obj_d_d2_flat = (1.0 / s_max) * d_soft_max_d_d2_flat - (1.0 / s_min) * d_soft_min_d_d2_flat\n        \n        # Full symmetric matrix of derivatives d(obj)/d(d2_ij)\n        d_obj_d_d2 = np.zeros((14, 14))\n        d_obj_d_d2[iu] = d_obj_d_d2_flat\n        d_obj_d_d2 += d_obj_d_d2.T\n        \n        # Backpropagate to coordinates: grad_i = sum_j [ d(obj)/d(d2_ij) * 2 * (X_i - X_j) ]\n        grad = 2 * np.sum(d_obj_d_d2[:, :, np.newaxis] * diff, axis=1)\n        \n        return obj, grad.flatten()\n\n    best_ratio_sq = 0\n    best_coords = None\n    start_time = time.time()\n    \n    # Generate diverse initial seeds\n    seeds = []\n    # 1. Random seeds in a cube\n    for _ in range(12):\n        seeds.append(np.random.rand(14 * 3) * 2 - 1)\n    # 2. Random seeds on a sphere\n    for _ in range(5):\n        pts = np.random.randn(14, 3)\n        pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        seeds.append(pts.flatten())\n    \n    # 3. Manual seed: Cube + face centers (14 points)\n    cube_face = []\n    for x in [-1, 1]:\n        for y in [-1, 1]:\n            for z in [-1, 1]:\n                cube_face.append([x, y, z])\n    cube_face.extend([[1.2, 0, 0], [-1.2, 0, 0], [0, 1.2, 0], [0, -1.2, 0], [0, 0, 1.2], [0, 0, -1.2]])\n    seeds.append(np.array(cube_face).flatten())\n\n    # 4. Manual seed: Hexagonal prism + 2 caps (14 points)\n    hex_prism = []\n    h = 0.8\n    for i in range(6):\n        angle = i * np.pi / 3\n        hex_prism.append([np.cos(angle), np.sin(angle), h])\n        hex_prism.append([np.cos(angle), np.sin(angle), -h])\n    hex_prism.extend([[0, 0, 1.5], [0, 0, -1.5]])\n    seeds.append(np.array(hex_prism).flatten())\n\n    # Optimization loop\n    for coords in seeds:\n        # Check time constraint\n        if time.time() - start_time > 55:\n            break\n        \n        try:\n            # First pass: coarse optimization with moderate k\n            res = minimize(objective_and_grad, coords, args=(100,), method='L-BFGS-B', jac=True, tol=1e-7)\n            # Second pass: refinement with large k\n            res = minimize(objective_and_grad, res.x, args=(1000,), method='L-BFGS-B', jac=True, tol=1e-9)\n            \n            # Evaluate current result\n            X = res.x.reshape((14, 3))\n            d2 = np.sum((X[:, np.newaxis, :] - X[np.newaxis, :, :])**2, axis=2)\n            d2_flat = d2[np.triu_indices(14, k=1)]\n            ratio_sq = np.min(d2_flat) / np.max(d2_flat)\n            \n            if ratio_sq > best_ratio_sq:\n                best_ratio_sq = ratio_sq\n                best_coords = X\n        except:\n            continue\n    \n    # Scale coordinates so that the maximum distance is exactly 1\n    # This satisfies the max(d_ij^2) <= 1 constraint without changing the ratio\n    d2 = np.sum((best_coords[:, np.newaxis, :] - best_coords[np.newaxis, :, :])**2, axis=2)\n    best_coords /= np.sqrt(np.max(d2))\n    \n    return best_coords",
  "metrics": {
    "valid": true,
    "score": 1.0000151440437297,
    "min_max_ratio": 0.24005069793092462,
    "min_distance": 0.4899496891834146,
    "max_distance": 0.9999999999999999,
    "eval_time": 1.929567813873291,
    "error": null
  },
  "prompt": "The ratio (min/max)^2 is being maximized. Instead of the slack variable 's', try using a LogSumExp approximation of the min distance: Objective = - (1/k) * log(sum(exp(-k * d_ij^2))) where k is very large (e.g., 1000). Combine this with a constraint that max(d_ij^2) <= 1. Solve using L-BFGS-B.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Place 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    The strategy uses a LogSumExp approximation for the minimum and maximum squared distances\n    and optimizes the ratio using the L-BFGS-B algorithm.\n    \"\"\"\n    \n    def objective_and_grad(coords, k):\n        # Reshape coordinates to (14 points, 3 dimensions)\n        X = coords.reshape((14, 3))\n        \n        # Compute all pairwise squared distances\n        # diff shape: (14, 14, 3)\n        diff = X[:, np.newaxis, :] - X[np.newaxis, :, :]\n        # d2 shape: (14, 14)\n        d2 = np.sum(diff**2, axis=2)\n        \n        # Extract upper triangle indices for unique pairs\n        iu = np.triu_indices(14, k=1)\n        d2_flat = d2[iu]\n        \n        # LogSumExp approximation for minimum distance\n        min_val = np.min(d2_flat)\n        exp_min = np.exp(-k * (d2_flat - min_val))\n        sum_exp_min = np.sum(exp_min)\n        soft_min = min_val - (1.0 / k) * np.log(sum_exp_min)\n        \n        # LogSumExp approximation for maximum distance\n        max_val = np.max(d2_flat)\n        exp_max = np.exp(k * (d2_flat - max_val))\n        sum_exp_max = np.sum(exp_max)\n        soft_max = max_val + (1.0 / k) * np.log(sum_exp_max)\n        \n        # Smooth objective: minimize log(max_dist^2 / min_dist^2)\n        # This is equivalent to maximizing (min_dist / max_dist)^2\n        s_min = max(soft_min, 1e-12)\n        s_max = max(soft_max, 1e-12)\n        obj = np.log(s_max) - np.log(s_min)\n        \n        # Gradient computation\n        d_soft_max_d_d2_flat = exp_max / sum_exp_max\n        d_soft_min_d_d2_flat = exp_min / sum_exp_min\n        \n        # Derivative of objective with respect to each d_ij^2\n        d_obj_d_d2_flat = (1.0 / s_max) * d_soft_max_d_d2_flat - (1.0 / s_min) * d_soft_min_d_d2_flat\n        \n        # Full symmetric matrix of derivatives d(obj)/d(d2_ij)\n        d_obj_d_d2 = np.zeros((14, 14))\n        d_obj_d_d2[iu] = d_obj_d_d2_flat\n        d_obj_d_d2 += d_obj_d_d2.T\n        \n        # Backpropagate to coordinates: grad_i = sum_j [ d(obj)/d(d2_ij) * 2 * (X_i - X_j) ]\n        grad = 2 * np.sum(d_obj_d_d2[:, :, np.newaxis] * diff, axis=1)\n        \n        return obj, grad.flatten()\n\n    best_ratio_sq = 0\n    best_coords = None\n    start_time = time.time()\n    \n    # Generate diverse initial seeds\n    seeds = []\n    # 1. Random seeds in a cube\n    for _ in range(12):\n        seeds.append(np.random.rand(14 * 3) * 2 - 1)\n    # 2. Random seeds on a sphere\n    for _ in range(5):\n        pts = np.random.randn(14, 3)\n        pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        seeds.append(pts.flatten())\n    \n    # 3. Manual seed: Cube + face centers (14 points)\n    cube_face = []\n    for x in [-1, 1]:\n        for y in [-1, 1]:\n            for z in [-1, 1]:\n                cube_face.append([x, y, z])\n    cube_face.extend([[1.2, 0, 0], [-1.2, 0, 0], [0, 1.2, 0], [0, -1.2, 0], [0, 0, 1.2], [0, 0, -1.2]])\n    seeds.append(np.array(cube_face).flatten())\n\n    # 4. Manual seed: Hexagonal prism + 2 caps (14 points)\n    hex_prism = []\n    h = 0.8\n    for i in range(6):\n        angle = i * np.pi / 3\n        hex_prism.append([np.cos(angle), np.sin(angle), h])\n        hex_prism.append([np.cos(angle), np.sin(angle), -h])\n    hex_prism.extend([[0, 0, 1.5], [0, 0, -1.5]])\n    seeds.append(np.array(hex_prism).flatten())\n\n    # Optimization loop\n    for coords in seeds:\n        # Check time constraint\n        if time.time() - start_time > 55:\n            break\n        \n        try:\n            # First pass: coarse optimization with moderate k\n            res = minimize(objective_and_grad, coords, args=(100,), method='L-BFGS-B', jac=True, tol=1e-7)\n            # Second pass: refinement with large k\n            res = minimize(objective_and_grad, res.x, args=(1000,), method='L-BFGS-B', jac=True, tol=1e-9)\n            \n            # Evaluate current result\n            X = res.x.reshape((14, 3))\n            d2 = np.sum((X[:, np.newaxis, :] - X[np.newaxis, :, :])**2, axis=2)\n            d2_flat = d2[np.triu_indices(14, k=1)]\n            ratio_sq = np.min(d2_flat) / np.max(d2_flat)\n            \n            if ratio_sq > best_ratio_sq:\n                best_ratio_sq = ratio_sq\n                best_coords = X\n        except:\n            continue\n    \n    # Scale coordinates so that the maximum distance is exactly 1\n    # This satisfies the max(d_ij^2) <= 1 constraint without changing the ratio\n    d2 = np.sum((best_coords[:, np.newaxis, :] - best_coords[np.newaxis, :, :])**2, axis=2)\n    best_coords /= np.sqrt(np.max(d2))\n    \n    return best_coords\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:53:39.361724",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 270,
        "candidates_token_count": 1720,
        "thoughts_token_count": 22261
      },
      "response_text_len": 4741
    }
  }
}