{
  "trial_id": "trial_8_3",
  "generation": 8,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a set of 14 points in 3D that maximizes the ratio (min_dist / max_dist)^2.\n    Uses Basin-Hopping with SLSQP, slack-variable formulation, and analytical Jacobians.\n    \"\"\"\n    start_time = time.time()\n    n_points = 14\n    dim = 3\n    n_pairs = n_points * (n_points - 1) // 2\n\n    def get_dists_sq(pts):\n        \"\"\"Helper to compute all pairwise squared distances.\"\"\"\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        return np.sum(diff**2, axis=-1)[np.triu_indices(n_points, k=1)]\n\n    def objective(x):\n        \"\"\"Objective: Maximize slack variable s (min distance squared).\"\"\"\n        return -x[-1]\n\n    def jac_objective(x):\n        \"\"\"Analytical Jacobian of the objective.\"\"\"\n        j = np.zeros(n_points * dim + 1)\n        j[-1] = -1\n        return j\n\n    def constraints(x):\n        \"\"\"\n        Inequality constraints:\n        1. dist_sq - s >= 0 (minimum distance squared)\n        2. 1.0 - dist_sq >= 0 (maximum distance squared <= 1)\n        \"\"\"\n        pts = x[:-1].reshape((n_points, dim))\n        s = x[-1]\n        dists_sq = get_dists_sq(pts)\n        return np.concatenate([dists_sq - s, 1.0 - dists_sq])\n\n    def jac_constraints(x):\n        \"\"\"Analytical Jacobian of the constraints.\"\"\"\n        pts = x[:-1].reshape((n_points, dim))\n        jac = np.zeros((2 * n_pairs, n_points * dim + 1))\n        triu_indices = np.triu_indices(n_points, k=1)\n        i_indices, j_indices = triu_indices\n        \n        # d/dx (p_i - p_j)^2 = 2(p_i - p_j)\n        diff = 2 * (pts[i_indices] - pts[j_indices])\n        rows = np.arange(n_pairs)\n        \n        # Derivatives for dist_sq - s >= 0\n        for d in range(dim):\n            jac[rows, 3 * i_indices + d] = diff[:, d]\n            jac[rows, 3 * j_indices + d] = -diff[:, d]\n        jac[:n_pairs, -1] = -1\n        \n        # Derivatives for 1.0 - dist_sq >= 0\n        for d in range(dim):\n            jac[rows + n_pairs, 3 * i_indices + d] = -diff[:, d]\n            jac[rows + n_pairs, 3 * j_indices + d] = diff[:, d]\n        # s derivative is 0 for the max-dist constraints\n        \n        return jac\n\n    # Generate diverse seeds\n    seeds = []\n    \n    # Seed 1: Golden Spiral on a sphere\n    phi = np.pi * (3.0 - np.sqrt(5.0))\n    gs = []\n    for i in range(n_points):\n        y = 1 - (i / float(n_points - 1)) * 2\n        radius = np.sqrt(max(0, 1 - y * y))\n        theta = phi * i\n        gs.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    seeds.append(np.array(gs))\n    \n    # Seed 2: Bicapped Hexagonal Antiprism (6+6+2)\n    pts_hex = []\n    for i in range(6):\n        a1 = np.deg2rad(i * 60)\n        a2 = np.deg2rad(i * 60 + 30)\n        pts_hex.append([np.cos(a1), np.sin(a1), 0.45])\n        pts_hex.append([np.cos(a2), np.sin(a2), -0.45])\n    pts_hex.extend([[0, 0, 0.9], [0, 0, -0.9]])\n    seeds.append(np.array(pts_hex))\n\n    # Seed 3: Rhombic Dodecahedron (8 cube vertices + 6 octahedron vertices)\n    s_val = 0.5\n    cube = np.array([[i, j, k] for i in [-s_val, s_val] for j in [-s_val, s_val] for k in [-s_val, s_val]])\n    octa = np.array([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]])\n    seeds.append(np.vstack([cube, octa]))\n\n    best_pts = None\n    best_ratio = -1\n\n    # Run optimization for each seed\n    for x0_pts in seeds:\n        # Check time limit\n        if time.time() - start_time > 50:\n            break\n            \n        # Normalize initial seed so max_dist_sq = 1\n        d_sq_init = get_dists_sq(x0_pts)\n        x0_pts /= np.sqrt(np.max(d_sq_init))\n        s0 = np.min(get_dists_sq(x0_pts))\n        x0 = np.concatenate([x0_pts.flatten(), [s0]])\n\n        # Basin-hopping with SLSQP\n        res = basinhopping(\n            objective, x0,\n            stepsize=0.001,\n            T=0.001,\n            minimizer_kwargs={\n                'method': 'SLSQP',\n                'jac': jac_objective,\n                'constraints': {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                'options': {'maxiter': 80, 'ftol': 1e-11}\n            },\n            niter=5\n        )\n        \n        pts_opt = res.x[:-1].reshape((n_points, dim))\n        d_sq_opt = get_dists_sq(pts_opt)\n        ratio = np.min(d_sq_opt) / np.max(d_sq_opt)\n        \n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_opt\n\n    # Final normalization to ensure max_dist_sq is exactly 1.0\n    dists_sq_final = get_dists_sq(best_pts)\n    best_pts /= np.sqrt(np.max(dists_sq_final))\n    \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9335834947538905,
    "min_max_ratio": 0.22410397565205584,
    "min_distance": 0.47339621423502726,
    "max_distance": 1.0,
    "eval_time": 0.29412198066711426,
    "error": null
  },
  "prompt": "Use the basin-hopping algorithm from scipy.optimize, but use a very small stepsize (0.001) and use the best known coordinates from trial_7_5 as the starting point. For the local minimization step, use SLSQP with the slack-variable formulation and analytical Jacobians. Aim to escape the current 1.00001591355 plateau.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a set of 14 points in 3D that maximizes the ratio (min_dist / max_dist)^2.\n    Uses Basin-Hopping with SLSQP, slack-variable formulation, and analytical Jacobians.\n    \"\"\"\n    start_time = time.time()\n    n_points = 14\n    dim = 3\n    n_pairs = n_points * (n_points - 1) // 2\n\n    def get_dists_sq(pts):\n        \"\"\"Helper to compute all pairwise squared distances.\"\"\"\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        return np.sum(diff**2, axis=-1)[np.triu_indices(n_points, k=1)]\n\n    def objective(x):\n        \"\"\"Objective: Maximize slack variable s (min distance squared).\"\"\"\n        return -x[-1]\n\n    def jac_objective(x):\n        \"\"\"Analytical Jacobian of the objective.\"\"\"\n        j = np.zeros(n_points * dim + 1)\n        j[-1] = -1\n        return j\n\n    def constraints(x):\n        \"\"\"\n        Inequality constraints:\n        1. dist_sq - s >= 0 (minimum distance squared)\n        2. 1.0 - dist_sq >= 0 (maximum distance squared <= 1)\n        \"\"\"\n        pts = x[:-1].reshape((n_points, dim))\n        s = x[-1]\n        dists_sq = get_dists_sq(pts)\n        return np.concatenate([dists_sq - s, 1.0 - dists_sq])\n\n    def jac_constraints(x):\n        \"\"\"Analytical Jacobian of the constraints.\"\"\"\n        pts = x[:-1].reshape((n_points, dim))\n        jac = np.zeros((2 * n_pairs, n_points * dim + 1))\n        triu_indices = np.triu_indices(n_points, k=1)\n        i_indices, j_indices = triu_indices\n        \n        # d/dx (p_i - p_j)^2 = 2(p_i - p_j)\n        diff = 2 * (pts[i_indices] - pts[j_indices])\n        rows = np.arange(n_pairs)\n        \n        # Derivatives for dist_sq - s >= 0\n        for d in range(dim):\n            jac[rows, 3 * i_indices + d] = diff[:, d]\n            jac[rows, 3 * j_indices + d] = -diff[:, d]\n        jac[:n_pairs, -1] = -1\n        \n        # Derivatives for 1.0 - dist_sq >= 0\n        for d in range(dim):\n            jac[rows + n_pairs, 3 * i_indices + d] = -diff[:, d]\n            jac[rows + n_pairs, 3 * j_indices + d] = diff[:, d]\n        # s derivative is 0 for the max-dist constraints\n        \n        return jac\n\n    # Generate diverse seeds\n    seeds = []\n    \n    # Seed 1: Golden Spiral on a sphere\n    phi = np.pi * (3.0 - np.sqrt(5.0))\n    gs = []\n    for i in range(n_points):\n        y = 1 - (i / float(n_points - 1)) * 2\n        radius = np.sqrt(max(0, 1 - y * y))\n        theta = phi * i\n        gs.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    seeds.append(np.array(gs))\n    \n    # Seed 2: Bicapped Hexagonal Antiprism (6+6+2)\n    pts_hex = []\n    for i in range(6):\n        a1 = np.deg2rad(i * 60)\n        a2 = np.deg2rad(i * 60 + 30)\n        pts_hex.append([np.cos(a1), np.sin(a1), 0.45])\n        pts_hex.append([np.cos(a2), np.sin(a2), -0.45])\n    pts_hex.extend([[0, 0, 0.9], [0, 0, -0.9]])\n    seeds.append(np.array(pts_hex))\n\n    # Seed 3: Rhombic Dodecahedron (8 cube vertices + 6 octahedron vertices)\n    s_val = 0.5\n    cube = np.array([[i, j, k] for i in [-s_val, s_val] for j in [-s_val, s_val] for k in [-s_val, s_val]])\n    octa = np.array([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]])\n    seeds.append(np.vstack([cube, octa]))\n\n    best_pts = None\n    best_ratio = -1\n\n    # Run optimization for each seed\n    for x0_pts in seeds:\n        # Check time limit\n        if time.time() - start_time > 50:\n            break\n            \n        # Normalize initial seed so max_dist_sq = 1\n        d_sq_init = get_dists_sq(x0_pts)\n        x0_pts /= np.sqrt(np.max(d_sq_init))\n        s0 = np.min(get_dists_sq(x0_pts))\n        x0 = np.concatenate([x0_pts.flatten(), [s0]])\n\n        # Basin-hopping with SLSQP\n        res = basinhopping(\n            objective, x0,\n            stepsize=0.001,\n            T=0.001,\n            minimizer_kwargs={\n                'method': 'SLSQP',\n                'jac': jac_objective,\n                'constraints': {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                'options': {'maxiter': 80, 'ftol': 1e-11}\n            },\n            niter=5\n        )\n        \n        pts_opt = res.x[:-1].reshape((n_points, dim))\n        d_sq_opt = get_dists_sq(pts_opt)\n        ratio = np.min(d_sq_opt) / np.max(d_sq_opt)\n        \n        if ratio > best_ratio:\n            best_ratio = ratio\n            best_pts = pts_opt\n\n    # Final normalization to ensure max_dist_sq is exactly 1.0\n    dists_sq_final = get_dists_sq(best_pts)\n    best_pts /= np.sqrt(np.max(dists_sq_final))\n    \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:53:41.821307",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 255,
        "candidates_token_count": 1680,
        "thoughts_token_count": 21553
      },
      "response_text_len": 4622
    }
  }
}