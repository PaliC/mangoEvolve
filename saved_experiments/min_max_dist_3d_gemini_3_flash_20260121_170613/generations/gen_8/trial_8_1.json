{
  "trial_id": "trial_8_1",
  "generation": 8,
  "parent_id": "trial_7_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximize the squared ratio (min pairwise distance / max pairwise distance)^2\n    for 14 points in 3D space.\n    \n    Strategy:\n    - Initialize points using a Fibonacci spiral on a sphere for even distribution.\n    - Multi-start strategy with small perturbations (1e-6 noise).\n    - Refine configurations using SLSQP with extreme precision (ftol=1e-15).\n    - Use an analytical Jacobian for distances and objective function.\n    - Scale points so the maximum pairwise distance is 1, making the objective\n      equivalent to maximizing the minimum squared pairwise distance.\n    \"\"\"\n    N = 14\n    dim = 3\n    i_indices, j_indices = np.triu_indices(N, k=1)\n    num_pairs = len(i_indices)\n\n    def get_fibonacci_spiral(n):\n        \"\"\"Generates a Fibonacci spiral of n points on a unit sphere.\"\"\"\n        indices = np.arange(0, n, dtype=float) + 0.5\n        y = 1 - 2 * indices / n\n        radius = np.sqrt(1 - y * y)\n        phi = np.pi * (3.0 - np.sqrt(5.0))\n        theta = phi * indices\n        x = np.cos(theta) * radius\n        z = np.sin(theta) * radius\n        return np.stack([x, y, z], axis=1)\n\n    def objective(vars):\n        \"\"\"Minimize the negative of the squared minimum distance s.\"\"\"\n        return -vars[-1]\n\n    def constraints_func(vars):\n        \"\"\"\n        Constraints: \n        1. Pairwise distance squared minus s >= 0 (all distances >= min_dist)\n        2. 1.0 minus pairwise distance squared >= 0 (all distances <= max_dist = 1.0)\n        \"\"\"\n        pts = vars[:-1].reshape((N, dim))\n        s = vars[-1]\n        dists = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        d2 = np.sum(dists**2, axis=-1)\n        d2_triu = d2[i_indices, j_indices]\n        # All elements in the returned array must be >= 0 for SLSQP\n        return np.concatenate([d2_triu - s, 1.0 - d2_triu])\n\n    def jacobian_func(vars):\n        \"\"\"Analytical Jacobian for the 182 constraints.\"\"\"\n        pts = vars[:-1].reshape((N, dim))\n        jac = np.zeros((2 * num_pairs, N * dim + 1))\n        diff = 2 * (pts[i_indices] - pts[j_indices])\n        \n        for k in range(num_pairs):\n            i, j = i_indices[k], j_indices[k]\n            # Jacobian for d2_triu[k] - s >= 0\n            jac[k, 3*i : 3*i+3] = diff[k]\n            jac[k, 3*j : 3*j+3] = -diff[k]\n            jac[k, -1] = -1\n            \n            # Jacobian for 1.0 - d2_triu[k] >= 0\n            jac[num_pairs + k, 3*i : 3*i+3] = -diff[k]\n            jac[num_pairs + k, 3*j : 3*j+3] = diff[k]\n            # jac[num_pairs + k, -1] remains 0\n            \n        return jac\n\n    best_s = -1.0\n    best_pts = None\n    base_pts = get_fibonacci_spiral(N)\n    \n    # Run multi-start optimization\n    for seed in range(8):\n        np.random.seed(seed)\n        # Perturb Fibonacci initialization with very small amount of noise\n        pts_init = base_pts + np.random.normal(0, 1e-6, (N, dim))\n        \n        # Center points to improve numerical stability\n        pts_init -= np.mean(pts_init, axis=0)\n        \n        # Normalize pts_init so the maximum pairwise distance squared is 1.0\n        dists = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2_init = np.sum(dists**2, axis=-1)\n        max_d2 = np.max(d2_init)\n        pts_init /= np.sqrt(max_d2)\n        \n        # Recalculate initial s (minimum pairwise distance squared)\n        dists = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2_init = np.sum(dists**2, axis=-1)\n        s_init = np.min(d2_init[i_indices, j_indices])\n        \n        # Concatenate coordinates and s into a single variable vector\n        x0 = np.concatenate([pts_init.flatten(), [s_init]])\n        \n        # Solve using SLSQP with analytical Jacobian and high precision\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.concatenate([np.zeros(N*dim), [-1.0]]),\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n            options={'ftol': 1e-15, 'maxiter': 500}\n        )\n        \n        # Track the configuration with the highest s (min/max ratio squared)\n        if res.x[-1] > best_s:\n            best_s = res.x[-1]\n            best_pts = res.x[:-1].reshape((N, dim))\n            \n    # Return exactly 14 points in 3 dimensions\n    return best_pts if best_pts is not None else base_pts",
  "metrics": {
    "valid": true,
    "score": 0.9239026355008302,
    "min_max_ratio": 0.2217801138244528,
    "min_distance": 0.47093536055859386,
    "max_distance": 1.0,
    "eval_time": 0.41899681091308594,
    "error": null
  },
  "prompt": "The current best solutions for N=14 in 3D utilize a Fibonacci spiral initialization and SLSQP refinement to reach a score of 1.00001591355. Implement a multi-start strategy that perturbs the Fibonacci initialization with very small amounts of noise (1e-6) and runs SLSQP with extreme precision (ftol=1e-15). Ensure the analytical Jacobian is used for the distance constraints.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Maximize the squared ratio (min pairwise distance / max pairwise distance)^2\n    for 14 points in 3D space.\n    \n    Strategy:\n    - Initialize points using a Fibonacci spiral on a sphere for even distribution.\n    - Multi-start strategy with small perturbations (1e-6 noise).\n    - Refine configurations using SLSQP with extreme precision (ftol=1e-15).\n    - Use an analytical Jacobian for distances and objective function.\n    - Scale points so the maximum pairwise distance is 1, making the objective\n      equivalent to maximizing the minimum squared pairwise distance.\n    \"\"\"\n    N = 14\n    dim = 3\n    i_indices, j_indices = np.triu_indices(N, k=1)\n    num_pairs = len(i_indices)\n\n    def get_fibonacci_spiral(n):\n        \"\"\"Generates a Fibonacci spiral of n points on a unit sphere.\"\"\"\n        indices = np.arange(0, n, dtype=float) + 0.5\n        y = 1 - 2 * indices / n\n        radius = np.sqrt(1 - y * y)\n        phi = np.pi * (3.0 - np.sqrt(5.0))\n        theta = phi * indices\n        x = np.cos(theta) * radius\n        z = np.sin(theta) * radius\n        return np.stack([x, y, z], axis=1)\n\n    def objective(vars):\n        \"\"\"Minimize the negative of the squared minimum distance s.\"\"\"\n        return -vars[-1]\n\n    def constraints_func(vars):\n        \"\"\"\n        Constraints: \n        1. Pairwise distance squared minus s >= 0 (all distances >= min_dist)\n        2. 1.0 minus pairwise distance squared >= 0 (all distances <= max_dist = 1.0)\n        \"\"\"\n        pts = vars[:-1].reshape((N, dim))\n        s = vars[-1]\n        dists = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        d2 = np.sum(dists**2, axis=-1)\n        d2_triu = d2[i_indices, j_indices]\n        # All elements in the returned array must be >= 0 for SLSQP\n        return np.concatenate([d2_triu - s, 1.0 - d2_triu])\n\n    def jacobian_func(vars):\n        \"\"\"Analytical Jacobian for the 182 constraints.\"\"\"\n        pts = vars[:-1].reshape((N, dim))\n        jac = np.zeros((2 * num_pairs, N * dim + 1))\n        diff = 2 * (pts[i_indices] - pts[j_indices])\n        \n        for k in range(num_pairs):\n            i, j = i_indices[k], j_indices[k]\n            # Jacobian for d2_triu[k] - s >= 0\n            jac[k, 3*i : 3*i+3] = diff[k]\n            jac[k, 3*j : 3*j+3] = -diff[k]\n            jac[k, -1] = -1\n            \n            # Jacobian for 1.0 - d2_triu[k] >= 0\n            jac[num_pairs + k, 3*i : 3*i+3] = -diff[k]\n            jac[num_pairs + k, 3*j : 3*j+3] = diff[k]\n            # jac[num_pairs + k, -1] remains 0\n            \n        return jac\n\n    best_s = -1.0\n    best_pts = None\n    base_pts = get_fibonacci_spiral(N)\n    \n    # Run multi-start optimization\n    for seed in range(8):\n        np.random.seed(seed)\n        # Perturb Fibonacci initialization with very small amount of noise\n        pts_init = base_pts + np.random.normal(0, 1e-6, (N, dim))\n        \n        # Center points to improve numerical stability\n        pts_init -= np.mean(pts_init, axis=0)\n        \n        # Normalize pts_init so the maximum pairwise distance squared is 1.0\n        dists = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2_init = np.sum(dists**2, axis=-1)\n        max_d2 = np.max(d2_init)\n        pts_init /= np.sqrt(max_d2)\n        \n        # Recalculate initial s (minimum pairwise distance squared)\n        dists = pts_init[:, np.newaxis, :] - pts_init[np.newaxis, :, :]\n        d2_init = np.sum(dists**2, axis=-1)\n        s_init = np.min(d2_init[i_indices, j_indices])\n        \n        # Concatenate coordinates and s into a single variable vector\n        x0 = np.concatenate([pts_init.flatten(), [s_init]])\n        \n        # Solve using SLSQP with analytical Jacobian and high precision\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.concatenate([np.zeros(N*dim), [-1.0]]),\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n            options={'ftol': 1e-15, 'maxiter': 500}\n        )\n        \n        # Track the configuration with the highest s (min/max ratio squared)\n        if res.x[-1] > best_s:\n            best_s = res.x[-1]\n            best_pts = res.x[:-1].reshape((N, dim))\n            \n    # Return exactly 14 points in 3 dimensions\n    return best_pts if best_pts is not None else base_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:53:15.974116",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 266,
        "candidates_token_count": 1430,
        "thoughts_token_count": 20414
      },
      "response_text_len": 4440
    }
  }
}