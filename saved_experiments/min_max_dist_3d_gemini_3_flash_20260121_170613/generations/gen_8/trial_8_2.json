{
  "trial_id": "trial_8_2",
  "generation": 8,
  "parent_id": "trial_6_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min_dist / max_dist)^2.\n    Uses a bicapped hexagonal antiprism (D6d symmetry) as a starting point,\n    then refines all 42 coordinates using a non-linear optimizer.\n    \"\"\"\n    \n    def get_points_sym(params):\n        \"\"\"\n        Generates 14 points with a generalized hexagonal symmetry.\n        params: r1, r2, zr1, zr2, zc, alpha\n        - r1, r2: radii of the two hexagonal rings\n        - zr1, zr2: z-coordinates of the two hexagonal rings\n        - zc: z-coordinate of the two capping points (0, 0, \u00b1zc)\n        - alpha: angular offset between the two rings\n        \"\"\"\n        r1, r2, zr1, zr2, zc, alpha = params\n        pts = np.zeros((14, 3))\n        # Two axial capping points\n        pts[0] = [0, 0, zc]\n        pts[1] = [0, 0, -zc]\n        # Two rings of 6 points each\n        for i in range(6):\n            theta = i * np.pi / 3\n            # Top ring\n            pts[2+i] = [r1 * np.cos(theta), r1 * np.sin(theta), zr1]\n            # Bottom ring\n            pts[8+i] = [r2 * np.cos(theta + alpha), r2 * np.sin(theta + alpha), -zr2]\n        return pts\n\n    def objective_sym(params):\n        \"\"\"Negative ratio squared (min_dist^2 / max_dist^2) for symmetry-constrained points.\"\"\"\n        pts = get_points_sym(params)\n        dist_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n        i, j = np.triu_indices(14, k=1)\n        dists = dist_sq[i, j]\n        # We maximize min/max, so minimize -min/max\n        return -np.min(dists) / np.max(dists)\n\n    # 1. Global optimization of the symmetry-constrained parameters\n    # Bounds: r: (0.1, 2), zr: (0.01, 2), zc: (0.1, 2), alpha: (0, 60 degrees)\n    bounds = [(0.1, 2.0), (0.1, 2.0), (0.01, 2.0), (0.01, 2.0), (0.1, 2.0), (0, np.pi/3)]\n    res_sym = differential_evolution(\n        objective_sym, \n        bounds, \n        tol=1e-7, \n        popsize=15, \n        seed=42,\n        strategy='best1bin'\n    )\n    \n    # 2. Extract best symmetric configuration and normalize\n    pts_init = get_points_sym(res_sym.x)\n    dist_sq_init = np.sum((pts_init[:, None, :] - pts_init[None, :, :])**2, axis=-1)\n    max_d2 = np.max(dist_sq_init)\n    pts_init = pts_init / np.sqrt(max_d2)\n    \n    # 3. Refine all 42 coordinates using SLSQP\n    # We maximize x[0] (min distance squared) subject to max distance squared <= 1.0.\n    i_idx, j_idx = np.triu_indices(14, k=1)\n    \n    def obj(x):\n        return -x[0]\n        \n    def constr(x):\n        pts = x[1:].reshape((14, 3))\n        # Compute all pairwise squared distances\n        dist_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n        dists = dist_sq[i_idx, j_idx]\n        # Constraints: \n        # 1. Every distance squared >= x[0] (min distance)\n        # 2. Every distance squared <= 1.0 (normalization of max distance)\n        c_min = dists - x[0]\n        c_max = 1.0 - dists\n        return np.concatenate([c_min, c_max])\n\n    # Initial guess for the unconstrained optimization\n    x0 = np.zeros(43)\n    dist_sq_norm = np.sum((pts_init[:, None, :] - pts_init[None, :, :])**2, axis=-1)\n    x0[0] = np.min(dist_sq_norm[i_idx, j_idx])\n    x0[1:] = pts_init.flatten()\n    \n    # Run the local refinement\n    res_final = minimize(\n        obj, \n        x0, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constr}, \n        tol=1e-12, \n        options={'maxiter': 300, 'disp': False}\n    )\n    \n    # Return the optimized 14 points in 3D\n    return res_final.x[1:].reshape((14, 3))",
  "metrics": {
    "valid": true,
    "score": 0.9331888308441744,
    "min_max_ratio": 0.22400923773979542,
    "min_distance": 0.47329614169122003,
    "max_distance": 1.0,
    "eval_time": 0.8437221050262451,
    "error": null
  },
  "prompt": "For 14 points, the optimal configuration is likely a Bicapped Hexagonal Antiprism. Implement an optimization that explicitly enforces D6d or D6h symmetry to reduce the number of free variables. This might allow the optimizer to reach a more precise local optimum than the unconstrained 42-variable search.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the ratio (min_dist / max_dist)^2.\n    Uses a bicapped hexagonal antiprism (D6d symmetry) as a starting point,\n    then refines all 42 coordinates using a non-linear optimizer.\n    \"\"\"\n    \n    def get_points_sym(params):\n        \"\"\"\n        Generates 14 points with a generalized hexagonal symmetry.\n        params: r1, r2, zr1, zr2, zc, alpha\n        - r1, r2: radii of the two hexagonal rings\n        - zr1, zr2: z-coordinates of the two hexagonal rings\n        - zc: z-coordinate of the two capping points (0, 0, \u00b1zc)\n        - alpha: angular offset between the two rings\n        \"\"\"\n        r1, r2, zr1, zr2, zc, alpha = params\n        pts = np.zeros((14, 3))\n        # Two axial capping points\n        pts[0] = [0, 0, zc]\n        pts[1] = [0, 0, -zc]\n        # Two rings of 6 points each\n        for i in range(6):\n            theta = i * np.pi / 3\n            # Top ring\n            pts[2+i] = [r1 * np.cos(theta), r1 * np.sin(theta), zr1]\n            # Bottom ring\n            pts[8+i] = [r2 * np.cos(theta + alpha), r2 * np.sin(theta + alpha), -zr2]\n        return pts\n\n    def objective_sym(params):\n        \"\"\"Negative ratio squared (min_dist^2 / max_dist^2) for symmetry-constrained points.\"\"\"\n        pts = get_points_sym(params)\n        dist_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n        i, j = np.triu_indices(14, k=1)\n        dists = dist_sq[i, j]\n        # We maximize min/max, so minimize -min/max\n        return -np.min(dists) / np.max(dists)\n\n    # 1. Global optimization of the symmetry-constrained parameters\n    # Bounds: r: (0.1, 2), zr: (0.01, 2), zc: (0.1, 2), alpha: (0, 60 degrees)\n    bounds = [(0.1, 2.0), (0.1, 2.0), (0.01, 2.0), (0.01, 2.0), (0.1, 2.0), (0, np.pi/3)]\n    res_sym = differential_evolution(\n        objective_sym, \n        bounds, \n        tol=1e-7, \n        popsize=15, \n        seed=42,\n        strategy='best1bin'\n    )\n    \n    # 2. Extract best symmetric configuration and normalize\n    pts_init = get_points_sym(res_sym.x)\n    dist_sq_init = np.sum((pts_init[:, None, :] - pts_init[None, :, :])**2, axis=-1)\n    max_d2 = np.max(dist_sq_init)\n    pts_init = pts_init / np.sqrt(max_d2)\n    \n    # 3. Refine all 42 coordinates using SLSQP\n    # We maximize x[0] (min distance squared) subject to max distance squared <= 1.0.\n    i_idx, j_idx = np.triu_indices(14, k=1)\n    \n    def obj(x):\n        return -x[0]\n        \n    def constr(x):\n        pts = x[1:].reshape((14, 3))\n        # Compute all pairwise squared distances\n        dist_sq = np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1)\n        dists = dist_sq[i_idx, j_idx]\n        # Constraints: \n        # 1. Every distance squared >= x[0] (min distance)\n        # 2. Every distance squared <= 1.0 (normalization of max distance)\n        c_min = dists - x[0]\n        c_max = 1.0 - dists\n        return np.concatenate([c_min, c_max])\n\n    # Initial guess for the unconstrained optimization\n    x0 = np.zeros(43)\n    dist_sq_norm = np.sum((pts_init[:, None, :] - pts_init[None, :, :])**2, axis=-1)\n    x0[0] = np.min(dist_sq_norm[i_idx, j_idx])\n    x0[1:] = pts_init.flatten()\n    \n    # Run the local refinement\n    res_final = minimize(\n        obj, \n        x0, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constr}, \n        tol=1e-12, \n        options={'maxiter': 300, 'disp': False}\n    )\n    \n    # Return the optimized 14 points in 3D\n    return res_final.x[1:].reshape((14, 3))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:53:18.253313",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 237,
        "candidates_token_count": 1317,
        "thoughts_token_count": 22024
      },
      "response_text_len": 3622
    }
  }
}