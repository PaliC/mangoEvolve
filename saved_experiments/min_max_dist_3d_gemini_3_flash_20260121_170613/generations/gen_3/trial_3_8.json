{
  "trial_id": "trial_3_8",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a combination of lattice-based seeds and local optimization with a smooth objective function.\n    \"\"\"\n    n = 14\n    dim = 3\n\n    def get_ratio_sq(X_flat):\n        X = X_flat.reshape((n, dim))\n        # Compute all pairwise squared distances\n        dists_sq = np.sum((X[:, None, :] - X[None, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n, 1)\n        d_sq = dists_sq[i, j]\n        if len(d_sq) == 0:\n            return 0\n        return np.min(d_sq) / np.max(d_sq)\n\n    def objective(X_flat, p):\n        X = X_flat.reshape((n, dim))\n        dists_sq = np.sum((X[:, None, :] - X[None, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n, 1)\n        d_sq = dists_sq[i, j]\n        \n        m = np.min(d_sq)\n        M = np.max(d_sq)\n        \n        # Smooth approximation of min and max using the log-sum-exp trick for numerical stability.\n        # Arguments to exp are always <= 0, preventing overflow.\n        # soft_min_sq = m - (1/p) * log(sum(exp(-p(d_sq - m))))\n        # soft_max_sq = M + (1/p) * log(sum(exp(p(d_sq - M))))\n        soft_min_sq = m - (1.0 / p) * np.log(np.sum(np.exp(-p * (d_sq - m))))\n        soft_max_sq = M + (1.0 / p) * np.log(np.sum(np.exp(p * (d_sq - M))))\n        \n        # We minimize the negative ratio of smooth min and smooth max\n        return -soft_min_sq / soft_max_sq\n\n    # Generate diverse starting configurations\n    seeds = []\n    \n    # Seed 1: Rhombic Dodecahedron (8 cube vertices + 6 octahedron vertices)\n    cube = np.array([[x, y, z] for x in [-1, 1] for y in [-1, 1] for z in [-1, 1]], dtype=float)\n    octa = np.array([[1.8, 0, 0], [-1.8, 0, 0], [0, 1.8, 0], [0, -1.8, 0], [0, 0, 1.8], [0, 0, -1.8]], dtype=float)\n    seeds.append(np.vstack([cube, octa]))\n    \n    # Seed 2: Bicapped Hexagonal Antiprism (12 antiprism vertices + 2 axial caps)\n    h = 0.5\n    hex_anti = []\n    for i in range(6):\n        c, s = np.cos(i * np.pi / 3), np.sin(i * np.pi / 3)\n        hex_anti.append([c, s, h])\n        c, s = np.cos(i * np.pi / 3 + np.pi / 6), np.sin(i * np.pi / 3 + np.pi / 6)\n        hex_anti.append([c, s, -h])\n    hex_anti.append([0, 0, 1.2])\n    hex_anti.append([0, 0, -1.2])\n    seeds.append(np.array(hex_anti))\n    \n    # Seed 3: Fibonacci Sphere (points distributed fairly uniformly on a sphere)\n    phi = np.pi * (3. - np.sqrt(5.))\n    pts_sphere = []\n    for i in range(n):\n        y = 1 - (i / float(n - 1)) * 2\n        radius = np.sqrt(1 - y * y)\n        theta = phi * i\n        pts_sphere.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    seeds.append(np.array(pts_sphere))\n    \n    # Seed 4-8: Random initializations\n    np.random.seed(42)  # For reproducibility during development\n    for _ in range(5):\n        seeds.append(np.random.normal(0, 1, (n, dim)))\n\n    best_X = seeds[0].flatten()\n    best_val = -1\n\n    # Optimize each seed\n    for X in seeds:\n        curr_X = X.flatten()\n        # Gradual refinement with increasing sharpness parameter p\n        for p_val in [15.0, 35.0]:\n            res = minimize(objective, curr_X, args=(p_val,), method='L-BFGS-B', \n                           options={'maxiter': 250, 'ftol': 1e-7})\n            curr_X = res.x\n        \n        val = get_ratio_sq(curr_X)\n        if val > best_val:\n            best_val = val\n            best_X = curr_X\n    \n    # Final polishing with a very sharp smooth objective and then a direct optimizer\n    res = minimize(objective, best_X, args=(70.0,), method='L-BFGS-B', \n                   options={'maxiter': 250, 'ftol': 1e-9})\n    best_X = res.x\n    \n    # Use Nelder-Mead for a final direct search on the non-smooth ratio objective\n    res = minimize(lambda x: -get_ratio_sq(x), best_X, method='Nelder-Mead', \n                   options={'maxiter': 500})\n    best_X = res.x\n    \n    return best_X.reshape((n, dim))",
  "metrics": {
    "valid": true,
    "score": 0.9987063917727923,
    "min_max_ratio": 0.23973653579255258,
    "min_distance": 9.119436133963148,
    "max_distance": 18.625196933829802,
    "eval_time": 4.277405023574829,
    "error": null
  },
  "prompt": "Try a lattice-based approach for 14 points. Try BCC, FCC, and HCP subsets of 14 points, then optimize locally.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Places 14 points in 3D space to maximize the squared ratio (min pairwise distance / max pairwise distance)^2.\n    Uses a combination of lattice-based seeds and local optimization with a smooth objective function.\n    \"\"\"\n    n = 14\n    dim = 3\n\n    def get_ratio_sq(X_flat):\n        X = X_flat.reshape((n, dim))\n        # Compute all pairwise squared distances\n        dists_sq = np.sum((X[:, None, :] - X[None, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n, 1)\n        d_sq = dists_sq[i, j]\n        if len(d_sq) == 0:\n            return 0\n        return np.min(d_sq) / np.max(d_sq)\n\n    def objective(X_flat, p):\n        X = X_flat.reshape((n, dim))\n        dists_sq = np.sum((X[:, None, :] - X[None, :, :])**2, axis=-1)\n        i, j = np.triu_indices(n, 1)\n        d_sq = dists_sq[i, j]\n        \n        m = np.min(d_sq)\n        M = np.max(d_sq)\n        \n        # Smooth approximation of min and max using the log-sum-exp trick for numerical stability.\n        # Arguments to exp are always <= 0, preventing overflow.\n        # soft_min_sq = m - (1/p) * log(sum(exp(-p(d_sq - m))))\n        # soft_max_sq = M + (1/p) * log(sum(exp(p(d_sq - M))))\n        soft_min_sq = m - (1.0 / p) * np.log(np.sum(np.exp(-p * (d_sq - m))))\n        soft_max_sq = M + (1.0 / p) * np.log(np.sum(np.exp(p * (d_sq - M))))\n        \n        # We minimize the negative ratio of smooth min and smooth max\n        return -soft_min_sq / soft_max_sq\n\n    # Generate diverse starting configurations\n    seeds = []\n    \n    # Seed 1: Rhombic Dodecahedron (8 cube vertices + 6 octahedron vertices)\n    cube = np.array([[x, y, z] for x in [-1, 1] for y in [-1, 1] for z in [-1, 1]], dtype=float)\n    octa = np.array([[1.8, 0, 0], [-1.8, 0, 0], [0, 1.8, 0], [0, -1.8, 0], [0, 0, 1.8], [0, 0, -1.8]], dtype=float)\n    seeds.append(np.vstack([cube, octa]))\n    \n    # Seed 2: Bicapped Hexagonal Antiprism (12 antiprism vertices + 2 axial caps)\n    h = 0.5\n    hex_anti = []\n    for i in range(6):\n        c, s = np.cos(i * np.pi / 3), np.sin(i * np.pi / 3)\n        hex_anti.append([c, s, h])\n        c, s = np.cos(i * np.pi / 3 + np.pi / 6), np.sin(i * np.pi / 3 + np.pi / 6)\n        hex_anti.append([c, s, -h])\n    hex_anti.append([0, 0, 1.2])\n    hex_anti.append([0, 0, -1.2])\n    seeds.append(np.array(hex_anti))\n    \n    # Seed 3: Fibonacci Sphere (points distributed fairly uniformly on a sphere)\n    phi = np.pi * (3. - np.sqrt(5.))\n    pts_sphere = []\n    for i in range(n):\n        y = 1 - (i / float(n - 1)) * 2\n        radius = np.sqrt(1 - y * y)\n        theta = phi * i\n        pts_sphere.append([np.cos(theta) * radius, y, np.sin(theta) * radius])\n    seeds.append(np.array(pts_sphere))\n    \n    # Seed 4-8: Random initializations\n    np.random.seed(42)  # For reproducibility during development\n    for _ in range(5):\n        seeds.append(np.random.normal(0, 1, (n, dim)))\n\n    best_X = seeds[0].flatten()\n    best_val = -1\n\n    # Optimize each seed\n    for X in seeds:\n        curr_X = X.flatten()\n        # Gradual refinement with increasing sharpness parameter p\n        for p_val in [15.0, 35.0]:\n            res = minimize(objective, curr_X, args=(p_val,), method='L-BFGS-B', \n                           options={'maxiter': 250, 'ftol': 1e-7})\n            curr_X = res.x\n        \n        val = get_ratio_sq(curr_X)\n        if val > best_val:\n            best_val = val\n            best_X = curr_X\n    \n    # Final polishing with a very sharp smooth objective and then a direct optimizer\n    res = minimize(objective, best_X, args=(70.0,), method='L-BFGS-B', \n                   options={'maxiter': 250, 'ftol': 1e-9})\n    best_X = res.x\n    \n    # Use Nelder-Mead for a final direct search on the non-smooth ratio objective\n    res = minimize(lambda x: -get_ratio_sq(x), best_X, method='Nelder-Mead', \n                   options={'maxiter': 500})\n    best_X = res.x\n    \n    return best_X.reshape((n, dim))\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:26:42.986000",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 202,
        "candidates_token_count": 1481,
        "thoughts_token_count": 26427
      },
      "response_text_len": 4009
    }
  }
}