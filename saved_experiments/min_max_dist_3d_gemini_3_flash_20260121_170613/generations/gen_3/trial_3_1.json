{
  "trial_id": "trial_3_1",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D that maximizes the squared ratio \n    (min_dist / max_dist)^2.\n    \n    Strategy:\n    1. Initialize with random points on a sphere.\n    2. Optimize the Thomson energy (sum 1/r^2) on the sphere to get a good distribution.\n    3. Use the spherical configuration as a starting point for a constrained optimization \n       problem (SLSQP) that maximizes the minimum distance subject to a fixed diameter.\n    4. Repeat with random restarts within the time limit to avoid local optima.\n    \"\"\"\n    N = 14\n    start_time = time.time()\n    \n    # Precompute indices for pairwise interactions (upper triangle)\n    idx_u, idx_v = np.triu_indices(N, k=1)\n    num_pairs = len(idx_u)\n    \n    # Helper to get difference vectors for all pairs\n    def get_diffs(x):\n        # x shape: (N, 3)\n        # Returns shape (num_pairs, 3)\n        return x[idx_u] - x[idx_v]\n\n    # --- Phase 1: Thomson Problem on Sphere (Initialization) ---\n    # Objective: Minimize sum(1/d^2) on unit sphere\n    # This provides a robust, well-separated initial guess.\n    \n    def energy_thomson(flat_x):\n        x = flat_x.reshape(N, 3)\n        diffs = get_diffs(x)\n        d2 = np.sum(diffs**2, axis=1)\n        # Avoid division by zero\n        d2 = np.maximum(d2, 1e-9)\n        return np.sum(1.0 / d2)\n\n    def grad_thomson(flat_x):\n        x = flat_x.reshape(N, 3)\n        diffs = get_diffs(x)\n        d2 = np.sum(diffs**2, axis=1)\n        d2 = np.maximum(d2, 1e-9)\n        \n        # dE/dx = sum -1/d^4 * d(d^2)/dx\n        # d(d^2)/dx = 2(x_u - x_v)\n        coeffs = -1.0 / (d2**2) # shape (num_pairs,)\n        \n        weighted_diff = diffs * coeffs[:, None] * 2.0\n        \n        grad = np.zeros_like(x)\n        np.add.at(grad, idx_u, weighted_diff)\n        np.add.at(grad, idx_v, -weighted_diff)\n        \n        return grad.flatten()\n\n    def sphere_constraint(flat_x):\n        x = flat_x.reshape(N, 3)\n        return np.sum(x**2, axis=1) - 1.0\n\n    def jac_sphere_constraint(flat_x):\n        x = flat_x.reshape(N, 3)\n        jac = np.zeros((N, N*3))\n        # Gradient of x^2 + y^2 + z^2 - 1 is [2x, 2y, 2z]\n        for i in range(N):\n            jac[i, 3*i:3*i+3] = 2 * x[i]\n        return jac\n\n    # --- Phase 2: Maximize Min Distance (Hard Constraints) ---\n    # Variables: [x_flattened (3N), s (1)] where s represents the squared minimum distance.\n    # Objective: Maximize s => Minimize -s\n    # Constraints: \n    #   1. d_ij^2 >= s   => d_ij^2 - s >= 0\n    #   2. d_ij^2 <= 1   => 1 - d_ij^2 >= 0 (Fixes diameter to 1)\n    \n    def obj_hard(params):\n        return -params[-1]\n\n    def jac_obj_hard(params):\n        grad = np.zeros_like(params)\n        grad[-1] = -1.0\n        return grad\n\n    def constraints_hard(params):\n        x = params[:-1].reshape(N, 3)\n        s = params[-1]\n        diffs = get_diffs(x)\n        d2 = np.sum(diffs**2, axis=1)\n        \n        c1 = d2 - s\n        c2 = 1.0 - d2\n        return np.concatenate([c1, c2])\n\n    def jac_constraints_hard(params):\n        x = params[:-1].reshape(N, 3)\n        diffs = get_diffs(x)\n        \n        # Jacobian shape: (2*num_pairs, 3N + 1)\n        jac = np.zeros((2 * num_pairs, 3 * N + 1))\n        \n        # Gradients of d^2 w.r.t x\n        grad_d2 = 2 * diffs # (num_pairs, 3)\n        \n        # Fill Jacobian\n        # For c1: d(d2 - s)/dx = grad_d2, d/ds = -1\n        # For c2: d(1 - d2)/dx = -grad_d2, d/ds = 0\n        \n        for k in range(num_pairs):\n            u, v = idx_u[k], idx_v[k]\n            g = grad_d2[k]\n            \n            # Constraint 1: d2 - s >= 0\n            jac[k, 3*u:3*u+3] = g\n            jac[k, 3*v:3*v+3] = -g\n            jac[k, -1] = -1.0\n            \n            # Constraint 2: 1 - d2 >= 0\n            jac[num_pairs+k, 3*u:3*u+3] = -g\n            jac[num_pairs+k, 3*v:3*v+3] = g\n            jac[num_pairs+k, -1] = 0.0\n            \n        return jac\n\n    # --- Main Optimization Loop ---\n    best_ratio = -1.0\n    # Initialize with random points in case optimization fails entirely\n    best_coords = np.random.rand(N, 3)\n    \n    # Run multiple restarts within 60 seconds (safe margin 55s)\n    while time.time() - start_time < 55:\n        # 1. Initialization: Random points on sphere\n        x0 = np.random.normal(size=(N, 3))\n        x0 /= np.linalg.norm(x0, axis=1, keepdims=True)\n        \n        # 2. Sphere Optimization (Thomson energy)\n        try:\n            res_sphere = minimize(\n                energy_thomson,\n                x0.flatten(),\n                jac=grad_thomson,\n                constraints={'type': 'eq', 'fun': sphere_constraint, 'jac': jac_sphere_constraint},\n                method='SLSQP',\n                options={'maxiter': 100, 'ftol': 1e-4}\n            )\n            x_sphere = res_sphere.x.reshape(N, 3)\n        except Exception:\n            x_sphere = x0\n\n        # 3. Setup Hard Optimization\n        # Normalize current configuration so max_dist = 1\n        diffs = get_diffs(x_sphere)\n        d2 = np.sum(diffs**2, axis=1)\n        max_d2 = np.max(d2)\n        if max_d2 < 1e-9: continue\n        \n        x_start = x_sphere / np.sqrt(max_d2)\n        \n        # Initial guess for s (squared min dist)\n        d2_norm = d2 / max_d2\n        s_start = np.min(d2_norm) * 0.95 # Start slightly feasible\n        \n        params0 = np.concatenate([x_start.flatten(), [s_start]])\n        \n        # 4. Hard Optimization (Maximize min dist given diameter <= 1)\n        try:\n            res_hard = minimize(\n                obj_hard,\n                params0,\n                jac=jac_obj_hard,\n                constraints={'type': 'ineq', 'fun': constraints_hard, 'jac': jac_constraints_hard},\n                method='SLSQP',\n                options={'maxiter': 300, 'ftol': 1e-8}\n            )\n            \n            final_params = res_hard.x\n            x_final = final_params[:-1].reshape(N, 3)\n            \n            # Evaluate Result\n            diffs_f = get_diffs(x_final)\n            d2_f = np.sum(diffs_f**2, axis=1)\n            d_min_sq = np.min(d2_f)\n            d_max_sq = np.max(d2_f)\n            \n            if d_max_sq > 1e-9:\n                ratio = d_min_sq / d_max_sq # This is (min/max)^2\n                if ratio > best_ratio:\n                    best_ratio = ratio\n                    best_coords = x_final\n        except Exception:\n            continue\n            \n    return best_coords",
  "metrics": {
    "valid": true,
    "score": 0.9451733108785565,
    "min_max_ratio": 0.226886076969409,
    "min_distance": 0.4763255999373744,
    "max_distance": 1.0000000004105378,
    "eval_time": 55.23165321350098,
    "error": null
  },
  "prompt": "Maximize the ratio (min_dist / max_dist)^2 for 14 points in 3D.\n        Strategy:\n        1. Initialize points using the optimal solution for the Tammes problem (14 points on a sphere).\n        2. Use these points as a starting configuration for a high-precision local optimizer (SLSQP or L-BFGS-B).\n        3. Since the points don't have to stay on a sphere, allow them to move radially to maximize the ratio.\n        4. Use a SoftMax or LogSumExp approximation of the minimum distance to create a smooth gradient for the optimizer before finishing with a hard min-dist optimization.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds a configuration of 14 points in 3D that maximizes the squared ratio \n    (min_dist / max_dist)^2.\n    \n    Strategy:\n    1. Initialize with random points on a sphere.\n    2. Optimize the Thomson energy (sum 1/r^2) on the sphere to get a good distribution.\n    3. Use the spherical configuration as a starting point for a constrained optimization \n       problem (SLSQP) that maximizes the minimum distance subject to a fixed diameter.\n    4. Repeat with random restarts within the time limit to avoid local optima.\n    \"\"\"\n    N = 14\n    start_time = time.time()\n    \n    # Precompute indices for pairwise interactions (upper triangle)\n    idx_u, idx_v = np.triu_indices(N, k=1)\n    num_pairs = len(idx_u)\n    \n    # Helper to get difference vectors for all pairs\n    def get_diffs(x):\n        # x shape: (N, 3)\n        # Returns shape (num_pairs, 3)\n        return x[idx_u] - x[idx_v]\n\n    # --- Phase 1: Thomson Problem on Sphere (Initialization) ---\n    # Objective: Minimize sum(1/d^2) on unit sphere\n    # This provides a robust, well-separated initial guess.\n    \n    def energy_thomson(flat_x):\n        x = flat_x.reshape(N, 3)\n        diffs = get_diffs(x)\n        d2 = np.sum(diffs**2, axis=1)\n        # Avoid division by zero\n        d2 = np.maximum(d2, 1e-9)\n        return np.sum(1.0 / d2)\n\n    def grad_thomson(flat_x):\n        x = flat_x.reshape(N, 3)\n        diffs = get_diffs(x)\n        d2 = np.sum(diffs**2, axis=1)\n        d2 = np.maximum(d2, 1e-9)\n        \n        # dE/dx = sum -1/d^4 * d(d^2)/dx\n        # d(d^2)/dx = 2(x_u - x_v)\n        coeffs = -1.0 / (d2**2) # shape (num_pairs,)\n        \n        weighted_diff = diffs * coeffs[:, None] * 2.0\n        \n        grad = np.zeros_like(x)\n        np.add.at(grad, idx_u, weighted_diff)\n        np.add.at(grad, idx_v, -weighted_diff)\n        \n        return grad.flatten()\n\n    def sphere_constraint(flat_x):\n        x = flat_x.reshape(N, 3)\n        return np.sum(x**2, axis=1) - 1.0\n\n    def jac_sphere_constraint(flat_x):\n        x = flat_x.reshape(N, 3)\n        jac = np.zeros((N, N*3))\n        # Gradient of x^2 + y^2 + z^2 - 1 is [2x, 2y, 2z]\n        for i in range(N):\n            jac[i, 3*i:3*i+3] = 2 * x[i]\n        return jac\n\n    # --- Phase 2: Maximize Min Distance (Hard Constraints) ---\n    # Variables: [x_flattened (3N), s (1)] where s represents the squared minimum distance.\n    # Objective: Maximize s => Minimize -s\n    # Constraints: \n    #   1. d_ij^2 >= s   => d_ij^2 - s >= 0\n    #   2. d_ij^2 <= 1   => 1 - d_ij^2 >= 0 (Fixes diameter to 1)\n    \n    def obj_hard(params):\n        return -params[-1]\n\n    def jac_obj_hard(params):\n        grad = np.zeros_like(params)\n        grad[-1] = -1.0\n        return grad\n\n    def constraints_hard(params):\n        x = params[:-1].reshape(N, 3)\n        s = params[-1]\n        diffs = get_diffs(x)\n        d2 = np.sum(diffs**2, axis=1)\n        \n        c1 = d2 - s\n        c2 = 1.0 - d2\n        return np.concatenate([c1, c2])\n\n    def jac_constraints_hard(params):\n        x = params[:-1].reshape(N, 3)\n        diffs = get_diffs(x)\n        \n        # Jacobian shape: (2*num_pairs, 3N + 1)\n        jac = np.zeros((2 * num_pairs, 3 * N + 1))\n        \n        # Gradients of d^2 w.r.t x\n        grad_d2 = 2 * diffs # (num_pairs, 3)\n        \n        # Fill Jacobian\n        # For c1: d(d2 - s)/dx = grad_d2, d/ds = -1\n        # For c2: d(1 - d2)/dx = -grad_d2, d/ds = 0\n        \n        for k in range(num_pairs):\n            u, v = idx_u[k], idx_v[k]\n            g = grad_d2[k]\n            \n            # Constraint 1: d2 - s >= 0\n            jac[k, 3*u:3*u+3] = g\n            jac[k, 3*v:3*v+3] = -g\n            jac[k, -1] = -1.0\n            \n            # Constraint 2: 1 - d2 >= 0\n            jac[num_pairs+k, 3*u:3*u+3] = -g\n            jac[num_pairs+k, 3*v:3*v+3] = g\n            jac[num_pairs+k, -1] = 0.0\n            \n        return jac\n\n    # --- Main Optimization Loop ---\n    best_ratio = -1.0\n    # Initialize with random points in case optimization fails entirely\n    best_coords = np.random.rand(N, 3)\n    \n    # Run multiple restarts within 60 seconds (safe margin 55s)\n    while time.time() - start_time < 55:\n        # 1. Initialization: Random points on sphere\n        x0 = np.random.normal(size=(N, 3))\n        x0 /= np.linalg.norm(x0, axis=1, keepdims=True)\n        \n        # 2. Sphere Optimization (Thomson energy)\n        try:\n            res_sphere = minimize(\n                energy_thomson,\n                x0.flatten(),\n                jac=grad_thomson,\n                constraints={'type': 'eq', 'fun': sphere_constraint, 'jac': jac_sphere_constraint},\n                method='SLSQP',\n                options={'maxiter': 100, 'ftol': 1e-4}\n            )\n            x_sphere = res_sphere.x.reshape(N, 3)\n        except Exception:\n            x_sphere = x0\n\n        # 3. Setup Hard Optimization\n        # Normalize current configuration so max_dist = 1\n        diffs = get_diffs(x_sphere)\n        d2 = np.sum(diffs**2, axis=1)\n        max_d2 = np.max(d2)\n        if max_d2 < 1e-9: continue\n        \n        x_start = x_sphere / np.sqrt(max_d2)\n        \n        # Initial guess for s (squared min dist)\n        d2_norm = d2 / max_d2\n        s_start = np.min(d2_norm) * 0.95 # Start slightly feasible\n        \n        params0 = np.concatenate([x_start.flatten(), [s_start]])\n        \n        # 4. Hard Optimization (Maximize min dist given diameter <= 1)\n        try:\n            res_hard = minimize(\n                obj_hard,\n                params0,\n                jac=jac_obj_hard,\n                constraints={'type': 'ineq', 'fun': constraints_hard, 'jac': jac_constraints_hard},\n                method='SLSQP',\n                options={'maxiter': 300, 'ftol': 1e-8}\n            )\n            \n            final_params = res_hard.x\n            x_final = final_params[:-1].reshape(N, 3)\n            \n            # Evaluate Result\n            diffs_f = get_diffs(x_final)\n            d2_f = np.sum(diffs_f**2, axis=1)\n            d_min_sq = np.min(d2_f)\n            d_max_sq = np.max(d2_f)\n            \n            if d_max_sq > 1e-9:\n                ratio = d_min_sq / d_max_sq # This is (min/max)^2\n                if ratio > best_ratio:\n                    best_ratio = ratio\n                    best_coords = x_final\n        except Exception:\n            continue\n            \n    return best_coords\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:27:04.777207",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-pro-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 314,
        "candidates_token_count": 2246,
        "thoughts_token_count": 12570
      },
      "response_text_len": 6485
    }
  }
}