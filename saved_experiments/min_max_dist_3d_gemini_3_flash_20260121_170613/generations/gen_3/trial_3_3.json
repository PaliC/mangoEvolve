{
  "trial_id": "trial_3_3",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min distance / max distance)^2.\n    The method uses a combination of repulsive force simulation for initialization\n    and SLSQP optimization to refine the configuration.\n    \"\"\"\n    N = 14\n    dim = 3\n    i_tri, j_tri = np.triu_indices(N, k=1)\n    num_pairs = len(i_tri)\n\n    def get_constraints(x):\n        \"\"\"\n        Calculates the inequality constraints:\n        1. All pairwise squared distances must be >= t (min distance squared).\n        2. All pairwise squared distances must be <= 1 (max distance squared normalized to 1).\n        \"\"\"\n        p = x[:-1].reshape((N, dim))\n        t = x[-1]\n        # Calculate pairwise differences for all pairs in the upper triangle\n        diff = p[i_tri] - p[j_tri]\n        d_sq = np.sum(diff**2, axis=1)\n        # Combine the min-distance and max-distance constraints\n        # Each constraint function f(x) must satisfy f(x) >= 0\n        return np.concatenate([d_sq - t, 1.0 - d_sq])\n\n    def get_jacobian(x):\n        \"\"\"\n        Calculates the Jacobian matrix for the constraints.\n        The Jacobian is of shape (num_constraints, num_variables).\n        \"\"\"\n        p = x[:-1].reshape((N, dim))\n        jac = np.zeros((2 * num_pairs, N * dim + 1))\n        # Gradient of distance squared d_ij^2 w.r.t. p_i is 2*(p_i - p_j)\n        # Gradient of distance squared d_ij^2 w.r.t. p_j is -2*(p_i - p_j)\n        diff = 2 * (p[i_tri] - p[j_tri])\n        \n        for k in range(num_pairs):\n            i, j = i_tri[k], j_tri[k]\n            # Constraint: d_ij^2 - t >= 0\n            jac[k, 3*i : 3*i+3] = diff[k]\n            jac[k, 3*j : 3*j+3] = -diff[k]\n            jac[k, -1] = -1\n            \n            # Constraint: 1.0 - d_ij^2 >= 0\n            jac[num_pairs + k, 3*i : 3*i+3] = -diff[k]\n            jac[num_pairs + k, 3*j : 3*j+3] = diff[k]\n            # jac[num_pairs + k, -1] remains 0\n        return jac\n\n    best_pts = None\n    best_val = -1\n    start_time = time.time()\n    \n    # Global optimization loop with multiple random restarts\n    # Runs for up to 50 seconds to fit within the 60s limit\n    while time.time() - start_time < 50:\n        # 1. Repulsive force-based initialization to spread points out\n        pts = np.random.normal(0, 1, (N, dim))\n        pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        \n        # Simulate repulsion with F proportional to 1/r^6\n        for _ in range(100):\n            diff_mat = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            d_sq_mat = np.sum(diff_mat**2, axis=2)\n            # Avoid division by zero on diagonal\n            d_sq_mat[np.diag_indices(N)] = 1e-6\n            # Force proportional to 1/r^6 -> potential 1/r^5 -> gradient 1/r^6\n            force_mat = diff_mat / (d_sq_mat[:, :, np.newaxis]**3)\n            pts += 0.01 * np.sum(force_mat, axis=1)\n            # Center the points and normalize the maximum distance to 1\n            pts -= np.mean(pts, axis=0)\n            d_max_sq = np.max(np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=2))\n            pts /= np.sqrt(d_max_sq)\n        \n        # 2. Local optimization using SLSQP\n        # x0 contains coordinates of 14 points and the slack variable t\n        x0 = np.zeros(N * dim + 1)\n        x0[:N * dim] = pts.flatten()\n        diff_init = pts[i_tri] - pts[j_tri]\n        x0[-1] = np.min(np.sum(diff_init**2, axis=1))\n        \n        res = minimize(\n            lambda x: -x[-1], # Objective: Maximize t (min distance squared)\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.concatenate([np.zeros(N * dim), [-1.0]]),\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian},\n            bounds=[(None, None)] * (N * dim) + [(0, None)],\n            options={'maxiter': 200, 'ftol': 1e-9}\n        )\n        \n        # Record the best configuration found across all restarts\n        if res.x[-1] > best_val:\n            best_val = res.x[-1]\n            best_pts = res.x[:-1].reshape((N, dim))\n            \n    # If no optimization completed successfully, ensure we return something\n    if best_pts is None:\n        best_pts = np.random.normal(0, 1, (N, dim))\n        \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.04031200092952745,
    "min_max_ratio": 0.009676777412584847,
    "min_distance": 0.4684961317333898,
    "max_distance": 4.762561903500401,
    "eval_time": 50.243212938308716,
    "error": null
  },
  "prompt": "Implement a physical simulation where 14 points repel each other with a force proportional to 1/r^p.\n        - Start with p=2 and gradually increase p to 50 or 100 to approximate the hard-sphere (max-min) problem.\n        - Add a 'container' force or constraint to keep the max distance from growing infinitely (or normalize at each step).\n        - Use a global optimization wrapper or multiple restarts with different random seeds.\n        - Finish with a local search to snap to the exact local maximum of the min-dist ratio.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space to maximize the squared ratio (min distance / max distance)^2.\n    The method uses a combination of repulsive force simulation for initialization\n    and SLSQP optimization to refine the configuration.\n    \"\"\"\n    N = 14\n    dim = 3\n    i_tri, j_tri = np.triu_indices(N, k=1)\n    num_pairs = len(i_tri)\n\n    def get_constraints(x):\n        \"\"\"\n        Calculates the inequality constraints:\n        1. All pairwise squared distances must be >= t (min distance squared).\n        2. All pairwise squared distances must be <= 1 (max distance squared normalized to 1).\n        \"\"\"\n        p = x[:-1].reshape((N, dim))\n        t = x[-1]\n        # Calculate pairwise differences for all pairs in the upper triangle\n        diff = p[i_tri] - p[j_tri]\n        d_sq = np.sum(diff**2, axis=1)\n        # Combine the min-distance and max-distance constraints\n        # Each constraint function f(x) must satisfy f(x) >= 0\n        return np.concatenate([d_sq - t, 1.0 - d_sq])\n\n    def get_jacobian(x):\n        \"\"\"\n        Calculates the Jacobian matrix for the constraints.\n        The Jacobian is of shape (num_constraints, num_variables).\n        \"\"\"\n        p = x[:-1].reshape((N, dim))\n        jac = np.zeros((2 * num_pairs, N * dim + 1))\n        # Gradient of distance squared d_ij^2 w.r.t. p_i is 2*(p_i - p_j)\n        # Gradient of distance squared d_ij^2 w.r.t. p_j is -2*(p_i - p_j)\n        diff = 2 * (p[i_tri] - p[j_tri])\n        \n        for k in range(num_pairs):\n            i, j = i_tri[k], j_tri[k]\n            # Constraint: d_ij^2 - t >= 0\n            jac[k, 3*i : 3*i+3] = diff[k]\n            jac[k, 3*j : 3*j+3] = -diff[k]\n            jac[k, -1] = -1\n            \n            # Constraint: 1.0 - d_ij^2 >= 0\n            jac[num_pairs + k, 3*i : 3*i+3] = -diff[k]\n            jac[num_pairs + k, 3*j : 3*j+3] = diff[k]\n            # jac[num_pairs + k, -1] remains 0\n        return jac\n\n    best_pts = None\n    best_val = -1\n    start_time = time.time()\n    \n    # Global optimization loop with multiple random restarts\n    # Runs for up to 50 seconds to fit within the 60s limit\n    while time.time() - start_time < 50:\n        # 1. Repulsive force-based initialization to spread points out\n        pts = np.random.normal(0, 1, (N, dim))\n        pts /= np.linalg.norm(pts, axis=1)[:, np.newaxis]\n        \n        # Simulate repulsion with F proportional to 1/r^6\n        for _ in range(100):\n            diff_mat = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            d_sq_mat = np.sum(diff_mat**2, axis=2)\n            # Avoid division by zero on diagonal\n            d_sq_mat[np.diag_indices(N)] = 1e-6\n            # Force proportional to 1/r^6 -> potential 1/r^5 -> gradient 1/r^6\n            force_mat = diff_mat / (d_sq_mat[:, :, np.newaxis]**3)\n            pts += 0.01 * np.sum(force_mat, axis=1)\n            # Center the points and normalize the maximum distance to 1\n            pts -= np.mean(pts, axis=0)\n            d_max_sq = np.max(np.sum((pts[:, np.newaxis, :] - pts[np.newaxis, :, :])**2, axis=2))\n            pts /= np.sqrt(d_max_sq)\n        \n        # 2. Local optimization using SLSQP\n        # x0 contains coordinates of 14 points and the slack variable t\n        x0 = np.zeros(N * dim + 1)\n        x0[:N * dim] = pts.flatten()\n        diff_init = pts[i_tri] - pts[j_tri]\n        x0[-1] = np.min(np.sum(diff_init**2, axis=1))\n        \n        res = minimize(\n            lambda x: -x[-1], # Objective: Maximize t (min distance squared)\n            x0,\n            method='SLSQP',\n            jac=lambda x: np.concatenate([np.zeros(N * dim), [-1.0]]),\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian},\n            bounds=[(None, None)] * (N * dim) + [(0, None)],\n            options={'maxiter': 200, 'ftol': 1e-9}\n        )\n        \n        # Record the best configuration found across all restarts\n        if res.x[-1] > best_val:\n            best_val = res.x[-1]\n            best_pts = res.x[:-1].reshape((N, dim))\n            \n    # If no optimization completed successfully, ensure we return something\n    if best_pts is None:\n        best_pts = np.random.normal(0, 1, (N, dim))\n        \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:26:45.779136",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 294,
        "candidates_token_count": 1436,
        "thoughts_token_count": 17775
      },
      "response_text_len": 4326
    }
  }
}