{
  "trial_id": "trial_3_7",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space that maximize the squared ratio (min_dist / max_dist)^2.\n    \n    The strategy uses a multi-start approach combining a smooth LogSumExp objective \n    with a high-precision refinement using the SLSQP optimizer.\n    \"\"\"\n    N = 14\n    dim = 3\n\n    def get_ratio_sq(pts):\n        \"\"\"Calculates the objective function: (min_dist / max_dist)^2.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0:\n            return 0.0\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def smooth_objective(x, k):\n        \"\"\"\n        Calculates a smooth approximation of -min_dist^2 / max_dist^2 \n        using a stable LogSumExp formulation.\n        \"\"\"\n        pts = x.reshape((N, dim))\n        dists_sq = pdist(pts, 'sqeuclidean')\n        \n        # Stable soft-min calculation\n        d_min_sq = np.min(dists_sq)\n        soft_min = d_min_sq - (1.0/k) * np.log(np.sum(np.exp(-k * (dists_sq - d_min_sq))))\n        \n        # Stable soft-max calculation\n        d_max_sq = np.max(dists_sq)\n        soft_max = d_max_sq + (1.0/k) * np.log(np.sum(np.exp(k * (dists_sq - d_max_sq))))\n        \n        return -soft_min / soft_max\n\n    best_pts = None\n    best_val = -1.0\n\n    # Define initial configurations for optimization\n    starts = []\n    \n    # 1. Fibonacci spiral on a sphere\n    phi = np.pi * (3. - np.sqrt(5.))  # Golden angle\n    pts_fib = []\n    for i in range(N):\n        y = 1 - (i / float(N - 1)) * 2\n        radius = np.sqrt(max(0.0, 1.0 - y * y))\n        theta = phi * i\n        pts_fib.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n    starts.append(np.array(pts_fib))\n    \n    # 2. Rhombic dodecahedron-like structure (Cube + face centers)\n    pts_cube = []\n    for i in [-1.0, 1.0]:\n        for j in [-1.0, 1.0]:\n            for k in [-1.0, 1.0]:\n                pts_cube.append([i, j, k])\n    # Face centers shifted outward\n    pts_cube.extend([[1.5, 0.0, 0.0], [-1.5, 0.0, 0.0], [0.0, 1.5, 0.0], \n                     [0.0, -1.5, 0.0], [0.0, 0.0, 1.5], [0.0, 0.0, -1.5]])\n    starts.append(np.array(pts_cube))\n    \n    # 3. Random normalized points on a sphere\n    pts_rand_sphere = np.random.normal(0, 1, (N, dim))\n    pts_rand_sphere /= np.linalg.norm(pts_rand_sphere, axis=1)[:, np.newaxis]\n    starts.append(pts_rand_sphere)\n    \n    # 4. Standard random initialization\n    starts.append(np.random.normal(0, 1, (N, dim)))\n\n    # Optimization Loop\n    for x0 in starts:\n        # Stage 1: Smooth optimization using L-BFGS-B (fast, gradient-based)\n        # We increase k to sharpen the approximation\n        res = minimize(smooth_objective, x0.flatten(), args=(50,), method='L-BFGS-B', options={'maxiter': 100})\n        res = minimize(smooth_objective, res.x, args=(200,), method='L-BFGS-B', options={'maxiter': 100})\n        \n        # Stage 2: Hard refinement using SLSQP with explicit min/max constraints\n        pts_current = res.x.reshape((N, dim))\n        \n        # Target: Maximize t (minimum squared distance)\n        def obj(x):\n            return -x[-1]\n        \n        # Constraints: all pairwise distances^2 >= t, and max distance^2 <= 1.0\n        def constr(x):\n            pts = x[:-1].reshape((N, dim))\n            t = x[-1]\n            dists_sq = pdist(pts, 'sqeuclidean')\n            c_min = dists_sq - t\n            c_max = 1.0 - np.max(dists_sq)\n            return np.concatenate([c_min, [c_max]])\n        \n        # Normalize current points to diameter 1 for initialization\n        dists_sq_init = pdist(pts_current, 'sqeuclidean')\n        max_d_sq = np.max(dists_sq_init)\n        pts_norm = pts_current / np.sqrt(max_d_sq)\n        t_norm = np.min(pdist(pts_norm, 'sqeuclidean'))\n        \n        x_refine = np.concatenate([pts_norm.flatten(), [t_norm]])\n        res_refine = minimize(obj, x_refine, method='SLSQP', \n                              constraints={'type': 'ineq', 'fun': constr},\n                              options={'maxiter': 150, 'ftol': 1e-8})\n        \n        # Keep track of the best solution found\n        if -res_refine.fun > best_val:\n            best_val = -res_refine.fun\n            best_pts = res_refine.x[:-1].reshape((N, dim))\n            \n    return best_pts",
  "metrics": {
    "valid": true,
    "score": 0.9305122146756699,
    "min_max_ratio": 0.22336672389071055,
    "min_distance": 0.5170351441357172,
    "max_distance": 1.0939836388152016,
    "eval_time": 1.7289421558380127,
    "error": null
  },
  "prompt": "Maximize the ratio (min_dist / max_dist)^2 for 14 points in 3D.\n        Strategy:\n        1. Initialize points using the optimal solution for the Tammes problem (14 points on a sphere).\n        2. Use these points as a starting configuration for a high-precision local optimizer (SLSQP or L-BFGS-B).\n        3. Since the points don't have to stay on a sphere, allow them to move radially to maximize the ratio.\n        4. Use a SoftMax or LogSumExp approximation of the minimum distance to create a smooth gradient for the optimizer before finishing with a hard min-dist optimization.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds 14 points in 3D space that maximize the squared ratio (min_dist / max_dist)^2.\n    \n    The strategy uses a multi-start approach combining a smooth LogSumExp objective \n    with a high-precision refinement using the SLSQP optimizer.\n    \"\"\"\n    N = 14\n    dim = 3\n\n    def get_ratio_sq(pts):\n        \"\"\"Calculates the objective function: (min_dist / max_dist)^2.\"\"\"\n        dists_sq = pdist(pts, 'sqeuclidean')\n        if len(dists_sq) == 0:\n            return 0.0\n        return np.min(dists_sq) / np.max(dists_sq)\n\n    def smooth_objective(x, k):\n        \"\"\"\n        Calculates a smooth approximation of -min_dist^2 / max_dist^2 \n        using a stable LogSumExp formulation.\n        \"\"\"\n        pts = x.reshape((N, dim))\n        dists_sq = pdist(pts, 'sqeuclidean')\n        \n        # Stable soft-min calculation\n        d_min_sq = np.min(dists_sq)\n        soft_min = d_min_sq - (1.0/k) * np.log(np.sum(np.exp(-k * (dists_sq - d_min_sq))))\n        \n        # Stable soft-max calculation\n        d_max_sq = np.max(dists_sq)\n        soft_max = d_max_sq + (1.0/k) * np.log(np.sum(np.exp(k * (dists_sq - d_max_sq))))\n        \n        return -soft_min / soft_max\n\n    best_pts = None\n    best_val = -1.0\n\n    # Define initial configurations for optimization\n    starts = []\n    \n    # 1. Fibonacci spiral on a sphere\n    phi = np.pi * (3. - np.sqrt(5.))  # Golden angle\n    pts_fib = []\n    for i in range(N):\n        y = 1 - (i / float(N - 1)) * 2\n        radius = np.sqrt(max(0.0, 1.0 - y * y))\n        theta = phi * i\n        pts_fib.append([radius * np.cos(theta), y, radius * np.sin(theta)])\n    starts.append(np.array(pts_fib))\n    \n    # 2. Rhombic dodecahedron-like structure (Cube + face centers)\n    pts_cube = []\n    for i in [-1.0, 1.0]:\n        for j in [-1.0, 1.0]:\n            for k in [-1.0, 1.0]:\n                pts_cube.append([i, j, k])\n    # Face centers shifted outward\n    pts_cube.extend([[1.5, 0.0, 0.0], [-1.5, 0.0, 0.0], [0.0, 1.5, 0.0], \n                     [0.0, -1.5, 0.0], [0.0, 0.0, 1.5], [0.0, 0.0, -1.5]])\n    starts.append(np.array(pts_cube))\n    \n    # 3. Random normalized points on a sphere\n    pts_rand_sphere = np.random.normal(0, 1, (N, dim))\n    pts_rand_sphere /= np.linalg.norm(pts_rand_sphere, axis=1)[:, np.newaxis]\n    starts.append(pts_rand_sphere)\n    \n    # 4. Standard random initialization\n    starts.append(np.random.normal(0, 1, (N, dim)))\n\n    # Optimization Loop\n    for x0 in starts:\n        # Stage 1: Smooth optimization using L-BFGS-B (fast, gradient-based)\n        # We increase k to sharpen the approximation\n        res = minimize(smooth_objective, x0.flatten(), args=(50,), method='L-BFGS-B', options={'maxiter': 100})\n        res = minimize(smooth_objective, res.x, args=(200,), method='L-BFGS-B', options={'maxiter': 100})\n        \n        # Stage 2: Hard refinement using SLSQP with explicit min/max constraints\n        pts_current = res.x.reshape((N, dim))\n        \n        # Target: Maximize t (minimum squared distance)\n        def obj(x):\n            return -x[-1]\n        \n        # Constraints: all pairwise distances^2 >= t, and max distance^2 <= 1.0\n        def constr(x):\n            pts = x[:-1].reshape((N, dim))\n            t = x[-1]\n            dists_sq = pdist(pts, 'sqeuclidean')\n            c_min = dists_sq - t\n            c_max = 1.0 - np.max(dists_sq)\n            return np.concatenate([c_min, [c_max]])\n        \n        # Normalize current points to diameter 1 for initialization\n        dists_sq_init = pdist(pts_current, 'sqeuclidean')\n        max_d_sq = np.max(dists_sq_init)\n        pts_norm = pts_current / np.sqrt(max_d_sq)\n        t_norm = np.min(pdist(pts_norm, 'sqeuclidean'))\n        \n        x_refine = np.concatenate([pts_norm.flatten(), [t_norm]])\n        res_refine = minimize(obj, x_refine, method='SLSQP', \n                              constraints={'type': 'ineq', 'fun': constr},\n                              options={'maxiter': 150, 'ftol': 1e-8})\n        \n        # Keep track of the best solution found\n        if -res_refine.fun > best_val:\n            best_val = -res_refine.fun\n            best_pts = res_refine.x[:-1].reshape((N, dim))\n            \n    return best_pts\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:26:16.315664",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 314,
        "candidates_token_count": 1502,
        "thoughts_token_count": 20576
      },
      "response_text_len": 4338
    }
  }
}