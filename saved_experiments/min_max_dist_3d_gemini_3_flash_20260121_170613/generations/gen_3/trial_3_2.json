{
  "trial_id": "trial_3_2",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution, minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds an arrangement of 14 points in 3D space that maximizes the squared ratio\n    (min pairwise distance / max pairwise distance)^2.\n    \n    Technique:\n    - Uses differential_evolution to find a near-global optimum.\n    - Uses SLSQP for local refinement of a smoothed objective function.\n    - Objective function: -1 * (min_dist / max_dist)**2.\n    - LogSumExp approximation is used for smooth min/max distance calculation.\n    \"\"\"\n    n_points = 14\n    dim = 3\n    indices = np.triu_indices(n_points, k=1)\n    \n    def get_dists(coords):\n        \"\"\"Calculates all unique pairwise distances between points.\"\"\"\n        pts = coords.reshape((n_points, dim))\n        # Compute difference vectors between all pairs\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        # Square differences and sum along the coordinate axis\n        dist_sq = np.sum(diff**2, axis=-1)\n        # Extract upper triangle (unique pairs i < j) and take sqrt\n        # Small epsilon added to ensure differentiability at zero\n        dists = np.sqrt(dist_sq[indices] + 1e-15)\n        return dists\n\n    def objective(coords):\n        \"\"\"Raw objective function to minimize: -1 * (min_dist / max_dist)**2.\"\"\"\n        pts = coords.reshape((n_points, dim))\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dists_sq = dist_sq[indices]\n        d_min_sq = np.min(dists_sq)\n        d_max_sq = np.max(dists_sq)\n        if d_max_sq == 0:\n            return 0\n        return -d_min_sq / d_max_sq\n\n    def smooth_objective(coords, k=100):\n        \"\"\"Smooth approximation of the objective using LogSumExp for min and max.\"\"\"\n        dists = get_dists(coords)\n        \n        # LogSumExp approximation for min(dists)\n        m_min = np.min(dists)\n        s_min = m_min - (1.0/k) * np.log(np.sum(np.exp(-k * (dists - m_min))))\n        \n        # LogSumExp approximation for max(dists)\n        m_max = np.max(dists)\n        s_max = m_max + (1.0/k) * np.log(np.sum(np.exp(k * (dists - m_max))))\n        \n        # Return negative squared ratio as the objective to minimize\n        return -(s_min / s_max)**2\n\n    # Define optimization bounds for 14 points * 3 dimensions\n    bounds = [(0, 1)] * (n_points * dim)\n    \n    # Global search using Differential Evolution\n    # Strategy 'best1bin' is typically effective for these geometric problems\n    res = differential_evolution(\n        objective,\n        bounds,\n        strategy='best1bin',\n        popsize=20,     # Large population multiplier (20 * 42 = 840 individuals)\n        maxiter=300,    # Number of generations\n        tol=1e-5,\n        polish=False,   # Custom polish with SLSQP follows\n        seed=42         # Fixed seed for reproducibility\n    )\n    \n    # Local refinement using SLSQP and the smoothed objective function\n    res_refined = minimize(\n        smooth_objective,\n        res.x,\n        method='SLSQP',\n        bounds=bounds,\n        options={'ftol': 1e-10, 'maxiter': 1000}\n    )\n    \n    # Reshape the flattened 1D array back to (14, 3)\n    final_points = res_refined.x.reshape((n_points, dim))\n    \n    return final_points",
  "metrics": {
    "valid": true,
    "score": 0.9732883208377839,
    "min_max_ratio": 0.23363500252643266,
    "min_distance": 0.5250502330764081,
    "max_distance": 1.0862552827945966,
    "eval_time": 7.895686149597168,
    "error": null
  },
  "prompt": "Use scipy.optimize.differential_evolution to find the optimal arrangement of 14 points in 3D.\n        - Objective: Minimize -1 * (min_dist / max_dist)**2.\n        - Bounds: [0, 1] for all 42 coordinates (14 points * 3 dims).\n        - Use a large population and 'best1bin' strategy.\n        - Crucially, use the 'polish' parameter or follow up with an SLSQP refinement to reach the local optimum.\n        - To handle the non-differentiability of min_dist, use a high-power LogSumExp: - (1/k) * log(sum(exp(-k * dists))) where k is large (e.g., 100).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution, minimize\n\ndef min_max_dist_dim3_14():\n    \"\"\"\n    Finds an arrangement of 14 points in 3D space that maximizes the squared ratio\n    (min pairwise distance / max pairwise distance)^2.\n    \n    Technique:\n    - Uses differential_evolution to find a near-global optimum.\n    - Uses SLSQP for local refinement of a smoothed objective function.\n    - Objective function: -1 * (min_dist / max_dist)**2.\n    - LogSumExp approximation is used for smooth min/max distance calculation.\n    \"\"\"\n    n_points = 14\n    dim = 3\n    indices = np.triu_indices(n_points, k=1)\n    \n    def get_dists(coords):\n        \"\"\"Calculates all unique pairwise distances between points.\"\"\"\n        pts = coords.reshape((n_points, dim))\n        # Compute difference vectors between all pairs\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        # Square differences and sum along the coordinate axis\n        dist_sq = np.sum(diff**2, axis=-1)\n        # Extract upper triangle (unique pairs i < j) and take sqrt\n        # Small epsilon added to ensure differentiability at zero\n        dists = np.sqrt(dist_sq[indices] + 1e-15)\n        return dists\n\n    def objective(coords):\n        \"\"\"Raw objective function to minimize: -1 * (min_dist / max_dist)**2.\"\"\"\n        pts = coords.reshape((n_points, dim))\n        diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dists_sq = dist_sq[indices]\n        d_min_sq = np.min(dists_sq)\n        d_max_sq = np.max(dists_sq)\n        if d_max_sq == 0:\n            return 0\n        return -d_min_sq / d_max_sq\n\n    def smooth_objective(coords, k=100):\n        \"\"\"Smooth approximation of the objective using LogSumExp for min and max.\"\"\"\n        dists = get_dists(coords)\n        \n        # LogSumExp approximation for min(dists)\n        m_min = np.min(dists)\n        s_min = m_min - (1.0/k) * np.log(np.sum(np.exp(-k * (dists - m_min))))\n        \n        # LogSumExp approximation for max(dists)\n        m_max = np.max(dists)\n        s_max = m_max + (1.0/k) * np.log(np.sum(np.exp(k * (dists - m_max))))\n        \n        # Return negative squared ratio as the objective to minimize\n        return -(s_min / s_max)**2\n\n    # Define optimization bounds for 14 points * 3 dimensions\n    bounds = [(0, 1)] * (n_points * dim)\n    \n    # Global search using Differential Evolution\n    # Strategy 'best1bin' is typically effective for these geometric problems\n    res = differential_evolution(\n        objective,\n        bounds,\n        strategy='best1bin',\n        popsize=20,     # Large population multiplier (20 * 42 = 840 individuals)\n        maxiter=300,    # Number of generations\n        tol=1e-5,\n        polish=False,   # Custom polish with SLSQP follows\n        seed=42         # Fixed seed for reproducibility\n    )\n    \n    # Local refinement using SLSQP and the smoothed objective function\n    res_refined = minimize(\n        smooth_objective,\n        res.x,\n        method='SLSQP',\n        bounds=bounds,\n        options={'ftol': 1e-10, 'maxiter': 1000}\n    )\n    \n    # Reshape the flattened 1D array back to (14, 3)\n    final_points = res_refined.x.reshape((n_points, dim))\n    \n    return final_points\n\n```",
  "reasoning": "",
  "timestamp": "2026-01-21T17:26:03.366451",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 339,
        "candidates_token_count": 994,
        "thoughts_token_count": 21441
      },
      "response_text_len": 3273
    }
  }
}