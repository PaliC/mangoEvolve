{
  "trial_id": "trial_1_3",
  "generation": 1,
  "parent_id": "trial_0_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start SLSQP optimization approach with 'shaking' (random perturbations)\n    to escape local optima.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Objective: Maximize the sum of radii.\n    # We minimize the negative sum for the scipy optimizer.\n    def objective(v):\n        return -np.sum(v[2*N:])\n\n    # Gradient of the objective function.\n    def jac_objective(v):\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    # Constraints: All must be >= 0 for 'ineq' type in scipy.optimize.minimize.\n    def constraints_func(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        \n        # 1. Boundary constraints: Circles must be entirely inside the [0,1]x[0,1] square.\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        b_cons = np.zeros(4*N)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1.0 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1.0 - y - r\n        \n        # 2. Non-overlap constraints: Distance between centers must be >= sum of radii.\n        # (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        i, j = np.triu_indices(N, k=1)\n        dist_sq = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n        \n        return np.concatenate([b_cons, dist_sq])\n\n    # Jacobian (gradient matrix) of the constraints.\n    def jac_constraints_func(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        \n        num_non_overlap = N*(N-1)//2\n        jac = np.zeros((4*N + num_non_overlap, 3*N))\n        \n        # Boundary constraints parts\n        for i in range(N):\n            # x_i - r_i >= 0\n            jac[4*i, i] = 1.0\n            jac[4*i, 2*N+i] = -1.0\n            # 1 - x_i - r_i >= 0\n            jac[4*i+1, i] = -1.0\n            jac[4*i+1, 2*N+i] = -1.0\n            # y_i - r_i >= 0\n            jac[4*i+2, N+i] = 1.0\n            jac[4*i+2, 2*N+i] = -1.0\n            # 1 - y_i - r_i >= 0\n            jac[4*i+3, N+i] = -1.0\n            jac[4*i+3, 2*N+i] = -1.0\n            \n        # Non-overlap constraints parts\n        i, j = np.triu_indices(N, k=1)\n        dx = x[i] - x[j]\n        dy = y[i] - y[j]\n        rs = r[i] + r[j]\n        \n        row_indices = np.arange(4*N, 4*N + num_non_overlap)\n        \n        # Vectorized assembly for efficiency\n        jac[row_indices, i] = 2 * dx\n        jac[row_indices, j] = -2 * dx\n        jac[row_indices, N+i] = 2 * dy\n        jac[row_indices, N+j] = -2 * dy\n        jac[row_indices, 2*N+i] = -2 * rs\n        jac[row_indices, 2*N+j] = -2 * rs\n        \n        return jac\n\n    # Box bounds for the variables: centers in [0,1], radii in [0,0.5]\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n    \n    # Initial seeds to explore different regions of the solution space\n    seeds = []\n    \n    # Seed 1: 5x5 grid plus one extra circle\n    xg1, yg1 = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    x1 = np.concatenate([xg1.flatten(), [0.5]])\n    y1 = np.concatenate([yg1.flatten(), [0.5]])\n    r1 = np.ones(N) * 0.04\n    seeds.append(np.concatenate([x1, y1, r1]))\n    \n    # Seed 2: 4x6 grid plus two extra circles\n    xg2, yg2 = np.meshgrid(np.linspace(0.12, 0.88, 4), np.linspace(0.08, 0.92, 6))\n    x2 = np.concatenate([xg2.flatten(), [0.5, 0.5]])\n    y2 = np.concatenate([yg2.flatten(), [0.1, 0.9]])\n    r2 = np.ones(N) * 0.04\n    seeds.append(np.concatenate([x2, y2, r2]))\n\n    # Seed 3: Random starts\n    np.random.seed(42)\n    for _ in range(3):\n        seeds.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.ones(N)*0.03]))\n\n    best_vars = seeds[0]\n    best_sum = 0\n    \n    # Main multi-start optimization loop\n    for v_start in seeds:\n        # Check time limit (300s total, we stop starting new runs at 280s)\n        if time.time() - start_time > 280:\n            break\n            \n        res = minimize(\n            objective, \n            v_start, \n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n            method='SLSQP',\n            bounds=bounds,\n            options={'maxiter': 100}\n        )\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n            \n        # Shaking phase: perturb the current result and re-optimize\n        curr_v = res.x\n        for shake_idx in range(5):\n            if time.time() - start_time > 280:\n                break\n            \n            # Decrease perturbation size as time progresses\n            shake_intensity = 0.02 * (1.0 - (time.time() - start_time) / 300.0)\n            shaken_v = curr_v + np.random.normal(0, max(shake_intensity, 0.001), size=3*N)\n            shaken_v[:2*N] = np.clip(shaken_v[:2*N], 0, 1)\n            shaken_v[2*N:] = np.clip(shaken_v[2*N:], 0, 0.5)\n            \n            res_s = minimize(\n                objective, \n                shaken_v, \n                jac=jac_objective,\n                constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                method='SLSQP',\n                bounds=bounds,\n                options={'maxiter': 80}\n            )\n            \n            if -res_s.fun > best_sum:\n                best_sum = -res_s.fun\n                best_vars = res_s.x\n                curr_v = res_s.x\n\n    # Final result formatting\n    centers = np.vstack([best_vars[:N], best_vars[N:2*N]]).T\n    radii = best_vars[2*N:]\n    \n    return centers, radii, float(best_sum)",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 2.127896547317505,
    "error": "Circle 2 at (0.7846496349354669, 0.3951642004597974) with radius 0.22224719163168494 extends outside x-bounds"
  },
  "prompt": "Use a multi-start approach with 'shaking'. Start with the best known configuration logic (two-stage: equal radii then variable), but perform multiple iterations where you take the best result, add small random noise to the centers ('shake'), and re-optimize. This helps escape local optima.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start SLSQP optimization approach with 'shaking' (random perturbations)\n    to escape local optima.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Objective: Maximize the sum of radii.\n    # We minimize the negative sum for the scipy optimizer.\n    def objective(v):\n        return -np.sum(v[2*N:])\n\n    # Gradient of the objective function.\n    def jac_objective(v):\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    # Constraints: All must be >= 0 for 'ineq' type in scipy.optimize.minimize.\n    def constraints_func(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        \n        # 1. Boundary constraints: Circles must be entirely inside the [0,1]x[0,1] square.\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        b_cons = np.zeros(4*N)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1.0 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1.0 - y - r\n        \n        # 2. Non-overlap constraints: Distance between centers must be >= sum of radii.\n        # (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        i, j = np.triu_indices(N, k=1)\n        dist_sq = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n        \n        return np.concatenate([b_cons, dist_sq])\n\n    # Jacobian (gradient matrix) of the constraints.\n    def jac_constraints_func(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        \n        num_non_overlap = N*(N-1)//2\n        jac = np.zeros((4*N + num_non_overlap, 3*N))\n        \n        # Boundary constraints parts\n        for i in range(N):\n            # x_i - r_i >= 0\n            jac[4*i, i] = 1.0\n            jac[4*i, 2*N+i] = -1.0\n            # 1 - x_i - r_i >= 0\n            jac[4*i+1, i] = -1.0\n            jac[4*i+1, 2*N+i] = -1.0\n            # y_i - r_i >= 0\n            jac[4*i+2, N+i] = 1.0\n            jac[4*i+2, 2*N+i] = -1.0\n            # 1 - y_i - r_i >= 0\n            jac[4*i+3, N+i] = -1.0\n            jac[4*i+3, 2*N+i] = -1.0\n            \n        # Non-overlap constraints parts\n        i, j = np.triu_indices(N, k=1)\n        dx = x[i] - x[j]\n        dy = y[i] - y[j]\n        rs = r[i] + r[j]\n        \n        row_indices = np.arange(4*N, 4*N + num_non_overlap)\n        \n        # Vectorized assembly for efficiency\n        jac[row_indices, i] = 2 * dx\n        jac[row_indices, j] = -2 * dx\n        jac[row_indices, N+i] = 2 * dy\n        jac[row_indices, N+j] = -2 * dy\n        jac[row_indices, 2*N+i] = -2 * rs\n        jac[row_indices, 2*N+j] = -2 * rs\n        \n        return jac\n\n    # Box bounds for the variables: centers in [0,1], radii in [0,0.5]\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n    \n    # Initial seeds to explore different regions of the solution space\n    seeds = []\n    \n    # Seed 1: 5x5 grid plus one extra circle\n    xg1, yg1 = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    x1 = np.concatenate([xg1.flatten(), [0.5]])\n    y1 = np.concatenate([yg1.flatten(), [0.5]])\n    r1 = np.ones(N) * 0.04\n    seeds.append(np.concatenate([x1, y1, r1]))\n    \n    # Seed 2: 4x6 grid plus two extra circles\n    xg2, yg2 = np.meshgrid(np.linspace(0.12, 0.88, 4), np.linspace(0.08, 0.92, 6))\n    x2 = np.concatenate([xg2.flatten(), [0.5, 0.5]])\n    y2 = np.concatenate([yg2.flatten(), [0.1, 0.9]])\n    r2 = np.ones(N) * 0.04\n    seeds.append(np.concatenate([x2, y2, r2]))\n\n    # Seed 3: Random starts\n    np.random.seed(42)\n    for _ in range(3):\n        seeds.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.ones(N)*0.03]))\n\n    best_vars = seeds[0]\n    best_sum = 0\n    \n    # Main multi-start optimization loop\n    for v_start in seeds:\n        # Check time limit (300s total, we stop starting new runs at 280s)\n        if time.time() - start_time > 280:\n            break\n            \n        res = minimize(\n            objective, \n            v_start, \n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n            method='SLSQP',\n            bounds=bounds,\n            options={'maxiter': 100}\n        )\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n            \n        # Shaking phase: perturb the current result and re-optimize\n        curr_v = res.x\n        for shake_idx in range(5):\n            if time.time() - start_time > 280:\n                break\n            \n            # Decrease perturbation size as time progresses\n            shake_intensity = 0.02 * (1.0 - (time.time() - start_time) / 300.0)\n            shaken_v = curr_v + np.random.normal(0, max(shake_intensity, 0.001), size=3*N)\n            shaken_v[:2*N] = np.clip(shaken_v[:2*N], 0, 1)\n            shaken_v[2*N:] = np.clip(shaken_v[2*N:], 0, 0.5)\n            \n            res_s = minimize(\n                objective, \n                shaken_v, \n                jac=jac_objective,\n                constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                method='SLSQP',\n                bounds=bounds,\n                options={'maxiter': 80}\n            )\n            \n            if -res_s.fun > best_sum:\n                best_sum = -res_s.fun\n                best_vars = res_s.x\n                curr_v = res_s.x\n\n    # Final result formatting\n    centers = np.vstack([best_vars[:N], best_vars[N:2*N]]).T\n    radii = best_vars[2*N:]\n    \n    return centers, radii, float(best_sum)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:01:20.833289",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 288,
        "candidates_token_count": 2125,
        "thoughts_token_count": 20993
      },
      "response_text_len": 5679
    }
  },
  "llm_call_duration_s": 130.74297412205487,
  "eval_duration_s": 2.1279042470268905
}