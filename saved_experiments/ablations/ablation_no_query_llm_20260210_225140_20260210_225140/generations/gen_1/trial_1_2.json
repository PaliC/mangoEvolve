{
  "trial_id": "trial_1_2",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef force_directed_vectorized(n, iterations=400):\n    \"\"\"\n    Force-directed simulation to spread points out in a unit square.\n    Uses repulsion forces between points and between points and walls.\n    \"\"\"\n    # Initialize points in the center area to avoid immediate wall collisions\n    pos = np.random.rand(n, 2) * 0.6 + 0.2\n    dt = 0.005\n    for _ in range(iterations):\n        # Calculate pairwise differences and squared distances\n        diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=2)\n        \n        # Add epsilon to the diagonal for numerical stability\n        np.fill_diagonal(d2, 1.0)\n        \n        # Calculate repulsion force: F = sum(diff / dist^3)\n        # Using d2^1.5 because dist = sqrt(d2)\n        f_pair = diff / (d2[:, :, np.newaxis]**1.5 + 1e-8)\n        \n        # Clear self-repulsion forces\n        np.fill_diagonal(f_pair[:, :, 0], 0)\n        np.fill_diagonal(f_pair[:, :, 1], 0)\n        \n        # Sum forces from other points\n        forces = np.sum(f_pair, axis=1) * 0.001\n        \n        # Boundary repulsion forces (1/d^2)\n        forces[:, 0] += 0.001 / (pos[:, 0]**2 + 1e-8)\n        forces[:, 0] -= 0.001 / ((1.0 - pos[:, 0])**2 + 1e-8)\n        forces[:, 1] += 0.001 / (pos[:, 1]**2 + 1e-8)\n        forces[:, 1] -= 0.001 / ((1.0 - pos[:, 1])**2 + 1e-8)\n        \n        # Update positions and clip to keep them inside the square\n        pos += forces * dt\n        pos = np.clip(pos, 0.001, 0.999)\n        \n    return pos\n\ndef objective(x_flat):\n    \"\"\"Objective function: Minimize the negative sum of radii.\"\"\"\n    # Radii are the last 26 elements\n    return -np.sum(x_flat[52:78])\n\ndef objective_grad(x_flat):\n    \"\"\"Gradient of the objective function.\"\"\"\n    grad = np.zeros(78)\n    grad[52:78] = -1.0\n    return grad\n\ndef constraints(x_flat):\n    \"\"\"\n    Vectorized calculation of constraints for SLSQP.\n    Returns an array of values that must be non-negative.\n    \"\"\"\n    x = x_flat[:26]\n    y = x_flat[26:52]\n    r = x_flat[52:78]\n    \n    # 104 Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n    c_boundary = np.zeros(104)\n    c_boundary[0::4] = x - r\n    c_boundary[1::4] = 1.0 - x - r\n    c_boundary[2::4] = y - r\n    c_boundary[3::4] = 1.0 - y - r\n    \n    # 325 Pairwise distance constraints: dist - (r_i + r_j) >= 0\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n    \n    dr = r[:, np.newaxis] + r[np.newaxis, :]\n    \n    # Use upper triangle indices to avoid double-counting and diagonal elements\n    indices = np.triu_indices(26, k=1)\n    c_dist = dist[indices] - dr[indices]\n    \n    return np.concatenate([c_boundary, c_dist])\n\ndef run_packing():\n    \"\"\"Main function to perform circle packing optimization.\"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Parameter bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1)] * 52 + [(0, 0.5)] * 26\n    cons = {'type': 'ineq', 'fun': constraints}\n    \n    # Run multiple restarts with different initializations\n    # Target 8-10 restarts within 300 seconds\n    for seed in range(12):\n        if time.time() - start_time > 280:\n            break\n            \n        np.random.seed(seed + 42)\n        \n        # 1. Initialization: Force-directed simulation for centers\n        centers = force_directed_vectorized(n)\n        \n        # 2. Initial guess for radii: Start small to ensure feasibility\n        radii = np.ones(n) * 0.02\n        \n        # Concatenate x, y, and r into a single variable vector\n        x0 = np.concatenate([centers[:, 0], centers[:, 1], radii])\n        \n        # 3. Optimization using SLSQP\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            jac=objective_grad,\n            constraints=cons, \n            bounds=bounds,\n            options={'maxiter': 500, 'ftol': 1e-8}\n        )\n        \n        # Track the best solution found so far\n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = np.column_stack([res.x[:26], res.x[26:52]])\n            best_radii = res.x[52:78]\n            \n    # Fallback in case no optimization succeeded\n    if best_centers is None:\n        best_centers = np.random.rand(26, 2)\n        best_radii = np.ones(26) * 0.01\n        best_sum = np.sum(best_radii)\n        \n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6239972371663685,
    "eval_time": 1.3808894157409668,
    "error": null
  },
  "prompt": "Implement a force-directed (repulsion) simulation to find a good initial configuration for 26 circles. Treat circles as particles that repel each other and the boundaries. After the simulation stabilizes, use the positions as seeds for an SLSQP optimization to maximize the sum of radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef force_directed_vectorized(n, iterations=400):\n    \"\"\"\n    Force-directed simulation to spread points out in a unit square.\n    Uses repulsion forces between points and between points and walls.\n    \"\"\"\n    # Initialize points in the center area to avoid immediate wall collisions\n    pos = np.random.rand(n, 2) * 0.6 + 0.2\n    dt = 0.005\n    for _ in range(iterations):\n        # Calculate pairwise differences and squared distances\n        diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n        d2 = np.sum(diff**2, axis=2)\n        \n        # Add epsilon to the diagonal for numerical stability\n        np.fill_diagonal(d2, 1.0)\n        \n        # Calculate repulsion force: F = sum(diff / dist^3)\n        # Using d2^1.5 because dist = sqrt(d2)\n        f_pair = diff / (d2[:, :, np.newaxis]**1.5 + 1e-8)\n        \n        # Clear self-repulsion forces\n        np.fill_diagonal(f_pair[:, :, 0], 0)\n        np.fill_diagonal(f_pair[:, :, 1], 0)\n        \n        # Sum forces from other points\n        forces = np.sum(f_pair, axis=1) * 0.001\n        \n        # Boundary repulsion forces (1/d^2)\n        forces[:, 0] += 0.001 / (pos[:, 0]**2 + 1e-8)\n        forces[:, 0] -= 0.001 / ((1.0 - pos[:, 0])**2 + 1e-8)\n        forces[:, 1] += 0.001 / (pos[:, 1]**2 + 1e-8)\n        forces[:, 1] -= 0.001 / ((1.0 - pos[:, 1])**2 + 1e-8)\n        \n        # Update positions and clip to keep them inside the square\n        pos += forces * dt\n        pos = np.clip(pos, 0.001, 0.999)\n        \n    return pos\n\ndef objective(x_flat):\n    \"\"\"Objective function: Minimize the negative sum of radii.\"\"\"\n    # Radii are the last 26 elements\n    return -np.sum(x_flat[52:78])\n\ndef objective_grad(x_flat):\n    \"\"\"Gradient of the objective function.\"\"\"\n    grad = np.zeros(78)\n    grad[52:78] = -1.0\n    return grad\n\ndef constraints(x_flat):\n    \"\"\"\n    Vectorized calculation of constraints for SLSQP.\n    Returns an array of values that must be non-negative.\n    \"\"\"\n    x = x_flat[:26]\n    y = x_flat[26:52]\n    r = x_flat[52:78]\n    \n    # 104 Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n    c_boundary = np.zeros(104)\n    c_boundary[0::4] = x - r\n    c_boundary[1::4] = 1.0 - x - r\n    c_boundary[2::4] = y - r\n    c_boundary[3::4] = 1.0 - y - r\n    \n    # 325 Pairwise distance constraints: dist - (r_i + r_j) >= 0\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n    \n    dr = r[:, np.newaxis] + r[np.newaxis, :]\n    \n    # Use upper triangle indices to avoid double-counting and diagonal elements\n    indices = np.triu_indices(26, k=1)\n    c_dist = dist[indices] - dr[indices]\n    \n    return np.concatenate([c_boundary, c_dist])\n\ndef run_packing():\n    \"\"\"Main function to perform circle packing optimization.\"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Parameter bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1)] * 52 + [(0, 0.5)] * 26\n    cons = {'type': 'ineq', 'fun': constraints}\n    \n    # Run multiple restarts with different initializations\n    # Target 8-10 restarts within 300 seconds\n    for seed in range(12):\n        if time.time() - start_time > 280:\n            break\n            \n        np.random.seed(seed + 42)\n        \n        # 1. Initialization: Force-directed simulation for centers\n        centers = force_directed_vectorized(n)\n        \n        # 2. Initial guess for radii: Start small to ensure feasibility\n        radii = np.ones(n) * 0.02\n        \n        # Concatenate x, y, and r into a single variable vector\n        x0 = np.concatenate([centers[:, 0], centers[:, 1], radii])\n        \n        # 3. Optimization using SLSQP\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            jac=objective_grad,\n            constraints=cons, \n            bounds=bounds,\n            options={'maxiter': 500, 'ftol': 1e-8}\n        )\n        \n        # Track the best solution found so far\n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = np.column_stack([res.x[:26], res.x[26:52]])\n            best_radii = res.x[52:78]\n            \n    # Fallback in case no optimization succeeded\n    if best_centers is None:\n        best_centers = np.random.rand(26, 2)\n        best_radii = np.ones(26) * 0.01\n        best_sum = np.sum(best_radii)\n        \n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:00:58.564195",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 284,
        "candidates_token_count": 1624,
        "thoughts_token_count": 16884
      },
      "response_text_len": 4673
    }
  },
  "llm_call_duration_s": 109.22138912498485,
  "eval_duration_s": 1.3808965649222955
}