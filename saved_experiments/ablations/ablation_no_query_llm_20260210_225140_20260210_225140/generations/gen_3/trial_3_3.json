{
  "trial_id": "trial_3_3",
  "generation": 3,
  "parent_id": "trial_2_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Basin-Hopping inspired approach with SLSQP as the local minimizer.\n    \"\"\"\n    N = 26\n    \n    # The objective function is the negative sum of radii.\n    def objective(v):\n        # v is structured as [x0...x25, y0...y25, r0...r25]\n        return -np.sum(v[2*N:3*N])\n\n    # Gradient of the objective function.\n    def objective_grad(v):\n        grad = np.zeros(3 * N)\n        grad[2*N:3*N] = -1.0\n        return grad\n\n    # Constraints: circles must be inside the square and must not overlap.\n    def all_constraints(v):\n        x = v[0:N]\n        y = v[N:2*N]\n        r = v[2*N:3*N]\n        \n        # Boundary constraints: 4 per circle (left, right, bottom, top)\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        c_boundary = np.zeros(4 * N)\n        c_boundary[0::4] = x - r\n        c_boundary[1::4] = 1.0 - x - r\n        c_boundary[2::4] = y - r\n        c_boundary[3::4] = 1.0 - y - r\n        \n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        i_idx, j_idx = np.triu_indices(N, k=1)\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dists = np.sqrt(dx*dx + dy*dy)\n        c_overlap = dists - (r[i_idx] + r[j_idx])\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    # Jacobian of the constraint functions to speed up the SLSQP optimizer.\n    def constraints_jacobian(v):\n        x = v[0:N]\n        y = v[N:2*N]\n        r = v[2*N:3*N]\n        \n        # Boundary constraints Jacobian\n        jac_boundary = np.zeros((4 * N, 3 * N))\n        for i in range(N):\n            jac_boundary[4*i, i] = 1.0           # d(x_i - r_i)/dx_i\n            jac_boundary[4*i, 2*N+i] = -1.0      # d(x_i - r_i)/dr_i\n            jac_boundary[4*i+1, i] = -1.0        # d(1 - x_i - r_i)/dx_i\n            jac_boundary[4*i+1, 2*N+i] = -1.0    # d(1 - x_i - r_i)/dr_i\n            jac_boundary[4*i+2, N+i] = 1.0       # d(y_i - r_i)/dy_i\n            jac_boundary[4*i+2, 2*N+i] = -1.0    # d(y_i - r_i)/dr_i\n            jac_boundary[4*i+3, N+i] = -1.0      # d(1 - y_i - r_i)/dy_i\n            jac_boundary[4*i+3, 2*N+i] = -1.0    # d(1 - y_i - r_i)/dr_i\n            \n        # Overlap constraints Jacobian\n        num_overlap = N * (N - 1) // 2\n        jac_overlap = np.zeros((num_overlap, 3 * N))\n        i_idx, j_idx = np.triu_indices(N, k=1)\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dists = np.sqrt(dx*dx + dy*dy)\n        dists_safe = np.where(dists < 1e-9, 1e-9, dists)\n        \n        row_idx = np.arange(num_overlap)\n        jac_overlap[row_idx, i_idx] = dx / dists_safe\n        jac_overlap[row_idx, j_idx] = -dx / dists_safe\n        jac_overlap[row_idx, N+i_idx] = dy / dists_safe\n        jac_overlap[row_idx, N+j_idx] = -dy / dists_safe\n        jac_overlap[row_idx, 2*N+i_idx] = -1.0\n        jac_overlap[row_idx, 2*N+j_idx] = -1.0\n        \n        return np.vstack([jac_boundary, jac_overlap])\n\n    # Variable bounds\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n    \n    start_time = time.time()\n    best_sum_r = 0\n    best_v = None\n    \n    # 1. Start with a grid-based initial guess\n    x_grid, y_grid = np.meshgrid(np.linspace(0.11, 0.89, 5), np.linspace(0.11, 0.89, 5))\n    x_init = np.append(x_grid.flatten(), 0.5)\n    y_init = np.append(y_grid.flatten(), 0.5)\n    v_init = np.concatenate([x_init, y_init, np.full(N, 0.05)])\n    \n    # Multi-start and Basin-Hopping loop\n    attempt = 0\n    while time.time() - start_time < 280:\n        if attempt == 0:\n            v_start = v_init\n        else:\n            # Randomize centers and start with small radii\n            v_start = np.concatenate([np.random.rand(2 * N), np.full(N, 0.05)])\n        \n        res = minimize(objective, v_start, method='SLSQP', jac=objective_grad,\n                       constraints={'type': 'ineq', 'fun': all_constraints, 'jac': constraints_jacobian},\n                       bounds=bounds, options={'maxiter': 100})\n        \n        if -res.fun > best_sum_r:\n            best_sum_r = -res.fun\n            best_v = res.x\n        \n        # Basin-Hopping step: if we found a good local minimum, perturb it and re-optimize\n        if best_v is not None:\n            for _ in range(2):\n                if time.time() - start_time > 280:\n                    break\n                v_perturbed = best_v.copy()\n                # Custom 'take_step': perturb centers slightly\n                v_perturbed[:2*N] += np.random.normal(0, 0.03, 2*N)\n                v_perturbed[:2*N] = np.clip(v_perturbed[:2*N], 0, 1)\n                # Perturb radii slightly\n                v_perturbed[2*N:] = np.clip(v_perturbed[2*N:] + np.random.normal(0, 0.01, N), 0, 0.5)\n                \n                res_p = minimize(objective, v_perturbed, method='SLSQP', jac=objective_grad,\n                                 constraints={'type': 'ineq', 'fun': all_constraints, 'jac': constraints_jacobian},\n                                 bounds=bounds, options={'maxiter': 100})\n                \n                if -res_p.fun > best_sum_r:\n                    best_sum_r = -res_p.fun\n                    best_v = res_p.x\n        attempt += 1\n\n    # Final extraction of centers and radii\n    centers = np.zeros((N, 2))\n    centers[:, 0] = best_v[0:N]\n    centers[:, 1] = best_v[N:2*N]\n    radii = best_v[2*N:3*N]\n    \n    return centers, radii, best_sum_r",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 285.0466876029968,
    "error": "Circle 0 at (1.0, 0.0) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "Implement a 'Basin-Hopping' inspired approach using SLSQP as the local minimizer.\nThe objective function should be the negative sum of radii.\nThe state space is the 26 centers (x, y). \nInside the objective function, for any given centers, calculate the optimal radii such that sum(radii) is maximized. This can be done by treating radii as variables in the SLSQP optimization (52 center variables + 26 radius variables).\nUse a custom 'take_step' that moves centers and ensures they stay within [0,1].",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Basin-Hopping inspired approach with SLSQP as the local minimizer.\n    \"\"\"\n    N = 26\n    \n    # The objective function is the negative sum of radii.\n    def objective(v):\n        # v is structured as [x0...x25, y0...y25, r0...r25]\n        return -np.sum(v[2*N:3*N])\n\n    # Gradient of the objective function.\n    def objective_grad(v):\n        grad = np.zeros(3 * N)\n        grad[2*N:3*N] = -1.0\n        return grad\n\n    # Constraints: circles must be inside the square and must not overlap.\n    def all_constraints(v):\n        x = v[0:N]\n        y = v[N:2*N]\n        r = v[2*N:3*N]\n        \n        # Boundary constraints: 4 per circle (left, right, bottom, top)\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        c_boundary = np.zeros(4 * N)\n        c_boundary[0::4] = x - r\n        c_boundary[1::4] = 1.0 - x - r\n        c_boundary[2::4] = y - r\n        c_boundary[3::4] = 1.0 - y - r\n        \n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        i_idx, j_idx = np.triu_indices(N, k=1)\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dists = np.sqrt(dx*dx + dy*dy)\n        c_overlap = dists - (r[i_idx] + r[j_idx])\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    # Jacobian of the constraint functions to speed up the SLSQP optimizer.\n    def constraints_jacobian(v):\n        x = v[0:N]\n        y = v[N:2*N]\n        r = v[2*N:3*N]\n        \n        # Boundary constraints Jacobian\n        jac_boundary = np.zeros((4 * N, 3 * N))\n        for i in range(N):\n            jac_boundary[4*i, i] = 1.0           # d(x_i - r_i)/dx_i\n            jac_boundary[4*i, 2*N+i] = -1.0      # d(x_i - r_i)/dr_i\n            jac_boundary[4*i+1, i] = -1.0        # d(1 - x_i - r_i)/dx_i\n            jac_boundary[4*i+1, 2*N+i] = -1.0    # d(1 - x_i - r_i)/dr_i\n            jac_boundary[4*i+2, N+i] = 1.0       # d(y_i - r_i)/dy_i\n            jac_boundary[4*i+2, 2*N+i] = -1.0    # d(y_i - r_i)/dr_i\n            jac_boundary[4*i+3, N+i] = -1.0      # d(1 - y_i - r_i)/dy_i\n            jac_boundary[4*i+3, 2*N+i] = -1.0    # d(1 - y_i - r_i)/dr_i\n            \n        # Overlap constraints Jacobian\n        num_overlap = N * (N - 1) // 2\n        jac_overlap = np.zeros((num_overlap, 3 * N))\n        i_idx, j_idx = np.triu_indices(N, k=1)\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dists = np.sqrt(dx*dx + dy*dy)\n        dists_safe = np.where(dists < 1e-9, 1e-9, dists)\n        \n        row_idx = np.arange(num_overlap)\n        jac_overlap[row_idx, i_idx] = dx / dists_safe\n        jac_overlap[row_idx, j_idx] = -dx / dists_safe\n        jac_overlap[row_idx, N+i_idx] = dy / dists_safe\n        jac_overlap[row_idx, N+j_idx] = -dy / dists_safe\n        jac_overlap[row_idx, 2*N+i_idx] = -1.0\n        jac_overlap[row_idx, 2*N+j_idx] = -1.0\n        \n        return np.vstack([jac_boundary, jac_overlap])\n\n    # Variable bounds\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n    \n    start_time = time.time()\n    best_sum_r = 0\n    best_v = None\n    \n    # 1. Start with a grid-based initial guess\n    x_grid, y_grid = np.meshgrid(np.linspace(0.11, 0.89, 5), np.linspace(0.11, 0.89, 5))\n    x_init = np.append(x_grid.flatten(), 0.5)\n    y_init = np.append(y_grid.flatten(), 0.5)\n    v_init = np.concatenate([x_init, y_init, np.full(N, 0.05)])\n    \n    # Multi-start and Basin-Hopping loop\n    attempt = 0\n    while time.time() - start_time < 280:\n        if attempt == 0:\n            v_start = v_init\n        else:\n            # Randomize centers and start with small radii\n            v_start = np.concatenate([np.random.rand(2 * N), np.full(N, 0.05)])\n        \n        res = minimize(objective, v_start, method='SLSQP', jac=objective_grad,\n                       constraints={'type': 'ineq', 'fun': all_constraints, 'jac': constraints_jacobian},\n                       bounds=bounds, options={'maxiter': 100})\n        \n        if -res.fun > best_sum_r:\n            best_sum_r = -res.fun\n            best_v = res.x\n        \n        # Basin-Hopping step: if we found a good local minimum, perturb it and re-optimize\n        if best_v is not None:\n            for _ in range(2):\n                if time.time() - start_time > 280:\n                    break\n                v_perturbed = best_v.copy()\n                # Custom 'take_step': perturb centers slightly\n                v_perturbed[:2*N] += np.random.normal(0, 0.03, 2*N)\n                v_perturbed[:2*N] = np.clip(v_perturbed[:2*N], 0, 1)\n                # Perturb radii slightly\n                v_perturbed[2*N:] = np.clip(v_perturbed[2*N:] + np.random.normal(0, 0.01, N), 0, 0.5)\n                \n                res_p = minimize(objective, v_perturbed, method='SLSQP', jac=objective_grad,\n                                 constraints={'type': 'ineq', 'fun': all_constraints, 'jac': constraints_jacobian},\n                                 bounds=bounds, options={'maxiter': 100})\n                \n                if -res_p.fun > best_sum_r:\n                    best_sum_r = -res_p.fun\n                    best_v = res_p.x\n        attempt += 1\n\n    # Final extraction of centers and radii\n    centers = np.zeros((N, 2))\n    centers[:, 0] = best_v[0:N]\n    centers[:, 1] = best_v[N:2*N]\n    radii = best_v[2*N:3*N]\n    \n    return centers, radii, best_sum_r\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:21:46.764015",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 349,
        "candidates_token_count": 2087,
        "thoughts_token_count": 18845
      },
      "response_text_len": 5533
    }
  },
  "llm_call_duration_s": 110.75844975700602,
  "eval_duration_s": 285.0466990810819
}