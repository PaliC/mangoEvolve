{
  "trial_id": "trial_8_0",
  "generation": 8,
  "parent_id": "trial_6_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\n# Expert algorithm designer solution for Circle Packing (n=26)\n# Optimization objective: Maximize the sum of radii in a unit square [0,1]x[0,1]\n\n# Constants\nN_CIRCLES = 26\nTRIU_I, TRIU_J = np.triu_indices(N_CIRCLES, k=1)\n\ndef run_packing():\n    \"\"\"\n    Main function to pack 26 circles into a unit square.\n    Uses SLSQP refinement on a set of initial configurations,\n    applying analytical Jacobians and multi-start perturbations.\n    \"\"\"\n    n = N_CIRCLES\n    triu_i, triu_j = TRIU_I, TRIU_J\n\n    def objective(v):\n        \"\"\"Minimize the negative sum of radii.\"\"\"\n        return -np.sum(v[2*n:])\n\n    def jac_objective(v):\n        \"\"\"Analytical Jacobian for the sum of radii.\"\"\"\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    def constraints(v):\n        \"\"\"\n        Constraints:\n        1. Circles must be inside the square [0, 1]x[0, 1].\n        2. Circles must not overlap.\n        \"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        \n        # Box constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        c_box = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Distance constraints: (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        dx = x[triu_i] - x[triu_j]\n        dy = y[triu_i] - y[triu_j]\n        dr = r[triu_i] + r[triu_j]\n        c_dist = dx*dx + dy*dy - dr*dr\n        \n        return np.concatenate([c_box, c_dist])\n\n    def jac_constraints(v):\n        \"\"\"Analytical Jacobian for all constraints.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        num_dist = n * (n - 1) // 2\n        jac = np.zeros((4 * n + num_dist, 3 * n))\n        \n        # Jacobian for Box constraints\n        for i in range(n):\n            # x_i - r_i >= 0\n            jac[i, i] = 1.0\n            jac[i, 2*n + i] = -1.0\n            # 1 - x_i - r_i >= 0\n            jac[n + i, i] = -1.0\n            jac[n + i, 2*n + i] = -1.0\n            # y_i - r_i >= 0\n            jac[2*n + i, n + i] = 1.0\n            jac[2*n + i, 2*n + i] = -1.0\n            # 1 - y_i - r_i >= 0\n            jac[3*n + i, n + i] = -1.0\n            jac[3*n + i, 2*n + i] = -1.0\n            \n        # Jacobian for Distance constraints\n        idx_offset = 4 * n\n        dx = x[triu_i] - x[triu_j]\n        dy = y[triu_i] - y[triu_j]\n        dr = r[triu_i] + r[triu_j]\n        \n        idx_range = np.arange(num_dist)\n        jac[idx_offset + idx_range, triu_i] = 2.0 * dx\n        jac[idx_offset + idx_range, triu_j] = -2.0 * dx\n        jac[idx_offset + idx_range, n + triu_i] = 2.0 * dy\n        jac[idx_offset + idx_range, n + triu_j] = -2.0 * dy\n        jac[idx_offset + idx_range, 2*n + triu_i] = -2.0 * dr\n        jac[idx_offset + idx_range, 2*n + triu_j] = -2.0 * dr\n        \n        return jac\n\n    # Variable bounds: centers in [0, 1], radii in [0, 0.5]\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n\n    best_sum = 0\n    best_v = None\n    \n    # Use a fixed seed for reproducibility across the multi-start logic\n    np.random.seed(42)\n    \n    # 1. Multi-start Phase: Find a high-quality global candidate\n    for i in range(12):\n        if i == 0:\n            # Start with a standard 5x5 grid + 1 extra circle\n            xs, ys = np.meshgrid(np.linspace(0.12, 0.88, 5), np.linspace(0.12, 0.88, 5))\n            c = np.vstack([xs.ravel(), ys.ravel()]).T\n            c = np.vstack([c, [0.5, 0.5]])\n            c += np.random.normal(0, 0.01, size=c.shape)\n        else:\n            # Structured random start based on perturbed grid\n            xs, ys = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            c = np.vstack([xs.ravel(), ys.ravel()]).T\n            c = np.vstack([c, [np.random.rand(), np.random.rand()]])\n            c += np.random.uniform(-0.1, 0.1, size=c.shape)\n        \n        c = np.clip(c, 0.05, 0.95)\n        v_start = np.concatenate([c[:, 0], c[:, 1], np.full(n, 0.04)])\n        \n        res = minimize(\n            objective, v_start, jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            method='SLSQP', bounds=bounds,\n            options={'ftol': 1e-10, 'maxiter': 600}\n        )\n        \n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_v = res.x\n\n    # 2. High-Precision Refinement Phase\n    # Refine the best configuration using tiny perturbations and tighter tolerances\n    if best_v is not None:\n        for _ in range(5):\n            # Apply tiny perturbation (1e-7) to the centers of the current best\n            guess = best_v.copy()\n            guess[:2*n] += np.random.normal(0, 1e-7, size=2*n)\n            \n            res_refine = minimize(\n                objective, guess, jac=jac_objective,\n                constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                method='SLSQP', bounds=bounds,\n                options={'ftol': 1e-15, 'maxiter': 2000}\n            )\n            \n            if -res_refine.fun > best_sum:\n                best_sum = -res_refine.fun\n                best_v = res_refine.x\n\n    # Prepare final output\n    centers = np.vstack([best_v[:n], best_v[n:2*n]]).T\n    radii = best_v[2*n:]\n    final_sum = np.sum(radii)\n    \n    return centers, radii, final_sum",
  "metrics": {
    "valid": true,
    "score": 2.6192331167557663,
    "eval_time": 1.7506539821624756,
    "error": null
  },
  "prompt": "The best score so far is 2.6359830855348263 from trial_6_5.\n        Your goal is to refine this specific configuration. \n        1. Extract the best configuration logic from trial_6_5.\n        2. Implement a high-precision refinement using SLSQP with:\n           - ftol: 1e-15\n           - maxiter: 2000\n           - Precise analytical Jacobians for the constraints (r_i + r_j <= distance_ij).\n        3. Use a multi-start approach where you apply TINY perturbations (1e-7) to the centers of the trial_6_5 configuration and re-optimize.\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Expert algorithm designer solution for Circle Packing (n=26)\n# Optimization objective: Maximize the sum of radii in a unit square [0,1]x[0,1]\n\n# Constants\nN_CIRCLES = 26\nTRIU_I, TRIU_J = np.triu_indices(N_CIRCLES, k=1)\n\ndef run_packing():\n    \"\"\"\n    Main function to pack 26 circles into a unit square.\n    Uses SLSQP refinement on a set of initial configurations,\n    applying analytical Jacobians and multi-start perturbations.\n    \"\"\"\n    n = N_CIRCLES\n    triu_i, triu_j = TRIU_I, TRIU_J\n\n    def objective(v):\n        \"\"\"Minimize the negative sum of radii.\"\"\"\n        return -np.sum(v[2*n:])\n\n    def jac_objective(v):\n        \"\"\"Analytical Jacobian for the sum of radii.\"\"\"\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    def constraints(v):\n        \"\"\"\n        Constraints:\n        1. Circles must be inside the square [0, 1]x[0, 1].\n        2. Circles must not overlap.\n        \"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        \n        # Box constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        c_box = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Distance constraints: (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        dx = x[triu_i] - x[triu_j]\n        dy = y[triu_i] - y[triu_j]\n        dr = r[triu_i] + r[triu_j]\n        c_dist = dx*dx + dy*dy - dr*dr\n        \n        return np.concatenate([c_box, c_dist])\n\n    def jac_constraints(v):\n        \"\"\"Analytical Jacobian for all constraints.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        num_dist = n * (n - 1) // 2\n        jac = np.zeros((4 * n + num_dist, 3 * n))\n        \n        # Jacobian for Box constraints\n        for i in range(n):\n            # x_i - r_i >= 0\n            jac[i, i] = 1.0\n            jac[i, 2*n + i] = -1.0\n            # 1 - x_i - r_i >= 0\n            jac[n + i, i] = -1.0\n            jac[n + i, 2*n + i] = -1.0\n            # y_i - r_i >= 0\n            jac[2*n + i, n + i] = 1.0\n            jac[2*n + i, 2*n + i] = -1.0\n            # 1 - y_i - r_i >= 0\n            jac[3*n + i, n + i] = -1.0\n            jac[3*n + i, 2*n + i] = -1.0\n            \n        # Jacobian for Distance constraints\n        idx_offset = 4 * n\n        dx = x[triu_i] - x[triu_j]\n        dy = y[triu_i] - y[triu_j]\n        dr = r[triu_i] + r[triu_j]\n        \n        idx_range = np.arange(num_dist)\n        jac[idx_offset + idx_range, triu_i] = 2.0 * dx\n        jac[idx_offset + idx_range, triu_j] = -2.0 * dx\n        jac[idx_offset + idx_range, n + triu_i] = 2.0 * dy\n        jac[idx_offset + idx_range, n + triu_j] = -2.0 * dy\n        jac[idx_offset + idx_range, 2*n + triu_i] = -2.0 * dr\n        jac[idx_offset + idx_range, 2*n + triu_j] = -2.0 * dr\n        \n        return jac\n\n    # Variable bounds: centers in [0, 1], radii in [0, 0.5]\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n\n    best_sum = 0\n    best_v = None\n    \n    # Use a fixed seed for reproducibility across the multi-start logic\n    np.random.seed(42)\n    \n    # 1. Multi-start Phase: Find a high-quality global candidate\n    for i in range(12):\n        if i == 0:\n            # Start with a standard 5x5 grid + 1 extra circle\n            xs, ys = np.meshgrid(np.linspace(0.12, 0.88, 5), np.linspace(0.12, 0.88, 5))\n            c = np.vstack([xs.ravel(), ys.ravel()]).T\n            c = np.vstack([c, [0.5, 0.5]])\n            c += np.random.normal(0, 0.01, size=c.shape)\n        else:\n            # Structured random start based on perturbed grid\n            xs, ys = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            c = np.vstack([xs.ravel(), ys.ravel()]).T\n            c = np.vstack([c, [np.random.rand(), np.random.rand()]])\n            c += np.random.uniform(-0.1, 0.1, size=c.shape)\n        \n        c = np.clip(c, 0.05, 0.95)\n        v_start = np.concatenate([c[:, 0], c[:, 1], np.full(n, 0.04)])\n        \n        res = minimize(\n            objective, v_start, jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            method='SLSQP', bounds=bounds,\n            options={'ftol': 1e-10, 'maxiter': 600}\n        )\n        \n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_v = res.x\n\n    # 2. High-Precision Refinement Phase\n    # Refine the best configuration using tiny perturbations and tighter tolerances\n    if best_v is not None:\n        for _ in range(5):\n            # Apply tiny perturbation (1e-7) to the centers of the current best\n            guess = best_v.copy()\n            guess[:2*n] += np.random.normal(0, 1e-7, size=2*n)\n            \n            res_refine = minimize(\n                objective, guess, jac=jac_objective,\n                constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                method='SLSQP', bounds=bounds,\n                options={'ftol': 1e-15, 'maxiter': 2000}\n            )\n            \n            if -res_refine.fun > best_sum:\n                best_sum = -res_refine.fun\n                best_v = res_refine.x\n\n    # Prepare final output\n    centers = np.vstack([best_v[:n], best_v[n:2*n]]).T\n    radii = best_v[2*n:]\n    final_sum = np.sum(radii)\n    \n    return centers, radii, final_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:56:12.671603",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 389,
        "candidates_token_count": 1959,
        "thoughts_token_count": 20633
      },
      "response_text_len": 5317
    }
  },
  "llm_call_duration_s": 132.01866983703803,
  "eval_duration_s": 1.7506646160036325
}