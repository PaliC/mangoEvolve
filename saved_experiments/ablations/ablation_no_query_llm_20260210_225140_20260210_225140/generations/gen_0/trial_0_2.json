{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nimport time\n\ndef get_initial_centers(n, target_r):\n    \"\"\"\n    Spreads n centers in a unit square using a repulsive force model.\n    \"\"\"\n    # Initial random positions\n    centers = np.random.rand(n, 2) * (1 - 2 * target_r) + target_r\n    for _ in range(300):\n        # Calculate pairwise distance vectors\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        # Squared distances to avoid sqrt where possible\n        d2 = np.sum(diffs**2, axis=2)\n        dists = np.sqrt(d2 + 1e-12)\n        \n        # Calculate overlap with a safety margin\n        overlap = 2 * target_r - dists\n        overlap[np.diag_indices(n)] = 0\n        overlap[overlap < 0] = 0\n        \n        if np.max(overlap) < 1e-5:\n            break\n            \n        # Repulsive forces: normalize diffs and scale by overlap\n        forces = diffs / (dists[:, :, np.newaxis] + 1e-12)\n        step = np.sum(forces * overlap[:, :, np.newaxis], axis=1)\n        \n        # Apply step and keep within bounds\n        centers += step * 0.1\n        centers = np.clip(centers, target_r, 1 - target_r)\n        \n    return centers\n\ndef objective_equal(v, n):\n    \"\"\"Objective function for equal-radius optimization (maximize r).\"\"\"\n    return -v[2*n]\n\ndef constraints_equal(v, n, tri_idx1, tri_idx2):\n    \"\"\"Constraints for equal-radius optimization.\"\"\"\n    centers = v[:2*n].reshape((n, 2))\n    r = v[2*n]\n    x, y = centers[:, 0], centers[:, 1]\n    \n    # Pairwise distance constraints: dist(i, j) >= 2*r\n    dx = x[tri_idx1] - x[tri_idx2]\n    dy = y[tri_idx1] - y[tri_idx2]\n    dists = np.sqrt(dx*dx + dy*dy + 1e-12)\n    c_pw = dists - 2*r\n    \n    # Boundary constraints: r <= x, y <= 1-r\n    c_b = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n    return np.concatenate([c_pw, c_b])\n\ndef objective_varying(v, n):\n    \"\"\"Objective function for varying-radius optimization (maximize sum of r_i).\"\"\"\n    return -np.sum(v[2*n:])\n\ndef constraints_varying(v, n, tri_idx1, tri_idx2):\n    \"\"\"Constraints for varying-radius optimization.\"\"\"\n    centers = v[:2*n].reshape((n, 2))\n    r = v[2*n:]\n    x, y = centers[:, 0], centers[:, 1]\n    \n    # Pairwise distance constraints: dist(i, j) >= r_i + r_j\n    dx = x[tri_idx1] - x[tri_idx2]\n    dy = y[tri_idx1] - y[tri_idx2]\n    dists = np.sqrt(dx*dx + dy*dy + 1e-12)\n    r_sum = r[tri_idx1] + r[tri_idx2]\n    c_pw = dists - r_sum\n    \n    # Boundary constraints: r_i <= x_i, y_i <= 1-r_i\n    c_b = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n    return np.concatenate([c_pw, c_b])\n\ndef run_packing():\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_v_varying = None\n    \n    # Pre-calculate triangle indices for pairwise constraints to save time\n    tri_idx1, tri_idx2 = np.triu_indices(n, k=1)\n    \n    # Multistart strategy: try multiple random initializations\n    # Time limit: 300 seconds total; leave time for final polish\n    for start_idx in range(12):\n        if time.time() - start_time > 220:\n            break\n            \n        # Get an initial spread of centers\n        target_r = 0.09 + 0.012 * np.random.rand()\n        centers = get_initial_centers(n, target_r)\n        \n        # Stage 1: Local optimization assuming equal radii (faster convergence)\n        v0_equal = np.concatenate([centers.flatten(), [target_r]])\n        res_eq = minimize(\n            objective_equal, v0_equal, args=(n,), method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)],\n            constraints={'type': 'ineq', 'fun': constraints_equal, 'args': (n, tri_idx1, tri_idx2)},\n            options={'maxiter': 100, 'ftol': 1e-7}\n        )\n        \n        # Stage 2: Local optimization allowing radii to vary\n        # Start from the equal-radius solution\n        v0_var = np.concatenate([res_eq.x[:2*n], [res_eq.x[2*n]] * n])\n        res_var = minimize(\n            objective_varying, v0_var, args=(n,), method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints_varying, 'args': (n, tri_idx1, tri_idx2)},\n            options={'maxiter': 150, 'ftol': 1e-8}\n        )\n        \n        current_sum = -res_var.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_v_varying = res_var.x\n            \n    # Final Stage: Polish the best solution found so far\n    if best_v_varying is not None:\n        res_final = minimize(\n            objective_varying, best_v_varying, args=(n,), method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints_varying, 'args': (n, tri_idx1, tri_idx2)},\n            options={'maxiter': 300, 'ftol': 1e-10}\n        )\n        best_v_varying = res_final.x\n        best_sum = -res_final.fun\n        \n    # Extract results\n    final_centers = best_v_varying[:2*n].reshape((n, 2))\n    final_radii = best_v_varying[2*n:]\n    \n    return final_centers, final_radii, float(best_sum)",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 55.84260153770447,
    "error": "Circle 18 at (0.1425756636915873, 0.5340754108276199) with radius 0.14644446734344016 extends outside x-bounds"
  },
  "prompt": "Pack 26 circles in a unit square to maximize the sum of radii. Implement a 'growth' strategy: start with 26 random points, and iteratively increase radii while moving centers to resolve overlaps (like a force-directed graph). Finally, refine the result using scipy.optimize.minimize (SLSQP or trust-constr) to reach a local maximum.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nimport time\n\ndef get_initial_centers(n, target_r):\n    \"\"\"\n    Spreads n centers in a unit square using a repulsive force model.\n    \"\"\"\n    # Initial random positions\n    centers = np.random.rand(n, 2) * (1 - 2 * target_r) + target_r\n    for _ in range(300):\n        # Calculate pairwise distance vectors\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        # Squared distances to avoid sqrt where possible\n        d2 = np.sum(diffs**2, axis=2)\n        dists = np.sqrt(d2 + 1e-12)\n        \n        # Calculate overlap with a safety margin\n        overlap = 2 * target_r - dists\n        overlap[np.diag_indices(n)] = 0\n        overlap[overlap < 0] = 0\n        \n        if np.max(overlap) < 1e-5:\n            break\n            \n        # Repulsive forces: normalize diffs and scale by overlap\n        forces = diffs / (dists[:, :, np.newaxis] + 1e-12)\n        step = np.sum(forces * overlap[:, :, np.newaxis], axis=1)\n        \n        # Apply step and keep within bounds\n        centers += step * 0.1\n        centers = np.clip(centers, target_r, 1 - target_r)\n        \n    return centers\n\ndef objective_equal(v, n):\n    \"\"\"Objective function for equal-radius optimization (maximize r).\"\"\"\n    return -v[2*n]\n\ndef constraints_equal(v, n, tri_idx1, tri_idx2):\n    \"\"\"Constraints for equal-radius optimization.\"\"\"\n    centers = v[:2*n].reshape((n, 2))\n    r = v[2*n]\n    x, y = centers[:, 0], centers[:, 1]\n    \n    # Pairwise distance constraints: dist(i, j) >= 2*r\n    dx = x[tri_idx1] - x[tri_idx2]\n    dy = y[tri_idx1] - y[tri_idx2]\n    dists = np.sqrt(dx*dx + dy*dy + 1e-12)\n    c_pw = dists - 2*r\n    \n    # Boundary constraints: r <= x, y <= 1-r\n    c_b = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n    return np.concatenate([c_pw, c_b])\n\ndef objective_varying(v, n):\n    \"\"\"Objective function for varying-radius optimization (maximize sum of r_i).\"\"\"\n    return -np.sum(v[2*n:])\n\ndef constraints_varying(v, n, tri_idx1, tri_idx2):\n    \"\"\"Constraints for varying-radius optimization.\"\"\"\n    centers = v[:2*n].reshape((n, 2))\n    r = v[2*n:]\n    x, y = centers[:, 0], centers[:, 1]\n    \n    # Pairwise distance constraints: dist(i, j) >= r_i + r_j\n    dx = x[tri_idx1] - x[tri_idx2]\n    dy = y[tri_idx1] - y[tri_idx2]\n    dists = np.sqrt(dx*dx + dy*dy + 1e-12)\n    r_sum = r[tri_idx1] + r[tri_idx2]\n    c_pw = dists - r_sum\n    \n    # Boundary constraints: r_i <= x_i, y_i <= 1-r_i\n    c_b = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n    return np.concatenate([c_pw, c_b])\n\ndef run_packing():\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_v_varying = None\n    \n    # Pre-calculate triangle indices for pairwise constraints to save time\n    tri_idx1, tri_idx2 = np.triu_indices(n, k=1)\n    \n    # Multistart strategy: try multiple random initializations\n    # Time limit: 300 seconds total; leave time for final polish\n    for start_idx in range(12):\n        if time.time() - start_time > 220:\n            break\n            \n        # Get an initial spread of centers\n        target_r = 0.09 + 0.012 * np.random.rand()\n        centers = get_initial_centers(n, target_r)\n        \n        # Stage 1: Local optimization assuming equal radii (faster convergence)\n        v0_equal = np.concatenate([centers.flatten(), [target_r]])\n        res_eq = minimize(\n            objective_equal, v0_equal, args=(n,), method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)],\n            constraints={'type': 'ineq', 'fun': constraints_equal, 'args': (n, tri_idx1, tri_idx2)},\n            options={'maxiter': 100, 'ftol': 1e-7}\n        )\n        \n        # Stage 2: Local optimization allowing radii to vary\n        # Start from the equal-radius solution\n        v0_var = np.concatenate([res_eq.x[:2*n], [res_eq.x[2*n]] * n])\n        res_var = minimize(\n            objective_varying, v0_var, args=(n,), method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints_varying, 'args': (n, tri_idx1, tri_idx2)},\n            options={'maxiter': 150, 'ftol': 1e-8}\n        )\n        \n        current_sum = -res_var.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_v_varying = res_var.x\n            \n    # Final Stage: Polish the best solution found so far\n    if best_v_varying is not None:\n        res_final = minimize(\n            objective_varying, best_v_varying, args=(n,), method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints_varying, 'args': (n, tri_idx1, tri_idx2)},\n            options={'maxiter': 300, 'ftol': 1e-10}\n        )\n        best_v_varying = res_final.x\n        best_sum = -res_final.fun\n        \n    # Extract results\n    final_centers = best_v_varying[:2*n].reshape((n, 2))\n    final_radii = best_v_varying[2*n:]\n    \n    return final_centers, final_radii, float(best_sum)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:55:25.298761",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 303,
        "candidates_token_count": 1758,
        "thoughts_token_count": 23760
      },
      "response_text_len": 5065
    }
  },
  "llm_call_duration_s": 152.2133011430269,
  "eval_duration_s": 55.84261183999479
}