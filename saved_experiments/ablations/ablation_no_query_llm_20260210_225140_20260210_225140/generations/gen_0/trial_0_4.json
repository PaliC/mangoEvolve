{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a two-stage approach:\n    1) Find a dense packing of 26 equal-sized circles.\n    2) Use that configuration as a starting point for an optimization where radii are allowed to vary.\n    \"\"\"\n    N = 26\n    \n    # Stage 1: Equal radii optimization\n    def stage1_obj(vars):\n        # vars = [x0, y0, x1, y1, ..., x25, y25, r]\n        return -vars[-1]\n\n    def stage1_obj_jac(vars):\n        jac = np.zeros_like(vars)\n        jac[-1] = -1.0\n        return jac\n\n    def stage1_cons(vars):\n        x = vars[0:2*N:2]\n        y = vars[1:2*N:2]\n        r = vars[-1]\n        c = np.zeros(4*N + N*(N-1)//2)\n        c[0:N] = x - r\n        c[N:2*N] = 1 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1 - y - r\n        idx = 4*N\n        for i in range(N):\n            xi, yi = x[i], y[i]\n            for j in range(i+1, N):\n                c[idx] = (xi-x[j])**2 + (yi-y[j])**2 - 4*r**2\n                idx += 1\n        return c\n\n    def stage1_cons_jac(vars):\n        x = vars[0:2*N:2]\n        y = vars[1:2*N:2]\n        r = vars[-1]\n        jac = np.zeros((4*N + N*(N-1)//2, 2*N+1))\n        for i in range(N):\n            jac[i, 2*i] = 1\n            jac[i, -1] = -1\n            jac[N+i, 2*i] = -1\n            jac[N+i, -1] = -1\n            jac[2*N+i, 2*i+1] = 1\n            jac[2*N+i, -1] = -1\n            jac[3*N+i, 2*i+1] = -1\n            jac[3*N+i, -1] = -1\n        idx = 4*N\n        for i in range(N):\n            xi, yi = x[i], y[i]\n            for j in range(i+1, N):\n                dx, dy = xi-x[j], yi-y[j]\n                jac[idx, 2*i], jac[idx, 2*j] = 2*dx, -2*dx\n                jac[idx, 2*i+1], jac[idx, 2*j+1] = 2*dy, -2*dy\n                jac[idx, -1] = -8*r\n                idx += 1\n        return jac\n\n    # Stage 2: Variable radii optimization\n    def stage2_obj(vars):\n        # vars = [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n        return -np.sum(vars[2::3])\n\n    def stage2_obj_jac(vars):\n        jac = np.zeros_like(vars)\n        jac[2::3] = -1.0\n        return jac\n\n    def stage2_cons(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        c = np.zeros(4*N + N*(N-1)//2)\n        c[0:N], c[N:2*N], c[2*N:3*N], c[3*N:4*N] = x-r, 1-x-r, y-r, 1-y-r\n        idx = 4*N\n        for i in range(N):\n            xi, yi, ri = x[i], y[i], r[i]\n            for j in range(i+1, N):\n                c[idx] = (xi-x[j])**2 + (yi-y[j])**2 - (ri+r[j])**2\n                idx += 1\n        return c\n\n    def stage2_cons_jac(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        jac = np.zeros((4*N + N*(N-1)//2, 3*N))\n        for i in range(N):\n            jac[i, 3*i], jac[i, 3*i+2] = 1, -1\n            jac[N+i, 3*i], jac[N+i, 3*i+2] = -1, -1\n            jac[2*N+i, 3*i+1], jac[2*N+i, 3*i+2] = 1, -1\n            jac[3*N+i, 3*i+1], jac[3*N+i, 3*i+2] = -1, -1\n        idx = 4*N\n        for i in range(N):\n            xi, yi, ri = x[i], y[i], r[i]\n            for j in range(i+1, N):\n                dx, dy, dr = xi-x[j], yi-y[j], ri+r[j]\n                jac[idx, 3*i], jac[idx, 3*j] = 2*dx, -2*dx\n                jac[idx, 3*i+1], jac[idx, 3*j+1] = 2*dy, -2*dy\n                jac[idx, 3*i+2], jac[idx, 3*j+2] = -2*dr, -2*dr\n                idx += 1\n        return jac\n\n    best_r = 0\n    best_vars = None\n    start_time = time.time()\n    \n    # Run Stage 1 multiple times with different starting points\n    for k in range(15):\n        if time.time() - start_time > 200:\n            break\n        \n        v = np.zeros(2*N+1)\n        if k == 0:\n            # 5x5 grid start\n            for i in range(5):\n                for j in range(5):\n                    v[2*(i*5+j)] = 0.1 + 0.2*i\n                    v[2*(i*5+j)+1] = 0.1 + 0.2*j\n            v[2*25], v[2*25+1] = 0.95, 0.95\n            v[0:2*N] += np.random.normal(0, 0.01, 2*N)\n        else:\n            v[0:2*N] = np.random.uniform(0.1, 0.9, 2*N)\n        \n        v[0:2*N] = np.clip(v[0:2*N], 0.001, 0.999)\n        v[-1] = 0.05\n        \n        res = minimize(stage1_obj, v, jac=stage1_obj_jac,\n                       constraints={'type': 'ineq', 'fun': stage1_cons, 'jac': stage1_cons_jac},\n                       method='SLSQP', options={'maxiter': 500})\n        \n        if -res.fun > best_r:\n            best_r = -res.fun\n            best_vars = res.x\n\n    # If Stage 1 failed to find any solution, initialize with random\n    if best_vars is None:\n        best_vars = np.zeros(2*N+1)\n        best_vars[0:2*N] = np.random.uniform(0.1, 0.9, 2*N)\n        best_vars[-1] = 0.05\n\n    # Stage 2: Maximize sum of radii starting from best equal-radii packing\n    s2_init = np.zeros(3*N)\n    s2_init[0::3] = best_vars[0:2*N:2]\n    s2_init[1::3] = best_vars[1:2*N:2]\n    s2_init[2::3] = best_vars[-1]\n    \n    res2 = minimize(stage2_obj, s2_init, jac=stage2_obj_jac,\n                    bounds=[(0, 1)] * (3*N),\n                    constraints={'type': 'ineq', 'fun': stage2_cons, 'jac': stage2_cons_jac},\n                    method='SLSQP', options={'maxiter': 1000})\n    \n    final_vars = res2.x\n    centers = final_vars.reshape((N, 3))[:, :2]\n    radii = final_vars.reshape((N, 3))[:, 2]\n    \n    # Post-processing to ensure absolute feasibility (shrink slightly if needed)\n    for i in range(N):\n        radii[i] = max(0, min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1]))\n    for _ in range(20):\n        for i in range(N):\n            for j in range(i+1, N):\n                d = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                if radii[i] + radii[j] > d:\n                    shrink = (radii[i] + radii[j] - d) / 2\n                    radii[i] -= (shrink + 1e-14)\n                    radii[j] -= (shrink + 1e-14)\n                    radii[i] = max(0, radii[i])\n                    radii[j] = max(0, radii[j])\n                    \n    return centers, radii, np.sum(radii)",
  "metrics": {
    "valid": true,
    "score": 2.619209720606274,
    "eval_time": 42.93903160095215,
    "error": null
  },
  "prompt": "Pack 26 circles in a unit square to maximize the sum of radii. Use a two-stage approach: 1) Find a dense packing of 26 equal-sized circles. 2) Use that configuration as a starting point for an optimization where radii are allowed to vary to maximize their sum. Use scipy.optimize.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a two-stage approach:\n    1) Find a dense packing of 26 equal-sized circles.\n    2) Use that configuration as a starting point for an optimization where radii are allowed to vary.\n    \"\"\"\n    N = 26\n    \n    # Stage 1: Equal radii optimization\n    def stage1_obj(vars):\n        # vars = [x0, y0, x1, y1, ..., x25, y25, r]\n        return -vars[-1]\n\n    def stage1_obj_jac(vars):\n        jac = np.zeros_like(vars)\n        jac[-1] = -1.0\n        return jac\n\n    def stage1_cons(vars):\n        x = vars[0:2*N:2]\n        y = vars[1:2*N:2]\n        r = vars[-1]\n        c = np.zeros(4*N + N*(N-1)//2)\n        c[0:N] = x - r\n        c[N:2*N] = 1 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1 - y - r\n        idx = 4*N\n        for i in range(N):\n            xi, yi = x[i], y[i]\n            for j in range(i+1, N):\n                c[idx] = (xi-x[j])**2 + (yi-y[j])**2 - 4*r**2\n                idx += 1\n        return c\n\n    def stage1_cons_jac(vars):\n        x = vars[0:2*N:2]\n        y = vars[1:2*N:2]\n        r = vars[-1]\n        jac = np.zeros((4*N + N*(N-1)//2, 2*N+1))\n        for i in range(N):\n            jac[i, 2*i] = 1\n            jac[i, -1] = -1\n            jac[N+i, 2*i] = -1\n            jac[N+i, -1] = -1\n            jac[2*N+i, 2*i+1] = 1\n            jac[2*N+i, -1] = -1\n            jac[3*N+i, 2*i+1] = -1\n            jac[3*N+i, -1] = -1\n        idx = 4*N\n        for i in range(N):\n            xi, yi = x[i], y[i]\n            for j in range(i+1, N):\n                dx, dy = xi-x[j], yi-y[j]\n                jac[idx, 2*i], jac[idx, 2*j] = 2*dx, -2*dx\n                jac[idx, 2*i+1], jac[idx, 2*j+1] = 2*dy, -2*dy\n                jac[idx, -1] = -8*r\n                idx += 1\n        return jac\n\n    # Stage 2: Variable radii optimization\n    def stage2_obj(vars):\n        # vars = [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n        return -np.sum(vars[2::3])\n\n    def stage2_obj_jac(vars):\n        jac = np.zeros_like(vars)\n        jac[2::3] = -1.0\n        return jac\n\n    def stage2_cons(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        c = np.zeros(4*N + N*(N-1)//2)\n        c[0:N], c[N:2*N], c[2*N:3*N], c[3*N:4*N] = x-r, 1-x-r, y-r, 1-y-r\n        idx = 4*N\n        for i in range(N):\n            xi, yi, ri = x[i], y[i], r[i]\n            for j in range(i+1, N):\n                c[idx] = (xi-x[j])**2 + (yi-y[j])**2 - (ri+r[j])**2\n                idx += 1\n        return c\n\n    def stage2_cons_jac(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        jac = np.zeros((4*N + N*(N-1)//2, 3*N))\n        for i in range(N):\n            jac[i, 3*i], jac[i, 3*i+2] = 1, -1\n            jac[N+i, 3*i], jac[N+i, 3*i+2] = -1, -1\n            jac[2*N+i, 3*i+1], jac[2*N+i, 3*i+2] = 1, -1\n            jac[3*N+i, 3*i+1], jac[3*N+i, 3*i+2] = -1, -1\n        idx = 4*N\n        for i in range(N):\n            xi, yi, ri = x[i], y[i], r[i]\n            for j in range(i+1, N):\n                dx, dy, dr = xi-x[j], yi-y[j], ri+r[j]\n                jac[idx, 3*i], jac[idx, 3*j] = 2*dx, -2*dx\n                jac[idx, 3*i+1], jac[idx, 3*j+1] = 2*dy, -2*dy\n                jac[idx, 3*i+2], jac[idx, 3*j+2] = -2*dr, -2*dr\n                idx += 1\n        return jac\n\n    best_r = 0\n    best_vars = None\n    start_time = time.time()\n    \n    # Run Stage 1 multiple times with different starting points\n    for k in range(15):\n        if time.time() - start_time > 200:\n            break\n        \n        v = np.zeros(2*N+1)\n        if k == 0:\n            # 5x5 grid start\n            for i in range(5):\n                for j in range(5):\n                    v[2*(i*5+j)] = 0.1 + 0.2*i\n                    v[2*(i*5+j)+1] = 0.1 + 0.2*j\n            v[2*25], v[2*25+1] = 0.95, 0.95\n            v[0:2*N] += np.random.normal(0, 0.01, 2*N)\n        else:\n            v[0:2*N] = np.random.uniform(0.1, 0.9, 2*N)\n        \n        v[0:2*N] = np.clip(v[0:2*N], 0.001, 0.999)\n        v[-1] = 0.05\n        \n        res = minimize(stage1_obj, v, jac=stage1_obj_jac,\n                       constraints={'type': 'ineq', 'fun': stage1_cons, 'jac': stage1_cons_jac},\n                       method='SLSQP', options={'maxiter': 500})\n        \n        if -res.fun > best_r:\n            best_r = -res.fun\n            best_vars = res.x\n\n    # If Stage 1 failed to find any solution, initialize with random\n    if best_vars is None:\n        best_vars = np.zeros(2*N+1)\n        best_vars[0:2*N] = np.random.uniform(0.1, 0.9, 2*N)\n        best_vars[-1] = 0.05\n\n    # Stage 2: Maximize sum of radii starting from best equal-radii packing\n    s2_init = np.zeros(3*N)\n    s2_init[0::3] = best_vars[0:2*N:2]\n    s2_init[1::3] = best_vars[1:2*N:2]\n    s2_init[2::3] = best_vars[-1]\n    \n    res2 = minimize(stage2_obj, s2_init, jac=stage2_obj_jac,\n                    bounds=[(0, 1)] * (3*N),\n                    constraints={'type': 'ineq', 'fun': stage2_cons, 'jac': stage2_cons_jac},\n                    method='SLSQP', options={'maxiter': 1000})\n    \n    final_vars = res2.x\n    centers = final_vars.reshape((N, 3))[:, :2]\n    radii = final_vars.reshape((N, 3))[:, 2]\n    \n    # Post-processing to ensure absolute feasibility (shrink slightly if needed)\n    for i in range(N):\n        radii[i] = max(0, min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1]))\n    for _ in range(20):\n        for i in range(N):\n            for j in range(i+1, N):\n                d = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                if radii[i] + radii[j] > d:\n                    shrink = (radii[i] + radii[j] - d) / 2\n                    radii[i] -= (shrink + 1e-14)\n                    radii[j] -= (shrink + 1e-14)\n                    radii[i] = max(0, radii[i])\n                    radii[j] = max(0, radii[j])\n                    \n    return centers, radii, np.sum(radii)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:54:40.858191",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 296,
        "candidates_token_count": 2514,
        "thoughts_token_count": 20116
      },
      "response_text_len": 6006
    }
  },
  "llm_call_duration_s": 120.67512094497215,
  "eval_duration_s": 42.93904184503481
}