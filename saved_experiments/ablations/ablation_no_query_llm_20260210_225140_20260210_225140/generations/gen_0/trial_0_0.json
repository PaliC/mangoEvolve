{
  "trial_id": "trial_0_0",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles in a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 5x5 grid plus one extra circle as the initial center positions.\n    Optimizes using scipy.optimize.minimize with the SLSQP method.\n    \"\"\"\n    n = 26\n    \n    # 1. Initial positions: 5x5 grid centers\n    # A 5x5 grid of circles with radius 0.1 fills the unit square.\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(grid_coords, grid_coords)\n    centers_25 = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    \n    # 2. Add the 26th circle\n    # Placing it initially at the center (0.5, 0.5).\n    centers = np.vstack([centers_25, [0.5, 0.5]])\n    \n    # 3. Jitter and Initial Radii\n    # Add small jitter to break symmetry and avoid exact overlaps during initialization.\n    np.random.seed(42)\n    jitter = np.random.uniform(-0.01, 0.01, centers.shape)\n    centers += jitter\n    centers = np.clip(centers, 0.02, 0.98)\n    \n    # Start with a small constant radius for all circles as requested.\n    radii = np.full(n, 0.01)\n    \n    # 4. Flatten the initial guess for the optimizer\n    # Layout: [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n    x0 = np.zeros(3 * n)\n    for i in range(n):\n        x0[3*i] = centers[i, 0]\n        x0[3*i+1] = centers[i, 1]\n        x0[3*i+2] = radii[i]\n        \n    # 5. Objective: Maximize sum(radii) -> Minimize -sum(radii)\n    def objective(x):\n        return -np.sum(x[2::3])\n    \n    def grad_objective(x):\n        grad = np.zeros_like(x)\n        grad[2::3] = -1.0\n        return grad\n\n    # 6. Constraints: Non-overlap and Boundary\n    def constraints_func(x):\n        xi = x[0::3]\n        yi = x[1::3]\n        ri = x[2::3]\n        \n        # Boundary constraints: circles must be entirely inside [0,1]x[0,1]\n        # x - r >= 0, 1 - x - r >= 0, y - r >= 0, 1 - y - r >= 0\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0::4] = xi - ri\n        c_boundary[1::4] = 1.0 - xi - ri\n        c_boundary[2::4] = yi - ri\n        c_boundary[3::4] = 1.0 - yi - ri\n        \n        # Non-overlap constraints: dist(ci, cj) >= ri + rj\n        # We use the squared distance: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        dx = xi[:, np.newaxis] - xi[np.newaxis, :]\n        dy = yi[:, np.newaxis] - yi[np.newaxis, :]\n        dr = ri[:, np.newaxis] + ri[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        overlap = dist_sq - dr**2\n        \n        # Extract only the upper triangular indices to avoid duplicate constraints\n        indices = np.triu_indices(n, k=1)\n        return np.concatenate([c_boundary, overlap[indices]])\n\n    def jac_constraints(x):\n        xi = x[0::3]\n        yi = x[1::3]\n        ri = x[2::3]\n        \n        num_boundary = 4 * n\n        num_overlap = n * (n - 1) // 2\n        jac = np.zeros((num_boundary + num_overlap, 3 * n))\n        \n        # Jacobian for boundary constraints\n        for i in range(n):\n            # xi - ri >= 0\n            jac[4*i, 3*i] = 1.0\n            jac[4*i, 3*i+2] = -1.0\n            # 1 - xi - ri >= 0\n            jac[4*i+1, 3*i] = -1.0\n            jac[4*i+1, 3*i+2] = -1.0\n            # yi - ri >= 0\n            jac[4*i+2, 3*i+1] = 1.0\n            jac[4*i+2, 3*i+2] = -1.0\n            # 1 - yi - ri >= 0\n            jac[4*i+3, 3*i+1] = -1.0\n            jac[4*i+3, 3*i+2] = -1.0\n            \n        # Jacobian for non-overlap constraints\n        idx = num_boundary\n        i_indices, j_indices = np.triu_indices(n, k=1)\n        for i, j in zip(i_indices, j_indices):\n            dx = xi[i] - xi[j]\n            dy = yi[i] - yi[j]\n            sr = ri[i] + ri[j]\n            # wrt circle i\n            jac[idx, 3*i] = 2 * dx\n            jac[idx, 3*i+1] = 2 * dy\n            jac[idx, 3*i+2] = -2 * sr\n            # wrt circle j\n            jac[idx, 3*j] = -2 * dx\n            jac[idx, 3*j+1] = -2 * dy\n            jac[idx, 3*j+2] = -2 * sr\n            idx += 1\n        return jac\n\n    # 7. Optimization\n    # Variable bounds: xi, yi in [0,1], ri in [0, 0.5]\n    bounds = [(0, 1)] * (3 * n)\n    \n    res = minimize(\n        objective, \n        x0, \n        method='SLSQP', \n        jac=grad_objective,\n        constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints},\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-8}\n    )\n    \n    # 8. Extract results\n    final_x = res.x.reshape(n, 3)\n    centers = final_x[:, :2]\n    radii = final_x[:, 2]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6071487862404634,
    "eval_time": 0.5514326095581055,
    "error": null
  },
  "prompt": "Pack 26 circles in a unit square to maximize the sum of radii. Use a 5x5 grid plus one extra circle as the initial center positions. Use scipy.optimize.minimize with method='SLSQP'. Define constraints for non-overlap (dist >= r1 + r2) and boundary limits. Use a small constant radius as a starting point.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles in a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 5x5 grid plus one extra circle as the initial center positions.\n    Optimizes using scipy.optimize.minimize with the SLSQP method.\n    \"\"\"\n    n = 26\n    \n    # 1. Initial positions: 5x5 grid centers\n    # A 5x5 grid of circles with radius 0.1 fills the unit square.\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(grid_coords, grid_coords)\n    centers_25 = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    \n    # 2. Add the 26th circle\n    # Placing it initially at the center (0.5, 0.5).\n    centers = np.vstack([centers_25, [0.5, 0.5]])\n    \n    # 3. Jitter and Initial Radii\n    # Add small jitter to break symmetry and avoid exact overlaps during initialization.\n    np.random.seed(42)\n    jitter = np.random.uniform(-0.01, 0.01, centers.shape)\n    centers += jitter\n    centers = np.clip(centers, 0.02, 0.98)\n    \n    # Start with a small constant radius for all circles as requested.\n    radii = np.full(n, 0.01)\n    \n    # 4. Flatten the initial guess for the optimizer\n    # Layout: [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n    x0 = np.zeros(3 * n)\n    for i in range(n):\n        x0[3*i] = centers[i, 0]\n        x0[3*i+1] = centers[i, 1]\n        x0[3*i+2] = radii[i]\n        \n    # 5. Objective: Maximize sum(radii) -> Minimize -sum(radii)\n    def objective(x):\n        return -np.sum(x[2::3])\n    \n    def grad_objective(x):\n        grad = np.zeros_like(x)\n        grad[2::3] = -1.0\n        return grad\n\n    # 6. Constraints: Non-overlap and Boundary\n    def constraints_func(x):\n        xi = x[0::3]\n        yi = x[1::3]\n        ri = x[2::3]\n        \n        # Boundary constraints: circles must be entirely inside [0,1]x[0,1]\n        # x - r >= 0, 1 - x - r >= 0, y - r >= 0, 1 - y - r >= 0\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0::4] = xi - ri\n        c_boundary[1::4] = 1.0 - xi - ri\n        c_boundary[2::4] = yi - ri\n        c_boundary[3::4] = 1.0 - yi - ri\n        \n        # Non-overlap constraints: dist(ci, cj) >= ri + rj\n        # We use the squared distance: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        dx = xi[:, np.newaxis] - xi[np.newaxis, :]\n        dy = yi[:, np.newaxis] - yi[np.newaxis, :]\n        dr = ri[:, np.newaxis] + ri[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        overlap = dist_sq - dr**2\n        \n        # Extract only the upper triangular indices to avoid duplicate constraints\n        indices = np.triu_indices(n, k=1)\n        return np.concatenate([c_boundary, overlap[indices]])\n\n    def jac_constraints(x):\n        xi = x[0::3]\n        yi = x[1::3]\n        ri = x[2::3]\n        \n        num_boundary = 4 * n\n        num_overlap = n * (n - 1) // 2\n        jac = np.zeros((num_boundary + num_overlap, 3 * n))\n        \n        # Jacobian for boundary constraints\n        for i in range(n):\n            # xi - ri >= 0\n            jac[4*i, 3*i] = 1.0\n            jac[4*i, 3*i+2] = -1.0\n            # 1 - xi - ri >= 0\n            jac[4*i+1, 3*i] = -1.0\n            jac[4*i+1, 3*i+2] = -1.0\n            # yi - ri >= 0\n            jac[4*i+2, 3*i+1] = 1.0\n            jac[4*i+2, 3*i+2] = -1.0\n            # 1 - yi - ri >= 0\n            jac[4*i+3, 3*i+1] = -1.0\n            jac[4*i+3, 3*i+2] = -1.0\n            \n        # Jacobian for non-overlap constraints\n        idx = num_boundary\n        i_indices, j_indices = np.triu_indices(n, k=1)\n        for i, j in zip(i_indices, j_indices):\n            dx = xi[i] - xi[j]\n            dy = yi[i] - yi[j]\n            sr = ri[i] + ri[j]\n            # wrt circle i\n            jac[idx, 3*i] = 2 * dx\n            jac[idx, 3*i+1] = 2 * dy\n            jac[idx, 3*i+2] = -2 * sr\n            # wrt circle j\n            jac[idx, 3*j] = -2 * dx\n            jac[idx, 3*j+1] = -2 * dy\n            jac[idx, 3*j+2] = -2 * sr\n            idx += 1\n        return jac\n\n    # 7. Optimization\n    # Variable bounds: xi, yi in [0,1], ri in [0, 0.5]\n    bounds = [(0, 1)] * (3 * n)\n    \n    res = minimize(\n        objective, \n        x0, \n        method='SLSQP', \n        jac=grad_objective,\n        constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints},\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-8}\n    )\n    \n    # 8. Extract results\n    final_x = res.x.reshape(n, 3)\n    centers = final_x[:, :2]\n    radii = final_x[:, 2]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:53:51.588196",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 303,
        "candidates_token_count": 1761,
        "thoughts_token_count": 18027
      },
      "response_text_len": 4629
    }
  },
  "llm_call_duration_s": 113.79499819094781,
  "eval_duration_s": 0.551444198936224
}