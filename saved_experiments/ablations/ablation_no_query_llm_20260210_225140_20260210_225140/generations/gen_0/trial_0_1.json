{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Returns:\n        tuple: (centers, radii, sum_radii)\n            centers: numpy array of shape (26, 2)\n            radii: numpy array of shape (26,)\n            sum_radii: float\n    \"\"\"\n    N = 26\n    \n    # Pre-compute indices for overlap constraints for efficiency\n    idx_i, idx_j = np.triu_indices(N, k=1)\n\n    def objective(state):\n        \"\"\"Minimize the negative sum of radii to maximize the sum.\"\"\"\n        # state[2::3] contains the radii r_1, r_2, ..., r_26\n        return -np.sum(state[2::3])\n\n    def objective_grad(state):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros_like(state)\n        grad[2::3] = -1.0\n        return grad\n\n    def constraints(state):\n        \"\"\"Boundary and non-overlap constraints.\"\"\"\n        x = state[0::3]\n        y = state[1::3]\n        r = state[2::3]\n        \n        # Boundary constraints:\n        # x_i - r_i >= 0  => x_i >= r_i\n        # 1.0 - x_i - r_i >= 0 => x_i + r_i <= 1.0\n        # y_i - r_i >= 0  => y_i >= r_i\n        # 1.0 - y_i - r_i >= 0 => y_i + r_i <= 1.0\n        c_bound = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Overlap constraints:\n        # Distance between centers (x_i, y_i) and (x_j, y_j) must be at least r_i + r_j\n        # (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        dr = r[idx_i] + r[idx_j]\n        c_overlap = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([c_bound, c_overlap])\n\n    # Initial guess: Arrange 25 circles in a 5x5 grid and add a 26th circle.\n    # The solver will then optimize their positions and radii.\n    np.random.seed(42)\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    centers = np.column_stack([xx.ravel(), yy.ravel()])\n    # Add the 26th circle at the center\n    centers = np.vstack([centers, [0.5, 0.5]])\n    # Add small noise to break symmetry\n    centers += np.random.normal(0, 0.01, (N, 2))\n    \n    # Start with a safe common radius\n    radii = np.full(N, 0.08)\n    \n    # Flatten the state: (x1, y1, r1, x2, y2, r2, ...)\n    state0 = np.zeros(N * 3)\n    state0[0::3] = centers[:, 0]\n    state0[1::3] = centers[:, 1]\n    state0[2::3] = radii\n    \n    # Define variable bounds: centers in [0, 1], radii in [0, 0.5]\n    bounds = []\n    for i in range(N):\n        bounds.append((0, 1))   # x_i\n        bounds.append((0, 1))   # y_i\n        bounds.append((0, 0.5)) # r_i\n        \n    # Configure the local optimizer\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"jac\": objective_grad,\n        \"constraints\": {'type': 'ineq', 'fun': constraints},\n        \"bounds\": bounds,\n        \"options\": {'maxiter': 500, 'ftol': 1e-8}\n    }\n    \n    # Use basinhopping to find a better global optimum\n    # niter=5 is chosen to stay well within the 300s time limit\n    res = basinhopping(\n        objective,\n        state0,\n        niter=5,\n        T=0.05,\n        stepsize=0.1,\n        minimizer_kwargs=minimizer_kwargs\n    )\n    \n    # Extract results\n    final_state = res.x\n    final_centers = np.stack([final_state[0::3], final_state[1::3]], axis=1)\n    final_radii = final_state[2::3]\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6033681270851092,
    "eval_time": 30.787628889083862,
    "error": null
  },
  "prompt": "Pack 26 circles in a unit square to maximize the sum of radii. Use scipy.optimize.basinhopping to find a global optimum. The state should be the (x, y) coordinates of the 26 centers and their 26 radii. Ensure the non-overlap and boundary constraints are handled via the 'constraints' parameter in the underlying minimizer.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Returns:\n        tuple: (centers, radii, sum_radii)\n            centers: numpy array of shape (26, 2)\n            radii: numpy array of shape (26,)\n            sum_radii: float\n    \"\"\"\n    N = 26\n    \n    # Pre-compute indices for overlap constraints for efficiency\n    idx_i, idx_j = np.triu_indices(N, k=1)\n\n    def objective(state):\n        \"\"\"Minimize the negative sum of radii to maximize the sum.\"\"\"\n        # state[2::3] contains the radii r_1, r_2, ..., r_26\n        return -np.sum(state[2::3])\n\n    def objective_grad(state):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros_like(state)\n        grad[2::3] = -1.0\n        return grad\n\n    def constraints(state):\n        \"\"\"Boundary and non-overlap constraints.\"\"\"\n        x = state[0::3]\n        y = state[1::3]\n        r = state[2::3]\n        \n        # Boundary constraints:\n        # x_i - r_i >= 0  => x_i >= r_i\n        # 1.0 - x_i - r_i >= 0 => x_i + r_i <= 1.0\n        # y_i - r_i >= 0  => y_i >= r_i\n        # 1.0 - y_i - r_i >= 0 => y_i + r_i <= 1.0\n        c_bound = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Overlap constraints:\n        # Distance between centers (x_i, y_i) and (x_j, y_j) must be at least r_i + r_j\n        # (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        dr = r[idx_i] + r[idx_j]\n        c_overlap = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([c_bound, c_overlap])\n\n    # Initial guess: Arrange 25 circles in a 5x5 grid and add a 26th circle.\n    # The solver will then optimize their positions and radii.\n    np.random.seed(42)\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    centers = np.column_stack([xx.ravel(), yy.ravel()])\n    # Add the 26th circle at the center\n    centers = np.vstack([centers, [0.5, 0.5]])\n    # Add small noise to break symmetry\n    centers += np.random.normal(0, 0.01, (N, 2))\n    \n    # Start with a safe common radius\n    radii = np.full(N, 0.08)\n    \n    # Flatten the state: (x1, y1, r1, x2, y2, r2, ...)\n    state0 = np.zeros(N * 3)\n    state0[0::3] = centers[:, 0]\n    state0[1::3] = centers[:, 1]\n    state0[2::3] = radii\n    \n    # Define variable bounds: centers in [0, 1], radii in [0, 0.5]\n    bounds = []\n    for i in range(N):\n        bounds.append((0, 1))   # x_i\n        bounds.append((0, 1))   # y_i\n        bounds.append((0, 0.5)) # r_i\n        \n    # Configure the local optimizer\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"jac\": objective_grad,\n        \"constraints\": {'type': 'ineq', 'fun': constraints},\n        \"bounds\": bounds,\n        \"options\": {'maxiter': 500, 'ftol': 1e-8}\n    }\n    \n    # Use basinhopping to find a better global optimum\n    # niter=5 is chosen to stay well within the 300s time limit\n    res = basinhopping(\n        objective,\n        state0,\n        niter=5,\n        T=0.05,\n        stepsize=0.1,\n        minimizer_kwargs=minimizer_kwargs\n    )\n    \n    # Extract results\n    final_state = res.x\n    final_centers = np.stack([final_state[0::3], final_state[1::3]], axis=1)\n    final_radii = final_state[2::3]\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:54:46.812562",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 304,
        "candidates_token_count": 1284,
        "thoughts_token_count": 22146
      },
      "response_text_len": 3492
    }
  },
  "llm_call_duration_s": 138.78251864702906,
  "eval_duration_s": 30.78763792407699
}