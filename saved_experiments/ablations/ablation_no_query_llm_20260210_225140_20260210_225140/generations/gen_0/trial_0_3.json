{
  "trial_id": "trial_0_3",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP optimization with vectorized constraints and gradients.\n    \"\"\"\n    N = 26\n    \n    # Objective function: maximize sum of radii, so minimize negative sum\n    def objective(vars):\n        # vars: [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n        return -np.sum(vars[2::3])\n\n    def objective_grad(vars):\n        grad = np.zeros_like(vars)\n        grad[2::3] = -1.0\n        return grad\n\n    # Vectorized constraint function for non-overlap and boundary constraints\n    def constraints_vectorized(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        b_res = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Non-overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        i_indices, j_indices = np.triu_indices(N, k=1)\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        o_res = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([b_res, o_res])\n\n    # Jacobian of the constraint function\n    def jacobian_vectorized(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        num_overlap = N * (N - 1) // 2\n        num_boundary = 4 * N\n        jac = np.zeros((num_boundary + num_overlap, 3 * N))\n        \n        # Filling boundary constraint derivatives\n        for i in range(N):\n            # x[i] - r[i] >= 0\n            jac[i, 3*i] = 1.0\n            jac[i, 3*i+2] = -1.0\n            # 1.0 - x[i] - r[i] >= 0\n            jac[N+i, 3*i] = -1.0\n            jac[N+i, 3*i+2] = -1.0\n            # y[i] - r[i] >= 0\n            jac[2*N+i, 3*i+1] = 1.0\n            jac[2*N+i, 3*i+2] = -1.0\n            # 1.0 - y[i] - r[i] >= 0\n            jac[3*N+i, 3*i+1] = -1.0\n            jac[3*N+i, 3*i+2] = -1.0\n            \n        # Filling overlap constraint derivatives\n        i_indices, j_indices = np.triu_indices(N, k=1)\n        row_indices = np.arange(num_boundary, num_boundary + num_overlap)\n        \n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        \n        jac[row_indices, 3*i_indices] = 2 * dx\n        jac[row_indices, 3*j_indices] = -2 * dx\n        jac[row_indices, 3*i_indices+1] = 2 * dy\n        jac[row_indices, 3*j_indices+1] = -2 * dy\n        jac[row_indices, 3*i_indices+2] = -2 * dr\n        jac[row_indices, 3*j_indices+2] = -2 * dr\n        \n        return jac\n\n    # Variable bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    \n    best_sum_radii = 0\n    best_vars = None\n    start_time = time.time()\n    \n    # Multi-start loop\n    for num_starts in range(1, 51):\n        # Time check: stop if we exceed 280 seconds to allow for refinement\n        if time.time() - start_time > 280:\n            break\n        \n        # Diverse initial guesses: grid-based and random\n        if num_starts % 10 == 1:\n            # Grid start\n            s = int(np.ceil(np.sqrt(N)))\n            xx, yy = np.meshgrid(np.linspace(0.1, 0.9, s), np.linspace(0.1, 0.9, s))\n            x0 = np.zeros(3 * N)\n            x0[0::3] = xx.flatten()[:N]\n            x0[1::3] = yy.flatten()[:N]\n            x0[2::3] = 0.09\n        else:\n            # Random starts with varying radii distributions\n            x0 = np.zeros(3 * N)\n            x0[0::3] = 0.1 + 0.8 * np.random.rand(N)\n            x0[1::3] = 0.1 + 0.8 * np.random.rand(N)\n            if num_starts % 3 == 0:\n                x0[2::3] = 0.05 + 0.05 * np.random.rand(N)\n            elif num_starts % 3 == 1:\n                x0[2::3] = 0.08 + 0.04 * np.random.rand(N)\n            else:\n                x0[2::3] = 0.1 * np.random.rand(N)\n        \n        # Local optimization using SLSQP\n        res = minimize(\n            objective, x0, method='SLSQP', jac=objective_grad,\n            constraints={'type': 'ineq', 'fun': constraints_vectorized, 'jac': jacobian_vectorized},\n            bounds=bounds, options={'maxiter': 100}\n        )\n        \n        if -res.fun > best_sum_radii:\n            best_sum_radii = -res.fun\n            best_vars = res.x\n            \n    # Final refinement step for the best solution found\n    if best_vars is not None:\n        res = minimize(\n            objective, best_vars, method='SLSQP', jac=objective_grad,\n            constraints={'type': 'ineq', 'fun': constraints_vectorized, 'jac': jacobian_vectorized},\n            bounds=bounds, options={'maxiter': 200}\n        )\n        best_sum_radii = -res.fun\n        best_vars = res.x\n    else:\n        # Fallback in case no optimization was completed\n        best_centers = np.random.rand(N, 2)\n        best_radii = np.zeros(N)\n        return best_centers, best_radii, 0.0\n\n    # Extract centers and radii from the flat result array\n    best_centers = np.column_stack((best_vars[0::3], best_vars[1::3]))\n    best_radii = best_vars[2::3]\n    \n    return best_centers, best_radii, best_sum_radii",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 82.01063680648804,
    "error": "Circle 0 at (2.466950235390686e-05, 0.999681583801249) with radius 0.4998407919006245 extends outside x-bounds"
  },
  "prompt": "Pack 26 circles in a unit square to maximize the sum of radii. Perform a multi-start optimization: in each iteration, randomly place 26 centers, then use SLSQP to maximize the sum of radii. Keep the best result found across 20-50 starts. Radii and centers should all be optimization variables.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP optimization with vectorized constraints and gradients.\n    \"\"\"\n    N = 26\n    \n    # Objective function: maximize sum of radii, so minimize negative sum\n    def objective(vars):\n        # vars: [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n        return -np.sum(vars[2::3])\n\n    def objective_grad(vars):\n        grad = np.zeros_like(vars)\n        grad[2::3] = -1.0\n        return grad\n\n    # Vectorized constraint function for non-overlap and boundary constraints\n    def constraints_vectorized(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        b_res = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Non-overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        i_indices, j_indices = np.triu_indices(N, k=1)\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        o_res = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([b_res, o_res])\n\n    # Jacobian of the constraint function\n    def jacobian_vectorized(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        num_overlap = N * (N - 1) // 2\n        num_boundary = 4 * N\n        jac = np.zeros((num_boundary + num_overlap, 3 * N))\n        \n        # Filling boundary constraint derivatives\n        for i in range(N):\n            # x[i] - r[i] >= 0\n            jac[i, 3*i] = 1.0\n            jac[i, 3*i+2] = -1.0\n            # 1.0 - x[i] - r[i] >= 0\n            jac[N+i, 3*i] = -1.0\n            jac[N+i, 3*i+2] = -1.0\n            # y[i] - r[i] >= 0\n            jac[2*N+i, 3*i+1] = 1.0\n            jac[2*N+i, 3*i+2] = -1.0\n            # 1.0 - y[i] - r[i] >= 0\n            jac[3*N+i, 3*i+1] = -1.0\n            jac[3*N+i, 3*i+2] = -1.0\n            \n        # Filling overlap constraint derivatives\n        i_indices, j_indices = np.triu_indices(N, k=1)\n        row_indices = np.arange(num_boundary, num_boundary + num_overlap)\n        \n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        \n        jac[row_indices, 3*i_indices] = 2 * dx\n        jac[row_indices, 3*j_indices] = -2 * dx\n        jac[row_indices, 3*i_indices+1] = 2 * dy\n        jac[row_indices, 3*j_indices+1] = -2 * dy\n        jac[row_indices, 3*i_indices+2] = -2 * dr\n        jac[row_indices, 3*j_indices+2] = -2 * dr\n        \n        return jac\n\n    # Variable bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    \n    best_sum_radii = 0\n    best_vars = None\n    start_time = time.time()\n    \n    # Multi-start loop\n    for num_starts in range(1, 51):\n        # Time check: stop if we exceed 280 seconds to allow for refinement\n        if time.time() - start_time > 280:\n            break\n        \n        # Diverse initial guesses: grid-based and random\n        if num_starts % 10 == 1:\n            # Grid start\n            s = int(np.ceil(np.sqrt(N)))\n            xx, yy = np.meshgrid(np.linspace(0.1, 0.9, s), np.linspace(0.1, 0.9, s))\n            x0 = np.zeros(3 * N)\n            x0[0::3] = xx.flatten()[:N]\n            x0[1::3] = yy.flatten()[:N]\n            x0[2::3] = 0.09\n        else:\n            # Random starts with varying radii distributions\n            x0 = np.zeros(3 * N)\n            x0[0::3] = 0.1 + 0.8 * np.random.rand(N)\n            x0[1::3] = 0.1 + 0.8 * np.random.rand(N)\n            if num_starts % 3 == 0:\n                x0[2::3] = 0.05 + 0.05 * np.random.rand(N)\n            elif num_starts % 3 == 1:\n                x0[2::3] = 0.08 + 0.04 * np.random.rand(N)\n            else:\n                x0[2::3] = 0.1 * np.random.rand(N)\n        \n        # Local optimization using SLSQP\n        res = minimize(\n            objective, x0, method='SLSQP', jac=objective_grad,\n            constraints={'type': 'ineq', 'fun': constraints_vectorized, 'jac': jacobian_vectorized},\n            bounds=bounds, options={'maxiter': 100}\n        )\n        \n        if -res.fun > best_sum_radii:\n            best_sum_radii = -res.fun\n            best_vars = res.x\n            \n    # Final refinement step for the best solution found\n    if best_vars is not None:\n        res = minimize(\n            objective, best_vars, method='SLSQP', jac=objective_grad,\n            constraints={'type': 'ineq', 'fun': constraints_vectorized, 'jac': jacobian_vectorized},\n            bounds=bounds, options={'maxiter': 200}\n        )\n        best_sum_radii = -res.fun\n        best_vars = res.x\n    else:\n        # Fallback in case no optimization was completed\n        best_centers = np.random.rand(N, 2)\n        best_radii = np.zeros(N)\n        return best_centers, best_radii, 0.0\n\n    # Extract centers and radii from the flat result array\n    best_centers = np.column_stack((best_vars[0::3], best_vars[1::3]))\n    best_radii = best_vars[2::3]\n    \n    return best_centers, best_radii, best_sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:55:15.490803",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 297,
        "candidates_token_count": 1921,
        "thoughts_token_count": 18184
      },
      "response_text_len": 5221
    }
  },
  "llm_call_duration_s": 116.23678046395071,
  "eval_duration_s": 82.01064639305696
}