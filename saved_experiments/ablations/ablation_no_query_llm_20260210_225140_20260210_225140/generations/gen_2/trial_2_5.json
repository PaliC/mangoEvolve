{
  "trial_id": "trial_2_5",
  "generation": 2,
  "parent_id": "trial_0_4",
  "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square to maximize the sum of their radii.\n    Uses an Iterative Growth algorithm followed by SLSQP optimization.\n    The process is repeated over multiple trials to avoid local optima.\n    \"\"\"\n    n_circles = 26\n    n_trials = 15\n    n_growth_iters = 500\n    \n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    # Precompute the constraint matrix for the Linear Programming (LP) radii update.\n    # The LP maximizes the sum of radii for a fixed set of center coordinates.\n    num_pairs = n_circles * (n_circles - 1) // 2\n    A_ub_lp = np.zeros((num_pairs, n_circles))\n    k = 0\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            A_ub_lp[k, i] = 1\n            A_ub_lp[k, j] = 1\n            k += 1\n\n    start_time = time.time()\n\n    for trial in range(n_trials):\n        # Time limit check to ensure completion within 300 seconds.\n        if time.time() - start_time > 275:\n            break\n            \n        # 1. Initialize centers randomly within the unit square [0, 1] x [0, 1].\n        centers = np.random.rand(n_circles, 2)\n        \n        # 2. Iterative Growth Phase\n        for it in range(n_growth_iters):\n            # Calculate pairwise distances between centers.\n            dists = pdist(centers)\n            \n            # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i.\n            bounds_lp = []\n            for i in range(n_circles):\n                xi, yi = centers[i]\n                max_ri = min(xi, 1-xi, yi, 1-yi)\n                bounds_lp.append((0, max(0, max_ri)))\n            \n            # Solve the LP to find radii that maximize the sum of radii for current centers.\n            # Objective is -1 for each radius to perform maximization using linprog.\n            res = linprog(-np.ones(n_circles), A_ub=A_ub_lp, b_ub=dists, bounds=bounds_lp, method='highs')\n            \n            if not res.success:\n                break\n            radii = res.x\n            \n            # Use gradient descent to move centers away from their most restrictive constraints.\n            forces = np.zeros((n_circles, 2))\n            eps = 1e-7\n            k_pair = 0\n            for i in range(n_circles):\n                # Boundary constraints check\n                if radii[i] >= centers[i, 0] - eps: forces[i, 0] += 1\n                if radii[i] >= 1 - centers[i, 0] - eps: forces[i, 0] -= 1\n                if radii[i] >= centers[i, 1] - eps: forces[i, 1] += 1\n                if radii[i] >= 1 - centers[i, 1] - eps: forces[i, 1] -= 1\n                \n                # Neighboring circle overlap check\n                for j in range(i + 1, n_circles):\n                    d_ij = dists[k_pair]\n                    if radii[i] + radii[j] >= d_ij - eps:\n                        force_vec = (centers[i] - centers[j]) / (d_ij + 1e-9)\n                        forces[i] += force_vec\n                        forces[j] -= force_vec\n                    k_pair += 1\n            \n            # Update center positions based on calculated forces.\n            step = 0.005 * (1 - it / n_growth_iters)\n            centers += step * forces\n            centers = np.clip(centers, 0, 1)\n            \n        # 3. Final SLSQP Optimization Phase\n        # Find the best radii for the final positions to use as the initial guess for SLSQP.\n        dists = pdist(centers)\n        bounds_lp = [(0, max(0, min(c[0], 1-c[0], c[1], 1-c[1]))) for c in centers]\n        res = linprog(-np.ones(n_circles), A_ub=A_ub_lp, b_ub=dists, bounds=bounds_lp, method='highs')\n        radii = res.x if res.success else np.zeros(n_circles)\n        \n        # Optimization variables: [x_1...x_26, y_1...y_26, r_1...r_26]\n        initial_guess = np.concatenate([centers[:, 0], centers[:, 1], radii])\n        \n        def objective(vars):\n            # Sum of radii is stored in the last 26 elements of the array.\n            return -np.sum(vars[52:])\n        \n        def constraint_fn(vars):\n            x = vars[:26]\n            y = vars[26:52]\n            r = vars[52:]\n            \n            # Boundary constraints: r_i must be within [0, x_i], [0, 1-x_i], etc.\n            c_bound = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n            \n            # Non-overlap constraints: dist(c_i, c_j) >= r_i + r_j\n            dx = x[:, None] - x[None, :]\n            dy = y[:, None] - y[None, :]\n            dist_matrix = np.sqrt(dx**2 + dy**2 + np.eye(n_circles))\n            r_sum_matrix = r[:, None] + r[None, :]\n            iu = np.triu_indices(n_circles, k=1)\n            c_overlap = dist_matrix[iu] - r_sum_matrix[iu]\n            \n            return np.concatenate([c_bound, c_overlap])\n\n        # Define bounds and constraints for SLSQP.\n        bnds = [(0, 1)] * 52 + [(0, 0.5)] * 26\n        cons = {'type': 'ineq', 'fun': constraint_fn}\n        \n        res_opt = minimize(objective, initial_guess, method='SLSQP', \n                           constraints=cons, bounds=bnds, options={'maxiter': 200})\n        \n        # Track the best solution found across all trials.\n        current_sum = -res_opt.fun\n        if current_sum > best_sum_radii:\n            best_sum_radii = current_sum\n            best_centers = np.column_stack((res_opt.x[:26], res_opt.x[26:52]))\n            best_radii = res_opt.x[52:]\n                \n    return best_centers, best_radii, best_sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.628037266260169,
    "eval_time": 13.06261134147644,
    "error": null
  },
  "prompt": "Implement an 'Iterative Growth' algorithm.\n1. Start with 26 random points in the unit square.\n2. In each iteration:\n   a. Calculate the maximum possible radius for each circle i, given the current positions of all other circles and the boundaries.\n   b. Update the radii to these maximum values.\n   c. Use a small gradient descent step on the centers to move them away from their tightest constraints (the neighbors or boundaries that limit their radii).\n3. After 500 iterations of this growth/movement, perform a final SLSQP optimization to maximize the sum of radii.\n4. Repeat with 15 different random initial point sets.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square to maximize the sum of their radii.\n    Uses an Iterative Growth algorithm followed by SLSQP optimization.\n    The process is repeated over multiple trials to avoid local optima.\n    \"\"\"\n    n_circles = 26\n    n_trials = 15\n    n_growth_iters = 500\n    \n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    # Precompute the constraint matrix for the Linear Programming (LP) radii update.\n    # The LP maximizes the sum of radii for a fixed set of center coordinates.\n    num_pairs = n_circles * (n_circles - 1) // 2\n    A_ub_lp = np.zeros((num_pairs, n_circles))\n    k = 0\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            A_ub_lp[k, i] = 1\n            A_ub_lp[k, j] = 1\n            k += 1\n\n    start_time = time.time()\n\n    for trial in range(n_trials):\n        # Time limit check to ensure completion within 300 seconds.\n        if time.time() - start_time > 275:\n            break\n            \n        # 1. Initialize centers randomly within the unit square [0, 1] x [0, 1].\n        centers = np.random.rand(n_circles, 2)\n        \n        # 2. Iterative Growth Phase\n        for it in range(n_growth_iters):\n            # Calculate pairwise distances between centers.\n            dists = pdist(centers)\n            \n            # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i.\n            bounds_lp = []\n            for i in range(n_circles):\n                xi, yi = centers[i]\n                max_ri = min(xi, 1-xi, yi, 1-yi)\n                bounds_lp.append((0, max(0, max_ri)))\n            \n            # Solve the LP to find radii that maximize the sum of radii for current centers.\n            # Objective is -1 for each radius to perform maximization using linprog.\n            res = linprog(-np.ones(n_circles), A_ub=A_ub_lp, b_ub=dists, bounds=bounds_lp, method='highs')\n            \n            if not res.success:\n                break\n            radii = res.x\n            \n            # Use gradient descent to move centers away from their most restrictive constraints.\n            forces = np.zeros((n_circles, 2))\n            eps = 1e-7\n            k_pair = 0\n            for i in range(n_circles):\n                # Boundary constraints check\n                if radii[i] >= centers[i, 0] - eps: forces[i, 0] += 1\n                if radii[i] >= 1 - centers[i, 0] - eps: forces[i, 0] -= 1\n                if radii[i] >= centers[i, 1] - eps: forces[i, 1] += 1\n                if radii[i] >= 1 - centers[i, 1] - eps: forces[i, 1] -= 1\n                \n                # Neighboring circle overlap check\n                for j in range(i + 1, n_circles):\n                    d_ij = dists[k_pair]\n                    if radii[i] + radii[j] >= d_ij - eps:\n                        force_vec = (centers[i] - centers[j]) / (d_ij + 1e-9)\n                        forces[i] += force_vec\n                        forces[j] -= force_vec\n                    k_pair += 1\n            \n            # Update center positions based on calculated forces.\n            step = 0.005 * (1 - it / n_growth_iters)\n            centers += step * forces\n            centers = np.clip(centers, 0, 1)\n            \n        # 3. Final SLSQP Optimization Phase\n        # Find the best radii for the final positions to use as the initial guess for SLSQP.\n        dists = pdist(centers)\n        bounds_lp = [(0, max(0, min(c[0], 1-c[0], c[1], 1-c[1]))) for c in centers]\n        res = linprog(-np.ones(n_circles), A_ub=A_ub_lp, b_ub=dists, bounds=bounds_lp, method='highs')\n        radii = res.x if res.success else np.zeros(n_circles)\n        \n        # Optimization variables: [x_1...x_26, y_1...y_26, r_1...r_26]\n        initial_guess = np.concatenate([centers[:, 0], centers[:, 1], radii])\n        \n        def objective(vars):\n            # Sum of radii is stored in the last 26 elements of the array.\n            return -np.sum(vars[52:])\n        \n        def constraint_fn(vars):\n            x = vars[:26]\n            y = vars[26:52]\n            r = vars[52:]\n            \n            # Boundary constraints: r_i must be within [0, x_i], [0, 1-x_i], etc.\n            c_bound = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n            \n            # Non-overlap constraints: dist(c_i, c_j) >= r_i + r_j\n            dx = x[:, None] - x[None, :]\n            dy = y[:, None] - y[None, :]\n            dist_matrix = np.sqrt(dx**2 + dy**2 + np.eye(n_circles))\n            r_sum_matrix = r[:, None] + r[None, :]\n            iu = np.triu_indices(n_circles, k=1)\n            c_overlap = dist_matrix[iu] - r_sum_matrix[iu]\n            \n            return np.concatenate([c_bound, c_overlap])\n\n        # Define bounds and constraints for SLSQP.\n        bnds = [(0, 1)] * 52 + [(0, 0.5)] * 26\n        cons = {'type': 'ineq', 'fun': constraint_fn}\n        \n        res_opt = minimize(objective, initial_guess, method='SLSQP', \n                           constraints=cons, bounds=bnds, options={'maxiter': 200})\n        \n        # Track the best solution found across all trials.\n        current_sum = -res_opt.fun\n        if current_sum > best_sum_radii:\n            best_sum_radii = current_sum\n            best_centers = np.column_stack((res_opt.x[:26], res_opt.x[26:52]))\n            best_radii = res_opt.x[52:]\n                \n    return best_centers, best_radii, best_sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:08:28.600184",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 371,
        "candidates_token_count": 1754,
        "thoughts_token_count": 15319
      },
      "response_text_len": 5553
    }
  },
  "llm_call_duration_s": 92.64281160908286,
  "eval_duration_s": 13.062620003940538
}