{
  "trial_id": "trial_2_0",
  "generation": 2,
  "parent_id": "trial_1_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The approach uses a two-stage optimization:\n    1. Maximize equal radii to spread centers evenly across the square.\n    2. Maximize the sum of radii starting from the equal-radii configuration.\n    It also uses several grid initializations and a shaking phase to escape local optima.\n    \"\"\"\n    start_time = time.time()\n    N = 26\n    np.random.seed(42)\n    \n    # Precompute indices for non-overlap constraints\n    IDX_I, IDX_J = np.triu_indices(N, k=1)\n\n    # Objective and constraints for Stage 1: Maximize equal radius r\n    def equal_r_obj(params):\n        return -params[2*N]\n\n    def equal_r_cons(params):\n        x, y, r = params[:N], params[N:2*N], params[2*N]\n        c = np.empty(4*N + N*(N-1)//2)\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        c[4*N:] = (x[IDX_I]-x[IDX_J])**2 + (y[IDX_I]-y[IDX_J])**2 - 4*r**2\n        return c\n\n    # Objective and constraints for Stage 2: Maximize sum of radii sum(r_i)\n    def sum_r_obj(params):\n        return -np.sum(params[2*N:3*N])\n\n    def sum_r_cons(params):\n        x, y, r = params[:N], params[N:2*N], params[2*N:3*N]\n        c = np.empty(4*N + N*(N-1)//2)\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        c[4*N:] = (x[IDX_I]-x[IDX_J])**2 + (y[IDX_I]-y[IDX_J])**2 - (r[IDX_I]+r[IDX_J])**2\n        return c\n\n    # Function to generate different grid-based initial centers\n    def get_grid(nx, ny, N, staggered=True):\n        centers = []\n        for i in range(nx):\n            for j in range(ny):\n                if staggered:\n                    cx = (i + 0.5 * (j % 2))\n                    cy = j * 0.866\n                else:\n                    cx = i\n                    cy = j\n                centers.append((cx, cy))\n        centers = np.array(centers)\n        if len(centers) < N:\n            # If grid is too small, pad with random points\n            extra = np.random.rand(N - len(centers), 2)\n            centers = np.vstack([centers, extra])\n        cmin = centers.min(axis=0)\n        cmax = centers.max(axis=0)\n        diff = cmax - cmin\n        diff[diff == 0] = 1.0\n        centers = (centers - cmin) / diff\n        centers = 0.1 + 0.8 * centers\n        return centers[:N]\n\n    # Define a set of initializations (random and grid variations)\n    all_centers = []\n    all_centers.append(np.random.rand(N, 2) * 0.8 + 0.1)\n    grid_configs = [(5, 6), (6, 5), (4, 7), (7, 4), (5, 5)]\n    for nx, ny in grid_configs:\n        for staggered in [True, False]:\n            all_centers.append(get_grid(nx, ny, N, staggered))\n    \n    best_sum_r = 0\n    best_centers = None\n    best_radii = None\n\n    # Iterate through initial configurations\n    for centers_init in all_centers:\n        if time.time() - start_time > 220:\n            break\n        \n        # Stage 1: Maximize equal radius (r) to find a good distribution of centers\n        x_init, y_init = centers_init[:, 0], centers_init[:, 1]\n        init_params1 = np.concatenate([x_init, y_init, [0.05]])\n        res1 = minimize(equal_r_obj, init_params1, method='SLSQP', \n                        constraints={'type': 'ineq', 'fun': equal_r_cons},\n                        bounds=[(0, 1)]*(2*N) + [(0, 0.5)],\n                        options={'maxiter': 100})\n        \n        # Stage 2: Maximize sum of radii (r_i) starting from Stage 1 result\n        x_opt, y_opt, r_opt = res1.x[:N], res1.x[N:2*N], res1.x[2*N]\n        # Start with slightly reduced radius to stay inside feasible region\n        init_params2 = np.concatenate([x_opt, y_opt, np.full(N, r_opt * 0.99)])\n        res2 = minimize(sum_r_obj, init_params2, method='SLSQP', \n                        constraints={'type': 'ineq', 'fun': sum_r_cons},\n                        bounds=[(0, 1)]*(2*N) + [(0, 0.5)]*N,\n                        options={'maxiter': 200})\n        \n        # Update the best solution found so far\n        current_sum_r = np.sum(res2.x[2*N:3*N])\n        if current_sum_r > best_sum_r:\n            best_sum_r = current_sum_r\n            best_centers = np.column_stack([res2.x[:N], res2.x[N:2*N]])\n            best_radii = res2.x[2*N:3*N]\n\n    # Shaking phase: Perturb the best result and re-optimize to refine the solution\n    while time.time() - start_time < 285:\n        if best_centers is None:\n            break\n        # Small perturbation to centers and radii\n        x_shake = best_centers[:, 0] + np.random.normal(0, 0.001, N)\n        y_shake = best_centers[:, 1] + np.random.normal(0, 0.001, N)\n        r_shake = best_radii * 0.99\n        init_params_shake = np.concatenate([x_shake, y_shake, r_shake])\n        \n        res_shake = minimize(sum_r_obj, init_params_shake, method='SLSQP', \n                             constraints={'type': 'ineq', 'fun': sum_r_cons},\n                             bounds=[(0, 1)]*(2*N) + [(0, 0.5)]*N,\n                             options={'maxiter': 200})\n        \n        current_sum_r = np.sum(res_shake.x[2*N:3*N])\n        if current_sum_r > best_sum_r:\n            best_sum_r = current_sum_r\n            best_centers = np.column_stack([res_shake.x[:N], res_shake.x[N:2*N]])\n            best_radii = res_shake.x[2*N:3*N]\n\n    # Final cleanup of sum_radii\n    best_sum_r = float(np.sum(best_radii))\n    \n    return best_centers, best_radii, best_sum_r",
  "metrics": {
    "valid": true,
    "score": 2.627756310814269,
    "eval_time": 285.40952706336975,
    "error": null
  },
  "prompt": "Improve the successful strategy in trial_1_1 (score: 2.629324720984922).\nThe previous approach used hexagonal grid variations and SLSQP.\nEnhance this by:\n1. Increasing the number of grid variations (try different aspect ratios and rotations).\n2. For each initialization, perform a 'shaking' phase: run a short Basin-Hopping or multiple SLSQP passes with small random perturbations to the centers.\n3. Ensure boundary constraints are robustly implemented: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i.\n4. Use a two-stage optimization: first optimize for equal radii, then use that as a seed to maximize the sum of radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The approach uses a two-stage optimization:\n    1. Maximize equal radii to spread centers evenly across the square.\n    2. Maximize the sum of radii starting from the equal-radii configuration.\n    It also uses several grid initializations and a shaking phase to escape local optima.\n    \"\"\"\n    start_time = time.time()\n    N = 26\n    np.random.seed(42)\n    \n    # Precompute indices for non-overlap constraints\n    IDX_I, IDX_J = np.triu_indices(N, k=1)\n\n    # Objective and constraints for Stage 1: Maximize equal radius r\n    def equal_r_obj(params):\n        return -params[2*N]\n\n    def equal_r_cons(params):\n        x, y, r = params[:N], params[N:2*N], params[2*N]\n        c = np.empty(4*N + N*(N-1)//2)\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        c[4*N:] = (x[IDX_I]-x[IDX_J])**2 + (y[IDX_I]-y[IDX_J])**2 - 4*r**2\n        return c\n\n    # Objective and constraints for Stage 2: Maximize sum of radii sum(r_i)\n    def sum_r_obj(params):\n        return -np.sum(params[2*N:3*N])\n\n    def sum_r_cons(params):\n        x, y, r = params[:N], params[N:2*N], params[2*N:3*N]\n        c = np.empty(4*N + N*(N-1)//2)\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        c[4*N:] = (x[IDX_I]-x[IDX_J])**2 + (y[IDX_I]-y[IDX_J])**2 - (r[IDX_I]+r[IDX_J])**2\n        return c\n\n    # Function to generate different grid-based initial centers\n    def get_grid(nx, ny, N, staggered=True):\n        centers = []\n        for i in range(nx):\n            for j in range(ny):\n                if staggered:\n                    cx = (i + 0.5 * (j % 2))\n                    cy = j * 0.866\n                else:\n                    cx = i\n                    cy = j\n                centers.append((cx, cy))\n        centers = np.array(centers)\n        if len(centers) < N:\n            # If grid is too small, pad with random points\n            extra = np.random.rand(N - len(centers), 2)\n            centers = np.vstack([centers, extra])\n        cmin = centers.min(axis=0)\n        cmax = centers.max(axis=0)\n        diff = cmax - cmin\n        diff[diff == 0] = 1.0\n        centers = (centers - cmin) / diff\n        centers = 0.1 + 0.8 * centers\n        return centers[:N]\n\n    # Define a set of initializations (random and grid variations)\n    all_centers = []\n    all_centers.append(np.random.rand(N, 2) * 0.8 + 0.1)\n    grid_configs = [(5, 6), (6, 5), (4, 7), (7, 4), (5, 5)]\n    for nx, ny in grid_configs:\n        for staggered in [True, False]:\n            all_centers.append(get_grid(nx, ny, N, staggered))\n    \n    best_sum_r = 0\n    best_centers = None\n    best_radii = None\n\n    # Iterate through initial configurations\n    for centers_init in all_centers:\n        if time.time() - start_time > 220:\n            break\n        \n        # Stage 1: Maximize equal radius (r) to find a good distribution of centers\n        x_init, y_init = centers_init[:, 0], centers_init[:, 1]\n        init_params1 = np.concatenate([x_init, y_init, [0.05]])\n        res1 = minimize(equal_r_obj, init_params1, method='SLSQP', \n                        constraints={'type': 'ineq', 'fun': equal_r_cons},\n                        bounds=[(0, 1)]*(2*N) + [(0, 0.5)],\n                        options={'maxiter': 100})\n        \n        # Stage 2: Maximize sum of radii (r_i) starting from Stage 1 result\n        x_opt, y_opt, r_opt = res1.x[:N], res1.x[N:2*N], res1.x[2*N]\n        # Start with slightly reduced radius to stay inside feasible region\n        init_params2 = np.concatenate([x_opt, y_opt, np.full(N, r_opt * 0.99)])\n        res2 = minimize(sum_r_obj, init_params2, method='SLSQP', \n                        constraints={'type': 'ineq', 'fun': sum_r_cons},\n                        bounds=[(0, 1)]*(2*N) + [(0, 0.5)]*N,\n                        options={'maxiter': 200})\n        \n        # Update the best solution found so far\n        current_sum_r = np.sum(res2.x[2*N:3*N])\n        if current_sum_r > best_sum_r:\n            best_sum_r = current_sum_r\n            best_centers = np.column_stack([res2.x[:N], res2.x[N:2*N]])\n            best_radii = res2.x[2*N:3*N]\n\n    # Shaking phase: Perturb the best result and re-optimize to refine the solution\n    while time.time() - start_time < 285:\n        if best_centers is None:\n            break\n        # Small perturbation to centers and radii\n        x_shake = best_centers[:, 0] + np.random.normal(0, 0.001, N)\n        y_shake = best_centers[:, 1] + np.random.normal(0, 0.001, N)\n        r_shake = best_radii * 0.99\n        init_params_shake = np.concatenate([x_shake, y_shake, r_shake])\n        \n        res_shake = minimize(sum_r_obj, init_params_shake, method='SLSQP', \n                             constraints={'type': 'ineq', 'fun': sum_r_cons},\n                             bounds=[(0, 1)]*(2*N) + [(0, 0.5)]*N,\n                             options={'maxiter': 200})\n        \n        current_sum_r = np.sum(res_shake.x[2*N:3*N])\n        if current_sum_r > best_sum_r:\n            best_sum_r = current_sum_r\n            best_centers = np.column_stack([res_shake.x[:N], res_shake.x[N:2*N]])\n            best_radii = res_shake.x[2*N:3*N]\n\n    # Final cleanup of sum_radii\n    best_sum_r = float(np.sum(best_radii))\n    \n    return best_centers, best_radii, best_sum_r\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:13:46.289484",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 408,
        "candidates_token_count": 1962,
        "thoughts_token_count": 23267
      },
      "response_text_len": 5538
    }
  },
  "llm_call_duration_s": 137.9860417500604,
  "eval_duration_s": 285.4095390830189
}