{
  "trial_id": "trial_2_3",
  "generation": 2,
  "parent_id": "trial_1_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a meta-heuristic 'Circle Swapping' approach with SLSQP local optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for distance constraints to speed up Jacobian computation\n    i_indices, j_indices = np.triu_indices(N, k=1)\n    k_indices = np.arange(len(i_indices))\n\n    def objective(vars):\n        # vars: [x1...xN, y1...yN, r1...rN]\n        # We want to maximize sum(radii), so minimize -sum(radii)\n        return -np.sum(vars[2*N:3*N])\n\n    def objective_jac(vars):\n        # Gradient of the objective function\n        jac = np.zeros(3*N)\n        jac[2*N:3*N] = -1.0\n        return jac\n\n    def constraints(vars):\n        # All constraints must be g(vars) >= 0\n        x, y, r = vars[0:N], vars[N:2*N], vars[2*N:3*N]\n        res = np.zeros(4*N + len(i_indices))\n        # Boundary constraints: circle must be inside [0,1]x[0,1]\n        res[0:N] = x - r           # x_i - r_i >= 0\n        res[N:2*N] = 1 - x - r     # 1 - x_i - r_i >= 0\n        res[2*N:3*N] = y - r       # y_i - r_i >= 0\n        res[3*N:4*N] = 1 - y - r   # 1 - y_i - r_i >= 0\n        # No-overlap constraints: dist(c_i, c_j)^2 >= (r_i + r_j)^2\n        res[4*N:] = (x[i_indices] - x[j_indices])**2 + \\\n                    (y[i_indices] - y[j_indices])**2 - \\\n                    (r[i_indices] + r[j_indices])**2\n        return res\n\n    def constraints_jac(vars):\n        # Jacobian of the constraints\n        x, y, r = vars[0:N], vars[N:2*N], vars[2*N:3*N]\n        jac = np.zeros((4*N + len(i_indices), 3*N))\n        # Gradients for boundary constraints\n        for i in range(N):\n            jac[i, i], jac[i, 2*N+i] = 1, -1\n            jac[N+i, i], jac[N+i, 2*N+i] = -1, -1\n            jac[2*N+i, N+i], jac[2*N+i, 2*N+i] = 1, -1\n            jac[3*N+i, N+i], jac[3*N+i, 2*N+i] = -1, -1\n        # Gradients for distance constraints\n        idx = 4*N\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        \n        jac[idx + k_indices, i_indices] = 2 * dx\n        jac[idx + k_indices, j_indices] = -2 * dx\n        jac[idx + k_indices, N + i_indices] = 2 * dy\n        jac[idx + k_indices, N + j_indices] = -2 * dy\n        jac[idx + k_indices, 2*N + i_indices] = -2 * dr\n        jac[idx + k_indices, 2*N + j_indices] = -2 * dr\n        return jac\n\n    # Problem setup for SLSQP\n    cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    best_sum = 0\n    best_vars = None\n\n    # Step 1: Initial random starts to explore different basins\n    # We try a few different initial radii to find a stable configuration\n    for r_val in [0.02, 0.05, 0.08]:\n        if time.time() - start_time > 60: break\n        x_init = np.random.rand(N) * 0.8 + 0.1\n        y_init = np.random.rand(N) * 0.8 + 0.1\n        vars_init = np.concatenate([x_init, y_init, np.ones(N) * r_val])\n        \n        res = minimize(objective, vars_init, jac=objective_jac,\n                       constraints=cons, bounds=bounds, method='SLSQP',\n                       options={'maxiter': 100, 'ftol': 1e-6})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n\n    # Step 2: Meta-heuristic 'Circle Swapping'\n    # Repeatedly move the smallest circle to the largest available gap\n    while time.time() - start_time < 260:\n        if best_vars is None: break\n        \n        x, y, r = best_vars[0:N], best_vars[N:2*N], best_vars[2*N:3*N]\n        idx_to_move = np.argmin(r) # Smallest circle\n        \n        # Exclude the circle being moved from gap calculation\n        x_other = np.delete(x, idx_to_move)\n        y_other = np.delete(y, idx_to_move)\n        r_other = np.delete(r, idx_to_move)\n        \n        # Find largest gap using random sampling\n        best_p, max_gap = (np.random.rand(2), -1)\n        for _ in range(1000):\n            p = np.random.rand(2)\n            # Distance from point p to nearest existing circle boundary\n            dists = np.sqrt((p[0]-x_other)**2 + (p[1]-y_other)**2) - r_other\n            # Must also stay within square boundaries\n            dist_to_bounds = np.array([p[0], 1-p[0], p[1], 1-p[1]])\n            min_dist = min(np.min(dists), np.min(dist_to_bounds))\n            \n            if min_dist > max_gap:\n                max_gap, best_p = min_dist, p\n        \n        # Create a new trial configuration by \"re-homing\" the smallest circle\n        new_vars = best_vars.copy()\n        new_vars[idx_to_move] = best_p[0]\n        new_vars[N + idx_to_move] = best_p[1]\n        new_vars[2*N + idx_to_move] = max(0, max_gap)\n        \n        # Optimize the new configuration\n        res = minimize(objective, new_vars, jac=objective_jac,\n                       constraints=cons, bounds=bounds, method='SLSQP',\n                       options={'maxiter': 100, 'ftol': 1e-7})\n        \n        # Update best solution if improvement is found\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n\n    # Step 3: Final polish of the best found configuration\n    if best_vars is not None:\n        res = minimize(objective, best_vars, jac=objective_jac,\n                       constraints=cons, bounds=bounds, method='SLSQP',\n                       options={'maxiter': 500, 'ftol': 1e-9})\n        if -res.fun > best_sum:\n            best_vars = res.x\n            best_sum = -res.fun\n\n    # Prepare final output\n    final_centers = np.column_stack([best_vars[0:N], best_vars[N:2*N]])\n    final_radii = best_vars[2*N:3*N]\n    \n    return final_centers, final_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.619835644207157,
    "eval_time": 260.9355595111847,
    "error": null
  },
  "prompt": "Explore a 'Circle Swapping' meta-heuristic.\n1. Start with the best known configuration from {best_trial.trial_id}.\n2. Identify the circles with the smallest radii.\n3. Attempt to 're-home' these small circles by moving their centers to the largest available gaps in the packing.\n4. After each move, run a local SLSQP optimization to see if the total sum of radii improves.\n5. If the sum improves, keep the change; otherwise, revert.\n6. This acts as a targeted Basin-Hopping approach to escape local optima where small circles are 'trapped'.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a meta-heuristic 'Circle Swapping' approach with SLSQP local optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for distance constraints to speed up Jacobian computation\n    i_indices, j_indices = np.triu_indices(N, k=1)\n    k_indices = np.arange(len(i_indices))\n\n    def objective(vars):\n        # vars: [x1...xN, y1...yN, r1...rN]\n        # We want to maximize sum(radii), so minimize -sum(radii)\n        return -np.sum(vars[2*N:3*N])\n\n    def objective_jac(vars):\n        # Gradient of the objective function\n        jac = np.zeros(3*N)\n        jac[2*N:3*N] = -1.0\n        return jac\n\n    def constraints(vars):\n        # All constraints must be g(vars) >= 0\n        x, y, r = vars[0:N], vars[N:2*N], vars[2*N:3*N]\n        res = np.zeros(4*N + len(i_indices))\n        # Boundary constraints: circle must be inside [0,1]x[0,1]\n        res[0:N] = x - r           # x_i - r_i >= 0\n        res[N:2*N] = 1 - x - r     # 1 - x_i - r_i >= 0\n        res[2*N:3*N] = y - r       # y_i - r_i >= 0\n        res[3*N:4*N] = 1 - y - r   # 1 - y_i - r_i >= 0\n        # No-overlap constraints: dist(c_i, c_j)^2 >= (r_i + r_j)^2\n        res[4*N:] = (x[i_indices] - x[j_indices])**2 + \\\n                    (y[i_indices] - y[j_indices])**2 - \\\n                    (r[i_indices] + r[j_indices])**2\n        return res\n\n    def constraints_jac(vars):\n        # Jacobian of the constraints\n        x, y, r = vars[0:N], vars[N:2*N], vars[2*N:3*N]\n        jac = np.zeros((4*N + len(i_indices), 3*N))\n        # Gradients for boundary constraints\n        for i in range(N):\n            jac[i, i], jac[i, 2*N+i] = 1, -1\n            jac[N+i, i], jac[N+i, 2*N+i] = -1, -1\n            jac[2*N+i, N+i], jac[2*N+i, 2*N+i] = 1, -1\n            jac[3*N+i, N+i], jac[3*N+i, 2*N+i] = -1, -1\n        # Gradients for distance constraints\n        idx = 4*N\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        \n        jac[idx + k_indices, i_indices] = 2 * dx\n        jac[idx + k_indices, j_indices] = -2 * dx\n        jac[idx + k_indices, N + i_indices] = 2 * dy\n        jac[idx + k_indices, N + j_indices] = -2 * dy\n        jac[idx + k_indices, 2*N + i_indices] = -2 * dr\n        jac[idx + k_indices, 2*N + j_indices] = -2 * dr\n        return jac\n\n    # Problem setup for SLSQP\n    cons = {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac}\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    best_sum = 0\n    best_vars = None\n\n    # Step 1: Initial random starts to explore different basins\n    # We try a few different initial radii to find a stable configuration\n    for r_val in [0.02, 0.05, 0.08]:\n        if time.time() - start_time > 60: break\n        x_init = np.random.rand(N) * 0.8 + 0.1\n        y_init = np.random.rand(N) * 0.8 + 0.1\n        vars_init = np.concatenate([x_init, y_init, np.ones(N) * r_val])\n        \n        res = minimize(objective, vars_init, jac=objective_jac,\n                       constraints=cons, bounds=bounds, method='SLSQP',\n                       options={'maxiter': 100, 'ftol': 1e-6})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n\n    # Step 2: Meta-heuristic 'Circle Swapping'\n    # Repeatedly move the smallest circle to the largest available gap\n    while time.time() - start_time < 260:\n        if best_vars is None: break\n        \n        x, y, r = best_vars[0:N], best_vars[N:2*N], best_vars[2*N:3*N]\n        idx_to_move = np.argmin(r) # Smallest circle\n        \n        # Exclude the circle being moved from gap calculation\n        x_other = np.delete(x, idx_to_move)\n        y_other = np.delete(y, idx_to_move)\n        r_other = np.delete(r, idx_to_move)\n        \n        # Find largest gap using random sampling\n        best_p, max_gap = (np.random.rand(2), -1)\n        for _ in range(1000):\n            p = np.random.rand(2)\n            # Distance from point p to nearest existing circle boundary\n            dists = np.sqrt((p[0]-x_other)**2 + (p[1]-y_other)**2) - r_other\n            # Must also stay within square boundaries\n            dist_to_bounds = np.array([p[0], 1-p[0], p[1], 1-p[1]])\n            min_dist = min(np.min(dists), np.min(dist_to_bounds))\n            \n            if min_dist > max_gap:\n                max_gap, best_p = min_dist, p\n        \n        # Create a new trial configuration by \"re-homing\" the smallest circle\n        new_vars = best_vars.copy()\n        new_vars[idx_to_move] = best_p[0]\n        new_vars[N + idx_to_move] = best_p[1]\n        new_vars[2*N + idx_to_move] = max(0, max_gap)\n        \n        # Optimize the new configuration\n        res = minimize(objective, new_vars, jac=objective_jac,\n                       constraints=cons, bounds=bounds, method='SLSQP',\n                       options={'maxiter': 100, 'ftol': 1e-7})\n        \n        # Update best solution if improvement is found\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n\n    # Step 3: Final polish of the best found configuration\n    if best_vars is not None:\n        res = minimize(objective, best_vars, jac=objective_jac,\n                       constraints=cons, bounds=bounds, method='SLSQP',\n                       options={'maxiter': 500, 'ftol': 1e-9})\n        if -res.fun > best_sum:\n            best_vars = res.x\n            best_sum = -res.fun\n\n    # Prepare final output\n    final_centers = np.column_stack([best_vars[0:N], best_vars[N:2*N]])\n    final_radii = best_vars[2*N:3*N]\n    \n    return final_centers, final_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:12:56.339134",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 359,
        "candidates_token_count": 2078,
        "thoughts_token_count": 18700
      },
      "response_text_len": 5814
    }
  },
  "llm_call_duration_s": 112.50845326902345,
  "eval_duration_s": 260.9355669369688
}