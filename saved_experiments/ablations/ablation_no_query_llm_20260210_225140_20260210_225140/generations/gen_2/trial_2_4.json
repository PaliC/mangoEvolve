{
  "trial_id": "trial_2_4",
  "generation": 2,
  "parent_id": "trial_1_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Multi-Start Basin-Hopping with diverse seeds (perturbed hexagonal and random).\n    \"\"\"\n    N = 26\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    start_time = time.time()\n\n    def objective(v):\n        # Objective: minimize the negative sum of radii\n        return -np.sum(v[2::3])\n\n    def constraint_fn(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        # Overlap constraints: dist(i, j) >= r_i + r_j\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        dists = np.sqrt(dx**2 + dy**2)\n        c_overlap = dists - (r[idx_i] + r[idx_j])\n        \n        # Boundary constraints: r <= x <= 1-r and r <= y <= 1-r\n        c_boundary = np.concatenate([\n            x - r,\n            1.0 - x - r,\n            y - r,\n            1.0 - y - r\n        ])\n        return np.concatenate([c_overlap, c_boundary])\n\n    class MyTakeStep:\n        def __init__(self, stepsize=0.02):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            # Perturb x, y, r while trying to maintain bounds\n            x += np.random.uniform(-self.stepsize, self.stepsize, x.shape)\n            x[0::3] = np.clip(x[0::3], 0, 1)\n            x[1::3] = np.clip(x[1::3], 0, 1)\n            x[2::3] = np.clip(x[2::3], 0, 0.5)\n            return x\n\n    # Constraints for SLSQP\n    cons = {'type': 'ineq', 'fun': constraint_fn}\n    # Bounds for x, y, r\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    # Minimizer arguments for Basin-Hopping\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'constraints': cons,\n        'bounds': bounds,\n        'options': {'maxiter': 75}\n    }\n\n    best_v = None\n    best_sum = -1\n\n    # Multi-start approach: 10 different seeds (5 hexagonal, 5 random)\n    for i in range(10):\n        # Stop if we are nearing the 300s limit\n        if time.time() - start_time > 275:\n            break\n        \n        np.random.seed(i)\n        if i < 5:\n            # Perturbed Hexagonal grid initial configuration\n            points = []\n            rows, cols = 5, 6\n            for r_idx in range(rows):\n                for c_idx in range(cols):\n                    # Skip some positions to fit exactly 26 circles\n                    if (r_idx == 0 and c_idx == 0) or (r_idx == 0 and c_idx == 5) or \\\n                       (r_idx == 4 and c_idx == 0) or (r_idx == 4 and c_idx == 5):\n                        continue\n                    if len(points) < N:\n                        # Map to roughly [0.1, 0.9]\n                        px = (c_idx + 0.5 + (0.2 if r_idx % 2 == 1 else 0)) / 6.5\n                        py = (r_idx + 0.5) / 5.5\n                        points.append([px, py])\n            v0 = np.empty(3 * N)\n            points_arr = np.array(points)\n            v0[0::3] = points_arr[:, 0]\n            v0[1::3] = points_arr[:, 1]\n            v0[2::3] = 0.08  # Initial radius guess\n            # Add small noise to coordinates\n            v0[0::3] += np.random.uniform(-0.01, 0.01, N)\n            v0[1::3] += np.random.uniform(-0.01, 0.01, N)\n        else:\n            # Random distribution initial configuration\n            v0 = np.empty(3 * N)\n            v0[0::3] = np.random.uniform(0.1, 0.9, N)\n            v0[1::3] = np.random.uniform(0.1, 0.9, N)\n            v0[2::3] = 0.05\n\n        # Run Basin-Hopping with a limited number of iterations\n        res = basinhopping(\n            objective, \n            v0, \n            niter=1, \n            minimizer_kwargs=minimizer_kwargs, \n            take_step=MyTakeStep(0.02), \n            T=0.1\n        )\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    if best_v is None:\n        return np.zeros((N, 2)), np.zeros(N), 0.0\n\n    # Final post-processing to ensure the solution is strictly feasible\n    x_final, y_final, r_final = best_v[0::3], best_v[1::3], best_v[2::3]\n    \n    # 1. Enforce boundary constraints\n    for i in range(N):\n        r_final[i] = min(r_final[i], x_final[i], 1.0 - x_final[i], y_final[i], 1.0 - y_final[i])\n    \n    # 2. Iteratively enforce overlap constraints (shrink radii if necessary)\n    for _ in range(30):\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.sqrt((x_final[i] - x_final[j])**2 + (y_final[i] - y_final[j])**2)\n                if r_final[i] + r_final[j] > dist:\n                    overlap = (r_final[i] + r_final[j] - dist)\n                    # Shrink both radii equally to resolve overlap\n                    r_final[i] -= overlap / 2.0 + 1e-13\n                    r_final[j] -= overlap / 2.0 + 1e-13\n    \n    r_final = np.maximum(r_final, 0)\n    centers = np.vstack([x_final, y_final]).T\n    sum_radii = np.sum(r_final)\n    \n    return centers, r_final, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.610771993926715,
    "eval_time": 1.2309505939483643,
    "error": null
  },
  "prompt": "Use a Multi-Start Basin-Hopping approach with diverse seeds.\n1. Generate 10 different initial configurations: 5 based on perturbed hexagonal grids and 5 based on random distributions.\n2. For each seed, run `scipy.optimize.basinhopping` using SLSQP as the local minimizer.\n3. The objective function is the negative sum of radii.\n4. Constraints: r_i >= 0, boundary constraints, and non-overlap constraints.\n5. Set a reasonable `niter` for basinhopping to ensure it completes within the 300s limit.\n6. Crucially, ensure the `stepsize` in basinhopping is tuned to keep circles within the unit square or project them back.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Multi-Start Basin-Hopping with diverse seeds (perturbed hexagonal and random).\n    \"\"\"\n    N = 26\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    start_time = time.time()\n\n    def objective(v):\n        # Objective: minimize the negative sum of radii\n        return -np.sum(v[2::3])\n\n    def constraint_fn(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        # Overlap constraints: dist(i, j) >= r_i + r_j\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        dists = np.sqrt(dx**2 + dy**2)\n        c_overlap = dists - (r[idx_i] + r[idx_j])\n        \n        # Boundary constraints: r <= x <= 1-r and r <= y <= 1-r\n        c_boundary = np.concatenate([\n            x - r,\n            1.0 - x - r,\n            y - r,\n            1.0 - y - r\n        ])\n        return np.concatenate([c_overlap, c_boundary])\n\n    class MyTakeStep:\n        def __init__(self, stepsize=0.02):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            # Perturb x, y, r while trying to maintain bounds\n            x += np.random.uniform(-self.stepsize, self.stepsize, x.shape)\n            x[0::3] = np.clip(x[0::3], 0, 1)\n            x[1::3] = np.clip(x[1::3], 0, 1)\n            x[2::3] = np.clip(x[2::3], 0, 0.5)\n            return x\n\n    # Constraints for SLSQP\n    cons = {'type': 'ineq', 'fun': constraint_fn}\n    # Bounds for x, y, r\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    # Minimizer arguments for Basin-Hopping\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'constraints': cons,\n        'bounds': bounds,\n        'options': {'maxiter': 75}\n    }\n\n    best_v = None\n    best_sum = -1\n\n    # Multi-start approach: 10 different seeds (5 hexagonal, 5 random)\n    for i in range(10):\n        # Stop if we are nearing the 300s limit\n        if time.time() - start_time > 275:\n            break\n        \n        np.random.seed(i)\n        if i < 5:\n            # Perturbed Hexagonal grid initial configuration\n            points = []\n            rows, cols = 5, 6\n            for r_idx in range(rows):\n                for c_idx in range(cols):\n                    # Skip some positions to fit exactly 26 circles\n                    if (r_idx == 0 and c_idx == 0) or (r_idx == 0 and c_idx == 5) or \\\n                       (r_idx == 4 and c_idx == 0) or (r_idx == 4 and c_idx == 5):\n                        continue\n                    if len(points) < N:\n                        # Map to roughly [0.1, 0.9]\n                        px = (c_idx + 0.5 + (0.2 if r_idx % 2 == 1 else 0)) / 6.5\n                        py = (r_idx + 0.5) / 5.5\n                        points.append([px, py])\n            v0 = np.empty(3 * N)\n            points_arr = np.array(points)\n            v0[0::3] = points_arr[:, 0]\n            v0[1::3] = points_arr[:, 1]\n            v0[2::3] = 0.08  # Initial radius guess\n            # Add small noise to coordinates\n            v0[0::3] += np.random.uniform(-0.01, 0.01, N)\n            v0[1::3] += np.random.uniform(-0.01, 0.01, N)\n        else:\n            # Random distribution initial configuration\n            v0 = np.empty(3 * N)\n            v0[0::3] = np.random.uniform(0.1, 0.9, N)\n            v0[1::3] = np.random.uniform(0.1, 0.9, N)\n            v0[2::3] = 0.05\n\n        # Run Basin-Hopping with a limited number of iterations\n        res = basinhopping(\n            objective, \n            v0, \n            niter=1, \n            minimizer_kwargs=minimizer_kwargs, \n            take_step=MyTakeStep(0.02), \n            T=0.1\n        )\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    if best_v is None:\n        return np.zeros((N, 2)), np.zeros(N), 0.0\n\n    # Final post-processing to ensure the solution is strictly feasible\n    x_final, y_final, r_final = best_v[0::3], best_v[1::3], best_v[2::3]\n    \n    # 1. Enforce boundary constraints\n    for i in range(N):\n        r_final[i] = min(r_final[i], x_final[i], 1.0 - x_final[i], y_final[i], 1.0 - y_final[i])\n    \n    # 2. Iteratively enforce overlap constraints (shrink radii if necessary)\n    for _ in range(30):\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.sqrt((x_final[i] - x_final[j])**2 + (y_final[i] - y_final[j])**2)\n                if r_final[i] + r_final[j] > dist:\n                    overlap = (r_final[i] + r_final[j] - dist)\n                    # Shrink both radii equally to resolve overlap\n                    r_final[i] -= overlap / 2.0 + 1e-13\n                    r_final[j] -= overlap / 2.0 + 1e-13\n    \n    r_final = np.maximum(r_final, 0)\n    centers = np.vstack([x_final, y_final]).T\n    sum_radii = np.sum(r_final)\n    \n    return centers, r_final, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:08:31.340124",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 386,
        "candidates_token_count": 1739,
        "thoughts_token_count": 17935
      },
      "response_text_len": 4932
    }
  },
  "llm_call_duration_s": 107.21421263203956,
  "eval_duration_s": 1.2309573949314654
}