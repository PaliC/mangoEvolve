{
  "trial_id": "trial_5_5",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'Growth Simulation' to initialize circle positions and radii, \n    followed by SLSQP refinement to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    def constraints_vect(vars):\n        \"\"\"Vectorized constraints for SLSQP.\"\"\"\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        \n        # Boundary constraints: x - r >= 0, 1 - x - r >= 0, etc.\n        # These ensure the circle is entirely within the unit square [0,1]x[0,1].\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        \n        # Non-overlap constraints: distance(i, j) >= r_i + r_j\n        i, j = np.triu_indices(n, k=1)\n        dist_sq = (x[i] - x[j])**2 + (y[i] - y[j])**2\n        # Adding a tiny epsilon to prevent NaN gradients in sqrt at distance 0\n        dist = np.sqrt(dist_sq + 1e-12)\n        o_cons = dist - (r[i] + r[j])\n        \n        return np.concatenate([b_cons, o_cons])\n\n    def objective(vars):\n        \"\"\"Objective function: maximize sum of radii (minimize negative sum).\"\"\"\n        return -np.sum(vars[2::3])\n\n    def growth_simulation(n, steps=400):\n        \"\"\"\n        Initializes circle centers randomly and grows their radii.\n        Growth rates are proportional to the distance to the nearest neighbor.\n        A simple repulsion force resolves overlaps during growth.\n        \"\"\"\n        centers = np.random.rand(n, 2) * 0.8 + 0.1\n        radii = np.zeros(n)\n        \n        for _ in range(steps):\n            # Calculate growth rates based on proximity to other circles or boundaries\n            rates = np.zeros(n)\n            for i in range(n):\n                d_nn = 1.0\n                for j in range(n):\n                    if i == j: continue\n                    d = np.sqrt(np.sum((centers[i] - centers[j])**2)) - radii[j]\n                    if d < d_nn: d_nn = d\n                d_b = min(centers[i, 0], 1-centers[i, 0], centers[i, 1], 1-centers[i, 1])\n                d_nn = min(d_nn, d_b)\n                \n                # Growth rate proportional to distance to obstacle\n                rates[i] = max(0.0001, (d_nn - radii[i]) * 0.1)\n            \n            radii += rates\n            \n            # Physics-like step to resolve overlaps and boundary violations\n            for _ in range(5):\n                for i in range(n):\n                    for j in range(i + 1, n):\n                        d_vec = centers[i] - centers[j]\n                        dist = np.sqrt(np.sum(d_vec**2))\n                        if dist < radii[i] + radii[j]:\n                            overlap = (radii[i] + radii[j] - dist)\n                            force = overlap / (dist + 1e-9)\n                            centers[i] += 0.5 * force * d_vec\n                            centers[j] -= 0.5 * force * d_vec\n                    \n                    centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                    centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n                    \n        return centers, radii\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Trial 1: Grid-based initialization\n    # Start with a 5x5 grid and add one extra circle to reach 26.\n    xs = np.linspace(0.1, 0.9, 5)\n    ys = np.linspace(0.1, 0.9, 5)\n    gx, gy = np.meshgrid(xs, ys)\n    c_x = gx.flatten()\n    c_y = gy.flatten()\n    c_x = np.append(c_x, 0.95)\n    c_y = np.append(c_y, 0.95)\n    r_init = np.ones(n) * 0.05\n    \n    x0_grid = np.zeros(3 * n)\n    x0_grid[0::3], x0_grid[1::3], x0_grid[2::3] = c_x, c_y, r_init\n    \n    res = minimize(objective, x0_grid, method='SLSQP', \n                   constraints={'type': 'ineq', 'fun': constraints_vect},\n                   bounds=[(0, 1)] * (3 * n),\n                   options={'maxiter': 300})\n    \n    if -res.fun > best_sum:\n        best_sum = -res.fun\n        best_centers = np.column_stack((res.x[0::3], res.x[1::3]))\n        best_radii = res.x[2::3]\n\n    # Additional Trials: Growth-simulation-based initializations\n    # This explores different topologies to find a better local maximum.\n    for _ in range(4):\n        c, r = growth_simulation(n)\n        x0 = np.zeros(3 * n)\n        x0[0::3], x0[1::3], x0[2::3] = c[:, 0], c[:, 1], r\n        \n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints_vect},\n                       bounds=[(0, 1)] * (3 * n),\n                       options={'maxiter': 300})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = np.column_stack((res.x[0::3], res.x[1::3]))\n            best_radii = res.x[2::3]\n\n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6105414943147967,
    "eval_time": 37.0683434009552,
    "error": null
  },
  "prompt": "Implement a 'Growth' simulation.\n        1. Start with 26 points (random or grid).\n        2. Set initial radii to 0.\n        3. Gradually increase radii at different rates (e.g., proportional to the distance to the nearest neighbor).\n        4. When two circles touch, they exert a repulsive force on each other.\n        5. Use a very small step size for the simulation.\n        6. After the growth phase stabilizes, run SLSQP to polish the result.\n        This often finds different topologies than standard force-directed methods.\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'Growth Simulation' to initialize circle positions and radii, \n    followed by SLSQP refinement to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    def constraints_vect(vars):\n        \"\"\"Vectorized constraints for SLSQP.\"\"\"\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        \n        # Boundary constraints: x - r >= 0, 1 - x - r >= 0, etc.\n        # These ensure the circle is entirely within the unit square [0,1]x[0,1].\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        \n        # Non-overlap constraints: distance(i, j) >= r_i + r_j\n        i, j = np.triu_indices(n, k=1)\n        dist_sq = (x[i] - x[j])**2 + (y[i] - y[j])**2\n        # Adding a tiny epsilon to prevent NaN gradients in sqrt at distance 0\n        dist = np.sqrt(dist_sq + 1e-12)\n        o_cons = dist - (r[i] + r[j])\n        \n        return np.concatenate([b_cons, o_cons])\n\n    def objective(vars):\n        \"\"\"Objective function: maximize sum of radii (minimize negative sum).\"\"\"\n        return -np.sum(vars[2::3])\n\n    def growth_simulation(n, steps=400):\n        \"\"\"\n        Initializes circle centers randomly and grows their radii.\n        Growth rates are proportional to the distance to the nearest neighbor.\n        A simple repulsion force resolves overlaps during growth.\n        \"\"\"\n        centers = np.random.rand(n, 2) * 0.8 + 0.1\n        radii = np.zeros(n)\n        \n        for _ in range(steps):\n            # Calculate growth rates based on proximity to other circles or boundaries\n            rates = np.zeros(n)\n            for i in range(n):\n                d_nn = 1.0\n                for j in range(n):\n                    if i == j: continue\n                    d = np.sqrt(np.sum((centers[i] - centers[j])**2)) - radii[j]\n                    if d < d_nn: d_nn = d\n                d_b = min(centers[i, 0], 1-centers[i, 0], centers[i, 1], 1-centers[i, 1])\n                d_nn = min(d_nn, d_b)\n                \n                # Growth rate proportional to distance to obstacle\n                rates[i] = max(0.0001, (d_nn - radii[i]) * 0.1)\n            \n            radii += rates\n            \n            # Physics-like step to resolve overlaps and boundary violations\n            for _ in range(5):\n                for i in range(n):\n                    for j in range(i + 1, n):\n                        d_vec = centers[i] - centers[j]\n                        dist = np.sqrt(np.sum(d_vec**2))\n                        if dist < radii[i] + radii[j]:\n                            overlap = (radii[i] + radii[j] - dist)\n                            force = overlap / (dist + 1e-9)\n                            centers[i] += 0.5 * force * d_vec\n                            centers[j] -= 0.5 * force * d_vec\n                    \n                    centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                    centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n                    \n        return centers, radii\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Trial 1: Grid-based initialization\n    # Start with a 5x5 grid and add one extra circle to reach 26.\n    xs = np.linspace(0.1, 0.9, 5)\n    ys = np.linspace(0.1, 0.9, 5)\n    gx, gy = np.meshgrid(xs, ys)\n    c_x = gx.flatten()\n    c_y = gy.flatten()\n    c_x = np.append(c_x, 0.95)\n    c_y = np.append(c_y, 0.95)\n    r_init = np.ones(n) * 0.05\n    \n    x0_grid = np.zeros(3 * n)\n    x0_grid[0::3], x0_grid[1::3], x0_grid[2::3] = c_x, c_y, r_init\n    \n    res = minimize(objective, x0_grid, method='SLSQP', \n                   constraints={'type': 'ineq', 'fun': constraints_vect},\n                   bounds=[(0, 1)] * (3 * n),\n                   options={'maxiter': 300})\n    \n    if -res.fun > best_sum:\n        best_sum = -res.fun\n        best_centers = np.column_stack((res.x[0::3], res.x[1::3]))\n        best_radii = res.x[2::3]\n\n    # Additional Trials: Growth-simulation-based initializations\n    # This explores different topologies to find a better local maximum.\n    for _ in range(4):\n        c, r = growth_simulation(n)\n        x0 = np.zeros(3 * n)\n        x0[0::3], x0[1::3], x0[2::3] = c[:, 0], c[:, 1], r\n        \n        res = minimize(objective, x0, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints_vect},\n                       bounds=[(0, 1)] * (3 * n),\n                       options={'maxiter': 300})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = np.column_stack((res.x[0::3], res.x[1::3]))\n            best_radii = res.x[2::3]\n\n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:32:11.958929",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 351,
        "candidates_token_count": 1611,
        "thoughts_token_count": 19553
      },
      "response_text_len": 4919
    }
  },
  "llm_call_duration_s": 125.23338822601363,
  "eval_duration_s": 37.06835380999837
}