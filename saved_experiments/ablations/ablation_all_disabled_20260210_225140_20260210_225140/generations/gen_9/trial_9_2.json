{
  "trial_id": "trial_9_2",
  "generation": 9,
  "parent_id": "trial_6_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a force-directed model for initial center placement and then SLSQP optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n\n    def get_initial_centers(N):\n        # Force-directed model to spread centers\n        centers = np.random.rand(N, 2) * 0.7 + 0.15\n        for _ in range(200):\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists_sq = np.sum(diffs**2, axis=2)\n            np.fill_diagonal(dists_sq, 1.0)\n            \n            # Repulsive force inversely proportional to distance\n            f_points = diffs / (dists_sq[:, :, np.newaxis] + 1e-8)\n            f_total = np.sum(f_points, axis=1) * 0.01\n            \n            # Boundary forces\n            f_total[:, 0] += 0.01 / (centers[:, 0] + 1e-8)\n            f_total[:, 0] -= 0.01 / (1 - centers[:, 0] + 1e-8)\n            f_total[:, 1] += 0.01 / (centers[:, 1] + 1e-8)\n            f_total[:, 1] -= 0.01 / (1 - centers[:, 1] + 1e-8)\n            \n            # Limit force magnitude to keep simulation stable\n            mag = np.linalg.norm(f_total, axis=1, keepdims=True)\n            f_total = f_total / (mag + 1) * np.minimum(mag, 0.05)\n            \n            centers += f_total\n            centers = np.clip(centers, 0.01, 0.99)\n        return centers\n\n    def obj(v, N):\n        # Maximize sum(r) -> Minimize -sum(r)\n        return -np.sum(v[2::3])\n\n    def obj_jac(v, N):\n        grad = np.zeros(3 * N)\n        grad[2::3] = -1.0\n        return grad\n\n    def cons_f(v, N):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, etc.\n        c_b = np.zeros(4 * N)\n        c_b[0::4] = x - r\n        c_b[1::4] = 1 - x - r\n        c_b[2::4] = y - r\n        c_b[3::4] = 1 - y - r\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        c_o = np.zeros(N * (N - 1) // 2)\n        idx = 0\n        for i in range(N):\n            num = N - 1 - i\n            if num == 0: continue\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            dr = r[i] + r[i+1:]\n            c_o[idx:idx+num] = dx**2 + dy**2 - dr**2\n            idx += num\n        \n        return np.concatenate([c_b, c_o])\n\n    def cons_jac(v, N):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        \n        jac_b = np.zeros((4 * N, 3 * N))\n        for i in range(N):\n            jac_b[4*i, 3*i] = 1; jac_b[4*i, 3*i+2] = -1\n            jac_b[4*i+1, 3*i] = -1; jac_b[4*i+1, 3*i+2] = -1\n            jac_b[4*i+2, 3*i+1] = 1; jac_b[4*i+2, 3*i+2] = -1\n            jac_b[4*i+3, 3*i+1] = -1; jac_b[4*i+3, 3*i+2] = -1\n            \n        jac_o = np.zeros((N * (N - 1) // 2, 3 * N))\n        idx = 0\n        for i in range(N):\n            num = N - 1 - i\n            if num == 0: continue\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            dr = r[i] + r[i+1:]\n            \n            rows = np.arange(idx, idx + num)\n            jac_o[rows, 3*i] = 2 * dx\n            jac_o[rows, 3*i+1] = 2 * dy\n            jac_o[rows, 3*i+2] = -2 * dr\n            \n            actual_js = np.arange(i + 1, N)\n            jac_o[rows, 3*actual_js] = -2 * dx\n            jac_o[rows, 3*actual_js+1] = -2 * dy\n            jac_o[rows, 3*actual_js+2] = -2 * dr\n            idx += num\n            \n        return np.concatenate([jac_b, jac_o])\n\n    def fix_solution(v, N):\n        if v is None: return None\n        x, y, r = v[0::3], v[1::3], v[2::3].copy()\n        v_max = 0\n        for i in range(N):\n            v_max = max(v_max, r[i] - x[i], x[i] + r[i] - 1, r[i] - y[i], y[i] + r[i] - 1)\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            dr = r[i] + r[i+1:]\n            if len(dr) > 0:\n                d = np.sqrt(dx**2 + dy**2)\n                v_max = max(v_max, np.max(dr - d))\n        if v_max > 0:\n            r -= (v_max + 1e-12)\n        r = np.maximum(r, 0)\n        v_fixed = v.copy()\n        v_fixed[2::3] = r\n        return v_fixed\n\n    best_v = None\n    best_sum = -1\n\n    # Run multiple random initializations\n    num_starts = 10\n    for i in range(num_starts):\n        if time.time() - start_time > 260:\n            break\n        \n        centers = get_initial_centers(N)\n        # Mix of constant and randomized initial radii to help search\n        if i < 5:\n            r_init = 0.07 + i * 0.01\n        else:\n            r_init = 0.06 + 0.06 * np.random.rand(N)\n            \n        v_init = np.zeros(3 * N)\n        v_init[0::3] = centers[:, 0]\n        v_init[1::3] = centers[:, 1]\n        v_init[2::3] = r_init\n        \n        res = minimize(\n            obj, v_init, args=(N,), method='SLSQP',\n            jac=obj_jac,\n            constraints=[{'type': 'ineq', 'fun': cons_f, 'jac': cons_jac, 'args': (N,)}],\n            bounds=[(0, 1), (0, 1), (0, 0.5)] * N,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # Ensure best_v is set\n    if best_v is None:\n        best_v = v_init\n\n    # Final feasibility fix\n    best_v = fix_solution(best_v, N)\n    \n    centers = best_v.reshape(N, 3)[:, :2]\n    radii = best_v.reshape(N, 3)[:, 2]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 0.0,
    "eval_time": 52.25327396392822,
    "error": null
  },
  "prompt": "\nThe best score is 2.6359830849175854. Try a different approach:\n1. Use a force-directed (repulsive) model to spread 26 circles within the unit square. \n   - Repulsive force between circles inversely proportional to distance.\n   - Boundary forces to keep them inside.\n2. After the force-directed simulation stabilizes, take the centers and use them as the initial guess for scipy.optimize.minimize (method='SLSQP').\n3. Maximize the sum of radii subject to non-overlap and boundary constraints.\n4. Run this with 5 different random initializations and return the best one.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a force-directed model for initial center placement and then SLSQP optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n\n    def get_initial_centers(N):\n        # Force-directed model to spread centers\n        centers = np.random.rand(N, 2) * 0.7 + 0.15\n        for _ in range(200):\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists_sq = np.sum(diffs**2, axis=2)\n            np.fill_diagonal(dists_sq, 1.0)\n            \n            # Repulsive force inversely proportional to distance\n            f_points = diffs / (dists_sq[:, :, np.newaxis] + 1e-8)\n            f_total = np.sum(f_points, axis=1) * 0.01\n            \n            # Boundary forces\n            f_total[:, 0] += 0.01 / (centers[:, 0] + 1e-8)\n            f_total[:, 0] -= 0.01 / (1 - centers[:, 0] + 1e-8)\n            f_total[:, 1] += 0.01 / (centers[:, 1] + 1e-8)\n            f_total[:, 1] -= 0.01 / (1 - centers[:, 1] + 1e-8)\n            \n            # Limit force magnitude to keep simulation stable\n            mag = np.linalg.norm(f_total, axis=1, keepdims=True)\n            f_total = f_total / (mag + 1) * np.minimum(mag, 0.05)\n            \n            centers += f_total\n            centers = np.clip(centers, 0.01, 0.99)\n        return centers\n\n    def obj(v, N):\n        # Maximize sum(r) -> Minimize -sum(r)\n        return -np.sum(v[2::3])\n\n    def obj_jac(v, N):\n        grad = np.zeros(3 * N)\n        grad[2::3] = -1.0\n        return grad\n\n    def cons_f(v, N):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, etc.\n        c_b = np.zeros(4 * N)\n        c_b[0::4] = x - r\n        c_b[1::4] = 1 - x - r\n        c_b[2::4] = y - r\n        c_b[3::4] = 1 - y - r\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        c_o = np.zeros(N * (N - 1) // 2)\n        idx = 0\n        for i in range(N):\n            num = N - 1 - i\n            if num == 0: continue\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            dr = r[i] + r[i+1:]\n            c_o[idx:idx+num] = dx**2 + dy**2 - dr**2\n            idx += num\n        \n        return np.concatenate([c_b, c_o])\n\n    def cons_jac(v, N):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        \n        jac_b = np.zeros((4 * N, 3 * N))\n        for i in range(N):\n            jac_b[4*i, 3*i] = 1; jac_b[4*i, 3*i+2] = -1\n            jac_b[4*i+1, 3*i] = -1; jac_b[4*i+1, 3*i+2] = -1\n            jac_b[4*i+2, 3*i+1] = 1; jac_b[4*i+2, 3*i+2] = -1\n            jac_b[4*i+3, 3*i+1] = -1; jac_b[4*i+3, 3*i+2] = -1\n            \n        jac_o = np.zeros((N * (N - 1) // 2, 3 * N))\n        idx = 0\n        for i in range(N):\n            num = N - 1 - i\n            if num == 0: continue\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            dr = r[i] + r[i+1:]\n            \n            rows = np.arange(idx, idx + num)\n            jac_o[rows, 3*i] = 2 * dx\n            jac_o[rows, 3*i+1] = 2 * dy\n            jac_o[rows, 3*i+2] = -2 * dr\n            \n            actual_js = np.arange(i + 1, N)\n            jac_o[rows, 3*actual_js] = -2 * dx\n            jac_o[rows, 3*actual_js+1] = -2 * dy\n            jac_o[rows, 3*actual_js+2] = -2 * dr\n            idx += num\n            \n        return np.concatenate([jac_b, jac_o])\n\n    def fix_solution(v, N):\n        if v is None: return None\n        x, y, r = v[0::3], v[1::3], v[2::3].copy()\n        v_max = 0\n        for i in range(N):\n            v_max = max(v_max, r[i] - x[i], x[i] + r[i] - 1, r[i] - y[i], y[i] + r[i] - 1)\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            dr = r[i] + r[i+1:]\n            if len(dr) > 0:\n                d = np.sqrt(dx**2 + dy**2)\n                v_max = max(v_max, np.max(dr - d))\n        if v_max > 0:\n            r -= (v_max + 1e-12)\n        r = np.maximum(r, 0)\n        v_fixed = v.copy()\n        v_fixed[2::3] = r\n        return v_fixed\n\n    best_v = None\n    best_sum = -1\n\n    # Run multiple random initializations\n    num_starts = 10\n    for i in range(num_starts):\n        if time.time() - start_time > 260:\n            break\n        \n        centers = get_initial_centers(N)\n        # Mix of constant and randomized initial radii to help search\n        if i < 5:\n            r_init = 0.07 + i * 0.01\n        else:\n            r_init = 0.06 + 0.06 * np.random.rand(N)\n            \n        v_init = np.zeros(3 * N)\n        v_init[0::3] = centers[:, 0]\n        v_init[1::3] = centers[:, 1]\n        v_init[2::3] = r_init\n        \n        res = minimize(\n            obj, v_init, args=(N,), method='SLSQP',\n            jac=obj_jac,\n            constraints=[{'type': 'ineq', 'fun': cons_f, 'jac': cons_jac, 'args': (N,)}],\n            bounds=[(0, 1), (0, 1), (0, 0.5)] * N,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # Ensure best_v is set\n    if best_v is None:\n        best_v = v_init\n\n    # Final feasibility fix\n    best_v = fix_solution(best_v, N)\n    \n    centers = best_v.reshape(N, 3)[:, :2]\n    radii = best_v.reshape(N, 3)[:, 2]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:01:27.149417",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 377,
        "candidates_token_count": 2179,
        "thoughts_token_count": 20423
      },
      "response_text_len": 5440
    }
  },
  "llm_call_duration_s": 131.47890104097314,
  "eval_duration_s": 52.2532842051005
}