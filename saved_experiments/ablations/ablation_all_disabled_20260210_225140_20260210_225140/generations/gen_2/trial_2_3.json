{
  "trial_id": "trial_2_3",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii.\n    Algorithm:\n    1. Greedy placement: Circles are added one by one. For each circle, its position\n       is chosen to maximize its radius given the previously placed circles.\n    2. Global optimization: A refined optimization using SLSQP to maximize the total sum of radii.\n    \"\"\"\n    N = 26\n    \n    def calculate_r(x, y, existing):\n        \"\"\"Calculates the maximum possible radius for a circle at (x, y).\"\"\"\n        r = min(x, 1 - x, y, 1 - y)\n        for ex, ey, er in existing:\n            dist = np.sqrt((x - ex)**2 + (y - ey)**2)\n            r = min(r, dist - er)\n        return max(0, r)\n\n    def greedy_obj(p, existing):\n        \"\"\"Objective function for the greedy refinement step (maximizing radius).\"\"\"\n        x, y = p\n        if x < 0 or x > 1 or y < 0 or y > 1:\n            return 1e9\n        r = min(x, 1 - x, y, 1 - y)\n        for ex, ey, er in existing:\n            dist = np.sqrt((x - ex)**2 + (y - ey)**2)\n            r = min(r, dist - er)\n        return -r\n\n    centers_greedy = []\n    radii_greedy = []\n    \n    # Grid for initial points to find a good starting position for each greedy step\n    grid_size = 60\n    gx, gy = np.meshgrid(np.linspace(0, 1, grid_size), np.linspace(0, 1, grid_size))\n    grid_points = np.stack([gx.ravel(), gy.ravel()], axis=1)\n\n    for i in range(N):\n        # Initial search on grid\n        r_grid = np.minimum(np.minimum(grid_points[:, 0], 1 - grid_points[:, 0]),\n                            np.minimum(grid_points[:, 1], 1 - grid_points[:, 1]))\n        for j in range(i):\n            ex, ey = centers_greedy[j]\n            er = radii_greedy[j]\n            dist = np.sqrt((grid_points[:, 0] - ex)**2 + (grid_points[:, 1] - ey)**2)\n            r_grid = np.minimum(r_grid, dist - er)\n        \n        best_idx = np.argmax(r_grid)\n        best_pos = grid_points[best_idx]\n        \n        # Refine the position using Nelder-Mead to find the local maximum radius\n        existing = list(zip([c[0] for c in centers_greedy], [c[1] for c in centers_greedy], radii_greedy))\n        res_refine = minimize(greedy_obj, best_pos, args=(existing,), method='Nelder-Mead', tol=1e-6)\n        \n        refined_pos = res_refine.x\n        refined_r = calculate_r(refined_pos[0], refined_pos[1], existing)\n        \n        centers_greedy.append(refined_pos)\n        radii_greedy.append(refined_r)\n    \n    # Prepare initial guess for global optimization: [x0, y0, r0, x1, y1, r1, ...]\n    x0 = np.zeros(3 * N)\n    for i in range(N):\n        x0[3*i] = centers_greedy[i][0]\n        x0[3*i+1] = centers_greedy[i][1]\n        x0[3*i+2] = radii_greedy[i]\n        \n    def objective(x):\n        \"\"\"Objective function: Minimize the negative sum of radii.\"\"\"\n        return -np.sum(x[2::3])\n    \n    def objective_jac(x):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        jac = np.zeros(3 * N)\n        jac[2::3] = -1.0\n        return jac\n    \n    def all_constraints(x):\n        \"\"\"Boundary and no-overlap constraints.\"\"\"\n        res = np.zeros(4 * N + (N * (N - 1)) // 2)\n        xi = x[0::3]\n        yi = x[1::3]\n        ri = x[2::3]\n        \n        for i in range(N):\n            res[4*i] = xi[i] - ri[i]\n            res[4*i+1] = 1 - xi[i] - ri[i]\n            res[4*i+2] = yi[i] - ri[i]\n            res[4*i+3] = 1 - yi[i] - ri[i]\n        \n        idx = 4 * N\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.sqrt((xi[i] - xi[j])**2 + (yi[i] - yi[j])**2)\n                res[idx] = dist - (ri[i] + ri[j])\n                idx += 1\n        return res\n    \n    def all_constraints_jac(x):\n        \"\"\"Jacobian of all constraints.\"\"\"\n        num_dist_constraints = (N * (N - 1)) // 2\n        jac = np.zeros((4 * N + num_dist_constraints, 3 * N))\n        xi = x[0::3]\n        yi = x[1::3]\n        ri = x[2::3]\n        \n        for i in range(N):\n            jac[4*i, 3*i] = 1\n            jac[4*i, 3*i+2] = -1\n            jac[4*i+1, 3*i] = -1\n            jac[4*i+1, 3*i+2] = -1\n            jac[4*i+2, 3*i+1] = 1\n            jac[4*i+2, 3*i+2] = -1\n            jac[4*i+3, 3*i+1] = -1\n            jac[4*i+3, 3*i+2] = -1\n        \n        idx = 4 * N\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = xi[i] - xi[j]\n                dy = yi[i] - yi[j]\n                dist = np.sqrt(dx**2 + dy**2) + 1e-10\n                jac[idx, 3*i] = dx / dist\n                jac[idx, 3*i+1] = dy / dist\n                jac[idx, 3*i+2] = -1\n                jac[idx, 3*j] = -dx / dist\n                jac[idx, 3*j+1] = -dy / dist\n                jac[idx, 3*j+2] = -1\n                idx += 1\n        return jac\n    \n    # Variable bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = []\n    for _ in range(N):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n        \n    # Run global optimization using SLSQP\n    res = minimize(objective, x0, method='SLSQP', jac=objective_jac,\n                   constraints={'type': 'ineq', 'fun': all_constraints, 'jac': all_constraints_jac},\n                   bounds=bounds, options={'maxiter': 1000, 'ftol': 1e-8})\n    \n    final_x = res.x\n    centers = final_x.reshape(N, 3)[:, 0:2]\n    radii = np.maximum(0, final_x.reshape(N, 3)[:, 2])\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.4995907881255994,
    "eval_time": 0.8842878341674805,
    "error": null
  },
  "prompt": "Design an algorithm that places 26 circles one by one into the unit square. For each new circle, find the position that allows for the largest possible radius given the existing circles. After all 26 are placed, run a global optimization using scipy.optimize.minimize to maximize the sum of all radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii.\n    Algorithm:\n    1. Greedy placement: Circles are added one by one. For each circle, its position\n       is chosen to maximize its radius given the previously placed circles.\n    2. Global optimization: A refined optimization using SLSQP to maximize the total sum of radii.\n    \"\"\"\n    N = 26\n    \n    def calculate_r(x, y, existing):\n        \"\"\"Calculates the maximum possible radius for a circle at (x, y).\"\"\"\n        r = min(x, 1 - x, y, 1 - y)\n        for ex, ey, er in existing:\n            dist = np.sqrt((x - ex)**2 + (y - ey)**2)\n            r = min(r, dist - er)\n        return max(0, r)\n\n    def greedy_obj(p, existing):\n        \"\"\"Objective function for the greedy refinement step (maximizing radius).\"\"\"\n        x, y = p\n        if x < 0 or x > 1 or y < 0 or y > 1:\n            return 1e9\n        r = min(x, 1 - x, y, 1 - y)\n        for ex, ey, er in existing:\n            dist = np.sqrt((x - ex)**2 + (y - ey)**2)\n            r = min(r, dist - er)\n        return -r\n\n    centers_greedy = []\n    radii_greedy = []\n    \n    # Grid for initial points to find a good starting position for each greedy step\n    grid_size = 60\n    gx, gy = np.meshgrid(np.linspace(0, 1, grid_size), np.linspace(0, 1, grid_size))\n    grid_points = np.stack([gx.ravel(), gy.ravel()], axis=1)\n\n    for i in range(N):\n        # Initial search on grid\n        r_grid = np.minimum(np.minimum(grid_points[:, 0], 1 - grid_points[:, 0]),\n                            np.minimum(grid_points[:, 1], 1 - grid_points[:, 1]))\n        for j in range(i):\n            ex, ey = centers_greedy[j]\n            er = radii_greedy[j]\n            dist = np.sqrt((grid_points[:, 0] - ex)**2 + (grid_points[:, 1] - ey)**2)\n            r_grid = np.minimum(r_grid, dist - er)\n        \n        best_idx = np.argmax(r_grid)\n        best_pos = grid_points[best_idx]\n        \n        # Refine the position using Nelder-Mead to find the local maximum radius\n        existing = list(zip([c[0] for c in centers_greedy], [c[1] for c in centers_greedy], radii_greedy))\n        res_refine = minimize(greedy_obj, best_pos, args=(existing,), method='Nelder-Mead', tol=1e-6)\n        \n        refined_pos = res_refine.x\n        refined_r = calculate_r(refined_pos[0], refined_pos[1], existing)\n        \n        centers_greedy.append(refined_pos)\n        radii_greedy.append(refined_r)\n    \n    # Prepare initial guess for global optimization: [x0, y0, r0, x1, y1, r1, ...]\n    x0 = np.zeros(3 * N)\n    for i in range(N):\n        x0[3*i] = centers_greedy[i][0]\n        x0[3*i+1] = centers_greedy[i][1]\n        x0[3*i+2] = radii_greedy[i]\n        \n    def objective(x):\n        \"\"\"Objective function: Minimize the negative sum of radii.\"\"\"\n        return -np.sum(x[2::3])\n    \n    def objective_jac(x):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        jac = np.zeros(3 * N)\n        jac[2::3] = -1.0\n        return jac\n    \n    def all_constraints(x):\n        \"\"\"Boundary and no-overlap constraints.\"\"\"\n        res = np.zeros(4 * N + (N * (N - 1)) // 2)\n        xi = x[0::3]\n        yi = x[1::3]\n        ri = x[2::3]\n        \n        for i in range(N):\n            res[4*i] = xi[i] - ri[i]\n            res[4*i+1] = 1 - xi[i] - ri[i]\n            res[4*i+2] = yi[i] - ri[i]\n            res[4*i+3] = 1 - yi[i] - ri[i]\n        \n        idx = 4 * N\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.sqrt((xi[i] - xi[j])**2 + (yi[i] - yi[j])**2)\n                res[idx] = dist - (ri[i] + ri[j])\n                idx += 1\n        return res\n    \n    def all_constraints_jac(x):\n        \"\"\"Jacobian of all constraints.\"\"\"\n        num_dist_constraints = (N * (N - 1)) // 2\n        jac = np.zeros((4 * N + num_dist_constraints, 3 * N))\n        xi = x[0::3]\n        yi = x[1::3]\n        ri = x[2::3]\n        \n        for i in range(N):\n            jac[4*i, 3*i] = 1\n            jac[4*i, 3*i+2] = -1\n            jac[4*i+1, 3*i] = -1\n            jac[4*i+1, 3*i+2] = -1\n            jac[4*i+2, 3*i+1] = 1\n            jac[4*i+2, 3*i+2] = -1\n            jac[4*i+3, 3*i+1] = -1\n            jac[4*i+3, 3*i+2] = -1\n        \n        idx = 4 * N\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = xi[i] - xi[j]\n                dy = yi[i] - yi[j]\n                dist = np.sqrt(dx**2 + dy**2) + 1e-10\n                jac[idx, 3*i] = dx / dist\n                jac[idx, 3*i+1] = dy / dist\n                jac[idx, 3*i+2] = -1\n                jac[idx, 3*j] = -dx / dist\n                jac[idx, 3*j+1] = -dy / dist\n                jac[idx, 3*j+2] = -1\n                idx += 1\n        return jac\n    \n    # Variable bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = []\n    for _ in range(N):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n        \n    # Run global optimization using SLSQP\n    res = minimize(objective, x0, method='SLSQP', jac=objective_jac,\n                   constraints={'type': 'ineq', 'fun': all_constraints, 'jac': all_constraints_jac},\n                   bounds=bounds, options={'maxiter': 1000, 'ftol': 1e-8})\n    \n    final_x = res.x\n    centers = final_x.reshape(N, 3)[:, 0:2]\n    radii = np.maximum(0, final_x.reshape(N, 3)[:, 2])\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:09:09.367035",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 291,
        "candidates_token_count": 1949,
        "thoughts_token_count": 23231
      },
      "response_text_len": 5425
    }
  },
  "llm_call_duration_s": 140.99110306391958,
  "eval_duration_s": 0.8842957160668448
}