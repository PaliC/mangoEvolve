{
  "trial_id": "trial_2_2",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import qmc\nfrom scipy.spatial.distance import pdist\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Sobol sequence for initialization and SLSQP for optimization.\n    \"\"\"\n    n = 26\n    # Precompute indices for vectorized operations\n    triu_indices = np.triu_indices(n, k=1)\n    i_idx, j_idx = triu_indices\n    row_idx_non_overlap = 104 + np.arange(325)\n    idx_n = np.arange(n)\n\n    def objective(vars):\n        # vars layout: [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n        # Sum of radii is to be maximized, so we minimize the negative sum.\n        radii = vars[2::3]\n        return -np.sum(radii)\n\n    def objective_jac(vars):\n        # Derivative of -sum(radii) with respect to all variables.\n        # x_i and y_i have derivative 0, r_i has derivative -1.\n        jac = np.zeros(3 * n)\n        jac[2::3] = -1.0\n        return jac\n\n    def constraints(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        \n        # 104 boundary constraints + 325 non-overlap constraints = 429 total.\n        res = np.zeros(104 + 325)\n        \n        # Boundary constraints: circles must stay inside [0, 1] x [0, 1]\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        res[0:26] = x - r\n        res[26:52] = 1.0 - x - r\n        res[52:78] = y - r\n        res[78:104] = 1.0 - y - r\n        \n        # Non-overlap constraints: dist(i, j) - (r_i + r_j) >= 0\n        coords = np.column_stack((x, y))\n        dists = pdist(coords)\n        r_sum = r[i_idx] + r[j_idx]\n        res[104:] = dists - r_sum\n        return res\n\n    def constraints_jac(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        \n        jac = np.zeros((429, 3 * n))\n        \n        # Boundary constraints derivatives\n        # x_i - r_i >= 0\n        jac[idx_n, 3 * idx_n] = 1.0\n        jac[idx_n, 3 * idx_n + 2] = -1.0\n        # 1 - x_i - r_i >= 0\n        jac[26 + idx_n, 3 * idx_n] = -1.0\n        jac[26 + idx_n, 3 * idx_n + 2] = -1.0\n        # y_i - r_i >= 0\n        jac[52 + idx_n, 3 * idx_n + 1] = 1.0\n        jac[52 + idx_n, 3 * idx_n + 2] = -1.0\n        # 1 - y_i - r_i >= 0\n        jac[78 + idx_n, 3 * idx_n + 1] = -1.0\n        jac[78 + idx_n, 3 * idx_n + 2] = -1.0\n        \n        # Non-overlap constraints derivatives\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dists = np.sqrt(dx**2 + dy**2)\n        # Avoid division by zero if centers overlap exactly\n        dists_safe = np.maximum(dists, 1e-12)\n        \n        # d/dxi(dist - r_sum) = dx/dist, d/dxj(dist - r_sum) = -dx/dist\n        jac[row_idx_non_overlap, 3 * i_idx] = dx / dists_safe\n        jac[row_idx_non_overlap, 3 * j_idx] = -dx / dists_safe\n        jac[row_idx_non_overlap, 3 * i_idx + 1] = dy / dists_safe\n        jac[row_idx_non_overlap, 3 * j_idx + 1] = -dy / dists_safe\n        # d/dri(dist - r_sum) = -1, d/drj(dist - r_sum) = -1\n        jac[row_idx_non_overlap, 3 * i_idx + 2] = -1.0\n        jac[row_idx_non_overlap, 3 * j_idx + 2] = -1.0\n        \n        return jac\n\n    best_sum = 0\n    best_vars = None\n    \n    # Try different Sobol seeds to explore different local maxima\n    seeds = [42, 123, 999, 555]\n    for seed in seeds:\n        # Sobol sequence for uniform distribution of circle centers\n        sampler = qmc.Sobol(d=2, scramble=True, seed=seed)\n        points = sampler.random(n=n)\n        \n        initial_vars = np.zeros(3 * n)\n        for i in range(n):\n            # Place centers initially away from the square boundaries\n            cx = 0.1 + 0.8 * points[i, 0]\n            cy = 0.1 + 0.8 * points[i, 1]\n            # Start with small radii to minimize initial overlap\n            initial_vars[3*i:3*i+3] = [cx, cy, 0.05]\n\n        # SLSQP optimization\n        res = minimize(\n            objective,\n            initial_vars,\n            method='SLSQP',\n            jac=objective_jac,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n            bounds=[(0, 1)] * (3 * n),\n            options={'maxiter': 1000, 'ftol': 1e-7}\n        )\n        \n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_vars = res.x\n            \n    # Final centers, radii, and sum\n    final_centers = best_vars.reshape(n, 3)[:, :2]\n    final_radii = best_vars.reshape(n, 3)[:, 2]\n    \n    return final_centers, final_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.596786098273724,
    "eval_time": 1.2307231426239014,
    "error": null
  },
  "prompt": "Use a Sobol sequence (from scipy.stats.qmc) to initialize the centers of 26 circles in a unit square. This provides a more uniform initial distribution than random sampling. Optimize the sum of radii using scipy.optimize.minimize with SLSQP, ensuring all 26 circles remain within the square and do not overlap.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import qmc\nfrom scipy.spatial.distance import pdist\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Sobol sequence for initialization and SLSQP for optimization.\n    \"\"\"\n    n = 26\n    # Precompute indices for vectorized operations\n    triu_indices = np.triu_indices(n, k=1)\n    i_idx, j_idx = triu_indices\n    row_idx_non_overlap = 104 + np.arange(325)\n    idx_n = np.arange(n)\n\n    def objective(vars):\n        # vars layout: [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n        # Sum of radii is to be maximized, so we minimize the negative sum.\n        radii = vars[2::3]\n        return -np.sum(radii)\n\n    def objective_jac(vars):\n        # Derivative of -sum(radii) with respect to all variables.\n        # x_i and y_i have derivative 0, r_i has derivative -1.\n        jac = np.zeros(3 * n)\n        jac[2::3] = -1.0\n        return jac\n\n    def constraints(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        \n        # 104 boundary constraints + 325 non-overlap constraints = 429 total.\n        res = np.zeros(104 + 325)\n        \n        # Boundary constraints: circles must stay inside [0, 1] x [0, 1]\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        res[0:26] = x - r\n        res[26:52] = 1.0 - x - r\n        res[52:78] = y - r\n        res[78:104] = 1.0 - y - r\n        \n        # Non-overlap constraints: dist(i, j) - (r_i + r_j) >= 0\n        coords = np.column_stack((x, y))\n        dists = pdist(coords)\n        r_sum = r[i_idx] + r[j_idx]\n        res[104:] = dists - r_sum\n        return res\n\n    def constraints_jac(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        \n        jac = np.zeros((429, 3 * n))\n        \n        # Boundary constraints derivatives\n        # x_i - r_i >= 0\n        jac[idx_n, 3 * idx_n] = 1.0\n        jac[idx_n, 3 * idx_n + 2] = -1.0\n        # 1 - x_i - r_i >= 0\n        jac[26 + idx_n, 3 * idx_n] = -1.0\n        jac[26 + idx_n, 3 * idx_n + 2] = -1.0\n        # y_i - r_i >= 0\n        jac[52 + idx_n, 3 * idx_n + 1] = 1.0\n        jac[52 + idx_n, 3 * idx_n + 2] = -1.0\n        # 1 - y_i - r_i >= 0\n        jac[78 + idx_n, 3 * idx_n + 1] = -1.0\n        jac[78 + idx_n, 3 * idx_n + 2] = -1.0\n        \n        # Non-overlap constraints derivatives\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dists = np.sqrt(dx**2 + dy**2)\n        # Avoid division by zero if centers overlap exactly\n        dists_safe = np.maximum(dists, 1e-12)\n        \n        # d/dxi(dist - r_sum) = dx/dist, d/dxj(dist - r_sum) = -dx/dist\n        jac[row_idx_non_overlap, 3 * i_idx] = dx / dists_safe\n        jac[row_idx_non_overlap, 3 * j_idx] = -dx / dists_safe\n        jac[row_idx_non_overlap, 3 * i_idx + 1] = dy / dists_safe\n        jac[row_idx_non_overlap, 3 * j_idx + 1] = -dy / dists_safe\n        # d/dri(dist - r_sum) = -1, d/drj(dist - r_sum) = -1\n        jac[row_idx_non_overlap, 3 * i_idx + 2] = -1.0\n        jac[row_idx_non_overlap, 3 * j_idx + 2] = -1.0\n        \n        return jac\n\n    best_sum = 0\n    best_vars = None\n    \n    # Try different Sobol seeds to explore different local maxima\n    seeds = [42, 123, 999, 555]\n    for seed in seeds:\n        # Sobol sequence for uniform distribution of circle centers\n        sampler = qmc.Sobol(d=2, scramble=True, seed=seed)\n        points = sampler.random(n=n)\n        \n        initial_vars = np.zeros(3 * n)\n        for i in range(n):\n            # Place centers initially away from the square boundaries\n            cx = 0.1 + 0.8 * points[i, 0]\n            cy = 0.1 + 0.8 * points[i, 1]\n            # Start with small radii to minimize initial overlap\n            initial_vars[3*i:3*i+3] = [cx, cy, 0.05]\n\n        # SLSQP optimization\n        res = minimize(\n            objective,\n            initial_vars,\n            method='SLSQP',\n            jac=objective_jac,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n            bounds=[(0, 1)] * (3 * n),\n            options={'maxiter': 1000, 'ftol': 1e-7}\n        )\n        \n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_vars = res.x\n            \n    # Final centers, radii, and sum\n    final_centers = best_vars.reshape(n, 3)[:, :2]\n    final_radii = best_vars.reshape(n, 3)[:, 2]\n    \n    return final_centers, final_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:08:57.379215",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 297,
        "candidates_token_count": 1743,
        "thoughts_token_count": 20173
      },
      "response_text_len": 4566
    }
  },
  "llm_call_duration_s": 128.65756939398125,
  "eval_duration_s": 1.2307295019272715
}