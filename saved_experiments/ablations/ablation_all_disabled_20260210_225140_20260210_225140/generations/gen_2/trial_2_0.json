{
  "trial_id": "trial_2_0",
  "generation": 2,
  "parent_id": "trial_0_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses basin-hopping with SLSQP as the local minimizer to find an optimal configuration.\n    \"\"\"\n    N = 26\n    # Indices for all unique pairs of circles for non-overlap constraints\n    triu_i, triu_j = np.triu_indices(N, k=1)\n    num_overlap_cons = len(triu_i)\n\n    def objective(v):\n        \"\"\"Negative sum of radii to be minimized.\"\"\"\n        return -np.sum(v[2*N:])\n\n    def objective_jac(v):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def constraints_fn(v):\n        \"\"\"\n        Hard constraints for the packing problem.\n        1. Boundary: Circles must be inside [0,1]x[0,1]\n        2. Non-overlap: Distance between any two centers must be at least the sum of their radii.\n        \"\"\"\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        # Total constraints: 4 per circle (boundary) + N(N-1)/2 (non-overlap)\n        c = np.empty(4*N + num_overlap_cons)\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        \n        # Non-overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = x[triu_i] - x[triu_j]\n        dy = y[triu_i] - y[triu_j]\n        dr = r[triu_i] + r[triu_j]\n        c[4*N:] = dx**2 + dy**2 - dr**2\n        return c\n\n    def constraints_jac(v):\n        \"\"\"Jacobian of the hard constraints.\"\"\"\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        jac = np.zeros((4*N + num_overlap_cons, 3*N))\n        \n        # Boundary gradients\n        for i in range(N):\n            # x_i - r_i >= 0\n            jac[i, i] = 1.0; jac[i, 2*N+i] = -1.0\n            # 1 - x_i - r_i >= 0\n            jac[N+i, i] = -1.0; jac[N+i, 2*N+i] = -1.0\n            # y_i - r_i >= 0\n            jac[2*N+i, N+i] = 1.0; jac[2*N+i, 2*N+i] = -1.0\n            # 1 - y_i - r_i >= 0\n            jac[3*N+i, N+i] = -1.0; jac[3*N+i, 2*N+i] = -1.0\n            \n        # Overlap gradients\n        dx = x[triu_i] - x[triu_j]\n        dy = y[triu_i] - y[triu_j]\n        dr = r[triu_i] + r[triu_j]\n        row_idx = 4*N + np.arange(num_overlap_cons)\n        \n        # Derivatives for circle i\n        jac[row_idx, triu_i] = 2 * dx\n        jac[row_idx, N + triu_i] = 2 * dy\n        jac[row_idx, 2*N + triu_i] = -2 * dr\n        \n        # Derivatives for circle j\n        jac[row_idx, triu_j] = -2 * dx\n        jac[row_idx, N + triu_j] = -2 * dy\n        jac[row_idx, 2*N + triu_j] = -2 * dr\n        \n        return jac\n\n    # Initial guess: A slightly perturbed 5x5 grid plus one extra circle\n    grid = np.linspace(0.12, 0.88, 5)\n    xx, yy = np.meshgrid(grid, grid)\n    x0 = np.append(xx.flatten(), 0.5)\n    y0 = np.append(yy.flatten(), 0.5)\n    \n    # Add small random noise to break exact symmetry and resolve overlapping centers\n    np.random.seed(42)\n    x0 += np.random.uniform(-0.01, 0.01, N)\n    y0 += np.random.uniform(-0.01, 0.01, N)\n    \n    # Initial radii set slightly below the target uniform radius\n    r0 = np.full(N, 0.09)\n    v0 = np.concatenate([x0, y0, r0])\n    \n    # Bounds for x, y, and r\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n\n    start_time = time.time()\n\n    def callback(x, f, accept):\n        \"\"\"Stops the optimization if the time limit is approaching.\"\"\"\n        if time.time() - start_time > 280:\n            return True\n        return False\n\n    # Basin-hopping explores different basins using SLSQP for local maximization\n    # SLSQP is suitable for this problem as it handles non-linear constraints efficiently.\n    res = basinhopping(\n        objective, \n        v0,\n        minimizer_kwargs={\n            \"method\": \"SLSQP\",\n            \"jac\": objective_jac,\n            \"constraints\": {\"type\": \"ineq\", \"fun\": constraints_fn, \"jac\": constraints_jac},\n            \"bounds\": bounds,\n            \"options\": {\"maxiter\": 120, \"ftol\": 1e-9}\n        },\n        niter=20,\n        stepsize=0.03,\n        T=0.01,\n        callback=callback\n    )\n    \n    # Extract final results\n    v_best = res.x\n    centers = np.stack([v_best[:N], v_best[N:2*N]], axis=1)\n    radii = v_best[2*N:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.622444452008155,
    "eval_time": 3.67333722114563,
    "error": null
  },
  "prompt": "Improve the following circle packing solution (score: 2.630700304202615). Use scipy.optimize.basinhopping with SLSQP as the local minimizer. Ensure the constraints (inside [0,1] and no overlaps) are strictly handled in the optimization function. The goal is to maximize the sum of radii for 26 circles.\n\nCode:\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of a penalty-based inflation strategy and SLSQP optimization.\n    \"\"\"\n    N = 26\n    triu_i, triu_j = np.triu_indices(N, k=1)\n\n    def get_initial_centers(seed):\n        \"\"\"Generates initial center positions for the circles.\"\"\"\n        if seed == 0:\n            # Start with a slightly perturbed 5x5 grid + 1 extra circle\n            xs = np.linspace(0.12, 0.88, 5)\n            ys = np.linspace(0.12, 0.88, 5)\n            xx, yy = np.meshgrid(xs, ys)\n            x = xx.flatten()\n            y = yy.flatten()\n            # 26th circle placed near the center\n            x = np.append(x, 0.5)\n            y = np.append(y, 0.5)\n            return x, y\n        \n        # Random initial centers\n        np.random.seed(seed)\n        x = np.random.uniform(0.1, 0.9, N)\n        y = np.random.uniform(0.1, 0.9, N)\n        return x, y\n\n    def penalty_obj(coords, r_fixed):\n        \"\"\"Smooth penalty function to reduce overlaps and boundary violations.\"\"\"\n        x, y = coords[:N], coords[N:]\n        \n        # Boundary violations\n        low_x = r_fixed - x\n        high_x = x + r_fixed - 1\n        low_y = r_fixed - y\n        high_y = y + r_fixed - 1\n        b_viols = (np.maximum(0, low_x)**2 + np.maximum(0, high_x)**2 +\n                   np.maximum(0, low_y)**2 + np.maximum(0, high_y)**2)\n        \n        # Overlap violations\n        dx = x[triu_i] - x[triu_j]\n        dy = y[triu_i] - y[triu_j]\n        d_sq = dx**2 + dy**2\n        rad_sum_sq = (2 * r_fixed)**2\n        o_viols = np.maximum(0, rad_sum_sq - d_sq)**2\n        \n        return np.sum(b_viols) + np.sum(o_viols)\n\n    def penalty_grad(coords, r_fixed):\n        \"\"\"Gradient of the penalty function for L-BFGS-B.\"\"\"\n        x, y = coords[:N], coords[N:]\n        gx, gy = np.zeros(N), np.zeros(N)\n        \n        # Boundary gradients\n        mask_low_x, mask_high_x = r_fixed > x, x + r_fixed > 1\n        mask_low_y, mask_high_y = r_fixed > y, y + r_fixed > 1\n        gx[mask_low_x] -= 2 * (r_fixed - x[mask_low_x])\n        gx[mask_high_x] += 2 * (x[mask_high_x] + r_fixed - 1)\n        gy[mask_low_y] -= 2 * (r_fixed - y[mask_low_y])\n        gy[mask_high_y] += 2 * (y[mask_high_y] + r_fixed - 1)\n        \n        # Overlap gradients\n        dx = x[triu_i] - x[triu_j]\n        dy = y[triu_i] - y[triu_j]\n        d_sq = dx**2 + dy**2\n        rad_sum_sq = (2 * r_fixed)**2\n        mask_overlap = rad_sum_sq > d_sq\n        if np.any(mask_overlap):\n            common = -4 * (rad_sum_sq - d_sq[mask_overlap])\n            np.add.at(gx, triu_i[mask_overlap], common * dx[mask_overlap])\n            np.add.at(gx, triu_j[mask_overlap], -common * dx[mask_overlap])\n            np.add.at(gy, triu_i[mask_overlap], common * dy[mask_overlap])\n            np.add.at(gy, triu_j[mask_overlap], -common * dy[mask_overlap])\n            \n        return np.concatenate([gx, gy])\n\n    def slsqp_obj(v):\n        \"\"\"Negative sum of radii as the objective for minimization.\"\"\"\n        return -np.sum(v[2*N:])\n    \n    def slsqp_obj_jac(v):\n        \"\"\"Gradient of the objective function.\"\"\"\n        jac = np.zeros(3*N)\n        jac[2*N:] = -1.0\n        return jac\n        \n    def all_constraints(v):\n        \"\"\"Hard constraints for the packing problem.\"\"\"\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        # Boundary: x_i - r_i >= 0, 1 - x_i - r_i >= 0, same for y\n        c_boundary = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        # Non-overlap: dist^2 - (r1+r2)^2 >= 0\n        dx, dy, dr = x[triu_i] - x[triu_j], y[triu_i] - y[triu_j], r[triu_i] + r[triu_j]\n        c_overlap = dx**2 + dy**2 - dr**2\n        return np.concatenate([c_boundary, c_overlap])\n\n    def all_constraints_jac(v):\n        \"\"\"Jacobian of the hard constraints.\"\"\"\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        num_cons = 4*N + len(triu_i)\n        jac = np.zeros((num_cons, 3*N))\n        \n        # Boundary derivatives\n        for i in range(N):\n            jac[i, i], jac[i, 2*N+i] = 1.0, -1.0\n            jac[N+i, i], jac[N+i, 2*N+i] = -1.0, -1.0\n            jac[2*N+i, N+i], jac[2*N+i, 2*N+i] = 1.0, -1.0\n            jac[3*N+i, N+i], jac[3*N+i, 2*N+i] = -1.0, -1.0\n            \n        # Overlap derivatives\n        offset = 4*N\n        rows = np.arange(len(triu_i))\n        dx, dy, dr = x[triu_i] - x[triu_j], y[triu_i] - y[triu_j], r[triu_i] + r[triu_j]\n        jac[offset + rows, triu_i] = 2 * dx\n        jac[offset + rows, triu_j] = -2 * dx\n        jac[offset + rows, N + triu_i] = 2 * dy\n        jac[offset + rows, N + triu_j] = -2 * dy\n        jac[offset + rows, 2*N + triu_i] = -2 * dr\n        jac[offset + rows, 2*N + triu_j] = -2 * dr\n        \n        return jac\n\n    best_sum, best_centers, best_radii = 0, None, None\n    start_time, seed = time.time(), 0\n    \n    # Run multiple trials within the time limit\n    while time.time() - start_time < 280:\n        # Step 1: Initialize\n        x_init, y_init = get_initial_centers(seed)\n        \n        # Step 2: Penalty Phase (resolve initial overlaps)\n        # Use fixed radius slightly smaller than the target uniform radius\n        r_target = 0.098\n        res_p = minimize(penalty_obj, np.concatenate([x_init, y_init]), args=(r_target,), \n                         method='L-BFGS-B', jac=penalty_grad, options={'maxiter': 150})\n        \n        # Step 3: SLSQP Phase (maximize sum of radii)\n        initial_vars = np.concatenate([res_p.x[:N], res_p.x[N:], np.full(N, r_target)])\n        res_s = minimize(slsqp_obj, initial_vars, method='SLSQP', jac=slsqp_obj_jac,\n                         constraints={'type': 'ineq', 'fun': all_constraints, 'jac': all_constraints_jac},\n                         bounds=[(0, 1)]*(2*N) + [(0, 0.5)]*N, \n                         options={'maxiter': 120, 'ftol': 1e-8})\n        \n        # Step 4: Validate and Update Best Result\n        if res_s.fun < -best_sum:\n            v = res_s.x\n            # Verify constraints with a small tolerance\n            if np.all(all_constraints(v) >= -1e-7):\n                best_sum = -res_s.fun\n                best_centers = np.stack([v[:N], v[N:2*N]], axis=1)\n                best_radii = v[2*N:]\n        \n        seed += 1\n        \n    return best_centers, best_radii, best_sum",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses basin-hopping with SLSQP as the local minimizer to find an optimal configuration.\n    \"\"\"\n    N = 26\n    # Indices for all unique pairs of circles for non-overlap constraints\n    triu_i, triu_j = np.triu_indices(N, k=1)\n    num_overlap_cons = len(triu_i)\n\n    def objective(v):\n        \"\"\"Negative sum of radii to be minimized.\"\"\"\n        return -np.sum(v[2*N:])\n\n    def objective_jac(v):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def constraints_fn(v):\n        \"\"\"\n        Hard constraints for the packing problem.\n        1. Boundary: Circles must be inside [0,1]x[0,1]\n        2. Non-overlap: Distance between any two centers must be at least the sum of their radii.\n        \"\"\"\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        # Total constraints: 4 per circle (boundary) + N(N-1)/2 (non-overlap)\n        c = np.empty(4*N + num_overlap_cons)\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        \n        # Non-overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = x[triu_i] - x[triu_j]\n        dy = y[triu_i] - y[triu_j]\n        dr = r[triu_i] + r[triu_j]\n        c[4*N:] = dx**2 + dy**2 - dr**2\n        return c\n\n    def constraints_jac(v):\n        \"\"\"Jacobian of the hard constraints.\"\"\"\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        jac = np.zeros((4*N + num_overlap_cons, 3*N))\n        \n        # Boundary gradients\n        for i in range(N):\n            # x_i - r_i >= 0\n            jac[i, i] = 1.0; jac[i, 2*N+i] = -1.0\n            # 1 - x_i - r_i >= 0\n            jac[N+i, i] = -1.0; jac[N+i, 2*N+i] = -1.0\n            # y_i - r_i >= 0\n            jac[2*N+i, N+i] = 1.0; jac[2*N+i, 2*N+i] = -1.0\n            # 1 - y_i - r_i >= 0\n            jac[3*N+i, N+i] = -1.0; jac[3*N+i, 2*N+i] = -1.0\n            \n        # Overlap gradients\n        dx = x[triu_i] - x[triu_j]\n        dy = y[triu_i] - y[triu_j]\n        dr = r[triu_i] + r[triu_j]\n        row_idx = 4*N + np.arange(num_overlap_cons)\n        \n        # Derivatives for circle i\n        jac[row_idx, triu_i] = 2 * dx\n        jac[row_idx, N + triu_i] = 2 * dy\n        jac[row_idx, 2*N + triu_i] = -2 * dr\n        \n        # Derivatives for circle j\n        jac[row_idx, triu_j] = -2 * dx\n        jac[row_idx, N + triu_j] = -2 * dy\n        jac[row_idx, 2*N + triu_j] = -2 * dr\n        \n        return jac\n\n    # Initial guess: A slightly perturbed 5x5 grid plus one extra circle\n    grid = np.linspace(0.12, 0.88, 5)\n    xx, yy = np.meshgrid(grid, grid)\n    x0 = np.append(xx.flatten(), 0.5)\n    y0 = np.append(yy.flatten(), 0.5)\n    \n    # Add small random noise to break exact symmetry and resolve overlapping centers\n    np.random.seed(42)\n    x0 += np.random.uniform(-0.01, 0.01, N)\n    y0 += np.random.uniform(-0.01, 0.01, N)\n    \n    # Initial radii set slightly below the target uniform radius\n    r0 = np.full(N, 0.09)\n    v0 = np.concatenate([x0, y0, r0])\n    \n    # Bounds for x, y, and r\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n\n    start_time = time.time()\n\n    def callback(x, f, accept):\n        \"\"\"Stops the optimization if the time limit is approaching.\"\"\"\n        if time.time() - start_time > 280:\n            return True\n        return False\n\n    # Basin-hopping explores different basins using SLSQP for local maximization\n    # SLSQP is suitable for this problem as it handles non-linear constraints efficiently.\n    res = basinhopping(\n        objective, \n        v0,\n        minimizer_kwargs={\n            \"method\": \"SLSQP\",\n            \"jac\": objective_jac,\n            \"constraints\": {\"type\": \"ineq\", \"fun\": constraints_fn, \"jac\": constraints_jac},\n            \"bounds\": bounds,\n            \"options\": {\"maxiter\": 120, \"ftol\": 1e-9}\n        },\n        niter=20,\n        stepsize=0.03,\n        T=0.01,\n        callback=callback\n    )\n    \n    # Extract final results\n    v_best = res.x\n    centers = np.stack([v_best[:N], v_best[N:2*N]], axis=1)\n    radii = v_best[2*N:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:09:09.981811",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2676,
        "candidates_token_count": 1683,
        "thoughts_token_count": 22310
      },
      "response_text_len": 4423
    }
  },
  "llm_call_duration_s": 138.8171874890104,
  "eval_duration_s": 3.67334568395745
}