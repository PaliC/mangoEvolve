{
  "trial_id": "trial_8_5",
  "generation": 8,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution, linprog\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Differential Evolution to optimize the centers (x, y) and Linear Programming (LP)\n    to find the optimal radii (r) for a given set of centers.\n    \"\"\"\n    n = 26\n    \n    # Pre-build the A matrix for the Linear Programming problem.\n    # Each row of A represents an overlap constraint between two circles: r_i + r_j <= distance_ij.\n    i_indices, j_indices = np.triu_indices(n, k=1)\n    num_overlap = len(i_indices)\n    A_template = np.zeros((num_overlap, n))\n    A_template[np.arange(num_overlap), i_indices] = 1\n    A_template[np.arange(num_overlap), j_indices] = 1\n    \n    # Pre-calculate the objective vector for linprog (minimize -sum(r_i) to maximize sum(r_i)).\n    c_lp = -np.ones(n)\n\n    def solve_for_radii(centers_flat):\n        \"\"\"\n        Given the centers of the circles, finds the radii that maximize their sum\n        subject to boundary and non-overlap constraints using Linear Programming.\n        \"\"\"\n        x = centers_flat[0:n]\n        y = centers_flat[n:2*n]\n        \n        # Boundary constraints: r_i must be <= distance to each of the four walls.\n        # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        b_boundary = np.minimum(np.minimum(x, 1-x), np.minimum(y, 1-y))\n        # Ensure boundary constraints are non-negative to avoid LP errors.\n        b_boundary = np.maximum(b_boundary, 0)\n        \n        # Overlap constraints: r_i + r_j <= distance between center i and center j.\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        # Solve the LP problem: Maximize sum(r_i) subject to:\n        # 1. r_i + r_j <= dist_ij\n        # 2. 0 <= r_i <= b_boundary_i\n        # Using the 'highs' method for its high performance and robustness.\n        res = linprog(c_lp, A_ub=A_template, b_ub=dist, \n                      bounds=list(zip(np.zeros(n), b_boundary)), \n                      method='highs')\n        \n        if res.success:\n            return float(res.fun), res.x\n        else:\n            # If the LP solver fails to find a solution, return a safe fallback.\n            return 0.0, np.zeros(n)\n\n    def de_objective(centers_flat):\n        \"\"\"\n        Objective function for the Differential Evolution algorithm.\n        Returns the negative sum of radii (to be minimized).\n        \"\"\"\n        val, _ = solve_for_radii(centers_flat)\n        return val\n\n    # The search space for Differential Evolution consists of the 52 coordinates (x_i, y_i).\n    bounds = [(0, 1)] * (2 * n)\n    \n    # Initialize the population with a structured guess.\n    # A 5x5 grid of circles is a good starting point for 26 circles.\n    pop_size = 52 # Differential Evolution popsize multiplier (1 * n_vars)\n    initial_pop = np.random.rand(pop_size, 2 * n)\n    \n    # Create a grid-based center configuration.\n    grid = np.linspace(0.1, 0.9, 5)\n    xx, yy = np.meshgrid(grid, grid)\n    # 25 circles in a grid plus one at the center.\n    x_init = np.append(xx.flatten(), 0.5)\n    y_init = np.append(yy.flatten(), 0.5)\n    grid_centers = np.concatenate([x_init, y_init])\n    \n    # Add the grid and some perturbed versions of it to the initial population.\n    initial_pop[0] = grid_centers\n    for k in range(1, 10):\n        perturbed = grid_centers + np.random.normal(0, 0.05, 2 * n)\n        initial_pop[k] = np.clip(perturbed, 0, 1)\n\n    # Run Differential Evolution to find the optimal centers.\n    # maxiter is set to ensure the algorithm completes within the 300s time limit.\n    res = differential_evolution(\n        de_objective,\n        bounds=bounds,\n        maxiter=65,\n        popsize=1,\n        init=initial_pop,\n        mutation=(0.5, 1),\n        recombination=0.7,\n        workers=1,\n        tol=1e-4\n    )\n    \n    # Solve the LP one final time with the best centers found to extract the optimal radii.\n    final_sum_neg, radii = solve_for_radii(res.x)\n    centers = np.column_stack((res.x[0:n], res.x[n:2*n]))\n    sum_radii = float(-final_sum_neg)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.400000268341552,
    "eval_time": 13.705413818359375,
    "error": null
  },
  "prompt": "Use scipy.optimize.differential_evolution to optimize the sum of radii. Represent the state as a 26*3 vector (x, y, r). Use a custom constraint function to handle non-overlap and boundary conditions. This global search might find a better configuration than local refinement.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution, linprog\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Differential Evolution to optimize the centers (x, y) and Linear Programming (LP)\n    to find the optimal radii (r) for a given set of centers.\n    \"\"\"\n    n = 26\n    \n    # Pre-build the A matrix for the Linear Programming problem.\n    # Each row of A represents an overlap constraint between two circles: r_i + r_j <= distance_ij.\n    i_indices, j_indices = np.triu_indices(n, k=1)\n    num_overlap = len(i_indices)\n    A_template = np.zeros((num_overlap, n))\n    A_template[np.arange(num_overlap), i_indices] = 1\n    A_template[np.arange(num_overlap), j_indices] = 1\n    \n    # Pre-calculate the objective vector for linprog (minimize -sum(r_i) to maximize sum(r_i)).\n    c_lp = -np.ones(n)\n\n    def solve_for_radii(centers_flat):\n        \"\"\"\n        Given the centers of the circles, finds the radii that maximize their sum\n        subject to boundary and non-overlap constraints using Linear Programming.\n        \"\"\"\n        x = centers_flat[0:n]\n        y = centers_flat[n:2*n]\n        \n        # Boundary constraints: r_i must be <= distance to each of the four walls.\n        # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        b_boundary = np.minimum(np.minimum(x, 1-x), np.minimum(y, 1-y))\n        # Ensure boundary constraints are non-negative to avoid LP errors.\n        b_boundary = np.maximum(b_boundary, 0)\n        \n        # Overlap constraints: r_i + r_j <= distance between center i and center j.\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        # Solve the LP problem: Maximize sum(r_i) subject to:\n        # 1. r_i + r_j <= dist_ij\n        # 2. 0 <= r_i <= b_boundary_i\n        # Using the 'highs' method for its high performance and robustness.\n        res = linprog(c_lp, A_ub=A_template, b_ub=dist, \n                      bounds=list(zip(np.zeros(n), b_boundary)), \n                      method='highs')\n        \n        if res.success:\n            return float(res.fun), res.x\n        else:\n            # If the LP solver fails to find a solution, return a safe fallback.\n            return 0.0, np.zeros(n)\n\n    def de_objective(centers_flat):\n        \"\"\"\n        Objective function for the Differential Evolution algorithm.\n        Returns the negative sum of radii (to be minimized).\n        \"\"\"\n        val, _ = solve_for_radii(centers_flat)\n        return val\n\n    # The search space for Differential Evolution consists of the 52 coordinates (x_i, y_i).\n    bounds = [(0, 1)] * (2 * n)\n    \n    # Initialize the population with a structured guess.\n    # A 5x5 grid of circles is a good starting point for 26 circles.\n    pop_size = 52 # Differential Evolution popsize multiplier (1 * n_vars)\n    initial_pop = np.random.rand(pop_size, 2 * n)\n    \n    # Create a grid-based center configuration.\n    grid = np.linspace(0.1, 0.9, 5)\n    xx, yy = np.meshgrid(grid, grid)\n    # 25 circles in a grid plus one at the center.\n    x_init = np.append(xx.flatten(), 0.5)\n    y_init = np.append(yy.flatten(), 0.5)\n    grid_centers = np.concatenate([x_init, y_init])\n    \n    # Add the grid and some perturbed versions of it to the initial population.\n    initial_pop[0] = grid_centers\n    for k in range(1, 10):\n        perturbed = grid_centers + np.random.normal(0, 0.05, 2 * n)\n        initial_pop[k] = np.clip(perturbed, 0, 1)\n\n    # Run Differential Evolution to find the optimal centers.\n    # maxiter is set to ensure the algorithm completes within the 300s time limit.\n    res = differential_evolution(\n        de_objective,\n        bounds=bounds,\n        maxiter=65,\n        popsize=1,\n        init=initial_pop,\n        mutation=(0.5, 1),\n        recombination=0.7,\n        workers=1,\n        tol=1e-4\n    )\n    \n    # Solve the LP one final time with the best centers found to extract the optimal radii.\n    final_sum_neg, radii = solve_for_radii(res.x)\n    centers = np.column_stack((res.x[0:n], res.x[n:2*n]))\n    sum_radii = float(-final_sum_neg)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:52:59.048760",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 287,
        "candidates_token_count": 1352,
        "thoughts_token_count": 19466
      },
      "response_text_len": 4234
    }
  },
  "llm_call_duration_s": 118.09787367098033,
  "eval_duration_s": 13.705424224026501
}