{
  "trial_id": "trial_8_3",
  "generation": 8,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of Simulated Annealing and Linear Programming.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n\n    def solve_lp(x, y):\n        \"\"\"\n        Given center positions (x, y), finds the optimal radii that maximize the sum\n        while satisfying boundary and overlap constraints.\n        \"\"\"\n        # Objective: Maximize sum(r_i) => Minimize sum(-r_i)\n        c = -np.ones(N)\n        \n        # Boundary constraints: r_i <= B_i, where B_i is dist to nearest wall\n        # x - r_i >= 0 => r_i <= x\n        # 1 - x - r_i >= 0 => r_i <= 1 - x\n        B = np.minimum(np.minimum(x, 1 - x), np.minimum(y, 1 - y))\n        B = np.maximum(0, B)  # Ensure no negative bounds\n        bounds = [(0, b) for b in B]\n        \n        # Overlap constraints: r_i + r_j <= d_ij\n        A = []\n        b_ub = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                row = np.zeros(N)\n                row[i], row[j] = 1, 1\n                A.append(row)\n                d_ij = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                b_ub.append(d_ij)\n        \n        # Solve the linear program\n        res = linprog(c, A_ub=A, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n        else:\n            # Fallback if LP fails\n            return None, 0\n\n    best_overall_sum = 0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Different initializations to avoid local optima\n    initializations = ['grid55', 'random', 'random']\n    \n    for init_mode in initializations:\n        # Check time limit (300 seconds)\n        if time.time() - start_time > 260:\n            break\n        \n        # Initialize centers\n        if init_mode == 'grid55':\n            # 5x5 grid plus one circle at the corner\n            grid = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(grid, grid)\n            x, y = xx.flatten(), yy.flatten()\n            x, y = np.append(x, 0.05), np.append(y, 0.05)\n        else:\n            x, y = np.random.rand(N), np.random.rand(N)\n        \n        # Initial radii\n        r = np.ones(N) * 0.05\n        \n        # Simulated Annealing parameters\n        steps = 150000\n        T_start, T_end = 0.05, 0.001\n        alpha_start, alpha_end = 10.0, 500.0\n        T_factor = (T_end / T_start)**(1 / steps)\n        alpha_factor = (alpha_end / alpha_start)**(1 / steps)\n        T, alpha = T_start, alpha_start\n        \n        for step in range(steps):\n            # Pick a random circle to perturb\n            idx = np.random.randint(N)\n            old_x, old_y, old_r = x[idx], y[idx], r[idx]\n            \n            # Calculate local energy before move\n            # Energy = -sum(radii) + alpha * penalty\n            dists_old = np.sqrt((x[idx] - x)**2 + (y[idx] - y)**2 + 1e-9)\n            old_o_viol = 0\n            for i in range(N):\n                if i != idx:\n                    old_o_viol += max(0, r[idx] + r[i] - dists_old[i])\n            old_b_viol = max(0, r[idx] - x[idx]) + max(0, x[idx] + r[idx] - 1) + \\\n                         max(0, r[idx] - y[idx]) + max(0, y[idx] + r[idx] - 1)\n            old_E = -r[idx] + alpha * (old_o_viol + old_b_viol)\n            \n            # Perturb center and radius\n            sigma = 0.05 * (T / 0.05)**0.5\n            x[idx] = np.clip(x[idx] + np.random.uniform(-sigma, sigma), 0, 1)\n            y[idx] = np.clip(y[idx] + np.random.uniform(-sigma, sigma), 0, 1)\n            r[idx] = np.clip(r[idx] + np.random.uniform(-sigma / 2, sigma / 2), 0, 0.5)\n            \n            # Calculate local energy after move\n            dists_new = np.sqrt((x[idx] - x)**2 + (y[idx] - y)**2 + 1e-9)\n            new_o_viol = 0\n            for i in range(N):\n                if i != idx:\n                    new_o_viol += max(0, r[idx] + r[i] - dists_new[i])\n            new_b_viol = max(0, r[idx] - x[idx]) + max(0, x[idx] + r[idx] - 1) + \\\n                         max(0, r[idx] - y[idx]) + max(0, y[idx] + r[idx] - 1)\n            new_E = -r[idx] + alpha * (new_o_viol + new_b_viol)\n            \n            # Acceptance criteria\n            if new_E < old_E or np.random.rand() < np.exp((old_E - new_E) / T):\n                # Accept the move\n                pass\n            else:\n                # Reject and restore\n                x[idx], y[idx], r[idx] = old_x, old_y, old_r\n            \n            # Update temperature and penalty weight\n            T *= T_factor\n            alpha *= alpha_factor\n\n        # Refine the centers with the optimal radii using LP\n        lp_r, lp_sum = solve_lp(x, y)\n        if lp_sum > best_overall_sum:\n            best_overall_sum = lp_sum\n            best_overall_centers = np.column_stack((x, y))\n            best_overall_radii = lp_r\n\n    return best_overall_centers, best_overall_radii, best_overall_sum",
  "metrics": {
    "valid": true,
    "score": 2.5602241671203996,
    "eval_time": 38.33842468261719,
    "error": null
  },
  "prompt": "Implement a simulated annealing algorithm. The state is the centers and radii of 26 circles. The energy function to minimize is -sum(radii) + alpha * penalty, where penalty is the sum of overlaps and boundary violations. Gradually decrease alpha and the temperature to converge to a valid, high-score packing.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of Simulated Annealing and Linear Programming.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n\n    def solve_lp(x, y):\n        \"\"\"\n        Given center positions (x, y), finds the optimal radii that maximize the sum\n        while satisfying boundary and overlap constraints.\n        \"\"\"\n        # Objective: Maximize sum(r_i) => Minimize sum(-r_i)\n        c = -np.ones(N)\n        \n        # Boundary constraints: r_i <= B_i, where B_i is dist to nearest wall\n        # x - r_i >= 0 => r_i <= x\n        # 1 - x - r_i >= 0 => r_i <= 1 - x\n        B = np.minimum(np.minimum(x, 1 - x), np.minimum(y, 1 - y))\n        B = np.maximum(0, B)  # Ensure no negative bounds\n        bounds = [(0, b) for b in B]\n        \n        # Overlap constraints: r_i + r_j <= d_ij\n        A = []\n        b_ub = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                row = np.zeros(N)\n                row[i], row[j] = 1, 1\n                A.append(row)\n                d_ij = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                b_ub.append(d_ij)\n        \n        # Solve the linear program\n        res = linprog(c, A_ub=A, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n        else:\n            # Fallback if LP fails\n            return None, 0\n\n    best_overall_sum = 0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Different initializations to avoid local optima\n    initializations = ['grid55', 'random', 'random']\n    \n    for init_mode in initializations:\n        # Check time limit (300 seconds)\n        if time.time() - start_time > 260:\n            break\n        \n        # Initialize centers\n        if init_mode == 'grid55':\n            # 5x5 grid plus one circle at the corner\n            grid = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(grid, grid)\n            x, y = xx.flatten(), yy.flatten()\n            x, y = np.append(x, 0.05), np.append(y, 0.05)\n        else:\n            x, y = np.random.rand(N), np.random.rand(N)\n        \n        # Initial radii\n        r = np.ones(N) * 0.05\n        \n        # Simulated Annealing parameters\n        steps = 150000\n        T_start, T_end = 0.05, 0.001\n        alpha_start, alpha_end = 10.0, 500.0\n        T_factor = (T_end / T_start)**(1 / steps)\n        alpha_factor = (alpha_end / alpha_start)**(1 / steps)\n        T, alpha = T_start, alpha_start\n        \n        for step in range(steps):\n            # Pick a random circle to perturb\n            idx = np.random.randint(N)\n            old_x, old_y, old_r = x[idx], y[idx], r[idx]\n            \n            # Calculate local energy before move\n            # Energy = -sum(radii) + alpha * penalty\n            dists_old = np.sqrt((x[idx] - x)**2 + (y[idx] - y)**2 + 1e-9)\n            old_o_viol = 0\n            for i in range(N):\n                if i != idx:\n                    old_o_viol += max(0, r[idx] + r[i] - dists_old[i])\n            old_b_viol = max(0, r[idx] - x[idx]) + max(0, x[idx] + r[idx] - 1) + \\\n                         max(0, r[idx] - y[idx]) + max(0, y[idx] + r[idx] - 1)\n            old_E = -r[idx] + alpha * (old_o_viol + old_b_viol)\n            \n            # Perturb center and radius\n            sigma = 0.05 * (T / 0.05)**0.5\n            x[idx] = np.clip(x[idx] + np.random.uniform(-sigma, sigma), 0, 1)\n            y[idx] = np.clip(y[idx] + np.random.uniform(-sigma, sigma), 0, 1)\n            r[idx] = np.clip(r[idx] + np.random.uniform(-sigma / 2, sigma / 2), 0, 0.5)\n            \n            # Calculate local energy after move\n            dists_new = np.sqrt((x[idx] - x)**2 + (y[idx] - y)**2 + 1e-9)\n            new_o_viol = 0\n            for i in range(N):\n                if i != idx:\n                    new_o_viol += max(0, r[idx] + r[i] - dists_new[i])\n            new_b_viol = max(0, r[idx] - x[idx]) + max(0, x[idx] + r[idx] - 1) + \\\n                         max(0, r[idx] - y[idx]) + max(0, y[idx] + r[idx] - 1)\n            new_E = -r[idx] + alpha * (new_o_viol + new_b_viol)\n            \n            # Acceptance criteria\n            if new_E < old_E or np.random.rand() < np.exp((old_E - new_E) / T):\n                # Accept the move\n                pass\n            else:\n                # Reject and restore\n                x[idx], y[idx], r[idx] = old_x, old_y, old_r\n            \n            # Update temperature and penalty weight\n            T *= T_factor\n            alpha *= alpha_factor\n\n        # Refine the centers with the optimal radii using LP\n        lp_r, lp_sum = solve_lp(x, y)\n        if lp_sum > best_overall_sum:\n            best_overall_sum = lp_sum\n            best_overall_centers = np.column_stack((x, y))\n            best_overall_radii = lp_r\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:53:35.649368",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 292,
        "candidates_token_count": 1714,
        "thoughts_token_count": 20591
      },
      "response_text_len": 5018
    }
  },
  "llm_call_duration_s": 130.05674354999792,
  "eval_duration_s": 38.338433044962585
}