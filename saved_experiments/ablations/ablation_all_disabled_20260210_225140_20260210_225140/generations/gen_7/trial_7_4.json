{
  "trial_id": "trial_7_4",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Quasi-Monte Carlo sequence for initial center positions and SLSQP for optimization.\n    \"\"\"\n    N = 26\n    # Precompute indices for constraints and Jacobian\n    IDX1, IDX2 = np.triu_indices(N, k=1)\n    NUM_OVERLAP = N * (N - 1) // 2\n    OVERLAP_IDX = np.arange(4 * N, 4 * N + NUM_OVERLAP)\n\n    def objective(vars):\n        # Objective: Maximize sum of radii -> Minimize negative sum of radii\n        # vars: [x0...x25, y0...y25, r0...r25]\n        return -np.sum(vars[2*N:3*N])\n\n    def jac_objective(vars):\n        # Gradient of the objective function\n        jac = np.zeros(3 * N)\n        jac[2*N:3*N] = -1.0\n        return jac\n\n    def constraints(vars):\n        # Constraints: circles must be inside the square and must not overlap\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:3*N]\n        \n        # Boundary constraints: r_i <= x_i <= 1 - r_i and r_i <= y_i <= 1 - r_i\n        c_boundary = np.concatenate([\n            x - r,\n            1.0 - x - r,\n            y - r,\n            1.0 - y - r\n        ])\n        \n        # Non-overlap constraints: distance between centers >= sum of radii\n        dist_sq = (x[IDX1] - x[IDX2])**2 + (y[IDX1] - y[IDX2])**2\n        rad_sum_sq = (r[IDX1] + r[IDX2])**2\n        c_overlap = dist_sq - rad_sum_sq\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    def jac_constraints(vars):\n        # Jacobian of the constraint functions\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:3*N]\n        \n        jac = np.zeros((4 * N + NUM_OVERLAP, 3 * N))\n        \n        # Boundary constraints Jacobian\n        # x_i - r_i >= 0\n        jac[np.arange(N), np.arange(N)] = 1.0\n        jac[np.arange(N), np.arange(2*N, 3*N)] = -1.0\n        # 1 - x_i - r_i >= 0\n        jac[np.arange(N, 2*N), np.arange(N)] = -1.0\n        jac[np.arange(N, 2*N), np.arange(2*N, 3*N)] = -1.0\n        # y_i - r_i >= 0\n        jac[np.arange(2*N, 3*N), np.arange(N, 2*N)] = 1.0\n        jac[np.arange(2*N, 3*N), np.arange(2*N, 3*N)] = -1.0\n        # 1 - y_i - r_i >= 0\n        jac[np.arange(3*N, 4*N), np.arange(N, 2*N)] = -1.0\n        jac[np.arange(3*N, 4*N), np.arange(2*N, 3*N)] = -1.0\n        \n        # Overlap constraints Jacobian\n        dx = 2.0 * (x[IDX1] - x[IDX2])\n        dy = 2.0 * (y[IDX1] - y[IDX2])\n        dr = -2.0 * (r[IDX1] + r[IDX2])\n        \n        jac[OVERLAP_IDX, IDX1] = dx\n        jac[OVERLAP_IDX, IDX2] = -dx\n        jac[OVERLAP_IDX, N + IDX1] = dy\n        jac[OVERLAP_IDX, N + IDX2] = -dy\n        jac[OVERLAP_IDX, 2*N + IDX1] = dr\n        jac[OVERLAP_IDX, 2*N + IDX2] = dr\n        \n        return jac\n\n    def halton_sequence(n, p):\n        # Generates the first n terms of a Halton sequence for base p\n        h = np.zeros(n)\n        for i in range(n):\n            f, r, k = 1.0, 0.0, i + 1\n            while k > 0:\n                f /= p\n                r += f * (k % p)\n                k //= p\n            h[i] = r\n        return h\n\n    # Generate 50 initial configurations using Halton sequence\n    try:\n        from scipy.stats import qmc\n        sampler = qmc.Halton(d=2, seed=42)\n        initial_points = [sampler.random(N) for _ in range(50)]\n    except (ImportError, AttributeError):\n        # Fallback to manual Halton sequence generation\n        initial_points = []\n        for i in range(50):\n            p1 = halton_sequence(N + i*N, 2)[i*N:]\n            p2 = halton_sequence(N + i*N, 3)[i*N:]\n            initial_points.append(np.column_stack([p1, p2]))\n\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n    \n    # 1. Quick optimization runs\n    quick_results = []\n    for i in range(50):\n        pts = initial_points[i]\n        # Start with a conservative radius\n        r_init = np.full(N, 0.05)\n        x0 = np.concatenate([pts[:, 0], pts[:, 1], r_init])\n        \n        res = minimize(\n            fun=objective,\n            x0=x0,\n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            method='SLSQP',\n            bounds=bounds,\n            options={'maxiter': 20}\n        )\n        quick_results.append(res)\n    \n    def get_score(res):\n        # Helper to evaluate results based on sum of radii and feasibility\n        x = res.x\n        cons = constraints(x)\n        violation = np.sum(np.maximum(0, -cons))\n        return np.sum(x[2*N:3*N]) - 10.0 * violation\n\n    # Sort results and take the best 3\n    quick_results.sort(key=get_score, reverse=True)\n    best_res = quick_results[0]\n    best_score = get_score(best_res)\n    \n    # 2. Deep optimization on top 3 candidates\n    for i in range(min(3, len(quick_results))):\n        res = minimize(\n            fun=objective,\n            x0=quick_results[i].x,\n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            method='SLSQP',\n            bounds=bounds,\n            options={'maxiter': 250, 'ftol': 1e-9}\n        )\n        score = get_score(res)\n        if score > best_score:\n            best_score = score\n            best_res = res\n\n    # Extract final configuration\n    x_final = best_res.x\n    centers = np.column_stack([x_final[:N], x_final[N:2*N]])\n    radii = x_final[2*N:3*N]\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6283153297183723,
    "eval_time": 7.72295355796814,
    "error": null
  },
  "prompt": "Maximize the sum of radii for 26 circles in a unit square. Use a Quasi-Monte Carlo sequence (like Sobol or Halton) to generate 50 different initial packing configurations. For each, perform a quick optimization using SLSQP, then take the best 3 results and perform a very deep optimization (more iterations, tighter tolerance) on them.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Quasi-Monte Carlo sequence for initial center positions and SLSQP for optimization.\n    \"\"\"\n    N = 26\n    # Precompute indices for constraints and Jacobian\n    IDX1, IDX2 = np.triu_indices(N, k=1)\n    NUM_OVERLAP = N * (N - 1) // 2\n    OVERLAP_IDX = np.arange(4 * N, 4 * N + NUM_OVERLAP)\n\n    def objective(vars):\n        # Objective: Maximize sum of radii -> Minimize negative sum of radii\n        # vars: [x0...x25, y0...y25, r0...r25]\n        return -np.sum(vars[2*N:3*N])\n\n    def jac_objective(vars):\n        # Gradient of the objective function\n        jac = np.zeros(3 * N)\n        jac[2*N:3*N] = -1.0\n        return jac\n\n    def constraints(vars):\n        # Constraints: circles must be inside the square and must not overlap\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:3*N]\n        \n        # Boundary constraints: r_i <= x_i <= 1 - r_i and r_i <= y_i <= 1 - r_i\n        c_boundary = np.concatenate([\n            x - r,\n            1.0 - x - r,\n            y - r,\n            1.0 - y - r\n        ])\n        \n        # Non-overlap constraints: distance between centers >= sum of radii\n        dist_sq = (x[IDX1] - x[IDX2])**2 + (y[IDX1] - y[IDX2])**2\n        rad_sum_sq = (r[IDX1] + r[IDX2])**2\n        c_overlap = dist_sq - rad_sum_sq\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    def jac_constraints(vars):\n        # Jacobian of the constraint functions\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:3*N]\n        \n        jac = np.zeros((4 * N + NUM_OVERLAP, 3 * N))\n        \n        # Boundary constraints Jacobian\n        # x_i - r_i >= 0\n        jac[np.arange(N), np.arange(N)] = 1.0\n        jac[np.arange(N), np.arange(2*N, 3*N)] = -1.0\n        # 1 - x_i - r_i >= 0\n        jac[np.arange(N, 2*N), np.arange(N)] = -1.0\n        jac[np.arange(N, 2*N), np.arange(2*N, 3*N)] = -1.0\n        # y_i - r_i >= 0\n        jac[np.arange(2*N, 3*N), np.arange(N, 2*N)] = 1.0\n        jac[np.arange(2*N, 3*N), np.arange(2*N, 3*N)] = -1.0\n        # 1 - y_i - r_i >= 0\n        jac[np.arange(3*N, 4*N), np.arange(N, 2*N)] = -1.0\n        jac[np.arange(3*N, 4*N), np.arange(2*N, 3*N)] = -1.0\n        \n        # Overlap constraints Jacobian\n        dx = 2.0 * (x[IDX1] - x[IDX2])\n        dy = 2.0 * (y[IDX1] - y[IDX2])\n        dr = -2.0 * (r[IDX1] + r[IDX2])\n        \n        jac[OVERLAP_IDX, IDX1] = dx\n        jac[OVERLAP_IDX, IDX2] = -dx\n        jac[OVERLAP_IDX, N + IDX1] = dy\n        jac[OVERLAP_IDX, N + IDX2] = -dy\n        jac[OVERLAP_IDX, 2*N + IDX1] = dr\n        jac[OVERLAP_IDX, 2*N + IDX2] = dr\n        \n        return jac\n\n    def halton_sequence(n, p):\n        # Generates the first n terms of a Halton sequence for base p\n        h = np.zeros(n)\n        for i in range(n):\n            f, r, k = 1.0, 0.0, i + 1\n            while k > 0:\n                f /= p\n                r += f * (k % p)\n                k //= p\n            h[i] = r\n        return h\n\n    # Generate 50 initial configurations using Halton sequence\n    try:\n        from scipy.stats import qmc\n        sampler = qmc.Halton(d=2, seed=42)\n        initial_points = [sampler.random(N) for _ in range(50)]\n    except (ImportError, AttributeError):\n        # Fallback to manual Halton sequence generation\n        initial_points = []\n        for i in range(50):\n            p1 = halton_sequence(N + i*N, 2)[i*N:]\n            p2 = halton_sequence(N + i*N, 3)[i*N:]\n            initial_points.append(np.column_stack([p1, p2]))\n\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n    \n    # 1. Quick optimization runs\n    quick_results = []\n    for i in range(50):\n        pts = initial_points[i]\n        # Start with a conservative radius\n        r_init = np.full(N, 0.05)\n        x0 = np.concatenate([pts[:, 0], pts[:, 1], r_init])\n        \n        res = minimize(\n            fun=objective,\n            x0=x0,\n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            method='SLSQP',\n            bounds=bounds,\n            options={'maxiter': 20}\n        )\n        quick_results.append(res)\n    \n    def get_score(res):\n        # Helper to evaluate results based on sum of radii and feasibility\n        x = res.x\n        cons = constraints(x)\n        violation = np.sum(np.maximum(0, -cons))\n        return np.sum(x[2*N:3*N]) - 10.0 * violation\n\n    # Sort results and take the best 3\n    quick_results.sort(key=get_score, reverse=True)\n    best_res = quick_results[0]\n    best_score = get_score(best_res)\n    \n    # 2. Deep optimization on top 3 candidates\n    for i in range(min(3, len(quick_results))):\n        res = minimize(\n            fun=objective,\n            x0=quick_results[i].x,\n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            method='SLSQP',\n            bounds=bounds,\n            options={'maxiter': 250, 'ftol': 1e-9}\n        )\n        score = get_score(res)\n        if score > best_score:\n            best_score = score\n            best_res = res\n\n    # Extract final configuration\n    x_final = best_res.x\n    centers = np.column_stack([x_final[:N], x_final[N:2*N]])\n    radii = x_final[2*N:3*N]\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:45:55.941020",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 302,
        "candidates_token_count": 1957,
        "thoughts_token_count": 19385
      },
      "response_text_len": 5474
    }
  },
  "llm_call_duration_s": 123.70306654996239,
  "eval_duration_s": 7.722962994943373
}