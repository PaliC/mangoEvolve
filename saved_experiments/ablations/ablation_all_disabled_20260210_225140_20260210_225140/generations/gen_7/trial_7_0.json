{
  "trial_id": "trial_7_0",
  "generation": 7,
  "parent_id": "trial_6_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP with vectorized Jacobian and a shaking procedure to find \n    high-quality packings.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Precompute indices for vectorized operations\n    i_tri, j_tri = np.triu_indices(N, k=1)\n    num_overlaps = len(i_tri)\n    \n    def objective(X):\n        # Minimize negative sum of radii to maximize the sum\n        return -np.sum(X[2::3])\n\n    def jac_objective(X):\n        # Gradient: -1 for each radius, 0 for centers\n        j = np.zeros(len(X))\n        j[2::3] = -1.0\n        return j\n\n    def constraints(X):\n        # Boundary and non-overlap constraints\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        c = np.zeros(4 * N + num_overlaps)\n        # Boundary: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c[0:4*N:4] = x - r\n        c[1:4*N:4] = 1.0 - x - r\n        c[2:4*N:4] = y - r\n        c[3:4*N:4] = 1.0 - y - r\n        # Overlap: distance(i,j) - (ri + rj) >= 0\n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        c[4*N:] = np.sqrt(dx*dx + dy*dy + 1e-15) - (r[i_tri] + r[j_tri])\n        return c\n\n    def jac_constraints(X):\n        # Jacobian of the boundary and overlap constraints\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        jac = np.zeros((4 * N + num_overlaps, 3 * N))\n        \n        idx_N = np.arange(N)\n        # Boundary constraints derivatives\n        jac[4*idx_N, 3*idx_N] = 1\n        jac[4*idx_N, 3*idx_N+2] = -1\n        jac[4*idx_N+1, 3*idx_N] = -1\n        jac[4*idx_N+1, 3*idx_N+2] = -1\n        jac[4*idx_N+2, 3*idx_N+1] = 1\n        jac[4*idx_N+2, 3*idx_N+2] = -1\n        jac[4*idx_N+3, 3*idx_N+1] = -1\n        jac[4*idx_N+3, 3*idx_N+2] = -1\n        \n        # Overlap constraints derivatives\n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        dists = np.sqrt(dx*dx + dy*dy + 1e-15)\n        \n        row_idx = np.arange(num_overlaps) + 4 * N\n        jac[row_idx, 3*i_tri] = dx / dists\n        jac[row_idx, 3*j_tri] = -dx / dists\n        jac[row_idx, 3*i_tri+1] = dy / dists\n        jac[row_idx, 3*j_tri+1] = -dy / dists\n        jac[row_idx, 3*i_tri+2] = -1\n        jac[row_idx, 3*j_tri+2] = -1\n        return jac\n\n    def get_valid_score(X, final=False):\n        # Robustly project solution to feasible space and compute the score\n        x, y, r = X[0::3].copy(), X[1::3].copy(), X[2::3].copy()\n        x = np.clip(x, 0, 1)\n        y = np.clip(y, 0, 1)\n        r = np.maximum(r, 0)\n        \n        # Boundary constraints check\n        r = np.minimum(r, x)\n        r = np.minimum(r, 1.0 - x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1.0 - y)\n        \n        # Overlap constraints: iterative proportional shrinkage\n        max_iters = 1000 if final else 400\n        for _ in range(max_iters):\n            changed = False\n            dx = x[i_tri] - x[j_tri]\n            dy = y[i_tri] - y[j_tri]\n            d = np.sqrt(dx*dx + dy*dy)\n            s_r = r[i_tri] + r[j_tri]\n            overlap = s_r - d\n            \n            # Find indices where overlap occurs\n            viol_mask = overlap > 1e-14\n            if np.any(viol_mask):\n                for k in np.where(viol_mask)[0]:\n                    i, j = i_tri[k], j_tri[k]\n                    ov = (r[i] + r[j]) - np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                    if ov > 0:\n                        ratio_i = r[i] / (r[i] + r[j]) if (r[i] + r[j]) > 1e-15 else 0.5\n                        r[i] -= ov * ratio_i\n                        r[j] -= ov * (1.0 - ratio_i)\n                        changed = True\n            if not changed: break\n        return np.sum(r), np.stack((x, y), axis=1), r\n\n    # Optimization setup\n    cons = {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints}\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    \n    # Starting Guess: 5x5 grid + 1 circle\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    gx, gy = np.meshgrid(grid_coords, grid_coords)\n    X_grid = np.zeros(3*N)\n    X_grid[0:75:3] = gx.flatten()\n    X_grid[1:75:3] = gy.flatten()\n    X_grid[2:75:3] = 0.09\n    X_grid[75:78] = [0.5, 0.5, 0.02]\n    \n    best_X = X_grid.copy()\n    best_score = -1.0\n    \n    attempt = 0\n    while time.time() - start_time < 285:\n        # Determine starting point for this iteration\n        if attempt == 0:\n            start_X = X_grid.copy()\n        elif attempt == 1:\n            start_X = X_grid.copy()\n            start_X[75:78] = [0.2, 0.2, 0.02]\n        elif attempt % 7 == 0:\n            # Completely random start\n            start_X = np.random.rand(3*N)\n            start_X[2::3] = 0.05\n        else:\n            # Shaking: perturb best solution found so far\n            elapsed = time.time() - start_time\n            # Intensity decreases as time runs out\n            intensity = 0.03 * (1.0 - elapsed / 300.0) + 0.001\n            start_X = best_X + np.random.normal(0, intensity, 3*N)\n            # Extra jitter on radii to escape local optima\n            start_X[2::3] += np.random.normal(0, intensity * 0.3, N)\n            # Occasional teleportation of one circle\n            if np.random.rand() < 0.15:\n                idx = np.random.randint(N)\n                start_X[3*idx:3*idx+2] = np.random.rand(2)\n                start_X[3*idx+2] = 0.05\n\n        # Optimization using SLSQP\n        res = minimize(objective, start_X, jac=jac_objective, method='SLSQP', \n                       constraints=cons, bounds=bounds,\n                       options={'maxiter': 300, 'ftol': 1e-10})\n        \n        # Check if this result is the best so far\n        current_score, _, _ = get_valid_score(res.x)\n        if current_score > best_score:\n            best_score = current_score\n            best_X = res.x\n        \n        attempt += 1\n\n    # Final polish of the best solution with tighter tolerance\n    res = minimize(objective, best_X, jac=jac_objective, method='SLSQP', \n                   constraints=cons, bounds=bounds,\n                   options={'maxiter': 800, 'ftol': 1e-12})\n    \n    # Ensure final result is strictly feasible and calculate final sum\n    final_sum, final_centers, final_radii = get_valid_score(res.x, final=True)\n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, total_r = run_packing()\n    print(f\"Total Sum of Radii: {total_r}\")",
  "metrics": {
    "valid": true,
    "score": 2.63097226765298,
    "eval_time": 285.8863642215729,
    "error": null
  },
  "prompt": "Improve the following code (score 2.6359830849175854). Focus on increasing the number of random restarts and using a more precise tolerance in the SLSQP optimizer. Also, try a small jitter on the radii during optimization to escape local optima.\n\nCode:\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP with vectorized Jacobian and a shaking procedure.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n\n    def objective(X):\n        # Minimize the negative sum of radii to maximize the sum.\n        return -np.sum(X[2::3])\n\n    def jac_objective(X):\n        # Gradient of the objective: -1 for each radius, 0 for centers.\n        j = np.zeros(len(X))\n        j[2::3] = -1.0\n        return j\n\n    def constraints(X):\n        # Vectorized non-linear constraints for SLSQP.\n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        # Overlap constraints: dist(i, j) - (ri + rj) >= 0\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        \n        c_boundary = np.zeros(4 * N)\n        c_boundary[0::4] = x - r\n        c_boundary[1::4] = 1.0 - x - r\n        c_boundary[2::4] = y - r\n        c_boundary[3::4] = 1.0 - y - r\n        \n        i, j = np.triu_indices(N, k=1)\n        dx = x[i] - x[j]\n        dy = y[i] - y[j]\n        dists = np.sqrt(dx*dx + dy*dy + 1e-15)\n        c_overlap = dists - (r[i] + r[j])\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    def jac_constraints(X):\n        # Vectorized Jacobian of the constraints.\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        i, j = np.triu_indices(N, k=1)\n        num_overlaps = len(i)\n        \n        jac = np.zeros((4 * N + num_overlaps, 3 * N))\n        \n        # Boundary constraints derivatives\n        for k in range(N):\n            jac[4*k, 3*k] = 1; jac[4*k, 3*k+2] = -1\n            jac[4*k+1, 3*k] = -1; jac[4*k+1, 3*k+2] = -1\n            jac[4*k+2, 3*k+1] = 1; jac[4*k+2, 3*k+2] = -1\n            jac[4*k+3, 3*k+1] = -1; jac[4*k+3, 3*k+2] = -1\n            \n        # Overlap constraints derivatives\n        dx = x[i] - x[j]\n        dy = y[i] - y[j]\n        dists = np.sqrt(dx*dx + dy*dy + 1e-15)\n        \n        row_indices = np.arange(num_overlaps) + 4 * N\n        jac[row_indices, 3*i] = dx / dists\n        jac[row_indices, 3*j] = -dx / dists\n        jac[row_indices, 3*i+1] = dy / dists\n        jac[row_indices, 3*j+1] = -dy / dists\n        jac[row_indices, 3*i+2] = -1\n        jac[row_indices, 3*j+2] = -1\n        \n        return jac\n\n    def get_valid_score(X):\n        # Robustly project the solution to the feasible region and compute the score.\n        x, y, r = X[0::3].copy(), X[1::3].copy(), X[2::3].copy()\n        x = np.clip(x, 0, 1)\n        y = np.clip(y, 0, 1)\n        r = np.maximum(r, 0)\n        \n        # Satisfy boundary constraints\n        r = np.minimum(r, x)\n        r = np.minimum(r, 1.0 - x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1.0 - y)\n        \n        # Satisfy overlap constraints using iterative shrinking\n        for _ in range(200):\n            changed = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    d = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                    if r[i] + r[j] > d:\n                        overlap = (r[i] + r[j]) - d\n                        if r[i] + r[j] > 1e-12:\n                            ratio = r[i] / (r[i] + r[j])\n                            r[i] -= overlap * ratio\n                            r[j] -= overlap * (1.0 - ratio)\n                        else:\n                            r[i] = r[j] = 0\n                        changed = True\n            if not changed:\n                break\n        return np.sum(r), np.stack((x, y), axis=1), r\n\n    # Initial Guesses\n    cons = {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints}\n    \n    # 1. 5x5 grid + 1 circle\n    x_g, y_g = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    X1 = np.zeros(3*N)\n    X1[0:75:3] = x_g.flatten()\n    X1[1:75:3] = y_g.flatten()\n    X1[2:75:3] = 0.09\n    X1[75], X1[76], X1[77] = 0.5, 0.5, 0.02\n    \n    # Randomly perturb to break symmetry\n    X1[0::3] += np.random.normal(0, 0.005, N)\n    X1[1::3] += np.random.normal(0, 0.005, N)\n    \n    # Initial optimization\n    res = minimize(objective, X1, jac=jac_objective, method='SLSQP', constraints=cons, \n                   options={'maxiter': 400, 'ftol': 1e-10})\n    \n    best_X = res.x\n    best_score, _, _ = get_valid_score(best_X)\n\n    # Shaking and re-optimization loop\n    while time.time() - start_time < 280:\n        # Decrease shake intensity over time\n        elapsed = time.time() - start_time\n        intensity = 0.04 * (1.0 - elapsed / 300.0)\n        \n        X_shaken = best_X.copy()\n        X_shaken += np.random.normal(0, intensity, 3*N)\n        \n        # Teleport one random circle occasionally\n        if np.random.rand() < 0.2:\n            idx = np.random.randint(0, N)\n            X_shaken[3*idx] = np.random.rand()\n            X_shaken[3*idx+1] = np.random.rand()\n            X_shaken[3*idx+2] = 0.05\n            \n        X_shaken[0::3] = np.clip(X_shaken[0::3], 0, 1)\n        X_shaken[1::3] = np.clip(X_shaken[1::3], 0, 1)\n        X_shaken[2::3] = np.clip(X_shaken[2::3], 0, 0.5)\n        \n        res = minimize(objective, X_shaken, jac=jac_objective, method='SLSQP', constraints=cons, \n                       options={'maxiter': 200, 'ftol': 1e-9})\n        \n        current_score, _, _ = get_valid_score(res.x)\n        if current_score > best_score:\n            best_score = current_score\n            best_X = res.x\n\n    final_sum, final_centers, final_radii = get_valid_score(best_X)\n    return final_centers, final_radii, final_sum",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP with vectorized Jacobian and a shaking procedure to find \n    high-quality packings.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Precompute indices for vectorized operations\n    i_tri, j_tri = np.triu_indices(N, k=1)\n    num_overlaps = len(i_tri)\n    \n    def objective(X):\n        # Minimize negative sum of radii to maximize the sum\n        return -np.sum(X[2::3])\n\n    def jac_objective(X):\n        # Gradient: -1 for each radius, 0 for centers\n        j = np.zeros(len(X))\n        j[2::3] = -1.0\n        return j\n\n    def constraints(X):\n        # Boundary and non-overlap constraints\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        c = np.zeros(4 * N + num_overlaps)\n        # Boundary: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c[0:4*N:4] = x - r\n        c[1:4*N:4] = 1.0 - x - r\n        c[2:4*N:4] = y - r\n        c[3:4*N:4] = 1.0 - y - r\n        # Overlap: distance(i,j) - (ri + rj) >= 0\n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        c[4*N:] = np.sqrt(dx*dx + dy*dy + 1e-15) - (r[i_tri] + r[j_tri])\n        return c\n\n    def jac_constraints(X):\n        # Jacobian of the boundary and overlap constraints\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        jac = np.zeros((4 * N + num_overlaps, 3 * N))\n        \n        idx_N = np.arange(N)\n        # Boundary constraints derivatives\n        jac[4*idx_N, 3*idx_N] = 1\n        jac[4*idx_N, 3*idx_N+2] = -1\n        jac[4*idx_N+1, 3*idx_N] = -1\n        jac[4*idx_N+1, 3*idx_N+2] = -1\n        jac[4*idx_N+2, 3*idx_N+1] = 1\n        jac[4*idx_N+2, 3*idx_N+2] = -1\n        jac[4*idx_N+3, 3*idx_N+1] = -1\n        jac[4*idx_N+3, 3*idx_N+2] = -1\n        \n        # Overlap constraints derivatives\n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        dists = np.sqrt(dx*dx + dy*dy + 1e-15)\n        \n        row_idx = np.arange(num_overlaps) + 4 * N\n        jac[row_idx, 3*i_tri] = dx / dists\n        jac[row_idx, 3*j_tri] = -dx / dists\n        jac[row_idx, 3*i_tri+1] = dy / dists\n        jac[row_idx, 3*j_tri+1] = -dy / dists\n        jac[row_idx, 3*i_tri+2] = -1\n        jac[row_idx, 3*j_tri+2] = -1\n        return jac\n\n    def get_valid_score(X, final=False):\n        # Robustly project solution to feasible space and compute the score\n        x, y, r = X[0::3].copy(), X[1::3].copy(), X[2::3].copy()\n        x = np.clip(x, 0, 1)\n        y = np.clip(y, 0, 1)\n        r = np.maximum(r, 0)\n        \n        # Boundary constraints check\n        r = np.minimum(r, x)\n        r = np.minimum(r, 1.0 - x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1.0 - y)\n        \n        # Overlap constraints: iterative proportional shrinkage\n        max_iters = 1000 if final else 400\n        for _ in range(max_iters):\n            changed = False\n            dx = x[i_tri] - x[j_tri]\n            dy = y[i_tri] - y[j_tri]\n            d = np.sqrt(dx*dx + dy*dy)\n            s_r = r[i_tri] + r[j_tri]\n            overlap = s_r - d\n            \n            # Find indices where overlap occurs\n            viol_mask = overlap > 1e-14\n            if np.any(viol_mask):\n                for k in np.where(viol_mask)[0]:\n                    i, j = i_tri[k], j_tri[k]\n                    ov = (r[i] + r[j]) - np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                    if ov > 0:\n                        ratio_i = r[i] / (r[i] + r[j]) if (r[i] + r[j]) > 1e-15 else 0.5\n                        r[i] -= ov * ratio_i\n                        r[j] -= ov * (1.0 - ratio_i)\n                        changed = True\n            if not changed: break\n        return np.sum(r), np.stack((x, y), axis=1), r\n\n    # Optimization setup\n    cons = {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints}\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    \n    # Starting Guess: 5x5 grid + 1 circle\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    gx, gy = np.meshgrid(grid_coords, grid_coords)\n    X_grid = np.zeros(3*N)\n    X_grid[0:75:3] = gx.flatten()\n    X_grid[1:75:3] = gy.flatten()\n    X_grid[2:75:3] = 0.09\n    X_grid[75:78] = [0.5, 0.5, 0.02]\n    \n    best_X = X_grid.copy()\n    best_score = -1.0\n    \n    attempt = 0\n    while time.time() - start_time < 285:\n        # Determine starting point for this iteration\n        if attempt == 0:\n            start_X = X_grid.copy()\n        elif attempt == 1:\n            start_X = X_grid.copy()\n            start_X[75:78] = [0.2, 0.2, 0.02]\n        elif attempt % 7 == 0:\n            # Completely random start\n            start_X = np.random.rand(3*N)\n            start_X[2::3] = 0.05\n        else:\n            # Shaking: perturb best solution found so far\n            elapsed = time.time() - start_time\n            # Intensity decreases as time runs out\n            intensity = 0.03 * (1.0 - elapsed / 300.0) + 0.001\n            start_X = best_X + np.random.normal(0, intensity, 3*N)\n            # Extra jitter on radii to escape local optima\n            start_X[2::3] += np.random.normal(0, intensity * 0.3, N)\n            # Occasional teleportation of one circle\n            if np.random.rand() < 0.15:\n                idx = np.random.randint(N)\n                start_X[3*idx:3*idx+2] = np.random.rand(2)\n                start_X[3*idx+2] = 0.05\n\n        # Optimization using SLSQP\n        res = minimize(objective, start_X, jac=jac_objective, method='SLSQP', \n                       constraints=cons, bounds=bounds,\n                       options={'maxiter': 300, 'ftol': 1e-10})\n        \n        # Check if this result is the best so far\n        current_score, _, _ = get_valid_score(res.x)\n        if current_score > best_score:\n            best_score = current_score\n            best_X = res.x\n        \n        attempt += 1\n\n    # Final polish of the best solution with tighter tolerance\n    res = minimize(objective, best_X, jac=jac_objective, method='SLSQP', \n                   constraints=cons, bounds=bounds,\n                   options={'maxiter': 800, 'ftol': 1e-12})\n    \n    # Ensure final result is strictly feasible and calculate final sum\n    final_sum, final_centers, final_radii = get_valid_score(res.x, final=True)\n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, total_r = run_packing()\n    print(f\"Total Sum of Radii: {total_r}\")\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:50:29.985173",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2435,
        "candidates_token_count": 2424,
        "thoughts_token_count": 18500
      },
      "response_text_len": 6470
    }
  },
  "llm_call_duration_s": 119.57735895807855,
  "eval_duration_s": 285.8863715280313
}