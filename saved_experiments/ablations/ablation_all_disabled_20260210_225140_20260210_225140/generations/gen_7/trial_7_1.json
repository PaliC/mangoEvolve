{
  "trial_id": "trial_7_1",
  "generation": 7,
  "parent_id": "trial_6_0",
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping, minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Basin-Hopping with SLSQP as the local minimizer.\n    \"\"\"\n    n = 26\n\n    # Objective function: Minimize the negative sum of radii to maximize the sum\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    # Jacobian of the objective function\n    def objective_jac(v):\n        jac = np.zeros(len(v))\n        jac[2::3] = -1\n        return jac\n\n    # Constraint function: Inside square and no overlap\n    def constraints_func(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        n_circles = len(x)\n        # Boundary constraints: x - r >= 0, 1 - x - r >= 0, y - r >= 0, 1 - y - r >= 0\n        c_bound = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        c_overlap = np.zeros(n_circles * (n_circles - 1) // 2)\n        idx = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                c_overlap[idx] = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n                idx += 1\n        return np.concatenate([c_bound, c_overlap])\n\n    # Jacobian of the constraints\n    def constraints_jac(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        n_circles = len(x)\n        num_cons = 4 * n_circles + n_circles * (n_circles - 1) // 2\n        jac = np.zeros((num_cons, 3 * n_circles))\n        \n        # Boundary constraints Jacobian\n        for i in range(n_circles):\n            jac[i, 3*i] = 1; jac[i, 3*i+2] = -1\n            jac[n_circles+i, 3*i] = -1; jac[n_circles+i, 3*i+2] = -1\n            jac[2*n_circles+i, 3*i+1] = 1; jac[2*n_circles+i, 3*i+2] = -1\n            jac[3*n_circles+i, 3*i+1] = -1; jac[3*n_circles+i, 3*i+2] = -1\n            \n        # Overlap constraints Jacobian\n        idx = 4 * n_circles\n        for i in range(n_circles):\n            j = np.arange(i + 1, n_circles)\n            if len(j) == 0:\n                continue\n            dx = x[i] - x[j]\n            dy = y[i] - y[j]\n            sr = r[i] + r[j]\n            row_indices = idx + np.arange(len(j))\n            \n            jac[row_indices, 3*i] = 2 * dx\n            jac[row_indices, 3*j] = -2 * dx\n            jac[row_indices, 3*i+1] = 2 * dy\n            jac[row_indices, 3*j+1] = -2 * dy\n            jac[row_indices, 3*i+2] = -2 * sr\n            jac[row_indices, 3*j+2] = -2 * sr\n            idx += len(j)\n        return jac\n\n    # Custom step function for basin-hopping\n    class MyStep:\n        def __init__(self, stepsize=0.03):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            x_new = x.copy()\n            n_circles = len(x) // 3\n            # Jitter centers and radii\n            x_new[0::3] += np.random.uniform(-self.stepsize, self.stepsize, n_circles)\n            x_new[1::3] += np.random.uniform(-self.stepsize, self.stepsize, n_circles)\n            x_new[2::3] += np.random.uniform(-self.stepsize/2, self.stepsize/2, n_circles)\n            # Clipping to stay within plausible bounds\n            x_new[0::3] = np.clip(x_new[0::3], 0, 1)\n            x_new[1::3] = np.clip(x_new[1::3], 0, 1)\n            x_new[2::3] = np.clip(x_new[2::3], 0, 0.5)\n            return x_new\n\n    # Initial guess: 5x5 grid plus one circle in the corner\n    r_init = 0.08\n    coords = np.linspace(r_init + 0.01, 1 - r_init - 0.01, 5)\n    v0 = []\n    for i in range(5):\n        for j in range(5):\n            v0.extend([coords[i], coords[j], r_init])\n    v0.extend([0.98, 0.98, 0.01]) # 26th circle\n    v0 = np.array(v0)\n\n    # SLSQP minimizer configuration\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * n\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"jac\": objective_jac,\n        \"constraints\": {\"type\": \"ineq\", \"fun\": constraints_func, \"jac\": constraints_jac},\n        \"bounds\": bounds,\n        \"options\": {\"maxiter\": 200, \"ftol\": 1e-8}\n    }\n\n    # First local optimization from the grid\n    res = minimize(objective, v0, **minimizer_kwargs)\n    v0 = res.x\n\n    # Basin-hopping to explore the solution space\n    # Using a small number of iterations to ensure completion within 300 seconds\n    bh_res = basinhopping(objective, v0, \n                          minimizer_kwargs=minimizer_kwargs,\n                          niter=12, \n                          take_step=MyStep(0.04))\n\n    best_v = bh_res.x\n    centers = best_v.reshape(n, 3)[:, :2]\n    radii = best_v.reshape(n, 3)[:, 2]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.613545071860278,
    "eval_time": 1.6793968677520752,
    "error": null
  },
  "prompt": "Implement a Basin-Hopping algorithm for maximizing the sum of radii of 26 circles in a unit square. Use scipy.optimize.basinhopping with SLSQP as the local minimizer. Define a custom step function that moves centers and adjusts radii slightly. Ensure the constraints (no overlap, inside square) are strictly handled in the local minimization.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Basin-Hopping with SLSQP as the local minimizer.\n    \"\"\"\n    n = 26\n\n    # Objective function: Minimize the negative sum of radii to maximize the sum\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    # Jacobian of the objective function\n    def objective_jac(v):\n        jac = np.zeros(len(v))\n        jac[2::3] = -1\n        return jac\n\n    # Constraint function: Inside square and no overlap\n    def constraints_func(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        n_circles = len(x)\n        # Boundary constraints: x - r >= 0, 1 - x - r >= 0, y - r >= 0, 1 - y - r >= 0\n        c_bound = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        c_overlap = np.zeros(n_circles * (n_circles - 1) // 2)\n        idx = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                c_overlap[idx] = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n                idx += 1\n        return np.concatenate([c_bound, c_overlap])\n\n    # Jacobian of the constraints\n    def constraints_jac(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        n_circles = len(x)\n        num_cons = 4 * n_circles + n_circles * (n_circles - 1) // 2\n        jac = np.zeros((num_cons, 3 * n_circles))\n        \n        # Boundary constraints Jacobian\n        for i in range(n_circles):\n            jac[i, 3*i] = 1; jac[i, 3*i+2] = -1\n            jac[n_circles+i, 3*i] = -1; jac[n_circles+i, 3*i+2] = -1\n            jac[2*n_circles+i, 3*i+1] = 1; jac[2*n_circles+i, 3*i+2] = -1\n            jac[3*n_circles+i, 3*i+1] = -1; jac[3*n_circles+i, 3*i+2] = -1\n            \n        # Overlap constraints Jacobian\n        idx = 4 * n_circles\n        for i in range(n_circles):\n            j = np.arange(i + 1, n_circles)\n            if len(j) == 0:\n                continue\n            dx = x[i] - x[j]\n            dy = y[i] - y[j]\n            sr = r[i] + r[j]\n            row_indices = idx + np.arange(len(j))\n            \n            jac[row_indices, 3*i] = 2 * dx\n            jac[row_indices, 3*j] = -2 * dx\n            jac[row_indices, 3*i+1] = 2 * dy\n            jac[row_indices, 3*j+1] = -2 * dy\n            jac[row_indices, 3*i+2] = -2 * sr\n            jac[row_indices, 3*j+2] = -2 * sr\n            idx += len(j)\n        return jac\n\n    # Custom step function for basin-hopping\n    class MyStep:\n        def __init__(self, stepsize=0.03):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            x_new = x.copy()\n            n_circles = len(x) // 3\n            # Jitter centers and radii\n            x_new[0::3] += np.random.uniform(-self.stepsize, self.stepsize, n_circles)\n            x_new[1::3] += np.random.uniform(-self.stepsize, self.stepsize, n_circles)\n            x_new[2::3] += np.random.uniform(-self.stepsize/2, self.stepsize/2, n_circles)\n            # Clipping to stay within plausible bounds\n            x_new[0::3] = np.clip(x_new[0::3], 0, 1)\n            x_new[1::3] = np.clip(x_new[1::3], 0, 1)\n            x_new[2::3] = np.clip(x_new[2::3], 0, 0.5)\n            return x_new\n\n    # Initial guess: 5x5 grid plus one circle in the corner\n    r_init = 0.08\n    coords = np.linspace(r_init + 0.01, 1 - r_init - 0.01, 5)\n    v0 = []\n    for i in range(5):\n        for j in range(5):\n            v0.extend([coords[i], coords[j], r_init])\n    v0.extend([0.98, 0.98, 0.01]) # 26th circle\n    v0 = np.array(v0)\n\n    # SLSQP minimizer configuration\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * n\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"jac\": objective_jac,\n        \"constraints\": {\"type\": \"ineq\", \"fun\": constraints_func, \"jac\": constraints_jac},\n        \"bounds\": bounds,\n        \"options\": {\"maxiter\": 200, \"ftol\": 1e-8}\n    }\n\n    # First local optimization from the grid\n    res = minimize(objective, v0, **minimizer_kwargs)\n    v0 = res.x\n\n    # Basin-hopping to explore the solution space\n    # Using a small number of iterations to ensure completion within 300 seconds\n    bh_res = basinhopping(objective, v0, \n                          minimizer_kwargs=minimizer_kwargs,\n                          niter=12, \n                          take_step=MyStep(0.04))\n\n    best_v = bh_res.x\n    centers = best_v.reshape(n, 3)[:, :2]\n    radii = best_v.reshape(n, 3)[:, 2]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:45:42.217170",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 299,
        "candidates_token_count": 1707,
        "thoughts_token_count": 19497
      },
      "response_text_len": 4609
    }
  },
  "llm_call_duration_s": 116.02108194900211,
  "eval_duration_s": 1.6794066219590604
}