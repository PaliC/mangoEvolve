{
  "trial_id": "trial_7_5",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution, minimize\nfrom scipy.spatial.distance import pdist\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Differential Evolution for global search of circle centers and SLSQP for local refinement.\n    \"\"\"\n    n = 26\n\n    def de_objective(coords):\n        \"\"\"\n        Objective function for Differential Evolution.\n        Determines the maximum possible equal radius r for a given set of centers.\n        Maximizing r is equivalent to maximizing the sum of radii for equal circles.\n        \"\"\"\n        c = coords.reshape((n, 2))\n        # Boundary constraints: circles must be within [0, 1] x [0, 1]\n        # For equal radii, r <= x_i, r <= 1-x_i, r <= y_i, r <= 1-y_i\n        r_boundary = min(np.min(c), np.min(1 - c))\n        \n        # Collision constraints: distance between centers must be at least 2r\n        # r <= dist_ij / 2\n        dists = pdist(c)\n        if len(dists) == 0:\n            r_collision = 0.0\n        else:\n            r_collision = np.min(dists) / 2.0\n            \n        # Differential Evolution minimizes, so we return -min(r_boundary, r_collision)\n        return -min(r_boundary, r_collision)\n\n    # 1. Global search for circle centers using Differential Evolution\n    # We optimize for 2*n variables (x and y coordinates for each circle)\n    bounds_de = [(0, 1)] * (2 * n)\n    \n    # Differential Evolution parameters chosen to balance speed and robustness\n    res_de = differential_evolution(\n        de_objective,\n        bounds_de,\n        popsize=15,       # Total population = 15 * 52 = 780 individuals\n        maxiter=500,      # Maximum number of generations\n        strategy='best1bin',\n        polish=False,     # We will do our own polish with SLSQP\n        tol=1e-7\n    )\n\n    # 2. Local refinement using SLSQP\n    # Starting configuration: best centers from DE and equal radii\n    best_r = -res_de.fun\n    # Initial parameters: [x1, y1, x2, y2, ..., x26, y26, r1, r2, ..., r26] (Total 78 variables)\n    x0 = np.concatenate([res_de.x, [best_r] * n])\n\n    def objective_sum_r(params):\n        \"\"\"Negative sum of radii to be minimized by SLSQP.\"\"\"\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints_unequal_r(params):\n        \"\"\"\n        Non-linear constraints for the circle packing problem:\n        1. Circles must be inside the unit square.\n        2. Circles must not overlap.\n        \"\"\"\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        # These ensure the circles are contained within the square [0,1]x[0,1]\n        c_boundary = np.concatenate([\n            (c - r[:, np.newaxis]).flatten(),\n            (1 - c - r[:, np.newaxis]).flatten()\n        ])\n        \n        # No-overlap constraints: dist_ij >= r_i + r_j\n        # We use squared distances for efficiency and stability: dist_ij^2 - (r_i + r_j)^2 >= 0\n        dist_sq = pdist(c, 'sqeuclidean')\n        r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n        r_sum_sq = r_sum[np.triu_indices(n, k=1)]**2\n        c_collision = dist_sq - r_sum_sq\n        \n        return np.concatenate([c_boundary, c_collision])\n\n    # Variable bounds: centers in [0, 1], radii in [0, 0.5]\n    bounds_slsqp = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    # Polishing step with SLSQP allows individual radii to vary to maximize the total sum\n    res_slsqp = minimize(\n        objective_sum_r,\n        x0,\n        method='SLSQP',\n        bounds=bounds_slsqp,\n        constraints={'type': 'ineq', 'fun': constraints_unequal_r},\n        options={'maxiter': 2000, 'ftol': 1e-12}\n    )\n\n    # 3. Prepare final results\n    final_params = res_slsqp.x\n    centers = final_params[:2*n].reshape((n, 2))\n    radii = final_params[2*n:]\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6121743894726173,
    "eval_time": 28.1819748878479,
    "error": null
  },
  "prompt": "Use scipy.optimize.differential_evolution to find a good starting configuration for the 26-circle packing problem (maximizing sum of radii). Since DE is slow, use a small population and low maxiter, then polish the best member of the population using SLSQP.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution, minimize\nfrom scipy.spatial.distance import pdist\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Differential Evolution for global search of circle centers and SLSQP for local refinement.\n    \"\"\"\n    n = 26\n\n    def de_objective(coords):\n        \"\"\"\n        Objective function for Differential Evolution.\n        Determines the maximum possible equal radius r for a given set of centers.\n        Maximizing r is equivalent to maximizing the sum of radii for equal circles.\n        \"\"\"\n        c = coords.reshape((n, 2))\n        # Boundary constraints: circles must be within [0, 1] x [0, 1]\n        # For equal radii, r <= x_i, r <= 1-x_i, r <= y_i, r <= 1-y_i\n        r_boundary = min(np.min(c), np.min(1 - c))\n        \n        # Collision constraints: distance between centers must be at least 2r\n        # r <= dist_ij / 2\n        dists = pdist(c)\n        if len(dists) == 0:\n            r_collision = 0.0\n        else:\n            r_collision = np.min(dists) / 2.0\n            \n        # Differential Evolution minimizes, so we return -min(r_boundary, r_collision)\n        return -min(r_boundary, r_collision)\n\n    # 1. Global search for circle centers using Differential Evolution\n    # We optimize for 2*n variables (x and y coordinates for each circle)\n    bounds_de = [(0, 1)] * (2 * n)\n    \n    # Differential Evolution parameters chosen to balance speed and robustness\n    res_de = differential_evolution(\n        de_objective,\n        bounds_de,\n        popsize=15,       # Total population = 15 * 52 = 780 individuals\n        maxiter=500,      # Maximum number of generations\n        strategy='best1bin',\n        polish=False,     # We will do our own polish with SLSQP\n        tol=1e-7\n    )\n\n    # 2. Local refinement using SLSQP\n    # Starting configuration: best centers from DE and equal radii\n    best_r = -res_de.fun\n    # Initial parameters: [x1, y1, x2, y2, ..., x26, y26, r1, r2, ..., r26] (Total 78 variables)\n    x0 = np.concatenate([res_de.x, [best_r] * n])\n\n    def objective_sum_r(params):\n        \"\"\"Negative sum of radii to be minimized by SLSQP.\"\"\"\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints_unequal_r(params):\n        \"\"\"\n        Non-linear constraints for the circle packing problem:\n        1. Circles must be inside the unit square.\n        2. Circles must not overlap.\n        \"\"\"\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        # These ensure the circles are contained within the square [0,1]x[0,1]\n        c_boundary = np.concatenate([\n            (c - r[:, np.newaxis]).flatten(),\n            (1 - c - r[:, np.newaxis]).flatten()\n        ])\n        \n        # No-overlap constraints: dist_ij >= r_i + r_j\n        # We use squared distances for efficiency and stability: dist_ij^2 - (r_i + r_j)^2 >= 0\n        dist_sq = pdist(c, 'sqeuclidean')\n        r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n        r_sum_sq = r_sum[np.triu_indices(n, k=1)]**2\n        c_collision = dist_sq - r_sum_sq\n        \n        return np.concatenate([c_boundary, c_collision])\n\n    # Variable bounds: centers in [0, 1], radii in [0, 0.5]\n    bounds_slsqp = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    # Polishing step with SLSQP allows individual radii to vary to maximize the total sum\n    res_slsqp = minimize(\n        objective_sum_r,\n        x0,\n        method='SLSQP',\n        bounds=bounds_slsqp,\n        constraints={'type': 'ineq', 'fun': constraints_unequal_r},\n        options={'maxiter': 2000, 'ftol': 1e-12}\n    )\n\n    # 3. Prepare final results\n    final_params = res_slsqp.x\n    centers = final_params[:2*n].reshape((n, 2))\n    radii = final_params[2*n:]\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:46:00.579184",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 283,
        "candidates_token_count": 1259,
        "thoughts_token_count": 17869
      },
      "response_text_len": 3966
    }
  },
  "llm_call_duration_s": 107.87558574706782,
  "eval_duration_s": 28.181983507005498
}