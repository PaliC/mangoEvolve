{
  "trial_id": "trial_7_2",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid approach: grid-based and random initializations, force-directed relaxation,\n    and SLSQP optimization.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for non-overlap constraints\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = len(i_idx)\n    num_c = 4 * n + num_overlap\n\n    def get_seeds():\n        \"\"\"Generates various initial circle center configurations.\"\"\"\n        seeds = []\n        # Seed 1: 5x5 grid plus one circle in the center\n        grid = np.linspace(0.1, 0.9, 5)\n        c1 = np.array([[x, y] for x in grid for y in grid])\n        c1 = np.vstack([c1, [0.5, 0.5]])\n        seeds.append(c1 + np.random.uniform(-0.01, 0.01, c1.shape))\n        \n        # Seed 2: 6x5 grid minus four corners\n        xs = np.linspace(0.1, 0.9, 6)\n        ys = np.linspace(0.1, 0.9, 5)\n        c2 = np.array([[x, y] for i, x in enumerate(xs) for j, y in enumerate(ys) \n                      if not ((i == 0 or i == 5) and (j == 0 or j == 4))])\n        seeds.append(c2 + np.random.uniform(-0.01, 0.01, c2.shape))\n        \n        # Seed 3: 5x6 grid minus four corners\n        xs = np.linspace(0.1, 0.9, 5)\n        ys = np.linspace(0.1, 0.9, 6)\n        c3 = np.array([[x, y] for i, x in enumerate(xs) for j, y in enumerate(ys) \n                      if not ((i == 0 or i == 4) and (j == 0 or j == 5))])\n        seeds.append(c3 + np.random.uniform(-0.01, 0.01, c3.shape))\n        \n        # Seed 4: Random placement with force-directed relaxation\n        c4 = np.random.rand(n, 2)\n        for _ in range(200):\n            diff = c4[:, np.newaxis, :] - c4[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, 1.0)\n            force_mag = 1.0 / (dist**2 + 0.01)\n            np.fill_diagonal(force_mag, 0)\n            forces = np.sum(diff * (force_mag / dist)[:, :, np.newaxis], axis=1)\n            c4 += forces * 0.001\n            c4 = np.clip(c4, 0.1, 0.9)\n        seeds.append(c4)\n        \n        return seeds\n\n    def constraints_vectorized(p_flat):\n        \"\"\"Calculates boundary and non-overlap constraints (all must be >= 0).\"\"\"\n        p = p_flat.reshape((n, 3))\n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0::4] = p[:, 0] - p[:, 2]\n        c_boundary[1::4] = 1.0 - p[:, 0] - p[:, 2]\n        c_boundary[2::4] = p[:, 1] - p[:, 2]\n        c_boundary[3::4] = 1.0 - p[:, 1] - p[:, 2]\n        \n        # Non-overlap constraints: dist^2 - (r1+r2)^2 >= 0\n        dx = p[i_idx, 0] - p[j_idx, 0]\n        dy = p[i_idx, 1] - p[j_idx, 1]\n        dr = p[i_idx, 2] + p[j_idx, 2]\n        c_overlap = dx**2 + dy**2 - dr**2\n        return np.concatenate([c_boundary, c_overlap])\n\n    def constraints_jac_vectorized(p_flat):\n        \"\"\"Calculates the Jacobian of the constraints.\"\"\"\n        p = p_flat.reshape((n, 3))\n        jac = np.zeros((num_c, 3 * n))\n        # Boundary jacobian\n        for i in range(n):\n            jac[4*i, 3*i] = 1.0; jac[4*i, 3*i+2] = -1.0\n            jac[4*i+1, 3*i] = -1.0; jac[4*i+1, 3*i+2] = -1.0\n            jac[4*i+2, 3*i+1] = 1.0; jac[4*i+2, 3*i+2] = -1.0\n            jac[4*i+3, 3*i+1] = -1.0; jac[4*i+3, 3*i+2] = -1.0\n        # Overlap jacobian\n        dx = p[i_idx, 0] - p[j_idx, 0]\n        dy = p[i_idx, 1] - p[j_idx, 1]\n        dr = p[i_idx, 2] + p[j_idx, 2]\n        row_idx = 4 * n + np.arange(num_overlap)\n        jac[row_idx, 3*i_idx] = 2.0 * dx\n        jac[row_idx, 3*j_idx] = -2.0 * dx\n        jac[row_idx, 3*i_idx+1] = 2.0 * dy\n        jac[row_idx, 3*j_idx+1] = -2.0 * dy\n        jac[row_idx, 3*i_idx+2] = -2.0 * dr\n        jac[row_idx, 3*j_idx+2] = -2.0 * dr\n        return jac\n\n    # Objective: Minimize negative sum of radii to maximize sum\n    obj_jac = np.tile([0.0, 0.0, -1.0], n)\n\n    best_params = (np.random.rand(n, 2), np.zeros(n))\n    best_sum = 0\n    \n    seeds = get_seeds()\n    for seed in seeds:\n        if time.time() - start_time > 260:\n            break\n            \n        # Initial guess: centers from seed, small initial radius\n        x0 = np.zeros(3 * n)\n        x0[0::3] = np.clip(seed[:, 0], 0.05, 0.95)\n        x0[1::3] = np.clip(seed[:, 1], 0.05, 0.95)\n        x0[2::3] = 0.05\n        \n        res = minimize(lambda p: -np.sum(p[2::3]), x0, method='SLSQP',\n                       jac=lambda p: obj_jac,\n                       constraints={'type': 'ineq', 'fun': constraints_vectorized, 'jac': constraints_jac_vectorized},\n                       bounds=[(0, 1)] * (3 * n),\n                       options={'maxiter': 400})\n        \n        # Extract and post-process parameters to ensure strict feasibility\n        p_opt = res.x.reshape((n, 3))\n        c, r = p_opt[:, :2], p_opt[:, 2].copy()\n        \n        # Strictly enforce boundaries\n        for i in range(n):\n            r[i] = min(r[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n            r[i] = max(0, r[i] - 1e-13)\n            \n        # Strictly enforce non-overlap iteratively\n        for _ in range(30):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.sqrt(np.sum((c[i] - c[j])**2))\n                    if d < r[i] + r[j] + 1e-14:\n                        overlap = (r[i] + r[j] - d) / 2.0\n                        r[i] -= overlap + 1e-14\n                        r[j] -= overlap + 1e-14\n            r = np.maximum(r, 0)\n            \n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_params = (c.copy(), r.copy())\n\n    return best_params[0], best_params[1], best_sum",
  "metrics": {
    "valid": true,
    "score": 2.619835584938953,
    "eval_time": 0.8471024036407471,
    "error": null
  },
  "prompt": "Create a hybrid approach: first, use a force-directed (repulsion) simulation where circles are treated as particles that expand until they hit boundaries or each other. Then, take the resulting configuration and use it as an initial guess for scipy.optimize.minimize with the SLSQP method to maximize the sum of radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid approach: grid-based and random initializations, force-directed relaxation,\n    and SLSQP optimization.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for non-overlap constraints\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = len(i_idx)\n    num_c = 4 * n + num_overlap\n\n    def get_seeds():\n        \"\"\"Generates various initial circle center configurations.\"\"\"\n        seeds = []\n        # Seed 1: 5x5 grid plus one circle in the center\n        grid = np.linspace(0.1, 0.9, 5)\n        c1 = np.array([[x, y] for x in grid for y in grid])\n        c1 = np.vstack([c1, [0.5, 0.5]])\n        seeds.append(c1 + np.random.uniform(-0.01, 0.01, c1.shape))\n        \n        # Seed 2: 6x5 grid minus four corners\n        xs = np.linspace(0.1, 0.9, 6)\n        ys = np.linspace(0.1, 0.9, 5)\n        c2 = np.array([[x, y] for i, x in enumerate(xs) for j, y in enumerate(ys) \n                      if not ((i == 0 or i == 5) and (j == 0 or j == 4))])\n        seeds.append(c2 + np.random.uniform(-0.01, 0.01, c2.shape))\n        \n        # Seed 3: 5x6 grid minus four corners\n        xs = np.linspace(0.1, 0.9, 5)\n        ys = np.linspace(0.1, 0.9, 6)\n        c3 = np.array([[x, y] for i, x in enumerate(xs) for j, y in enumerate(ys) \n                      if not ((i == 0 or i == 4) and (j == 0 or j == 5))])\n        seeds.append(c3 + np.random.uniform(-0.01, 0.01, c3.shape))\n        \n        # Seed 4: Random placement with force-directed relaxation\n        c4 = np.random.rand(n, 2)\n        for _ in range(200):\n            diff = c4[:, np.newaxis, :] - c4[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, 1.0)\n            force_mag = 1.0 / (dist**2 + 0.01)\n            np.fill_diagonal(force_mag, 0)\n            forces = np.sum(diff * (force_mag / dist)[:, :, np.newaxis], axis=1)\n            c4 += forces * 0.001\n            c4 = np.clip(c4, 0.1, 0.9)\n        seeds.append(c4)\n        \n        return seeds\n\n    def constraints_vectorized(p_flat):\n        \"\"\"Calculates boundary and non-overlap constraints (all must be >= 0).\"\"\"\n        p = p_flat.reshape((n, 3))\n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0::4] = p[:, 0] - p[:, 2]\n        c_boundary[1::4] = 1.0 - p[:, 0] - p[:, 2]\n        c_boundary[2::4] = p[:, 1] - p[:, 2]\n        c_boundary[3::4] = 1.0 - p[:, 1] - p[:, 2]\n        \n        # Non-overlap constraints: dist^2 - (r1+r2)^2 >= 0\n        dx = p[i_idx, 0] - p[j_idx, 0]\n        dy = p[i_idx, 1] - p[j_idx, 1]\n        dr = p[i_idx, 2] + p[j_idx, 2]\n        c_overlap = dx**2 + dy**2 - dr**2\n        return np.concatenate([c_boundary, c_overlap])\n\n    def constraints_jac_vectorized(p_flat):\n        \"\"\"Calculates the Jacobian of the constraints.\"\"\"\n        p = p_flat.reshape((n, 3))\n        jac = np.zeros((num_c, 3 * n))\n        # Boundary jacobian\n        for i in range(n):\n            jac[4*i, 3*i] = 1.0; jac[4*i, 3*i+2] = -1.0\n            jac[4*i+1, 3*i] = -1.0; jac[4*i+1, 3*i+2] = -1.0\n            jac[4*i+2, 3*i+1] = 1.0; jac[4*i+2, 3*i+2] = -1.0\n            jac[4*i+3, 3*i+1] = -1.0; jac[4*i+3, 3*i+2] = -1.0\n        # Overlap jacobian\n        dx = p[i_idx, 0] - p[j_idx, 0]\n        dy = p[i_idx, 1] - p[j_idx, 1]\n        dr = p[i_idx, 2] + p[j_idx, 2]\n        row_idx = 4 * n + np.arange(num_overlap)\n        jac[row_idx, 3*i_idx] = 2.0 * dx\n        jac[row_idx, 3*j_idx] = -2.0 * dx\n        jac[row_idx, 3*i_idx+1] = 2.0 * dy\n        jac[row_idx, 3*j_idx+1] = -2.0 * dy\n        jac[row_idx, 3*i_idx+2] = -2.0 * dr\n        jac[row_idx, 3*j_idx+2] = -2.0 * dr\n        return jac\n\n    # Objective: Minimize negative sum of radii to maximize sum\n    obj_jac = np.tile([0.0, 0.0, -1.0], n)\n\n    best_params = (np.random.rand(n, 2), np.zeros(n))\n    best_sum = 0\n    \n    seeds = get_seeds()\n    for seed in seeds:\n        if time.time() - start_time > 260:\n            break\n            \n        # Initial guess: centers from seed, small initial radius\n        x0 = np.zeros(3 * n)\n        x0[0::3] = np.clip(seed[:, 0], 0.05, 0.95)\n        x0[1::3] = np.clip(seed[:, 1], 0.05, 0.95)\n        x0[2::3] = 0.05\n        \n        res = minimize(lambda p: -np.sum(p[2::3]), x0, method='SLSQP',\n                       jac=lambda p: obj_jac,\n                       constraints={'type': 'ineq', 'fun': constraints_vectorized, 'jac': constraints_jac_vectorized},\n                       bounds=[(0, 1)] * (3 * n),\n                       options={'maxiter': 400})\n        \n        # Extract and post-process parameters to ensure strict feasibility\n        p_opt = res.x.reshape((n, 3))\n        c, r = p_opt[:, :2], p_opt[:, 2].copy()\n        \n        # Strictly enforce boundaries\n        for i in range(n):\n            r[i] = min(r[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n            r[i] = max(0, r[i] - 1e-13)\n            \n        # Strictly enforce non-overlap iteratively\n        for _ in range(30):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.sqrt(np.sum((c[i] - c[j])**2))\n                    if d < r[i] + r[j] + 1e-14:\n                        overlap = (r[i] + r[j] - d) / 2.0\n                        r[i] -= overlap + 1e-14\n                        r[j] -= overlap + 1e-14\n            r = np.maximum(r, 0)\n            \n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_params = (c.copy(), r.copy())\n\n    return best_params[0], best_params[1], best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:46:10.623598",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 292,
        "candidates_token_count": 2294,
        "thoughts_token_count": 24307
      },
      "response_text_len": 5809
    }
  },
  "llm_call_duration_s": 145.26054099493194,
  "eval_duration_s": 0.847111196955666
}