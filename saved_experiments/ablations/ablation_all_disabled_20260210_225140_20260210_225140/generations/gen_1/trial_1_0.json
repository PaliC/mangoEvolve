{
  "trial_id": "trial_1_0",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP optimization with a grid-based and random initialization strategy.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    \n    # Pre-calculate indices for non-overlap constraints\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = n * (n - 1) // 2\n    num_boundary = 4 * n\n    \n    def create_v(x, y, r):\n        \"\"\"Helper to create the optimization variable vector.\"\"\"\n        v = np.zeros(3 * n)\n        v[0::3] = x\n        v[1::3] = y\n        v[2::3] = r\n        return v\n\n    def objective(v):\n        \"\"\"Maximize sum of radii -> minimize negative sum.\"\"\"\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(3 * n)\n        j[2::3] = -1.0\n        return j\n\n    def constraints_fn(v):\n        \"\"\"Non-overlap and boundary constraints.\"\"\"\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        \n        # Overlap constraints: (xi - xj)^2 + (yi - yj)^2 >= (ri + rj)^2\n        overlap = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        \n        # Boundary constraints: ri <= xi <= 1-ri and ri <= yi <= 1-ri\n        boundary = np.zeros(num_boundary)\n        boundary[0::4] = x - r\n        boundary[1::4] = 1.0 - x - r\n        boundary[2::4] = y - r\n        boundary[3::4] = 1.0 - y - r\n        \n        return np.concatenate([overlap, boundary])\n\n    def jac_constraints(v):\n        \"\"\"Jacobian of the constraints.\"\"\"\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        jac = np.zeros((num_overlap + num_boundary, 3 * n))\n        \n        # Non-overlap part\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        \n        idx = np.arange(num_overlap)\n        jac[idx, 3*i_idx] = 2 * dx\n        jac[idx, 3*j_idx] = -2 * dx\n        jac[idx, 3*i_idx+1] = 2 * dy\n        jac[idx, 3*j_idx+1] = -2 * dy\n        jac[idx, 3*i_idx+2] = -2 * dr\n        jac[idx, 3*j_idx+2] = -2 * dr\n        \n        # Boundary part\n        b_start = num_overlap\n        k = np.arange(n)\n        jac[b_start + 4*k, 3*k] = 1\n        jac[b_start + 4*k, 3*k+2] = -1\n        jac[b_start + 4*k + 1, 3*k] = -1\n        jac[b_start + 4*k + 1, 3*k+2] = -1\n        jac[b_start + 4*k + 2, 3*k+1] = 1\n        jac[b_start + 4*k + 2, 3*k+2] = -1\n        jac[b_start + 4*k + 3, 3*k+1] = -1\n        jac[b_start + 4*k + 3, 3*k+2] = -1\n        \n        return jac\n\n    # Define constraints and bounds for SLSQP\n    cons = {'type': 'ineq', 'fun': constraints_fn, 'jac': jac_constraints}\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * n\n    \n    # Generate initial guesses\n    inits = []\n    \n    # 1. 5x5 grid + 1 circle at various positions\n    x5 = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x5, x5)\n    x_base, y_base = xv.flatten(), yv.flatten()\n    for pos in [(0.5, 0.5), (0.01, 0.01), (0.99, 0.99), (0.01, 0.99), (0.99, 0.01)]:\n        inits.append(create_v(np.append(x_base, pos[0]), np.append(y_base, pos[1]), np.full(n, 0.095)))\n    \n    # 2. 6x5 grid and 5x6 grid\n    xs, ys = np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 6)\n    xv, yv = np.meshgrid(xs, ys)\n    inits.append(create_v(xv.flatten()[:n], yv.flatten()[:n], np.full(n, 0.08)))\n    \n    xs, ys = np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(xs, ys)\n    inits.append(create_v(xv.flatten()[:n], yv.flatten()[:n], np.full(n, 0.08)))\n    \n    # 3. Random initializations\n    np.random.seed(42)\n    for _ in range(2):\n        inits.append(create_v(np.random.rand(n), np.random.rand(n), np.full(n, 0.05)))\n\n    best_v, best_sum = inits[0], 0\n    \n    # Multi-start: Short runs to find promising regions\n    for init_v in inits:\n        if time.time() - start_time > 180:\n            break\n        res = minimize(objective, init_v, method='SLSQP', jac=jac_objective,\n                       constraints=cons, bounds=bounds, options={'maxiter': 80, 'ftol': 1e-6})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n            \n    # Final optimization: Long run to converge from the best starting point\n    res = minimize(objective, best_v, method='SLSQP', jac=jac_objective,\n                   constraints=cons, bounds=bounds, options={'maxiter': 1500, 'ftol': 1e-10})\n    \n    best_v = res.x\n    centers = np.column_stack((best_v[0::3], best_v[1::3]))\n    radii = best_v[2::3]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6159377689551357,
    "eval_time": 1.3025248050689697,
    "error": null
  },
  "prompt": "Strategy: Grid-based initialization with SLSQP optimization.\n        Initialize 26 circles in a 5x5 grid with one extra circle placed centrally. \n        Use scipy.optimize.minimize with the SLSQP method.\n        Variables: 26*3 (x, y, r).\n        Constraints:\n        1. x_i - r_i >= 0, x_i + r_i <= 1\n        2. y_i - r_i >= 0, y_i + r_i <= 1\n        3. dist(c_i, c_j) >= r_i + r_j\n        Objective: Maximize sum(radii).\n        Ensure the optimization runs until convergence or near the 300s timeout.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP optimization with a grid-based and random initialization strategy.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    \n    # Pre-calculate indices for non-overlap constraints\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = n * (n - 1) // 2\n    num_boundary = 4 * n\n    \n    def create_v(x, y, r):\n        \"\"\"Helper to create the optimization variable vector.\"\"\"\n        v = np.zeros(3 * n)\n        v[0::3] = x\n        v[1::3] = y\n        v[2::3] = r\n        return v\n\n    def objective(v):\n        \"\"\"Maximize sum of radii -> minimize negative sum.\"\"\"\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(3 * n)\n        j[2::3] = -1.0\n        return j\n\n    def constraints_fn(v):\n        \"\"\"Non-overlap and boundary constraints.\"\"\"\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        \n        # Overlap constraints: (xi - xj)^2 + (yi - yj)^2 >= (ri + rj)^2\n        overlap = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        \n        # Boundary constraints: ri <= xi <= 1-ri and ri <= yi <= 1-ri\n        boundary = np.zeros(num_boundary)\n        boundary[0::4] = x - r\n        boundary[1::4] = 1.0 - x - r\n        boundary[2::4] = y - r\n        boundary[3::4] = 1.0 - y - r\n        \n        return np.concatenate([overlap, boundary])\n\n    def jac_constraints(v):\n        \"\"\"Jacobian of the constraints.\"\"\"\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        jac = np.zeros((num_overlap + num_boundary, 3 * n))\n        \n        # Non-overlap part\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        \n        idx = np.arange(num_overlap)\n        jac[idx, 3*i_idx] = 2 * dx\n        jac[idx, 3*j_idx] = -2 * dx\n        jac[idx, 3*i_idx+1] = 2 * dy\n        jac[idx, 3*j_idx+1] = -2 * dy\n        jac[idx, 3*i_idx+2] = -2 * dr\n        jac[idx, 3*j_idx+2] = -2 * dr\n        \n        # Boundary part\n        b_start = num_overlap\n        k = np.arange(n)\n        jac[b_start + 4*k, 3*k] = 1\n        jac[b_start + 4*k, 3*k+2] = -1\n        jac[b_start + 4*k + 1, 3*k] = -1\n        jac[b_start + 4*k + 1, 3*k+2] = -1\n        jac[b_start + 4*k + 2, 3*k+1] = 1\n        jac[b_start + 4*k + 2, 3*k+2] = -1\n        jac[b_start + 4*k + 3, 3*k+1] = -1\n        jac[b_start + 4*k + 3, 3*k+2] = -1\n        \n        return jac\n\n    # Define constraints and bounds for SLSQP\n    cons = {'type': 'ineq', 'fun': constraints_fn, 'jac': jac_constraints}\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * n\n    \n    # Generate initial guesses\n    inits = []\n    \n    # 1. 5x5 grid + 1 circle at various positions\n    x5 = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x5, x5)\n    x_base, y_base = xv.flatten(), yv.flatten()\n    for pos in [(0.5, 0.5), (0.01, 0.01), (0.99, 0.99), (0.01, 0.99), (0.99, 0.01)]:\n        inits.append(create_v(np.append(x_base, pos[0]), np.append(y_base, pos[1]), np.full(n, 0.095)))\n    \n    # 2. 6x5 grid and 5x6 grid\n    xs, ys = np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 6)\n    xv, yv = np.meshgrid(xs, ys)\n    inits.append(create_v(xv.flatten()[:n], yv.flatten()[:n], np.full(n, 0.08)))\n    \n    xs, ys = np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(xs, ys)\n    inits.append(create_v(xv.flatten()[:n], yv.flatten()[:n], np.full(n, 0.08)))\n    \n    # 3. Random initializations\n    np.random.seed(42)\n    for _ in range(2):\n        inits.append(create_v(np.random.rand(n), np.random.rand(n), np.full(n, 0.05)))\n\n    best_v, best_sum = inits[0], 0\n    \n    # Multi-start: Short runs to find promising regions\n    for init_v in inits:\n        if time.time() - start_time > 180:\n            break\n        res = minimize(objective, init_v, method='SLSQP', jac=jac_objective,\n                       constraints=cons, bounds=bounds, options={'maxiter': 80, 'ftol': 1e-6})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n            \n    # Final optimization: Long run to converge from the best starting point\n    res = minimize(objective, best_v, method='SLSQP', jac=jac_objective,\n                   constraints=cons, bounds=bounds, options={'maxiter': 1500, 'ftol': 1e-10})\n    \n    best_v = res.x\n    centers = np.column_stack((best_v[0::3], best_v[1::3]))\n    radii = best_v[2::3]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:01:25.014523",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 396,
        "candidates_token_count": 1869,
        "thoughts_token_count": 22174
      },
      "response_text_len": 4639
    }
  },
  "llm_call_duration_s": 129.53429709398188,
  "eval_duration_s": 1.3025339080486447
}