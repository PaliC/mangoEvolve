{
  "trial_id": "trial_1_5",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses a multi-stage approach: \n    1. Multi-start local optimization to maximize a common radius.\n    2. A final local optimization to maximize the sum of potentially different radii\n       starting from the best common radius arrangement found.\n    \"\"\"\n    n = 26\n    \n    # Objective for Stage 1: Maximize a common radius r\n    def objective_common(params):\n        return -params[-1]\n\n    # Constraints for Stage 1: Common radius r must satisfy boundary and overlap constraints\n    def constraint_common(params):\n        centers = params[:-1].reshape((n, 2))\n        r = params[-1]\n        \n        # Boundary constraints: x_i - r >= 0, 1 - x_i - r >= 0, etc.\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0::4] = centers[:, 0] - r\n        c_boundary[1::4] = 1.0 - centers[:, 0] - r\n        c_boundary[2::4] = centers[:, 1] - r\n        c_boundary[3::4] = 1.0 - centers[:, 1] - r\n        \n        # Overlap constraints: distance between centers >= 2*r\n        c_overlap = []\n        for i in range(n - 1):\n            dx = centers[i, 0] - centers[i+1:, 0]\n            dy = centers[i, 1] - centers[i+1:, 1]\n            # Use squared distance to avoid sqrt calculation\n            c_overlap.append(dx**2 + dy**2 - 4 * r**2)\n            \n        return np.concatenate([c_boundary] + c_overlap)\n\n    # Objective for Stage 2: Maximize the sum of radii (r1, r2, ..., r26)\n    def objective_sum(params):\n        return -np.sum(params[2*n:])\n\n    # Constraints for Stage 2: Radii must satisfy boundary and overlap constraints\n    def constraint_sum(params):\n        centers = params[:2*n].reshape((n, 2))\n        radii = params[2*n:]\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0::4] = centers[:, 0] - radii\n        c_boundary[1::4] = 1.0 - centers[:, 0] - radii\n        c_boundary[2::4] = centers[:, 1] - radii\n        c_boundary[3::4] = 1.0 - centers[:, 1] - radii\n        \n        # Overlap constraints: distance between centers >= r_i + r_j\n        c_overlap = []\n        for i in range(n - 1):\n            dx = centers[i, 0] - centers[i+1:, 0]\n            dy = centers[i, 1] - centers[i+1:, 1]\n            sr = radii[i] + radii[i+1:]\n            c_overlap.append(dx**2 + dy**2 - sr**2)\n            \n        return np.concatenate([c_boundary] + c_overlap)\n\n    best_r = 0\n    best_params_common = None\n    \n    # Generate several initialization patterns for Stage 1\n    inits = []\n    \n    # 1. 5,5,6,5,5 grid (Total 26)\n    c1 = []\n    for j, row_size in enumerate([5, 5, 6, 5, 5]):\n        y = 0.1 + j * 0.2\n        xs = np.linspace(0.1, 0.9, row_size)\n        for x in xs: c1.append([x, y])\n    inits.append(np.array(c1)[:n])\n    \n    # 2. 6,5,6,5,4 grid (Total 26)\n    c2 = []\n    for j, row_size in enumerate([6, 5, 6, 5, 4]):\n        y = 0.1 + j * 0.2\n        xs = np.linspace(0.1, 0.9, row_size)\n        for x in xs: c2.append([x, y])\n    inits.append(np.array(c2)[:n])\n    \n    # 3. Hexagonal-ish layout\n    c3 = []\n    for i in range(6):\n        for j in range(5):\n            c3.append([0.1 + j * 0.2 + (i % 2) * 0.1, 0.1 + i * 0.17])\n    inits.append(np.array(c3)[:n])\n    \n    # 4. Random starts\n    np.random.seed(42)\n    for _ in range(12):\n        inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    # Stage 1: Run SLSQP for each initialization to find the best common radius structure\n    for centers in inits:\n        # Initial guess: centers flattened, plus a small radius r=0.08\n        x0 = np.concatenate([centers.ravel(), [0.08]])\n        res = minimize(objective_common, x0, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraint_common},\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)],\n                       options={'maxiter': 200})\n        if -res.fun > best_r:\n            best_r = -res.fun\n            best_params_common = res.x\n\n    # Fallback if optimization didn't converge well\n    if best_params_common is None:\n        centers_init = inits[0].ravel()\n        r_init = 0.08\n    else:\n        centers_init = best_params_common[:-1]\n        r_init = best_params_common[-1]\n    \n    # Stage 2: Refine the best common radius result by allowing individual radii to vary\n    # Initial guess for Stage 2: centers from Stage 1, all radii equal to the best r found\n    x0_sum = np.concatenate([centers_init, np.full(n, r_init)])\n    \n    res_sum = minimize(objective_sum, x0_sum, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraint_sum},\n                       bounds=[(0, 1)] * (3 * n),\n                       tol=1e-12,\n                       options={'maxiter': 1000, 'ftol': 1e-12})\n\n    # Prepare the output\n    final_params = res_sum.x\n    centers = final_params[:2*n].reshape((n, 2))\n    radii = final_params[2*n:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.609388356825329,
    "eval_time": 5.505990266799927,
    "error": null
  },
  "prompt": "Strategy: Differential Evolution for Circle Packing.\n        Use scipy.optimize.differential_evolution to find the optimal centers and radii.\n        Since the search space is large (26*3 variables), consider a two-stage approach:\n        1. Optimize centers with fixed equal radii to find a good packing structure.\n        2. Optimize both centers and radii together starting from the best structure found.\n        Maximize sum(radii) subject to non-overlap and boundary constraints.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses a multi-stage approach: \n    1. Multi-start local optimization to maximize a common radius.\n    2. A final local optimization to maximize the sum of potentially different radii\n       starting from the best common radius arrangement found.\n    \"\"\"\n    n = 26\n    \n    # Objective for Stage 1: Maximize a common radius r\n    def objective_common(params):\n        return -params[-1]\n\n    # Constraints for Stage 1: Common radius r must satisfy boundary and overlap constraints\n    def constraint_common(params):\n        centers = params[:-1].reshape((n, 2))\n        r = params[-1]\n        \n        # Boundary constraints: x_i - r >= 0, 1 - x_i - r >= 0, etc.\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0::4] = centers[:, 0] - r\n        c_boundary[1::4] = 1.0 - centers[:, 0] - r\n        c_boundary[2::4] = centers[:, 1] - r\n        c_boundary[3::4] = 1.0 - centers[:, 1] - r\n        \n        # Overlap constraints: distance between centers >= 2*r\n        c_overlap = []\n        for i in range(n - 1):\n            dx = centers[i, 0] - centers[i+1:, 0]\n            dy = centers[i, 1] - centers[i+1:, 1]\n            # Use squared distance to avoid sqrt calculation\n            c_overlap.append(dx**2 + dy**2 - 4 * r**2)\n            \n        return np.concatenate([c_boundary] + c_overlap)\n\n    # Objective for Stage 2: Maximize the sum of radii (r1, r2, ..., r26)\n    def objective_sum(params):\n        return -np.sum(params[2*n:])\n\n    # Constraints for Stage 2: Radii must satisfy boundary and overlap constraints\n    def constraint_sum(params):\n        centers = params[:2*n].reshape((n, 2))\n        radii = params[2*n:]\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0::4] = centers[:, 0] - radii\n        c_boundary[1::4] = 1.0 - centers[:, 0] - radii\n        c_boundary[2::4] = centers[:, 1] - radii\n        c_boundary[3::4] = 1.0 - centers[:, 1] - radii\n        \n        # Overlap constraints: distance between centers >= r_i + r_j\n        c_overlap = []\n        for i in range(n - 1):\n            dx = centers[i, 0] - centers[i+1:, 0]\n            dy = centers[i, 1] - centers[i+1:, 1]\n            sr = radii[i] + radii[i+1:]\n            c_overlap.append(dx**2 + dy**2 - sr**2)\n            \n        return np.concatenate([c_boundary] + c_overlap)\n\n    best_r = 0\n    best_params_common = None\n    \n    # Generate several initialization patterns for Stage 1\n    inits = []\n    \n    # 1. 5,5,6,5,5 grid (Total 26)\n    c1 = []\n    for j, row_size in enumerate([5, 5, 6, 5, 5]):\n        y = 0.1 + j * 0.2\n        xs = np.linspace(0.1, 0.9, row_size)\n        for x in xs: c1.append([x, y])\n    inits.append(np.array(c1)[:n])\n    \n    # 2. 6,5,6,5,4 grid (Total 26)\n    c2 = []\n    for j, row_size in enumerate([6, 5, 6, 5, 4]):\n        y = 0.1 + j * 0.2\n        xs = np.linspace(0.1, 0.9, row_size)\n        for x in xs: c2.append([x, y])\n    inits.append(np.array(c2)[:n])\n    \n    # 3. Hexagonal-ish layout\n    c3 = []\n    for i in range(6):\n        for j in range(5):\n            c3.append([0.1 + j * 0.2 + (i % 2) * 0.1, 0.1 + i * 0.17])\n    inits.append(np.array(c3)[:n])\n    \n    # 4. Random starts\n    np.random.seed(42)\n    for _ in range(12):\n        inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    # Stage 1: Run SLSQP for each initialization to find the best common radius structure\n    for centers in inits:\n        # Initial guess: centers flattened, plus a small radius r=0.08\n        x0 = np.concatenate([centers.ravel(), [0.08]])\n        res = minimize(objective_common, x0, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraint_common},\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)],\n                       options={'maxiter': 200})\n        if -res.fun > best_r:\n            best_r = -res.fun\n            best_params_common = res.x\n\n    # Fallback if optimization didn't converge well\n    if best_params_common is None:\n        centers_init = inits[0].ravel()\n        r_init = 0.08\n    else:\n        centers_init = best_params_common[:-1]\n        r_init = best_params_common[-1]\n    \n    # Stage 2: Refine the best common radius result by allowing individual radii to vary\n    # Initial guess for Stage 2: centers from Stage 1, all radii equal to the best r found\n    x0_sum = np.concatenate([centers_init, np.full(n, r_init)])\n    \n    res_sum = minimize(objective_sum, x0_sum, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraint_sum},\n                       bounds=[(0, 1)] * (3 * n),\n                       tol=1e-12,\n                       options={'maxiter': 1000, 'ftol': 1e-12})\n\n    # Prepare the output\n    final_params = res_sum.x\n    centers = final_params[:2*n].reshape((n, 2))\n    radii = final_params[2*n:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:01:29.645572",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 327,
        "candidates_token_count": 1758,
        "thoughts_token_count": 22284
      },
      "response_text_len": 5106
    }
  },
  "llm_call_duration_s": 129.96194097597618,
  "eval_duration_s": 5.505998426000588
}