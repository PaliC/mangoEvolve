{
  "trial_id": "trial_1_2",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of a force-directed (shove) simulation and SLSQP optimization.\n    \"\"\"\n    n = 26\n\n    def objective(params):\n        # params: [x0, y0, r0, x1, y1, r1, ...]\n        # Objective is to minimize negative sum of radii\n        return -np.sum(params[2::3])\n\n    def con_overlap(params):\n        # Overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        diff_x = x[:, np.newaxis] - x[np.newaxis, :]\n        diff_y = y[:, np.newaxis] - y[np.newaxis, :]\n        dist_sq = diff_x**2 + diff_y**2\n        min_dist_sq = (r[:, np.newaxis] + r[np.newaxis, :])**2\n        \n        # Use upper triangle to avoid duplicate constraints and self-distance\n        indices = np.triu_indices(n, k=1)\n        return (dist_sq - min_dist_sq)[indices]\n\n    def con_boundary(params):\n        # Boundary constraints: circles must stay inside [0, 1] x [0, 1]\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        return np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    constraints = [\n        {'type': 'ineq', 'fun': con_overlap},\n        {'type': 'ineq', 'fun': con_boundary}\n    ]\n\n    # Variable bounds: centers in [0, 1], radii in [0, 0.5]\n    bounds = []\n    for _ in range(n):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Try several different initial configurations to find a good local optimum\n    for i in range(12):\n        if i == 0:\n            # Layout 1: Slightly jittered 5x5 grid plus one extra circle\n            xs = np.linspace(0.12, 0.88, 5)\n            ys = np.linspace(0.12, 0.88, 5)\n            centers = np.array([[x, y] for x in xs for y in ys] + [[0.5, 0.5]])\n            r_init = 0.098\n        elif i == 1:\n            # Layout 2: 6x4 grid plus two extra circles\n            xs = np.linspace(0.1, 0.9, 6)\n            ys = np.linspace(0.12, 0.88, 4)\n            centers = np.array([[x, y] for x in xs for y in ys] + [[0.5, 0.95], [0.5, 0.05]])\n            r_init = 0.08\n        else:\n            # Layout 3+: Random placements\n            centers = np.random.rand(n, 2)\n            r_init = 0.095\n\n        # Add small jitter to break symmetry\n        centers += np.random.normal(0, 0.005, centers.shape)\n        centers = np.clip(centers, r_init, 1 - r_init)\n        \n        # Phase 1: Force-directed simulation (shove) to resolve major overlaps\n        # Treating it as an equal-radius problem initially for stability\n        current_r = r_init\n        for _ in range(600):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-12\n            overlap = 2 * current_r - dist\n            overlap[np.diag_indices(n)] = 0\n            overlap = np.maximum(overlap, 0)\n            \n            # Push circles apart based on overlap\n            push_direction = diff / dist[:, :, np.newaxis]\n            centers += np.sum(overlap[:, :, np.newaxis] * push_direction * 0.3, axis=1)\n            \n            # Keep circles within square walls\n            centers = np.clip(centers, current_r, 1 - current_r)\n            \n            # If everything is resolved, stop or slightly increase r to pack tighter\n            if np.max(overlap) < 1e-6:\n                break\n\n        # Phase 2: Refine the layout using SLSQP local optimizer\n        init_params = np.zeros(3*n)\n        init_params[0::3] = centers[:, 0]\n        init_params[1::3] = centers[:, 1]\n        init_params[2::3] = current_r\n        \n        res = minimize(objective, init_params, method='SLSQP', \n                       constraints=constraints, bounds=bounds, \n                       options={'maxiter': 150, 'ftol': 1e-7})\n        \n        # Track the best solution found across all starts\n        if res.success or (res.fun < 0):\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_params = res.x\n                best_centers = best_params.reshape((n, 3))[:, :2]\n                best_radii = best_params.reshape((n, 3))[:, 2]\n\n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    # Output is handled by the evaluator",
  "metrics": {
    "valid": true,
    "score": 2.6259671194648755,
    "eval_time": 2.217679500579834,
    "error": null
  },
  "prompt": "Strategy: Force-directed / Spring-based simulation.\n        Treat circles as particles that repel each other and are contained by the square walls.\n        Start with 26 small circles and gradually increase their radii.\n        At each step, resolve overlaps by moving centers according to repulsion forces (proportional to overlap distance).\n        After the simulation stabilizes, perform a final refinement step using a local optimizer like SLSQP.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of a force-directed (shove) simulation and SLSQP optimization.\n    \"\"\"\n    n = 26\n\n    def objective(params):\n        # params: [x0, y0, r0, x1, y1, r1, ...]\n        # Objective is to minimize negative sum of radii\n        return -np.sum(params[2::3])\n\n    def con_overlap(params):\n        # Overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        diff_x = x[:, np.newaxis] - x[np.newaxis, :]\n        diff_y = y[:, np.newaxis] - y[np.newaxis, :]\n        dist_sq = diff_x**2 + diff_y**2\n        min_dist_sq = (r[:, np.newaxis] + r[np.newaxis, :])**2\n        \n        # Use upper triangle to avoid duplicate constraints and self-distance\n        indices = np.triu_indices(n, k=1)\n        return (dist_sq - min_dist_sq)[indices]\n\n    def con_boundary(params):\n        # Boundary constraints: circles must stay inside [0, 1] x [0, 1]\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        return np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    constraints = [\n        {'type': 'ineq', 'fun': con_overlap},\n        {'type': 'ineq', 'fun': con_boundary}\n    ]\n\n    # Variable bounds: centers in [0, 1], radii in [0, 0.5]\n    bounds = []\n    for _ in range(n):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Try several different initial configurations to find a good local optimum\n    for i in range(12):\n        if i == 0:\n            # Layout 1: Slightly jittered 5x5 grid plus one extra circle\n            xs = np.linspace(0.12, 0.88, 5)\n            ys = np.linspace(0.12, 0.88, 5)\n            centers = np.array([[x, y] for x in xs for y in ys] + [[0.5, 0.5]])\n            r_init = 0.098\n        elif i == 1:\n            # Layout 2: 6x4 grid plus two extra circles\n            xs = np.linspace(0.1, 0.9, 6)\n            ys = np.linspace(0.12, 0.88, 4)\n            centers = np.array([[x, y] for x in xs for y in ys] + [[0.5, 0.95], [0.5, 0.05]])\n            r_init = 0.08\n        else:\n            # Layout 3+: Random placements\n            centers = np.random.rand(n, 2)\n            r_init = 0.095\n\n        # Add small jitter to break symmetry\n        centers += np.random.normal(0, 0.005, centers.shape)\n        centers = np.clip(centers, r_init, 1 - r_init)\n        \n        # Phase 1: Force-directed simulation (shove) to resolve major overlaps\n        # Treating it as an equal-radius problem initially for stability\n        current_r = r_init\n        for _ in range(600):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-12\n            overlap = 2 * current_r - dist\n            overlap[np.diag_indices(n)] = 0\n            overlap = np.maximum(overlap, 0)\n            \n            # Push circles apart based on overlap\n            push_direction = diff / dist[:, :, np.newaxis]\n            centers += np.sum(overlap[:, :, np.newaxis] * push_direction * 0.3, axis=1)\n            \n            # Keep circles within square walls\n            centers = np.clip(centers, current_r, 1 - current_r)\n            \n            # If everything is resolved, stop or slightly increase r to pack tighter\n            if np.max(overlap) < 1e-6:\n                break\n\n        # Phase 2: Refine the layout using SLSQP local optimizer\n        init_params = np.zeros(3*n)\n        init_params[0::3] = centers[:, 0]\n        init_params[1::3] = centers[:, 1]\n        init_params[2::3] = current_r\n        \n        res = minimize(objective, init_params, method='SLSQP', \n                       constraints=constraints, bounds=bounds, \n                       options={'maxiter': 150, 'ftol': 1e-7})\n        \n        # Track the best solution found across all starts\n        if res.success or (res.fun < 0):\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_params = res.x\n                best_centers = best_params.reshape((n, 3))[:, :2]\n                best_radii = best_params.reshape((n, 3))[:, 2]\n\n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    # Output is handled by the evaluator\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:01:20.656802",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 314,
        "candidates_token_count": 1530,
        "thoughts_token_count": 19833
      },
      "response_text_len": 4612
    }
  },
  "llm_call_duration_s": 124.26060447003692,
  "eval_duration_s": 2.217686902033165
}