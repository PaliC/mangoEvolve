{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP optimization for global search.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Precompute indices for vectorized constraint calculations\n    row_idx, col_idx = np.triu_indices(N, k=1)\n    num_overlap = N * (N - 1) // 2\n    overlap_rows = np.arange(4 * N, 4 * N + num_overlap)\n    idx_N = np.arange(N)\n\n    def objective(params):\n        # Objective: Maximize sum(r_i), so minimize -sum(r_i)\n        # params are ordered as [x1, y1, r1, x2, y2, r2, ...]\n        return -np.sum(params[2::3])\n\n    def objective_jac(params):\n        # Gradient of the objective: -1 for all r_i, 0 for x_i, y_i\n        jac = np.zeros(3 * N)\n        jac[2::3] = -1\n        return jac\n\n    def constraint_func(params):\n        # Extracts x, y, r from the flat params array\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        # Boundary constraints: circles must be inside [0,1]x[0,1]\n        # x - r >= 0, 1 - x - r >= 0, y - r >= 0, 1 - y - r >= 0\n        c_bound = np.zeros(4 * N)\n        c_bound[0::4] = x - r\n        c_bound[1::4] = 1 - x - r\n        c_bound[2::4] = y - r\n        c_bound[3::4] = 1 - y - r\n        \n        # Non-overlap constraints: dist(C_i, C_j) >= r_i + r_j\n        # (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = x[row_idx] - x[col_idx]\n        dy = y[row_idx] - y[col_idx]\n        dr = r[row_idx] + r[col_idx]\n        c_overlap = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([c_bound, c_overlap])\n\n    def constraint_jac(params):\n        # Jacobian of the constraints\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        jac = np.zeros((4 * N + num_overlap, 3 * N))\n        \n        # Jacobian for boundary constraints\n        jac[4*idx_N, 3*idx_N] = 1      # d(x-r)/dx\n        jac[4*idx_N, 3*idx_N+2] = -1   # d(x-r)/dr\n        jac[4*idx_N+1, 3*idx_N] = -1    # d(1-x-r)/dx\n        jac[4*idx_N+1, 3*idx_N+2] = -1  # d(1-x-r)/dr\n        jac[4*idx_N+2, 3*idx_N+1] = 1   # d(y-r)/dy\n        jac[4*idx_N+2, 3*idx_N+2] = -1  # d(y-r)/dr\n        jac[4*idx_N+3, 3*idx_N+1] = -1  # d(1-y-r)/dy\n        jac[4*idx_N+3, 3*idx_N+2] = -1  # d(1-y-r)/dr\n        \n        # Jacobian for overlap constraints\n        dx = x[row_idx] - x[col_idx]\n        dy = y[row_idx] - y[col_idx]\n        dr = r[row_idx] + r[col_idx]\n        \n        # d((xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2) / dxi = 2(xi-xj)\n        jac[overlap_rows, 3*row_idx] = 2 * dx\n        jac[overlap_rows, 3*col_idx] = -2 * dx\n        jac[overlap_rows, 3*row_idx+1] = 2 * dy\n        jac[overlap_rows, 3*col_idx+1] = -2 * dy\n        jac[overlap_rows, 3*row_idx+2] = -2 * dr\n        jac[overlap_rows, 3*col_idx+2] = -2 * dr\n        \n        return jac\n\n    # Variable bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    best_sum = 0\n    best_params = None\n\n    # Global optimization using multi-start SLSQP\n    attempt = 0\n    while time.time() - start_time < 260:\n        if attempt == 0:\n            # First attempt: Initialized with a jittered 5x5 grid + 1 random circle\n            x_grid = np.linspace(0.15, 0.85, 5)\n            y_grid = np.linspace(0.15, 0.85, 5)\n            X, Y = np.meshgrid(x_grid, y_grid)\n            x_init = np.append(X.flatten(), np.random.rand())\n            y_init = np.append(Y.flatten(), np.random.rand())\n            params = np.zeros(3 * N)\n            params[0::3] = x_init\n            params[1::3] = y_init\n            params[2::3] = 0.05\n        else:\n            # Subsequent attempts: Random initialization\n            params = np.zeros(3 * N)\n            params[0::3] = np.random.rand(N)\n            params[1::3] = np.random.rand(N)\n            params[2::3] = 0.05\n            \n        try:\n            res = minimize(objective, params, method='SLSQP', jac=objective_jac,\n                           constraints={'type': 'ineq', 'fun': constraint_func, 'jac': constraint_jac},\n                           bounds=bounds, options={'maxiter': 150, 'ftol': 1e-7})\n            \n            if -res.fun > best_sum:\n                best_sum = -res.fun\n                best_params = res.x\n        except:\n            continue\n        attempt += 1\n\n    # Final refinement of the best configuration found\n    if best_params is not None:\n        res = minimize(objective, best_params, method='SLSQP', jac=objective_jac,\n                       constraints={'type': 'ineq', 'fun': constraint_func, 'jac': constraint_jac},\n                       bounds=bounds, options={'maxiter': 500, 'ftol': 1e-10})\n        best_params = res.x\n        best_sum = -res.fun\n\n    # Reshape results for output\n    final_params = best_params.reshape(N, 3)\n    centers = final_params[:, :2]\n    radii = final_params[:, 2]\n    \n    return centers, radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.576079047270506,
    "eval_time": 264.6398723125458,
    "error": null
  },
  "prompt": "Strategy: Basin-hopping for global optimization.\n        Use scipy.optimize.basinhopping with SLSQP as the local minimizer.\n        Initialize with random centers and small equal radii.\n        Define the objective as -sum(radii) and include the overlap/boundary constraints as penalties or hard constraints in the local minimizer.\n        Try to explore the configuration space to avoid local optima.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP optimization for global search.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Precompute indices for vectorized constraint calculations\n    row_idx, col_idx = np.triu_indices(N, k=1)\n    num_overlap = N * (N - 1) // 2\n    overlap_rows = np.arange(4 * N, 4 * N + num_overlap)\n    idx_N = np.arange(N)\n\n    def objective(params):\n        # Objective: Maximize sum(r_i), so minimize -sum(r_i)\n        # params are ordered as [x1, y1, r1, x2, y2, r2, ...]\n        return -np.sum(params[2::3])\n\n    def objective_jac(params):\n        # Gradient of the objective: -1 for all r_i, 0 for x_i, y_i\n        jac = np.zeros(3 * N)\n        jac[2::3] = -1\n        return jac\n\n    def constraint_func(params):\n        # Extracts x, y, r from the flat params array\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        # Boundary constraints: circles must be inside [0,1]x[0,1]\n        # x - r >= 0, 1 - x - r >= 0, y - r >= 0, 1 - y - r >= 0\n        c_bound = np.zeros(4 * N)\n        c_bound[0::4] = x - r\n        c_bound[1::4] = 1 - x - r\n        c_bound[2::4] = y - r\n        c_bound[3::4] = 1 - y - r\n        \n        # Non-overlap constraints: dist(C_i, C_j) >= r_i + r_j\n        # (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = x[row_idx] - x[col_idx]\n        dy = y[row_idx] - y[col_idx]\n        dr = r[row_idx] + r[col_idx]\n        c_overlap = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([c_bound, c_overlap])\n\n    def constraint_jac(params):\n        # Jacobian of the constraints\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        jac = np.zeros((4 * N + num_overlap, 3 * N))\n        \n        # Jacobian for boundary constraints\n        jac[4*idx_N, 3*idx_N] = 1      # d(x-r)/dx\n        jac[4*idx_N, 3*idx_N+2] = -1   # d(x-r)/dr\n        jac[4*idx_N+1, 3*idx_N] = -1    # d(1-x-r)/dx\n        jac[4*idx_N+1, 3*idx_N+2] = -1  # d(1-x-r)/dr\n        jac[4*idx_N+2, 3*idx_N+1] = 1   # d(y-r)/dy\n        jac[4*idx_N+2, 3*idx_N+2] = -1  # d(y-r)/dr\n        jac[4*idx_N+3, 3*idx_N+1] = -1  # d(1-y-r)/dy\n        jac[4*idx_N+3, 3*idx_N+2] = -1  # d(1-y-r)/dr\n        \n        # Jacobian for overlap constraints\n        dx = x[row_idx] - x[col_idx]\n        dy = y[row_idx] - y[col_idx]\n        dr = r[row_idx] + r[col_idx]\n        \n        # d((xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2) / dxi = 2(xi-xj)\n        jac[overlap_rows, 3*row_idx] = 2 * dx\n        jac[overlap_rows, 3*col_idx] = -2 * dx\n        jac[overlap_rows, 3*row_idx+1] = 2 * dy\n        jac[overlap_rows, 3*col_idx+1] = -2 * dy\n        jac[overlap_rows, 3*row_idx+2] = -2 * dr\n        jac[overlap_rows, 3*col_idx+2] = -2 * dr\n        \n        return jac\n\n    # Variable bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    best_sum = 0\n    best_params = None\n\n    # Global optimization using multi-start SLSQP\n    attempt = 0\n    while time.time() - start_time < 260:\n        if attempt == 0:\n            # First attempt: Initialized with a jittered 5x5 grid + 1 random circle\n            x_grid = np.linspace(0.15, 0.85, 5)\n            y_grid = np.linspace(0.15, 0.85, 5)\n            X, Y = np.meshgrid(x_grid, y_grid)\n            x_init = np.append(X.flatten(), np.random.rand())\n            y_init = np.append(Y.flatten(), np.random.rand())\n            params = np.zeros(3 * N)\n            params[0::3] = x_init\n            params[1::3] = y_init\n            params[2::3] = 0.05\n        else:\n            # Subsequent attempts: Random initialization\n            params = np.zeros(3 * N)\n            params[0::3] = np.random.rand(N)\n            params[1::3] = np.random.rand(N)\n            params[2::3] = 0.05\n            \n        try:\n            res = minimize(objective, params, method='SLSQP', jac=objective_jac,\n                           constraints={'type': 'ineq', 'fun': constraint_func, 'jac': constraint_jac},\n                           bounds=bounds, options={'maxiter': 150, 'ftol': 1e-7})\n            \n            if -res.fun > best_sum:\n                best_sum = -res.fun\n                best_params = res.x\n        except:\n            continue\n        attempt += 1\n\n    # Final refinement of the best configuration found\n    if best_params is not None:\n        res = minimize(objective, best_params, method='SLSQP', jac=objective_jac,\n                       constraints={'type': 'ineq', 'fun': constraint_func, 'jac': constraint_jac},\n                       bounds=bounds, options={'maxiter': 500, 'ftol': 1e-10})\n        best_params = res.x\n        best_sum = -res.fun\n\n    # Reshape results for output\n    final_params = best_params.reshape(N, 3)\n    centers = final_params[:, :2]\n    radii = final_params[:, 2]\n    \n    return centers, radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:05:57.715652",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 310,
        "candidates_token_count": 1879,
        "thoughts_token_count": 22479
      },
      "response_text_len": 4991
    }
  },
  "llm_call_duration_s": 138.89824528608005,
  "eval_duration_s": 264.6398819469614
}