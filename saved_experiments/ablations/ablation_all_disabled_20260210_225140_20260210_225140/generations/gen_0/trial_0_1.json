{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The approach consists of two stages:\n    1. Maximize the common radius 'r' for all 26 circles starting from a grid-based layout.\n    2. Use that result as an initial guess to maximize the sum of radii, allowing each radius to vary independently.\n    \"\"\"\n    N = 26\n    \n    # Precompute indices for pairwise distance and overlap constraints\n    triu_indices = np.triu_indices(N, k=1)\n\n    # --- Stage 1: Maximize common radius r ---\n    def get_cons_stage1(params):\n        \"\"\"\n        Constraints for equal radii:\n        - Boundary constraints: circles must stay inside [0, 1] x [0, 1].\n        - Non-overlap constraints: distance between centers must be at least 2*r.\n        \"\"\"\n        r = params[-1]\n        xy = params[:-1].reshape((N, 2))\n        # Boundary constraints: x_i - r >= 0, 1 - x_i - r >= 0, etc.\n        b_cons = np.concatenate([\n            xy[:, 0] - r, \n            1.0 - xy[:, 0] - r, \n            xy[:, 1] - r, \n            1.0 - xy[:, 1] - r\n        ])\n        # Non-overlap: (x_i - x_j)^2 + (y_i - y_j)^2 - (2*r)^2 >= 0\n        dx = xy[:, 0, np.newaxis] - xy[:, 0]\n        dy = xy[:, 1, np.newaxis] - xy[:, 1]\n        dist_sq = dx**2 + dy**2\n        o_cons = dist_sq[triu_indices] - 4.0 * r**2\n        return np.concatenate([b_cons, o_cons])\n\n    # Initial guess Stage 1: Start with a 5x5 grid and add the 26th circle.\n    # A 5x5 grid in [0, 1] x [0, 1] has centers at [0.1, 0.3, 0.5, 0.7, 0.9].\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    initial_xy = np.vstack([xx.flatten(), yy.flatten()]).T # 25 points\n    # Add 26th point at a corner\n    initial_xy = np.vstack([initial_xy, [0.95, 0.95]])\n    \n    # Add small noise to break symmetry and allow the optimizer to explore better local optima\n    np.random.seed(42)\n    initial_xy += np.random.normal(0, 0.02, initial_xy.shape)\n    initial_xy = np.clip(initial_xy, 0.05, 0.95)\n    \n    # Initial parameters: flatten centers and append a starting common radius\n    initial_r = 0.05\n    initial_params1 = np.hstack([initial_xy.flatten(), initial_r])\n    \n    # Bounds for Stage 1: centers in [0, 1], common radius in [0, 0.5]\n    bounds1 = [(0, 1)] * (2 * N) + [(0, 0.5)]\n\n    # Optimize Stage 1: Maximize common radius 'r'\n    res1 = minimize(\n        lambda p: -p[-1],\n        initial_params1,\n        method='SLSQP',\n        bounds=bounds1,\n        constraints={'type': 'ineq', 'fun': get_cons_stage1},\n        options={'maxiter': 100}\n    )\n\n    # --- Stage 2: Maximize sum of radii ---\n    # Retrieve centers and common radius from Stage 1 result\n    res1_xy = res1.x[:-1].reshape((N, 2))\n    res1_r = res1.x[-1]\n    \n    # Initial guess Stage 2: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n    initial_params2 = np.zeros(3 * N)\n    for i in range(N):\n        initial_params2[3*i:3*i+2] = res1_xy[i]\n        initial_params2[3*i+2] = res1_r\n        \n    def get_cons_stage2(params):\n        \"\"\"\n        Constraints for variable radii:\n        - Boundary constraints: each circle must stay inside [0, 1] x [0, 1].\n        - Non-overlap constraints: distance between centers must be at least r_i + r_j.\n        \"\"\"\n        p = params.reshape((N, 3))\n        xy = p[:, :2]\n        r = p[:, 2]\n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        b_cons = np.concatenate([\n            xy[:, 0] - r, \n            1.0 - xy[:, 0] - r, \n            xy[:, 1] - r, \n            1.0 - xy[:, 1] - r\n        ])\n        # Non-overlap: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = xy[:, 0, np.newaxis] - xy[:, 0]\n        dy = xy[:, 1, np.newaxis] - xy[:, 1]\n        dist_sq = dx**2 + dy**2\n        r_sum = r[:, np.newaxis] + r\n        o_cons = dist_sq[triu_indices] - r_sum[triu_indices]**2\n        return np.concatenate([b_cons, o_cons])\n\n    # Bounds for Stage 2: centers in [0, 1], radii in [0, 0.5]\n    bounds2 = []\n    for _ in range(N):\n        bounds2.extend([(0, 1), (0, 1), (0, 0.5)])\n\n    # Optimize Stage 2: Maximize the sum of radii\n    res2 = minimize(\n        lambda p: -np.sum(p[2::3]),\n        initial_params2,\n        method='SLSQP',\n        bounds=bounds2,\n        constraints={'type': 'ineq', 'fun': get_cons_stage2},\n        options={'maxiter': 300}\n    )\n    \n    # Format the final result\n    final_params = res2.x.reshape((N, 3))\n    centers = final_params[:, :2]\n    radii = final_params[:, 2]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6176837367154655,
    "eval_time": 11.1842942237854,
    "error": null
  },
  "prompt": "Maximize the sum of radii for 26 circles in a unit square using a two-stage approach:\n        Stage 1: Find a valid packing of 26 EQUAL circles by maximizing the common radius 'r'. \n        You can use a grid-based start or multi-start for this.\n        Stage 2: Use the result from Stage 1 as an initial guess for a second optimization (SLSQP) \n        where all radii can vary independently to maximize the sum of radii.\n        Ensure all boundary and non-overlap constraints are strictly enforced.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The approach consists of two stages:\n    1. Maximize the common radius 'r' for all 26 circles starting from a grid-based layout.\n    2. Use that result as an initial guess to maximize the sum of radii, allowing each radius to vary independently.\n    \"\"\"\n    N = 26\n    \n    # Precompute indices for pairwise distance and overlap constraints\n    triu_indices = np.triu_indices(N, k=1)\n\n    # --- Stage 1: Maximize common radius r ---\n    def get_cons_stage1(params):\n        \"\"\"\n        Constraints for equal radii:\n        - Boundary constraints: circles must stay inside [0, 1] x [0, 1].\n        - Non-overlap constraints: distance between centers must be at least 2*r.\n        \"\"\"\n        r = params[-1]\n        xy = params[:-1].reshape((N, 2))\n        # Boundary constraints: x_i - r >= 0, 1 - x_i - r >= 0, etc.\n        b_cons = np.concatenate([\n            xy[:, 0] - r, \n            1.0 - xy[:, 0] - r, \n            xy[:, 1] - r, \n            1.0 - xy[:, 1] - r\n        ])\n        # Non-overlap: (x_i - x_j)^2 + (y_i - y_j)^2 - (2*r)^2 >= 0\n        dx = xy[:, 0, np.newaxis] - xy[:, 0]\n        dy = xy[:, 1, np.newaxis] - xy[:, 1]\n        dist_sq = dx**2 + dy**2\n        o_cons = dist_sq[triu_indices] - 4.0 * r**2\n        return np.concatenate([b_cons, o_cons])\n\n    # Initial guess Stage 1: Start with a 5x5 grid and add the 26th circle.\n    # A 5x5 grid in [0, 1] x [0, 1] has centers at [0.1, 0.3, 0.5, 0.7, 0.9].\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    initial_xy = np.vstack([xx.flatten(), yy.flatten()]).T # 25 points\n    # Add 26th point at a corner\n    initial_xy = np.vstack([initial_xy, [0.95, 0.95]])\n    \n    # Add small noise to break symmetry and allow the optimizer to explore better local optima\n    np.random.seed(42)\n    initial_xy += np.random.normal(0, 0.02, initial_xy.shape)\n    initial_xy = np.clip(initial_xy, 0.05, 0.95)\n    \n    # Initial parameters: flatten centers and append a starting common radius\n    initial_r = 0.05\n    initial_params1 = np.hstack([initial_xy.flatten(), initial_r])\n    \n    # Bounds for Stage 1: centers in [0, 1], common radius in [0, 0.5]\n    bounds1 = [(0, 1)] * (2 * N) + [(0, 0.5)]\n\n    # Optimize Stage 1: Maximize common radius 'r'\n    res1 = minimize(\n        lambda p: -p[-1],\n        initial_params1,\n        method='SLSQP',\n        bounds=bounds1,\n        constraints={'type': 'ineq', 'fun': get_cons_stage1},\n        options={'maxiter': 100}\n    )\n\n    # --- Stage 2: Maximize sum of radii ---\n    # Retrieve centers and common radius from Stage 1 result\n    res1_xy = res1.x[:-1].reshape((N, 2))\n    res1_r = res1.x[-1]\n    \n    # Initial guess Stage 2: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n    initial_params2 = np.zeros(3 * N)\n    for i in range(N):\n        initial_params2[3*i:3*i+2] = res1_xy[i]\n        initial_params2[3*i+2] = res1_r\n        \n    def get_cons_stage2(params):\n        \"\"\"\n        Constraints for variable radii:\n        - Boundary constraints: each circle must stay inside [0, 1] x [0, 1].\n        - Non-overlap constraints: distance between centers must be at least r_i + r_j.\n        \"\"\"\n        p = params.reshape((N, 3))\n        xy = p[:, :2]\n        r = p[:, 2]\n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        b_cons = np.concatenate([\n            xy[:, 0] - r, \n            1.0 - xy[:, 0] - r, \n            xy[:, 1] - r, \n            1.0 - xy[:, 1] - r\n        ])\n        # Non-overlap: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = xy[:, 0, np.newaxis] - xy[:, 0]\n        dy = xy[:, 1, np.newaxis] - xy[:, 1]\n        dist_sq = dx**2 + dy**2\n        r_sum = r[:, np.newaxis] + r\n        o_cons = dist_sq[triu_indices] - r_sum[triu_indices]**2\n        return np.concatenate([b_cons, o_cons])\n\n    # Bounds for Stage 2: centers in [0, 1], radii in [0, 0.5]\n    bounds2 = []\n    for _ in range(N):\n        bounds2.extend([(0, 1), (0, 1), (0, 0.5)])\n\n    # Optimize Stage 2: Maximize the sum of radii\n    res2 = minimize(\n        lambda p: -np.sum(p[2::3]),\n        initial_params2,\n        method='SLSQP',\n        bounds=bounds2,\n        constraints={'type': 'ineq', 'fun': get_cons_stage2},\n        options={'maxiter': 300}\n    )\n    \n    # Format the final result\n    final_params = res2.x.reshape((N, 3))\n    centers = final_params[:, :2]\n    radii = final_params[:, 2]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:54:13.617705",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 348,
        "candidates_token_count": 1706,
        "thoughts_token_count": 19785
      },
      "response_text_len": 4649
    }
  },
  "llm_call_duration_s": 122.4525671309093,
  "eval_duration_s": 11.18430421303492
}