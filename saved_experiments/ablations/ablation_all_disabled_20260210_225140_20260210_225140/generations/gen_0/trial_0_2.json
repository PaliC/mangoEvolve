{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a force-directed simulation to find a good initial configuration for equal circles,\n    followed by SLSQP optimization for equal radii, and finally a general SLSQP \n    optimization for the sum of individual radii.\n    \"\"\"\n    N = 26\n    \n    def solve_equal_r(initial_centers, initial_r):\n        \"\"\"Optimize positions to maximize a single common radius r.\"\"\"\n        # Variables: x = [x0, ..., x25, y0, ..., y25, r]\n        x0 = np.concatenate([initial_centers[:, 0], initial_centers[:, 1], [initial_r]])\n        \n        def obj(x):\n            return -x[-1]\n        \n        def obj_jac(x):\n            j = np.zeros(2 * N + 1)\n            j[-1] = -1\n            return j\n\n        def cons(x):\n            xs = x[:N]\n            ys = x[N:2*N]\n            r = x[-1]\n            # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n            c_bound = np.concatenate([xs - r, 1.0 - xs - r, ys - r, 1.0 - ys - r])\n            \n            # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (2r)^2 >= 0\n            dx = xs[:, None] - xs[None, :]\n            dy = ys[:, None] - ys[None, :]\n            dist_sq = dx**2 + dy**2\n            indices = np.triu_indices(N, k=1)\n            c_overlap = dist_sq[indices] - 4 * r**2\n            return np.concatenate([c_bound, c_overlap])\n\n        def cons_jac(x):\n            xs = x[:N]\n            ys = x[N:2*N]\n            r = x[-1]\n            num_overlap = N * (N - 1) // 2\n            jac = np.zeros((4 * N + num_overlap, 2 * N + 1))\n            for i in range(N):\n                jac[i, i] = 1; jac[i, -1] = -1\n                jac[N + i, i] = -1; jac[N + i, -1] = -1\n                jac[2 * N + i, N + i] = 1; jac[2 * N + i, -1] = -1\n                jac[3 * N + i, N + i] = -1; jac[3 * N + i, -1] = -1\n            indices = np.triu_indices(N, k=1)\n            row_idx = 4 * N\n            for i, j in zip(*indices):\n                dx = xs[i] - xs[j]\n                dy = ys[i] - ys[j]\n                jac[row_idx, i] = 2 * dx\n                jac[row_idx, j] = -2 * dx\n                jac[row_idx, N + i] = 2 * dy\n                jac[row_idx, N + j] = -2 * dy\n                jac[row_idx, -1] = -8 * r\n                row_idx += 1\n            return jac\n\n        res = minimize(obj, x0, method='SLSQP', jac=obj_jac,\n                       constraints={'type': 'ineq', 'fun': cons, 'jac': cons_jac},\n                       bounds=[(0, 1)] * (2 * N) + [(0, 0.5)],\n                       options={'maxiter': 400})\n        return res\n\n    def solve_unequal_r(initial_centers, initial_radii):\n        \"\"\"Refine positions and individual radii to maximize the sum of radii.\"\"\"\n        # Variables: x = [x0, ..., x25, y0, ..., y25, r0, ..., r25]\n        x0 = np.concatenate([initial_centers[:, 0], initial_centers[:, 1], initial_radii])\n        \n        def obj(x):\n            return -np.sum(x[2 * N:])\n        \n        def obj_jac(x):\n            j = np.zeros(3 * N)\n            j[2 * N:] = -1\n            return j\n\n        def cons(x):\n            xs = x[:N]\n            ys = x[N:2 * N]\n            rs = x[2 * N:]\n            c_bound = np.concatenate([xs - rs, 1.0 - xs - rs, ys - rs, 1.0 - ys - rs])\n            dx = xs[:, None] - xs[None, :]\n            dy = ys[:, None] - ys[None, :]\n            dist_sq = dx**2 + dy**2\n            r_sum = rs[:, None] + rs[None, :]\n            indices = np.triu_indices(N, k=1)\n            c_overlap = dist_sq[indices] - r_sum[indices]**2\n            return np.concatenate([c_bound, c_overlap])\n\n        def cons_jac(x):\n            xs = x[:N]\n            ys = x[N:2 * N]\n            rs = x[2 * N:]\n            num_overlap = N * (N - 1) // 2\n            jac = np.zeros((4 * N + num_overlap, 3 * N))\n            for i in range(N):\n                jac[i, i] = 1; jac[i, 2 * N + i] = -1\n                jac[N + i, i] = -1; jac[N + i, 2 * N + i] = -1\n                jac[2 * N + i, N + i] = 1; jac[2 * N + i, 2 * N + i] = -1\n                jac[3 * N + i, N + i] = -1; jac[3 * N + i, 2 * N + i] = -1\n            indices = np.triu_indices(N, k=1)\n            row_idx = 4 * N\n            for i, j in zip(*indices):\n                dx = xs[i] - xs[j]\n                dy = ys[i] - ys[j]\n                dr = rs[i] + rs[j]\n                jac[row_idx, i] = 2 * dx\n                jac[row_idx, j] = -2 * dx\n                jac[row_idx, N + i] = 2 * dy\n                jac[row_idx, N + j] = -2 * dy\n                jac[row_idx, 2 * N + i] = -2 * dr\n                jac[row_idx, 2 * N + j] = -2 * dr\n                row_idx += 1\n            return jac\n\n        res = minimize(obj, x0, method='SLSQP', jac=obj_jac,\n                       constraints={'type': 'ineq', 'fun': cons, 'jac': cons_jac},\n                       bounds=[(0, 1)] * (3 * N),\n                       options={'maxiter': 500})\n        return res\n\n    # Generate initial configurations\n    starts = []\n    # Grid-based starts\n    for corner in [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9], [0.5, 0.5]]:\n        centers_grid = []\n        for i in range(5):\n            for j in range(5):\n                centers_grid.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n        centers_grid.append(corner)\n        starts.append(np.array(centers_grid))\n    # Random starts\n    for _ in range(25):\n        starts.append(np.random.rand(N, 2))\n\n    best_equal_sum = -1\n    best_equal_config = None\n\n    # Step 1: Find best equal-radius configuration\n    for i, centers in enumerate(starts):\n        r = 0.05\n        # Quick force-directed simulation to untangle\n        for _ in range(400):\n            dists = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist_sq = np.sum(dists**2, axis=-1)\n            dist_norm = np.sqrt(dist_sq + np.eye(N))\n            overlap = 2 * r - dist_norm\n            overlap_mask = (overlap > 0) & (~np.eye(N, dtype=bool))\n            if np.any(overlap_mask):\n                force_dir = dists / dist_norm[:, :, np.newaxis]\n                force = force_dir * (overlap[:, :, np.newaxis] * overlap_mask[:, :, np.newaxis])\n                centers += np.sum(force, axis=1) * 0.1\n                r *= 0.995\n            else:\n                r *= 1.005\n            r = np.clip(r, 0.01, 0.15)\n            centers = np.clip(centers, r, 1.0 - r)\n\n        res_equal = solve_equal_r(centers, r)\n        if -res_equal.fun > best_equal_sum:\n            best_equal_sum = -res_equal.fun\n            best_equal_config = res_equal.x\n\n    # Step 2: Refine the best configuration with unequal radii\n    if best_equal_config is not None:\n        best_equal_centers = np.stack([best_equal_config[:N], best_equal_config[N:2 * N]], axis=1)\n        best_equal_r = best_equal_config[-1]\n        res_unequal = solve_unequal_r(best_equal_centers, np.full(N, best_equal_r))\n        \n        final_x = res_unequal.x\n        final_centers = np.stack([final_x[:N], final_x[N:2 * N]], axis=1)\n        final_radii = final_x[2 * N:]\n        final_sum = -res_unequal.fun\n        return final_centers, final_radii, final_sum\n    else:\n        # Fallback (should not be reached)\n        fallback_centers = np.random.rand(N, 2) * 0.5 + 0.25\n        fallback_radii = np.full(N, 0.01)\n        return fallback_centers, fallback_radii, np.sum(fallback_radii)\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 30.941880702972412,
    "error": "NaN values in centers"
  },
  "prompt": "Implement a 'force-directed' or 'repulsion' algorithm to pack 26 circles in a unit square.\n        1. Start with 26 circles with random positions and a fixed radius.\n        2. Iteratively move circles away from each other and the boundaries to resolve overlaps (using a simple repulsion vector).\n        3. Gradually increase radii when no overlaps are present.\n        4. After the simulation, use the final configuration as an initial guess for scipy.optimize.minimize (SLSQP) \n           to maximize the sum of radii.\n        Return the final optimized configuration.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a force-directed simulation to find a good initial configuration for equal circles,\n    followed by SLSQP optimization for equal radii, and finally a general SLSQP \n    optimization for the sum of individual radii.\n    \"\"\"\n    N = 26\n    \n    def solve_equal_r(initial_centers, initial_r):\n        \"\"\"Optimize positions to maximize a single common radius r.\"\"\"\n        # Variables: x = [x0, ..., x25, y0, ..., y25, r]\n        x0 = np.concatenate([initial_centers[:, 0], initial_centers[:, 1], [initial_r]])\n        \n        def obj(x):\n            return -x[-1]\n        \n        def obj_jac(x):\n            j = np.zeros(2 * N + 1)\n            j[-1] = -1\n            return j\n\n        def cons(x):\n            xs = x[:N]\n            ys = x[N:2*N]\n            r = x[-1]\n            # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n            c_bound = np.concatenate([xs - r, 1.0 - xs - r, ys - r, 1.0 - ys - r])\n            \n            # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (2r)^2 >= 0\n            dx = xs[:, None] - xs[None, :]\n            dy = ys[:, None] - ys[None, :]\n            dist_sq = dx**2 + dy**2\n            indices = np.triu_indices(N, k=1)\n            c_overlap = dist_sq[indices] - 4 * r**2\n            return np.concatenate([c_bound, c_overlap])\n\n        def cons_jac(x):\n            xs = x[:N]\n            ys = x[N:2*N]\n            r = x[-1]\n            num_overlap = N * (N - 1) // 2\n            jac = np.zeros((4 * N + num_overlap, 2 * N + 1))\n            for i in range(N):\n                jac[i, i] = 1; jac[i, -1] = -1\n                jac[N + i, i] = -1; jac[N + i, -1] = -1\n                jac[2 * N + i, N + i] = 1; jac[2 * N + i, -1] = -1\n                jac[3 * N + i, N + i] = -1; jac[3 * N + i, -1] = -1\n            indices = np.triu_indices(N, k=1)\n            row_idx = 4 * N\n            for i, j in zip(*indices):\n                dx = xs[i] - xs[j]\n                dy = ys[i] - ys[j]\n                jac[row_idx, i] = 2 * dx\n                jac[row_idx, j] = -2 * dx\n                jac[row_idx, N + i] = 2 * dy\n                jac[row_idx, N + j] = -2 * dy\n                jac[row_idx, -1] = -8 * r\n                row_idx += 1\n            return jac\n\n        res = minimize(obj, x0, method='SLSQP', jac=obj_jac,\n                       constraints={'type': 'ineq', 'fun': cons, 'jac': cons_jac},\n                       bounds=[(0, 1)] * (2 * N) + [(0, 0.5)],\n                       options={'maxiter': 400})\n        return res\n\n    def solve_unequal_r(initial_centers, initial_radii):\n        \"\"\"Refine positions and individual radii to maximize the sum of radii.\"\"\"\n        # Variables: x = [x0, ..., x25, y0, ..., y25, r0, ..., r25]\n        x0 = np.concatenate([initial_centers[:, 0], initial_centers[:, 1], initial_radii])\n        \n        def obj(x):\n            return -np.sum(x[2 * N:])\n        \n        def obj_jac(x):\n            j = np.zeros(3 * N)\n            j[2 * N:] = -1\n            return j\n\n        def cons(x):\n            xs = x[:N]\n            ys = x[N:2 * N]\n            rs = x[2 * N:]\n            c_bound = np.concatenate([xs - rs, 1.0 - xs - rs, ys - rs, 1.0 - ys - rs])\n            dx = xs[:, None] - xs[None, :]\n            dy = ys[:, None] - ys[None, :]\n            dist_sq = dx**2 + dy**2\n            r_sum = rs[:, None] + rs[None, :]\n            indices = np.triu_indices(N, k=1)\n            c_overlap = dist_sq[indices] - r_sum[indices]**2\n            return np.concatenate([c_bound, c_overlap])\n\n        def cons_jac(x):\n            xs = x[:N]\n            ys = x[N:2 * N]\n            rs = x[2 * N:]\n            num_overlap = N * (N - 1) // 2\n            jac = np.zeros((4 * N + num_overlap, 3 * N))\n            for i in range(N):\n                jac[i, i] = 1; jac[i, 2 * N + i] = -1\n                jac[N + i, i] = -1; jac[N + i, 2 * N + i] = -1\n                jac[2 * N + i, N + i] = 1; jac[2 * N + i, 2 * N + i] = -1\n                jac[3 * N + i, N + i] = -1; jac[3 * N + i, 2 * N + i] = -1\n            indices = np.triu_indices(N, k=1)\n            row_idx = 4 * N\n            for i, j in zip(*indices):\n                dx = xs[i] - xs[j]\n                dy = ys[i] - ys[j]\n                dr = rs[i] + rs[j]\n                jac[row_idx, i] = 2 * dx\n                jac[row_idx, j] = -2 * dx\n                jac[row_idx, N + i] = 2 * dy\n                jac[row_idx, N + j] = -2 * dy\n                jac[row_idx, 2 * N + i] = -2 * dr\n                jac[row_idx, 2 * N + j] = -2 * dr\n                row_idx += 1\n            return jac\n\n        res = minimize(obj, x0, method='SLSQP', jac=obj_jac,\n                       constraints={'type': 'ineq', 'fun': cons, 'jac': cons_jac},\n                       bounds=[(0, 1)] * (3 * N),\n                       options={'maxiter': 500})\n        return res\n\n    # Generate initial configurations\n    starts = []\n    # Grid-based starts\n    for corner in [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9], [0.5, 0.5]]:\n        centers_grid = []\n        for i in range(5):\n            for j in range(5):\n                centers_grid.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n        centers_grid.append(corner)\n        starts.append(np.array(centers_grid))\n    # Random starts\n    for _ in range(25):\n        starts.append(np.random.rand(N, 2))\n\n    best_equal_sum = -1\n    best_equal_config = None\n\n    # Step 1: Find best equal-radius configuration\n    for i, centers in enumerate(starts):\n        r = 0.05\n        # Quick force-directed simulation to untangle\n        for _ in range(400):\n            dists = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist_sq = np.sum(dists**2, axis=-1)\n            dist_norm = np.sqrt(dist_sq + np.eye(N))\n            overlap = 2 * r - dist_norm\n            overlap_mask = (overlap > 0) & (~np.eye(N, dtype=bool))\n            if np.any(overlap_mask):\n                force_dir = dists / dist_norm[:, :, np.newaxis]\n                force = force_dir * (overlap[:, :, np.newaxis] * overlap_mask[:, :, np.newaxis])\n                centers += np.sum(force, axis=1) * 0.1\n                r *= 0.995\n            else:\n                r *= 1.005\n            r = np.clip(r, 0.01, 0.15)\n            centers = np.clip(centers, r, 1.0 - r)\n\n        res_equal = solve_equal_r(centers, r)\n        if -res_equal.fun > best_equal_sum:\n            best_equal_sum = -res_equal.fun\n            best_equal_config = res_equal.x\n\n    # Step 2: Refine the best configuration with unequal radii\n    if best_equal_config is not None:\n        best_equal_centers = np.stack([best_equal_config[:N], best_equal_config[N:2 * N]], axis=1)\n        best_equal_r = best_equal_config[-1]\n        res_unequal = solve_unequal_r(best_equal_centers, np.full(N, best_equal_r))\n        \n        final_x = res_unequal.x\n        final_centers = np.stack([final_x[:N], final_x[N:2 * N]], axis=1)\n        final_radii = final_x[2 * N:]\n        final_sum = -res_unequal.fun\n        return final_centers, final_radii, final_sum\n    else:\n        # Fallback (should not be reached)\n        fallback_centers = np.random.rand(N, 2) * 0.5 + 0.25\n        fallback_radii = np.full(N, 0.01)\n        return fallback_centers, fallback_radii, np.sum(fallback_radii)\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:54:26.566778",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 353,
        "candidates_token_count": 2614,
        "thoughts_token_count": 19074
      },
      "response_text_len": 7467
    }
  },
  "llm_call_duration_s": 115.64370087592397,
  "eval_duration_s": 30.941892597009428
}