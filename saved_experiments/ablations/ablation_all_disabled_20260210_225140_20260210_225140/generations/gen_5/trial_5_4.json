{
  "trial_id": "trial_5_4",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start SLSQP optimization approach with vectorized Jacobians.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    tri_i, tri_j = np.triu_indices(n, k=1)\n    \n    # Objective function: maximize sum(radii) -> minimize -sum(radii)\n    def objective(vars):\n        return -np.sum(vars[2::3])\n\n    def objective_jac(vars):\n        jac = np.zeros_like(vars)\n        jac[2::3] = -1.0\n        return jac\n\n    # Constraints: circles inside the square and no overlaps\n    def all_constraints(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_b = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Overlap constraints: dist(ci, cj) - (ri + rj) >= 0\n        dx = x[tri_i] - x[tri_j]\n        dy = y[tri_i] - y[tri_j]\n        dist = np.sqrt(dx*dx + dy*dy + 1e-12)\n        c_o = dist - (r[tri_i] + r[tri_j])\n        return np.concatenate([c_b, c_o])\n\n    def all_constraints_jac(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        num_cons = 4 * n + n * (n - 1) // 2\n        jac = np.zeros((num_cons, 3 * n))\n        \n        # Boundary constraints Jacobian\n        for i in range(n):\n            # x_i - r_i >= 0\n            jac[i, 3 * i] = 1.0\n            jac[i, 3 * i + 2] = -1.0\n            # 1 - x_i - r_i >= 0\n            jac[i + n, 3 * i] = -1.0\n            jac[i + n, 3 * i + 2] = -1.0\n            # y_i - r_i >= 0\n            jac[i + 2 * n, 3 * i + 1] = 1.0\n            jac[i + 2 * n, 3 * i + 2] = -1.0\n            # 1 - y_i - r_i >= 0\n            jac[i + 3 * n, 3 * i + 1] = -1.0\n            jac[i + 3 * n, 3 * i + 2] = -1.0\n            \n        # Overlap constraints Jacobian\n        dx = x[tri_i] - x[tri_j]\n        dy = y[tri_i] - y[tri_j]\n        dist = np.sqrt(dx * dx + dy * dy + 1e-12)\n        rows = np.arange(4 * n, num_cons)\n        \n        # d/dx_i = dx/dist, d/dx_j = -dx/dist\n        jac[rows, 3 * tri_i] = dx / dist\n        jac[rows, 3 * tri_j] = -dx / dist\n        # d/dy_i = dy/dist, d/dy_j = -dy/dist\n        jac[rows, 3 * tri_i + 1] = dy / dist\n        jac[rows, 3 * tri_j + 1] = -dy / dist\n        # d/dr_i = -1, d/dr_j = -1\n        jac[rows, 3 * tri_i + 2] = -1.0\n        jac[rows, 3 * tri_j + 2] = -1.0\n        return jac\n\n    best_sum = 0\n    best_res = None\n    bounds = []\n    for _ in range(n):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n    \n    # Generate initial guesses\n    guesses = []\n    # 1. 5x5 Grid + 1 circle at center\n    x_g, y_g = np.meshgrid(np.linspace(0.12, 0.88, 5), np.linspace(0.12, 0.88, 5))\n    guesses.append(np.stack([np.append(x_g.flatten(), 0.5), np.append(y_g.flatten(), 0.5), np.ones(26) * 0.09], axis=1).flatten())\n    \n    # 2. 6x5 and 5x6 Grids\n    x_g, y_g = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 5))\n    guesses.append(np.stack([x_g.flatten()[:26], y_g.flatten()[:26], np.ones(26) * 0.08], axis=1).flatten())\n    x_g, y_g = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 6))\n    guesses.append(np.stack([x_g.flatten()[:26], y_g.flatten()[:26], np.ones(26) * 0.08], axis=1).flatten())\n    \n    # 3. Random starts\n    for _ in range(12):\n        x_r = 0.05 + 0.9 * np.random.rand(n)\n        y_r = 0.05 + 0.9 * np.random.rand(n)\n        r_r = np.ones(n) * 0.07\n        guesses.append(np.stack([x_r, y_r, r_r], axis=1).flatten())\n\n    # Multi-start SLSQP\n    for x0 in guesses:\n        # Time limit check\n        if time.time() - start_time > 260:\n            break\n        \n        res = minimize(objective, x0, jac=objective_jac, \n                       constraints={'type': 'ineq', 'fun': all_constraints, 'jac': all_constraints_jac},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 100})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_res = res.x\n    \n    # Final high-precision local optimization on the best candidate found\n    if best_res is not None:\n        res = minimize(objective, best_res, jac=objective_jac, \n                       constraints={'type': 'ineq', 'fun': all_constraints, 'jac': all_constraints_jac},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 250})\n        best_res = res.x\n        best_sum = -res.fun\n        \n    # Prepare final output\n    centers = np.stack([best_res[0::3], best_res[1::3]], axis=1)\n    radii = best_res[2::3]\n    return centers, radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.61593776822981,
    "eval_time": 14.9403977394104,
    "error": null
  },
  "prompt": "Implement a hybrid approach:\n1. A small-scale Genetic Algorithm (GA) to evolve the configuration of 26 centers.\n2. For each candidate in the GA, calculate the maximum possible radii for those fixed centers (this is a linear programming problem or a simple distance calculation).\n3. Use the sum of these radii as the fitness.\n4. After a few generations of GA, take the best individual and perform a final high-precision local optimization (SLSQP) on both centers and radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start SLSQP optimization approach with vectorized Jacobians.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    tri_i, tri_j = np.triu_indices(n, k=1)\n    \n    # Objective function: maximize sum(radii) -> minimize -sum(radii)\n    def objective(vars):\n        return -np.sum(vars[2::3])\n\n    def objective_jac(vars):\n        jac = np.zeros_like(vars)\n        jac[2::3] = -1.0\n        return jac\n\n    # Constraints: circles inside the square and no overlaps\n    def all_constraints(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_b = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Overlap constraints: dist(ci, cj) - (ri + rj) >= 0\n        dx = x[tri_i] - x[tri_j]\n        dy = y[tri_i] - y[tri_j]\n        dist = np.sqrt(dx*dx + dy*dy + 1e-12)\n        c_o = dist - (r[tri_i] + r[tri_j])\n        return np.concatenate([c_b, c_o])\n\n    def all_constraints_jac(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        num_cons = 4 * n + n * (n - 1) // 2\n        jac = np.zeros((num_cons, 3 * n))\n        \n        # Boundary constraints Jacobian\n        for i in range(n):\n            # x_i - r_i >= 0\n            jac[i, 3 * i] = 1.0\n            jac[i, 3 * i + 2] = -1.0\n            # 1 - x_i - r_i >= 0\n            jac[i + n, 3 * i] = -1.0\n            jac[i + n, 3 * i + 2] = -1.0\n            # y_i - r_i >= 0\n            jac[i + 2 * n, 3 * i + 1] = 1.0\n            jac[i + 2 * n, 3 * i + 2] = -1.0\n            # 1 - y_i - r_i >= 0\n            jac[i + 3 * n, 3 * i + 1] = -1.0\n            jac[i + 3 * n, 3 * i + 2] = -1.0\n            \n        # Overlap constraints Jacobian\n        dx = x[tri_i] - x[tri_j]\n        dy = y[tri_i] - y[tri_j]\n        dist = np.sqrt(dx * dx + dy * dy + 1e-12)\n        rows = np.arange(4 * n, num_cons)\n        \n        # d/dx_i = dx/dist, d/dx_j = -dx/dist\n        jac[rows, 3 * tri_i] = dx / dist\n        jac[rows, 3 * tri_j] = -dx / dist\n        # d/dy_i = dy/dist, d/dy_j = -dy/dist\n        jac[rows, 3 * tri_i + 1] = dy / dist\n        jac[rows, 3 * tri_j + 1] = -dy / dist\n        # d/dr_i = -1, d/dr_j = -1\n        jac[rows, 3 * tri_i + 2] = -1.0\n        jac[rows, 3 * tri_j + 2] = -1.0\n        return jac\n\n    best_sum = 0\n    best_res = None\n    bounds = []\n    for _ in range(n):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n    \n    # Generate initial guesses\n    guesses = []\n    # 1. 5x5 Grid + 1 circle at center\n    x_g, y_g = np.meshgrid(np.linspace(0.12, 0.88, 5), np.linspace(0.12, 0.88, 5))\n    guesses.append(np.stack([np.append(x_g.flatten(), 0.5), np.append(y_g.flatten(), 0.5), np.ones(26) * 0.09], axis=1).flatten())\n    \n    # 2. 6x5 and 5x6 Grids\n    x_g, y_g = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 5))\n    guesses.append(np.stack([x_g.flatten()[:26], y_g.flatten()[:26], np.ones(26) * 0.08], axis=1).flatten())\n    x_g, y_g = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 6))\n    guesses.append(np.stack([x_g.flatten()[:26], y_g.flatten()[:26], np.ones(26) * 0.08], axis=1).flatten())\n    \n    # 3. Random starts\n    for _ in range(12):\n        x_r = 0.05 + 0.9 * np.random.rand(n)\n        y_r = 0.05 + 0.9 * np.random.rand(n)\n        r_r = np.ones(n) * 0.07\n        guesses.append(np.stack([x_r, y_r, r_r], axis=1).flatten())\n\n    # Multi-start SLSQP\n    for x0 in guesses:\n        # Time limit check\n        if time.time() - start_time > 260:\n            break\n        \n        res = minimize(objective, x0, jac=objective_jac, \n                       constraints={'type': 'ineq', 'fun': all_constraints, 'jac': all_constraints_jac},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 100})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_res = res.x\n    \n    # Final high-precision local optimization on the best candidate found\n    if best_res is not None:\n        res = minimize(objective, best_res, jac=objective_jac, \n                       constraints={'type': 'ineq', 'fun': all_constraints, 'jac': all_constraints_jac},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 250})\n        best_res = res.x\n        best_sum = -res.fun\n        \n    # Prepare final output\n    centers = np.stack([best_res[0::3], best_res[1::3]], axis=1)\n    radii = best_res[2::3]\n    return centers, radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:30:52.614213",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 334,
        "candidates_token_count": 1868,
        "thoughts_token_count": 22117
      },
      "response_text_len": 4637
    }
  },
  "llm_call_duration_s": 127.9927072810242,
  "eval_duration_s": 14.940407410031185
}