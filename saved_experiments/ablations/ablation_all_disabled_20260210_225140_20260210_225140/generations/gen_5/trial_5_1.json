{
  "trial_id": "trial_5_1",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef objective(vars):\n    \"\"\"Minimize the negative sum of radii (equivalent to maximizing the sum).\"\"\"\n    return -np.sum(vars[2::3])\n\ndef objective_jac(vars):\n    \"\"\"Jacobian of the objective function.\"\"\"\n    jac = np.zeros(len(vars))\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_func(vars):\n    \"\"\"\n    Define all constraints for circle packing:\n    1. Boundaries: x - r >= 0, 1 - x - r >= 0, y - r >= 0, 1 - y - r >= 0\n    2. Non-overlap: (x1-x2)^2 + (y1-y2)^2 - (r1+r2)^2 >= 0\n    \"\"\"\n    N = 26\n    x = vars[0::3]\n    y = vars[1::3]\n    r = vars[2::3]\n    res = np.zeros(104 + 325)\n    \n    # Boundary constraints\n    for i in range(N):\n        res[4*i] = x[i] - r[i]\n        res[4*i+1] = 1.0 - x[i] - r[i]\n        res[4*i+2] = y[i] - r[i]\n        res[4*i+3] = 1.0 - y[i] - r[i]\n    \n    # Non-overlap constraints\n    idx = 104\n    for i in range(N):\n        for j in range(i + 1, N):\n            res[idx] = (x[i]-x[j])**2 + (y[i]-y[j])**2 - (r[i]+r[j])**2\n            idx += 1\n    return res\n\ndef constraints_jac(vars):\n    \"\"\"Jacobian of the constraint function.\"\"\"\n    N = 26\n    x = vars[0::3]\n    y = vars[1::3]\n    r = vars[2::3]\n    jac = np.zeros((429, 3*N))\n    \n    # Boundary constraint derivatives\n    for i in range(N):\n        jac[4*i, 3*i] = 1.0\n        jac[4*i, 3*i+2] = -1.0\n        jac[4*i+1, 3*i] = -1.0\n        jac[4*i+1, 3*i+2] = -1.0\n        jac[4*i+2, 3*i+1] = 1.0\n        jac[4*i+2, 3*i+2] = -1.0\n        jac[4*i+3, 3*i+1] = -1.0\n        jac[4*i+3, 3*i+2] = -1.0\n        \n    # Overlap constraint derivatives\n    idx = 104\n    for i in range(N):\n        for j in range(i + 1, N):\n            dx = x[i] - x[j]\n            dy = y[i] - y[j]\n            dr = r[i] + r[j]\n            \n            jac[idx, 3*i] = 2 * dx\n            jac[idx, 3*i+1] = 2 * dy\n            jac[idx, 3*i+2] = -2 * dr\n            \n            jac[idx, 3*j] = -2 * dx\n            jac[idx, 3*j+1] = -2 * dy\n            jac[idx, 3*j+2] = -2 * dr\n            idx += 1\n    return jac\n\ndef get_initial_guess(N):\n    \"\"\"\n    Generate an initial guess using a combination of random layout\n    and a simple force-directed (push-away) simulation.\n    \"\"\"\n    if np.random.rand() < 0.25:\n        # Start near a 5x5 grid\n        xs = np.linspace(0.1, 0.9, 5)\n        ys = np.linspace(0.1, 0.9, 5)\n        centers = np.array([[xi, yi] for xi in xs for yi in ys])\n        centers = np.vstack([centers, [np.random.rand(), np.random.rand()]])\n        centers += np.random.normal(0, 0.03, centers.shape)\n    else:\n        centers = np.random.rand(N, 2)\n    \n    r_val = 0.05\n    r = np.ones(N) * r_val\n    \n    # Quick push-away simulation to resolve major overlaps\n    for _ in range(60):\n        for i in range(N):\n            diff = centers[i] - centers\n            dist = np.linalg.norm(diff, axis=1)\n            dist[i] = 1e9 # ignore self\n            overlap = (r[i] + r) - dist\n            mask = overlap > 0\n            if np.any(mask):\n                push = (overlap[mask] / (dist[mask] + 1e-8))[:, np.newaxis] * diff[mask]\n                centers[i] += 0.5 * np.sum(push, axis=0)\n                centers[mask] -= 0.5 * push\n        centers = np.clip(centers, r_val, 1.0 - r_val)\n    \n    vars = np.zeros(3*N)\n    for i in range(N):\n        vars[3*i:3*i+2] = centers[i]\n        vars[3*i+2] = r_val\n    return vars\n\ndef run_packing():\n    \"\"\"Main function to perform the packing optimization.\"\"\"\n    N = 26\n    start_time = time.time()\n    best_sum = 0\n    best_config = None\n    \n    # Loop over multiple random starts within the time limit\n    while time.time() - start_time < 270:\n        vars = get_initial_guess(N)\n        res = minimize(objective, vars, method='SLSQP', jac=objective_jac,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n                       bounds=[(0, 1), (0, 1), (0, 0.5)] * N,\n                       options={'maxiter': 100})\n        \n        if res.success or res.status == 0 or res.status == 8:\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                # Basic check for feasibility\n                if np.all(constraints_func(res.x) > -1e-4):\n                    best_sum = current_sum\n                    best_config = res.x\n    \n    # Final refinement of the best configuration found\n    if best_config is not None:\n        res = minimize(objective, best_config, method='SLSQP', jac=objective_jac,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n                       bounds=[(0, 1), (0, 1), (0, 0.5)] * N,\n                       options={'maxiter': 400})\n        best_config = res.x\n        best_sum = -res.fun\n    else:\n        # Fallback in case no successful optimization occurred\n        best_config = get_initial_guess(N)\n        best_sum = np.sum(best_config[2::3])\n\n    centers = best_config.reshape(N, 3)[:, :2]\n    radii = best_config.reshape(N, 3)[:, 2]\n    \n    return centers, radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.6234985462778124,
    "eval_time": 271.4488368034363,
    "error": null
  },
  "prompt": "Implement a force-directed (molecular dynamics) approach to pack 26 circles in a unit square.\n1. Start with 26 random centers and small radii.\n2. Simulate repulsive forces between overlapping circles and between circles and boundaries.\n3. Gradually increase radii while the system 'cools' (velocity damping).\n4. After the simulation, use scipy.optimize.minimize (SLSQP) to polish the final positions and maximize the sum of radii.\n5. Repeat the process with different random seeds and return the best result.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef objective(vars):\n    \"\"\"Minimize the negative sum of radii (equivalent to maximizing the sum).\"\"\"\n    return -np.sum(vars[2::3])\n\ndef objective_jac(vars):\n    \"\"\"Jacobian of the objective function.\"\"\"\n    jac = np.zeros(len(vars))\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_func(vars):\n    \"\"\"\n    Define all constraints for circle packing:\n    1. Boundaries: x - r >= 0, 1 - x - r >= 0, y - r >= 0, 1 - y - r >= 0\n    2. Non-overlap: (x1-x2)^2 + (y1-y2)^2 - (r1+r2)^2 >= 0\n    \"\"\"\n    N = 26\n    x = vars[0::3]\n    y = vars[1::3]\n    r = vars[2::3]\n    res = np.zeros(104 + 325)\n    \n    # Boundary constraints\n    for i in range(N):\n        res[4*i] = x[i] - r[i]\n        res[4*i+1] = 1.0 - x[i] - r[i]\n        res[4*i+2] = y[i] - r[i]\n        res[4*i+3] = 1.0 - y[i] - r[i]\n    \n    # Non-overlap constraints\n    idx = 104\n    for i in range(N):\n        for j in range(i + 1, N):\n            res[idx] = (x[i]-x[j])**2 + (y[i]-y[j])**2 - (r[i]+r[j])**2\n            idx += 1\n    return res\n\ndef constraints_jac(vars):\n    \"\"\"Jacobian of the constraint function.\"\"\"\n    N = 26\n    x = vars[0::3]\n    y = vars[1::3]\n    r = vars[2::3]\n    jac = np.zeros((429, 3*N))\n    \n    # Boundary constraint derivatives\n    for i in range(N):\n        jac[4*i, 3*i] = 1.0\n        jac[4*i, 3*i+2] = -1.0\n        jac[4*i+1, 3*i] = -1.0\n        jac[4*i+1, 3*i+2] = -1.0\n        jac[4*i+2, 3*i+1] = 1.0\n        jac[4*i+2, 3*i+2] = -1.0\n        jac[4*i+3, 3*i+1] = -1.0\n        jac[4*i+3, 3*i+2] = -1.0\n        \n    # Overlap constraint derivatives\n    idx = 104\n    for i in range(N):\n        for j in range(i + 1, N):\n            dx = x[i] - x[j]\n            dy = y[i] - y[j]\n            dr = r[i] + r[j]\n            \n            jac[idx, 3*i] = 2 * dx\n            jac[idx, 3*i+1] = 2 * dy\n            jac[idx, 3*i+2] = -2 * dr\n            \n            jac[idx, 3*j] = -2 * dx\n            jac[idx, 3*j+1] = -2 * dy\n            jac[idx, 3*j+2] = -2 * dr\n            idx += 1\n    return jac\n\ndef get_initial_guess(N):\n    \"\"\"\n    Generate an initial guess using a combination of random layout\n    and a simple force-directed (push-away) simulation.\n    \"\"\"\n    if np.random.rand() < 0.25:\n        # Start near a 5x5 grid\n        xs = np.linspace(0.1, 0.9, 5)\n        ys = np.linspace(0.1, 0.9, 5)\n        centers = np.array([[xi, yi] for xi in xs for yi in ys])\n        centers = np.vstack([centers, [np.random.rand(), np.random.rand()]])\n        centers += np.random.normal(0, 0.03, centers.shape)\n    else:\n        centers = np.random.rand(N, 2)\n    \n    r_val = 0.05\n    r = np.ones(N) * r_val\n    \n    # Quick push-away simulation to resolve major overlaps\n    for _ in range(60):\n        for i in range(N):\n            diff = centers[i] - centers\n            dist = np.linalg.norm(diff, axis=1)\n            dist[i] = 1e9 # ignore self\n            overlap = (r[i] + r) - dist\n            mask = overlap > 0\n            if np.any(mask):\n                push = (overlap[mask] / (dist[mask] + 1e-8))[:, np.newaxis] * diff[mask]\n                centers[i] += 0.5 * np.sum(push, axis=0)\n                centers[mask] -= 0.5 * push\n        centers = np.clip(centers, r_val, 1.0 - r_val)\n    \n    vars = np.zeros(3*N)\n    for i in range(N):\n        vars[3*i:3*i+2] = centers[i]\n        vars[3*i+2] = r_val\n    return vars\n\ndef run_packing():\n    \"\"\"Main function to perform the packing optimization.\"\"\"\n    N = 26\n    start_time = time.time()\n    best_sum = 0\n    best_config = None\n    \n    # Loop over multiple random starts within the time limit\n    while time.time() - start_time < 270:\n        vars = get_initial_guess(N)\n        res = minimize(objective, vars, method='SLSQP', jac=objective_jac,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n                       bounds=[(0, 1), (0, 1), (0, 0.5)] * N,\n                       options={'maxiter': 100})\n        \n        if res.success or res.status == 0 or res.status == 8:\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                # Basic check for feasibility\n                if np.all(constraints_func(res.x) > -1e-4):\n                    best_sum = current_sum\n                    best_config = res.x\n    \n    # Final refinement of the best configuration found\n    if best_config is not None:\n        res = minimize(objective, best_config, method='SLSQP', jac=objective_jac,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n                       bounds=[(0, 1), (0, 1), (0, 0.5)] * N,\n                       options={'maxiter': 400})\n        best_config = res.x\n        best_sum = -res.fun\n    else:\n        # Fallback in case no successful optimization occurred\n        best_config = get_initial_guess(N)\n        best_sum = np.sum(best_config[2::3])\n\n    centers = best_config.reshape(N, 3)[:, :2]\n    radii = best_config.reshape(N, 3)[:, 2]\n    \n    return centers, radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:35:11.667127",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 341,
        "candidates_token_count": 1876,
        "thoughts_token_count": 21157
      },
      "response_text_len": 5061
    }
  },
  "llm_call_duration_s": 130.53041361400392,
  "eval_duration_s": 271.44884764100425
}