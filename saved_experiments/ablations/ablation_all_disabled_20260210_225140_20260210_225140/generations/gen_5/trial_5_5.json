{
  "trial_id": "trial_5_5",
  "generation": 5,
  "parent_id": "trial_4_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Implements a Shaking and Polishing loop using SLSQP and Gaussian noise perturbations.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    idx_i, idx_j = np.triu_indices(N, k=1)\n\n    def get_initial_guess(attempt):\n        \"\"\"Generates various grid-based and random starting configurations.\"\"\"\n        if attempt % 4 == 0:\n            # Grid-like configuration (5x5 + 1)\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x = np.append(x.flatten(), 0.5)\n            y = np.append(y.flatten(), 0.5)\n        elif attempt % 4 == 1:\n            # 4x6 grid + 2\n            x, y = np.meshgrid(np.linspace(0.08, 0.92, 6), np.linspace(0.12, 0.88, 4))\n            x = np.append(x.flatten(), [0.2, 0.8])\n            y = np.append(y.flatten(), [0.5, 0.5])\n        elif attempt % 4 == 2:\n            # 3x8 grid + 2\n            x, y = np.meshgrid(np.linspace(0.06, 0.94, 8), np.linspace(0.15, 0.85, 3))\n            x = np.append(x.flatten(), [0.5, 0.5])\n            y = np.append(y.flatten(), [0.1, 0.9])\n        else:\n            # Random initial positions\n            x = np.random.rand(N)\n            y = np.random.rand(N)\n        \n        # Add small noise to break symmetry\n        x += np.random.normal(0, 0.005, N)\n        y += np.random.normal(0, 0.005, N)\n        return np.clip(x, 0, 1), np.clip(y, 0, 1)\n\n    def force_directed(x, y, iterations=50):\n        \"\"\"Physics-based simulation to separate overlapping circles.\"\"\"\n        dt = 0.02\n        r_approx = 0.09\n        for _ in range(iterations):\n            dx = x[idx_i] - x[idx_j]\n            dy = y[idx_i] - y[idx_j]\n            d = np.sqrt(dx**2 + dy**2 + 1e-9)\n            f = np.maximum(0, (2 * r_approx - d) / d)\n            fx_apply = dx * f\n            fy_apply = dy * f\n            np.add.at(x, idx_i, fx_apply * dt)\n            np.add.at(x, idx_j, -fx_apply * dt)\n            np.add.at(y, idx_i, fy_apply * dt)\n            np.add.at(y, idx_j, -fy_apply * dt)\n            x = np.clip(x, 0, 1)\n            y = np.clip(y, 0, 1)\n            dt *= 0.99\n        return x, y\n\n    def objective(X):\n        \"\"\"Negative sum of radii to be minimized.\"\"\"\n        return -np.sum(X[2*N:])\n\n    def jac_objective(X):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def fast_constraints(X):\n        \"\"\"Feasibility constraints: inside square and no overlaps.\"\"\"\n        x, y, r = X[:N], X[N:2*N], X[2*N:]\n        c = np.zeros(4*N + N*(N-1)//2)\n        # Boundary constraints\n        c[0:4*N:4] = x - r\n        c[1:4*N:4] = 1 - x - r\n        c[2:4*N:4] = y - r\n        c[3:4*N:4] = 1 - y - r\n        # Non-overlap constraints\n        c[4*N:] = (x[idx_i] - x[idx_j])**2 + (y[idx_i] - y[idx_j])**2 - (r[idx_i] + r[idx_j])**2\n        return c\n\n    def fast_jac(X):\n        \"\"\"Jacobian of the constraints.\"\"\"\n        x, y, r = X[:N], X[N:2*N], X[2*N:]\n        n_overlap = N*(N-1)//2\n        jac = np.zeros((4*N + n_overlap, 3*N))\n        # Boundaries\n        for i in range(N):\n            jac[4*i, i] = 1; jac[4*i, 2*N+i] = -1\n            jac[4*i+1, i] = -1; jac[4*i+1, 2*N+i] = -1\n            jac[4*i+2, N+i] = 1; jac[4*i+2, 2*N+i] = -1\n            jac[4*i+3, N+i] = -1; jac[4*i+3, 2*N+i] = -1\n        # Overlaps\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n        row_idx = 4*N + np.arange(n_overlap)\n        jac[row_idx, idx_i] = 2 * dx\n        jac[row_idx, idx_j] = -2 * dx\n        jac[row_idx, N + idx_i] = 2 * dy\n        jac[row_idx, N + idx_j] = -2 * dy\n        jac[row_idx, 2*N + idx_i] = -2 * sr\n        jac[row_idx, 2*N + idx_j] = -2 * sr\n        return jac\n\n    def ensure_valid(x, y, r):\n        \"\"\"Post-processing to strictly enforce all constraints.\"\"\"\n        r = np.array(r)\n        r = np.minimum(r, x)\n        r = np.minimum(r, 1-x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1-y)\n        r = np.maximum(r, 0)\n        for _ in range(50):\n            changed = False\n            for i in range(N):\n                for j in range(i+1, N):\n                    dx, dy = x[i]-x[j], y[i]-y[j]\n                    d = np.sqrt(dx*dx + dy*dy)\n                    if r[i] + r[j] > d:\n                        overlap = (r[i] + r[j]) - d\n                        r_sum = r[i] + r[j]\n                        if r_sum > 1e-12:\n                            r[i] -= overlap * (r[i] / r_sum)\n                            r[j] -= overlap * (r[j] / r_sum)\n                        else:\n                            r[i] = r[j] = 0\n                        changed = True\n            if not changed: break\n        return r\n\n    best_sum = 0\n    best_X = None\n    attempt = 0\n    \n    # Shaking and Polishing Loop\n    while time.time() - start_time < 285:\n        if attempt > 0 and best_X is not None and attempt % 3 != 0:\n            # Shake the best solution found so far\n            sigma = 0.02 * (0.99 ** (attempt // 10))\n            x = np.clip(best_X[:N] + np.random.normal(0, sigma, N), 0, 1)\n            y = np.clip(best_X[N:2*N] + np.random.normal(0, sigma, N), 0, 1)\n            r = best_X[2*N:]\n        else:\n            # Explore a new part of the search space\n            x, y = get_initial_guess(attempt)\n            x, y = force_directed(x, y)\n            r = np.full(N, 0.08)\n        \n        X0 = np.concatenate([x, y, r])\n        try:\n            # Polishing step using SLSQP\n            res = minimize(objective, X0, method='SLSQP', jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': fast_constraints, 'jac': fast_jac},\n                           bounds=[(0, 1)]*(2*N) + [(0, 0.5)]*N,\n                           options={'maxiter': 100, 'ftol': 1e-9})\n            curr_X = res.x if (res.success or res.fun < -best_sum) else X0\n        except:\n            curr_X = X0\n            \n        # Guarantee strict feasibility\n        r_valid = ensure_valid(curr_X[:N], curr_X[N:2*N], curr_X[2*N:])\n        curr_sum = np.sum(r_valid)\n        \n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_X = np.concatenate([curr_X[:N], curr_X[N:2*N], r_valid])\n        \n        attempt += 1\n\n    centers = np.stack((best_X[:N], best_X[N:2*N]), axis=1)\n    radii = best_X[2*N:]\n    return centers, radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, score = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.630438538491646,
    "eval_time": 285.97044825553894,
    "error": null
  },
  "prompt": "Take the following packing strategy and implement a 'Shaking and Polishing' loop:\n1. Start with the logic in the provided code.\n2. After finding a local optimum, 'shake' the configuration by adding small Gaussian noise to the centers.\n3. Re-optimize the shaken configuration.\n4. If the new sum of radii is better, keep it.\n5. Repeat this 50-100 times within the time limit.\n\nCode to improve:\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    N = 26\n    start_time = time.time()\n    \n    def get_initial_positions(N, attempt):\n        if attempt % 3 == 0:\n            # Grid-like configuration (5x5 + 1)\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x = np.append(x.flatten(), 0.5)\n            y = np.append(y.flatten(), 0.5)\n        elif attempt % 3 == 1:\n            # 4x6 grid + 2\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n            x = np.append(x.flatten(), [0.2, 0.8])\n            y = np.append(y.flatten(), [0.5, 0.5])\n        else:\n            # Random initial positions\n            x = np.random.rand(N)\n            y = np.random.rand(N)\n        \n        # Add small noise to break symmetry\n        x += np.random.normal(0, 0.005, N)\n        y += np.random.normal(0, 0.005, N)\n        return np.clip(x, 0, 1), np.clip(y, 0, 1)\n\n    def force_directed(x, y, N, iterations=200):\n        dt = 0.02\n        r_approx = 0.091\n        for _ in range(iterations):\n            fx, fy = np.zeros(N), np.zeros(N)\n            for i in range(N):\n                dx = x[i] - x[i+1:]\n                dy = y[i] - y[i+1:]\n                d2 = dx**2 + dy**2 + 1e-9\n                d = np.sqrt(d2)\n                mask = d < 2 * r_approx\n                if np.any(mask):\n                    f = (2 * r_approx - d[mask]) / d[mask]\n                    fx[i] += np.sum(dx[mask] * f)\n                    fy[i] += np.sum(dy[mask] * f)\n                    fx[i+1:][mask] -= dx[mask] * f\n                    fy[i+1:][mask] -= dy[mask] * f\n            x += fx * dt\n            y += fy * dt\n            x = np.clip(x, 0, 1)\n            y = np.clip(y, 0, 1)\n            dt *= 0.99\n        return x, y\n\n    def objective(X):\n        return -np.sum(X[2::3])\n\n    def jac_objective(X):\n        j = np.zeros(3*N)\n        j[2::3] = -1.0\n        return j\n\n    def fast_constraints(X):\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        res = np.zeros(4*N + N*(N-1)//2)\n        res[0:4*N:4] = x - r\n        res[1:4*N:4] = 1 - x - r\n        res[2:4*N:4] = y - r\n        res[3:4*N:4] = 1 - y - r\n        idx = 4*N\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            rs = r[i] + r[i+1:]\n            res[idx:idx+N-1-i] = dx**2 + dy**2 - rs**2\n            idx += N-1-i\n        return res\n\n    def fast_jac(X):\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        jac = np.zeros((4*N + N*(N-1)//2, 3*N))\n        for i in range(N):\n            jac[4*i, 3*i] = 1; jac[4*i, 3*i+2] = -1\n            jac[4*i+1, 3*i] = -1; jac[4*i+1, 3*i+2] = -1\n            jac[4*i+2, 3*i+1] = 1; jac[4*i+2, 3*i+2] = -1\n            jac[4*i+3, 3*i+1] = -1; jac[4*i+3, 3*i+2] = -1\n        idx = 4*N\n        for i in range(N):\n            for j in range(i+1, N):\n                dx, dy, rs = x[i]-x[j], y[i]-y[j], r[i]+r[j]\n                jac[idx, 3*i] = 2*dx; jac[idx, 3*j] = -2*dx\n                jac[idx, 3*i+1] = 2*dy; jac[idx, 3*j+1] = -2*dy\n                jac[idx, 3*i+2] = -2*rs; jac[idx, 3*j+2] = -2*rs\n                idx += 1\n        return jac\n\n    def ensure_valid(centers, radii, N):\n        radii = radii.copy()\n        for i in range(N):\n            radii[i] = min(radii[i], centers[i, 0], 1.0 - centers[i, 0],\n                           centers[i, 1], 1.0 - centers[i, 1])\n        for _ in range(100):\n            changed = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    d = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    if radii[i] + radii[j] > d + 1e-15:\n                        over = (radii[i] + radii[j]) - d\n                        r_sum = radii[i] + radii[j]\n                        if r_sum > 1e-12:\n                            radii[i] -= over * (radii[i] / r_sum)\n                            radii[j] -= over * (radii[j] / r_sum)\n                        else:\n                            radii[i] = radii[j] = 0\n                        changed = True\n            if not changed:\n                break\n        return np.maximum(radii, 0)\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    attempt = 0\n\n    while time.time() - start_time < 280:\n        if attempt > 0 and best_centers is not None and attempt % 5 == 0:\n            # Shake the best solution\n            x = best_centers[:, 0] + np.random.normal(0, 0.01, N)\n            y = best_centers[:, 1] + np.random.normal(0, 0.01, N)\n            r0 = best_radii\n        else:\n            x, y = get_initial_positions(N, attempt)\n            x, y = force_directed(x, y, N)\n            r0 = np.full(N, 0.05)\n        \n        X0 = np.zeros(3*N)\n        X0[0::3], X0[1::3], X0[2::3] = x, y, r0\n        \n        try:\n            res = minimize(objective, X0, method='SLSQP', jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': fast_constraints, 'jac': fast_jac},\n                           options={'maxiter': 300, 'ftol': 1e-11})\n            curr_X = res.x\n        except:\n            curr_X = X0\n            \n        x_curr, y_curr, r_curr = curr_X[0::3], curr_X[1::3], curr_X[2::3]\n        centers_curr = np.stack((x_curr, y_curr), axis=1)\n        radii_curr = ensure_valid(centers_curr, r_curr, N)\n        sum_curr = np.sum(radii_curr)\n        \n        if sum_curr > best_sum:\n            best_sum = sum_curr\n            best_centers = centers_curr\n            best_radii = radii_curr\n            \n        attempt += 1\n\n    return best_centers, best_radii, best_sum",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Implements a Shaking and Polishing loop using SLSQP and Gaussian noise perturbations.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    idx_i, idx_j = np.triu_indices(N, k=1)\n\n    def get_initial_guess(attempt):\n        \"\"\"Generates various grid-based and random starting configurations.\"\"\"\n        if attempt % 4 == 0:\n            # Grid-like configuration (5x5 + 1)\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x = np.append(x.flatten(), 0.5)\n            y = np.append(y.flatten(), 0.5)\n        elif attempt % 4 == 1:\n            # 4x6 grid + 2\n            x, y = np.meshgrid(np.linspace(0.08, 0.92, 6), np.linspace(0.12, 0.88, 4))\n            x = np.append(x.flatten(), [0.2, 0.8])\n            y = np.append(y.flatten(), [0.5, 0.5])\n        elif attempt % 4 == 2:\n            # 3x8 grid + 2\n            x, y = np.meshgrid(np.linspace(0.06, 0.94, 8), np.linspace(0.15, 0.85, 3))\n            x = np.append(x.flatten(), [0.5, 0.5])\n            y = np.append(y.flatten(), [0.1, 0.9])\n        else:\n            # Random initial positions\n            x = np.random.rand(N)\n            y = np.random.rand(N)\n        \n        # Add small noise to break symmetry\n        x += np.random.normal(0, 0.005, N)\n        y += np.random.normal(0, 0.005, N)\n        return np.clip(x, 0, 1), np.clip(y, 0, 1)\n\n    def force_directed(x, y, iterations=50):\n        \"\"\"Physics-based simulation to separate overlapping circles.\"\"\"\n        dt = 0.02\n        r_approx = 0.09\n        for _ in range(iterations):\n            dx = x[idx_i] - x[idx_j]\n            dy = y[idx_i] - y[idx_j]\n            d = np.sqrt(dx**2 + dy**2 + 1e-9)\n            f = np.maximum(0, (2 * r_approx - d) / d)\n            fx_apply = dx * f\n            fy_apply = dy * f\n            np.add.at(x, idx_i, fx_apply * dt)\n            np.add.at(x, idx_j, -fx_apply * dt)\n            np.add.at(y, idx_i, fy_apply * dt)\n            np.add.at(y, idx_j, -fy_apply * dt)\n            x = np.clip(x, 0, 1)\n            y = np.clip(y, 0, 1)\n            dt *= 0.99\n        return x, y\n\n    def objective(X):\n        \"\"\"Negative sum of radii to be minimized.\"\"\"\n        return -np.sum(X[2*N:])\n\n    def jac_objective(X):\n        \"\"\"Gradient of the objective function.\"\"\"\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def fast_constraints(X):\n        \"\"\"Feasibility constraints: inside square and no overlaps.\"\"\"\n        x, y, r = X[:N], X[N:2*N], X[2*N:]\n        c = np.zeros(4*N + N*(N-1)//2)\n        # Boundary constraints\n        c[0:4*N:4] = x - r\n        c[1:4*N:4] = 1 - x - r\n        c[2:4*N:4] = y - r\n        c[3:4*N:4] = 1 - y - r\n        # Non-overlap constraints\n        c[4*N:] = (x[idx_i] - x[idx_j])**2 + (y[idx_i] - y[idx_j])**2 - (r[idx_i] + r[idx_j])**2\n        return c\n\n    def fast_jac(X):\n        \"\"\"Jacobian of the constraints.\"\"\"\n        x, y, r = X[:N], X[N:2*N], X[2*N:]\n        n_overlap = N*(N-1)//2\n        jac = np.zeros((4*N + n_overlap, 3*N))\n        # Boundaries\n        for i in range(N):\n            jac[4*i, i] = 1; jac[4*i, 2*N+i] = -1\n            jac[4*i+1, i] = -1; jac[4*i+1, 2*N+i] = -1\n            jac[4*i+2, N+i] = 1; jac[4*i+2, 2*N+i] = -1\n            jac[4*i+3, N+i] = -1; jac[4*i+3, 2*N+i] = -1\n        # Overlaps\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n        row_idx = 4*N + np.arange(n_overlap)\n        jac[row_idx, idx_i] = 2 * dx\n        jac[row_idx, idx_j] = -2 * dx\n        jac[row_idx, N + idx_i] = 2 * dy\n        jac[row_idx, N + idx_j] = -2 * dy\n        jac[row_idx, 2*N + idx_i] = -2 * sr\n        jac[row_idx, 2*N + idx_j] = -2 * sr\n        return jac\n\n    def ensure_valid(x, y, r):\n        \"\"\"Post-processing to strictly enforce all constraints.\"\"\"\n        r = np.array(r)\n        r = np.minimum(r, x)\n        r = np.minimum(r, 1-x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1-y)\n        r = np.maximum(r, 0)\n        for _ in range(50):\n            changed = False\n            for i in range(N):\n                for j in range(i+1, N):\n                    dx, dy = x[i]-x[j], y[i]-y[j]\n                    d = np.sqrt(dx*dx + dy*dy)\n                    if r[i] + r[j] > d:\n                        overlap = (r[i] + r[j]) - d\n                        r_sum = r[i] + r[j]\n                        if r_sum > 1e-12:\n                            r[i] -= overlap * (r[i] / r_sum)\n                            r[j] -= overlap * (r[j] / r_sum)\n                        else:\n                            r[i] = r[j] = 0\n                        changed = True\n            if not changed: break\n        return r\n\n    best_sum = 0\n    best_X = None\n    attempt = 0\n    \n    # Shaking and Polishing Loop\n    while time.time() - start_time < 285:\n        if attempt > 0 and best_X is not None and attempt % 3 != 0:\n            # Shake the best solution found so far\n            sigma = 0.02 * (0.99 ** (attempt // 10))\n            x = np.clip(best_X[:N] + np.random.normal(0, sigma, N), 0, 1)\n            y = np.clip(best_X[N:2*N] + np.random.normal(0, sigma, N), 0, 1)\n            r = best_X[2*N:]\n        else:\n            # Explore a new part of the search space\n            x, y = get_initial_guess(attempt)\n            x, y = force_directed(x, y)\n            r = np.full(N, 0.08)\n        \n        X0 = np.concatenate([x, y, r])\n        try:\n            # Polishing step using SLSQP\n            res = minimize(objective, X0, method='SLSQP', jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': fast_constraints, 'jac': fast_jac},\n                           bounds=[(0, 1)]*(2*N) + [(0, 0.5)]*N,\n                           options={'maxiter': 100, 'ftol': 1e-9})\n            curr_X = res.x if (res.success or res.fun < -best_sum) else X0\n        except:\n            curr_X = X0\n            \n        # Guarantee strict feasibility\n        r_valid = ensure_valid(curr_X[:N], curr_X[N:2*N], curr_X[2*N:])\n        curr_sum = np.sum(r_valid)\n        \n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_X = np.concatenate([curr_X[:N], curr_X[N:2*N], r_valid])\n        \n        attempt += 1\n\n    centers = np.stack((best_X[:N], best_X[N:2*N]), axis=1)\n    radii = best_X[2*N:]\n    return centers, radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, score = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:35:41.097963",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2490,
        "candidates_token_count": 2490,
        "thoughts_token_count": 23129
      },
      "response_text_len": 6566
    }
  },
  "llm_call_duration_s": 145.44810515805148,
  "eval_duration_s": 285.970455941977
}