{
  "trial_id": "trial_5_2",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\nimport random\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses an iterative expansion strategy with multi-start SLSQP and LP for initial radii.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def get_halton_centers(n):\n        def halton(n_pts, base):\n            seq = np.zeros(n_pts)\n            for i in range(n_pts):\n                f, r, curr = 1, 0, i + 1\n                while curr > 0:\n                    f /= base\n                    r += f * (curr % base)\n                    curr //= base\n                seq[i] = r\n            return seq\n        return np.stack([halton(n, 2), halton(n, 3)], axis=1)\n\n    def get_initial_centers(n, iteration):\n        if iteration % 3 == 0:\n            # Jittered 5x5 grid + 1 random point\n            xs = np.linspace(0.15, 0.85, 5)\n            ys = np.linspace(0.15, 0.85, 5)\n            xi, yi = np.meshgrid(xs, ys)\n            centers = np.stack([xi.ravel(), yi.ravel()], axis=1)\n            while len(centers) < n:\n                centers = np.vstack([centers, np.random.rand(2)])\n            centers += np.random.uniform(-0.05, 0.05, size=centers.shape)\n        elif iteration % 3 == 1:\n            # Halton sequence\n            centers = get_halton_centers(n)\n        else:\n            # Random uniform\n            centers = np.random.rand(n, 2)\n        return np.clip(centers, 0.05, 0.95)\n\n    def solve_lp_for_radii(centers):\n        n_circles = len(centers)\n        c = -np.ones(n_circles)\n        num_overlap = n_circles * (n_circles - 1) // 2\n        A_ub = np.zeros((num_overlap, n_circles))\n        b_ub = np.zeros(num_overlap)\n        idx = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                A_ub[idx, i] = 1\n                A_ub[idx, j] = 1\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                b_ub[idx] = dist\n                idx += 1\n        \n        bounds = []\n        for i in range(n_circles):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            bounds.append((0, max(0, max_r)))\n            \n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                return res.x\n        except:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n            if res.success:\n                return res.x\n        return np.full(n_circles, 0.01)\n\n    def obj_fun(params):\n        return -np.sum(params[2::3])\n\n    def obj_jac(params):\n        grad = np.zeros_like(params)\n        grad[2::3] = -1.0\n        return grad\n\n    def get_constraints(params):\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        c_b = np.empty(4 * N)\n        c_b[0::4] = x - r\n        c_b[1::4] = 1 - x - r\n        c_b[2::4] = y - r\n        c_b[3::4] = 1 - y - r\n        \n        c_o = np.empty(N * (N - 1) // 2)\n        idx = 0\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            sr = r[i] + r[i+1:]\n            num = N - 1 - i\n            c_o[idx:idx+num] = dx*dx + dy*dy - sr*sr\n            idx += num\n        return np.concatenate([c_b, c_o])\n\n    def get_jacobian(params):\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        jac_b = np.zeros((4 * N, 3 * N))\n        for i in range(N):\n            jac_b[4*i, 3*i], jac_b[4*i, 3*i+2] = 1, -1\n            jac_b[4*i+1, 3*i], jac_b[4*i+1, 3*i+2] = -1, -1\n            jac_b[4*i+2, 3*i+1], jac_b[4*i+2, 3*i+2] = 1, -1\n            jac_b[4*i+3, 3*i+1], jac_b[4*i+3, 3*i+2] = -1, -1\n            \n        jac_o = np.zeros((N * (N - 1) // 2, 3 * N))\n        row_idx = 0\n        for i in range(N):\n            num = N - 1 - i\n            idx_j = np.arange(i + 1, N)\n            dx, dy, sr = x[i] - x[idx_j], y[i] - y[idx_j], r[i] + r[idx_j]\n            jac_o[row_idx:row_idx+num, 3*i] = 2 * dx\n            jac_o[row_idx:row_idx+num, 3*i+1] = 2 * dy\n            jac_o[row_idx:row_idx+num, 3*i+2] = -2 * sr\n            rows = np.arange(row_idx, row_idx + num)\n            jac_o[rows, 3*idx_j] = -2 * dx\n            jac_o[rows, 3*idx_j+1] = -2 * dy\n            jac_o[rows, 3*idx_j+2] = -2 * sr\n            row_idx += num\n        return np.vstack([jac_b, jac_o])\n\n    best_sum = 0\n    best_params = None\n    iteration = 0\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    con = {'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian}\n\n    while time.time() - start_time < 275:\n        if best_params is not None and random.random() < 0.4:\n            # Shake the best centers\n            curr_centers = np.stack([best_params[0::3], best_params[1::3]], axis=1)\n            centers = curr_centers + np.random.normal(0, 0.03, size=curr_centers.shape)\n            centers = np.clip(centers, 0.01, 0.99)\n            radii = solve_lp_for_radii(centers)\n            x0 = np.zeros(3 * N)\n            x0[0::3], x0[1::3], x0[2::3] = centers[:, 0], centers[:, 1], radii\n        else:\n            centers = get_initial_centers(N, iteration)\n            radii = solve_lp_for_radii(centers)\n            x0 = np.zeros(3 * N)\n            x0[0::3], x0[1::3], x0[2::3] = centers[:, 0], centers[:, 1], radii\n        \n        res = minimize(obj_fun, x0, jac=obj_jac, constraints=con, bounds=bounds, method='SLSQP', options={'maxiter': 150})\n        \n        current_centers = np.stack([res.x[0::3], res.x[1::3]], axis=1)\n        feasible_radii = solve_lp_for_radii(current_centers)\n        current_sum = np.sum(feasible_radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_params = np.zeros(3 * N)\n            best_params[0::3], best_params[1::3], best_params[2::3] = current_centers[:, 0], current_centers[:, 1], feasible_radii\n            \n        iteration += 1\n\n    final_centers = np.stack([best_params[0::3], best_params[1::3]], axis=1)\n    final_radii = solve_lp_for_radii(final_centers)\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum",
  "metrics": {
    "valid": true,
    "score": 2.63429243877358,
    "eval_time": 277.50826716423035,
    "error": null
  },
  "prompt": "Use an 'Iterative Expansion' strategy for 26 circles:\n1. Start with 26 points using a low-discrepancy sequence (like Sobol or Halton) or a grid with jitter.\n2. Treat the radii as variables. Objective: maximize sum(radii).\n3. Constraints: dist(c_i, c_j) >= r_i + r_j and 0 + r_i <= x,y <= 1 - r_i.\n4. Use a multi-start approach. In each start, first solve a feasibility problem to find valid radii for fixed centers, then optimize centers and radii together using SLSQP.\n5. If the solver gets stuck, try 'shaking' the centers and re-optimizing.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\nimport random\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses an iterative expansion strategy with multi-start SLSQP and LP for initial radii.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def get_halton_centers(n):\n        def halton(n_pts, base):\n            seq = np.zeros(n_pts)\n            for i in range(n_pts):\n                f, r, curr = 1, 0, i + 1\n                while curr > 0:\n                    f /= base\n                    r += f * (curr % base)\n                    curr //= base\n                seq[i] = r\n            return seq\n        return np.stack([halton(n, 2), halton(n, 3)], axis=1)\n\n    def get_initial_centers(n, iteration):\n        if iteration % 3 == 0:\n            # Jittered 5x5 grid + 1 random point\n            xs = np.linspace(0.15, 0.85, 5)\n            ys = np.linspace(0.15, 0.85, 5)\n            xi, yi = np.meshgrid(xs, ys)\n            centers = np.stack([xi.ravel(), yi.ravel()], axis=1)\n            while len(centers) < n:\n                centers = np.vstack([centers, np.random.rand(2)])\n            centers += np.random.uniform(-0.05, 0.05, size=centers.shape)\n        elif iteration % 3 == 1:\n            # Halton sequence\n            centers = get_halton_centers(n)\n        else:\n            # Random uniform\n            centers = np.random.rand(n, 2)\n        return np.clip(centers, 0.05, 0.95)\n\n    def solve_lp_for_radii(centers):\n        n_circles = len(centers)\n        c = -np.ones(n_circles)\n        num_overlap = n_circles * (n_circles - 1) // 2\n        A_ub = np.zeros((num_overlap, n_circles))\n        b_ub = np.zeros(num_overlap)\n        idx = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                A_ub[idx, i] = 1\n                A_ub[idx, j] = 1\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                b_ub[idx] = dist\n                idx += 1\n        \n        bounds = []\n        for i in range(n_circles):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            bounds.append((0, max(0, max_r)))\n            \n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                return res.x\n        except:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n            if res.success:\n                return res.x\n        return np.full(n_circles, 0.01)\n\n    def obj_fun(params):\n        return -np.sum(params[2::3])\n\n    def obj_jac(params):\n        grad = np.zeros_like(params)\n        grad[2::3] = -1.0\n        return grad\n\n    def get_constraints(params):\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        c_b = np.empty(4 * N)\n        c_b[0::4] = x - r\n        c_b[1::4] = 1 - x - r\n        c_b[2::4] = y - r\n        c_b[3::4] = 1 - y - r\n        \n        c_o = np.empty(N * (N - 1) // 2)\n        idx = 0\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            sr = r[i] + r[i+1:]\n            num = N - 1 - i\n            c_o[idx:idx+num] = dx*dx + dy*dy - sr*sr\n            idx += num\n        return np.concatenate([c_b, c_o])\n\n    def get_jacobian(params):\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        jac_b = np.zeros((4 * N, 3 * N))\n        for i in range(N):\n            jac_b[4*i, 3*i], jac_b[4*i, 3*i+2] = 1, -1\n            jac_b[4*i+1, 3*i], jac_b[4*i+1, 3*i+2] = -1, -1\n            jac_b[4*i+2, 3*i+1], jac_b[4*i+2, 3*i+2] = 1, -1\n            jac_b[4*i+3, 3*i+1], jac_b[4*i+3, 3*i+2] = -1, -1\n            \n        jac_o = np.zeros((N * (N - 1) // 2, 3 * N))\n        row_idx = 0\n        for i in range(N):\n            num = N - 1 - i\n            idx_j = np.arange(i + 1, N)\n            dx, dy, sr = x[i] - x[idx_j], y[i] - y[idx_j], r[i] + r[idx_j]\n            jac_o[row_idx:row_idx+num, 3*i] = 2 * dx\n            jac_o[row_idx:row_idx+num, 3*i+1] = 2 * dy\n            jac_o[row_idx:row_idx+num, 3*i+2] = -2 * sr\n            rows = np.arange(row_idx, row_idx + num)\n            jac_o[rows, 3*idx_j] = -2 * dx\n            jac_o[rows, 3*idx_j+1] = -2 * dy\n            jac_o[rows, 3*idx_j+2] = -2 * sr\n            row_idx += num\n        return np.vstack([jac_b, jac_o])\n\n    best_sum = 0\n    best_params = None\n    iteration = 0\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n    con = {'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian}\n\n    while time.time() - start_time < 275:\n        if best_params is not None and random.random() < 0.4:\n            # Shake the best centers\n            curr_centers = np.stack([best_params[0::3], best_params[1::3]], axis=1)\n            centers = curr_centers + np.random.normal(0, 0.03, size=curr_centers.shape)\n            centers = np.clip(centers, 0.01, 0.99)\n            radii = solve_lp_for_radii(centers)\n            x0 = np.zeros(3 * N)\n            x0[0::3], x0[1::3], x0[2::3] = centers[:, 0], centers[:, 1], radii\n        else:\n            centers = get_initial_centers(N, iteration)\n            radii = solve_lp_for_radii(centers)\n            x0 = np.zeros(3 * N)\n            x0[0::3], x0[1::3], x0[2::3] = centers[:, 0], centers[:, 1], radii\n        \n        res = minimize(obj_fun, x0, jac=obj_jac, constraints=con, bounds=bounds, method='SLSQP', options={'maxiter': 150})\n        \n        current_centers = np.stack([res.x[0::3], res.x[1::3]], axis=1)\n        feasible_radii = solve_lp_for_radii(current_centers)\n        current_sum = np.sum(feasible_radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_params = np.zeros(3 * N)\n            best_params[0::3], best_params[1::3], best_params[2::3] = current_centers[:, 0], current_centers[:, 1], feasible_radii\n            \n        iteration += 1\n\n    final_centers = np.stack([best_params[0::3], best_params[1::3]], axis=1)\n    final_radii = solve_lp_for_radii(final_centers)\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:35:03.839796",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 392,
        "candidates_token_count": 2329,
        "thoughts_token_count": 19245
      },
      "response_text_len": 6169
    }
  },
  "llm_call_duration_s": 116.62644534301944,
  "eval_duration_s": 277.50827755290084
}