{
  "trial_id": "trial_3_4",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The optimization utilizes multiple initializations including grid and hexagonal-like\n    layouts, followed by high-precision local optimization using SLSQP.\n    \"\"\"\n    n = 26\n\n    def get_initial_guess(mode):\n        \"\"\"Generates different initial center configurations to explore the search space.\"\"\"\n        np.random.seed(mode)\n        if mode == 0:\n            # 5x5 grid with one additional circle in the center\n            xs = np.linspace(0.1, 0.9, 5)\n            ys = np.linspace(0.1, 0.9, 5)\n            X, Y = np.meshgrid(xs, ys)\n            centers = np.vstack([X.ravel(), Y.ravel()]).T\n            centers = np.vstack([centers, [0.5, 0.5]])\n        elif mode == 1:\n            # 6x5 grid layout\n            nx, ny = 6, 5\n            xs = np.linspace(0.1, 0.9, nx)\n            ys = np.linspace(0.1, 0.9, ny)\n            X, Y = np.meshgrid(xs, ys)\n            centers = np.vstack([X.ravel(), Y.ravel()]).T\n        elif mode == 2:\n            # 5x6 grid layout\n            nx, ny = 5, 6\n            xs = np.linspace(0.1, 0.9, nx)\n            ys = np.linspace(0.1, 0.9, ny)\n            X, Y = np.meshgrid(xs, ys)\n            centers = np.vstack([X.ravel(), Y.ravel()]).T\n        elif mode == 3:\n            # Hexagonal-like staggered rows\n            centers = []\n            for r_idx in range(6):\n                for c_idx in range(5):\n                    x = 0.1 + c_idx * 0.2 + (0.1 if r_idx % 2 == 1 else 0)\n                    y = 0.1 + r_idx * 0.17\n                    centers.append([x, y])\n            centers = np.array(centers)\n        else:\n            # Random initialization\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n        \n        # Trim to exactly n circles and add slight noise to break symmetry\n        centers = centers[:n]\n        centers += np.random.normal(0, 0.005, centers.shape)\n        centers = np.clip(centers, 0.05, 0.95)\n        return centers, np.full(n, 0.05)\n\n    def objective(X):\n        \"\"\"Objective function: Minimize negative sum of radii to maximize the sum.\"\"\"\n        return -np.sum(X[2*n:])\n    \n    def jac_obj(X):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n    \n    def cons_fn(X):\n        \"\"\"Combined inequality constraints: box boundaries and circle overlaps.\"\"\"\n        x, y, r = X[:n], X[n:2*n], X[2*n:]\n        # Box constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_box = np.zeros(4*n)\n        c_box[0::4] = x - r\n        c_box[1::4] = 1.0 - x - r\n        c_box[2::4] = y - r\n        c_box[3::4] = 1.0 - y - r\n        \n        # Overlap constraints: dist^2 - (ri+rj)^2 >= 0\n        i, j = np.triu_indices(n, k=1)\n        c_ov = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n        return np.concatenate([c_box, c_ov])\n\n    def jac_cons(X):\n        \"\"\"Jacobian of the constraints matrix.\"\"\"\n        x, y, r = X[:n], X[n:2*n], X[2*n:]\n        num_ov = n * (n - 1) // 2\n        jac = np.zeros((4 * n + num_ov, 3 * n))\n        \n        # Box constraint derivatives\n        for i in range(n):\n            jac[4*i, i] = 1; jac[4*i, 2*n+i] = -1\n            jac[4*i+1, i] = -1; jac[4*i+1, 2*n+i] = -1\n            jac[4*i+2, n+i] = 1; jac[4*i+2, 2*n+i] = -1\n            jac[4*i+3, n+i] = -1; jac[4*i+3, 2*n+i] = -1\n        \n        # Overlap constraint derivatives\n        i, j = np.triu_indices(n, k=1)\n        row_indices = np.arange(4 * n, 4 * n + num_ov)\n        dx, dy, dr = x[i] - x[j], y[i] - y[j], r[i] + r[j]\n        \n        jac[row_indices, i] = 2 * dx\n        jac[row_indices, j] = -2 * dx\n        jac[row_indices, n+i] = 2 * dy\n        jac[row_indices, n+j] = -2 * dy\n        jac[row_indices, 2*n+i] = -2 * dr\n        jac[row_indices, 2*n+j] = -2 * dr\n        return jac\n\n    best_res_fun = np.inf\n    best_x = None\n\n    # Run optimization for several different initial starting points\n    for mode in range(5):\n        centers, r_init = get_initial_guess(mode)\n        x0 = np.concatenate([centers[:, 0], centers[:, 1], r_init])\n        \n        res = minimize(\n            objective, x0, method='SLSQP', jac=jac_obj,\n            constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_cons},\n            bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n            options={'maxiter': 600, 'ftol': 1e-10}\n        )\n        \n        if res.fun < best_res_fun:\n            best_res_fun = res.fun\n            best_x = res.x\n            \n    # Extract results from the best optimization run\n    centers_final = np.vstack([best_x[:n], best_x[n:2*n]]).T\n    radii_final = best_x[2*n:]\n    sum_radii_final = -best_res_fun\n    \n    return (centers_final, radii_final, sum_radii_final)",
  "metrics": {
    "valid": true,
    "score": 2.6190849734011312,
    "eval_time": 1.1681270599365234,
    "error": null
  },
  "prompt": "Try a dense hexagonal packing initialization for 26 circles. Since 26 isn't a perfect hexagonal number, fill a slightly larger grid and prune/adjust to fit the unit square. Then, use a high-precision optimizer (scipy.optimize.minimize with method='SLSQP' and tight tolerances) to maximize the sum of radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The optimization utilizes multiple initializations including grid and hexagonal-like\n    layouts, followed by high-precision local optimization using SLSQP.\n    \"\"\"\n    n = 26\n\n    def get_initial_guess(mode):\n        \"\"\"Generates different initial center configurations to explore the search space.\"\"\"\n        np.random.seed(mode)\n        if mode == 0:\n            # 5x5 grid with one additional circle in the center\n            xs = np.linspace(0.1, 0.9, 5)\n            ys = np.linspace(0.1, 0.9, 5)\n            X, Y = np.meshgrid(xs, ys)\n            centers = np.vstack([X.ravel(), Y.ravel()]).T\n            centers = np.vstack([centers, [0.5, 0.5]])\n        elif mode == 1:\n            # 6x5 grid layout\n            nx, ny = 6, 5\n            xs = np.linspace(0.1, 0.9, nx)\n            ys = np.linspace(0.1, 0.9, ny)\n            X, Y = np.meshgrid(xs, ys)\n            centers = np.vstack([X.ravel(), Y.ravel()]).T\n        elif mode == 2:\n            # 5x6 grid layout\n            nx, ny = 5, 6\n            xs = np.linspace(0.1, 0.9, nx)\n            ys = np.linspace(0.1, 0.9, ny)\n            X, Y = np.meshgrid(xs, ys)\n            centers = np.vstack([X.ravel(), Y.ravel()]).T\n        elif mode == 3:\n            # Hexagonal-like staggered rows\n            centers = []\n            for r_idx in range(6):\n                for c_idx in range(5):\n                    x = 0.1 + c_idx * 0.2 + (0.1 if r_idx % 2 == 1 else 0)\n                    y = 0.1 + r_idx * 0.17\n                    centers.append([x, y])\n            centers = np.array(centers)\n        else:\n            # Random initialization\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n        \n        # Trim to exactly n circles and add slight noise to break symmetry\n        centers = centers[:n]\n        centers += np.random.normal(0, 0.005, centers.shape)\n        centers = np.clip(centers, 0.05, 0.95)\n        return centers, np.full(n, 0.05)\n\n    def objective(X):\n        \"\"\"Objective function: Minimize negative sum of radii to maximize the sum.\"\"\"\n        return -np.sum(X[2*n:])\n    \n    def jac_obj(X):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n    \n    def cons_fn(X):\n        \"\"\"Combined inequality constraints: box boundaries and circle overlaps.\"\"\"\n        x, y, r = X[:n], X[n:2*n], X[2*n:]\n        # Box constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_box = np.zeros(4*n)\n        c_box[0::4] = x - r\n        c_box[1::4] = 1.0 - x - r\n        c_box[2::4] = y - r\n        c_box[3::4] = 1.0 - y - r\n        \n        # Overlap constraints: dist^2 - (ri+rj)^2 >= 0\n        i, j = np.triu_indices(n, k=1)\n        c_ov = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n        return np.concatenate([c_box, c_ov])\n\n    def jac_cons(X):\n        \"\"\"Jacobian of the constraints matrix.\"\"\"\n        x, y, r = X[:n], X[n:2*n], X[2*n:]\n        num_ov = n * (n - 1) // 2\n        jac = np.zeros((4 * n + num_ov, 3 * n))\n        \n        # Box constraint derivatives\n        for i in range(n):\n            jac[4*i, i] = 1; jac[4*i, 2*n+i] = -1\n            jac[4*i+1, i] = -1; jac[4*i+1, 2*n+i] = -1\n            jac[4*i+2, n+i] = 1; jac[4*i+2, 2*n+i] = -1\n            jac[4*i+3, n+i] = -1; jac[4*i+3, 2*n+i] = -1\n        \n        # Overlap constraint derivatives\n        i, j = np.triu_indices(n, k=1)\n        row_indices = np.arange(4 * n, 4 * n + num_ov)\n        dx, dy, dr = x[i] - x[j], y[i] - y[j], r[i] + r[j]\n        \n        jac[row_indices, i] = 2 * dx\n        jac[row_indices, j] = -2 * dx\n        jac[row_indices, n+i] = 2 * dy\n        jac[row_indices, n+j] = -2 * dy\n        jac[row_indices, 2*n+i] = -2 * dr\n        jac[row_indices, 2*n+j] = -2 * dr\n        return jac\n\n    best_res_fun = np.inf\n    best_x = None\n\n    # Run optimization for several different initial starting points\n    for mode in range(5):\n        centers, r_init = get_initial_guess(mode)\n        x0 = np.concatenate([centers[:, 0], centers[:, 1], r_init])\n        \n        res = minimize(\n            objective, x0, method='SLSQP', jac=jac_obj,\n            constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_cons},\n            bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n            options={'maxiter': 600, 'ftol': 1e-10}\n        )\n        \n        if res.fun < best_res_fun:\n            best_res_fun = res.fun\n            best_x = res.x\n            \n    # Extract results from the best optimization run\n    centers_final = np.vstack([best_x[:n], best_x[n:2*n]]).T\n    radii_final = best_x[2*n:]\n    sum_radii_final = -best_res_fun\n    \n    return (centers_final, radii_final, sum_radii_final)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:15:35.953028",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 300,
        "candidates_token_count": 1775,
        "thoughts_token_count": 15190
      },
      "response_text_len": 4839
    }
  },
  "llm_call_duration_s": 100.86029937199783,
  "eval_duration_s": 1.1681358439382166
}