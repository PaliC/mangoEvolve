{
  "trial_id": "trial_3_2",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses a force-directed initialization followed by a two-stage \n    SLSQP optimization (equal radii optimization then full radii sum maximization).\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Precompute indices for constraints and Jacobian\n    iu = np.triu_indices(N, k=1)\n    i_idx, j_idx = iu\n    num_cc = N * (N - 1) // 2\n    row_indices_cc = np.arange(num_cc)\n\n    # Constraint function for equal radii case\n    def constr_equal(v):\n        x = v[:2*N:2]\n        y = v[1:2*N:2]\n        r = v[2*N]\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        cc = dx**2 + dy**2 - 4*r**2\n        b = np.zeros(4*N)\n        b[0::4] = x - r\n        b[1::4] = 1 - x - r\n        b[2::4] = y - r\n        b[3::4] = 1 - y - r\n        return np.concatenate([cc, b])\n\n    # Jacobian for equal radii constraints\n    def jac_equal(v):\n        x = v[:2*N:2]\n        y = v[1:2*N:2]\n        r = v[2*N]\n        jac = np.zeros((num_cc + 4*N, 2*N + 1))\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        jac[row_indices_cc, 2*i_idx] = 2 * dx\n        jac[row_indices_cc, 2*j_idx] = -2 * dx\n        jac[row_indices_cc, 2*i_idx+1] = 2 * dy\n        jac[row_indices_cc, 2*j_idx+1] = -2 * dy\n        jac[row_indices_cc, 2*N] = -8 * r\n        for i in range(N):\n            jac[num_cc + 4*i, 2*i] = 1; jac[num_cc + 4*i, 2*N] = -1\n            jac[num_cc + 4*i+1, 2*i] = -1; jac[num_cc + 4*i+1, 2*N] = -1\n            jac[num_cc + 4*i+2, 2*i+1] = 1; jac[num_cc + 4*i+2, 2*N] = -1\n            jac[num_cc + 4*i+3, 2*i+1] = -1; jac[num_cc + 4*i+3, 2*N] = -1\n        return jac\n\n    # Constraint function for general radii case\n    def constr_full(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        cc = dx**2 + dy**2 - dr**2\n        b = np.zeros(4*N)\n        b[0::4] = x - r\n        b[1::4] = 1 - x - r\n        b[2::4] = y - r\n        b[3::4] = 1 - y - r\n        return np.concatenate([cc, b])\n\n    # Jacobian for general radii constraints\n    def jac_full(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n        jac = np.zeros((num_cc + 4*N, 3*N))\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        jac[row_indices_cc, 3*i_idx] = 2 * dx\n        jac[row_indices_cc, 3*j_idx] = -2 * dx\n        jac[row_indices_cc, 3*i_idx+1] = 2 * dy\n        jac[row_indices_cc, 3*j_idx+1] = -2 * dy\n        jac[row_indices_cc, 3*i_idx+2] = -2 * dr\n        jac[row_indices_cc, 3*j_idx+2] = -2 * dr\n        for i in range(N):\n            jac[num_cc + 4*i, 3*i] = 1; jac[num_cc + 4*i, 3*i+2] = -1\n            jac[num_cc + 4*i+1, 3*i] = -1; jac[num_cc + 4*i+1, 3*i+2] = -1\n            jac[num_cc + 4*i+2, 3*i+1] = 1; jac[num_cc + 4*i+2, 3*i+2] = -1\n            jac[num_cc + 4*i+3, 3*i+1] = -1; jac[num_cc + 4*i+3, 3*i+2] = -1\n        return jac\n\n    # Force-directed spreading of centers\n    def spread(centers, r=0.095, iterations=200):\n        c = centers.copy()\n        for _ in range(iterations):\n            dx = c[:, np.newaxis, 0] - c[np.newaxis, :, 0]\n            dy = c[:, np.newaxis, 1] - c[np.newaxis, :, 1]\n            dist = np.sqrt(dx**2 + dy**2) + 1e-9\n            overlap = 2*r - dist\n            overlap[overlap < 0] = 0\n            np.fill_diagonal(overlap, 0)\n            c[:, 0] += (overlap * dx / dist).sum(axis=1) * 0.05\n            c[:, 1] += (overlap * dy / dist).sum(axis=1) * 0.05\n            c = np.clip(c, r, 1-r)\n        return c\n\n    best_sum_r = 0\n    best_v = None\n\n    # Initial layouts to try\n    layouts = []\n    # Grid 5x5 + 1\n    c_grid = []\n    for i in [0.1, 0.3, 0.5, 0.7, 0.9]:\n        for j in [0.1, 0.3, 0.5, 0.7, 0.9]:\n            c_grid.append([i, j])\n    c_grid.append([0.5, 0.5])\n    layouts.append(np.array(c_grid) + np.random.normal(0, 0.001, (26, 2)))\n    \n    # Grid 6x5 take 26\n    c_grid65 = []\n    for i in np.linspace(0.1, 0.9, 6):\n        for j in np.linspace(0.1, 0.9, 5):\n            c_grid65.append([i, j])\n    layouts.append(np.array(c_grid65[:26]) + np.random.normal(0, 0.001, (26, 2)))\n    \n    # Random layouts\n    for _ in range(15):\n        layouts.append(np.random.rand(N, 2))\n\n    # Multi-start optimization loop\n    for layout in layouts:\n        if time.time() - start_time > 260:\n            break\n        \n        c_spread = spread(layout, 0.095)\n        \n        # Step 1: Maximize equal radius r\n        v0_equal = np.zeros(2*N + 1)\n        v0_equal[:2*N] = c_spread.flatten()\n        v0_equal[2*N] = 0.095\n        res_eq = minimize(lambda v: -v[2*N], v0_equal, \n                          jac=lambda v: np.concatenate([np.zeros(2*N), [-1.0]]),\n                          constraints={'type': 'ineq', 'fun': constr_equal, 'jac': jac_equal},\n                          method='SLSQP', options={'maxiter': 100})\n        \n        # Step 2: Maximize sum of radii starting from Step 1 result\n        v0_full = np.zeros(3*N)\n        v0_full[0::3] = res_eq.x[:2*N:2]\n        v0_full[1::3] = res_eq.x[1:2*N:2]\n        v0_full[2::3] = res_eq.x[2*N]\n        res_full = minimize(lambda v: -np.sum(v[2::3]), v0_full,\n                            jac=lambda v: np.tile([0, 0, -1.0], N),\n                            constraints={'type': 'ineq', 'fun': constr_full, 'jac': jac_full},\n                            method='SLSQP', options={'maxiter': 100})\n        \n        if -res_full.fun > best_sum_r:\n            best_sum_r = -res_full.fun\n            best_v = res_full.x\n            \n    # Prepare output\n    x_final = best_v[0::3]\n    y_final = best_v[1::3]\n    r_final = best_v[2::3]\n    centers_final = np.stack([x_final, y_final], axis=1)\n    \n    return centers_final, r_final, best_sum_r",
  "metrics": {
    "valid": true,
    "score": 2.627118577997429,
    "eval_time": 15.479114532470703,
    "error": null
  },
  "prompt": "Implement a force-directed packing algorithm. Treat 26 circles as particles with repulsive forces and a boundary force keeping them in [0, 1]x[0, 1]. Gradually increase their 'radii' while minimizing overlap energy. Finally, refine the result using scipy.optimize.minimize (SLSQP) to maximize the sum of radii while strictly enforcing non-overlap constraints.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses a force-directed initialization followed by a two-stage \n    SLSQP optimization (equal radii optimization then full radii sum maximization).\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Precompute indices for constraints and Jacobian\n    iu = np.triu_indices(N, k=1)\n    i_idx, j_idx = iu\n    num_cc = N * (N - 1) // 2\n    row_indices_cc = np.arange(num_cc)\n\n    # Constraint function for equal radii case\n    def constr_equal(v):\n        x = v[:2*N:2]\n        y = v[1:2*N:2]\n        r = v[2*N]\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        cc = dx**2 + dy**2 - 4*r**2\n        b = np.zeros(4*N)\n        b[0::4] = x - r\n        b[1::4] = 1 - x - r\n        b[2::4] = y - r\n        b[3::4] = 1 - y - r\n        return np.concatenate([cc, b])\n\n    # Jacobian for equal radii constraints\n    def jac_equal(v):\n        x = v[:2*N:2]\n        y = v[1:2*N:2]\n        r = v[2*N]\n        jac = np.zeros((num_cc + 4*N, 2*N + 1))\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        jac[row_indices_cc, 2*i_idx] = 2 * dx\n        jac[row_indices_cc, 2*j_idx] = -2 * dx\n        jac[row_indices_cc, 2*i_idx+1] = 2 * dy\n        jac[row_indices_cc, 2*j_idx+1] = -2 * dy\n        jac[row_indices_cc, 2*N] = -8 * r\n        for i in range(N):\n            jac[num_cc + 4*i, 2*i] = 1; jac[num_cc + 4*i, 2*N] = -1\n            jac[num_cc + 4*i+1, 2*i] = -1; jac[num_cc + 4*i+1, 2*N] = -1\n            jac[num_cc + 4*i+2, 2*i+1] = 1; jac[num_cc + 4*i+2, 2*N] = -1\n            jac[num_cc + 4*i+3, 2*i+1] = -1; jac[num_cc + 4*i+3, 2*N] = -1\n        return jac\n\n    # Constraint function for general radii case\n    def constr_full(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        cc = dx**2 + dy**2 - dr**2\n        b = np.zeros(4*N)\n        b[0::4] = x - r\n        b[1::4] = 1 - x - r\n        b[2::4] = y - r\n        b[3::4] = 1 - y - r\n        return np.concatenate([cc, b])\n\n    # Jacobian for general radii constraints\n    def jac_full(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n        jac = np.zeros((num_cc + 4*N, 3*N))\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        jac[row_indices_cc, 3*i_idx] = 2 * dx\n        jac[row_indices_cc, 3*j_idx] = -2 * dx\n        jac[row_indices_cc, 3*i_idx+1] = 2 * dy\n        jac[row_indices_cc, 3*j_idx+1] = -2 * dy\n        jac[row_indices_cc, 3*i_idx+2] = -2 * dr\n        jac[row_indices_cc, 3*j_idx+2] = -2 * dr\n        for i in range(N):\n            jac[num_cc + 4*i, 3*i] = 1; jac[num_cc + 4*i, 3*i+2] = -1\n            jac[num_cc + 4*i+1, 3*i] = -1; jac[num_cc + 4*i+1, 3*i+2] = -1\n            jac[num_cc + 4*i+2, 3*i+1] = 1; jac[num_cc + 4*i+2, 3*i+2] = -1\n            jac[num_cc + 4*i+3, 3*i+1] = -1; jac[num_cc + 4*i+3, 3*i+2] = -1\n        return jac\n\n    # Force-directed spreading of centers\n    def spread(centers, r=0.095, iterations=200):\n        c = centers.copy()\n        for _ in range(iterations):\n            dx = c[:, np.newaxis, 0] - c[np.newaxis, :, 0]\n            dy = c[:, np.newaxis, 1] - c[np.newaxis, :, 1]\n            dist = np.sqrt(dx**2 + dy**2) + 1e-9\n            overlap = 2*r - dist\n            overlap[overlap < 0] = 0\n            np.fill_diagonal(overlap, 0)\n            c[:, 0] += (overlap * dx / dist).sum(axis=1) * 0.05\n            c[:, 1] += (overlap * dy / dist).sum(axis=1) * 0.05\n            c = np.clip(c, r, 1-r)\n        return c\n\n    best_sum_r = 0\n    best_v = None\n\n    # Initial layouts to try\n    layouts = []\n    # Grid 5x5 + 1\n    c_grid = []\n    for i in [0.1, 0.3, 0.5, 0.7, 0.9]:\n        for j in [0.1, 0.3, 0.5, 0.7, 0.9]:\n            c_grid.append([i, j])\n    c_grid.append([0.5, 0.5])\n    layouts.append(np.array(c_grid) + np.random.normal(0, 0.001, (26, 2)))\n    \n    # Grid 6x5 take 26\n    c_grid65 = []\n    for i in np.linspace(0.1, 0.9, 6):\n        for j in np.linspace(0.1, 0.9, 5):\n            c_grid65.append([i, j])\n    layouts.append(np.array(c_grid65[:26]) + np.random.normal(0, 0.001, (26, 2)))\n    \n    # Random layouts\n    for _ in range(15):\n        layouts.append(np.random.rand(N, 2))\n\n    # Multi-start optimization loop\n    for layout in layouts:\n        if time.time() - start_time > 260:\n            break\n        \n        c_spread = spread(layout, 0.095)\n        \n        # Step 1: Maximize equal radius r\n        v0_equal = np.zeros(2*N + 1)\n        v0_equal[:2*N] = c_spread.flatten()\n        v0_equal[2*N] = 0.095\n        res_eq = minimize(lambda v: -v[2*N], v0_equal, \n                          jac=lambda v: np.concatenate([np.zeros(2*N), [-1.0]]),\n                          constraints={'type': 'ineq', 'fun': constr_equal, 'jac': jac_equal},\n                          method='SLSQP', options={'maxiter': 100})\n        \n        # Step 2: Maximize sum of radii starting from Step 1 result\n        v0_full = np.zeros(3*N)\n        v0_full[0::3] = res_eq.x[:2*N:2]\n        v0_full[1::3] = res_eq.x[1:2*N:2]\n        v0_full[2::3] = res_eq.x[2*N]\n        res_full = minimize(lambda v: -np.sum(v[2::3]), v0_full,\n                            jac=lambda v: np.tile([0, 0, -1.0], N),\n                            constraints={'type': 'ineq', 'fun': constr_full, 'jac': jac_full},\n                            method='SLSQP', options={'maxiter': 100})\n        \n        if -res_full.fun > best_sum_r:\n            best_sum_r = -res_full.fun\n            best_v = res_full.x\n            \n    # Prepare output\n    x_final = best_v[0::3]\n    y_final = best_v[1::3]\n    r_final = best_v[2::3]\n    centers_final = np.stack([x_final, y_final], axis=1)\n    \n    return centers_final, r_final, best_sum_r\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:16:34.222902",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 308,
        "candidates_token_count": 2543,
        "thoughts_token_count": 23866
      },
      "response_text_len": 5957
    }
  },
  "llm_call_duration_s": 144.81944040302187,
  "eval_duration_s": 15.479123911936767
}