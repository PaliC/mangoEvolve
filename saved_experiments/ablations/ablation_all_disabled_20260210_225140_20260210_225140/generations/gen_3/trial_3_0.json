{
  "trial_id": "trial_3_0",
  "generation": 3,
  "parent_id": "trial_2_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef run_packing():\n    N = 26\n    start_time = time.time()\n\n    def objective(X):\n        # We want to maximize the sum of radii, so minimize the negative sum.\n        return -np.sum(X[2::3])\n\n    def jac_objective(X):\n        j = np.zeros(3 * N)\n        j[2::3] = -1.0\n        return j\n\n    def constraints(X):\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        # Number of constraints: 4*N (boundary) + N*(N-1)//2 (overlap)\n        cons = np.zeros(4 * N + N * (N - 1) // 2)\n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        cons[0:N] = x - r\n        cons[N:2*N] = 1 - x - r\n        cons[2*N:3*N] = y - r\n        cons[3*N:4*N] = 1 - y - r\n        \n        idx = 4 * N\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            rr = r[i] + r[i+1:]\n            # Overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n            cons[idx:idx+N-1-i] = dx**2 + dy**2 - rr**2\n            idx += N - 1 - i\n        return cons\n\n    def jac_constraints(X):\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        num_cons = 4 * N + N * (N - 1) // 2\n        jac = np.zeros((num_cons, 3 * N))\n        \n        # Boundary\n        idx_N = np.arange(N)\n        jac[idx_N, 3*idx_N] = 1; jac[idx_N, 3*idx_N+2] = -1\n        jac[idx_N+N, 3*idx_N] = -1; jac[idx_N+N, 3*idx_N+2] = -1\n        jac[idx_N+2*N, 3*idx_N+1] = 1; jac[idx_N+2*N, 3*idx_N+2] = -1\n        jac[idx_N+3*N, 3*idx_N+1] = -1; jac[idx_N+3*N, 3*idx_N+2] = -1\n        \n        # Overlap\n        idx = 4 * N\n        for i in range(N):\n            num_j = N - 1 - i\n            target_idx = np.arange(idx, idx + num_j)\n            j_indices = np.arange(i + 1, N)\n            dx, dy, rr = x[i] - x[j_indices], y[i] - y[j_indices], r[i] + r[j_indices]\n            \n            jac[target_idx, 3*i] = 2 * dx\n            jac[target_idx, 3*i+1] = 2 * dy\n            jac[target_idx, 3*i+2] = -2 * rr\n            \n            jac[target_idx, 3*j_indices] = -2 * dx\n            jac[target_idx, 3*j_indices+1] = -2 * dy\n            jac[target_idx, 3*j_indices+2] = -2 * rr\n            idx += num_j\n        return jac\n\n    def force_directed(N):\n        x, y = np.random.rand(N), np.random.rand(N)\n        r = 0.05\n        for _ in range(400):\n            fx, fy = np.zeros(N), np.zeros(N)\n            for i in range(N):\n                dx, dy = x[i] - x[i+1:], y[i] - y[i+1:]\n                d = np.hypot(dx, dy) + 1e-9\n                mask = d < 2 * r\n                f = (2 * r - d[mask]) / d[mask]\n                fx[i] += np.sum(dx[mask] * f)\n                fy[i] += np.sum(dy[mask] * f)\n                fx[i+1:][mask] -= dx[mask] * f\n                fy[i+1:][mask] -= dy[mask] * f\n            x += fx * 0.02\n            y += fy * 0.02\n            x, y = np.clip(x, r, 1-r), np.clip(y, r, 1-r)\n            r += 0.0001\n        return x, y, r\n\n    # Initial Grid-based Guess\n    x_grid, y_grid = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    X0_grid = np.zeros(3 * N)\n    X0_grid[0:3*25:3], X0_grid[1:3*25:3], X0_grid[2:3*25:3] = x_grid.flatten(), y_grid.flatten(), 0.09\n    X0_grid[75], X0_grid[76], X0_grid[77] = 0.5, 0.5, 0.01\n    \n    best_X = X0_grid\n    best_sum = -objective(X0_grid)\n\n    # Initial SLSQP on grid\n    try:\n        res = minimize(objective, X0_grid, method='SLSQP', jac=jac_objective,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=[(0, 1)] * (3 * N), options={'maxiter': 200, 'ftol': 1e-9})\n        if -res.fun > best_sum:\n            best_sum, best_X = -res.fun, res.x\n    except:\n        pass\n\n    # Multi-start loop\n    attempt = 0\n    while time.time() - start_time < 265:\n        try:\n            if attempt % 3 == 0:\n                x, y, r_val = force_directed(N)\n                X0 = np.zeros(3 * N)\n                X0[0::3], X0[1::3], X0[2::3] = x, y, r_val\n            else:\n                X0 = np.zeros(3 * N)\n                X0[0::3], X0[1::3], X0[2::3] = np.random.rand(N), np.random.rand(N), 0.08\n            \n            res = minimize(objective, X0, method='SLSQP', jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                           bounds=[(0, 1)] * (3 * N), options={'maxiter': 100, 'ftol': 1e-8})\n            \n            if -res.fun > best_sum:\n                best_sum, best_X = -res.fun, res.x\n                # Refine with basinhopping\n                res_bh = basinhopping(objective, res.x,\n                                      minimizer_kwargs={\n                                          'method': 'SLSQP', 'jac': jac_objective,\n                                          'constraints': {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                                          'bounds': [(0, 1)] * (3 * N), 'options': {'maxiter': 100, 'ftol': 1e-9}\n                                      }, niter=3, T=0.01, stepsize=0.02)\n                if -res_bh.fun > best_sum:\n                    best_sum, best_X = -res_bh.fun, res_bh.x\n        except:\n            pass\n        attempt += 1\n\n    # Final Refinement\n    res_final = minimize(objective, best_X, method='SLSQP', jac=jac_objective,\n                         constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                         bounds=[(0, 1)] * (3 * N), options={'maxiter': 500, 'ftol': 1e-12})\n    best_X = res_final.x\n    \n    centers = best_X.reshape(N, 3)[:, :2]\n    radii = best_X[2::3]\n    \n    # Strict validation and adjustment\n    for _ in range(20):\n        radii = np.maximum(radii, 0)\n        for i in range(N):\n            radii[i] = min(radii[i], centers[i,0], 1-centers[i,0], centers[i,1], 1-centers[i,1])\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                if radii[i] + radii[j] > d:\n                    diff = (radii[i] + radii[j] - d) + 1e-15\n                    sum_r = radii[i] + radii[j]\n                    if sum_r > 0:\n                        radii[i] -= diff * (radii[i] / sum_r)\n                        radii[j] -= diff * (radii[j] / sum_r)\n                    else:\n                        radii[i] = radii[j] = 0\n                        \n    return centers, radii, np.sum(radii)",
  "metrics": {
    "valid": true,
    "score": 2.5524661820983336,
    "eval_time": 273.09106254577637,
    "error": null
  },
  "prompt": "Improve this solution (score=2.630700304208408) by applying a more rigorous global optimization strategy. Use scipy.optimize.basinhopping with SLSQP as the local minimizer. The current best code is:\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    N = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    def get_initial_positions(N, attempt):\n        if attempt == 0:\n            # Start with a grid-like configuration\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x = np.append(x.flatten(), 0.5)\n            y = np.append(y.flatten(), 0.5)\n            x += np.random.normal(0, 0.01, N)\n            y += np.random.normal(0, 0.01, N)\n        else:\n            # Random initial positions\n            x = np.random.rand(N) * 0.8 + 0.1\n            y = np.random.rand(N) * 0.8 + 0.1\n        return x, y\n\n    def force_directed(x, y, N, iterations=1000):\n        r_val = 0.05\n        dt = 0.02\n        for _ in range(iterations):\n            fx, fy = np.zeros(N), np.zeros(N)\n            for i in range(N):\n                dx = x[i] - x[i+1:]\n                dy = y[i] - y[i+1:]\n                d2 = dx**2 + dy**2\n                mask = d2 < (2*r_val)**2\n                d = np.sqrt(d2[mask]) + 1e-12\n                f = (2*r_val - d) / d\n                fx[i] += np.sum(dx[mask] * f)\n                fy[i] += np.sum(dy[mask] * f)\n                fx[i+1:][mask] -= dx[mask] * f\n                fy[i+1:][mask] -= dy[mask] * f\n            \n            x += fx * dt\n            y += fy * dt\n            r_val += 0.00005\n            x = np.clip(x, r_val, 1-r_val)\n            y = np.clip(y, r_val, 1-r_val)\n            dt *= 0.9999\n        return x, y\n\n    def get_initial_r(x, y, N):\n        r = 1.0\n        for i in range(N):\n            r = min(r, x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n            for j in range(i + 1, N):\n                d = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                r = min(r, d / 2.0)\n        return max(r, 0.0)\n\n    def objective_r(X):\n        return -X[2*N]\n\n    def jac_objective_r(X):\n        j = np.zeros(2*N + 1)\n        j[2*N] = -1.0\n        return j\n\n    def constraints_r(X):\n        x, y, r = X[:2*N:2], X[1:2*N:2], X[2*N]\n        cons = np.zeros(4*N + N*(N-1)//2)\n        idx = 0\n        for i in range(N):\n            cons[idx] = x[i] - r; idx += 1\n            cons[idx] = 1.0 - x[i] - r; idx += 1\n            cons[idx] = y[i] - r; idx += 1\n            cons[idx] = 1.0 - y[i] - r; idx += 1\n        for i in range(N):\n            dx, dy = x[i] - x[i+1:], y[i] - y[i+1:]\n            cons[idx:idx+N-1-i] = dx**2 + dy**2 - 4*r**2\n            idx += N-1-i\n        return cons\n\n    def jac_constraints_r(X):\n        x, y, r = X[:2*N:2], X[1:2*N:2], X[2*N]\n        num_cons = 4*N + N*(N-1)//2\n        jac = np.zeros((num_cons, 2*N + 1))\n        idx = 0\n        for i in range(N):\n            jac[idx, 2*i] = 1.0; jac[idx, 2*N] = -1.0; idx += 1\n            jac[idx, 2*i] = -1.0; jac[idx, 2*N] = -1.0; idx += 1\n            jac[idx, 2*i+1] = 1.0; jac[idx, 2*N] = -1.0; idx += 1\n            jac[idx, 2*i+1] = -1.0; jac[idx, 2*N] = -1.0; idx += 1\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx, dy = x[i] - x[j], y[i] - y[j]\n                jac[idx, 2*i] = 2*dx; jac[idx, 2*j] = -2*dx\n                jac[idx, 2*i+1] = 2*dy; jac[idx, 2*j+1] = -2*dy\n                jac[idx, 2*N] = -8*r\n                idx += 1\n        return jac\n\n    def objective_sum(X):\n        return -np.sum(X[2::3])\n\n    def jac_objective_sum(X):\n        j = np.zeros(3*N)\n        j[2::3] = -1.0\n        return j\n\n    def constraints_sum(X):\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        cons = np.zeros(4*N + N*(N-1)//2)\n        idx = 0\n        for i in range(N):\n            cons[idx] = x[i] - r[i]; idx += 1\n            cons[idx] = 1.0 - x[i] - r[i]; idx += 1\n            cons[idx] = y[i] - r[i]; idx += 1\n            cons[idx] = 1.0 - y[i] - r[i]; idx += 1\n        for i in range(N):\n            for j in range(i + 1, N):\n                cons[idx] = (x[i]-x[j])**2 + (y[i]-y[j])**2 - (r[i]+r[j])**2\n                idx += 1\n        return cons\n\n    def jac_constraints_sum(X):\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        num_cons = 4*N + N*(N-1)//2\n        jac = np.zeros((num_cons, 3*N))\n        idx = 0\n        for i in range(N):\n            jac[idx, 3*i] = 1.0; jac[idx, 3*i+2] = -1.0; idx += 1\n            jac[idx, 3*i] = -1.0; jac[idx, 3*i+2] = -1.0; idx += 1\n            jac[idx, 3*i+1] = 1.0; jac[idx, 3*i+2] = -1.0; idx += 1\n            jac[idx, 3*i+1] = -1.0; jac[idx, 3*i+2] = -1.0; idx += 1\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx, dy, rs = x[i] - x[j], y[i] - y[j], r[i] + r[j]\n                jac[idx, 3*i] = 2*dx; jac[idx, 3*j] = -2*dx\n                jac[idx, 3*i+1] = 2*dy; jac[idx, 3*j+1] = -2*dy\n                jac[idx, 3*i+2] = -2*rs; jac[idx, 3*j+2] = -2*rs\n                idx += 1\n        return jac\n\n    def ensure_valid(centers, radii, N):\n        for _ in range(50):\n            for i in range(N):\n                radii[i] = min(radii[i], centers[i, 0], 1.0 - centers[i, 0],\n                               centers[i, 1], 1.0 - centers[i, 1])\n            for i in range(N):\n                for j in range(i + 1, N):\n                    d = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    if d < radii[i] + radii[j]:\n                        overlap = (radii[i] + radii[j]) - d\n                        radii[i] -= overlap / 2.0 + 1e-15\n                        radii[j] -= overlap / 2.0 + 1e-15\n            radii = np.maximum(radii, 0)\n        return radii\n\n    start_time = time.time()\n    attempt = 0\n    while time.time() - start_time < 260:\n        x, y = get_initial_positions(N, attempt)\n        x, y = force_directed(x, y, N)\n        r_start = get_initial_r(x, y, N)\n        \n        # Stage 1: Equal Radius Optimization\n        X0 = np.zeros(2*N + 1)\n        X0[:2*N:2], X0[1:2*N:2], X0[2*N] = x, y, r_start * 0.99\n        res1 = minimize(objective_r, X0, method='SLSQP', jac=jac_objective_r,\n                        constraints={'type': 'ineq', 'fun': constraints_r, 'jac': jac_constraints_r},\n                        options={'maxiter': 400, 'ftol': 1e-10})\n        \n        # Stage 2: Variable Radius Optimization\n        X1 = np.zeros(3*N)\n        for i in range(N):\n            X1[3*i], X1[3*i+1], X1[3*i+2] = res1.x[2*i], res1.x[2*i+1], res1.x[2*N]\n        res2 = minimize(objective_sum, X1, method='SLSQP', jac=jac_objective_sum,\n                        constraints={'type': 'ineq', 'fun': constraints_sum, 'jac': jac_constraints_sum},\n                        options={'maxiter': 400, 'ftol': 1e-12})\n        \n        # Process and store the best result\n        final_X = res2.x\n        centers = final_X.reshape(N, 3)[:, :2]\n        radii = final_X[2::3]\n        radii = ensure_valid(centers, radii, N)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, centers, radii\n        attempt += 1\n\n    return best_centers, best_radii, best_sum",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\nimport time\n\ndef run_packing():\n    N = 26\n    start_time = time.time()\n\n    def objective(X):\n        # We want to maximize the sum of radii, so minimize the negative sum.\n        return -np.sum(X[2::3])\n\n    def jac_objective(X):\n        j = np.zeros(3 * N)\n        j[2::3] = -1.0\n        return j\n\n    def constraints(X):\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        # Number of constraints: 4*N (boundary) + N*(N-1)//2 (overlap)\n        cons = np.zeros(4 * N + N * (N - 1) // 2)\n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        cons[0:N] = x - r\n        cons[N:2*N] = 1 - x - r\n        cons[2*N:3*N] = y - r\n        cons[3*N:4*N] = 1 - y - r\n        \n        idx = 4 * N\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            rr = r[i] + r[i+1:]\n            # Overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n            cons[idx:idx+N-1-i] = dx**2 + dy**2 - rr**2\n            idx += N - 1 - i\n        return cons\n\n    def jac_constraints(X):\n        x, y, r = X[0::3], X[1::3], X[2::3]\n        num_cons = 4 * N + N * (N - 1) // 2\n        jac = np.zeros((num_cons, 3 * N))\n        \n        # Boundary\n        idx_N = np.arange(N)\n        jac[idx_N, 3*idx_N] = 1; jac[idx_N, 3*idx_N+2] = -1\n        jac[idx_N+N, 3*idx_N] = -1; jac[idx_N+N, 3*idx_N+2] = -1\n        jac[idx_N+2*N, 3*idx_N+1] = 1; jac[idx_N+2*N, 3*idx_N+2] = -1\n        jac[idx_N+3*N, 3*idx_N+1] = -1; jac[idx_N+3*N, 3*idx_N+2] = -1\n        \n        # Overlap\n        idx = 4 * N\n        for i in range(N):\n            num_j = N - 1 - i\n            target_idx = np.arange(idx, idx + num_j)\n            j_indices = np.arange(i + 1, N)\n            dx, dy, rr = x[i] - x[j_indices], y[i] - y[j_indices], r[i] + r[j_indices]\n            \n            jac[target_idx, 3*i] = 2 * dx\n            jac[target_idx, 3*i+1] = 2 * dy\n            jac[target_idx, 3*i+2] = -2 * rr\n            \n            jac[target_idx, 3*j_indices] = -2 * dx\n            jac[target_idx, 3*j_indices+1] = -2 * dy\n            jac[target_idx, 3*j_indices+2] = -2 * rr\n            idx += num_j\n        return jac\n\n    def force_directed(N):\n        x, y = np.random.rand(N), np.random.rand(N)\n        r = 0.05\n        for _ in range(400):\n            fx, fy = np.zeros(N), np.zeros(N)\n            for i in range(N):\n                dx, dy = x[i] - x[i+1:], y[i] - y[i+1:]\n                d = np.hypot(dx, dy) + 1e-9\n                mask = d < 2 * r\n                f = (2 * r - d[mask]) / d[mask]\n                fx[i] += np.sum(dx[mask] * f)\n                fy[i] += np.sum(dy[mask] * f)\n                fx[i+1:][mask] -= dx[mask] * f\n                fy[i+1:][mask] -= dy[mask] * f\n            x += fx * 0.02\n            y += fy * 0.02\n            x, y = np.clip(x, r, 1-r), np.clip(y, r, 1-r)\n            r += 0.0001\n        return x, y, r\n\n    # Initial Grid-based Guess\n    x_grid, y_grid = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    X0_grid = np.zeros(3 * N)\n    X0_grid[0:3*25:3], X0_grid[1:3*25:3], X0_grid[2:3*25:3] = x_grid.flatten(), y_grid.flatten(), 0.09\n    X0_grid[75], X0_grid[76], X0_grid[77] = 0.5, 0.5, 0.01\n    \n    best_X = X0_grid\n    best_sum = -objective(X0_grid)\n\n    # Initial SLSQP on grid\n    try:\n        res = minimize(objective, X0_grid, method='SLSQP', jac=jac_objective,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=[(0, 1)] * (3 * N), options={'maxiter': 200, 'ftol': 1e-9})\n        if -res.fun > best_sum:\n            best_sum, best_X = -res.fun, res.x\n    except:\n        pass\n\n    # Multi-start loop\n    attempt = 0\n    while time.time() - start_time < 265:\n        try:\n            if attempt % 3 == 0:\n                x, y, r_val = force_directed(N)\n                X0 = np.zeros(3 * N)\n                X0[0::3], X0[1::3], X0[2::3] = x, y, r_val\n            else:\n                X0 = np.zeros(3 * N)\n                X0[0::3], X0[1::3], X0[2::3] = np.random.rand(N), np.random.rand(N), 0.08\n            \n            res = minimize(objective, X0, method='SLSQP', jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                           bounds=[(0, 1)] * (3 * N), options={'maxiter': 100, 'ftol': 1e-8})\n            \n            if -res.fun > best_sum:\n                best_sum, best_X = -res.fun, res.x\n                # Refine with basinhopping\n                res_bh = basinhopping(objective, res.x,\n                                      minimizer_kwargs={\n                                          'method': 'SLSQP', 'jac': jac_objective,\n                                          'constraints': {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                                          'bounds': [(0, 1)] * (3 * N), 'options': {'maxiter': 100, 'ftol': 1e-9}\n                                      }, niter=3, T=0.01, stepsize=0.02)\n                if -res_bh.fun > best_sum:\n                    best_sum, best_X = -res_bh.fun, res_bh.x\n        except:\n            pass\n        attempt += 1\n\n    # Final Refinement\n    res_final = minimize(objective, best_X, method='SLSQP', jac=jac_objective,\n                         constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                         bounds=[(0, 1)] * (3 * N), options={'maxiter': 500, 'ftol': 1e-12})\n    best_X = res_final.x\n    \n    centers = best_X.reshape(N, 3)[:, :2]\n    radii = best_X[2::3]\n    \n    # Strict validation and adjustment\n    for _ in range(20):\n        radii = np.maximum(radii, 0)\n        for i in range(N):\n            radii[i] = min(radii[i], centers[i,0], 1-centers[i,0], centers[i,1], 1-centers[i,1])\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                if radii[i] + radii[j] > d:\n                    diff = (radii[i] + radii[j] - d) + 1e-15\n                    sum_r = radii[i] + radii[j]\n                    if sum_r > 0:\n                        radii[i] -= diff * (radii[i] / sum_r)\n                        radii[j] -= diff * (radii[j] / sum_r)\n                    else:\n                        radii[i] = radii[j] = 0\n                        \n    return centers, radii, np.sum(radii)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:20:46.577445",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 3160,
        "candidates_token_count": 2471,
        "thoughts_token_count": 22030
      },
      "response_text_len": 6453
    }
  },
  "llm_call_duration_s": 139.5611517910147,
  "eval_duration_s": 273.09107057203073
}