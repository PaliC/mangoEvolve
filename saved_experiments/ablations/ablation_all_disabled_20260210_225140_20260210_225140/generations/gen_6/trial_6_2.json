{
  "trial_id": "trial_6_2",
  "generation": 6,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef objective(x, n):\n    \"\"\"Minimize the negative sum of radii to maximize the sum of radii.\"\"\"\n    return -np.sum(x[2*n:])\n\ndef objective_jac(x, n):\n    \"\"\"Jacobian of the objective function.\"\"\"\n    j = np.zeros(3*n)\n    j[2*n:] = -1.0\n    return j\n\ndef constraints_func(x, n, i_idx, j_idx):\n    \"\"\"Combined vector-valued constraint function for SLSQP.\"\"\"\n    xc, yc, r = x[:n], x[n:2*n], x[2*n:]\n    # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n    b1 = xc - r\n    b2 = 1.0 - xc - r\n    b3 = yc - r\n    b4 = 1.0 - yc - r\n    # Pairwise distance constraints: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n    dx = xc[i_idx] - xc[j_idx]\n    dy = yc[i_idx] - yc[j_idx]\n    rs = r[i_idx] + r[j_idx]\n    dist_sq = dx**2 + dy**2 - rs**2\n    return np.concatenate([b1, b2, b3, b4, dist_sq])\n\ndef constraints_jac(x, n, i_idx, j_idx):\n    \"\"\"Jacobian of the combined constraint function.\"\"\"\n    xc, yc, r = x[:n], x[n:2*n], x[2*n:]\n    num_pairwise = len(i_idx)\n    jac = np.zeros((4 * n + num_pairwise, 3 * n))\n    \n    # Pre-calculate boundary indices\n    idx_n = np.arange(n)\n    # x_i - r_i\n    jac[idx_n, idx_n] = 1\n    jac[idx_n, 2*n + idx_n] = -1\n    # 1 - x_i - r_i\n    jac[n + idx_n, idx_n] = -1\n    jac[n + idx_n, 2*n + idx_n] = -1\n    # y_i - r_i\n    jac[2*n + idx_n, n + idx_n] = 1\n    jac[2*n + idx_n, 2*n + idx_n] = -1\n    # 1 - y_i - r_i\n    jac[3*n + idx_n, n + idx_n] = -1\n    jac[3*n + idx_n, 2*n + idx_n] = -1\n        \n    # Vectorized pairwise constraints\n    row_indices = 4 * n + np.arange(num_pairwise)\n    dx = xc[i_idx] - xc[j_idx]\n    dy = yc[i_idx] - yc[j_idx]\n    rs = r[i_idx] + r[j_idx]\n    \n    jac[row_indices, i_idx] = 2 * dx\n    jac[row_indices, j_idx] = -2 * dx\n    jac[row_indices, n + i_idx] = 2 * dy\n    jac[row_indices, n + j_idx] = -2 * dy\n    jac[row_indices, 2 * n + i_idx] = -2 * rs\n    jac[row_indices, 2 * n + j_idx] = -2 * rs\n    \n    return jac\n\ndef is_feasible(x, n, i_idx, j_idx):\n    \"\"\"Check if the solution is feasible within a tolerance.\"\"\"\n    xc, yc, r = x[:n], x[n:2*n], x[2*n:]\n    if np.any(r < 0): return False\n    if np.any(xc - r < -1e-6): return False\n    if np.any(1 - xc - r < -1e-6): return False\n    if np.any(yc - r < -1e-6): return False\n    if np.any(1 - yc - r < -1e-6): return False\n    \n    dx = xc[i_idx] - xc[j_idx]\n    dy = yc[i_idx] - yc[j_idx]\n    rs = r[i_idx] + r[j_idx]\n    if np.any(dx**2 + dy**2 - rs**2 < -1e-6): return False\n    \n    return True\n\ndef lloyds(n):\n    \"\"\"Approximate Lloyd's algorithm for uniform point distribution.\"\"\"\n    pts = np.random.rand(n, 2)\n    for _ in range(20):\n        samples = np.random.rand(2000, 2)\n        dists = np.sum((samples[:, None, :] - pts[None, :, :])**2, axis=2)\n        nearest = np.argmin(dists, axis=1)\n        new_pts = np.zeros_like(pts)\n        for i in range(n):\n            mask = (nearest == i)\n            if np.any(mask):\n                new_pts[i] = np.mean(samples[mask], axis=0)\n            else:\n                new_pts[i] = np.random.rand(2)\n        pts = new_pts\n    return pts\n\ndef run_packing():\n    \"\"\"Main function to perform circle packing and maximize sum of radii.\"\"\"\n    n = 26\n    best_sum = 0\n    best_x = None\n    start_time = time.time()\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    \n    while time.time() - start_time < 280:\n        # Choose an initialization strategy\n        mode = np.random.choice(['lloyds', 'random', 'corners', 'grid'], p=[0.4, 0.2, 0.2, 0.2])\n        if mode == 'lloyds':\n            pts = lloyds(n)\n        elif mode == 'random':\n            pts = np.random.rand(n, 2)\n        elif mode == 'grid':\n            xs = np.linspace(0.1, 0.9, 5)\n            ys = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(xs, ys)\n            pts_grid = np.vstack([xv.flatten(), yv.flatten()]).T\n            pts = np.vstack([pts_grid, [0.5, 0.5]])\n        else: # corners strategy: one large circle, others near corners\n            pts = np.random.rand(n, 2)\n            pts[0] = [0.5, 0.5]\n            for i in range(1, n):\n                corner = np.random.randint(4)\n                if corner == 0: pts[i] = np.random.rand(2) * 0.4\n                elif corner == 1: pts[i] = [1 - np.random.rand()*0.4, np.random.rand()*0.4]\n                elif corner == 2: pts[i] = [np.random.rand()*0.4, 1 - np.random.rand()*0.4]\n                else: pts[i] = [1 - np.random.rand()*0.4, 1 - np.random.rand()*0.4]\n        \n        # Initial radii\n        r0 = np.ones(n) * (0.09 if mode == 'grid' else 0.05)\n        x0 = np.concatenate([pts[:, 0], pts[:, 1], r0])\n        \n        # Optimization using SLSQP\n        res = minimize(\n            objective, x0, args=(n,), method='SLSQP',\n            jac=objective_jac,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac, 'args': (n, i_idx, j_idx)},\n            bounds=[(0, 1)] * (2*n) + [(0, 0.5)] * n,\n            options={'maxiter': 200, 'ftol': 1e-8}\n        )\n        \n        # Update best solution if feasible and better\n        if is_feasible(res.x, n, i_idx, j_idx):\n            if -res.fun > best_sum:\n                best_sum = -res.fun\n                best_x = res.x\n    \n    # Fallback to a safe configuration if no best_x was found (unlikely)\n    if best_x is None:\n        xs = np.linspace(0.1, 0.9, 5)\n        ys = np.linspace(0.1, 0.9, 5)\n        xv, yv = np.meshgrid(xs, ys)\n        centers = np.vstack([xv.flatten(), yv.flatten()]).T\n        centers = np.vstack([centers, [0.5, 0.5]])\n        radii = np.ones(26) * 0.08\n        return centers, radii, 26 * 0.08\n                    \n    # Return formatted result\n    centers = np.vstack([best_x[:n], best_x[n:2*n]]).T\n    radii = best_x[2*n:]\n    return centers, radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.6342924020628793,
    "eval_time": 282.87992095947266,
    "error": null
  },
  "prompt": "\nTry a Voronoi-based approach to initialize the circle centers for 26 circles.\n1. Use Lloyd's algorithm or a similar Centroidal Voronoi Tessellation (CVT) to distribute 26 points uniformly in the unit square.\n2. Use the resulting centers as the starting point for a non-linear optimization (scipy.optimize.minimize).\n3. Maximize sum(radii) where radii are determined by the distance to the nearest neighbor or boundary.\n4. Use a 'max-min' strategy or SLSQP.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef objective(x, n):\n    \"\"\"Minimize the negative sum of radii to maximize the sum of radii.\"\"\"\n    return -np.sum(x[2*n:])\n\ndef objective_jac(x, n):\n    \"\"\"Jacobian of the objective function.\"\"\"\n    j = np.zeros(3*n)\n    j[2*n:] = -1.0\n    return j\n\ndef constraints_func(x, n, i_idx, j_idx):\n    \"\"\"Combined vector-valued constraint function for SLSQP.\"\"\"\n    xc, yc, r = x[:n], x[n:2*n], x[2*n:]\n    # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n    b1 = xc - r\n    b2 = 1.0 - xc - r\n    b3 = yc - r\n    b4 = 1.0 - yc - r\n    # Pairwise distance constraints: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n    dx = xc[i_idx] - xc[j_idx]\n    dy = yc[i_idx] - yc[j_idx]\n    rs = r[i_idx] + r[j_idx]\n    dist_sq = dx**2 + dy**2 - rs**2\n    return np.concatenate([b1, b2, b3, b4, dist_sq])\n\ndef constraints_jac(x, n, i_idx, j_idx):\n    \"\"\"Jacobian of the combined constraint function.\"\"\"\n    xc, yc, r = x[:n], x[n:2*n], x[2*n:]\n    num_pairwise = len(i_idx)\n    jac = np.zeros((4 * n + num_pairwise, 3 * n))\n    \n    # Pre-calculate boundary indices\n    idx_n = np.arange(n)\n    # x_i - r_i\n    jac[idx_n, idx_n] = 1\n    jac[idx_n, 2*n + idx_n] = -1\n    # 1 - x_i - r_i\n    jac[n + idx_n, idx_n] = -1\n    jac[n + idx_n, 2*n + idx_n] = -1\n    # y_i - r_i\n    jac[2*n + idx_n, n + idx_n] = 1\n    jac[2*n + idx_n, 2*n + idx_n] = -1\n    # 1 - y_i - r_i\n    jac[3*n + idx_n, n + idx_n] = -1\n    jac[3*n + idx_n, 2*n + idx_n] = -1\n        \n    # Vectorized pairwise constraints\n    row_indices = 4 * n + np.arange(num_pairwise)\n    dx = xc[i_idx] - xc[j_idx]\n    dy = yc[i_idx] - yc[j_idx]\n    rs = r[i_idx] + r[j_idx]\n    \n    jac[row_indices, i_idx] = 2 * dx\n    jac[row_indices, j_idx] = -2 * dx\n    jac[row_indices, n + i_idx] = 2 * dy\n    jac[row_indices, n + j_idx] = -2 * dy\n    jac[row_indices, 2 * n + i_idx] = -2 * rs\n    jac[row_indices, 2 * n + j_idx] = -2 * rs\n    \n    return jac\n\ndef is_feasible(x, n, i_idx, j_idx):\n    \"\"\"Check if the solution is feasible within a tolerance.\"\"\"\n    xc, yc, r = x[:n], x[n:2*n], x[2*n:]\n    if np.any(r < 0): return False\n    if np.any(xc - r < -1e-6): return False\n    if np.any(1 - xc - r < -1e-6): return False\n    if np.any(yc - r < -1e-6): return False\n    if np.any(1 - yc - r < -1e-6): return False\n    \n    dx = xc[i_idx] - xc[j_idx]\n    dy = yc[i_idx] - yc[j_idx]\n    rs = r[i_idx] + r[j_idx]\n    if np.any(dx**2 + dy**2 - rs**2 < -1e-6): return False\n    \n    return True\n\ndef lloyds(n):\n    \"\"\"Approximate Lloyd's algorithm for uniform point distribution.\"\"\"\n    pts = np.random.rand(n, 2)\n    for _ in range(20):\n        samples = np.random.rand(2000, 2)\n        dists = np.sum((samples[:, None, :] - pts[None, :, :])**2, axis=2)\n        nearest = np.argmin(dists, axis=1)\n        new_pts = np.zeros_like(pts)\n        for i in range(n):\n            mask = (nearest == i)\n            if np.any(mask):\n                new_pts[i] = np.mean(samples[mask], axis=0)\n            else:\n                new_pts[i] = np.random.rand(2)\n        pts = new_pts\n    return pts\n\ndef run_packing():\n    \"\"\"Main function to perform circle packing and maximize sum of radii.\"\"\"\n    n = 26\n    best_sum = 0\n    best_x = None\n    start_time = time.time()\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    \n    while time.time() - start_time < 280:\n        # Choose an initialization strategy\n        mode = np.random.choice(['lloyds', 'random', 'corners', 'grid'], p=[0.4, 0.2, 0.2, 0.2])\n        if mode == 'lloyds':\n            pts = lloyds(n)\n        elif mode == 'random':\n            pts = np.random.rand(n, 2)\n        elif mode == 'grid':\n            xs = np.linspace(0.1, 0.9, 5)\n            ys = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(xs, ys)\n            pts_grid = np.vstack([xv.flatten(), yv.flatten()]).T\n            pts = np.vstack([pts_grid, [0.5, 0.5]])\n        else: # corners strategy: one large circle, others near corners\n            pts = np.random.rand(n, 2)\n            pts[0] = [0.5, 0.5]\n            for i in range(1, n):\n                corner = np.random.randint(4)\n                if corner == 0: pts[i] = np.random.rand(2) * 0.4\n                elif corner == 1: pts[i] = [1 - np.random.rand()*0.4, np.random.rand()*0.4]\n                elif corner == 2: pts[i] = [np.random.rand()*0.4, 1 - np.random.rand()*0.4]\n                else: pts[i] = [1 - np.random.rand()*0.4, 1 - np.random.rand()*0.4]\n        \n        # Initial radii\n        r0 = np.ones(n) * (0.09 if mode == 'grid' else 0.05)\n        x0 = np.concatenate([pts[:, 0], pts[:, 1], r0])\n        \n        # Optimization using SLSQP\n        res = minimize(\n            objective, x0, args=(n,), method='SLSQP',\n            jac=objective_jac,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac, 'args': (n, i_idx, j_idx)},\n            bounds=[(0, 1)] * (2*n) + [(0, 0.5)] * n,\n            options={'maxiter': 200, 'ftol': 1e-8}\n        )\n        \n        # Update best solution if feasible and better\n        if is_feasible(res.x, n, i_idx, j_idx):\n            if -res.fun > best_sum:\n                best_sum = -res.fun\n                best_x = res.x\n    \n    # Fallback to a safe configuration if no best_x was found (unlikely)\n    if best_x is None:\n        xs = np.linspace(0.1, 0.9, 5)\n        ys = np.linspace(0.1, 0.9, 5)\n        xv, yv = np.meshgrid(xs, ys)\n        centers = np.vstack([xv.flatten(), yv.flatten()]).T\n        centers = np.vstack([centers, [0.5, 0.5]])\n        radii = np.ones(26) * 0.08\n        return centers, radii, 26 * 0.08\n                    \n    # Return formatted result\n    centers = np.vstack([best_x[:n], best_x[n:2*n]]).T\n    radii = best_x[2*n:]\n    return centers, radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:43:22.203530",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 348,
        "candidates_token_count": 2303,
        "thoughts_token_count": 23624
      },
      "response_text_len": 5797
    }
  },
  "llm_call_duration_s": 153.66221635905094,
  "eval_duration_s": 282.87993085500784
}