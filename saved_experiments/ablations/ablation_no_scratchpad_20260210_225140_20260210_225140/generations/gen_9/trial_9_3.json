{
  "trial_id": "trial_9_3",
  "generation": 9,
  "parent_id": "trial_6_1",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of a grid-based initial guess, a push-out heuristic, and\n    Successive Linear Programming (SLP) for refinement.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Initial Guess: Start with a 5x5 grid and add one extra circle in the middle.\n    # This structure is often near-optimal for n=26 equal circle packing.\n    r_init = 0.09\n    coords = np.linspace(r_init, 1 - r_init, 5)\n    X, Y = np.meshgrid(coords, coords)\n    x = X.flatten()\n    y = Y.flatten()\n    # Add the 26th circle at the center\n    x = np.append(x, 0.5)\n    y = np.append(y, 0.5)\n    # Add a small amount of noise to break symmetry and avoid zero distances\n    x += np.random.normal(0, 0.005, n)\n    y += np.random.normal(0, 0.005, n)\n    \n    # 2. Push-out Heuristic: Quickly separate overlapping circles and push them into the box.\n    r_val = r_init\n    for _ in range(400):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = x[i] - x[j], y[i] - y[j]\n                d = np.sqrt(dx**2 + dy**2) + 1e-12\n                if d < 2 * r_val:\n                    push = (2 * r_val - d) / 2\n                    x[i] += (dx / d) * push\n                    y[i] += (dy / d) * push\n                    x[j] -= (dx / d) * push\n                    y[j] -= (dy / d) * push\n        # Keep circles inside the unit square [r, 1-r]\n        x = np.clip(x, r_val, 1 - r_val)\n        y = np.clip(y, r_val, 1 - r_val)\n        # Gradually increase radius during push-out\n        r_val += 0.00002\n            \n    centers = np.stack([x, y], axis=1)\n    radii = np.ones(n) * r_val\n    \n    # 3. Successive Linear Programming (SLP) Refinement:\n    # Linearizes the non-overlap and boundary constraints and solves the resulting LP iteratively.\n    step_limit = 0.03\n    for _ in range(200):\n        # Objective: Maximize sum(r_i + dr_i) => Minimize sum(-dr_i)\n        # Variables: [dx1...dxn, dy1...dyn, dr1...drn] (Total 3n = 78 variables)\n        c = np.zeros(3 * n)\n        c[2*n:] = -1\n        \n        A_ub = []\n        b_ub = []\n        \n        # Boundary constraints: r_i + dr_i <= x_i + dx_i <= 1 - (r_i + dr_i)\n        for i in range(n):\n            # x_i + dx_i >= r_i + dr_i  => -dx_i + dr_i <= x_i - r_i\n            row_x1 = np.zeros(3*n); row_x1[i] = -1; row_x1[2*n+i] = 1; A_ub.append(row_x1); b_ub.append(centers[i, 0] - radii[i])\n            # x_i + dx_i <= 1 - (r_i + dr_i) => dx_i + dr_i <= 1 - x_i - r_i\n            row_x2 = np.zeros(3*n); row_x2[i] = 1; row_x2[2*n+i] = 1; A_ub.append(row_x2); b_ub.append(1 - centers[i, 0] - radii[i])\n            # y_i + dy_i >= r_i + dr_i  => -dy_i + dr_i <= y_i - r_i\n            row_y1 = np.zeros(3*n); row_y1[n+i] = -1; row_y1[2*n+i] = 1; A_ub.append(row_y1); b_ub.append(centers[i, 1] - radii[i])\n            # y_i + dy_i <= 1 - (r_i + dr_i) => dy_i + dr_i <= 1 - y_i - r_i\n            row_y2 = np.zeros(3*n); row_y2[n+i] = 1; row_y2[2*n+i] = 1; A_ub.append(row_y2); b_ub.append(1 - centers[i, 1] - radii[i])\n        \n        # Non-overlap constraints linearized: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i, 0] - centers[j, 0], centers[i, 1] - centers[j, 1]\n                d_ij = np.sqrt(dx**2 + dy**2) + 1e-12\n                # Only include constraints for circles that are relatively close to save computation\n                if d_ij < 0.4:\n                    # Linearized form: (xi-xj)/d_ij * (dxi-dxj) + (yi-yj)/d_ij * (dyi-dyj) >= dri + drj + (ri + rj - d_ij)\n                    # Re-arranged for Ax <= b:\n                    row = np.zeros(3*n)\n                    row[i], row[j] = -dx/d_ij, dx/d_ij\n                    row[n+i], row[n+j] = -dy/d_ij, dy/d_ij\n                    row[2*n+i], row[2*n+j] = 1, 1\n                    A_ub.append(row)\n                    b_ub.append(d_ij - radii[i] - radii[j])\n        \n        # Define bounds for step size and ensure radii remain non-negative\n        lp_bounds = [(-step_limit, step_limit)] * (2 * n) + \\\n                    [(max(-step_limit, -r), step_limit) for r in radii]\n        \n        # Solve the LP using the 'highs' method for efficiency\n        res = linprog(c, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=lp_bounds, method='highs')\n        \n        if not res.success:\n            break\n            \n        # Update variables\n        centers[:, 0] += res.x[:n]\n        centers[:, 1] += res.x[n:2*n]\n        radii += res.x[2*n:]\n        \n        # Reduce step limit for convergence\n        step_limit *= 0.96\n        if step_limit < 1e-8:\n            break\n            \n    # 4. Strictly enforce constraints: Ensure no overlaps or boundary violations due to linearization errors.\n    # Adjust radii slightly to be safe.\n    for i in range(n):\n        radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.sqrt(np.sum((centers[i] - centers[j])**2))\n            if radii[i] + radii[j] > d:\n                # Shrink both radii proportionally to eliminate overlap\n                overlap = (radii[i] + radii[j]) - d\n                total_r = radii[i] + radii[j]\n                if total_r > 0:\n                    radii[i] -= overlap * (radii[i] / total_r)\n                    radii[j] -= overlap * (radii[j] / total_r)\n                else:\n                    radii[i] = radii[j] = d / 2\n\n    # Ensure all radii are non-negative\n    radii = np.maximum(radii, 0.0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6259671195244985,
    "eval_time": 3.1679539680480957,
    "error": null
  },
  "prompt": "\nImplement a Successive Linear Programming (SLP) or Sequential Quadratic Programming approach to refine the packing.\nGiven the current centers and radii from Trial trial_6_1, linearize the non-overlap constraints:\ndist(ci, cj) >= ri + rj  =>  (ci-cj)\u00b7(\u0394ci-\u0394cj)/dist(ci, cj) >= \u0394ri + \u0394rj + (ri+rj - dist(ci, cj))\nSolve the resulting LP to find updates \u0394c and \u0394r, then update and repeat. This is often more robust for packing than general-purpose NLP solvers.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of a grid-based initial guess, a push-out heuristic, and\n    Successive Linear Programming (SLP) for refinement.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Initial Guess: Start with a 5x5 grid and add one extra circle in the middle.\n    # This structure is often near-optimal for n=26 equal circle packing.\n    r_init = 0.09\n    coords = np.linspace(r_init, 1 - r_init, 5)\n    X, Y = np.meshgrid(coords, coords)\n    x = X.flatten()\n    y = Y.flatten()\n    # Add the 26th circle at the center\n    x = np.append(x, 0.5)\n    y = np.append(y, 0.5)\n    # Add a small amount of noise to break symmetry and avoid zero distances\n    x += np.random.normal(0, 0.005, n)\n    y += np.random.normal(0, 0.005, n)\n    \n    # 2. Push-out Heuristic: Quickly separate overlapping circles and push them into the box.\n    r_val = r_init\n    for _ in range(400):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = x[i] - x[j], y[i] - y[j]\n                d = np.sqrt(dx**2 + dy**2) + 1e-12\n                if d < 2 * r_val:\n                    push = (2 * r_val - d) / 2\n                    x[i] += (dx / d) * push\n                    y[i] += (dy / d) * push\n                    x[j] -= (dx / d) * push\n                    y[j] -= (dy / d) * push\n        # Keep circles inside the unit square [r, 1-r]\n        x = np.clip(x, r_val, 1 - r_val)\n        y = np.clip(y, r_val, 1 - r_val)\n        # Gradually increase radius during push-out\n        r_val += 0.00002\n            \n    centers = np.stack([x, y], axis=1)\n    radii = np.ones(n) * r_val\n    \n    # 3. Successive Linear Programming (SLP) Refinement:\n    # Linearizes the non-overlap and boundary constraints and solves the resulting LP iteratively.\n    step_limit = 0.03\n    for _ in range(200):\n        # Objective: Maximize sum(r_i + dr_i) => Minimize sum(-dr_i)\n        # Variables: [dx1...dxn, dy1...dyn, dr1...drn] (Total 3n = 78 variables)\n        c = np.zeros(3 * n)\n        c[2*n:] = -1\n        \n        A_ub = []\n        b_ub = []\n        \n        # Boundary constraints: r_i + dr_i <= x_i + dx_i <= 1 - (r_i + dr_i)\n        for i in range(n):\n            # x_i + dx_i >= r_i + dr_i  => -dx_i + dr_i <= x_i - r_i\n            row_x1 = np.zeros(3*n); row_x1[i] = -1; row_x1[2*n+i] = 1; A_ub.append(row_x1); b_ub.append(centers[i, 0] - radii[i])\n            # x_i + dx_i <= 1 - (r_i + dr_i) => dx_i + dr_i <= 1 - x_i - r_i\n            row_x2 = np.zeros(3*n); row_x2[i] = 1; row_x2[2*n+i] = 1; A_ub.append(row_x2); b_ub.append(1 - centers[i, 0] - radii[i])\n            # y_i + dy_i >= r_i + dr_i  => -dy_i + dr_i <= y_i - r_i\n            row_y1 = np.zeros(3*n); row_y1[n+i] = -1; row_y1[2*n+i] = 1; A_ub.append(row_y1); b_ub.append(centers[i, 1] - radii[i])\n            # y_i + dy_i <= 1 - (r_i + dr_i) => dy_i + dr_i <= 1 - y_i - r_i\n            row_y2 = np.zeros(3*n); row_y2[n+i] = 1; row_y2[2*n+i] = 1; A_ub.append(row_y2); b_ub.append(1 - centers[i, 1] - radii[i])\n        \n        # Non-overlap constraints linearized: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i, 0] - centers[j, 0], centers[i, 1] - centers[j, 1]\n                d_ij = np.sqrt(dx**2 + dy**2) + 1e-12\n                # Only include constraints for circles that are relatively close to save computation\n                if d_ij < 0.4:\n                    # Linearized form: (xi-xj)/d_ij * (dxi-dxj) + (yi-yj)/d_ij * (dyi-dyj) >= dri + drj + (ri + rj - d_ij)\n                    # Re-arranged for Ax <= b:\n                    row = np.zeros(3*n)\n                    row[i], row[j] = -dx/d_ij, dx/d_ij\n                    row[n+i], row[n+j] = -dy/d_ij, dy/d_ij\n                    row[2*n+i], row[2*n+j] = 1, 1\n                    A_ub.append(row)\n                    b_ub.append(d_ij - radii[i] - radii[j])\n        \n        # Define bounds for step size and ensure radii remain non-negative\n        lp_bounds = [(-step_limit, step_limit)] * (2 * n) + \\\n                    [(max(-step_limit, -r), step_limit) for r in radii]\n        \n        # Solve the LP using the 'highs' method for efficiency\n        res = linprog(c, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=lp_bounds, method='highs')\n        \n        if not res.success:\n            break\n            \n        # Update variables\n        centers[:, 0] += res.x[:n]\n        centers[:, 1] += res.x[n:2*n]\n        radii += res.x[2*n:]\n        \n        # Reduce step limit for convergence\n        step_limit *= 0.96\n        if step_limit < 1e-8:\n            break\n            \n    # 4. Strictly enforce constraints: Ensure no overlaps or boundary violations due to linearization errors.\n    # Adjust radii slightly to be safe.\n    for i in range(n):\n        radii[i] = min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.sqrt(np.sum((centers[i] - centers[j])**2))\n            if radii[i] + radii[j] > d:\n                # Shrink both radii proportionally to eliminate overlap\n                overlap = (radii[i] + radii[j]) - d\n                total_r = radii[i] + radii[j]\n                if total_r > 0:\n                    radii[i] -= overlap * (radii[i] / total_r)\n                    radii[j] -= overlap * (radii[j] / total_r)\n                else:\n                    radii[i] = radii[j] = d / 2\n\n    # Ensure all radii are non-negative\n    radii = np.maximum(radii, 0.0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:06:27.528765",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 361,
        "candidates_token_count": 2150,
        "thoughts_token_count": 21175
      },
      "response_text_len": 5766
    }
  },
  "llm_call_duration_s": 125.36465959798079,
  "eval_duration_s": 3.1679631690494716
}