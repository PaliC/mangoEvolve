{
  "trial_id": "trial_9_2",
  "generation": 9,
  "parent_id": "trial_6_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef refine_radii(centers, n):\n    \"\"\"Finds optimal radii for fixed centers using Linear Programming.\"\"\"\n    x, y = centers[:, 0], centers[:, 1]\n    c = -np.ones(n)\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = n * (n - 1) // 2\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), i_idx] = 1\n    A_ub[np.arange(num_overlap), j_idx] = 1\n    \n    dx = x[i_idx] - x[j_idx]\n    dy = y[i_idx] - y[j_idx]\n    b_ub = np.sqrt(dx**2 + dy**2)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    max_r_boundary = np.minimum.reduce([x, 1 - x, y, 1 - y, np.ones(n) * 0.5])\n    \n    # Tiny buffer to handle floating-point precision issues\n    b_ub -= 1e-11\n    max_r_boundary -= 1e-11\n    max_r_boundary = np.maximum(max_r_boundary, 0)\n    \n    # LP Refinement\n    try:\n        # Highs solver is efficient for this scale\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=[(0, b) for b in max_r_boundary], method='highs')\n        if res.success:\n            return res.x\n    except:\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=[(0, b) for b in max_r_boundary])\n            if res.success:\n                return res.x\n        except:\n            pass\n    return None\n\ndef take_step(v, n, step_size):\n    \"\"\"Perturbs centers and swaps positions of small and large circles to jump basins.\"\"\"\n    x, y, r = v[:n].copy(), v[n:2*n].copy(), v[2*n:].copy()\n    \n    # Add random movement to centers\n    x += np.random.normal(0, step_size, n)\n    y += np.random.normal(0, step_size, n)\n    \n    # Randomly swap positions of small and large circles\n    if np.random.rand() < 0.75:\n        num_swaps = np.random.randint(1, 4)\n        for _ in range(num_swaps):\n            idx = np.argsort(r)\n            # Choose one from the smallest 10 and one from the largest 10\n            i = np.random.choice(idx[:10])\n            j = np.random.choice(idx[-10:])\n            # Swap their center coordinates\n            x[i], x[j] = x[j], x[i]\n            y[i], y[j] = y[j], y[i]\n            # Radii are kept to adapt in the next optimization step\n            \n    # Keep centers within the unit square\n    x = np.clip(x, 0, 1)\n    y = np.clip(y, 0, 1)\n    \n    # Adjust radii slightly to ensure they stay within boundary constraints at new positions\n    r = np.minimum(r, np.minimum(x, 1-x))\n    r = np.minimum(r, np.minimum(y, 1-y))\n    \n    return np.concatenate([x, y, r])\n\ndef run_packing():\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for overlap constraints\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    \n    # Initialization: 5x5 grid + 1 random circle\n    x_grid, y_grid = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    x_init = np.concatenate([x_grid.flatten(), [np.random.rand()]])\n    y_init = np.concatenate([y_grid.flatten(), [np.random.rand()]])\n    # Add small noise to break symmetry\n    x_init += np.random.normal(0, 0.01, n)\n    y_init += np.random.normal(0, 0.01, n)\n    x_init, y_init = np.clip(x_init, 0, 1), np.clip(y_init, 0, 1)\n    \n    # Initial radii optimization\n    centers_init = np.column_stack((x_init, y_init))\n    r_init = refine_radii(centers_init, n)\n    if r_init is None:\n        r_init = np.ones(n) * 0.05\n        \n    v_current = np.concatenate([x_init, y_init, r_init])\n    best_v = v_current.copy()\n    best_sum = np.sum(r_init)\n    \n    # Constraint functions for SLSQP\n    def overlap_cons(v):\n        x_c, y_c, r_c = v[:n], v[n:2*n], v[2*n:]\n        dx = x_c[i_idx] - x_c[j_idx]\n        dy = y_c[i_idx] - y_c[j_idx]\n        return np.sqrt(dx**2 + dy**2 + 1e-12) - (r_c[i_idx] + r_c[j_idx])\n    \n    def boundary_cons(v):\n        x_c, y_c, r_c = v[:n], v[n:2*n], v[2*n:]\n        return np.concatenate([x_c - r_c, 1 - x_c - r_c, y_c - r_c, 1 - y_c - r_c])\n        \n    cons = [{'type': 'ineq', 'fun': overlap_cons},\n            {'type': 'ineq', 'fun': boundary_cons}]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    # Basin-Hopping Strategy\n    temperature = 0.005\n    step_size = 0.05\n    \n    while time.time() - start_time < 280:\n        # Local optimization using SLSQP\n        try:\n            res = minimize(objective, v_current, method='SLSQP', \n                           constraints=cons, bounds=bounds, \n                           options={'maxiter': 150})\n            v_new = res.x\n        except:\n            v_new = v_current.copy()\n            \n        # Refine radii for the newly found centers using LP\n        centers_new = np.column_stack((v_new[:n], v_new[n:2*n]))\n        refined_radii = refine_radii(centers_new, n)\n        \n        if refined_radii is not None:\n            v_new[2*n:] = refined_radii\n            new_sum = np.sum(v_new[2*n:])\n            \n            # Global best update\n            if new_sum > best_sum:\n                best_sum = new_sum\n                best_v = v_new.copy()\n            \n            # Metropolis-Hastings Acceptance Criterion\n            current_sum = np.sum(v_current[2*n:])\n            if new_sum > current_sum or np.exp((new_sum - current_sum) / temperature) > np.random.rand():\n                v_current = v_new\n            else:\n                # If rejected, start next step from the best known point to stay in good basins\n                v_current = best_v.copy()\n        \n        # Take a custom step to explore new configurations\n        v_current = take_step(v_current, n, step_size)\n        \n    # Final polishing of the best configuration found\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = refine_radii(final_centers, n)\n    if final_radii is not None:\n        best_v[2*n:] = final_radii\n    \n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:]\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum",
  "metrics": {
    "valid": true,
    "score": 2.6359830849618215,
    "eval_time": 280.4898045063019,
    "error": null
  },
  "prompt": "\nThe sum of radii objective (26 circles) is sensitive to the contact graph. \nImplement a Basin-Hopping strategy using SLSQP as the local minimizer.\nUse a custom 'take_step' that not only moves centers but also randomly swaps the positions of a small circle and a large circle to potentially jump to a better contact graph.\nObjective: Maximize sum(radii).\nConstraints: r_i + r_j <= dist(c_i, c_j) and r_i <= x_i, y_i <= 1-r_i.\n\nStarting point: Trial trial_6_1\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Strategy:\n    1. Multi-start approach using grid-based, hexagonal-like, and random initializations.\n    2. Non-linear optimization (L-BFGS-B) with a penalty method and a continuation \n       schedule for the penalty parameter to find promising layout basins.\n    3. Linear Programming (LP) refinement to find the exact optimal radii for given centers.\n    4. Final polishing of the best-found configuration using SLSQP to optimize centers \n       and radii simultaneously.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Global best tracking\n    best_sum = 0\n    best_centers = np.random.rand(n, 2) * 0.8 + 0.1\n    best_radii = np.zeros(n)\n\n    # Pre-calculate Linear Programming constraint matrix for radii\n    num_pairs = n * (n - 1) // 2\n    A_ub = np.zeros((num_pairs, n))\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1\n            A_ub[idx, j] = 1\n            idx += 1\n    c_lp = -np.ones(n)\n\n    def get_radii_lp(centers):\n        \"\"\"Finds optimal radii for fixed centers using LP.\"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        b_ub = np.zeros(num_pairs)\n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                b_ub[idx] = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                idx += 1\n        # Radii limited by distance to the nearest wall\n        max_r_bound = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        lp_bounds = [(0, max(0.0, b)) for b in max_r_bound]\n        \n        try:\n            # Highs solver is significantly faster if available\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if res.success:\n            return res.x, -res.fun\n        return None, 0\n\n    def penalty_obj(vars, n, lam):\n        \"\"\"Penalty objective function for L-BFGS-B.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        obj = -np.sum(r)\n        # Boundary violations\n        b_cons = np.concatenate([r - x, x + r - 1, r - y, y + r - 1])\n        p_bound = np.sum(np.maximum(0, b_cons)**2)\n        # Overlap violations\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        p_overlap = np.sum(np.triu(np.maximum(0, r_sum - dist)**2, k=1))\n        return obj + lam * (p_bound + p_overlap)\n\n    def penalty_grad(vars, n, lam):\n        \"\"\"Gradient of the penalty objective function.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        dx_v, dy_v, dr_v = np.zeros(n), np.zeros(n), -np.ones(n)\n        \n        # Boundary gradients\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dr_v += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        dx_v += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_v += 2 * lam * (-b3 * m3 + b4 * m4)\n        \n        # Overlap gradients\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        violation = r_sum - dist\n        mask = (violation > 0)\n        np.fill_diagonal(mask, False)\n        mask = np.triu(mask)\n        \n        common = 2 * lam * violation * mask\n        dr_v += np.sum(common, axis=1) + np.sum(common, axis=0)\n        dist_inv = common / dist\n        dx_diff = dx * dist_inv\n        dy_diff = dy * dist_inv\n        dx_v -= np.sum(dx_diff, axis=1)\n        dx_v += np.sum(dx_diff, axis=0)\n        dy_v -= np.sum(dy_diff, axis=1)\n        dy_v += np.sum(dy_diff, axis=0)\n        \n        return np.concatenate([dx_v, dy_v, dr_v])\n\n    # Main exploration loop\n    trial = 0\n    while time.time() - start_time < 270:\n        # Diverse initialization strategies\n        if trial == 0:\n            # 5x5 grid + 1 central circle\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init, y_init = np.concatenate([xg.flatten(), [0.5]]), np.concatenate([yg.flatten(), [0.5]])\n            r_init = np.concatenate([np.ones(25)*0.1, [0.01]])\n        elif trial == 1:\n            # Shifted row (hexagonal-like) layout\n            row_counts = [5, 5, 6, 5, 5]\n            x_init, y_init = [], []\n            y_coords = np.linspace(0.1, 0.9, 5)\n            for i, count in enumerate(row_counts):\n                xs = np.linspace(0.1, 0.9, count)\n                for x in xs:\n                    x_init.append(x)\n                    y_init.append(y_coords[i])\n            x_init, y_init, r_init = np.array(x_init), np.array(y_init), np.ones(n)*0.09\n        elif trial == 2:\n            # 6x4 grid + 2 side circles\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n            x_init, y_init = np.concatenate([xg.flatten(), [0.1, 0.9]]), np.concatenate([yg.flatten(), [0.1, 0.9]])\n            r_init = np.ones(n)*0.09\n        else:\n            # Random starts\n            x_init, y_init = np.random.uniform(0.1, 0.9, n), np.random.uniform(0.1, 0.9, n)\n            r_init = np.ones(n)*0.09\n        \n        # Continuation method: solve with increasing penalty\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n        for lam in [20, 200, 2000]:\n            res = minimize(penalty_obj, vars_curr, args=(n, lam), jac=penalty_grad, \n                           method='L-BFGS-B', bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, \n                           options={'maxiter': 400, 'ftol': 1e-8})\n            vars_curr = res.x\n        \n        # Refine centers found by penalty method using LP\n        centers = np.stack([vars_curr[:n], vars_curr[n:2*n]], axis=1)\n        radii, current_sum = get_radii_lp(centers)\n        \n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, centers, radii\n        trial += 1\n\n    # Final polish using SLSQP on the best configuration found\n    def slsqp_obj(vars): return -np.sum(vars[2*n:])\n    \n    def slsqp_con(vars):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        o_cons = (dist - (r[:, None] + r[None, :]))[np.triu_indices(n, k=1)]\n        return np.concatenate([b_cons, o_cons])\n\n    try:\n        init_vars = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n        res_slsqp = minimize(slsqp_obj, init_vars, method='SLSQP', \n                             constraints={'type': 'ineq', 'fun': slsqp_con}, \n                             bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, \n                             options={'maxiter': 200})\n        if res_slsqp.success and -res_slsqp.fun > best_sum:\n            best_sum = -res_slsqp.fun\n            best_centers = np.stack([res_slsqp.x[:n], res_slsqp.x[n:2*n]], axis=1)\n            best_radii = res_slsqp.x[2*n:]\n    except:\n        pass\n\n    return best_centers, best_radii, best_sum\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef refine_radii(centers, n):\n    \"\"\"Finds optimal radii for fixed centers using Linear Programming.\"\"\"\n    x, y = centers[:, 0], centers[:, 1]\n    c = -np.ones(n)\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = n * (n - 1) // 2\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), i_idx] = 1\n    A_ub[np.arange(num_overlap), j_idx] = 1\n    \n    dx = x[i_idx] - x[j_idx]\n    dy = y[i_idx] - y[j_idx]\n    b_ub = np.sqrt(dx**2 + dy**2)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    max_r_boundary = np.minimum.reduce([x, 1 - x, y, 1 - y, np.ones(n) * 0.5])\n    \n    # Tiny buffer to handle floating-point precision issues\n    b_ub -= 1e-11\n    max_r_boundary -= 1e-11\n    max_r_boundary = np.maximum(max_r_boundary, 0)\n    \n    # LP Refinement\n    try:\n        # Highs solver is efficient for this scale\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=[(0, b) for b in max_r_boundary], method='highs')\n        if res.success:\n            return res.x\n    except:\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=[(0, b) for b in max_r_boundary])\n            if res.success:\n                return res.x\n        except:\n            pass\n    return None\n\ndef take_step(v, n, step_size):\n    \"\"\"Perturbs centers and swaps positions of small and large circles to jump basins.\"\"\"\n    x, y, r = v[:n].copy(), v[n:2*n].copy(), v[2*n:].copy()\n    \n    # Add random movement to centers\n    x += np.random.normal(0, step_size, n)\n    y += np.random.normal(0, step_size, n)\n    \n    # Randomly swap positions of small and large circles\n    if np.random.rand() < 0.75:\n        num_swaps = np.random.randint(1, 4)\n        for _ in range(num_swaps):\n            idx = np.argsort(r)\n            # Choose one from the smallest 10 and one from the largest 10\n            i = np.random.choice(idx[:10])\n            j = np.random.choice(idx[-10:])\n            # Swap their center coordinates\n            x[i], x[j] = x[j], x[i]\n            y[i], y[j] = y[j], y[i]\n            # Radii are kept to adapt in the next optimization step\n            \n    # Keep centers within the unit square\n    x = np.clip(x, 0, 1)\n    y = np.clip(y, 0, 1)\n    \n    # Adjust radii slightly to ensure they stay within boundary constraints at new positions\n    r = np.minimum(r, np.minimum(x, 1-x))\n    r = np.minimum(r, np.minimum(y, 1-y))\n    \n    return np.concatenate([x, y, r])\n\ndef run_packing():\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for overlap constraints\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    \n    # Initialization: 5x5 grid + 1 random circle\n    x_grid, y_grid = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    x_init = np.concatenate([x_grid.flatten(), [np.random.rand()]])\n    y_init = np.concatenate([y_grid.flatten(), [np.random.rand()]])\n    # Add small noise to break symmetry\n    x_init += np.random.normal(0, 0.01, n)\n    y_init += np.random.normal(0, 0.01, n)\n    x_init, y_init = np.clip(x_init, 0, 1), np.clip(y_init, 0, 1)\n    \n    # Initial radii optimization\n    centers_init = np.column_stack((x_init, y_init))\n    r_init = refine_radii(centers_init, n)\n    if r_init is None:\n        r_init = np.ones(n) * 0.05\n        \n    v_current = np.concatenate([x_init, y_init, r_init])\n    best_v = v_current.copy()\n    best_sum = np.sum(r_init)\n    \n    # Constraint functions for SLSQP\n    def overlap_cons(v):\n        x_c, y_c, r_c = v[:n], v[n:2*n], v[2*n:]\n        dx = x_c[i_idx] - x_c[j_idx]\n        dy = y_c[i_idx] - y_c[j_idx]\n        return np.sqrt(dx**2 + dy**2 + 1e-12) - (r_c[i_idx] + r_c[j_idx])\n    \n    def boundary_cons(v):\n        x_c, y_c, r_c = v[:n], v[n:2*n], v[2*n:]\n        return np.concatenate([x_c - r_c, 1 - x_c - r_c, y_c - r_c, 1 - y_c - r_c])\n        \n    cons = [{'type': 'ineq', 'fun': overlap_cons},\n            {'type': 'ineq', 'fun': boundary_cons}]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    # Basin-Hopping Strategy\n    temperature = 0.005\n    step_size = 0.05\n    \n    while time.time() - start_time < 280:\n        # Local optimization using SLSQP\n        try:\n            res = minimize(objective, v_current, method='SLSQP', \n                           constraints=cons, bounds=bounds, \n                           options={'maxiter': 150})\n            v_new = res.x\n        except:\n            v_new = v_current.copy()\n            \n        # Refine radii for the newly found centers using LP\n        centers_new = np.column_stack((v_new[:n], v_new[n:2*n]))\n        refined_radii = refine_radii(centers_new, n)\n        \n        if refined_radii is not None:\n            v_new[2*n:] = refined_radii\n            new_sum = np.sum(v_new[2*n:])\n            \n            # Global best update\n            if new_sum > best_sum:\n                best_sum = new_sum\n                best_v = v_new.copy()\n            \n            # Metropolis-Hastings Acceptance Criterion\n            current_sum = np.sum(v_current[2*n:])\n            if new_sum > current_sum or np.exp((new_sum - current_sum) / temperature) > np.random.rand():\n                v_current = v_new\n            else:\n                # If rejected, start next step from the best known point to stay in good basins\n                v_current = best_v.copy()\n        \n        # Take a custom step to explore new configurations\n        v_current = take_step(v_current, n, step_size)\n        \n    # Final polishing of the best configuration found\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = refine_radii(final_centers, n)\n    if final_radii is not None:\n        best_v[2*n:] = final_radii\n    \n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:]\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:10:57.543435",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 3038,
        "candidates_token_count": 2201,
        "thoughts_token_count": 19362
      },
      "response_text_len": 6015
    }
  },
  "llm_call_duration_s": 118.1207029200159,
  "eval_duration_s": 280.48981091799214
}