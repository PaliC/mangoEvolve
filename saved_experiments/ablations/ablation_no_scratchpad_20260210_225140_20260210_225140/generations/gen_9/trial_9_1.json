{
  "trial_id": "trial_9_1",
  "generation": 9,
  "parent_id": "trial_6_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Strategy:\n    1. Initial exploration using a penalty method with L-BFGS-B and Linear Programming (LP).\n    2. 'Shake and Squeeze' algorithm:\n       - Apply small random perturbations to circle centers.\n       - Use SLSQP to optimize centers and radii simultaneously.\n       - Reposition circles with very small radii into the largest available gaps.\n    3. Final polish using SLSQP on the best-found configuration.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    TRIU_IDX = np.triu_indices(N, k=1)\n    \n    # Pre-calculate Linear Programming components\n    num_pairs = N * (N - 1) // 2\n    A_ub_lp = np.zeros((num_pairs, N))\n    idx = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            A_ub_lp[idx, i] = 1\n            A_ub_lp[idx, j] = 1\n            idx += 1\n    c_lp = -np.ones(N)\n\n    def get_radii_lp(centers):\n        \"\"\"Optimizes radii for fixed centers using LP.\"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        b_ub = np.zeros(num_pairs)\n        idx = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                b_ub[idx] = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                idx += 1\n        max_r_bound = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        lp_bounds = [(0, max(0.0, b)) for b in max_r_bound]\n        \n        try:\n            res = linprog(c_lp, A_ub=A_ub_lp, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            res = linprog(c_lp, A_ub=A_ub_lp, b_ub=b_ub, bounds=lp_bounds)\n            \n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(N), 0\n\n    def penalty_obj(vars, lam):\n        x, y, r = vars[:N], vars[N:2*N], vars[2*N:]\n        obj = -np.sum(r)\n        b_cons = np.concatenate([r - x, x + r - 1, r - y, y + r - 1])\n        p_bound = np.sum(np.maximum(0, b_cons)**2)\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        p_overlap = np.sum(np.triu(np.maximum(0, r_sum - dist)**2, k=1))\n        return obj + lam * (p_bound + p_overlap)\n\n    def penalty_grad(vars, lam):\n        x, y, r = vars[:N], vars[N:2*N], vars[2*N:]\n        dx_v, dy_v, dr_v = np.zeros(N), np.zeros(N), -np.ones(N)\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dr_v += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        dx_v += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_v += 2 * lam * (-b3 * m3 + b4 * m4)\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        violation = r_sum - dist\n        mask = np.triu(violation > 0, k=1)\n        common = 2 * lam * violation * mask\n        dr_v += np.sum(common, axis=1) + np.sum(common, axis=0)\n        dist_inv = common / dist\n        dx_diff = dx * dist_inv\n        dy_diff = dy * dist_inv\n        dx_v -= np.sum(dx_diff, axis=1); dx_v += np.sum(dx_diff, axis=0)\n        dy_v -= np.sum(dy_diff, axis=1); dy_v += np.sum(dy_diff, axis=0)\n        return np.concatenate([dx_v, dy_v, dr_v])\n\n    def slsqp_obj(vars): return -np.sum(vars[2*N:])\n    def slsqp_obj_jac(vars):\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def slsqp_con(vars):\n        x, y, r = vars[:N], vars[N:2*N], vars[2*N:]\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        dx = x[TRIU_IDX[0]] - x[TRIU_IDX[1]]\n        dy = y[TRIU_IDX[0]] - y[TRIU_IDX[1]]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        o_cons = dist - (r[TRIU_IDX[0]] + r[TRIU_IDX[1]])\n        return np.concatenate([b_cons, o_cons])\n\n    def slsqp_con_jac(vars):\n        x, y, r = vars[:N], vars[N:2*N], vars[2*N:]\n        J = np.zeros((4*N + num_pairs, 3*N))\n        for i in range(N):\n            J[i, i] = 1; J[i, 2*N+i] = -1\n            J[N+i, i] = -1; J[N+i, 2*N+i] = -1\n            J[2*N+i, N+i] = 1; J[2*N+i, 2*N+i] = -1\n            J[3*N+i, N+i] = -1; J[3*N+i, 2*N+i] = -1\n        dx = x[TRIU_IDX[0]] - x[TRIU_IDX[1]]\n        dy = y[TRIU_IDX[0]] - y[TRIU_IDX[1]]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        for idx, (i, j) in enumerate(zip(TRIU_IDX[0], TRIU_IDX[1])):\n            row = 4*N + idx\n            J[row, i] = dx[idx] / dist[idx]\n            J[row, j] = -dx[idx] / dist[idx]\n            J[row, N+i] = dy[idx] / dist[idx]\n            J[row, N+j] = -dy[idx] / dist[idx]\n            J[row, 2*N+i] = -1\n            J[row, 2*N+j] = -1\n        return J\n\n    def find_gap(other_centers, other_radii):\n        best_p, max_d = np.random.rand(2), -1\n        for _ in range(500):\n            p = np.random.rand(2)\n            d_wall = min(p[0], 1-p[0], p[1], 1-p[1])\n            d_circle = np.min(np.sqrt(np.sum((other_centers - p)**2, axis=1)) - other_radii)\n            d = min(d_wall, d_circle)\n            if d > max_d:\n                max_d, best_p = d, p\n        return best_p\n\n    # 1. Initialization\n    best_sum = 0\n    best_centers = np.random.rand(N, 2)\n    best_radii = np.zeros(N)\n    \n    # Try different layouts\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    inits = [np.vstack([xg.flatten(), yg.flatten()]).T]\n    inits[0] = np.vstack([inits[0], [0.5, 0.5]])\n    \n    for x_init_c in inits:\n        vars_curr = np.concatenate([x_init_c[:, 0], x_init_c[:, 1], np.ones(N)*0.09])\n        for lam in [50, 500]:\n            res = minimize(penalty_obj, vars_curr, args=(lam,), jac=penalty_grad, \n                           method='L-BFGS-B', bounds=[(0, 1)]*2*N + [(0, 0.5)]*N, \n                           options={'maxiter': 200})\n            vars_curr = res.x\n        centers = np.stack([vars_curr[:N], vars_curr[N:2*N]], axis=1)\n        radii, current_sum = get_radii_lp(centers)\n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, centers, radii\n\n    # 2. Shake and Squeeze Loop\n    sigma = 0.005\n    while time.time() - start_time < 260:\n        new_centers = best_centers + np.random.normal(0, sigma, (N, 2))\n        new_centers = np.clip(new_centers, 0, 1)\n        new_radii = best_radii.copy()\n        \n        # Reposition small circles\n        for i in range(N):\n            if new_radii[i] < 0.02:\n                new_centers[i] = find_gap(np.delete(new_centers, i, axis=0), np.delete(new_radii, i))\n                new_radii[i] = 0.01\n        \n        init_vars = np.concatenate([new_centers[:, 0], new_centers[:, 1], new_radii])\n        try:\n            res = minimize(slsqp_obj, init_vars, method='SLSQP', jac=slsqp_obj_jac,\n                           constraints={'type': 'ineq', 'fun': slsqp_con, 'jac': slsqp_con_jac},\n                           bounds=[(0, 1)]*2*N + [(0, 0.5)]*N, options={'maxiter': 60})\n            if res.success and -res.fun > best_sum:\n                best_sum = -res.fun\n                best_centers = np.stack([res.x[:N], res.x[N:2*N]], axis=1)\n                best_radii = res.x[2*N:]\n                sigma = 0.005\n            else:\n                sigma = max(1e-6, sigma * 0.95)\n        except:\n            continue\n\n    # Final Polish\n    try:\n        init_vars = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n        res = minimize(slsqp_obj, init_vars, method='SLSQP', jac=slsqp_obj_jac,\n                       constraints={'type': 'ineq', 'fun': slsqp_con, 'jac': slsqp_con_jac},\n                       bounds=[(0, 1)]*2*N + [(0, 0.5)]*N, options={'maxiter': 200})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = np.stack([res.x[:N], res.x[N:2*N]], axis=1)\n            best_radii = res.x[2*N:]\n    except:\n        pass\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.6123026658193442,
    "eval_time": 260.7429361343384,
    "error": null
  },
  "prompt": "\nImprove upon Trial trial_6_1 (Score: 2.6359773947794705).\nImplement a 'shake and squeeze' algorithm:\n1. Start with the best configuration.\n2. Apply a series of small random perturbations to the centers.\n3. For each perturbation, use SLSQP to maximize the sum of radii.\n4. If a circle's radius becomes very small, try repositioning it in the largest empty 'gap' in the square before re-optimizing.\n5. Repeat for 100 iterations or until timeout.\n\nCode of Trial trial_6_1:\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Strategy:\n    1. Multi-start approach using grid-based, hexagonal-like, and random initializations.\n    2. Non-linear optimization (L-BFGS-B) with a penalty method and a continuation \n       schedule for the penalty parameter to find promising layout basins.\n    3. Linear Programming (LP) refinement to find the exact optimal radii for given centers.\n    4. Final polishing of the best-found configuration using SLSQP to optimize centers \n       and radii simultaneously.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Global best tracking\n    best_sum = 0\n    best_centers = np.random.rand(n, 2) * 0.8 + 0.1\n    best_radii = np.zeros(n)\n\n    # Pre-calculate Linear Programming constraint matrix for radii\n    num_pairs = n * (n - 1) // 2\n    A_ub = np.zeros((num_pairs, n))\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1\n            A_ub[idx, j] = 1\n            idx += 1\n    c_lp = -np.ones(n)\n\n    def get_radii_lp(centers):\n        \"\"\"Finds optimal radii for fixed centers using LP.\"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        b_ub = np.zeros(num_pairs)\n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                b_ub[idx] = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                idx += 1\n        # Radii limited by distance to the nearest wall\n        max_r_bound = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        lp_bounds = [(0, max(0.0, b)) for b in max_r_bound]\n        \n        try:\n            # Highs solver is significantly faster if available\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if res.success:\n            return res.x, -res.fun\n        return None, 0\n\n    def penalty_obj(vars, n, lam):\n        \"\"\"Penalty objective function for L-BFGS-B.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        obj = -np.sum(r)\n        # Boundary violations\n        b_cons = np.concatenate([r - x, x + r - 1, r - y, y + r - 1])\n        p_bound = np.sum(np.maximum(0, b_cons)**2)\n        # Overlap violations\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        p_overlap = np.sum(np.triu(np.maximum(0, r_sum - dist)**2, k=1))\n        return obj + lam * (p_bound + p_overlap)\n\n    def penalty_grad(vars, n, lam):\n        \"\"\"Gradient of the penalty objective function.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        dx_v, dy_v, dr_v = np.zeros(n), np.zeros(n), -np.ones(n)\n        \n        # Boundary gradients\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dr_v += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        dx_v += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_v += 2 * lam * (-b3 * m3 + b4 * m4)\n        \n        # Overlap gradients\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        violation = r_sum - dist\n        mask = (violation > 0)\n        np.fill_diagonal(mask, False)\n        mask = np.triu(mask)\n        \n        common = 2 * lam * violation * mask\n        dr_v += np.sum(common, axis=1) + np.sum(common, axis=0)\n        dist_inv = common / dist\n        dx_diff = dx * dist_inv\n        dy_diff = dy * dist_inv\n        dx_v -= np.sum(dx_diff, axis=1)\n        dx_v += np.sum(dx_diff, axis=0)\n        dy_v -= np.sum(dy_diff, axis=1)\n        dy_v += np.sum(dy_diff, axis=0)\n        \n        return np.concatenate([dx_v, dy_v, dr_v])\n\n    # Main exploration loop\n    trial = 0\n    while time.time() - start_time < 270:\n        # Diverse initialization strategies\n        if trial == 0:\n            # 5x5 grid + 1 central circle\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init, y_init = np.concatenate([xg.flatten(), [0.5]]), np.concatenate([yg.flatten(), [0.5]])\n            r_init = np.concatenate([np.ones(25)*0.1, [0.01]])\n        elif trial == 1:\n            # Shifted row (hexagonal-like) layout\n            row_counts = [5, 5, 6, 5, 5]\n            x_init, y_init = [], []\n            y_coords = np.linspace(0.1, 0.9, 5)\n            for i, count in enumerate(row_counts):\n                xs = np.linspace(0.1, 0.9, count)\n                for x in xs:\n                    x_init.append(x)\n                    y_init.append(y_coords[i])\n            x_init, y_init, r_init = np.array(x_init), np.array(y_init), np.ones(n)*0.09\n        elif trial == 2:\n            # 6x4 grid + 2 side circles\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n            x_init, y_init = np.concatenate([xg.flatten(), [0.1, 0.9]]), np.concatenate([yg.flatten(), [0.1, 0.9]])\n            r_init = np.ones(n)*0.09\n        else:\n            # Random starts\n            x_init, y_init = np.random.uniform(0.1, 0.9, n), np.random.uniform(0.1, 0.9, n)\n            r_init = np.ones(n)*0.09\n        \n        # Continuation method: solve with increasing penalty\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n        for lam in [20, 200, 2000]:\n            res = minimize(penalty_obj, vars_curr, args=(n, lam), jac=penalty_grad, \n                           method='L-BFGS-B', bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, \n                           options={'maxiter': 400, 'ftol': 1e-8})\n            vars_curr = res.x\n        \n        # Refine centers found by penalty method using LP\n        centers = np.stack([vars_curr[:n], vars_curr[n:2*n]], axis=1)\n        radii, current_sum = get_radii_lp(centers)\n        \n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, centers, radii\n        trial += 1\n\n    # Final polish using SLSQP on the best configuration found\n    def slsqp_obj(vars): return -np.sum(vars[2*n:])\n    \n    def slsqp_con(vars):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        o_cons = (dist - (r[:, None] + r[None, :]))[np.triu_indices(n, k=1)]\n        return np.concatenate([b_cons, o_cons])\n\n    try:\n        init_vars = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n        res_slsqp = minimize(slsqp_obj, init_vars, method='SLSQP', \n                             constraints={'type': 'ineq', 'fun': slsqp_con}, \n                             bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, \n                             options={'maxiter': 200})\n        if res_slsqp.success and -res_slsqp.fun > best_sum:\n            best_sum = -res_slsqp.fun\n            best_centers = np.stack([res_slsqp.x[:n], res_slsqp.x[n:2*n]], axis=1)\n            best_radii = res_slsqp.x[2*n:]\n    except:\n        pass\n\n    return best_centers, best_radii, best_sum\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Strategy:\n    1. Initial exploration using a penalty method with L-BFGS-B and Linear Programming (LP).\n    2. 'Shake and Squeeze' algorithm:\n       - Apply small random perturbations to circle centers.\n       - Use SLSQP to optimize centers and radii simultaneously.\n       - Reposition circles with very small radii into the largest available gaps.\n    3. Final polish using SLSQP on the best-found configuration.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    TRIU_IDX = np.triu_indices(N, k=1)\n    \n    # Pre-calculate Linear Programming components\n    num_pairs = N * (N - 1) // 2\n    A_ub_lp = np.zeros((num_pairs, N))\n    idx = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            A_ub_lp[idx, i] = 1\n            A_ub_lp[idx, j] = 1\n            idx += 1\n    c_lp = -np.ones(N)\n\n    def get_radii_lp(centers):\n        \"\"\"Optimizes radii for fixed centers using LP.\"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        b_ub = np.zeros(num_pairs)\n        idx = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                b_ub[idx] = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                idx += 1\n        max_r_bound = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        lp_bounds = [(0, max(0.0, b)) for b in max_r_bound]\n        \n        try:\n            res = linprog(c_lp, A_ub=A_ub_lp, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            res = linprog(c_lp, A_ub=A_ub_lp, b_ub=b_ub, bounds=lp_bounds)\n            \n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(N), 0\n\n    def penalty_obj(vars, lam):\n        x, y, r = vars[:N], vars[N:2*N], vars[2*N:]\n        obj = -np.sum(r)\n        b_cons = np.concatenate([r - x, x + r - 1, r - y, y + r - 1])\n        p_bound = np.sum(np.maximum(0, b_cons)**2)\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        p_overlap = np.sum(np.triu(np.maximum(0, r_sum - dist)**2, k=1))\n        return obj + lam * (p_bound + p_overlap)\n\n    def penalty_grad(vars, lam):\n        x, y, r = vars[:N], vars[N:2*N], vars[2*N:]\n        dx_v, dy_v, dr_v = np.zeros(N), np.zeros(N), -np.ones(N)\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dr_v += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        dx_v += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_v += 2 * lam * (-b3 * m3 + b4 * m4)\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        violation = r_sum - dist\n        mask = np.triu(violation > 0, k=1)\n        common = 2 * lam * violation * mask\n        dr_v += np.sum(common, axis=1) + np.sum(common, axis=0)\n        dist_inv = common / dist\n        dx_diff = dx * dist_inv\n        dy_diff = dy * dist_inv\n        dx_v -= np.sum(dx_diff, axis=1); dx_v += np.sum(dx_diff, axis=0)\n        dy_v -= np.sum(dy_diff, axis=1); dy_v += np.sum(dy_diff, axis=0)\n        return np.concatenate([dx_v, dy_v, dr_v])\n\n    def slsqp_obj(vars): return -np.sum(vars[2*N:])\n    def slsqp_obj_jac(vars):\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def slsqp_con(vars):\n        x, y, r = vars[:N], vars[N:2*N], vars[2*N:]\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        dx = x[TRIU_IDX[0]] - x[TRIU_IDX[1]]\n        dy = y[TRIU_IDX[0]] - y[TRIU_IDX[1]]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        o_cons = dist - (r[TRIU_IDX[0]] + r[TRIU_IDX[1]])\n        return np.concatenate([b_cons, o_cons])\n\n    def slsqp_con_jac(vars):\n        x, y, r = vars[:N], vars[N:2*N], vars[2*N:]\n        J = np.zeros((4*N + num_pairs, 3*N))\n        for i in range(N):\n            J[i, i] = 1; J[i, 2*N+i] = -1\n            J[N+i, i] = -1; J[N+i, 2*N+i] = -1\n            J[2*N+i, N+i] = 1; J[2*N+i, 2*N+i] = -1\n            J[3*N+i, N+i] = -1; J[3*N+i, 2*N+i] = -1\n        dx = x[TRIU_IDX[0]] - x[TRIU_IDX[1]]\n        dy = y[TRIU_IDX[0]] - y[TRIU_IDX[1]]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        for idx, (i, j) in enumerate(zip(TRIU_IDX[0], TRIU_IDX[1])):\n            row = 4*N + idx\n            J[row, i] = dx[idx] / dist[idx]\n            J[row, j] = -dx[idx] / dist[idx]\n            J[row, N+i] = dy[idx] / dist[idx]\n            J[row, N+j] = -dy[idx] / dist[idx]\n            J[row, 2*N+i] = -1\n            J[row, 2*N+j] = -1\n        return J\n\n    def find_gap(other_centers, other_radii):\n        best_p, max_d = np.random.rand(2), -1\n        for _ in range(500):\n            p = np.random.rand(2)\n            d_wall = min(p[0], 1-p[0], p[1], 1-p[1])\n            d_circle = np.min(np.sqrt(np.sum((other_centers - p)**2, axis=1)) - other_radii)\n            d = min(d_wall, d_circle)\n            if d > max_d:\n                max_d, best_p = d, p\n        return best_p\n\n    # 1. Initialization\n    best_sum = 0\n    best_centers = np.random.rand(N, 2)\n    best_radii = np.zeros(N)\n    \n    # Try different layouts\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    inits = [np.vstack([xg.flatten(), yg.flatten()]).T]\n    inits[0] = np.vstack([inits[0], [0.5, 0.5]])\n    \n    for x_init_c in inits:\n        vars_curr = np.concatenate([x_init_c[:, 0], x_init_c[:, 1], np.ones(N)*0.09])\n        for lam in [50, 500]:\n            res = minimize(penalty_obj, vars_curr, args=(lam,), jac=penalty_grad, \n                           method='L-BFGS-B', bounds=[(0, 1)]*2*N + [(0, 0.5)]*N, \n                           options={'maxiter': 200})\n            vars_curr = res.x\n        centers = np.stack([vars_curr[:N], vars_curr[N:2*N]], axis=1)\n        radii, current_sum = get_radii_lp(centers)\n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, centers, radii\n\n    # 2. Shake and Squeeze Loop\n    sigma = 0.005\n    while time.time() - start_time < 260:\n        new_centers = best_centers + np.random.normal(0, sigma, (N, 2))\n        new_centers = np.clip(new_centers, 0, 1)\n        new_radii = best_radii.copy()\n        \n        # Reposition small circles\n        for i in range(N):\n            if new_radii[i] < 0.02:\n                new_centers[i] = find_gap(np.delete(new_centers, i, axis=0), np.delete(new_radii, i))\n                new_radii[i] = 0.01\n        \n        init_vars = np.concatenate([new_centers[:, 0], new_centers[:, 1], new_radii])\n        try:\n            res = minimize(slsqp_obj, init_vars, method='SLSQP', jac=slsqp_obj_jac,\n                           constraints={'type': 'ineq', 'fun': slsqp_con, 'jac': slsqp_con_jac},\n                           bounds=[(0, 1)]*2*N + [(0, 0.5)]*N, options={'maxiter': 60})\n            if res.success and -res.fun > best_sum:\n                best_sum = -res.fun\n                best_centers = np.stack([res.x[:N], res.x[N:2*N]], axis=1)\n                best_radii = res.x[2*N:]\n                sigma = 0.005\n            else:\n                sigma = max(1e-6, sigma * 0.95)\n        except:\n            continue\n\n    # Final Polish\n    try:\n        init_vars = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n        res = minimize(slsqp_obj, init_vars, method='SLSQP', jac=slsqp_obj_jac,\n                       constraints={'type': 'ineq', 'fun': slsqp_con, 'jac': slsqp_con_jac},\n                       bounds=[(0, 1)]*2*N + [(0, 0.5)]*N, options={'maxiter': 200})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = np.stack([res.x[:N], res.x[N:2*N]], axis=1)\n            best_radii = res.x[2*N:]\n    except:\n        pass\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:10:34.892391",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 3043,
        "candidates_token_count": 3172,
        "thoughts_token_count": 17766
      },
      "response_text_len": 7963
    }
  },
  "llm_call_duration_s": 115.22992073802743,
  "eval_duration_s": 260.74294399190694
}