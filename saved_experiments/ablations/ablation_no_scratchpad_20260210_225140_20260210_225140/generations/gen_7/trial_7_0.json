{
  "trial_id": "trial_7_0",
  "generation": 7,
  "parent_id": "trial_6_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    \n    The strategy involves:\n    1. Multi-start with structured (grid, hexagonal) and random initializations.\n    2. Linear Programming (LP) to find optimal radii for any given set of circle centers.\n    3. SLSQP optimization to simultaneously refine centers and radii using analytical Jacobians.\n    4. A shaking (perturbation) strategy around the current best solution to escape local optima.\n    5. Final high-precision polishing of the best-found configuration.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices and LP matrices for efficiency\n    num_pairs = n * (n - 1) // 2\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    \n    A_ub = np.zeros((num_pairs, n))\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1\n            A_ub[idx, j] = 1\n            idx += 1\n    c_lp = -np.ones(n)\n\n    def get_radii_lp(centers):\n        \"\"\"Finds the optimal radii for a fixed set of centers using Linear Programming.\"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dist = np.sqrt(dx**2 + dy**2)\n        b_ub = dist\n        \n        # Radii are bounded by the distance to the square's walls\n        max_r_bound = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        lp_bounds = [(0, max(0.0, float(b))) for b in max_r_bound]\n        \n        try:\n            # Highs solver is efficient for this scale\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            # Fallback for older scipy versions\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n), 0\n\n    def slsqp_obj(vars):\n        \"\"\"Negative sum of radii for minimization.\"\"\"\n        return -np.sum(vars[2*n:])\n\n    def slsqp_obj_jac(vars):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1\n        return grad\n\n    def slsqp_con(vars):\n        \"\"\"Constraint function for SLSQP: all values must be >= 0.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        # Boundary constraints: circles must stay inside [0, 1] x [0, 1]\n        c_bound = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        c_overlap = dist - (r[i_idx] + r[j_idx])\n        return np.concatenate([c_bound, c_overlap])\n\n    def slsqp_jac(vars):\n        \"\"\"Analytical Jacobian for the SLSQP constraints.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        jac = np.zeros((4*n + num_pairs, 3*n))\n        \n        # Boundary constraints Jacobian parts\n        idx_n = np.arange(n)\n        jac[idx_n, idx_n] = 1\n        jac[idx_n, 2*n + idx_n] = -1\n        jac[n + idx_n, idx_n] = -1\n        jac[n + idx_n, 2*n + idx_n] = -1\n        jac[2*n + idx_n, n + idx_n] = 1\n        jac[2*n + idx_n, 2*n + idx_n] = -1\n        jac[3*n + idx_n, n + idx_n] = -1\n        jac[3*n + idx_n, 2*n + idx_n] = -1\n        \n        # Overlap constraints Jacobian parts\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        row_idx = 4*n + np.arange(num_pairs)\n        \n        jac[row_idx, i_idx] = dx / dist\n        jac[row_idx, j_idx] = -dx / dist\n        jac[row_idx, n + i_idx] = dy / dist\n        jac[row_idx, n + j_idx] = -dy / dist\n        jac[row_idx, 2*n + i_idx] = -1\n        jac[row_idx, 2*n + j_idx] = -1\n        \n        return jac\n\n    # Global best tracking\n    best_sum = 0\n    best_centers = np.random.rand(n, 2)\n    best_radii = np.zeros(n)\n\n    # Initial Strategy Generation\n    strategies = []\n    # Grid 5x5 + 1\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    strategies.append(np.column_stack([np.concatenate([xg.flatten(), [0.5]]), np.concatenate([yg.flatten(), [0.5]])]))\n    # Grid 4x6 + 2\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    strategies.append(np.column_stack([np.concatenate([xg.flatten(), [0.1, 0.9]]), np.concatenate([yg.flatten(), [0.1, 0.9]])]))\n    # Grid 3x8 + 2\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 8), np.linspace(0.1, 0.9, 3))\n    strategies.append(np.column_stack([np.concatenate([xg.flatten(), [0.1, 0.9]]), np.concatenate([yg.flatten(), [0.5, 0.5]])]))\n    # Hexagonal-like\n    xh, yh = [], []\n    for y, count in zip(np.linspace(0.1, 0.9, 5), [5, 6, 5, 6, 4]):\n        for x in np.linspace(0.1, 0.9, count):\n            xh.append(x); yh.append(y)\n    strategies.append(np.column_stack([xh, yh]))\n    # Random starts\n    for _ in range(10):\n        strategies.append(0.1 + 0.8 * np.random.rand(n, 2))\n\n    # Phase 1: Multi-start Exploration\n    for centers in strategies:\n        if time.time() - start_time > 150: break\n        radii, current_sum = get_radii_lp(centers)\n        init_vars = np.concatenate([centers[:, 0], centers[:, 1], radii])\n        res = minimize(slsqp_obj, init_vars, method='SLSQP', jac=slsqp_obj_jac,\n                       constraints={'type': 'ineq', 'fun': slsqp_con, 'jac': slsqp_jac},\n                       bounds=[(0, 1)]*2*n + [(0, 0.5)]*n,\n                       options={'maxiter': 100, 'ftol': 1e-7})\n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = np.column_stack([res.x[:n], res.x[n:2*n]])\n            best_radii = res.x[2*n:]\n\n    # Phase 2: Shaking (Perturbation) and Refinement\n    sigma = 0.02\n    while time.time() - start_time < 275:\n        # Slightly perturb the current best centers\n        new_centers = best_centers + np.random.normal(0, sigma, best_centers.shape)\n        new_centers = np.clip(new_centers, 0, 1)\n        radii, current_sum = get_radii_lp(new_centers)\n        \n        # If the perturbed centers are promising, refine them\n        if current_sum > best_sum - 0.02:\n            init_vars = np.concatenate([new_centers[:, 0], new_centers[:, 1], radii])\n            res = minimize(slsqp_obj, init_vars, method='SLSQP', jac=slsqp_obj_jac,\n                           constraints={'type': 'ineq', 'fun': slsqp_con, 'jac': slsqp_jac},\n                           bounds=[(0, 1)]*2*n + [(0, 0.5)]*n,\n                           options={'maxiter': 150, 'ftol': 1e-9})\n            if res.success and -res.fun > best_sum:\n                best_sum = -res.fun\n                best_centers = np.column_stack([res.x[:n], res.x[n:2*n]])\n                best_radii = res.x[2*n:]\n                sigma = 0.02 # Reset shaking intensity\n            else:\n                sigma *= 0.99 # Slowly reduce shaking intensity\n        else:\n            sigma *= 0.98\n\n    # Final Phase: High-precision polish\n    init_vars = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n    res = minimize(slsqp_obj, init_vars, method='SLSQP', jac=slsqp_obj_jac,\n                   constraints={'type': 'ineq', 'fun': slsqp_con, 'jac': slsqp_jac},\n                   bounds=[(0, 1)]*2*n + [(0, 0.5)]*n,\n                   options={'maxiter': 500, 'ftol': 1e-12})\n    \n    if res.success and -res.fun > best_sum:\n        best_sum = -res.fun\n        best_centers = np.column_stack([res.x[:n], res.x[n:2*n]])\n        best_radii = res.x[2*n:]\n    \n    # Final LP safety check for exact optimal radii\n    final_radii, final_sum = get_radii_lp(best_centers)\n    if final_sum > best_sum:\n        best_sum = final_sum\n        best_radii = final_radii\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.6171909725719074,
    "eval_time": 275.8466122150421,
    "error": null
  },
  "prompt": "\nRefine the following best-performing solution (score=2.6359773947794705). \nThe current approach uses SLSQP/Basin-hopping. \nImprove it by:\n1. Implementing a more robust multi-start strategy with small perturbations (shaking) around the current best configuration.\n2. Using scipy.optimize.minimize with 'SLSQP' but with much tighter tolerances (ftol=1e-12).\n3. Ensure the 'sum of radii' objective is handled carefully with constraints to prevent overlap.\n4. Try a 'basin-hopping' approach where the local minimizer is a very carefully tuned SLSQP.\n\nCode to improve:\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Strategy:\n    1. Multi-start approach using grid-based, hexagonal-like, and random initializations.\n    2. Non-linear optimization (L-BFGS-B) with a penalty method and a continuation \n       schedule for the penalty parameter to find promising layout basins.\n    3. Linear Programming (LP) refinement to find the exact optimal radii for given centers.\n    4. Final polishing of the best-found configuration using SLSQP to optimize centers \n       and radii simultaneously.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Global best tracking\n    best_sum = 0\n    best_centers = np.random.rand(n, 2) * 0.8 + 0.1\n    best_radii = np.zeros(n)\n\n    # Pre-calculate Linear Programming constraint matrix for radii\n    num_pairs = n * (n - 1) // 2\n    A_ub = np.zeros((num_pairs, n))\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1\n            A_ub[idx, j] = 1\n            idx += 1\n    c_lp = -np.ones(n)\n\n    def get_radii_lp(centers):\n        \"\"\"Finds optimal radii for fixed centers using LP.\"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        b_ub = np.zeros(num_pairs)\n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                b_ub[idx] = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                idx += 1\n        # Radii limited by distance to the nearest wall\n        max_r_bound = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        lp_bounds = [(0, max(0.0, b)) for b in max_r_bound]\n        \n        try:\n            # Highs solver is significantly faster if available\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if res.success:\n            return res.x, -res.fun\n        return None, 0\n\n    def penalty_obj(vars, n, lam):\n        \"\"\"Penalty objective function for L-BFGS-B.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        obj = -np.sum(r)\n        # Boundary violations\n        b_cons = np.concatenate([r - x, x + r - 1, r - y, y + r - 1])\n        p_bound = np.sum(np.maximum(0, b_cons)**2)\n        # Overlap violations\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        p_overlap = np.sum(np.triu(np.maximum(0, r_sum - dist)**2, k=1))\n        return obj + lam * (p_bound + p_overlap)\n\n    def penalty_grad(vars, n, lam):\n        \"\"\"Gradient of the penalty objective function.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        dx_v, dy_v, dr_v = np.zeros(n), np.zeros(n), -np.ones(n)\n        \n        # Boundary gradients\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dr_v += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        dx_v += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_v += 2 * lam * (-b3 * m3 + b4 * m4)\n        \n        # Overlap gradients\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        violation = r_sum - dist\n        mask = (violation > 0)\n        np.fill_diagonal(mask, False)\n        mask = np.triu(mask)\n        \n        common = 2 * lam * violation * mask\n        dr_v += np.sum(common, axis=1) + np.sum(common, axis=0)\n        dist_inv = common / dist\n        dx_diff = dx * dist_inv\n        dy_diff = dy * dist_inv\n        dx_v -= np.sum(dx_diff, axis=1)\n        dx_v += np.sum(dx_diff, axis=0)\n        dy_v -= np.sum(dy_diff, axis=1)\n        dy_v += np.sum(dy_diff, axis=0)\n        \n        return np.concatenate([dx_v, dy_v, dr_v])\n\n    # Main exploration loop\n    trial = 0\n    while time.time() - start_time < 270:\n        # Diverse initialization strategies\n        if trial == 0:\n            # 5x5 grid + 1 central circle\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init, y_init = np.concatenate([xg.flatten(), [0.5]]), np.concatenate([yg.flatten(), [0.5]])\n            r_init = np.concatenate([np.ones(25)*0.1, [0.01]])\n        elif trial == 1:\n            # Shifted row (hexagonal-like) layout\n            row_counts = [5, 5, 6, 5, 5]\n            x_init, y_init = [], []\n            y_coords = np.linspace(0.1, 0.9, 5)\n            for i, count in enumerate(row_counts):\n                xs = np.linspace(0.1, 0.9, count)\n                for x in xs:\n                    x_init.append(x)\n                    y_init.append(y_coords[i])\n            x_init, y_init, r_init = np.array(x_init), np.array(y_init), np.ones(n)*0.09\n        elif trial == 2:\n            # 6x4 grid + 2 side circles\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n            x_init, y_init = np.concatenate([xg.flatten(), [0.1, 0.9]]), np.concatenate([yg.flatten(), [0.1, 0.9]])\n            r_init = np.ones(n)*0.09\n        else:\n            # Random starts\n            x_init, y_init = np.random.uniform(0.1, 0.9, n), np.random.uniform(0.1, 0.9, n)\n            r_init = np.ones(n)*0.09\n        \n        # Continuation method: solve with increasing penalty\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n        for lam in [20, 200, 2000]:\n            res = minimize(penalty_obj, vars_curr, args=(n, lam), jac=penalty_grad, \n                           method='L-BFGS-B', bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, \n                           options={'maxiter': 400, 'ftol': 1e-8})\n            vars_curr = res.x\n        \n        # Refine centers found by penalty method using LP\n        centers = np.stack([vars_curr[:n], vars_curr[n:2*n]], axis=1)\n        radii, current_sum = get_radii_lp(centers)\n        \n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, centers, radii\n        trial += 1\n\n    # Final polish using SLSQP on the best configuration found\n    def slsqp_obj(vars): return -np.sum(vars[2*n:])\n    \n    def slsqp_con(vars):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        o_cons = (dist - (r[:, None] + r[None, :]))[np.triu_indices(n, k=1)]\n        return np.concatenate([b_cons, o_cons])\n\n    try:\n        init_vars = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n        res_slsqp = minimize(slsqp_obj, init_vars, method='SLSQP', \n                             constraints={'type': 'ineq', 'fun': slsqp_con}, \n                             bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, \n                             options={'maxiter': 200})\n        if res_slsqp.success and -res_slsqp.fun > best_sum:\n            best_sum = -res_slsqp.fun\n            best_centers = np.stack([res_slsqp.x[:n], res_slsqp.x[n:2*n]], axis=1)\n            best_radii = res_slsqp.x[2*n:]\n    except:\n        pass\n\n    return best_centers, best_radii, best_sum\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    \n    The strategy involves:\n    1. Multi-start with structured (grid, hexagonal) and random initializations.\n    2. Linear Programming (LP) to find optimal radii for any given set of circle centers.\n    3. SLSQP optimization to simultaneously refine centers and radii using analytical Jacobians.\n    4. A shaking (perturbation) strategy around the current best solution to escape local optima.\n    5. Final high-precision polishing of the best-found configuration.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices and LP matrices for efficiency\n    num_pairs = n * (n - 1) // 2\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    \n    A_ub = np.zeros((num_pairs, n))\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1\n            A_ub[idx, j] = 1\n            idx += 1\n    c_lp = -np.ones(n)\n\n    def get_radii_lp(centers):\n        \"\"\"Finds the optimal radii for a fixed set of centers using Linear Programming.\"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dist = np.sqrt(dx**2 + dy**2)\n        b_ub = dist\n        \n        # Radii are bounded by the distance to the square's walls\n        max_r_bound = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        lp_bounds = [(0, max(0.0, float(b))) for b in max_r_bound]\n        \n        try:\n            # Highs solver is efficient for this scale\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            # Fallback for older scipy versions\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n), 0\n\n    def slsqp_obj(vars):\n        \"\"\"Negative sum of radii for minimization.\"\"\"\n        return -np.sum(vars[2*n:])\n\n    def slsqp_obj_jac(vars):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1\n        return grad\n\n    def slsqp_con(vars):\n        \"\"\"Constraint function for SLSQP: all values must be >= 0.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        # Boundary constraints: circles must stay inside [0, 1] x [0, 1]\n        c_bound = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        c_overlap = dist - (r[i_idx] + r[j_idx])\n        return np.concatenate([c_bound, c_overlap])\n\n    def slsqp_jac(vars):\n        \"\"\"Analytical Jacobian for the SLSQP constraints.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        jac = np.zeros((4*n + num_pairs, 3*n))\n        \n        # Boundary constraints Jacobian parts\n        idx_n = np.arange(n)\n        jac[idx_n, idx_n] = 1\n        jac[idx_n, 2*n + idx_n] = -1\n        jac[n + idx_n, idx_n] = -1\n        jac[n + idx_n, 2*n + idx_n] = -1\n        jac[2*n + idx_n, n + idx_n] = 1\n        jac[2*n + idx_n, 2*n + idx_n] = -1\n        jac[3*n + idx_n, n + idx_n] = -1\n        jac[3*n + idx_n, 2*n + idx_n] = -1\n        \n        # Overlap constraints Jacobian parts\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        row_idx = 4*n + np.arange(num_pairs)\n        \n        jac[row_idx, i_idx] = dx / dist\n        jac[row_idx, j_idx] = -dx / dist\n        jac[row_idx, n + i_idx] = dy / dist\n        jac[row_idx, n + j_idx] = -dy / dist\n        jac[row_idx, 2*n + i_idx] = -1\n        jac[row_idx, 2*n + j_idx] = -1\n        \n        return jac\n\n    # Global best tracking\n    best_sum = 0\n    best_centers = np.random.rand(n, 2)\n    best_radii = np.zeros(n)\n\n    # Initial Strategy Generation\n    strategies = []\n    # Grid 5x5 + 1\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    strategies.append(np.column_stack([np.concatenate([xg.flatten(), [0.5]]), np.concatenate([yg.flatten(), [0.5]])]))\n    # Grid 4x6 + 2\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    strategies.append(np.column_stack([np.concatenate([xg.flatten(), [0.1, 0.9]]), np.concatenate([yg.flatten(), [0.1, 0.9]])]))\n    # Grid 3x8 + 2\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 8), np.linspace(0.1, 0.9, 3))\n    strategies.append(np.column_stack([np.concatenate([xg.flatten(), [0.1, 0.9]]), np.concatenate([yg.flatten(), [0.5, 0.5]])]))\n    # Hexagonal-like\n    xh, yh = [], []\n    for y, count in zip(np.linspace(0.1, 0.9, 5), [5, 6, 5, 6, 4]):\n        for x in np.linspace(0.1, 0.9, count):\n            xh.append(x); yh.append(y)\n    strategies.append(np.column_stack([xh, yh]))\n    # Random starts\n    for _ in range(10):\n        strategies.append(0.1 + 0.8 * np.random.rand(n, 2))\n\n    # Phase 1: Multi-start Exploration\n    for centers in strategies:\n        if time.time() - start_time > 150: break\n        radii, current_sum = get_radii_lp(centers)\n        init_vars = np.concatenate([centers[:, 0], centers[:, 1], radii])\n        res = minimize(slsqp_obj, init_vars, method='SLSQP', jac=slsqp_obj_jac,\n                       constraints={'type': 'ineq', 'fun': slsqp_con, 'jac': slsqp_jac},\n                       bounds=[(0, 1)]*2*n + [(0, 0.5)]*n,\n                       options={'maxiter': 100, 'ftol': 1e-7})\n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = np.column_stack([res.x[:n], res.x[n:2*n]])\n            best_radii = res.x[2*n:]\n\n    # Phase 2: Shaking (Perturbation) and Refinement\n    sigma = 0.02\n    while time.time() - start_time < 275:\n        # Slightly perturb the current best centers\n        new_centers = best_centers + np.random.normal(0, sigma, best_centers.shape)\n        new_centers = np.clip(new_centers, 0, 1)\n        radii, current_sum = get_radii_lp(new_centers)\n        \n        # If the perturbed centers are promising, refine them\n        if current_sum > best_sum - 0.02:\n            init_vars = np.concatenate([new_centers[:, 0], new_centers[:, 1], radii])\n            res = minimize(slsqp_obj, init_vars, method='SLSQP', jac=slsqp_obj_jac,\n                           constraints={'type': 'ineq', 'fun': slsqp_con, 'jac': slsqp_jac},\n                           bounds=[(0, 1)]*2*n + [(0, 0.5)]*n,\n                           options={'maxiter': 150, 'ftol': 1e-9})\n            if res.success and -res.fun > best_sum:\n                best_sum = -res.fun\n                best_centers = np.column_stack([res.x[:n], res.x[n:2*n]])\n                best_radii = res.x[2*n:]\n                sigma = 0.02 # Reset shaking intensity\n            else:\n                sigma *= 0.99 # Slowly reduce shaking intensity\n        else:\n            sigma *= 0.98\n\n    # Final Phase: High-precision polish\n    init_vars = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n    res = minimize(slsqp_obj, init_vars, method='SLSQP', jac=slsqp_obj_jac,\n                   constraints={'type': 'ineq', 'fun': slsqp_con, 'jac': slsqp_jac},\n                   bounds=[(0, 1)]*2*n + [(0, 0.5)]*n,\n                   options={'maxiter': 500, 'ftol': 1e-12})\n    \n    if res.success and -res.fun > best_sum:\n        best_sum = -res.fun\n        best_centers = np.column_stack([res.x[:n], res.x[n:2*n]])\n        best_radii = res.x[2*n:]\n    \n    # Final LP safety check for exact optimal radii\n    final_radii, final_sum = get_radii_lp(best_centers)\n    if final_sum > best_sum:\n        best_sum = final_sum\n        best_radii = final_radii\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:55:04.658612",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 3058,
        "candidates_token_count": 2852,
        "thoughts_token_count": 20833
      },
      "response_text_len": 7857
    }
  },
  "llm_call_duration_s": 137.98630500899162,
  "eval_duration_s": 275.8466223030118
}