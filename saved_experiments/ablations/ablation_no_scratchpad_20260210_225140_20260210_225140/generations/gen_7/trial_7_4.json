{
  "trial_id": "trial_7_4",
  "generation": 7,
  "parent_id": "trial_6_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    \n    Strategy:\n    1. For fixed circle centers, the problem of maximizing the sum of radii is a Linear Program (LP).\n    2. The dual variables (marginals) of this LP provide the gradient of the maximized sum \n       with respect to the centers.\n    3. We use this gradient to perform a non-linear optimization (L-BFGS-B) on the center positions.\n    4. Multiple initializations (grid-based, spiral, and random) are used to explore different basins.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate LP constraint matrix structure\n    num_pairs = n * (n - 1) // 2\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    \n    # Pairwise distance constraints: r_i + r_j <= dist_ij\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1\n            A_ub[idx, j] = 1\n            idx += 1\n            \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    for i in range(n):\n        A_ub[idx + i, i] = 1          \n        A_ub[idx + n + i, i] = 1      \n        A_ub[idx + 2 * n + i, i] = 1  \n        A_ub[idx + 3 * n + i, i] = 1  \n        \n    # Objective for linprog: minimize -sum(r_i)\n    c_lp = -np.ones(n)\n    \n    def get_sum_and_grad(centers_flat):\n        \"\"\"Calculates the max sum of radii and its gradient w.r.t. centers.\"\"\"\n        x = centers_flat[:n]\n        y = centers_flat[n:]\n        \n        b_ub = np.zeros(num_pairs + 4 * n)\n        dists = np.zeros(num_pairs)\n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                dists[idx] = d\n                b_ub[idx] = d\n                idx += 1\n        \n        b_ub[num_pairs : num_pairs + n] = x\n        b_ub[num_pairs + n : num_pairs + 2 * n] = 1 - x\n        b_ub[num_pairs + 2 * n : num_pairs + 3 * n] = y\n        b_ub[num_pairs + 3 * n : num_pairs + 4 * n] = 1 - y\n        \n        try:\n            # Solve LP to find optimal radii for these centers\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, method='highs')\n            if not res.success:\n                return 0, np.zeros_like(centers_flat)\n            \n            # Marginals (dual variables) represent the sensitivity of the sum to constraints\n            m = res.ineqlin.marginals # d(res.fun) / d(b_ub)\n            \n            grad_x = np.zeros(n)\n            grad_y = np.zeros(n)\n            \n            idx = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = max(dists[idx], 1e-9)\n                    # Gradient contribution from pairwise distance constraints\n                    val_x = m[idx] * (x[i] - x[j]) / d\n                    val_y = m[idx] * (y[i] - y[j]) / d\n                    grad_x[i] += val_x\n                    grad_x[j] -= val_x\n                    grad_y[i] += val_y\n                    grad_y[j] -= val_y\n                    idx += 1\n            \n            # Gradient contribution from boundary constraints\n            grad_x += m[num_pairs : num_pairs + n]\n            grad_x -= m[num_pairs + n : num_pairs + 2 * n]\n            grad_y += m[num_pairs + 2 * n : num_pairs + 3 * n]\n            grad_y -= m[num_pairs + 3 * n : num_pairs + 4 * n]\n            \n            return res.fun, np.concatenate([grad_x, grad_y])\n        except:\n            return 0, np.zeros_like(centers_flat)\n\n    best_sum_total = 0\n    best_centers_total = np.random.rand(n, 2)\n    best_radii_total = np.zeros(n)\n\n    # Diverse initialization strategies\n    seeds = []\n    # 1. 5x5 grid + 1 extra\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    seeds.append(np.vstack([np.column_stack([xg.flatten(), yg.flatten()]), [0.05, 0.05]]))\n    # 2. 4x6 grid + 2 extra\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    seeds.append(np.vstack([np.column_stack([xg.flatten(), yg.flatten()]), [[0.05, 0.05], [0.95, 0.95]]]))\n    # 3. Fermat spiral (Sunflower packing)\n    phi = (1 + 5**0.5) / 2\n    r_spiral = 0.45 * np.sqrt(np.arange(n) / n)\n    theta = 2 * np.pi * phi * np.arange(n)\n    seeds.append(np.column_stack([0.5 + r_spiral * np.cos(theta), 0.5 + r_spiral * np.sin(theta)]))\n    # 4. Random seeds\n    for _ in range(25):\n        seeds.append(np.random.rand(n, 2) * 0.8 + 0.1)\n\n    # Optimization loop\n    for centers_init in seeds:\n        if time.time() - start_time > 280:\n            break\n            \n        # Optimize center positions using L-BFGS-B and the LP-derived gradient\n        res = minimize(get_sum_and_grad, centers_init.flatten(order='F'), jac=True,\n                       method='L-BFGS-B', bounds=[(0, 1)] * (2 * n),\n                       options={'maxiter': 100})\n        \n        current_sum = -res.fun\n        if current_sum > best_sum_total:\n            # Re-run LP to extract final radii for the best centers found\n            x, y = res.x[:n], res.x[n:]\n            b_ub = np.zeros(num_pairs + 4 * n)\n            idx = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    b_ub[idx] = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                    idx += 1\n            b_ub[num_pairs : num_pairs + n] = x\n            b_ub[num_pairs + n : num_pairs + 2 * n] = 1 - x\n            b_ub[num_pairs + 2 * n : num_pairs + 3 * n] = y\n            b_ub[num_pairs + 3 * n : num_pairs + 4 * n] = 1 - y\n            \n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, method='highs')\n            if lp_res.success:\n                best_sum_total = -lp_res.fun\n                best_centers_total = np.column_stack([x, y])\n                best_radii_total = lp_res.x\n\n    return best_centers_total, best_radii_total, best_sum_total",
  "metrics": {
    "valid": true,
    "score": 2.4707108744981565,
    "eval_time": 81.58255863189697,
    "error": null
  },
  "prompt": "\nTake the best configuration found so far:\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Strategy:\n    1. Multi-start approach using grid-based, hexagonal-like, and random initializations.\n    2. Non-linear optimization (L-BFGS-B) with a penalty method and a continuation \n       schedule for the penalty parameter to find promising layout basins.\n    3. Linear Programming (LP) refinement to find the exact optimal radii for given centers.\n    4. Final polishing of the best-found configuration using SLSQP to optimize centers \n       and radii simultaneously.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Global best tracking\n    best_sum = 0\n    best_centers = np.random.rand(n, 2) * 0.8 + 0.1\n    best_radii = np.zeros(n)\n\n    # Pre-calculate Linear Programming constraint matrix for radii\n    num_pairs = n * (n - 1) // 2\n    A_ub = np.zeros((num_pairs, n))\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1\n            A_ub[idx, j] = 1\n            idx += 1\n    c_lp = -np.ones(n)\n\n    def get_radii_lp(centers):\n        \"\"\"Finds optimal radii for fixed centers using LP.\"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        b_ub = np.zeros(num_pairs)\n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                b_ub[idx] = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                idx += 1\n        # Radii limited by distance to the nearest wall\n        max_r_bound = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        lp_bounds = [(0, max(0.0, b)) for b in max_r_bound]\n        \n        try:\n            # Highs solver is significantly faster if available\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if res.success:\n            return res.x, -res.fun\n        return None, 0\n\n    def penalty_obj(vars, n, lam):\n        \"\"\"Penalty objective function for L-BFGS-B.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        obj = -np.sum(r)\n        # Boundary violations\n        b_cons = np.concatenate([r - x, x + r - 1, r - y, y + r - 1])\n        p_bound = np.sum(np.maximum(0, b_cons)**2)\n        # Overlap violations\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        p_overlap = np.sum(np.triu(np.maximum(0, r_sum - dist)**2, k=1))\n        return obj + lam * (p_bound + p_overlap)\n\n    def penalty_grad(vars, n, lam):\n        \"\"\"Gradient of the penalty objective function.\"\"\"\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        dx_v, dy_v, dr_v = np.zeros(n), np.zeros(n), -np.ones(n)\n        \n        # Boundary gradients\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dr_v += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        dx_v += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_v += 2 * lam * (-b3 * m3 + b4 * m4)\n        \n        # Overlap gradients\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        violation = r_sum - dist\n        mask = (violation > 0)\n        np.fill_diagonal(mask, False)\n        mask = np.triu(mask)\n        \n        common = 2 * lam * violation * mask\n        dr_v += np.sum(common, axis=1) + np.sum(common, axis=0)\n        dist_inv = common / dist\n        dx_diff = dx * dist_inv\n        dy_diff = dy * dist_inv\n        dx_v -= np.sum(dx_diff, axis=1)\n        dx_v += np.sum(dx_diff, axis=0)\n        dy_v -= np.sum(dy_diff, axis=1)\n        dy_v += np.sum(dy_diff, axis=0)\n        \n        return np.concatenate([dx_v, dy_v, dr_v])\n\n    # Main exploration loop\n    trial = 0\n    while time.time() - start_time < 270:\n        # Diverse initialization strategies\n        if trial == 0:\n            # 5x5 grid + 1 central circle\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init, y_init = np.concatenate([xg.flatten(), [0.5]]), np.concatenate([yg.flatten(), [0.5]])\n            r_init = np.concatenate([np.ones(25)*0.1, [0.01]])\n        elif trial == 1:\n            # Shifted row (hexagonal-like) layout\n            row_counts = [5, 5, 6, 5, 5]\n            x_init, y_init = [], []\n            y_coords = np.linspace(0.1, 0.9, 5)\n            for i, count in enumerate(row_counts):\n                xs = np.linspace(0.1, 0.9, count)\n                for x in xs:\n                    x_init.append(x)\n                    y_init.append(y_coords[i])\n            x_init, y_init, r_init = np.array(x_init), np.array(y_init), np.ones(n)*0.09\n        elif trial == 2:\n            # 6x4 grid + 2 side circles\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n            x_init, y_init = np.concatenate([xg.flatten(), [0.1, 0.9]]), np.concatenate([yg.flatten(), [0.1, 0.9]])\n            r_init = np.ones(n)*0.09\n        else:\n            # Random starts\n            x_init, y_init = np.random.uniform(0.1, 0.9, n), np.random.uniform(0.1, 0.9, n)\n            r_init = np.ones(n)*0.09\n        \n        # Continuation method: solve with increasing penalty\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n        for lam in [20, 200, 2000]:\n            res = minimize(penalty_obj, vars_curr, args=(n, lam), jac=penalty_grad, \n                           method='L-BFGS-B', bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, \n                           options={'maxiter': 400, 'ftol': 1e-8})\n            vars_curr = res.x\n        \n        # Refine centers found by penalty method using LP\n        centers = np.stack([vars_curr[:n], vars_curr[n:2*n]], axis=1)\n        radii, current_sum = get_radii_lp(centers)\n        \n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, centers, radii\n        trial += 1\n\n    # Final polish using SLSQP on the best configuration found\n    def slsqp_obj(vars): return -np.sum(vars[2*n:])\n    \n    def slsqp_con(vars):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        o_cons = (dist - (r[:, None] + r[None, :]))[np.triu_indices(n, k=1)]\n        return np.concatenate([b_cons, o_cons])\n\n    try:\n        init_vars = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n        res_slsqp = minimize(slsqp_obj, init_vars, method='SLSQP', \n                             constraints={'type': 'ineq', 'fun': slsqp_con}, \n                             bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, \n                             options={'maxiter': 200})\n        if res_slsqp.success and -res_slsqp.fun > best_sum:\n            best_sum = -res_slsqp.fun\n            best_centers = np.stack([res_slsqp.x[:n], res_slsqp.x[n:2*n]], axis=1)\n            best_radii = res_slsqp.x[2*n:]\n    except:\n        pass\n\n    return best_centers, best_radii, best_sum\nIdentify the circles with the smallest radii in this configuration. \nPerform a local search that specifically tries to shift other circles to allow these 'weak' circles to grow, potentially increasing the total sum.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    \n    Strategy:\n    1. For fixed circle centers, the problem of maximizing the sum of radii is a Linear Program (LP).\n    2. The dual variables (marginals) of this LP provide the gradient of the maximized sum \n       with respect to the centers.\n    3. We use this gradient to perform a non-linear optimization (L-BFGS-B) on the center positions.\n    4. Multiple initializations (grid-based, spiral, and random) are used to explore different basins.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate LP constraint matrix structure\n    num_pairs = n * (n - 1) // 2\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    \n    # Pairwise distance constraints: r_i + r_j <= dist_ij\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1\n            A_ub[idx, j] = 1\n            idx += 1\n            \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    for i in range(n):\n        A_ub[idx + i, i] = 1          \n        A_ub[idx + n + i, i] = 1      \n        A_ub[idx + 2 * n + i, i] = 1  \n        A_ub[idx + 3 * n + i, i] = 1  \n        \n    # Objective for linprog: minimize -sum(r_i)\n    c_lp = -np.ones(n)\n    \n    def get_sum_and_grad(centers_flat):\n        \"\"\"Calculates the max sum of radii and its gradient w.r.t. centers.\"\"\"\n        x = centers_flat[:n]\n        y = centers_flat[n:]\n        \n        b_ub = np.zeros(num_pairs + 4 * n)\n        dists = np.zeros(num_pairs)\n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                dists[idx] = d\n                b_ub[idx] = d\n                idx += 1\n        \n        b_ub[num_pairs : num_pairs + n] = x\n        b_ub[num_pairs + n : num_pairs + 2 * n] = 1 - x\n        b_ub[num_pairs + 2 * n : num_pairs + 3 * n] = y\n        b_ub[num_pairs + 3 * n : num_pairs + 4 * n] = 1 - y\n        \n        try:\n            # Solve LP to find optimal radii for these centers\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, method='highs')\n            if not res.success:\n                return 0, np.zeros_like(centers_flat)\n            \n            # Marginals (dual variables) represent the sensitivity of the sum to constraints\n            m = res.ineqlin.marginals # d(res.fun) / d(b_ub)\n            \n            grad_x = np.zeros(n)\n            grad_y = np.zeros(n)\n            \n            idx = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = max(dists[idx], 1e-9)\n                    # Gradient contribution from pairwise distance constraints\n                    val_x = m[idx] * (x[i] - x[j]) / d\n                    val_y = m[idx] * (y[i] - y[j]) / d\n                    grad_x[i] += val_x\n                    grad_x[j] -= val_x\n                    grad_y[i] += val_y\n                    grad_y[j] -= val_y\n                    idx += 1\n            \n            # Gradient contribution from boundary constraints\n            grad_x += m[num_pairs : num_pairs + n]\n            grad_x -= m[num_pairs + n : num_pairs + 2 * n]\n            grad_y += m[num_pairs + 2 * n : num_pairs + 3 * n]\n            grad_y -= m[num_pairs + 3 * n : num_pairs + 4 * n]\n            \n            return res.fun, np.concatenate([grad_x, grad_y])\n        except:\n            return 0, np.zeros_like(centers_flat)\n\n    best_sum_total = 0\n    best_centers_total = np.random.rand(n, 2)\n    best_radii_total = np.zeros(n)\n\n    # Diverse initialization strategies\n    seeds = []\n    # 1. 5x5 grid + 1 extra\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    seeds.append(np.vstack([np.column_stack([xg.flatten(), yg.flatten()]), [0.05, 0.05]]))\n    # 2. 4x6 grid + 2 extra\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    seeds.append(np.vstack([np.column_stack([xg.flatten(), yg.flatten()]), [[0.05, 0.05], [0.95, 0.95]]]))\n    # 3. Fermat spiral (Sunflower packing)\n    phi = (1 + 5**0.5) / 2\n    r_spiral = 0.45 * np.sqrt(np.arange(n) / n)\n    theta = 2 * np.pi * phi * np.arange(n)\n    seeds.append(np.column_stack([0.5 + r_spiral * np.cos(theta), 0.5 + r_spiral * np.sin(theta)]))\n    # 4. Random seeds\n    for _ in range(25):\n        seeds.append(np.random.rand(n, 2) * 0.8 + 0.1)\n\n    # Optimization loop\n    for centers_init in seeds:\n        if time.time() - start_time > 280:\n            break\n            \n        # Optimize center positions using L-BFGS-B and the LP-derived gradient\n        res = minimize(get_sum_and_grad, centers_init.flatten(order='F'), jac=True,\n                       method='L-BFGS-B', bounds=[(0, 1)] * (2 * n),\n                       options={'maxiter': 100})\n        \n        current_sum = -res.fun\n        if current_sum > best_sum_total:\n            # Re-run LP to extract final radii for the best centers found\n            x, y = res.x[:n], res.x[n:]\n            b_ub = np.zeros(num_pairs + 4 * n)\n            idx = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    b_ub[idx] = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                    idx += 1\n            b_ub[num_pairs : num_pairs + n] = x\n            b_ub[num_pairs + n : num_pairs + 2 * n] = 1 - x\n            b_ub[num_pairs + 2 * n : num_pairs + 3 * n] = y\n            b_ub[num_pairs + 3 * n : num_pairs + 4 * n] = 1 - y\n            \n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, method='highs')\n            if lp_res.success:\n                best_sum_total = -lp_res.fun\n                best_centers_total = np.column_stack([x, y])\n                best_radii_total = lp_res.x\n\n    return best_centers_total, best_radii_total, best_sum_total\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:51:20.010905",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2954,
        "candidates_token_count": 2112,
        "thoughts_token_count": 16798
      },
      "response_text_len": 5942
    }
  },
  "llm_call_duration_s": 107.5896132880589,
  "eval_duration_s": 81.58256671600975
}