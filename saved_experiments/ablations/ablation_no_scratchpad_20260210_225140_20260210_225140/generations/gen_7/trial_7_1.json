{
  "trial_id": "trial_7_1",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid approach:\n    1. Force-directed simulation to find a promising layout.\n    2. SLSQP optimization to maximize a common radius (equal packing).\n    3. SLSQP optimization to maximize the sum of radii (allowing different sizes).\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def is_valid(pos, radii):\n        \"\"\"Checks if the packing is valid within a small tolerance.\"\"\"\n        if np.any(pos - radii[:, np.newaxis] < -1e-8): return False\n        if np.any(pos + radii[:, np.newaxis] > 1.0 + 1e-8): return False\n        i, j = np.triu_indices(N, k=1)\n        d2 = np.sum((pos[i] - pos[j])**2, axis=1)\n        r2 = (radii[i] + radii[j])**2\n        if np.any(d2 - r2 < -1e-8): return False\n        return True\n\n    def solve_equal(pos, r_val):\n        \"\"\"Phase 2: Maximize a common radius r for all circles.\"\"\"\n        x0 = np.concatenate([pos.flatten(), [r_val]])\n        \n        def objective(x):\n            return -x[-1]\n        \n        def jac_objective(x):\n            j = np.zeros(2*N + 1)\n            j[-1] = -1.0\n            return j\n\n        def constraints(x):\n            p = x[:2*N].reshape((N, 2))\n            r = x[-1]\n            # Boundary\n            c_b = np.zeros(4*N)\n            c_b[0::4] = p[:, 0] - r\n            c_b[1::4] = 1.0 - p[:, 0] - r\n            c_b[2::4] = p[:, 1] - r\n            c_b[3::4] = 1.0 - p[:, 1] - r\n            # Overlap\n            i, j = np.triu_indices(N, k=1)\n            d2 = np.sum((p[i] - p[j])**2, axis=1)\n            c_o = d2 - 4 * r**2\n            return np.concatenate([c_b, c_o])\n\n        def constraint_jac(x):\n            p = x[:2*N].reshape((N, 2))\n            r = x[2*N]\n            i, j = np.triu_indices(N, k=1)\n            num_o = len(i)\n            jac = np.zeros((4*N + num_o, 2*N + 1))\n            idx_n = np.arange(N)\n            jac[4*idx_n, 2*idx_n] = 1.0\n            jac[4*idx_n, 2*N] = -1.0\n            jac[4*idx_n+1, 2*idx_n] = -1.0\n            jac[4*idx_n+1, 2*N] = -1.0\n            jac[4*idx_n+2, 2*idx_n+1] = 1.0\n            jac[4*idx_n+2, 2*N] = -1.0\n            jac[4*idx_n+3, 2*idx_n+1] = -1.0\n            jac[4*idx_n+3, 2*N] = -1.0\n            idx_o = np.arange(4*N, 4*N + num_o)\n            dx, dy = p[i, 0] - p[j, 0], p[i, 1] - p[j, 1]\n            jac[idx_o, 2*i] = 2*dx\n            jac[idx_o, 2*j] = -2*dx\n            jac[idx_o, 2*i+1] = 2*dy\n            jac[idx_o, 2*j+1] = -2*dy\n            jac[idx_o, 2*N] = -8*r\n            return jac\n\n        res = minimize(objective, x0, method='SLSQP', jac=jac_objective,\n                       constraints=[{'type': 'ineq', 'fun': constraints, 'jac': constraint_jac}],\n                       bounds=[(0, 1)] * (2*N) + [(0, 0.5)], options={'maxiter': 300})\n        return res.x[:2*N].reshape((N, 2)), res.x[-1]\n\n    def solve_sum(pos, r_start):\n        \"\"\"Phase 3: Maximize the sum of radii starting from the equal-radius layout.\"\"\"\n        if np.isscalar(r_start):\n            r_start = np.ones(N) * r_start\n        x0 = np.concatenate([pos.flatten(), r_start])\n        \n        def objective(x):\n            return -np.sum(x[2*N:])\n        \n        def jac_objective(x):\n            j = np.zeros(3*N)\n            j[2*N:] = -1.0\n            return j\n\n        def constraints(x):\n            p = x[:2*N].reshape((N, 2))\n            r = x[2*N:]\n            c_b = np.zeros(4*N)\n            c_b[0::4] = p[:, 0] - r\n            c_b[1::4] = 1.0 - p[:, 0] - r\n            c_b[2::4] = p[:, 1] - r\n            c_b[3::4] = 1.0 - p[:, 1] - r\n            i, j = np.triu_indices(N, k=1)\n            d2 = np.sum((p[i] - p[j])**2, axis=1)\n            c_o = d2 - (r[i] + r[j])**2\n            return np.concatenate([c_b, c_o])\n\n        def constraint_jac(x):\n            p = x[:2*N].reshape((N, 2))\n            r = x[2*N:]\n            i, j = np.triu_indices(N, k=1)\n            num_o = len(i)\n            jac = np.zeros((4*N + num_o, 3*N))\n            idx_n = np.arange(N)\n            jac[4*idx_n, 2*idx_n] = 1.0\n            jac[4*idx_n, 2*N+idx_n] = -1.0\n            jac[4*idx_n+1, 2*idx_n] = -1.0\n            jac[4*idx_n+1, 2*N+idx_n] = -1.0\n            jac[4*idx_n+2, 2*idx_n+1] = 1.0\n            jac[4*idx_n+2, 2*N+idx_n] = -1.0\n            jac[4*idx_n+3, 2*idx_n+1] = -1.0\n            jac[4*idx_n+3, 2*N+idx_n] = -1.0\n            idx_o = np.arange(4*N, 4*N + num_o)\n            dx, dy = p[i, 0] - p[j, 0], p[i, 1] - p[j, 1]\n            dr = r[i] + r[j]\n            jac[idx_o, 2*i] = 2*dx\n            jac[idx_o, 2*j] = -2*dx\n            jac[idx_o, 2*i+1] = 2*dy\n            jac[idx_o, 2*j+1] = -2*dy\n            jac[idx_o, 2*N+i] = -2*dr\n            jac[idx_o, 2*N+j] = -2*dr\n            return jac\n\n        res = minimize(objective, x0, method='SLSQP', jac=jac_objective,\n                       constraints=[{'type': 'ineq', 'fun': constraints, 'jac': constraint_jac}],\n                       bounds=[(0, 1)] * (2*N) + [(0, 0.5)] * N, options={'maxiter': 500})\n        return res.x[:2*N].reshape((N, 2)), res.x[2*N:], -res.fun\n\n    # Fallback initialization\n    best_sum = 26 * 0.05\n    best_pos = (np.random.rand(N, 2) * 0.8 + 0.1)\n    best_radii = np.ones(N) * 0.05\n\n    # Main multi-start optimization loop\n    while time.time() - start_time < 260:\n        # Phase 1: Force-directed simulation to find a good layout\n        pos = np.random.rand(N, 2) * 0.7 + 0.15\n        r_current = 0.085\n        dt = 0.05\n        for _ in range(1000):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, 10)\n            overlap = 2 * r_current - dist\n            forces = np.sum(np.maximum(0, overlap)[:, :, np.newaxis] * (diff / (dist[:, :, np.newaxis] + 1e-9)), axis=1)\n            pos += forces * dt\n            r_current += 0.000016\n            pos = np.clip(pos, r_current, 1.0 - r_current)\n            dt *= 0.998\n        \n        # Phase 2 & 3: Refine with SLSQP\n        try:\n            p_eq, r_eq = solve_equal(pos, r_current)\n            p_sum, r_sum, s_sum = solve_sum(p_eq, r_eq)\n            \n            if is_valid(p_sum, r_sum):\n                if s_sum > best_sum:\n                    best_sum, best_pos, best_radii = s_sum, p_sum, r_sum\n            elif is_valid(p_eq, np.ones(N) * r_eq):\n                s_eq = N * r_eq\n                if s_eq > best_sum:\n                    best_sum, best_pos, best_radii = s_eq, p_eq, np.ones(N) * r_eq\n        except:\n            continue\n            \n    return best_pos, best_radii, float(best_sum)",
  "metrics": {
    "valid": true,
    "score": 2.6307003065807564,
    "eval_time": 260.95898175239563,
    "error": null
  },
  "prompt": "\nImplement a hybrid approach for packing 26 circles in a unit square:\n1. Phase 1: Use a force-directed (physics) simulation where circles exert repulsive forces on each other and are contained by the square walls. Gradually increase 'pressure' (radii) while the simulation runs.\n2. Phase 2: Take the resulting configuration and use it as the starting point for a high-precision SLSQP optimization.\n3. Aim for a total sum of radii > 2.635.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid approach:\n    1. Force-directed simulation to find a promising layout.\n    2. SLSQP optimization to maximize a common radius (equal packing).\n    3. SLSQP optimization to maximize the sum of radii (allowing different sizes).\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def is_valid(pos, radii):\n        \"\"\"Checks if the packing is valid within a small tolerance.\"\"\"\n        if np.any(pos - radii[:, np.newaxis] < -1e-8): return False\n        if np.any(pos + radii[:, np.newaxis] > 1.0 + 1e-8): return False\n        i, j = np.triu_indices(N, k=1)\n        d2 = np.sum((pos[i] - pos[j])**2, axis=1)\n        r2 = (radii[i] + radii[j])**2\n        if np.any(d2 - r2 < -1e-8): return False\n        return True\n\n    def solve_equal(pos, r_val):\n        \"\"\"Phase 2: Maximize a common radius r for all circles.\"\"\"\n        x0 = np.concatenate([pos.flatten(), [r_val]])\n        \n        def objective(x):\n            return -x[-1]\n        \n        def jac_objective(x):\n            j = np.zeros(2*N + 1)\n            j[-1] = -1.0\n            return j\n\n        def constraints(x):\n            p = x[:2*N].reshape((N, 2))\n            r = x[-1]\n            # Boundary\n            c_b = np.zeros(4*N)\n            c_b[0::4] = p[:, 0] - r\n            c_b[1::4] = 1.0 - p[:, 0] - r\n            c_b[2::4] = p[:, 1] - r\n            c_b[3::4] = 1.0 - p[:, 1] - r\n            # Overlap\n            i, j = np.triu_indices(N, k=1)\n            d2 = np.sum((p[i] - p[j])**2, axis=1)\n            c_o = d2 - 4 * r**2\n            return np.concatenate([c_b, c_o])\n\n        def constraint_jac(x):\n            p = x[:2*N].reshape((N, 2))\n            r = x[2*N]\n            i, j = np.triu_indices(N, k=1)\n            num_o = len(i)\n            jac = np.zeros((4*N + num_o, 2*N + 1))\n            idx_n = np.arange(N)\n            jac[4*idx_n, 2*idx_n] = 1.0\n            jac[4*idx_n, 2*N] = -1.0\n            jac[4*idx_n+1, 2*idx_n] = -1.0\n            jac[4*idx_n+1, 2*N] = -1.0\n            jac[4*idx_n+2, 2*idx_n+1] = 1.0\n            jac[4*idx_n+2, 2*N] = -1.0\n            jac[4*idx_n+3, 2*idx_n+1] = -1.0\n            jac[4*idx_n+3, 2*N] = -1.0\n            idx_o = np.arange(4*N, 4*N + num_o)\n            dx, dy = p[i, 0] - p[j, 0], p[i, 1] - p[j, 1]\n            jac[idx_o, 2*i] = 2*dx\n            jac[idx_o, 2*j] = -2*dx\n            jac[idx_o, 2*i+1] = 2*dy\n            jac[idx_o, 2*j+1] = -2*dy\n            jac[idx_o, 2*N] = -8*r\n            return jac\n\n        res = minimize(objective, x0, method='SLSQP', jac=jac_objective,\n                       constraints=[{'type': 'ineq', 'fun': constraints, 'jac': constraint_jac}],\n                       bounds=[(0, 1)] * (2*N) + [(0, 0.5)], options={'maxiter': 300})\n        return res.x[:2*N].reshape((N, 2)), res.x[-1]\n\n    def solve_sum(pos, r_start):\n        \"\"\"Phase 3: Maximize the sum of radii starting from the equal-radius layout.\"\"\"\n        if np.isscalar(r_start):\n            r_start = np.ones(N) * r_start\n        x0 = np.concatenate([pos.flatten(), r_start])\n        \n        def objective(x):\n            return -np.sum(x[2*N:])\n        \n        def jac_objective(x):\n            j = np.zeros(3*N)\n            j[2*N:] = -1.0\n            return j\n\n        def constraints(x):\n            p = x[:2*N].reshape((N, 2))\n            r = x[2*N:]\n            c_b = np.zeros(4*N)\n            c_b[0::4] = p[:, 0] - r\n            c_b[1::4] = 1.0 - p[:, 0] - r\n            c_b[2::4] = p[:, 1] - r\n            c_b[3::4] = 1.0 - p[:, 1] - r\n            i, j = np.triu_indices(N, k=1)\n            d2 = np.sum((p[i] - p[j])**2, axis=1)\n            c_o = d2 - (r[i] + r[j])**2\n            return np.concatenate([c_b, c_o])\n\n        def constraint_jac(x):\n            p = x[:2*N].reshape((N, 2))\n            r = x[2*N:]\n            i, j = np.triu_indices(N, k=1)\n            num_o = len(i)\n            jac = np.zeros((4*N + num_o, 3*N))\n            idx_n = np.arange(N)\n            jac[4*idx_n, 2*idx_n] = 1.0\n            jac[4*idx_n, 2*N+idx_n] = -1.0\n            jac[4*idx_n+1, 2*idx_n] = -1.0\n            jac[4*idx_n+1, 2*N+idx_n] = -1.0\n            jac[4*idx_n+2, 2*idx_n+1] = 1.0\n            jac[4*idx_n+2, 2*N+idx_n] = -1.0\n            jac[4*idx_n+3, 2*idx_n+1] = -1.0\n            jac[4*idx_n+3, 2*N+idx_n] = -1.0\n            idx_o = np.arange(4*N, 4*N + num_o)\n            dx, dy = p[i, 0] - p[j, 0], p[i, 1] - p[j, 1]\n            dr = r[i] + r[j]\n            jac[idx_o, 2*i] = 2*dx\n            jac[idx_o, 2*j] = -2*dx\n            jac[idx_o, 2*i+1] = 2*dy\n            jac[idx_o, 2*j+1] = -2*dy\n            jac[idx_o, 2*N+i] = -2*dr\n            jac[idx_o, 2*N+j] = -2*dr\n            return jac\n\n        res = minimize(objective, x0, method='SLSQP', jac=jac_objective,\n                       constraints=[{'type': 'ineq', 'fun': constraints, 'jac': constraint_jac}],\n                       bounds=[(0, 1)] * (2*N) + [(0, 0.5)] * N, options={'maxiter': 500})\n        return res.x[:2*N].reshape((N, 2)), res.x[2*N:], -res.fun\n\n    # Fallback initialization\n    best_sum = 26 * 0.05\n    best_pos = (np.random.rand(N, 2) * 0.8 + 0.1)\n    best_radii = np.ones(N) * 0.05\n\n    # Main multi-start optimization loop\n    while time.time() - start_time < 260:\n        # Phase 1: Force-directed simulation to find a good layout\n        pos = np.random.rand(N, 2) * 0.7 + 0.15\n        r_current = 0.085\n        dt = 0.05\n        for _ in range(1000):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, 10)\n            overlap = 2 * r_current - dist\n            forces = np.sum(np.maximum(0, overlap)[:, :, np.newaxis] * (diff / (dist[:, :, np.newaxis] + 1e-9)), axis=1)\n            pos += forces * dt\n            r_current += 0.000016\n            pos = np.clip(pos, r_current, 1.0 - r_current)\n            dt *= 0.998\n        \n        # Phase 2 & 3: Refine with SLSQP\n        try:\n            p_eq, r_eq = solve_equal(pos, r_current)\n            p_sum, r_sum, s_sum = solve_sum(p_eq, r_eq)\n            \n            if is_valid(p_sum, r_sum):\n                if s_sum > best_sum:\n                    best_sum, best_pos, best_radii = s_sum, p_sum, r_sum\n            elif is_valid(p_eq, np.ones(N) * r_eq):\n                s_eq = N * r_eq\n                if s_eq > best_sum:\n                    best_sum, best_pos, best_radii = s_eq, p_eq, np.ones(N) * r_eq\n        except:\n            continue\n            \n    return best_pos, best_radii, float(best_sum)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:55:18.330795",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 336,
        "candidates_token_count": 2687,
        "thoughts_token_count": 27589
      },
      "response_text_len": 6685
    }
  },
  "llm_call_duration_s": 166.5352684969548,
  "eval_duration_s": 260.95899093989283
}