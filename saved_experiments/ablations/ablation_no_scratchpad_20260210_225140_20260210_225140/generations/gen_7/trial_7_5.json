{
  "trial_id": "trial_7_5",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Uses a Successive Linear Programming (SLP) approach to iteratively \n    approximate the non-overlap constraints and grow the radii.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Mix of grid-based and random starts to find a good local optimum\n    num_starts = 150\n    for start_idx in range(num_starts):\n        # Time limit management\n        if time.time() - start_time > 280:\n            break\n            \n        if start_idx == 0:\n            # Grid-based starting configuration\n            grid_size = 5\n            gx, gy = np.meshgrid(np.linspace(0.1, 0.9, grid_size), np.linspace(0.1, 0.9, grid_size))\n            x = np.append(gx.flatten(), 0.5)\n            y = np.append(gy.flatten(), 0.5)\n            # Add small noise to break symmetry\n            x += np.random.uniform(-0.02, 0.02, n)\n            y += np.random.uniform(-0.02, 0.02, n)\n        else:\n            # Random starting configuration\n            x = np.random.uniform(0.05, 0.95, n)\n            y = np.random.uniform(0.05, 0.95, n)\n            \n        r = np.zeros(n)\n        delta = 0.05  # Trust region radius\n        \n        # SLP iterations\n        for it in range(100):\n            # Objective: Maximize sum(r_i + dr_i) -> Minimize -sum(dr_i)\n            # Variables: [dx0, dy0, dr0, ..., dx_n-1, dy_n-1, dr_n-1]\n            c = np.zeros(3 * n)\n            c[2::3] = -1.0\n            \n            num_non_overlap = n * (n - 1) // 2\n            num_constraints = 4 * n + num_non_overlap\n            A_ub = np.zeros((num_constraints, 3 * n))\n            b_ub = np.zeros(num_constraints)\n            \n            # Boundary constraints: circles must stay inside [0, 1] x [0, 1]\n            # (x + dx) + (r + dr) <= 1  =>  dx + dr <= 1 - x - r\n            # (x + dx) - (r + dr) >= 0  => -dx + dr <= x - r\n            # (y + dy) + (r + dr) <= 1  =>  dy + dr <= 1 - y - r\n            # (y + dy) - (r + dr) >= 0  => -dy + dr <= y - r\n            for i in range(n):\n                A_ub[4 * i, 3 * i] = 1.0\n                A_ub[4 * i, 3 * i + 2] = 1.0\n                b_ub[4 * i] = 1.0 - x[i] - r[i]\n                \n                A_ub[4 * i + 1, 3 * i] = -1.0\n                A_ub[4 * i + 1, 3 * i + 2] = 1.0\n                b_ub[4 * i + 1] = x[i] - r[i]\n                \n                A_ub[4 * i + 2, 3 * i + 1] = 1.0\n                A_ub[4 * i + 2, 3 * i + 2] = 1.0\n                b_ub[4 * i + 2] = 1.0 - y[i] - r[i]\n                \n                A_ub[4 * i + 3, 3 * i + 1] = -1.0\n                A_ub[4 * i + 3, 3 * i + 2] = 1.0\n                b_ub[4 * i + 3] = y[i] - r[i]\n            \n            # Non-overlap constraints: linearized distance >= sum of radii\n            # d_ij + grad_d * [dx_i - dx_j, dy_i - dy_j] >= r_i + dr_i + r_j + dr_j\n            idx = 4 * n\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_val = x[i] - x[j]\n                    dy_val = y[i] - y[j]\n                    d_ij = np.sqrt(dx_val**2 + dy_val**2)\n                    \n                    # Handle overlapping centers with a small epsilon and directional push\n                    if d_ij < 1e-8:\n                        dx_val = 1e-8 * np.cos(i)\n                        dy_val = 1e-8 * np.sin(i)\n                        d_ij = 1e-8\n                    \n                    # Linearized non-overlap constraint rearrangement:\n                    # dr_i + dr_j - (dx_val/d_ij)*dx_i + (dx_val/d_ij)*dx_j - (dy_val/d_ij)*dy_i + (dy_val/d_ij)*dy_j <= d_ij - r_i - r_j\n                    A_ub[idx, 3 * i] = -dx_val / d_ij\n                    A_ub[idx, 3 * i + 1] = -dy_val / d_ij\n                    A_ub[idx, 3 * i + 2] = 1.0\n                    A_ub[idx, 3 * j] = dx_val / d_ij\n                    A_ub[idx, 3 * j + 1] = dy_val / d_ij\n                    A_ub[idx, 3 * j + 2] = 1.0\n                    b_ub[idx] = d_ij - r[i] - r[j]\n                    idx += 1\n            \n            # Trust region bounds and non-negativity for radii\n            bounds = []\n            for i in range(n):\n                bounds.append((-delta, delta)) # dx\n                bounds.append((-delta, delta)) # dy\n                bounds.append((-r[i], delta)) # dr (ensures r_new >= 0)\n            \n            # Solve LP to find optimal step\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            \n            if res.success:\n                step = res.x\n                x += step[0::3]\n                y += step[1::3]\n                r += step[2::3]\n                \n                # If the improvement is negligible, shrink the trust region\n                if np.sum(step[2::3]) < 1e-7:\n                    delta *= 0.5\n            else:\n                # If LP fails (should not happen for valid trust regions), abort start\n                break\n            \n            # Convergence check\n            if delta < 1e-6:\n                break\n        \n        # Update best solution found across all starts\n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = np.stack([x, y], axis=1)\n            best_radii = r.copy()\n            \n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.6205202814289796,
    "eval_time": 38.93636989593506,
    "error": null
  },
  "prompt": "\nImplement a Successive Linear Programming (SLP) or Sequential Quadratic Programming (SQP) approach specifically tailored for circle packing.\nApproximate the non-overlap constraints linearly at each step and solve the resulting LP to find a search direction.\nThis can be more efficient than general-purpose SLSQP for this specific geometry.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Uses a Successive Linear Programming (SLP) approach to iteratively \n    approximate the non-overlap constraints and grow the radii.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Mix of grid-based and random starts to find a good local optimum\n    num_starts = 150\n    for start_idx in range(num_starts):\n        # Time limit management\n        if time.time() - start_time > 280:\n            break\n            \n        if start_idx == 0:\n            # Grid-based starting configuration\n            grid_size = 5\n            gx, gy = np.meshgrid(np.linspace(0.1, 0.9, grid_size), np.linspace(0.1, 0.9, grid_size))\n            x = np.append(gx.flatten(), 0.5)\n            y = np.append(gy.flatten(), 0.5)\n            # Add small noise to break symmetry\n            x += np.random.uniform(-0.02, 0.02, n)\n            y += np.random.uniform(-0.02, 0.02, n)\n        else:\n            # Random starting configuration\n            x = np.random.uniform(0.05, 0.95, n)\n            y = np.random.uniform(0.05, 0.95, n)\n            \n        r = np.zeros(n)\n        delta = 0.05  # Trust region radius\n        \n        # SLP iterations\n        for it in range(100):\n            # Objective: Maximize sum(r_i + dr_i) -> Minimize -sum(dr_i)\n            # Variables: [dx0, dy0, dr0, ..., dx_n-1, dy_n-1, dr_n-1]\n            c = np.zeros(3 * n)\n            c[2::3] = -1.0\n            \n            num_non_overlap = n * (n - 1) // 2\n            num_constraints = 4 * n + num_non_overlap\n            A_ub = np.zeros((num_constraints, 3 * n))\n            b_ub = np.zeros(num_constraints)\n            \n            # Boundary constraints: circles must stay inside [0, 1] x [0, 1]\n            # (x + dx) + (r + dr) <= 1  =>  dx + dr <= 1 - x - r\n            # (x + dx) - (r + dr) >= 0  => -dx + dr <= x - r\n            # (y + dy) + (r + dr) <= 1  =>  dy + dr <= 1 - y - r\n            # (y + dy) - (r + dr) >= 0  => -dy + dr <= y - r\n            for i in range(n):\n                A_ub[4 * i, 3 * i] = 1.0\n                A_ub[4 * i, 3 * i + 2] = 1.0\n                b_ub[4 * i] = 1.0 - x[i] - r[i]\n                \n                A_ub[4 * i + 1, 3 * i] = -1.0\n                A_ub[4 * i + 1, 3 * i + 2] = 1.0\n                b_ub[4 * i + 1] = x[i] - r[i]\n                \n                A_ub[4 * i + 2, 3 * i + 1] = 1.0\n                A_ub[4 * i + 2, 3 * i + 2] = 1.0\n                b_ub[4 * i + 2] = 1.0 - y[i] - r[i]\n                \n                A_ub[4 * i + 3, 3 * i + 1] = -1.0\n                A_ub[4 * i + 3, 3 * i + 2] = 1.0\n                b_ub[4 * i + 3] = y[i] - r[i]\n            \n            # Non-overlap constraints: linearized distance >= sum of radii\n            # d_ij + grad_d * [dx_i - dx_j, dy_i - dy_j] >= r_i + dr_i + r_j + dr_j\n            idx = 4 * n\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_val = x[i] - x[j]\n                    dy_val = y[i] - y[j]\n                    d_ij = np.sqrt(dx_val**2 + dy_val**2)\n                    \n                    # Handle overlapping centers with a small epsilon and directional push\n                    if d_ij < 1e-8:\n                        dx_val = 1e-8 * np.cos(i)\n                        dy_val = 1e-8 * np.sin(i)\n                        d_ij = 1e-8\n                    \n                    # Linearized non-overlap constraint rearrangement:\n                    # dr_i + dr_j - (dx_val/d_ij)*dx_i + (dx_val/d_ij)*dx_j - (dy_val/d_ij)*dy_i + (dy_val/d_ij)*dy_j <= d_ij - r_i - r_j\n                    A_ub[idx, 3 * i] = -dx_val / d_ij\n                    A_ub[idx, 3 * i + 1] = -dy_val / d_ij\n                    A_ub[idx, 3 * i + 2] = 1.0\n                    A_ub[idx, 3 * j] = dx_val / d_ij\n                    A_ub[idx, 3 * j + 1] = dy_val / d_ij\n                    A_ub[idx, 3 * j + 2] = 1.0\n                    b_ub[idx] = d_ij - r[i] - r[j]\n                    idx += 1\n            \n            # Trust region bounds and non-negativity for radii\n            bounds = []\n            for i in range(n):\n                bounds.append((-delta, delta)) # dx\n                bounds.append((-delta, delta)) # dy\n                bounds.append((-r[i], delta)) # dr (ensures r_new >= 0)\n            \n            # Solve LP to find optimal step\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            \n            if res.success:\n                step = res.x\n                x += step[0::3]\n                y += step[1::3]\n                r += step[2::3]\n                \n                # If the improvement is negligible, shrink the trust region\n                if np.sum(step[2::3]) < 1e-7:\n                    delta *= 0.5\n            else:\n                # If LP fails (should not happen for valid trust regions), abort start\n                break\n            \n            # Convergence check\n            if delta < 1e-6:\n                break\n        \n        # Update best solution found across all starts\n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = np.stack([x, y], axis=1)\n            best_radii = r.copy()\n            \n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:50:47.940962",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 295,
        "candidates_token_count": 1869,
        "thoughts_token_count": 19579
      },
      "response_text_len": 5463
    }
  },
  "llm_call_duration_s": 118.18038319493644,
  "eval_duration_s": 38.936379991006106
}