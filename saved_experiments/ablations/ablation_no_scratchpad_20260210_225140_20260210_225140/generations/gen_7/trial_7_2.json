{
  "trial_id": "trial_7_2",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a simplified CMA-ES algorithm to optimize circle centers and Linear Programming \n    to determine the optimal radii for those centers.\n    \"\"\"\n    n_circles = 26\n    n_constraints = n_circles * (n_circles - 1) // 2\n    \n    # Pre-allocate the constraint matrix for the Linear Programming solver\n    # Each row represents a constraint r_i + r_j <= distance(c_i, c_j)\n    A_ub_global = np.zeros((n_constraints, n_circles))\n    k = 0\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            A_ub_global[k, i] = 1\n            A_ub_global[k, j] = 1\n            k += 1\n\n    def get_radii_and_sum(centers):\n        \"\"\"\n        For a given set of centers, solves a Linear Program to find the radii\n        that maximize the sum of radii subject to boundary and overlap constraints.\n        \"\"\"\n        # Objective: maximize sum(r_i) -> minimize -sum(r_i)\n        c = -np.ones(n_circles)\n        \n        # Boundary constraints: r_i <= distance to nearest edge\n        # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        b_boundary = np.min(np.hstack([centers, 1 - centers]), axis=1)\n        # Ensure bounds are strictly positive for the solver\n        b_boundary = np.maximum(b_boundary, 1e-10)\n        \n        # Overlap constraints: r_i + r_j <= distance between center i and center j\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n        b_ub = np.zeros(n_constraints)\n        k = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                b_ub[k] = dist_matrix[i, j]\n                k += 1\n        \n        # Solve the LP using the HiGHS solver (fast and robust)\n        res = linprog(c, A_ub=A_ub_global, b_ub=b_ub, \n                      bounds=[(0, b) for b in b_boundary], method='highs')\n        \n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n_circles), 0.0\n\n    # Initialization: Start with a 5x5 grid and add one extra circle\n    # Grid centers: [0.1, 0.3, 0.5, 0.7, 0.9]\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(grid_coords, grid_coords)\n    initial_centers = np.vstack([xv.ravel(), yv.ravel()]).T\n    # Add a 26th circle near the center\n    initial_centers = np.vstack([initial_centers, [0.48, 0.48]])\n    \n    # Add small random jitter to break symmetry\n    initial_centers += np.random.normal(0, 0.01, initial_centers.shape)\n    initial_centers = np.clip(initial_centers, 0, 1)\n    \n    # CMA-ES Parameters\n    mean = initial_centers.ravel()\n    n_params = len(mean)\n    popsize = 24  # Population size\n    mu = popsize // 2  # Number of parents\n    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n    weights /= np.sum(weights)\n    \n    sigma = 0.03 # Initial step size\n    C = np.eye(n_params) # Initial covariance matrix\n    \n    best_overall_sum = 0.0\n    best_overall_centers = initial_centers.copy()\n    best_overall_radii = np.zeros(n_circles)\n    \n    # Optimization Loop\n    max_iterations = 180\n    for it in range(max_iterations):\n        # Sample new center configurations from the current distribution\n        try:\n            samples = np.random.multivariate_normal(mean, sigma**2 * C, popsize)\n        except np.linalg.LinAlgError:\n            # If C becomes non-positive definite, reset it\n            C = np.eye(n_params)\n            samples = np.random.multivariate_normal(mean, sigma**2 * C, popsize)\n        \n        fitness = []\n        for s in samples:\n            # Clip centers to ensure they stay within the unit square [0, 1]\n            s_centers = np.clip(s.reshape(n_circles, 2), 0, 1)\n            radii, sum_r = get_radii_and_sum(s_centers)\n            fitness.append(-sum_r) # Minimize -sum_r\n            \n            if sum_r > best_overall_sum:\n                best_overall_sum = sum_r\n                best_overall_centers = s_centers\n                best_overall_radii = radii\n        \n        # Sort population by fitness and select the best mu individuals\n        indices = np.argsort(fitness)\n        best_samples = samples[indices[:mu]]\n        \n        # Update the mean of the distribution\n        old_mean = mean\n        mean = weights @ best_samples\n        \n        # Update the covariance matrix (simplified CMA update)\n        diff = (best_samples - old_mean) / sigma\n        C_new = diff.T @ np.diag(weights) @ diff\n        C = 0.8 * C + 0.2 * C_new\n        \n        # Enforce symmetry and regularize the covariance matrix periodically\n        if it % 10 == 0:\n            C = (C + C.T) / 2\n            vals, vecs = np.linalg.eigh(C)\n            vals = np.maximum(vals, 1e-8)\n            C = vecs @ np.diag(vals) @ vecs.T\n\n    return best_overall_centers, best_overall_radii, best_overall_sum",
  "metrics": {
    "valid": true,
    "score": 2.466509350365949,
    "eval_time": 123.90806341171265,
    "error": null
  },
  "prompt": "\nUse the CMA-ES algorithm (from scipy or a simple implementation) to optimize the centers of 26 circles.\n1. The objective function should be the sum of radii.\n2. For a given set of centers, the radii should be calculated as the maximum possible without overlap or boundary violation.\n3. Use a large population size and a good initial sigma.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a simplified CMA-ES algorithm to optimize circle centers and Linear Programming \n    to determine the optimal radii for those centers.\n    \"\"\"\n    n_circles = 26\n    n_constraints = n_circles * (n_circles - 1) // 2\n    \n    # Pre-allocate the constraint matrix for the Linear Programming solver\n    # Each row represents a constraint r_i + r_j <= distance(c_i, c_j)\n    A_ub_global = np.zeros((n_constraints, n_circles))\n    k = 0\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            A_ub_global[k, i] = 1\n            A_ub_global[k, j] = 1\n            k += 1\n\n    def get_radii_and_sum(centers):\n        \"\"\"\n        For a given set of centers, solves a Linear Program to find the radii\n        that maximize the sum of radii subject to boundary and overlap constraints.\n        \"\"\"\n        # Objective: maximize sum(r_i) -> minimize -sum(r_i)\n        c = -np.ones(n_circles)\n        \n        # Boundary constraints: r_i <= distance to nearest edge\n        # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        b_boundary = np.min(np.hstack([centers, 1 - centers]), axis=1)\n        # Ensure bounds are strictly positive for the solver\n        b_boundary = np.maximum(b_boundary, 1e-10)\n        \n        # Overlap constraints: r_i + r_j <= distance between center i and center j\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n        b_ub = np.zeros(n_constraints)\n        k = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                b_ub[k] = dist_matrix[i, j]\n                k += 1\n        \n        # Solve the LP using the HiGHS solver (fast and robust)\n        res = linprog(c, A_ub=A_ub_global, b_ub=b_ub, \n                      bounds=[(0, b) for b in b_boundary], method='highs')\n        \n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n_circles), 0.0\n\n    # Initialization: Start with a 5x5 grid and add one extra circle\n    # Grid centers: [0.1, 0.3, 0.5, 0.7, 0.9]\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(grid_coords, grid_coords)\n    initial_centers = np.vstack([xv.ravel(), yv.ravel()]).T\n    # Add a 26th circle near the center\n    initial_centers = np.vstack([initial_centers, [0.48, 0.48]])\n    \n    # Add small random jitter to break symmetry\n    initial_centers += np.random.normal(0, 0.01, initial_centers.shape)\n    initial_centers = np.clip(initial_centers, 0, 1)\n    \n    # CMA-ES Parameters\n    mean = initial_centers.ravel()\n    n_params = len(mean)\n    popsize = 24  # Population size\n    mu = popsize // 2  # Number of parents\n    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n    weights /= np.sum(weights)\n    \n    sigma = 0.03 # Initial step size\n    C = np.eye(n_params) # Initial covariance matrix\n    \n    best_overall_sum = 0.0\n    best_overall_centers = initial_centers.copy()\n    best_overall_radii = np.zeros(n_circles)\n    \n    # Optimization Loop\n    max_iterations = 180\n    for it in range(max_iterations):\n        # Sample new center configurations from the current distribution\n        try:\n            samples = np.random.multivariate_normal(mean, sigma**2 * C, popsize)\n        except np.linalg.LinAlgError:\n            # If C becomes non-positive definite, reset it\n            C = np.eye(n_params)\n            samples = np.random.multivariate_normal(mean, sigma**2 * C, popsize)\n        \n        fitness = []\n        for s in samples:\n            # Clip centers to ensure they stay within the unit square [0, 1]\n            s_centers = np.clip(s.reshape(n_circles, 2), 0, 1)\n            radii, sum_r = get_radii_and_sum(s_centers)\n            fitness.append(-sum_r) # Minimize -sum_r\n            \n            if sum_r > best_overall_sum:\n                best_overall_sum = sum_r\n                best_overall_centers = s_centers\n                best_overall_radii = radii\n        \n        # Sort population by fitness and select the best mu individuals\n        indices = np.argsort(fitness)\n        best_samples = samples[indices[:mu]]\n        \n        # Update the mean of the distribution\n        old_mean = mean\n        mean = weights @ best_samples\n        \n        # Update the covariance matrix (simplified CMA update)\n        diff = (best_samples - old_mean) / sigma\n        C_new = diff.T @ np.diag(weights) @ diff\n        C = 0.8 * C + 0.2 * C_new\n        \n        # Enforce symmetry and regularize the covariance matrix periodically\n        if it % 10 == 0:\n            C = (C + C.T) / 2\n            vals, vecs = np.linalg.eigh(C)\n            vals = np.maximum(vals, 1e-8)\n            C = vecs @ np.diag(vals) @ vecs.T\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:52:04.659982",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 306,
        "candidates_token_count": 1583,
        "thoughts_token_count": 16796
      },
      "response_text_len": 4973
    }
  },
  "llm_call_duration_s": 109.92012930603232,
  "eval_duration_s": 123.9080724439118
}