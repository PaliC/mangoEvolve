{
  "trial_id": "trial_1_2",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of force-directed initialization and SLSQP optimization.\n    \"\"\"\n    n = 26\n    triu_idx = np.triu_indices(n, k=1)\n\n    def objective(v):\n        # Minimize the negative sum of radii to maximize the sum\n        return -np.sum(v[2*n:])\n\n    def constraint_overlap(v):\n        # Non-overlap constraint: (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        x = v[:n]\n        y = v[n:2*n]\n        r = v[2*n:]\n        dx = x[triu_idx[0]] - x[triu_idx[1]]\n        dy = y[triu_idx[0]] - y[triu_idx[1]]\n        dr = r[triu_idx[0]] + r[triu_idx[1]]\n        return dx**2 + dy**2 - dr**2\n\n    def constraint_boundary(v):\n        # Boundary constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        x = v[:n]\n        y = v[n:2*n]\n        r = v[2*n:]\n        return np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n\n    cons = [\n        {'type': 'ineq', 'fun': constraint_overlap},\n        {'type': 'ineq', 'fun': constraint_boundary}\n    ]\n    \n    # Boundary constraints for the optimizer: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    best_sum = 0\n    best_v = None\n    \n    start_time = time.time()\n    \n    # Initial trial: A slightly perturbed grid-based start\n    x_grid = np.linspace(0.12, 0.88, 5)\n    y_grid = np.linspace(0.12, 0.88, 5)\n    X, Y = np.meshgrid(x_grid, y_grid)\n    x_init = np.concatenate([X.flatten(), [0.5]])\n    y_init = np.concatenate([Y.flatten(), [0.5]])\n    r_init = np.ones(n) * 0.09\n    vars0 = np.concatenate([x_init, y_init, r_init])\n    \n    res = minimize(objective, vars0, method='SLSQP', constraints=cons, bounds=bounds, \n                   options={'maxiter': 200, 'ftol': 1e-8, 'disp': False})\n    \n    if -res.fun > best_sum:\n        best_sum = -res.fun\n        best_v = res.x\n\n    # Subsequent trials: Random starts refined by a force-directed simulation\n    while time.time() - start_time < 260: # Limit to 260 seconds to allow for final processing\n        r_target = 0.10138  # Target radius based on best known packing for n=26\n        pos = np.random.rand(n, 2)\n        dt = 0.015\n        \n        # Physics simulation: push overlapping circles apart and away from boundaries\n        for _ in range(350):\n            dx = pos[:, 0][:, np.newaxis] - pos[:, 0][np.newaxis, :]\n            dy = pos[:, 1][:, np.newaxis] - pos[:, 1][np.newaxis, :]\n            dist = np.sqrt(dx**2 + dy**2) + 1e-9\n            overlap = (2 * r_target) - dist\n            mask = (overlap > 0)\n            np.fill_diagonal(mask, False)\n            f_mag = overlap * mask\n            fx = np.sum(f_mag * (dx / dist), axis=1)\n            fy = np.sum(f_mag * (dy / dist), axis=1)\n            pos[:, 0] += fx * dt\n            pos[:, 1] += fy * dt\n            # Keep centers within the boundary limits for the target radius\n            pos[:, 0] = np.clip(pos[:, 0], r_target, 1 - r_target)\n            pos[:, 1] = np.clip(pos[:, 1], r_target, 1 - r_target)\n        \n        vars0 = np.concatenate([pos[:, 0], pos[:, 1], np.ones(n) * r_target])\n        res = minimize(objective, vars0, method='SLSQP', constraints=cons, bounds=bounds, \n                       options={'maxiter': 150, 'ftol': 1e-7, 'disp': False})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n    \n    # Final extraction of centers and radii\n    v = best_v\n    centers = np.vstack([v[:n], v[n:2*n]]).T\n    radii = v[2*n:]\n    \n    # Validity Post-Processing: Ensure all constraints are strictly met\n    for i in range(n):\n        # Enforce boundary constraints\n        radii[i] = max(0, min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1]))\n    \n    # Enforce non-overlap constraints by shrinking radii if necessary\n    for _ in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                if dist < radii[i] + radii[j]:\n                    overlap = (radii[i] + radii[j]) - dist\n                    # Shrink radii to resolve overlap exactly\n                    radii[i] -= overlap * 0.5000000001\n                    radii[j] -= overlap * 0.5000000001\n                    radii[i] = max(0, radii[i])\n                    radii[j] = max(0, radii[j])\n                    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 0.0,
    "eval_time": 260.6264171600342,
    "error": null
  },
  "prompt": "\nCreate a circle packing algorithm for 26 circles in a unit square to maximize the sum of radii.\nStrategy:\n1. Physics Simulation: Implement a force-directed approach where circles repel each other and the boundaries.\n2. Growth: Start with small radii and gradually increase them while the simulation runs.\n3. Forces: Use a potential function or spring-like forces to resolve overlaps.\n4. Refinement: After the simulation reaches a quasi-equilibrium, use scipy.optimize.minimize to fine-tune the positions and radii.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of force-directed initialization and SLSQP optimization.\n    \"\"\"\n    n = 26\n    triu_idx = np.triu_indices(n, k=1)\n\n    def objective(v):\n        # Minimize the negative sum of radii to maximize the sum\n        return -np.sum(v[2*n:])\n\n    def constraint_overlap(v):\n        # Non-overlap constraint: (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        x = v[:n]\n        y = v[n:2*n]\n        r = v[2*n:]\n        dx = x[triu_idx[0]] - x[triu_idx[1]]\n        dy = y[triu_idx[0]] - y[triu_idx[1]]\n        dr = r[triu_idx[0]] + r[triu_idx[1]]\n        return dx**2 + dy**2 - dr**2\n\n    def constraint_boundary(v):\n        # Boundary constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        x = v[:n]\n        y = v[n:2*n]\n        r = v[2*n:]\n        return np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n\n    cons = [\n        {'type': 'ineq', 'fun': constraint_overlap},\n        {'type': 'ineq', 'fun': constraint_boundary}\n    ]\n    \n    # Boundary constraints for the optimizer: x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    best_sum = 0\n    best_v = None\n    \n    start_time = time.time()\n    \n    # Initial trial: A slightly perturbed grid-based start\n    x_grid = np.linspace(0.12, 0.88, 5)\n    y_grid = np.linspace(0.12, 0.88, 5)\n    X, Y = np.meshgrid(x_grid, y_grid)\n    x_init = np.concatenate([X.flatten(), [0.5]])\n    y_init = np.concatenate([Y.flatten(), [0.5]])\n    r_init = np.ones(n) * 0.09\n    vars0 = np.concatenate([x_init, y_init, r_init])\n    \n    res = minimize(objective, vars0, method='SLSQP', constraints=cons, bounds=bounds, \n                   options={'maxiter': 200, 'ftol': 1e-8, 'disp': False})\n    \n    if -res.fun > best_sum:\n        best_sum = -res.fun\n        best_v = res.x\n\n    # Subsequent trials: Random starts refined by a force-directed simulation\n    while time.time() - start_time < 260: # Limit to 260 seconds to allow for final processing\n        r_target = 0.10138  # Target radius based on best known packing for n=26\n        pos = np.random.rand(n, 2)\n        dt = 0.015\n        \n        # Physics simulation: push overlapping circles apart and away from boundaries\n        for _ in range(350):\n            dx = pos[:, 0][:, np.newaxis] - pos[:, 0][np.newaxis, :]\n            dy = pos[:, 1][:, np.newaxis] - pos[:, 1][np.newaxis, :]\n            dist = np.sqrt(dx**2 + dy**2) + 1e-9\n            overlap = (2 * r_target) - dist\n            mask = (overlap > 0)\n            np.fill_diagonal(mask, False)\n            f_mag = overlap * mask\n            fx = np.sum(f_mag * (dx / dist), axis=1)\n            fy = np.sum(f_mag * (dy / dist), axis=1)\n            pos[:, 0] += fx * dt\n            pos[:, 1] += fy * dt\n            # Keep centers within the boundary limits for the target radius\n            pos[:, 0] = np.clip(pos[:, 0], r_target, 1 - r_target)\n            pos[:, 1] = np.clip(pos[:, 1], r_target, 1 - r_target)\n        \n        vars0 = np.concatenate([pos[:, 0], pos[:, 1], np.ones(n) * r_target])\n        res = minimize(objective, vars0, method='SLSQP', constraints=cons, bounds=bounds, \n                       options={'maxiter': 150, 'ftol': 1e-7, 'disp': False})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n    \n    # Final extraction of centers and radii\n    v = best_v\n    centers = np.vstack([v[:n], v[n:2*n]]).T\n    radii = v[2*n:]\n    \n    # Validity Post-Processing: Ensure all constraints are strictly met\n    for i in range(n):\n        # Enforce boundary constraints\n        radii[i] = max(0, min(radii[i], centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1]))\n    \n    # Enforce non-overlap constraints by shrinking radii if necessary\n    for _ in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                if dist < radii[i] + radii[j]:\n                    overlap = (radii[i] + radii[j]) - dist\n                    # Shrink radii to resolve overlap exactly\n                    radii[i] -= overlap * 0.5000000001\n                    radii[j] -= overlap * 0.5000000001\n                    radii[i] = max(0, radii[i])\n                    radii[j] = max(0, radii[j])\n                    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:06:36.204130",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 341,
        "candidates_token_count": 1624,
        "thoughts_token_count": 18814
      },
      "response_text_len": 4564
    }
  },
  "llm_call_duration_s": 118.12795595102943,
  "eval_duration_s": 260.62642642401624
}