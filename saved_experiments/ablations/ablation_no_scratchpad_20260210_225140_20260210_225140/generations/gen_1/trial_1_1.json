{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses basin-hopping with SLSQP to search the configuration space.\n    \"\"\"\n    N = 26\n\n    def objective(x):\n        # Minimize -sum(radii) to maximize sum(radii)\n        return -np.sum(x[2::3])\n\n    def jac_objective(x):\n        # Gradient of -sum(radii)\n        j = np.zeros(3 * N)\n        j[2::3] = -1.0\n        return j\n\n    def constraints(x):\n        # State vector x = [x1, y1, r1, x2, y2, r2, ...]\n        x_pos = x[0::3]\n        y_pos = x[1::3]\n        radii = x[2::3]\n        \n        # Boundary constraints: circles must stay inside [0,1]x[0,1]\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        c_boundary = np.empty(4 * N)\n        c_boundary[0::4] = x_pos - radii\n        c_boundary[1::4] = 1.0 - x_pos - radii\n        c_boundary[2::4] = y_pos - radii\n        c_boundary[3::4] = 1.0 - y_pos - radii\n        \n        # Non-overlap constraints: dist(ci, cj) >= ri + rj\n        # (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = x_pos[:, np.newaxis] - x_pos[np.newaxis, :]\n        dy = y_pos[:, np.newaxis] - y_pos[np.newaxis, :]\n        dr = radii[:, np.newaxis] + radii[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        overlap = dist_sq - dr**2\n        \n        # Only extract the unique pairs (upper triangle)\n        indices = np.triu_indices(N, k=1)\n        c_overlap = overlap[indices]\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    def jac_constraints(x):\n        x_pos = x[0::3]\n        y_pos = x[1::3]\n        radii = x[2::3]\n        num_overlap = N * (N - 1) // 2\n        num_boundary = 4 * N\n        jac = np.zeros((num_boundary + num_overlap, 3 * N))\n        \n        # Jacobian for boundary constraints\n        for i in range(N):\n            # x_i - r_i >= 0\n            jac[4*i, 3*i] = 1.0\n            jac[4*i, 3*i+2] = -1.0\n            # 1 - x_i - r_i >= 0\n            jac[4*i+1, 3*i] = -1.0\n            jac[4*i+1, 3*i+2] = -1.0\n            # y_i - r_i >= 0\n            jac[4*i+2, 3*i+1] = 1.0\n            jac[4*i+2, 3*i+2] = -1.0\n            # 1 - y_i - r_i >= 0\n            jac[4*i+3, 3*i+1] = -1.0\n            jac[4*i+3, 3*i+2] = -1.0\n            \n        # Jacobian for overlap constraints\n        indices = np.triu_indices(N, k=1)\n        row_offset = num_boundary\n        for idx, (i, j) in enumerate(zip(*indices)):\n            row = row_offset + idx\n            dx = x_pos[i] - x_pos[j]\n            dy = y_pos[i] - y_pos[j]\n            dr = radii[i] + radii[j]\n            \n            # d/dxi, d/dyi, d/dri\n            jac[row, 3*i] = 2 * dx\n            jac[row, 3*i+1] = 2 * dy\n            jac[row, 3*i+2] = -2 * dr\n            \n            # d/dxj, d/dyj, d/drj\n            jac[row, 3*j] = -2 * dx\n            jac[row, 3*j+1] = -2 * dy\n            jac[row, 3*j+2] = -2 * dr\n            \n        return jac\n\n    class MyStep:\n        \"\"\"Custom perturbation step for basinhopping.\"\"\"\n        def __init__(self, stepsize=0.04):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            x = x.copy()\n            n = len(x) // 3\n            # Perturb positions and radii\n            x[0::3] += np.random.uniform(-self.stepsize, self.stepsize, n)\n            x[1::3] += np.random.uniform(-self.stepsize, self.stepsize, n)\n            x[2::3] += np.random.uniform(-self.stepsize * 0.1, self.stepsize * 0.1, n)\n            # Clip values to keep them within the search bounds\n            x = np.clip(x, 0, 1)\n            return x\n\n    # Initial guess: A slightly perturbed 5x5 grid with one additional circle\n    x0 = np.zeros(3 * N)\n    coords = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(coords, coords)\n    centers_init = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    # Add the 26th circle near the center\n    centers_init = np.vstack([centers_init, [0.5, 0.5]])\n    \n    np.random.seed(42)\n    x0[0::3] = centers_init[:, 0]\n    x0[1::3] = centers_init[:, 1]\n    x0[2::3] = 0.09 # Start with a reasonable radius\n    x0 += np.random.uniform(-0.01, 0.01, 3 * N)\n    x0 = np.clip(x0, 0, 1)\n\n    # Search bounds for each variable (x, y, r)\n    bounds = []\n    for _ in range(N):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'jac': jac_objective,\n        'constraints': [{'type': 'ineq', 'fun': constraints, 'jac': jac_constraints}],\n        'bounds': bounds,\n        'options': {'maxiter': 100}\n    }\n\n    # Run basin-hopping to explore the configuration space\n    res = basinhopping(\n        objective, x0,\n        minimizer_kwargs=minimizer_kwargs,\n        niter=12,\n        take_step=MyStep(0.04),\n        T=0.01\n    )\n\n    # Extract final configuration\n    final_x = res.x\n    centers = np.stack([final_x[0::3], final_x[1::3]], axis=1)\n    radii = final_x[2::3]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6122999656469563,
    "eval_time": 19.146433115005493,
    "error": null
  },
  "prompt": "\nCreate a circle packing algorithm for 26 circles in a unit square to maximize the sum of radii.\nUse scipy.optimize.basinhopping to explore the configuration space.\nStrategy:\n1. State: The state vector should include 26 centers (x, y) and 26 radii (r).\n2. Local Minimizer: Use 'SLSQP' as the local search method within basin-hopping.\n3. Objective: Minimize -sum(radii).\n4. Constraints: Handle the non-overlap and boundary constraints strictly within the SLSQP local search.\n5. Custom Step: Implement a step function that slightly perturbs circle positions.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses basin-hopping with SLSQP to search the configuration space.\n    \"\"\"\n    N = 26\n\n    def objective(x):\n        # Minimize -sum(radii) to maximize sum(radii)\n        return -np.sum(x[2::3])\n\n    def jac_objective(x):\n        # Gradient of -sum(radii)\n        j = np.zeros(3 * N)\n        j[2::3] = -1.0\n        return j\n\n    def constraints(x):\n        # State vector x = [x1, y1, r1, x2, y2, r2, ...]\n        x_pos = x[0::3]\n        y_pos = x[1::3]\n        radii = x[2::3]\n        \n        # Boundary constraints: circles must stay inside [0,1]x[0,1]\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        c_boundary = np.empty(4 * N)\n        c_boundary[0::4] = x_pos - radii\n        c_boundary[1::4] = 1.0 - x_pos - radii\n        c_boundary[2::4] = y_pos - radii\n        c_boundary[3::4] = 1.0 - y_pos - radii\n        \n        # Non-overlap constraints: dist(ci, cj) >= ri + rj\n        # (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = x_pos[:, np.newaxis] - x_pos[np.newaxis, :]\n        dy = y_pos[:, np.newaxis] - y_pos[np.newaxis, :]\n        dr = radii[:, np.newaxis] + radii[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        overlap = dist_sq - dr**2\n        \n        # Only extract the unique pairs (upper triangle)\n        indices = np.triu_indices(N, k=1)\n        c_overlap = overlap[indices]\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    def jac_constraints(x):\n        x_pos = x[0::3]\n        y_pos = x[1::3]\n        radii = x[2::3]\n        num_overlap = N * (N - 1) // 2\n        num_boundary = 4 * N\n        jac = np.zeros((num_boundary + num_overlap, 3 * N))\n        \n        # Jacobian for boundary constraints\n        for i in range(N):\n            # x_i - r_i >= 0\n            jac[4*i, 3*i] = 1.0\n            jac[4*i, 3*i+2] = -1.0\n            # 1 - x_i - r_i >= 0\n            jac[4*i+1, 3*i] = -1.0\n            jac[4*i+1, 3*i+2] = -1.0\n            # y_i - r_i >= 0\n            jac[4*i+2, 3*i+1] = 1.0\n            jac[4*i+2, 3*i+2] = -1.0\n            # 1 - y_i - r_i >= 0\n            jac[4*i+3, 3*i+1] = -1.0\n            jac[4*i+3, 3*i+2] = -1.0\n            \n        # Jacobian for overlap constraints\n        indices = np.triu_indices(N, k=1)\n        row_offset = num_boundary\n        for idx, (i, j) in enumerate(zip(*indices)):\n            row = row_offset + idx\n            dx = x_pos[i] - x_pos[j]\n            dy = y_pos[i] - y_pos[j]\n            dr = radii[i] + radii[j]\n            \n            # d/dxi, d/dyi, d/dri\n            jac[row, 3*i] = 2 * dx\n            jac[row, 3*i+1] = 2 * dy\n            jac[row, 3*i+2] = -2 * dr\n            \n            # d/dxj, d/dyj, d/drj\n            jac[row, 3*j] = -2 * dx\n            jac[row, 3*j+1] = -2 * dy\n            jac[row, 3*j+2] = -2 * dr\n            \n        return jac\n\n    class MyStep:\n        \"\"\"Custom perturbation step for basinhopping.\"\"\"\n        def __init__(self, stepsize=0.04):\n            self.stepsize = stepsize\n        def __call__(self, x):\n            x = x.copy()\n            n = len(x) // 3\n            # Perturb positions and radii\n            x[0::3] += np.random.uniform(-self.stepsize, self.stepsize, n)\n            x[1::3] += np.random.uniform(-self.stepsize, self.stepsize, n)\n            x[2::3] += np.random.uniform(-self.stepsize * 0.1, self.stepsize * 0.1, n)\n            # Clip values to keep them within the search bounds\n            x = np.clip(x, 0, 1)\n            return x\n\n    # Initial guess: A slightly perturbed 5x5 grid with one additional circle\n    x0 = np.zeros(3 * N)\n    coords = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(coords, coords)\n    centers_init = np.stack([xv.ravel(), yv.ravel()], axis=1)\n    # Add the 26th circle near the center\n    centers_init = np.vstack([centers_init, [0.5, 0.5]])\n    \n    np.random.seed(42)\n    x0[0::3] = centers_init[:, 0]\n    x0[1::3] = centers_init[:, 1]\n    x0[2::3] = 0.09 # Start with a reasonable radius\n    x0 += np.random.uniform(-0.01, 0.01, 3 * N)\n    x0 = np.clip(x0, 0, 1)\n\n    # Search bounds for each variable (x, y, r)\n    bounds = []\n    for _ in range(N):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'jac': jac_objective,\n        'constraints': [{'type': 'ineq', 'fun': constraints, 'jac': jac_constraints}],\n        'bounds': bounds,\n        'options': {'maxiter': 100}\n    }\n\n    # Run basin-hopping to explore the configuration space\n    res = basinhopping(\n        objective, x0,\n        minimizer_kwargs=minimizer_kwargs,\n        niter=12,\n        take_step=MyStep(0.04),\n        T=0.01\n    )\n\n    # Extract final configuration\n    final_x = res.x\n    centers = np.stack([final_x[0::3], final_x[1::3]], axis=1)\n    radii = final_x[2::3]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:02:20.794549",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 369,
        "candidates_token_count": 1928,
        "thoughts_token_count": 17291
      },
      "response_text_len": 5040
    }
  },
  "llm_call_duration_s": 104.19946264300961,
  "eval_duration_s": 19.146443057921715
}