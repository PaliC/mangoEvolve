{
  "trial_id": "trial_4_2",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start strategy with a force-directed repulsion phase followed by \n    constrained optimization (SLSQP).\n    \"\"\"\n    N = 26\n    \n    def objective(params):\n        # params: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n        # Maximize the sum of radii (minimize negative sum)\n        return -np.sum(params[2::3])\n\n    def objective_grad(params):\n        grad = np.zeros(3 * N)\n        grad[2::3] = -1.0\n        return grad\n\n    def constraints(params):\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        b_con = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        # Overlap constraints: (x_i-x_j)^2 + (y_i-y_j)^2 - (r_i+r_j)^2 >= 0\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dr = r[:, np.newaxis] + r[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        indices = np.triu_indices(N, k=1)\n        o_con = dist_sq[indices] - dr[indices]**2\n        return np.concatenate([b_con, o_con])\n\n    def constraints_jac(params):\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        # 104 boundary, 325 overlap\n        jac = np.zeros((429, 3 * N))\n        # Boundary\n        for i in range(N):\n            # x_i - r_i\n            jac[i, 3*i] = 1.0; jac[i, 3*i+2] = -1.0\n            # 1 - x_i - r_i\n            jac[N+i, 3*i] = -1.0; jac[N+i, 3*i+2] = -1.0\n            # y_i - r_i\n            jac[2*N+i, 3*i+1] = 1.0; jac[2*N+i, 3*i+2] = -1.0\n            # 1 - y_i - r_i\n            jac[3*N+i, 3*i+1] = -1.0; jac[3*N+i, 3*i+2] = -1.0\n        # Overlap\n        indices = np.triu_indices(N, k=1)\n        row_indices = np.arange(4 * N, 4 * N + 325)\n        i_idx, j_idx = indices\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        jac[row_indices, 3*i_idx] = 2 * dx\n        jac[row_indices, 3*j_idx] = -2 * dx\n        jac[row_indices, 3*i_idx+1] = 2 * dy\n        jac[row_indices, 3*j_idx+1] = -2 * dy\n        jac[row_indices, 3*i_idx+2] = -2 * dr\n        jac[row_indices, 3*j_idx+2] = -2 * dr\n        return jac\n\n    def get_valid_solution(params):\n        \"\"\"Ensures the solution is strictly valid by slightly shrinking radii if needed.\"\"\"\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        # Boundary check\n        r_bound = np.minimum(r, np.minimum(np.minimum(x, 1-x), np.minimum(y, 1-y)))\n        # Overlap check\n        scale = 1.0\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                if d < r_bound[i] + r_bound[j]:\n                    scale = min(scale, d / (r_bound[i] + r_bound[j] + 1e-12))\n        final_r = r_bound * scale\n        final_centers = np.column_stack([x, y])\n        return final_centers, final_r, np.sum(final_r)\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Multi-start optimization\n    num_starts = 12\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n\n    for start_idx in range(num_starts):\n        # Initial placement\n        if start_idx == 0:\n            # Grid-like start\n            xs = np.linspace(0.1, 0.9, 5)\n            ys = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(xs, ys)\n            centers = np.column_stack([xx.ravel(), yy.ravel()])\n            centers = np.vstack([centers, [0.5, 0.5]])\n        else:\n            # Random start\n            centers = np.random.rand(N, 2) * 0.8 + 0.1\n        \n        centers += np.random.normal(0, 0.02, centers.shape)\n\n        # Force-directed repulsion phase\n        for step in range(250):\n            r_rep = 0.05 + 0.052 * (step / 250)\n            for i in range(N):\n                for j in range(i + 1, N):\n                    d_vec = centers[i] - centers[j]\n                    d = np.linalg.norm(d_vec)\n                    if d < 2 * r_rep:\n                        push = d_vec / (d + 1e-9) * (2 * r_rep - d) * 0.4\n                        centers[i] += push\n                        centers[j] -= push\n            centers = np.clip(centers, r_rep, 1 - r_rep)\n\n        init_params = np.zeros(3 * N)\n        init_params[0::3] = centers[:, 0]\n        init_params[1::3] = centers[:, 1]\n        init_params[2::3] = 0.09 # Start with a reasonable radius\n\n        # Optimization phase\n        res = minimize(objective, init_params, method='SLSQP', jac=objective_grad,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                       bounds=bounds, options={'maxiter': 400}, tol=1e-8)\n\n        # Evaluate and store best valid solution\n        curr_centers, curr_radii, curr_sum = get_valid_solution(res.x)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_centers = curr_centers\n            best_radii = curr_radii\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.621446751836763,
    "eval_time": 17.615474462509155,
    "error": null
  },
  "prompt": "Use a force-directed (physics-based) approach to initially position 26 circles. Model circles as particles with repulsive forces and a boundary force keeping them in [0,1]^2. Once the forces equilibrate, use the positions as a starting point for a constrained optimization (SLSQP or Basin-hopping) to maximize the sum of radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start strategy with a force-directed repulsion phase followed by \n    constrained optimization (SLSQP).\n    \"\"\"\n    N = 26\n    \n    def objective(params):\n        # params: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n        # Maximize the sum of radii (minimize negative sum)\n        return -np.sum(params[2::3])\n\n    def objective_grad(params):\n        grad = np.zeros(3 * N)\n        grad[2::3] = -1.0\n        return grad\n\n    def constraints(params):\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        b_con = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        # Overlap constraints: (x_i-x_j)^2 + (y_i-y_j)^2 - (r_i+r_j)^2 >= 0\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dr = r[:, np.newaxis] + r[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        indices = np.triu_indices(N, k=1)\n        o_con = dist_sq[indices] - dr[indices]**2\n        return np.concatenate([b_con, o_con])\n\n    def constraints_jac(params):\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        # 104 boundary, 325 overlap\n        jac = np.zeros((429, 3 * N))\n        # Boundary\n        for i in range(N):\n            # x_i - r_i\n            jac[i, 3*i] = 1.0; jac[i, 3*i+2] = -1.0\n            # 1 - x_i - r_i\n            jac[N+i, 3*i] = -1.0; jac[N+i, 3*i+2] = -1.0\n            # y_i - r_i\n            jac[2*N+i, 3*i+1] = 1.0; jac[2*N+i, 3*i+2] = -1.0\n            # 1 - y_i - r_i\n            jac[3*N+i, 3*i+1] = -1.0; jac[3*N+i, 3*i+2] = -1.0\n        # Overlap\n        indices = np.triu_indices(N, k=1)\n        row_indices = np.arange(4 * N, 4 * N + 325)\n        i_idx, j_idx = indices\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        jac[row_indices, 3*i_idx] = 2 * dx\n        jac[row_indices, 3*j_idx] = -2 * dx\n        jac[row_indices, 3*i_idx+1] = 2 * dy\n        jac[row_indices, 3*j_idx+1] = -2 * dy\n        jac[row_indices, 3*i_idx+2] = -2 * dr\n        jac[row_indices, 3*j_idx+2] = -2 * dr\n        return jac\n\n    def get_valid_solution(params):\n        \"\"\"Ensures the solution is strictly valid by slightly shrinking radii if needed.\"\"\"\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        # Boundary check\n        r_bound = np.minimum(r, np.minimum(np.minimum(x, 1-x), np.minimum(y, 1-y)))\n        # Overlap check\n        scale = 1.0\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                if d < r_bound[i] + r_bound[j]:\n                    scale = min(scale, d / (r_bound[i] + r_bound[j] + 1e-12))\n        final_r = r_bound * scale\n        final_centers = np.column_stack([x, y])\n        return final_centers, final_r, np.sum(final_r)\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Multi-start optimization\n    num_starts = 12\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N\n\n    for start_idx in range(num_starts):\n        # Initial placement\n        if start_idx == 0:\n            # Grid-like start\n            xs = np.linspace(0.1, 0.9, 5)\n            ys = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(xs, ys)\n            centers = np.column_stack([xx.ravel(), yy.ravel()])\n            centers = np.vstack([centers, [0.5, 0.5]])\n        else:\n            # Random start\n            centers = np.random.rand(N, 2) * 0.8 + 0.1\n        \n        centers += np.random.normal(0, 0.02, centers.shape)\n\n        # Force-directed repulsion phase\n        for step in range(250):\n            r_rep = 0.05 + 0.052 * (step / 250)\n            for i in range(N):\n                for j in range(i + 1, N):\n                    d_vec = centers[i] - centers[j]\n                    d = np.linalg.norm(d_vec)\n                    if d < 2 * r_rep:\n                        push = d_vec / (d + 1e-9) * (2 * r_rep - d) * 0.4\n                        centers[i] += push\n                        centers[j] -= push\n            centers = np.clip(centers, r_rep, 1 - r_rep)\n\n        init_params = np.zeros(3 * N)\n        init_params[0::3] = centers[:, 0]\n        init_params[1::3] = centers[:, 1]\n        init_params[2::3] = 0.09 # Start with a reasonable radius\n\n        # Optimization phase\n        res = minimize(objective, init_params, method='SLSQP', jac=objective_grad,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                       bounds=bounds, options={'maxiter': 400}, tol=1e-8)\n\n        # Evaluate and store best valid solution\n        curr_centers, curr_radii, curr_sum = get_valid_solution(res.x)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_centers = curr_centers\n            best_radii = curr_radii\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:25:42.821913",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 301,
        "candidates_token_count": 1922,
        "thoughts_token_count": 18234
      },
      "response_text_len": 5136
    }
  },
  "llm_call_duration_s": 111.41785198298749,
  "eval_duration_s": 17.61548335500993
}