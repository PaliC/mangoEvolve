{
  "trial_id": "trial_4_0",
  "generation": 4,
  "parent_id": "trial_3_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Strategy:\n    1. Multi-start approach with varied initializations (grid, random, beta, perturbed best).\n    2. Nonlinear optimization (L-BFGS-B) using a penalty method for non-overlap and boundary constraints.\n    3. Linear Programming (LP) to find the exact optimal radii for given circle centers.\n    4. Iterative refinement of the best found configuration.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate the LP constraint matrix A_ub (sum of radii r_i + r_j <= d_ij)\n    num_overlap_constraints = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap_constraints, n))\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[k, i], A_ub[k, j] = 1, 1\n            k += 1\n    c_lp = -np.ones(n)\n\n    best_sum = 0\n    best_centers = np.random.rand(n, 2)\n    best_radii = np.zeros(n)\n\n    def solve_lp(x, y):\n        # Calculate distances for the LP constraints\n        b_ub = np.zeros(num_overlap_constraints)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                b_ub[k] = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                k += 1\n        \n        # Boundary constraints for radii: r_i <= x_i, r_i <= 1-x_i, etc.\n        max_r_bound = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        lp_bounds = [(0, max(0, b)) for b in max_r_bound]\n        \n        try:\n            # Use Highs solver if available for speed\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n            if lp_res.success:\n                return -lp_res.fun, lp_res.x\n        except:\n            # Fallback for older scipy versions\n            try:\n                lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n                if lp_res.success:\n                    return -lp_res.fun, lp_res.x\n            except:\n                pass\n        return 0, None\n\n    def objective(vars, n, lam):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        # Boundary violation penalty\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        p_bound = np.sum(np.maximum(0, b1)**2 + np.maximum(0, b2)**2 + \n                         np.maximum(0, b3)**2 + np.maximum(0, b4)**2)\n        \n        # Overlap violation penalty\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        d = np.sqrt(dx**2 + dy**2 + 1e-9)\n        rr = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = np.maximum(0, rr - d)\n        np.fill_diagonal(violation, 0)\n        p_overlap = 0.5 * np.sum(violation**2)\n        \n        return -np.sum(r) + lam * (p_bound + p_overlap)\n\n    def gradient(vars, n, lam):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        \n        # Gradients from boundary penalty\n        dx_vec = 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_vec = 2 * lam * (-b3 * m3 + b4 * m4)\n        dr_vec = -np.ones(n) + 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        \n        # Gradients from overlap penalty\n        dx_mat = x[:, np.newaxis] - x[np.newaxis, :]\n        dy_mat = y[:, np.newaxis] - y[np.newaxis, :]\n        d_mat = np.sqrt(dx_mat**2 + dy_mat**2 + 1e-9)\n        rr_mat = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = np.maximum(0, rr_mat - d_mat)\n        np.fill_diagonal(violation, 0)\n        \n        common = 2 * lam * violation\n        dx_vec += np.sum(common * (-dx_mat / d_mat), axis=1)\n        dy_vec += np.sum(common * (-dy_mat / d_mat), axis=1)\n        dr_vec += np.sum(common, axis=1)\n        \n        return np.concatenate([dx_vec, dy_vec, dr_vec])\n\n    iter_idx = 0\n    while time.time() - start_time < 285:\n        # 1. Choose initialization strategy\n        if iter_idx == 0:\n            # Grid-based (5x5 + 1)\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init = np.concatenate([xg.flatten(), [0.5]])\n            y_init = np.concatenate([yg.flatten(), [0.5]])\n        elif iter_idx % 5 == 1:\n            x_init, y_init = np.random.rand(n), np.random.rand(n)\n        elif iter_idx % 5 == 2:\n            x_init, y_init = np.random.beta(0.5, 0.5, n), np.random.beta(0.5, 0.5, n)\n        elif iter_idx % 5 == 3 and best_sum > 0:\n            scale = 0.05 / (1 + (iter_idx // 30))\n            x_init = np.clip(best_centers[:, 0] + np.random.normal(0, scale, n), 0.01, 0.99)\n            y_init = np.clip(best_centers[:, 1] + np.random.normal(0, scale, n), 0.01, 0.99)\n        elif iter_idx % 5 == 4 and best_sum > 0:\n            x_init, y_init = best_centers[:, 0].copy(), best_centers[:, 1].copy()\n            idx1, idx2 = np.random.choice(n, 2, replace=False)\n            x_init[idx1], x_init[idx2] = x_init[idx2], x_init[idx1]\n            y_init[idx1], y_init[idx2] = y_init[idx2], y_init[idx1]\n        else:\n            x_init, y_init = np.random.rand(n), np.random.rand(n)\n\n        r_init = np.random.uniform(0.01, 0.05, n)\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n\n        # 2. Optimization sequence (Continuation Method)\n        for lam in [20, 200, 1000]:\n            res = minimize(objective, vars_curr, args=(n, lam), jac=gradient, method='L-BFGS-B',\n                           bounds=[(0, 1)]*n + [(0, 1)]*n + [(0, 0.5)]*n,\n                           options={'maxiter': 400, 'ftol': 1e-7})\n            vars_curr = res.x\n        \n        # 3. Solve for optimal radii with exact center coordinates\n        current_sum, current_radii = solve_lp(vars_curr[:n], vars_curr[n:2*n])\n        \n        # 4. Update best configuration and perform local refinement\n        if current_sum > best_sum:\n            best_sum, best_radii, best_centers = current_sum, current_radii, np.stack([vars_curr[:n], vars_curr[n:2*n]], axis=1)\n            \n            # Local refinement of the new best configuration\n            for _ in range(3):\n                if time.time() - start_time > 295: break\n                refine_vars = np.concatenate([best_centers[:,0], best_centers[:,1], best_radii])\n                refine_vars = np.clip(refine_vars + np.random.normal(0, 0.002, 3*n), 0, 1)\n                res = minimize(objective, refine_vars, args=(n, 1000), jac=gradient, method='L-BFGS-B',\n                               bounds=[(0, 1)]*n + [(0, 1)]*n + [(0, 0.5)]*n,\n                               options={'maxiter': 200, 'ftol': 1e-7})\n                refine_sum, refine_radii = solve_lp(res.x[:n], res.x[n:2*n])\n                if refine_sum > best_sum:\n                    best_sum, best_radii, best_centers = refine_sum, refine_radii, np.stack([res.x[:n], res.x[n:2*n]], axis=1)\n\n        iter_idx += 1\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.6283902076553414,
    "eval_time": 286.27095341682434,
    "error": null
  },
  "prompt": "Refine the following best-performing solution (score 2.631867250238027). Use a more intensive local search. Specifically, try increasing the number of basin-hopping iterations or using a multi-stage optimization where you first optimize for non-overlap and then maximize the sum of radii. Try small perturbations to escape local optima.\n\nCode:\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses a hybrid approach:\n    1. Multi-start with a combination of grid-based, random, and basin-hopping initializations.\n    2. Non-linear optimization (L-BFGS-B) with a penalty method to find promising center layouts.\n    3. Linear Programming (LP) to find the exact optimal radii for those fixed centers.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_centers = np.random.rand(n, 2) * 0.8 + 0.1\n    best_radii = np.zeros(n)\n\n    def objective(vars, n, lam):\n        # vars contains [x1...xn, y1...yn, r1...rn]\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        \n        # Boundary violation penalty\n        # Constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        b1 = r - x\n        b2 = x + r - 1\n        b3 = r - y\n        b4 = y + r - 1\n        p_bound = np.sum(np.maximum(0, b1)**2 + np.maximum(0, b2)**2 + \n                         np.maximum(0, b3)**2 + np.maximum(0, b4)**2)\n        \n        # Overlap violation penalty\n        # Constraints: r_i + r_j <= distance(C_i, C_j)\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        d = np.sqrt(dx**2 + dy**2 + 1e-12)\n        rr = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = np.maximum(0, rr - d)\n        # Use only upper triangle to avoid double counting and diagonal\n        p_overlap = np.sum(np.triu(violation**2, k=1))\n        \n        # Objective: Maximize sum(r) -> Minimize -sum(r)\n        return -np.sum(r) + lam * (p_bound + p_overlap)\n\n    def gradient(vars, n, lam):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        dx_vec, dy_vec, dr_vec = np.zeros(n), np.zeros(n), -np.ones(n)\n        \n        # Boundary gradients\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dx_vec += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_vec += 2 * lam * (-b3 * m3 + b4 * m4)\n        dr_vec += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        \n        # Overlap gradients\n        dx_mat = x[:, np.newaxis] - x[np.newaxis, :]\n        dy_mat = y[:, np.newaxis] - y[np.newaxis, :]\n        d_mat = np.sqrt(dx_mat**2 + dy_mat**2 + 1e-12)\n        rr_mat = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = rr_mat - d_mat\n        mask = violation > 0\n        np.fill_diagonal(mask, False)\n        \n        common = 2 * lam * violation * mask\n        # Gradient of -d_ij w.r.t x_i is -(x_i - x_j) / d_ij\n        dx_vec += np.sum(common * (-dx_mat / d_mat), axis=1)\n        dy_vec += np.sum(common * (-dy_mat / d_mat), axis=1)\n        dr_vec += np.sum(common, axis=1)\n        \n        return np.concatenate([dx_vec, dy_vec, dr_vec])\n\n    # Pre-calculate the constant part of the LP constraint matrix\n    A_ub = np.zeros((n * (n - 1) // 2, n))\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[k, i], A_ub[k, j] = 1, 1\n            k += 1\n    c_lp = -np.ones(n)\n\n    iter_idx = 0\n    while time.time() - start_time < 285:\n        # Multi-start strategy incorporating Basin Hopping\n        if iter_idx == 0:\n            # 1. Grid-like initialization (5x5 + 1)\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init = np.concatenate([xg.flatten(), [0.5]])\n            y_init = np.concatenate([yg.flatten(), [0.5]])\n        elif iter_idx % 3 == 0 and best_sum > 0:\n            # 2. Basin Hopping: Perturb the best known configuration\n            scale = 0.06 / (1 + (iter_idx // 30)) \n            x_init = np.clip(best_centers[:, 0] + np.random.normal(0, scale, n), 0.01, 0.99)\n            y_init = np.clip(best_centers[:, 1] + np.random.normal(0, scale, n), 0.01, 0.99)\n        else:\n            # 3. Pure random initialization\n            x_init = np.random.uniform(0.05, 0.95, n)\n            y_init = np.random.uniform(0.05, 0.95, n)\n            \n        # Initial radii guess\n        r_init = np.ones(n) * 0.05\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n        \n        # Optimization with increasing penalty strength (Continuation Method)\n        for lam in [20, 200, 2000]:\n            res = minimize(objective, vars_curr, args=(n, lam), jac=gradient, method='L-BFGS-B', \n                           bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, \n                           options={'maxiter': 400, 'ftol': 1e-8})\n            vars_curr = res.x\n            \n        # Extract centers from non-linear optimization result\n        x_final = np.clip(vars_curr[:n], 0, 1)\n        y_final = np.clip(vars_curr[n:2*n], 0, 1)\n        \n        # Solve LP to find the exact optimal radii for the fixed centers\n        b_ub = np.zeros(n * (n - 1) // 2)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                b_ub[k] = np.sqrt((x_final[i] - x_final[j])**2 + (y_final[i] - y_final[j])**2)\n                k += 1\n        \n        # Radii must also satisfy boundary constraints\n        max_r_bound = np.minimum.reduce([x_final, 1 - x_final, y_final, 1 - y_final])\n        lp_bounds = [(0, max(0, b)) for b in max_r_bound]\n        \n        try:\n            # Highs is significantly faster for LP\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            # Fallback for older environments\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if lp_res.success:\n            current_sum = -lp_res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_radii = lp_res.x\n                best_centers = np.stack([x_final, y_final], axis=1)\n        \n        iter_idx += 1\n\n    return best_centers, best_radii, best_sum",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Strategy:\n    1. Multi-start approach with varied initializations (grid, random, beta, perturbed best).\n    2. Nonlinear optimization (L-BFGS-B) using a penalty method for non-overlap and boundary constraints.\n    3. Linear Programming (LP) to find the exact optimal radii for given circle centers.\n    4. Iterative refinement of the best found configuration.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate the LP constraint matrix A_ub (sum of radii r_i + r_j <= d_ij)\n    num_overlap_constraints = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap_constraints, n))\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[k, i], A_ub[k, j] = 1, 1\n            k += 1\n    c_lp = -np.ones(n)\n\n    best_sum = 0\n    best_centers = np.random.rand(n, 2)\n    best_radii = np.zeros(n)\n\n    def solve_lp(x, y):\n        # Calculate distances for the LP constraints\n        b_ub = np.zeros(num_overlap_constraints)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                b_ub[k] = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                k += 1\n        \n        # Boundary constraints for radii: r_i <= x_i, r_i <= 1-x_i, etc.\n        max_r_bound = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        lp_bounds = [(0, max(0, b)) for b in max_r_bound]\n        \n        try:\n            # Use Highs solver if available for speed\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n            if lp_res.success:\n                return -lp_res.fun, lp_res.x\n        except:\n            # Fallback for older scipy versions\n            try:\n                lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n                if lp_res.success:\n                    return -lp_res.fun, lp_res.x\n            except:\n                pass\n        return 0, None\n\n    def objective(vars, n, lam):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        # Boundary violation penalty\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        p_bound = np.sum(np.maximum(0, b1)**2 + np.maximum(0, b2)**2 + \n                         np.maximum(0, b3)**2 + np.maximum(0, b4)**2)\n        \n        # Overlap violation penalty\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        d = np.sqrt(dx**2 + dy**2 + 1e-9)\n        rr = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = np.maximum(0, rr - d)\n        np.fill_diagonal(violation, 0)\n        p_overlap = 0.5 * np.sum(violation**2)\n        \n        return -np.sum(r) + lam * (p_bound + p_overlap)\n\n    def gradient(vars, n, lam):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        \n        # Gradients from boundary penalty\n        dx_vec = 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_vec = 2 * lam * (-b3 * m3 + b4 * m4)\n        dr_vec = -np.ones(n) + 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        \n        # Gradients from overlap penalty\n        dx_mat = x[:, np.newaxis] - x[np.newaxis, :]\n        dy_mat = y[:, np.newaxis] - y[np.newaxis, :]\n        d_mat = np.sqrt(dx_mat**2 + dy_mat**2 + 1e-9)\n        rr_mat = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = np.maximum(0, rr_mat - d_mat)\n        np.fill_diagonal(violation, 0)\n        \n        common = 2 * lam * violation\n        dx_vec += np.sum(common * (-dx_mat / d_mat), axis=1)\n        dy_vec += np.sum(common * (-dy_mat / d_mat), axis=1)\n        dr_vec += np.sum(common, axis=1)\n        \n        return np.concatenate([dx_vec, dy_vec, dr_vec])\n\n    iter_idx = 0\n    while time.time() - start_time < 285:\n        # 1. Choose initialization strategy\n        if iter_idx == 0:\n            # Grid-based (5x5 + 1)\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init = np.concatenate([xg.flatten(), [0.5]])\n            y_init = np.concatenate([yg.flatten(), [0.5]])\n        elif iter_idx % 5 == 1:\n            x_init, y_init = np.random.rand(n), np.random.rand(n)\n        elif iter_idx % 5 == 2:\n            x_init, y_init = np.random.beta(0.5, 0.5, n), np.random.beta(0.5, 0.5, n)\n        elif iter_idx % 5 == 3 and best_sum > 0:\n            scale = 0.05 / (1 + (iter_idx // 30))\n            x_init = np.clip(best_centers[:, 0] + np.random.normal(0, scale, n), 0.01, 0.99)\n            y_init = np.clip(best_centers[:, 1] + np.random.normal(0, scale, n), 0.01, 0.99)\n        elif iter_idx % 5 == 4 and best_sum > 0:\n            x_init, y_init = best_centers[:, 0].copy(), best_centers[:, 1].copy()\n            idx1, idx2 = np.random.choice(n, 2, replace=False)\n            x_init[idx1], x_init[idx2] = x_init[idx2], x_init[idx1]\n            y_init[idx1], y_init[idx2] = y_init[idx2], y_init[idx1]\n        else:\n            x_init, y_init = np.random.rand(n), np.random.rand(n)\n\n        r_init = np.random.uniform(0.01, 0.05, n)\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n\n        # 2. Optimization sequence (Continuation Method)\n        for lam in [20, 200, 1000]:\n            res = minimize(objective, vars_curr, args=(n, lam), jac=gradient, method='L-BFGS-B',\n                           bounds=[(0, 1)]*n + [(0, 1)]*n + [(0, 0.5)]*n,\n                           options={'maxiter': 400, 'ftol': 1e-7})\n            vars_curr = res.x\n        \n        # 3. Solve for optimal radii with exact center coordinates\n        current_sum, current_radii = solve_lp(vars_curr[:n], vars_curr[n:2*n])\n        \n        # 4. Update best configuration and perform local refinement\n        if current_sum > best_sum:\n            best_sum, best_radii, best_centers = current_sum, current_radii, np.stack([vars_curr[:n], vars_curr[n:2*n]], axis=1)\n            \n            # Local refinement of the new best configuration\n            for _ in range(3):\n                if time.time() - start_time > 295: break\n                refine_vars = np.concatenate([best_centers[:,0], best_centers[:,1], best_radii])\n                refine_vars = np.clip(refine_vars + np.random.normal(0, 0.002, 3*n), 0, 1)\n                res = minimize(objective, refine_vars, args=(n, 1000), jac=gradient, method='L-BFGS-B',\n                               bounds=[(0, 1)]*n + [(0, 1)]*n + [(0, 0.5)]*n,\n                               options={'maxiter': 200, 'ftol': 1e-7})\n                refine_sum, refine_radii = solve_lp(res.x[:n], res.x[n:2*n])\n                if refine_sum > best_sum:\n                    best_sum, best_radii, best_centers = refine_sum, refine_radii, np.stack([res.x[:n], res.x[n:2*n]], axis=1)\n\n        iter_idx += 1\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:30:14.621596",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2517,
        "candidates_token_count": 2586,
        "thoughts_token_count": 17239
      },
      "response_text_len": 6971
    }
  },
  "llm_call_duration_s": 114.56228141998872,
  "eval_duration_s": 286.2709635719657
}