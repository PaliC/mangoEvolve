{
  "trial_id": "trial_4_1",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a two-stage optimization strategy (equal-radius packing followed by \n    variable-radius refinement) with multiple restarts.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_params = None\n    \n    # Pre-calculate indices for overlap constraints\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = n * (n - 1) // 2\n    \n    # --- Stage 1: Equal-Radius Packing (Maximize r) ---\n    def s1_objective(p):\n        return -p[-1] # Minimize -r (Maximize r)\n\n    def s1_grad_objective(p):\n        grad = np.zeros(2*n + 1)\n        grad[-1] = -1.0\n        return grad\n\n    def s1_constraints(p):\n        x = p[0:2*n:2]\n        y = p[1:2*n:2]\n        r = p[-1]\n        # Boundary constraints (4*n): x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        b1 = x - r\n        b2 = 1 - x - r\n        b3 = y - r\n        b4 = 1 - y - r\n        # Overlap constraints: dist^2 - (2r)^2 >= 0\n        dist_sq = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2\n        overlap = dist_sq - 4 * r**2\n        return np.concatenate([b1, b2, b3, b4, overlap])\n\n    def s1_jac_constraints(p):\n        x = p[0:2*n:2]\n        y = p[1:2*n:2]\n        r = p[-1]\n        jac = np.zeros((4*n + num_overlap, 2*n + 1))\n        # Boundary\n        for i in range(n):\n            jac[i, 2*i] = 1; jac[i, 2*n] = -1\n            jac[n+i, 2*i] = -1; jac[n+i, 2*n] = -1\n            jac[2*n+i, 2*i+1] = 1; jac[2*n+i, 2*n] = -1\n            jac[3*n+i, 2*i+1] = -1; jac[3*n+i, 2*n] = -1\n        # Overlap\n        row_idx = 4*n + np.arange(num_overlap)\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        jac[row_idx, 2*i_idx] = 2 * dx\n        jac[row_idx, 2*j_idx] = -2 * dx\n        jac[row_idx, 2*i_idx+1] = 2 * dy\n        jac[row_idx, 2*j_idx+1] = -2 * dy\n        jac[row_idx, 2*n] = -8 * r\n        return jac\n\n    # --- Stage 2: Variable-Radius Refinement (Maximize sum of r_i) ---\n    def s2_objective(p):\n        return -np.sum(p[2::3]) # Minimize -sum(r_i)\n\n    def s2_grad_objective(p):\n        grad = np.zeros(3*n)\n        grad[2::3] = -1.0\n        return grad\n\n    def s2_constraints(p):\n        x = p[0::3]\n        y = p[1::3]\n        r = p[2::3]\n        b1 = x - r\n        b2 = 1 - x - r\n        b3 = y - r\n        b4 = 1 - y - r\n        dist_sq = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2\n        rad_sq = (r[i_idx] + r[j_idx])**2\n        overlap = dist_sq - rad_sq\n        return np.concatenate([b1, b2, b3, b4, overlap])\n\n    def s2_jac_constraints(p):\n        x = p[0::3]\n        y = p[1::3]\n        r = p[2::3]\n        jac = np.zeros((4*n + num_overlap, 3*n))\n        for i in range(n):\n            jac[i, 3*i] = 1; jac[i, 3*i+2] = -1\n            jac[n+i, 3*i] = -1; jac[n+i, 3*i+2] = -1\n            jac[2*n+i, 3*i+1] = 1; jac[2*n+i, 3*i+2] = -1\n            jac[3*n+i, 3*i+1] = -1; jac[3*n+i, 3*i+2] = -1\n        row_idx = 4*n + np.arange(num_overlap)\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        sr = r[i_idx] + r[j_idx]\n        jac[row_idx, 3*i_idx] = 2 * dx\n        jac[row_idx, 3*j_idx] = -2 * dx\n        jac[row_idx, 3*i_idx+1] = 2 * dy\n        jac[row_idx, 3*j_idx+1] = -2 * dy\n        jac[row_idx, 3*i_idx+2] = -2 * sr\n        jac[row_idx, 3*j_idx+2] = -2 * sr\n        return jac\n\n    def convert_s1_to_s2(p1):\n        p2 = np.zeros(3*n)\n        p2[0::3] = p1[0:2*n:2]\n        p2[1::3] = p1[1:2*n:2]\n        p2[2::3] = p1[2*n]\n        return p2\n\n    # Optimization settings\n    cons1 = {'type': 'ineq', 'fun': s1_constraints, 'jac': s1_jac_constraints}\n    cons2 = {'type': 'ineq', 'fun': s2_constraints, 'jac': s2_jac_constraints}\n    bounds1 = [(0, 1)] * (2*n) + [(0, 0.5)]\n    bounds2 = [(0, 1)] * (3*n)\n    \n    # --- Main Loop: Multiple Restarts ---\n    iteration = 0\n    np.random.seed(42)\n    while time.time() - start_time < 270:\n        # Initial guess for Stage 1\n        r_init = 0.05\n        x_init = r_init + (1 - 2*r_init) * np.random.rand(n)\n        y_init = r_init + (1 - 2*r_init) * np.random.rand(n)\n        p0_s1 = np.zeros(2*n + 1)\n        p0_s1[0:2*n:2] = x_init\n        p0_s1[1:2*n:2] = y_init\n        p0_s1[2*n] = r_init\n        \n        try:\n            # Stage 1: Fast equal-radius search\n            res1 = minimize(s1_objective, p0_s1, method='SLSQP', jac=s1_grad_objective,\n                            constraints=cons1, bounds=bounds1, options={'maxiter': 60, 'ftol': 1e-5})\n            \n            # Stage 2: Refine sum of radii\n            p0_s2 = convert_s1_to_s2(res1.x)\n            res2 = minimize(s2_objective, p0_s2, method='SLSQP', jac=s2_grad_objective,\n                            constraints=cons2, bounds=bounds2, options={'maxiter': 100, 'ftol': 1e-6})\n            \n            if -res2.fun > best_sum:\n                best_sum = -res2.fun\n                best_params = res2.x\n        except:\n            continue\n        iteration += 1\n\n    # --- Final Refinement of the Global Best ---\n    if best_params is not None:\n        res_final = minimize(s2_objective, best_params, method='SLSQP', jac=s2_grad_objective,\n                             constraints=cons2, bounds=bounds2, options={'maxiter': 500, 'ftol': 1e-9})\n        best_params = res_final.x\n        best_sum = -res_final.fun\n\n    # Prepare output\n    centers = np.zeros((n, 2))\n    centers[:, 0] = best_params[0::3]\n    centers[:, 1] = best_params[1::3]\n    radii = best_params[2::3]\n    \n    return (centers, radii, best_sum)",
  "metrics": {
    "valid": true,
    "score": 2.5745510710685253,
    "eval_time": 275.55038356781006,
    "error": null
  },
  "prompt": "Implement a circle packing algorithm for 26 circles in a unit square. Use a Sobol or Halton sequence (from scipy.stats.qmc) for initial center placements to ensure better coverage of the square. Use scipy.optimize.minimize (SLSQP) to maximize the sum of radii subject to non-overlap and boundary constraints. Try multiple restarts with different quasi-random seeds.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a two-stage optimization strategy (equal-radius packing followed by \n    variable-radius refinement) with multiple restarts.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_params = None\n    \n    # Pre-calculate indices for overlap constraints\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = n * (n - 1) // 2\n    \n    # --- Stage 1: Equal-Radius Packing (Maximize r) ---\n    def s1_objective(p):\n        return -p[-1] # Minimize -r (Maximize r)\n\n    def s1_grad_objective(p):\n        grad = np.zeros(2*n + 1)\n        grad[-1] = -1.0\n        return grad\n\n    def s1_constraints(p):\n        x = p[0:2*n:2]\n        y = p[1:2*n:2]\n        r = p[-1]\n        # Boundary constraints (4*n): x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        b1 = x - r\n        b2 = 1 - x - r\n        b3 = y - r\n        b4 = 1 - y - r\n        # Overlap constraints: dist^2 - (2r)^2 >= 0\n        dist_sq = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2\n        overlap = dist_sq - 4 * r**2\n        return np.concatenate([b1, b2, b3, b4, overlap])\n\n    def s1_jac_constraints(p):\n        x = p[0:2*n:2]\n        y = p[1:2*n:2]\n        r = p[-1]\n        jac = np.zeros((4*n + num_overlap, 2*n + 1))\n        # Boundary\n        for i in range(n):\n            jac[i, 2*i] = 1; jac[i, 2*n] = -1\n            jac[n+i, 2*i] = -1; jac[n+i, 2*n] = -1\n            jac[2*n+i, 2*i+1] = 1; jac[2*n+i, 2*n] = -1\n            jac[3*n+i, 2*i+1] = -1; jac[3*n+i, 2*n] = -1\n        # Overlap\n        row_idx = 4*n + np.arange(num_overlap)\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        jac[row_idx, 2*i_idx] = 2 * dx\n        jac[row_idx, 2*j_idx] = -2 * dx\n        jac[row_idx, 2*i_idx+1] = 2 * dy\n        jac[row_idx, 2*j_idx+1] = -2 * dy\n        jac[row_idx, 2*n] = -8 * r\n        return jac\n\n    # --- Stage 2: Variable-Radius Refinement (Maximize sum of r_i) ---\n    def s2_objective(p):\n        return -np.sum(p[2::3]) # Minimize -sum(r_i)\n\n    def s2_grad_objective(p):\n        grad = np.zeros(3*n)\n        grad[2::3] = -1.0\n        return grad\n\n    def s2_constraints(p):\n        x = p[0::3]\n        y = p[1::3]\n        r = p[2::3]\n        b1 = x - r\n        b2 = 1 - x - r\n        b3 = y - r\n        b4 = 1 - y - r\n        dist_sq = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2\n        rad_sq = (r[i_idx] + r[j_idx])**2\n        overlap = dist_sq - rad_sq\n        return np.concatenate([b1, b2, b3, b4, overlap])\n\n    def s2_jac_constraints(p):\n        x = p[0::3]\n        y = p[1::3]\n        r = p[2::3]\n        jac = np.zeros((4*n + num_overlap, 3*n))\n        for i in range(n):\n            jac[i, 3*i] = 1; jac[i, 3*i+2] = -1\n            jac[n+i, 3*i] = -1; jac[n+i, 3*i+2] = -1\n            jac[2*n+i, 3*i+1] = 1; jac[2*n+i, 3*i+2] = -1\n            jac[3*n+i, 3*i+1] = -1; jac[3*n+i, 3*i+2] = -1\n        row_idx = 4*n + np.arange(num_overlap)\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        sr = r[i_idx] + r[j_idx]\n        jac[row_idx, 3*i_idx] = 2 * dx\n        jac[row_idx, 3*j_idx] = -2 * dx\n        jac[row_idx, 3*i_idx+1] = 2 * dy\n        jac[row_idx, 3*j_idx+1] = -2 * dy\n        jac[row_idx, 3*i_idx+2] = -2 * sr\n        jac[row_idx, 3*j_idx+2] = -2 * sr\n        return jac\n\n    def convert_s1_to_s2(p1):\n        p2 = np.zeros(3*n)\n        p2[0::3] = p1[0:2*n:2]\n        p2[1::3] = p1[1:2*n:2]\n        p2[2::3] = p1[2*n]\n        return p2\n\n    # Optimization settings\n    cons1 = {'type': 'ineq', 'fun': s1_constraints, 'jac': s1_jac_constraints}\n    cons2 = {'type': 'ineq', 'fun': s2_constraints, 'jac': s2_jac_constraints}\n    bounds1 = [(0, 1)] * (2*n) + [(0, 0.5)]\n    bounds2 = [(0, 1)] * (3*n)\n    \n    # --- Main Loop: Multiple Restarts ---\n    iteration = 0\n    np.random.seed(42)\n    while time.time() - start_time < 270:\n        # Initial guess for Stage 1\n        r_init = 0.05\n        x_init = r_init + (1 - 2*r_init) * np.random.rand(n)\n        y_init = r_init + (1 - 2*r_init) * np.random.rand(n)\n        p0_s1 = np.zeros(2*n + 1)\n        p0_s1[0:2*n:2] = x_init\n        p0_s1[1:2*n:2] = y_init\n        p0_s1[2*n] = r_init\n        \n        try:\n            # Stage 1: Fast equal-radius search\n            res1 = minimize(s1_objective, p0_s1, method='SLSQP', jac=s1_grad_objective,\n                            constraints=cons1, bounds=bounds1, options={'maxiter': 60, 'ftol': 1e-5})\n            \n            # Stage 2: Refine sum of radii\n            p0_s2 = convert_s1_to_s2(res1.x)\n            res2 = minimize(s2_objective, p0_s2, method='SLSQP', jac=s2_grad_objective,\n                            constraints=cons2, bounds=bounds2, options={'maxiter': 100, 'ftol': 1e-6})\n            \n            if -res2.fun > best_sum:\n                best_sum = -res2.fun\n                best_params = res2.x\n        except:\n            continue\n        iteration += 1\n\n    # --- Final Refinement of the Global Best ---\n    if best_params is not None:\n        res_final = minimize(s2_objective, best_params, method='SLSQP', jac=s2_grad_objective,\n                             constraints=cons2, bounds=bounds2, options={'maxiter': 500, 'ftol': 1e-9})\n        best_params = res_final.x\n        best_sum = -res_final.fun\n\n    # Prepare output\n    centers = np.zeros((n, 2))\n    centers[:, 0] = best_params[0::3]\n    centers[:, 1] = best_params[1::3]\n    radii = best_params[2::3]\n    \n    return (centers, radii, best_sum)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:30:35.590173",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 308,
        "candidates_token_count": 2362,
        "thoughts_token_count": 24314
      },
      "response_text_len": 5606
    }
  },
  "llm_call_duration_s": 146.250580249005,
  "eval_duration_s": 275.5503934969893
}