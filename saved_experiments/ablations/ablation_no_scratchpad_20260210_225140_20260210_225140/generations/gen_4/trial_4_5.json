{
  "trial_id": "trial_4_5",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    n = 26\n    \n    def objective(vars):\n        # Objective: Maximize sum of radii. Scipy minimizes, so we negate.\n        return -np.sum(vars[2::3])\n\n    def objective_jac(vars):\n        # Jacobian of the objective function\n        jac = np.zeros(3 * n)\n        jac[2::3] = -1\n        return jac\n\n    def con_overlap(vars):\n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        # Written as: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        res = []\n        for i in range(n - 1):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            d2 = dx**2 + dy**2\n            r2 = (r[i] + r[i+1:])**2\n            res.append(d2 - r2)\n        return np.concatenate(res)\n\n    def con_overlap_jac(vars):\n        # Jacobian of the non-overlap constraints\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        jac = np.zeros((n * (n - 1) // 2, 3 * n))\n        row = 0\n        for i in range(n - 1):\n            num = n - 1 - i\n            idx = np.arange(i + 1, n)\n            dx, dy, rs = x[i] - x[idx], y[i] - y[idx], r[i] + r[idx]\n            rows = np.arange(row, row + num)\n            # Derivatives with respect to x_i, y_i, r_i\n            jac[rows, 3*i] = 2 * dx\n            jac[rows, 3*i+1] = 2 * dy\n            jac[rows, 3*i+2] = -2 * rs\n            # Derivatives with respect to x_j, y_j, r_j\n            jac[rows, 3*idx] = -2 * dx\n            jac[rows, 3*idx+1] = -2 * dy\n            jac[rows, 3*idx+2] = -2 * rs\n            row += num\n        return jac\n\n    def con_box(vars):\n        # Boundary constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        # Also include r_i >= 0\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        return np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r, r])\n\n    def con_box_jac(vars):\n        # Jacobian of the boundary constraints\n        jac = np.zeros((5 * n, 3 * n))\n        for i in range(n):\n            jac[5*i, 3*i], jac[5*i, 3*i+2] = 1, -1\n            jac[5*i+1, 3*i], jac[5*i+1, 3*i+2] = -1, -1\n            jac[5*i+2, 3*i+1], jac[5*i+2, 3*i+2] = 1, -1\n            jac[5*i+3, 3*i+1], jac[5*i+3, 3*i+2] = -1, -1\n            jac[5*i+4, 3*i+2] = 1\n        return jac\n\n    def make_feasible(vars):\n        # Iterative cleanup to ensure strict feasibility\n        x, y, r = vars[0::3].copy(), vars[1::3].copy(), vars[2::3].copy()\n        r = np.maximum(r, 0)\n        # Ensure box constraints\n        r = np.minimum(r, x)\n        r = np.minimum(r, 1 - x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1 - y)\n        # Ensure non-overlap constraints\n        for _ in range(15):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] > 1e-12:\n                            ratio = dist / (r[i] + r[j])\n                            r[i] *= ratio\n                            r[j] *= ratio\n        return np.stack([x, y, r], axis=1).flatten()\n\n    cons = [\n        {'type': 'ineq', 'fun': con_overlap, 'jac': con_overlap_jac},\n        {'type': 'ineq', 'fun': con_box, 'jac': con_box_jac}\n    ]\n\n    start_time = time.time()\n    best_x = None\n    best_sum = -1\n\n    # Attempt several initial configurations\n    for attempt in range(8):\n        if time.time() - start_time > 150:\n            break\n        \n        if attempt == 0:\n            # 5x5 grid plus one circle in the middle\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x, y = x.flatten(), y.flatten()\n            x, y = np.append(x, 0.5), np.append(y, 0.5)\n            r = np.full(n, 0.09)\n        elif attempt == 1:\n            # One large circle and several small ones\n            x = np.random.uniform(0.1, 0.9, n)\n            y = np.random.uniform(0.1, 0.9, n)\n            r = np.full(n, 0.07)\n            x[0], y[0], r[0] = 0.5, 0.5, 0.35\n        else:\n            # Randomized initial guess\n            x = np.random.uniform(0.1, 0.9, n)\n            y = np.random.uniform(0.1, 0.9, n)\n            r = np.random.uniform(0.01, 0.1, n)\n            \n        x0 = np.stack([x, y, r], axis=1).flatten()\n        res = minimize(objective, x0, method='SLSQP', jac=objective_jac,\n                       constraints=cons, options={'maxiter': 100, 'ftol': 1e-7})\n        \n        fx = make_feasible(res.x)\n        fs = np.sum(fx[2::3])\n        if fs > best_sum:\n            best_sum = fs\n            best_x = fx\n\n    # Basin-hopping refinement loop\n    while time.time() - start_time < 280:\n        new_x = best_x.copy()\n        # Custom hop: move 1 circle to a new random location\n        idx = np.random.randint(n)\n        new_x[3*idx] = np.random.uniform(0.1, 0.9)\n        new_x[3*idx+1] = np.random.uniform(0.1, 0.9)\n        new_x[3*idx+2] = np.random.uniform(0.01, 0.15)\n        \n        res = minimize(objective, new_x, method='SLSQP', jac=objective_jac,\n                       constraints=cons, options={'maxiter': 80, 'ftol': 1e-7})\n        \n        fx = make_feasible(res.x)\n        fs = np.sum(fx[2::3])\n        if fs > best_sum:\n            best_sum = fs\n            best_x = fx\n\n    # Final polish of the best solution\n    res = minimize(objective, best_x, method='SLSQP', jac=objective_jac,\n                   constraints=cons, options={'maxiter': 200, 'ftol': 1e-9})\n    final_x = make_feasible(res.x)\n    \n    centers = np.stack([final_x[0::3], final_x[1::3]], axis=1)\n    radii = final_x[2::3]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 282.3482220172882,
    "error": "Circle 0 has negative radius -0.09317007153925339"
  },
  "prompt": "Start with a near-optimal packing structure (like a slightly perturbed 5x5 grid plus one extra circle). Apply Basin-hopping with a custom 'hop' function that moves one circle at a time to a new random location while keeping others fixed, then runs a local SLSQP. This explores the configuration space by jumping circles into 'holes' in the packing.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    n = 26\n    \n    def objective(vars):\n        # Objective: Maximize sum of radii. Scipy minimizes, so we negate.\n        return -np.sum(vars[2::3])\n\n    def objective_jac(vars):\n        # Jacobian of the objective function\n        jac = np.zeros(3 * n)\n        jac[2::3] = -1\n        return jac\n\n    def con_overlap(vars):\n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        # Written as: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        res = []\n        for i in range(n - 1):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            d2 = dx**2 + dy**2\n            r2 = (r[i] + r[i+1:])**2\n            res.append(d2 - r2)\n        return np.concatenate(res)\n\n    def con_overlap_jac(vars):\n        # Jacobian of the non-overlap constraints\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        jac = np.zeros((n * (n - 1) // 2, 3 * n))\n        row = 0\n        for i in range(n - 1):\n            num = n - 1 - i\n            idx = np.arange(i + 1, n)\n            dx, dy, rs = x[i] - x[idx], y[i] - y[idx], r[i] + r[idx]\n            rows = np.arange(row, row + num)\n            # Derivatives with respect to x_i, y_i, r_i\n            jac[rows, 3*i] = 2 * dx\n            jac[rows, 3*i+1] = 2 * dy\n            jac[rows, 3*i+2] = -2 * rs\n            # Derivatives with respect to x_j, y_j, r_j\n            jac[rows, 3*idx] = -2 * dx\n            jac[rows, 3*idx+1] = -2 * dy\n            jac[rows, 3*idx+2] = -2 * rs\n            row += num\n        return jac\n\n    def con_box(vars):\n        # Boundary constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        # Also include r_i >= 0\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        return np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r, r])\n\n    def con_box_jac(vars):\n        # Jacobian of the boundary constraints\n        jac = np.zeros((5 * n, 3 * n))\n        for i in range(n):\n            jac[5*i, 3*i], jac[5*i, 3*i+2] = 1, -1\n            jac[5*i+1, 3*i], jac[5*i+1, 3*i+2] = -1, -1\n            jac[5*i+2, 3*i+1], jac[5*i+2, 3*i+2] = 1, -1\n            jac[5*i+3, 3*i+1], jac[5*i+3, 3*i+2] = -1, -1\n            jac[5*i+4, 3*i+2] = 1\n        return jac\n\n    def make_feasible(vars):\n        # Iterative cleanup to ensure strict feasibility\n        x, y, r = vars[0::3].copy(), vars[1::3].copy(), vars[2::3].copy()\n        r = np.maximum(r, 0)\n        # Ensure box constraints\n        r = np.minimum(r, x)\n        r = np.minimum(r, 1 - x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1 - y)\n        # Ensure non-overlap constraints\n        for _ in range(15):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] > 1e-12:\n                            ratio = dist / (r[i] + r[j])\n                            r[i] *= ratio\n                            r[j] *= ratio\n        return np.stack([x, y, r], axis=1).flatten()\n\n    cons = [\n        {'type': 'ineq', 'fun': con_overlap, 'jac': con_overlap_jac},\n        {'type': 'ineq', 'fun': con_box, 'jac': con_box_jac}\n    ]\n\n    start_time = time.time()\n    best_x = None\n    best_sum = -1\n\n    # Attempt several initial configurations\n    for attempt in range(8):\n        if time.time() - start_time > 150:\n            break\n        \n        if attempt == 0:\n            # 5x5 grid plus one circle in the middle\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x, y = x.flatten(), y.flatten()\n            x, y = np.append(x, 0.5), np.append(y, 0.5)\n            r = np.full(n, 0.09)\n        elif attempt == 1:\n            # One large circle and several small ones\n            x = np.random.uniform(0.1, 0.9, n)\n            y = np.random.uniform(0.1, 0.9, n)\n            r = np.full(n, 0.07)\n            x[0], y[0], r[0] = 0.5, 0.5, 0.35\n        else:\n            # Randomized initial guess\n            x = np.random.uniform(0.1, 0.9, n)\n            y = np.random.uniform(0.1, 0.9, n)\n            r = np.random.uniform(0.01, 0.1, n)\n            \n        x0 = np.stack([x, y, r], axis=1).flatten()\n        res = minimize(objective, x0, method='SLSQP', jac=objective_jac,\n                       constraints=cons, options={'maxiter': 100, 'ftol': 1e-7})\n        \n        fx = make_feasible(res.x)\n        fs = np.sum(fx[2::3])\n        if fs > best_sum:\n            best_sum = fs\n            best_x = fx\n\n    # Basin-hopping refinement loop\n    while time.time() - start_time < 280:\n        new_x = best_x.copy()\n        # Custom hop: move 1 circle to a new random location\n        idx = np.random.randint(n)\n        new_x[3*idx] = np.random.uniform(0.1, 0.9)\n        new_x[3*idx+1] = np.random.uniform(0.1, 0.9)\n        new_x[3*idx+2] = np.random.uniform(0.01, 0.15)\n        \n        res = minimize(objective, new_x, method='SLSQP', jac=objective_jac,\n                       constraints=cons, options={'maxiter': 80, 'ftol': 1e-7})\n        \n        fx = make_feasible(res.x)\n        fs = np.sum(fx[2::3])\n        if fs > best_sum:\n            best_sum = fs\n            best_x = fx\n\n    # Final polish of the best solution\n    res = minimize(objective, best_x, method='SLSQP', jac=objective_jac,\n                   constraints=cons, options={'maxiter': 200, 'ftol': 1e-9})\n    final_x = make_feasible(res.x)\n    \n    centers = np.stack([final_x[0::3], final_x[1::3]], axis=1)\n    radii = final_x[2::3]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:30:27.012311",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 302,
        "candidates_token_count": 2174,
        "thoughts_token_count": 21086
      },
      "response_text_len": 5715
    }
  },
  "llm_call_duration_s": 130.87445666792337,
  "eval_duration_s": 282.3482322508935
}