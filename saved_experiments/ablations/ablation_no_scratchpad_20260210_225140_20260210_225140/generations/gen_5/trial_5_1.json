{
  "trial_id": "trial_5_1",
  "generation": 5,
  "parent_id": "trial_3_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of radii.\n    The strategy uses a 'shaking' approach with Scipy's SLSQP method.\n    1. Initial search: Starts with grid-based and random configurations.\n    2. Shaking: Small perturbations to the best known configuration followed by SLSQP refinement.\n    3. Optimal Radii: Uses Linear Programming (LP) to find optimal radii for any center configuration.\n    \"\"\"\n    n = 26\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = n * (n - 1) // 2\n\n    def all_cons(v):\n        \"\"\"Vectorized constraint function for SLSQP.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_bound = np.zeros(4 * n)\n        c_bound[0::4] = x - r\n        c_bound[1::4] = 1.0 - x - r\n        c_bound[2::4] = y - r\n        c_bound[3::4] = 1.0 - y - r\n        # Overlap constraints: dist - (ri + rj) >= 0\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        d = np.sqrt(dx**2 + dy**2 + 1e-12)\n        c_overlap = d - (r[i_idx] + r[j_idx])\n        return np.concatenate([c_bound, c_overlap])\n\n    def jac_all_cons(v):\n        \"\"\"Jacobian of the constraint function.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        jac = np.zeros((4 * n + num_overlap, 3 * n))\n        # Boundary part\n        for i in range(n):\n            jac[4*i, i] = 1; jac[4*i, 2*n+i] = -1\n            jac[4*i+1, i] = -1; jac[4*i+1, 2*n+i] = -1\n            jac[4*i+2, n+i] = 1; jac[4*i+2, 2*n+i] = -1\n            jac[4*i+3, n+i] = -1; jac[4*i+3, 2*n+i] = -1\n        # Overlap part\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        d = np.sqrt(dx**2 + dy**2 + 1e-12)\n        rows = 4 * n + np.arange(num_overlap)\n        jac[rows, i_idx] = dx / d\n        jac[rows, j_idx] = -dx / d\n        jac[rows, n + i_idx] = dy / d\n        jac[rows, n + j_idx] = -dy / d\n        jac[rows, 2*n + i_idx] = -1\n        jac[rows, 2*n + j_idx] = -1\n        return jac\n\n    def objective(v):\n        \"\"\"Negative sum of radii to maximize sum of radii.\"\"\"\n        return -np.sum(v[2*n:])\n\n    def jac_objective(v):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        j = np.zeros(3 * n)\n        j[2*n:] = -1.0\n        return j\n\n    def get_radii(centers):\n        \"\"\"Solves LP to find optimal radii for fixed centers.\"\"\"\n        c_lp = -np.ones(n)\n        A_ub = np.zeros((num_overlap, n))\n        A_ub[np.arange(num_overlap), i_idx] = 1\n        A_ub[np.arange(num_overlap), j_idx] = 1\n        dist = np.sqrt(np.sum((centers[i_idx] - centers[j_idx])**2, axis=1))\n        b_ub = dist\n        max_r_bound = np.minimum(np.minimum(centers[:, 0], 1 - centers[:, 0]),\n                                 np.minimum(centers[:, 1], 1 - centers[:, 1]))\n        lp_bounds = [(0, max(0, b)) for b in max_r_bound]\n        try:\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n        if res.success:\n            return res.x, -res.fun\n        return None, 0\n\n    def is_feasible(v):\n        \"\"\"Check if a configuration is feasible within a small tolerance.\"\"\"\n        return np.all(all_cons(v) >= -1e-7)\n\n    start_time = time.time()\n    best_sum = 0\n    best_v = None\n\n    # Initial multi-start to find a good basin\n    for i in range(10):\n        if i == 0:\n            c = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(c, c)\n            x = np.append(xv.flatten(), 0.05)\n            y = np.append(yv.flatten(), 0.05)\n        elif i < 5:\n            c = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(c, c)\n            x = np.append(xv.flatten() + np.random.normal(0, 0.01, 25), np.random.rand())\n            y = np.append(yv.flatten() + np.random.normal(0, 0.01, 25), np.random.rand())\n            x, y = np.clip(x, 0, 1), np.clip(y, 0, 1)\n        else:\n            x, y = np.random.rand(n), np.random.rand(n)\n        \n        radii, s = get_radii(np.column_stack([x, y]))\n        if radii is not None:\n            v_init = np.concatenate([x, y, radii])\n            res = minimize(objective, v_init, jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': all_cons, 'jac': jac_all_cons},\n                           method='SLSQP', options={'maxiter': 30})\n            if -res.fun > best_sum and is_feasible(res.x):\n                best_sum = -res.fun\n                best_v = res.x\n\n    # Shaking strategy loop\n    while time.time() - start_time < 280:\n        if best_v is None: break\n        \n        curr_x, curr_y = best_v[:n], best_v[n:2*n]\n        # Shake: apply small perturbation\n        sigma = 0.002 if np.random.rand() > 0.2 else 0.01\n        shaken_x = np.clip(curr_x + np.random.normal(0, sigma, n), 0, 1)\n        shaken_y = np.clip(curr_y + np.random.normal(0, sigma, n), 0, 1)\n        \n        # Optimize radii for shaken centers to start SLSQP from a feasible point\n        shaken_radii, _ = get_radii(np.column_stack([shaken_x, shaken_y]))\n        if shaken_radii is not None:\n            v_init = np.concatenate([shaken_x, shaken_y, shaken_radii])\n            # Local refinement with SLSQP\n            res = minimize(objective, v_init, jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': all_cons, 'jac': jac_all_cons},\n                           method='SLSQP', options={'maxiter': 25})\n            \n            if -res.fun > best_sum and is_feasible(res.x):\n                best_sum = -res.fun\n                best_v = res.x\n\n    # Final polish\n    final_centers = np.column_stack([best_v[:n], best_v[n:2*n]])\n    final_radii, final_sum = get_radii(final_centers)\n    return final_centers, final_radii, final_sum",
  "metrics": {
    "valid": true,
    "score": 2.630972267661489,
    "eval_time": 280.8096487522125,
    "error": null
  },
  "prompt": "Using the layout from Trial trial_3_0 (score 2.631867250238027), implement a 'shaking' strategy. Perturb the centers slightly and then use Scipy's 'minimize' with the 'SLSQP' method. The key is to run this hundreds of times with very small perturbations to find a local optimum that improves the sum of radii. import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses a hybrid approach:\n    1. Multi-start with a combination of grid-based, random, and basin-hopping initializations.\n    2. Non-linear optimization (L-BFGS-B) with a penalty method to find promising center layouts.\n    3. Linear Programming (LP) to find the exact optimal radii for those fixed centers.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_centers = np.random.rand(n, 2) * 0.8 + 0.1\n    best_radii = np.zeros(n)\n\n    def objective(vars, n, lam):\n        # vars contains [x1...xn, y1...yn, r1...rn]\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        \n        # Boundary violation penalty\n        # Constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        b1 = r - x\n        b2 = x + r - 1\n        b3 = r - y\n        b4 = y + r - 1\n        p_bound = np.sum(np.maximum(0, b1)**2 + np.maximum(0, b2)**2 + \n                         np.maximum(0, b3)**2 + np.maximum(0, b4)**2)\n        \n        # Overlap violation penalty\n        # Constraints: r_i + r_j <= distance(C_i, C_j)\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        d = np.sqrt(dx**2 + dy**2 + 1e-12)\n        rr = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = np.maximum(0, rr - d)\n        # Use only upper triangle to avoid double counting and diagonal\n        p_overlap = np.sum(np.triu(violation**2, k=1))\n        \n        # Objective: Maximize sum(r) -> Minimize -sum(r)\n        return -np.sum(r) + lam * (p_bound + p_overlap)\n\n    def gradient(vars, n, lam):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        dx_vec, dy_vec, dr_vec = np.zeros(n), np.zeros(n), -np.ones(n)\n        \n        # Boundary gradients\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dx_vec += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_vec += 2 * lam * (-b3 * m3 + b4 * m4)\n        dr_vec += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        \n        # Overlap gradients\n        dx_mat = x[:, np.newaxis] - x[np.newaxis, :]\n        dy_mat = y[:, np.newaxis] - y[np.newaxis, :]\n        d_mat = np.sqrt(dx_mat**2 + dy_mat**2 + 1e-12)\n        rr_mat = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = rr_mat - d_mat\n        mask = violation > 0\n        np.fill_diagonal(mask, False)\n        \n        common = 2 * lam * violation * mask\n        # Gradient of -d_ij w.r.t x_i is -(x_i - x_j) / d_ij\n        dx_vec += np.sum(common * (-dx_mat / d_mat), axis=1)\n        dy_vec += np.sum(common * (-dy_mat / d_mat), axis=1)\n        dr_vec += np.sum(common, axis=1)\n        \n        return np.concatenate([dx_vec, dy_vec, dr_vec])\n\n    # Pre-calculate the constant part of the LP constraint matrix\n    A_ub = np.zeros((n * (n - 1) // 2, n))\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[k, i], A_ub[k, j] = 1, 1\n            k += 1\n    c_lp = -np.ones(n)\n\n    iter_idx = 0\n    while time.time() - start_time < 285:\n        # Multi-start strategy incorporating Basin Hopping\n        if iter_idx == 0:\n            # 1. Grid-like initialization (5x5 + 1)\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init = np.concatenate([xg.flatten(), [0.5]])\n            y_init = np.concatenate([yg.flatten(), [0.5]])\n        elif iter_idx % 3 == 0 and best_sum > 0:\n            # 2. Basin Hopping: Perturb the best known configuration\n            scale = 0.06 / (1 + (iter_idx // 30)) \n            x_init = np.clip(best_centers[:, 0] + np.random.normal(0, scale, n), 0.01, 0.99)\n            y_init = np.clip(best_centers[:, 1] + np.random.normal(0, scale, n), 0.01, 0.99)\n        else:\n            # 3. Pure random initialization\n            x_init = np.random.uniform(0.05, 0.95, n)\n            y_init = np.random.uniform(0.05, 0.95, n)\n            \n        # Initial radii guess\n        r_init = np.ones(n) * 0.05\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n        \n        # Optimization with increasing penalty strength (Continuation Method)\n        for lam in [20, 200, 2000]:\n            res = minimize(objective, vars_curr, args=(n, lam), jac=gradient, method='L-BFGS-B', \n                           bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, \n                           options={'maxiter': 400, 'ftol': 1e-8})\n            vars_curr = res.x\n            \n        # Extract centers from non-linear optimization result\n        x_final = np.clip(vars_curr[:n], 0, 1)\n        y_final = np.clip(vars_curr[n:2*n], 0, 1)\n        \n        # Solve LP to find the exact optimal radii for the fixed centers\n        b_ub = np.zeros(n * (n - 1) // 2)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                b_ub[k] = np.sqrt((x_final[i] - x_final[j])**2 + (y_final[i] - y_final[j])**2)\n                k += 1\n        \n        # Radii must also satisfy boundary constraints\n        max_r_bound = np.minimum.reduce([x_final, 1 - x_final, y_final, 1 - y_final])\n        lp_bounds = [(0, max(0, b)) for b in max_r_bound]\n        \n        try:\n            # Highs is significantly faster for LP\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            # Fallback for older environments\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if lp_res.success:\n            current_sum = -lp_res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_radii = lp_res.x\n                best_centers = np.stack([x_final, y_final], axis=1)\n        \n        iter_idx += 1\n\n    return best_centers, best_radii, best_sum",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of radii.\n    The strategy uses a 'shaking' approach with Scipy's SLSQP method.\n    1. Initial search: Starts with grid-based and random configurations.\n    2. Shaking: Small perturbations to the best known configuration followed by SLSQP refinement.\n    3. Optimal Radii: Uses Linear Programming (LP) to find optimal radii for any center configuration.\n    \"\"\"\n    n = 26\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = n * (n - 1) // 2\n\n    def all_cons(v):\n        \"\"\"Vectorized constraint function for SLSQP.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_bound = np.zeros(4 * n)\n        c_bound[0::4] = x - r\n        c_bound[1::4] = 1.0 - x - r\n        c_bound[2::4] = y - r\n        c_bound[3::4] = 1.0 - y - r\n        # Overlap constraints: dist - (ri + rj) >= 0\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        d = np.sqrt(dx**2 + dy**2 + 1e-12)\n        c_overlap = d - (r[i_idx] + r[j_idx])\n        return np.concatenate([c_bound, c_overlap])\n\n    def jac_all_cons(v):\n        \"\"\"Jacobian of the constraint function.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        jac = np.zeros((4 * n + num_overlap, 3 * n))\n        # Boundary part\n        for i in range(n):\n            jac[4*i, i] = 1; jac[4*i, 2*n+i] = -1\n            jac[4*i+1, i] = -1; jac[4*i+1, 2*n+i] = -1\n            jac[4*i+2, n+i] = 1; jac[4*i+2, 2*n+i] = -1\n            jac[4*i+3, n+i] = -1; jac[4*i+3, 2*n+i] = -1\n        # Overlap part\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        d = np.sqrt(dx**2 + dy**2 + 1e-12)\n        rows = 4 * n + np.arange(num_overlap)\n        jac[rows, i_idx] = dx / d\n        jac[rows, j_idx] = -dx / d\n        jac[rows, n + i_idx] = dy / d\n        jac[rows, n + j_idx] = -dy / d\n        jac[rows, 2*n + i_idx] = -1\n        jac[rows, 2*n + j_idx] = -1\n        return jac\n\n    def objective(v):\n        \"\"\"Negative sum of radii to maximize sum of radii.\"\"\"\n        return -np.sum(v[2*n:])\n\n    def jac_objective(v):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        j = np.zeros(3 * n)\n        j[2*n:] = -1.0\n        return j\n\n    def get_radii(centers):\n        \"\"\"Solves LP to find optimal radii for fixed centers.\"\"\"\n        c_lp = -np.ones(n)\n        A_ub = np.zeros((num_overlap, n))\n        A_ub[np.arange(num_overlap), i_idx] = 1\n        A_ub[np.arange(num_overlap), j_idx] = 1\n        dist = np.sqrt(np.sum((centers[i_idx] - centers[j_idx])**2, axis=1))\n        b_ub = dist\n        max_r_bound = np.minimum(np.minimum(centers[:, 0], 1 - centers[:, 0]),\n                                 np.minimum(centers[:, 1], 1 - centers[:, 1]))\n        lp_bounds = [(0, max(0, b)) for b in max_r_bound]\n        try:\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n        if res.success:\n            return res.x, -res.fun\n        return None, 0\n\n    def is_feasible(v):\n        \"\"\"Check if a configuration is feasible within a small tolerance.\"\"\"\n        return np.all(all_cons(v) >= -1e-7)\n\n    start_time = time.time()\n    best_sum = 0\n    best_v = None\n\n    # Initial multi-start to find a good basin\n    for i in range(10):\n        if i == 0:\n            c = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(c, c)\n            x = np.append(xv.flatten(), 0.05)\n            y = np.append(yv.flatten(), 0.05)\n        elif i < 5:\n            c = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(c, c)\n            x = np.append(xv.flatten() + np.random.normal(0, 0.01, 25), np.random.rand())\n            y = np.append(yv.flatten() + np.random.normal(0, 0.01, 25), np.random.rand())\n            x, y = np.clip(x, 0, 1), np.clip(y, 0, 1)\n        else:\n            x, y = np.random.rand(n), np.random.rand(n)\n        \n        radii, s = get_radii(np.column_stack([x, y]))\n        if radii is not None:\n            v_init = np.concatenate([x, y, radii])\n            res = minimize(objective, v_init, jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': all_cons, 'jac': jac_all_cons},\n                           method='SLSQP', options={'maxiter': 30})\n            if -res.fun > best_sum and is_feasible(res.x):\n                best_sum = -res.fun\n                best_v = res.x\n\n    # Shaking strategy loop\n    while time.time() - start_time < 280:\n        if best_v is None: break\n        \n        curr_x, curr_y = best_v[:n], best_v[n:2*n]\n        # Shake: apply small perturbation\n        sigma = 0.002 if np.random.rand() > 0.2 else 0.01\n        shaken_x = np.clip(curr_x + np.random.normal(0, sigma, n), 0, 1)\n        shaken_y = np.clip(curr_y + np.random.normal(0, sigma, n), 0, 1)\n        \n        # Optimize radii for shaken centers to start SLSQP from a feasible point\n        shaken_radii, _ = get_radii(np.column_stack([shaken_x, shaken_y]))\n        if shaken_radii is not None:\n            v_init = np.concatenate([shaken_x, shaken_y, shaken_radii])\n            # Local refinement with SLSQP\n            res = minimize(objective, v_init, jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': all_cons, 'jac': jac_all_cons},\n                           method='SLSQP', options={'maxiter': 25})\n            \n            if -res.fun > best_sum and is_feasible(res.x):\n                best_sum = -res.fun\n                best_v = res.x\n\n    # Final polish\n    final_centers = np.column_stack([best_v[:n], best_v[n:2*n]])\n    final_radii, final_sum = get_radii(final_centers)\n    return final_centers, final_radii, final_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:38:23.276582",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2523,
        "candidates_token_count": 2177,
        "thoughts_token_count": 21249
      },
      "response_text_len": 5884
    }
  },
  "llm_call_duration_s": 125.48833651491441,
  "eval_duration_s": 280.80965930002276
}