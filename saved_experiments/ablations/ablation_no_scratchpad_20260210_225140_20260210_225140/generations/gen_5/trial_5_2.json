{
  "trial_id": "trial_5_2",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of force-directed relaxation and high-precision SLSQP refinement.\n    \"\"\"\n    N = 26\n    \n    def get_initial_guess(trial_idx):\n        \"\"\"Generates diverse initial configurations for the packing problem.\"\"\"\n        if trial_idx % 4 == 0:\n            # 5x5 grid + 1 extra circle\n            x, y = np.meshgrid(np.linspace(0.12, 0.88, 5), np.linspace(0.12, 0.88, 5))\n            centers = np.vstack([x.ravel(), y.ravel()]).T\n            centers = np.vstack([centers, [0.5, 0.5]])\n        elif trial_idx % 4 == 1:\n            # 6x5 grid, pick 26 slots\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 5))\n            centers = np.vstack([x.ravel(), y.ravel()]).T\n            state = np.random.RandomState(trial_idx)\n            idx = state.choice(len(centers), N, replace=False)\n            centers = centers[idx]\n        elif trial_idx % 4 == 2:\n            # 5x6 grid, pick 26 slots\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 6))\n            centers = np.vstack([x.ravel(), y.ravel()]).T\n            state = np.random.RandomState(trial_idx)\n            idx = state.choice(len(centers), N, replace=False)\n            centers = centers[idx]\n        else:\n            # Random placement in the center region\n            centers = np.random.rand(N, 2) * 0.6 + 0.2\n        \n        # Add slight noise to break symmetries\n        centers += np.random.normal(0, 0.015, centers.shape)\n        radii = np.ones(N) * 0.08\n        return centers, radii\n\n    def constraints(x):\n        \"\"\"Vectorized constraints for SLSQP: boundary and non-overlap.\"\"\"\n        c = x[:2*N].reshape((N, 2))\n        r = x[2*N:]\n        \n        # Boundary constraints (4*N): c_i - r_i >= 0 and 1 - c_i - r_i >= 0\n        b_cons = np.zeros(4 * N)\n        b_cons[0::4] = c[:, 0] - r\n        b_cons[1::4] = 1.0 - c[:, 0] - r\n        b_cons[2::4] = c[:, 1] - r\n        b_cons[3::4] = 1.0 - c[:, 1] - r\n        \n        # Overlap constraints (N*(N-1)/2): dist(c_i, c_j) - (r_i + r_j) >= 0\n        diffs = c[:, np.newaxis, :] - c[np.newaxis, :, :]\n        # Add epsilon to avoid sqrt(0) which has an undefined gradient\n        dists = np.sqrt(np.sum(diffs**2, axis=-1) + 1e-12)\n        r_sums = r[:, np.newaxis] + r[np.newaxis, :]\n        \n        indices = np.triu_indices(N, k=1)\n        o_cons = dists[indices] - r_sums[indices]\n        \n        return np.concatenate([b_cons, o_cons])\n\n    def objective(x):\n        \"\"\"Objective function: minimize the negative sum of radii.\"\"\"\n        return -np.sum(x[2*N:])\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    start_time = time.time()\n    trial = 0\n    \n    # Run multiple trials within the 300s time limit\n    while time.time() - start_time < 265:\n        centers, radii = get_initial_guess(trial)\n        \n        # --- Stage 1: Force-Directed Relaxation ---\n        # Circles exert repulsive forces based on overlap and grow toward target size.\n        for _ in range(350):\n            for i in range(N):\n                ci = centers[i]\n                ri = radii[i]\n                for j in range(i + 1, N):\n                    cj = centers[j]\n                    rj = radii[j]\n                    dx = ci[0] - cj[0]\n                    dy = ci[1] - cj[1]\n                    d = (dx*dx + dy*dy)**0.5\n                    if d < ri + rj:\n                        push = (ri + rj - d) * 0.5\n                        d_safe = max(d, 1e-9)\n                        nx, ny = dx / d_safe, dy / d_safe\n                        centers[i, 0] += nx * push\n                        centers[i, 1] += ny * push\n                        centers[j, 0] -= nx * push\n                        centers[j, 1] -= ny * push\n            \n            # Radii growth and boundary clipping\n            for i in range(N):\n                # Target radius slightly larger than expected optimal (~0.1014)\n                radii[i] += (0.103 - radii[i]) * 0.05\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1.0 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1.0 - radii[i])\n        \n        # --- Stage 2: SLSQP Refinement ---\n        # High-precision optimization of centers and radii simultaneously.\n        x0 = np.concatenate([centers.flatten(), radii])\n        # x_i, y_i in [0, 1], r_i in [0, 0.5]\n        bounds = [(0.0, 1.0)] * (2 * N) + [(0.0, 0.5)] * N\n        \n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=bounds, \n            options={'maxiter': 250, 'ftol': 1e-9}\n        )\n        \n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = res.x[:2*N].reshape((N, 2))\n            best_radii = res.x[2*N:]\n            \n        trial += 1\n        \n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 265.8837163448334,
    "error": "Circle 1 at (0.0, 1.0) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "Implement a force-directed algorithm where circles exert repulsive forces on each other and the boundaries. Unlike standard packing, make the 'rest length' of the forces variable and tied to the individual radii to maximize the sum of radii. Follow this with a high-precision SLSQP refinement.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of force-directed relaxation and high-precision SLSQP refinement.\n    \"\"\"\n    N = 26\n    \n    def get_initial_guess(trial_idx):\n        \"\"\"Generates diverse initial configurations for the packing problem.\"\"\"\n        if trial_idx % 4 == 0:\n            # 5x5 grid + 1 extra circle\n            x, y = np.meshgrid(np.linspace(0.12, 0.88, 5), np.linspace(0.12, 0.88, 5))\n            centers = np.vstack([x.ravel(), y.ravel()]).T\n            centers = np.vstack([centers, [0.5, 0.5]])\n        elif trial_idx % 4 == 1:\n            # 6x5 grid, pick 26 slots\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 5))\n            centers = np.vstack([x.ravel(), y.ravel()]).T\n            state = np.random.RandomState(trial_idx)\n            idx = state.choice(len(centers), N, replace=False)\n            centers = centers[idx]\n        elif trial_idx % 4 == 2:\n            # 5x6 grid, pick 26 slots\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 6))\n            centers = np.vstack([x.ravel(), y.ravel()]).T\n            state = np.random.RandomState(trial_idx)\n            idx = state.choice(len(centers), N, replace=False)\n            centers = centers[idx]\n        else:\n            # Random placement in the center region\n            centers = np.random.rand(N, 2) * 0.6 + 0.2\n        \n        # Add slight noise to break symmetries\n        centers += np.random.normal(0, 0.015, centers.shape)\n        radii = np.ones(N) * 0.08\n        return centers, radii\n\n    def constraints(x):\n        \"\"\"Vectorized constraints for SLSQP: boundary and non-overlap.\"\"\"\n        c = x[:2*N].reshape((N, 2))\n        r = x[2*N:]\n        \n        # Boundary constraints (4*N): c_i - r_i >= 0 and 1 - c_i - r_i >= 0\n        b_cons = np.zeros(4 * N)\n        b_cons[0::4] = c[:, 0] - r\n        b_cons[1::4] = 1.0 - c[:, 0] - r\n        b_cons[2::4] = c[:, 1] - r\n        b_cons[3::4] = 1.0 - c[:, 1] - r\n        \n        # Overlap constraints (N*(N-1)/2): dist(c_i, c_j) - (r_i + r_j) >= 0\n        diffs = c[:, np.newaxis, :] - c[np.newaxis, :, :]\n        # Add epsilon to avoid sqrt(0) which has an undefined gradient\n        dists = np.sqrt(np.sum(diffs**2, axis=-1) + 1e-12)\n        r_sums = r[:, np.newaxis] + r[np.newaxis, :]\n        \n        indices = np.triu_indices(N, k=1)\n        o_cons = dists[indices] - r_sums[indices]\n        \n        return np.concatenate([b_cons, o_cons])\n\n    def objective(x):\n        \"\"\"Objective function: minimize the negative sum of radii.\"\"\"\n        return -np.sum(x[2*N:])\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    start_time = time.time()\n    trial = 0\n    \n    # Run multiple trials within the 300s time limit\n    while time.time() - start_time < 265:\n        centers, radii = get_initial_guess(trial)\n        \n        # --- Stage 1: Force-Directed Relaxation ---\n        # Circles exert repulsive forces based on overlap and grow toward target size.\n        for _ in range(350):\n            for i in range(N):\n                ci = centers[i]\n                ri = radii[i]\n                for j in range(i + 1, N):\n                    cj = centers[j]\n                    rj = radii[j]\n                    dx = ci[0] - cj[0]\n                    dy = ci[1] - cj[1]\n                    d = (dx*dx + dy*dy)**0.5\n                    if d < ri + rj:\n                        push = (ri + rj - d) * 0.5\n                        d_safe = max(d, 1e-9)\n                        nx, ny = dx / d_safe, dy / d_safe\n                        centers[i, 0] += nx * push\n                        centers[i, 1] += ny * push\n                        centers[j, 0] -= nx * push\n                        centers[j, 1] -= ny * push\n            \n            # Radii growth and boundary clipping\n            for i in range(N):\n                # Target radius slightly larger than expected optimal (~0.1014)\n                radii[i] += (0.103 - radii[i]) * 0.05\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1.0 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1.0 - radii[i])\n        \n        # --- Stage 2: SLSQP Refinement ---\n        # High-precision optimization of centers and radii simultaneously.\n        x0 = np.concatenate([centers.flatten(), radii])\n        # x_i, y_i in [0, 1], r_i in [0, 0.5]\n        bounds = [(0.0, 1.0)] * (2 * N) + [(0.0, 0.5)] * N\n        \n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=bounds, \n            options={'maxiter': 250, 'ftol': 1e-9}\n        )\n        \n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = res.x[:2*N].reshape((N, 2))\n            best_radii = res.x[2*N:]\n            \n        trial += 1\n        \n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:37:54.251080",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 284,
        "candidates_token_count": 1747,
        "thoughts_token_count": 17199
      },
      "response_text_len": 5221
    }
  },
  "llm_call_duration_s": 111.38504735194147,
  "eval_duration_s": 265.88372527295724
}