{
  "trial_id": "trial_5_4",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start optimizer combining Basin-hopping and SLSQP with Sobol initialization.\n    \"\"\"\n    n = 26\n    \n    # Objective function: minimize -sum(radii) to maximize sum(radii)\n    def obj_func(vars):\n        # vars layout: [x0, y0, r0, x1, y1, r1, ..., xN-1, yN-1, rN-1]\n        r = vars[2::3]\n        return -np.sum(r), np.tile([0, 0, -1], n)\n\n    # Constraints: circle containment in unit square and non-overlapping circles\n    def get_constraints(n_circles):\n        def cons_f(vars):\n            x = vars[0::3]\n            y = vars[1::3]\n            r = vars[2::3]\n            \n            # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n            c_square = np.zeros(4 * n_circles)\n            c_square[0::4] = x - r\n            c_square[1::4] = 1.0 - x - r\n            c_square[2::4] = y - r\n            c_square[3::4] = 1.0 - y - r\n            \n            # Non-overlapping constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n            dx = x[:, np.newaxis] - x[np.newaxis, :]\n            dy = y[:, np.newaxis] - y[np.newaxis, :]\n            dist_sq = dx**2 + dy**2\n            r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n            r_sum_sq = r_sum**2\n            \n            indices = np.triu_indices(n_circles, k=1)\n            c_overlap = dist_sq[indices] - r_sum_sq[indices]\n            \n            return np.concatenate([c_square, c_overlap])\n\n        def cons_j(vars):\n            x = vars[0::3]\n            y = vars[1::3]\n            r = vars[2::3]\n            n_overlap = n_circles * (n_circles - 1) // 2\n            jac = np.zeros((4 * n_circles + n_overlap, 3 * n_circles))\n            \n            # Gradients for square boundary constraints\n            for i in range(n_circles):\n                jac[4*i, 3*i], jac[4*i, 3*i+2] = 1, -1\n                jac[4*i+1, 3*i], jac[4*i+1, 3*i+2] = -1, -1\n                jac[4*i+2, 3*i+1], jac[4*i+2, 3*i+2] = 1, -1\n                jac[4*i+3, 3*i+1], jac[4*i+3, 3*i+2] = -1, -1\n                \n            # Gradients for overlap constraints\n            k = 4 * n_circles\n            i_idx, j_idx = np.triu_indices(n_circles, k=1)\n            dx = x[i_idx] - x[j_idx]\n            dy = y[i_idx] - y[j_idx]\n            rs = r[i_idx] + r[j_idx]\n            \n            row_idx = np.arange(k, k + n_overlap)\n            jac[row_idx, 3 * i_idx] = 2 * dx\n            jac[row_idx, 3 * j_idx] = -2 * dx\n            jac[row_idx, 3 * i_idx + 1] = 2 * dy\n            jac[row_idx, 3 * j_idx + 1] = -2 * dy\n            jac[row_idx, 3 * i_idx + 2] = -2 * rs\n            jac[row_idx, 3 * j_idx + 2] = -2 * rs\n            return jac\n\n        return {'type': 'ineq', 'fun': cons_f, 'jac': cons_j}\n\n    # Use Sobol sequence for initialization to ensure good spread\n    def get_initial_vars(seed):\n        try:\n            from scipy.stats import qmc\n            sampler = qmc.Sobol(d=2, seed=seed)\n            points = sampler.random(n=32)[:n]\n        except (ImportError, AttributeError):\n            np.random.seed(seed)\n            points = np.random.rand(n, 2)\n        \n        # Start with small radii to simplify initial feasibility\n        r_init = np.full(n, 0.02)\n        vars = np.zeros(3 * n)\n        vars[0::3] = points[:, 0]\n        vars[1::3] = points[:, 1]\n        vars[2::3] = r_init\n        return vars\n\n    # Custom perturbation step for Basin-hopping\n    def my_step(x):\n        x = x.copy()\n        # Perturb centers and radii slightly\n        x[0::3] += np.random.normal(0, 0.03, n)\n        x[1::3] += np.random.normal(0, 0.03, n)\n        x[2::3] += np.random.normal(0, 0.005, n)\n        # Ensure variables stay within logical bounds\n        for i in range(n):\n            x[3*i] = np.clip(x[3*i], 0, 1)\n            x[3*i+1] = np.clip(x[3*i+1], 0, 1)\n            x[3*i+2] = np.clip(x[3*i+2], 0.0, 0.5)\n        return x\n\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * n\n    cons = get_constraints(n)\n    \n    # Global search using Basin-hopping with SLSQP as the local minimizer\n    initial_vars = get_initial_vars(seed=42)\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'bounds': bounds,\n        'constraints': cons,\n        'jac': True,\n        'options': {'maxiter': 100}\n    }\n    \n    # Run Basin-hopping; T is tuned for objective scale (~2.6)\n    res = basinhopping(\n        obj_func,\n        initial_vars,\n        minimizer_kwargs=minimizer_kwargs,\n        niter=12,\n        take_step=my_step,\n        T=0.015,\n        seed=42\n    )\n    \n    # Final polishing of the best result found during Basin-hopping\n    res_final = minimize(\n        obj_func,\n        res.x,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=cons,\n        jac=True,\n        options={'maxiter': 250}\n    )\n    \n    final_vars = res_final.x\n    sum_radii = -res_final.fun\n    \n    # Construct final outputs\n    centers = np.column_stack((final_vars[0::3], final_vars[1::3]))\n    radii = final_vars[2::3]\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 1.1481430530548096,
    "error": "error: All inputs to slsqp must be of type numpy.float64, except \"indices\" which must be of numpy.int32."
  },
  "prompt": "Create a robust multi-start optimizer that uses a combination of 'Basin-hopping' and 'SLSQP'. For initialization, use a Sobol sequence to ensure better coverage of the unit square compared to uniform random sampling. Optimize the sum of radii directly.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start optimizer combining Basin-hopping and SLSQP with Sobol initialization.\n    \"\"\"\n    n = 26\n    \n    # Objective function: minimize -sum(radii) to maximize sum(radii)\n    def obj_func(vars):\n        # vars layout: [x0, y0, r0, x1, y1, r1, ..., xN-1, yN-1, rN-1]\n        r = vars[2::3]\n        return -np.sum(r), np.tile([0, 0, -1], n)\n\n    # Constraints: circle containment in unit square and non-overlapping circles\n    def get_constraints(n_circles):\n        def cons_f(vars):\n            x = vars[0::3]\n            y = vars[1::3]\n            r = vars[2::3]\n            \n            # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n            c_square = np.zeros(4 * n_circles)\n            c_square[0::4] = x - r\n            c_square[1::4] = 1.0 - x - r\n            c_square[2::4] = y - r\n            c_square[3::4] = 1.0 - y - r\n            \n            # Non-overlapping constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n            dx = x[:, np.newaxis] - x[np.newaxis, :]\n            dy = y[:, np.newaxis] - y[np.newaxis, :]\n            dist_sq = dx**2 + dy**2\n            r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n            r_sum_sq = r_sum**2\n            \n            indices = np.triu_indices(n_circles, k=1)\n            c_overlap = dist_sq[indices] - r_sum_sq[indices]\n            \n            return np.concatenate([c_square, c_overlap])\n\n        def cons_j(vars):\n            x = vars[0::3]\n            y = vars[1::3]\n            r = vars[2::3]\n            n_overlap = n_circles * (n_circles - 1) // 2\n            jac = np.zeros((4 * n_circles + n_overlap, 3 * n_circles))\n            \n            # Gradients for square boundary constraints\n            for i in range(n_circles):\n                jac[4*i, 3*i], jac[4*i, 3*i+2] = 1, -1\n                jac[4*i+1, 3*i], jac[4*i+1, 3*i+2] = -1, -1\n                jac[4*i+2, 3*i+1], jac[4*i+2, 3*i+2] = 1, -1\n                jac[4*i+3, 3*i+1], jac[4*i+3, 3*i+2] = -1, -1\n                \n            # Gradients for overlap constraints\n            k = 4 * n_circles\n            i_idx, j_idx = np.triu_indices(n_circles, k=1)\n            dx = x[i_idx] - x[j_idx]\n            dy = y[i_idx] - y[j_idx]\n            rs = r[i_idx] + r[j_idx]\n            \n            row_idx = np.arange(k, k + n_overlap)\n            jac[row_idx, 3 * i_idx] = 2 * dx\n            jac[row_idx, 3 * j_idx] = -2 * dx\n            jac[row_idx, 3 * i_idx + 1] = 2 * dy\n            jac[row_idx, 3 * j_idx + 1] = -2 * dy\n            jac[row_idx, 3 * i_idx + 2] = -2 * rs\n            jac[row_idx, 3 * j_idx + 2] = -2 * rs\n            return jac\n\n        return {'type': 'ineq', 'fun': cons_f, 'jac': cons_j}\n\n    # Use Sobol sequence for initialization to ensure good spread\n    def get_initial_vars(seed):\n        try:\n            from scipy.stats import qmc\n            sampler = qmc.Sobol(d=2, seed=seed)\n            points = sampler.random(n=32)[:n]\n        except (ImportError, AttributeError):\n            np.random.seed(seed)\n            points = np.random.rand(n, 2)\n        \n        # Start with small radii to simplify initial feasibility\n        r_init = np.full(n, 0.02)\n        vars = np.zeros(3 * n)\n        vars[0::3] = points[:, 0]\n        vars[1::3] = points[:, 1]\n        vars[2::3] = r_init\n        return vars\n\n    # Custom perturbation step for Basin-hopping\n    def my_step(x):\n        x = x.copy()\n        # Perturb centers and radii slightly\n        x[0::3] += np.random.normal(0, 0.03, n)\n        x[1::3] += np.random.normal(0, 0.03, n)\n        x[2::3] += np.random.normal(0, 0.005, n)\n        # Ensure variables stay within logical bounds\n        for i in range(n):\n            x[3*i] = np.clip(x[3*i], 0, 1)\n            x[3*i+1] = np.clip(x[3*i+1], 0, 1)\n            x[3*i+2] = np.clip(x[3*i+2], 0.0, 0.5)\n        return x\n\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * n\n    cons = get_constraints(n)\n    \n    # Global search using Basin-hopping with SLSQP as the local minimizer\n    initial_vars = get_initial_vars(seed=42)\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'bounds': bounds,\n        'constraints': cons,\n        'jac': True,\n        'options': {'maxiter': 100}\n    }\n    \n    # Run Basin-hopping; T is tuned for objective scale (~2.6)\n    res = basinhopping(\n        obj_func,\n        initial_vars,\n        minimizer_kwargs=minimizer_kwargs,\n        niter=12,\n        take_step=my_step,\n        T=0.015,\n        seed=42\n    )\n    \n    # Final polishing of the best result found during Basin-hopping\n    res_final = minimize(\n        obj_func,\n        res.x,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=cons,\n        jac=True,\n        options={'maxiter': 250}\n    )\n    \n    final_vars = res_final.x\n    sum_radii = -res_final.fun\n    \n    # Construct final outputs\n    centers = np.column_stack((final_vars[0::3], final_vars[1::3]))\n    radii = final_vars[2::3]\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:33:29.976889",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 281,
        "candidates_token_count": 1883,
        "thoughts_token_count": 19010
      },
      "response_text_len": 5152
    }
  },
  "llm_call_duration_s": 111.84741299296729,
  "eval_duration_s": 1.14815369900316
}