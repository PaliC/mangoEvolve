{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a physics-based simulation for initial layout and SLSQP for refinement.\n    \"\"\"\n    N = 26\n\n    def get_pos(strategy, N):\n        \"\"\"Generates initial positions based on different strategies.\"\"\"\n        if strategy == 0:\n            # Distorted 5x5 grid + 1 circle\n            side = 5\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, side), np.linspace(0.1, 0.9, side))\n            pos = np.column_stack([x.ravel(), y.ravel()])\n            # Add 26th circle near the center\n            pos = np.vstack([pos, [0.5, 0.5]])\n            # Add jitter to allow the simulation to find a better configuration\n            pos += np.random.normal(0, 0.01, pos.shape)\n        else:\n            # Random initialization\n            pos = np.random.rand(N, 2)\n        return pos\n\n    def run_simulation(pos, N, steps=1000):\n        \"\"\"Physics-based simulation to grow circles and resolve overlaps.\"\"\"\n        r = np.full(N, 0.05)\n        dt = 0.02\n        for s in range(steps):\n            # Calculate pairwise distances\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1) + 1e-9)\n            min_dist = r[:, np.newaxis] + r[np.newaxis, :]\n            overlap = min_dist - dist\n            # Ignore self-interaction\n            np.fill_diagonal(overlap, 0)\n            \n            max_ov = np.max(overlap)\n            if max_ov > 0:\n                # Repulsive forces based on overlaps\n                force_dir = diff / dist[:, :, np.newaxis]\n                forces = np.sum(np.maximum(0, overlap)[:, :, np.newaxis] * force_dir, axis=1)\n                pos += forces * dt\n                # Slowly grow radii even during overlap resolution to maintain pressure\n                r += 0.0001\n            else:\n                # No overlaps, grow radii faster\n                r += 0.0005\n            \n            # Keep radii within reasonable bounds\n            r = np.clip(r, 0.001, 0.45)\n            # Boundary constraints: keep circles inside the unit square\n            for i in range(N):\n                pos[i] = np.clip(pos[i], r[i], 1-r[i])\n        return pos, r\n\n    best_sum = -1\n    best_vars = None\n\n    # Run multiple simulations with different initial conditions\n    for strategy in range(12):\n        pos = get_pos(strategy, N)\n        pos, r = run_simulation(pos, N)\n        \n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            # Flatten variables for scipy.optimize.minimize: [x_coords, y_coords, radii]\n            best_vars = np.concatenate([pos[:, 0], pos[:, 1], r])\n\n    # Objective function: maximize sum of radii (minimize negative sum)\n    def objective(vars):\n        return -np.sum(vars[2*N:])\n\n    # Inequality constraints: (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n    # and boundary constraints: r_i <= x_i <= 1 - r_i\n    def vectorized_constraints(vars, N):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:3*N]\n        \n        # Wall constraints (x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.)\n        c_wall = np.zeros(4*N)\n        c_wall[0::4] = x - r\n        c_wall[1::4] = 1 - x - r\n        c_wall[2::4] = y - r\n        c_wall[3::4] = 1 - y - r\n        \n        # Overlap constraints\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dr = r[:, np.newaxis] + r[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        min_dist_sq = dr**2\n        \n        # Use upper triangle to avoid redundant constraints\n        indices = np.triu_indices(N, k=1)\n        c_overlap = dist_sq[indices] - min_dist_sq[indices]\n        \n        return np.concatenate([c_wall, c_overlap])\n\n    # Constraint dictionary for SLSQP\n    cons = {'type': 'ineq', 'fun': vectorized_constraints, 'args': (N,)}\n    # Variable bounds: centers in [0, 1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    # Fine-tune the configuration using SLSQP\n    res = minimize(objective, best_vars, method='SLSQP', \n                   constraints=cons, bounds=bounds, \n                   options={'maxiter': 1000, 'ftol': 1e-10})\n    \n    # Extract final results\n    final_vars = res.x\n    centers = np.column_stack([final_vars[:N], final_vars[N:2*N]])\n    radii = final_vars[2*N:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, score = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.612916885443371,
    "eval_time": 6.241255760192871,
    "error": null
  },
  "prompt": "Design an algorithm to pack 26 circles in a unit square to maximize the sum of their radii.\n        Implement a physics-based simulation where circles exert repulsive forces on each other and are contained by the square's boundaries.\n        Slowly grow the radii while the simulation runs.\n        After the simulation reaches a quasi-equilibrium, use the resulting configuration as an initial guess for scipy.optimize.minimize with SLSQP to fine-tune the sum of radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a physics-based simulation for initial layout and SLSQP for refinement.\n    \"\"\"\n    N = 26\n\n    def get_pos(strategy, N):\n        \"\"\"Generates initial positions based on different strategies.\"\"\"\n        if strategy == 0:\n            # Distorted 5x5 grid + 1 circle\n            side = 5\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, side), np.linspace(0.1, 0.9, side))\n            pos = np.column_stack([x.ravel(), y.ravel()])\n            # Add 26th circle near the center\n            pos = np.vstack([pos, [0.5, 0.5]])\n            # Add jitter to allow the simulation to find a better configuration\n            pos += np.random.normal(0, 0.01, pos.shape)\n        else:\n            # Random initialization\n            pos = np.random.rand(N, 2)\n        return pos\n\n    def run_simulation(pos, N, steps=1000):\n        \"\"\"Physics-based simulation to grow circles and resolve overlaps.\"\"\"\n        r = np.full(N, 0.05)\n        dt = 0.02\n        for s in range(steps):\n            # Calculate pairwise distances\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1) + 1e-9)\n            min_dist = r[:, np.newaxis] + r[np.newaxis, :]\n            overlap = min_dist - dist\n            # Ignore self-interaction\n            np.fill_diagonal(overlap, 0)\n            \n            max_ov = np.max(overlap)\n            if max_ov > 0:\n                # Repulsive forces based on overlaps\n                force_dir = diff / dist[:, :, np.newaxis]\n                forces = np.sum(np.maximum(0, overlap)[:, :, np.newaxis] * force_dir, axis=1)\n                pos += forces * dt\n                # Slowly grow radii even during overlap resolution to maintain pressure\n                r += 0.0001\n            else:\n                # No overlaps, grow radii faster\n                r += 0.0005\n            \n            # Keep radii within reasonable bounds\n            r = np.clip(r, 0.001, 0.45)\n            # Boundary constraints: keep circles inside the unit square\n            for i in range(N):\n                pos[i] = np.clip(pos[i], r[i], 1-r[i])\n        return pos, r\n\n    best_sum = -1\n    best_vars = None\n\n    # Run multiple simulations with different initial conditions\n    for strategy in range(12):\n        pos = get_pos(strategy, N)\n        pos, r = run_simulation(pos, N)\n        \n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            # Flatten variables for scipy.optimize.minimize: [x_coords, y_coords, radii]\n            best_vars = np.concatenate([pos[:, 0], pos[:, 1], r])\n\n    # Objective function: maximize sum of radii (minimize negative sum)\n    def objective(vars):\n        return -np.sum(vars[2*N:])\n\n    # Inequality constraints: (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n    # and boundary constraints: r_i <= x_i <= 1 - r_i\n    def vectorized_constraints(vars, N):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:3*N]\n        \n        # Wall constraints (x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.)\n        c_wall = np.zeros(4*N)\n        c_wall[0::4] = x - r\n        c_wall[1::4] = 1 - x - r\n        c_wall[2::4] = y - r\n        c_wall[3::4] = 1 - y - r\n        \n        # Overlap constraints\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dr = r[:, np.newaxis] + r[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        min_dist_sq = dr**2\n        \n        # Use upper triangle to avoid redundant constraints\n        indices = np.triu_indices(N, k=1)\n        c_overlap = dist_sq[indices] - min_dist_sq[indices]\n        \n        return np.concatenate([c_wall, c_overlap])\n\n    # Constraint dictionary for SLSQP\n    cons = {'type': 'ineq', 'fun': vectorized_constraints, 'args': (N,)}\n    # Variable bounds: centers in [0, 1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    # Fine-tune the configuration using SLSQP\n    res = minimize(objective, best_vars, method='SLSQP', \n                   constraints=cons, bounds=bounds, \n                   options={'maxiter': 1000, 'ftol': 1e-10})\n    \n    # Extract final results\n    final_vars = res.x\n    centers = np.column_stack([final_vars[:N], final_vars[N:2*N]])\n    radii = final_vars[2*N:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, score = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:54:09.195957",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 324,
        "candidates_token_count": 1486,
        "thoughts_token_count": 20475
      },
      "response_text_len": 4622
    }
  },
  "llm_call_duration_s": 120.94111395301297,
  "eval_duration_s": 6.241270000929944
}