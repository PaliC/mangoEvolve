{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses basinhopping with SLSQP as the local minimizer and provides a Jacobian for speed.\n    \"\"\"\n    N = 26\n    \n    # Precompute indices for constraints and Jacobian\n    idx1, idx2 = np.triu_indices(N, k=1)\n    num_overlap = len(idx1)\n    row_offset = 4 * N\n    rows = np.arange(row_offset, row_offset + num_overlap)\n\n    def objective(params):\n        # params: [x0, y0, r0, x1, y1, r1, ...]\n        # We want to maximize the sum of radii, so minimize the negative sum.\n        return -np.sum(params[2::3])\n\n    def objective_jac(params):\n        # Gradient of -sum(r_i) with respect to (x_i, y_i, r_i)\n        # d(-sum(r))/dx_i = 0, d(-sum(r))/dy_i = 0, d(-sum(r))/dr_i = -1\n        jac = np.zeros(3 * N)\n        jac[2::3] = -1.0\n        return jac\n\n    def constraints_fn(params):\n        # params: [x0, y0, r0, x1, y1, r1, ...]\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        # We need to return an array where each element c_i >= 0\n        c = np.zeros(4 * N + num_overlap)\n        \n        # 1. Boundary constraints (4*N): x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        \n        # 2. Overlap constraints (N*(N-1)/2): dist^2 - (r1+r2)^2 >= 0\n        dist_sq = (x[idx1] - x[idx2])**2 + (y[idx1] - y[idx2])**2\n        r_sum_sq = (r[idx1] + r[idx2])**2\n        c[row_offset:] = dist_sq - r_sum_sq\n        \n        return c\n\n    def constraints_jac(params):\n        # Jacobian of the constraint function\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        # Matrix shape: (num_constraints, num_variables) = (429, 78)\n        jac = np.zeros((row_offset + num_overlap, 3 * N))\n        \n        # Boundary constraints gradients\n        for i in range(N):\n            # d(x_i - r_i)\n            jac[i, 3*i] = 1.0\n            jac[i, 3*i+2] = -1.0\n            # d(1 - x_i - r_i)\n            jac[N+i, 3*i] = -1.0\n            jac[N+i, 3*i+2] = -1.0\n            # d(y_i - r_i)\n            jac[2*N+i, 3*i+1] = 1.0\n            jac[2*N+i, 3*i+2] = -1.0\n            # d(1 - y_i - r_i)\n            jac[3*N+i, 3*i+1] = -1.0\n            jac[3*N+i, 3*i+2] = -1.0\n            \n        # Overlap constraints gradients\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        rs = r[idx1] + r[idx2]\n        \n        # Vectorized population of the overlap part of the Jacobian\n        jac[rows, 3*idx1] = 2 * dx\n        jac[rows, 3*idx1+1] = 2 * dy\n        jac[rows, 3*idx1+2] = -2 * rs\n        \n        jac[rows, 3*idx2] = -2 * dx\n        jac[rows, 3*idx2+1] = -2 * dy\n        jac[rows, 3*idx2+2] = -2 * rs\n        \n        return jac\n\n    # Initial guess: A jittered 5x5 grid plus one extra circle\n    grid_coords = np.linspace(0.15, 0.85, 5)\n    xv, yv = np.meshgrid(grid_coords, grid_coords)\n    x_init = xv.flatten()\n    y_init = yv.flatten()\n    # Add 26th point in a gap\n    x_init = np.append(x_init, 0.05)\n    y_init = np.append(y_init, 0.05)\n    \n    # Jitter to break symmetry\n    np.random.seed(42)\n    x_init = np.clip(x_init + np.random.normal(0, 0.01, N), 0.05, 0.95)\n    y_init = np.clip(y_init + np.random.normal(0, 0.01, N), 0.05, 0.95)\n    r_init = np.full(N, 0.04) # Start with a safe small radius\n    \n    initial_guess = np.zeros(3 * N)\n    initial_guess[0::3] = x_init\n    initial_guess[1::3] = y_init\n    initial_guess[2::3] = r_init\n\n    # SLSQP minimizer configuration\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'jac': objective_jac,\n        'constraints': {'type': 'ineq', 'fun': constraints_fn, 'jac': constraints_jac},\n        'bounds': [(0, 1), (0, 1), (0, 0.5)] * N,\n        'options': {'maxiter': 250}\n    }\n\n    # Optimization using basinhopping to explore the configuration space\n    # niter=12 is chosen to ensure completion within the 300s time limit\n    res = basinhopping(\n        objective, \n        initial_guess, \n        minimizer_kwargs=minimizer_kwargs, \n        niter=12, \n        stepsize=0.1, \n        T=0.1\n    )\n    \n    # Extract results\n    best_params = res.x\n    centers = best_params.reshape(N, 3)[:, :2]\n    radii = best_params.reshape(N, 3)[:, 2]\n    sum_radii = -res.fun\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.613121399045015,
    "eval_time": 21.415147304534912,
    "error": null
  },
  "prompt": "Design an algorithm to pack 26 circles in a unit square to maximize the sum of their radii.\n        Use scipy.optimize.basinhopping with SLSQP as the local minimizer.\n        The state vector should include both centers (x, y) and radii (r).\n        Ensure that the constraints (within square and no overlap) are handled via the 'constraints' parameter of the SLSQP minimizer.\n        Provide a good initial guess, perhaps a jittered grid or a set of random points.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses basinhopping with SLSQP as the local minimizer and provides a Jacobian for speed.\n    \"\"\"\n    N = 26\n    \n    # Precompute indices for constraints and Jacobian\n    idx1, idx2 = np.triu_indices(N, k=1)\n    num_overlap = len(idx1)\n    row_offset = 4 * N\n    rows = np.arange(row_offset, row_offset + num_overlap)\n\n    def objective(params):\n        # params: [x0, y0, r0, x1, y1, r1, ...]\n        # We want to maximize the sum of radii, so minimize the negative sum.\n        return -np.sum(params[2::3])\n\n    def objective_jac(params):\n        # Gradient of -sum(r_i) with respect to (x_i, y_i, r_i)\n        # d(-sum(r))/dx_i = 0, d(-sum(r))/dy_i = 0, d(-sum(r))/dr_i = -1\n        jac = np.zeros(3 * N)\n        jac[2::3] = -1.0\n        return jac\n\n    def constraints_fn(params):\n        # params: [x0, y0, r0, x1, y1, r1, ...]\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        # We need to return an array where each element c_i >= 0\n        c = np.zeros(4 * N + num_overlap)\n        \n        # 1. Boundary constraints (4*N): x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        \n        # 2. Overlap constraints (N*(N-1)/2): dist^2 - (r1+r2)^2 >= 0\n        dist_sq = (x[idx1] - x[idx2])**2 + (y[idx1] - y[idx2])**2\n        r_sum_sq = (r[idx1] + r[idx2])**2\n        c[row_offset:] = dist_sq - r_sum_sq\n        \n        return c\n\n    def constraints_jac(params):\n        # Jacobian of the constraint function\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        # Matrix shape: (num_constraints, num_variables) = (429, 78)\n        jac = np.zeros((row_offset + num_overlap, 3 * N))\n        \n        # Boundary constraints gradients\n        for i in range(N):\n            # d(x_i - r_i)\n            jac[i, 3*i] = 1.0\n            jac[i, 3*i+2] = -1.0\n            # d(1 - x_i - r_i)\n            jac[N+i, 3*i] = -1.0\n            jac[N+i, 3*i+2] = -1.0\n            # d(y_i - r_i)\n            jac[2*N+i, 3*i+1] = 1.0\n            jac[2*N+i, 3*i+2] = -1.0\n            # d(1 - y_i - r_i)\n            jac[3*N+i, 3*i+1] = -1.0\n            jac[3*N+i, 3*i+2] = -1.0\n            \n        # Overlap constraints gradients\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        rs = r[idx1] + r[idx2]\n        \n        # Vectorized population of the overlap part of the Jacobian\n        jac[rows, 3*idx1] = 2 * dx\n        jac[rows, 3*idx1+1] = 2 * dy\n        jac[rows, 3*idx1+2] = -2 * rs\n        \n        jac[rows, 3*idx2] = -2 * dx\n        jac[rows, 3*idx2+1] = -2 * dy\n        jac[rows, 3*idx2+2] = -2 * rs\n        \n        return jac\n\n    # Initial guess: A jittered 5x5 grid plus one extra circle\n    grid_coords = np.linspace(0.15, 0.85, 5)\n    xv, yv = np.meshgrid(grid_coords, grid_coords)\n    x_init = xv.flatten()\n    y_init = yv.flatten()\n    # Add 26th point in a gap\n    x_init = np.append(x_init, 0.05)\n    y_init = np.append(y_init, 0.05)\n    \n    # Jitter to break symmetry\n    np.random.seed(42)\n    x_init = np.clip(x_init + np.random.normal(0, 0.01, N), 0.05, 0.95)\n    y_init = np.clip(y_init + np.random.normal(0, 0.01, N), 0.05, 0.95)\n    r_init = np.full(N, 0.04) # Start with a safe small radius\n    \n    initial_guess = np.zeros(3 * N)\n    initial_guess[0::3] = x_init\n    initial_guess[1::3] = y_init\n    initial_guess[2::3] = r_init\n\n    # SLSQP minimizer configuration\n    minimizer_kwargs = {\n        'method': 'SLSQP',\n        'jac': objective_jac,\n        'constraints': {'type': 'ineq', 'fun': constraints_fn, 'jac': constraints_jac},\n        'bounds': [(0, 1), (0, 1), (0, 0.5)] * N,\n        'options': {'maxiter': 250}\n    }\n\n    # Optimization using basinhopping to explore the configuration space\n    # niter=12 is chosen to ensure completion within the 300s time limit\n    res = basinhopping(\n        objective, \n        initial_guess, \n        minimizer_kwargs=minimizer_kwargs, \n        niter=12, \n        stepsize=0.1, \n        T=0.1\n    )\n    \n    # Extract results\n    best_params = res.x\n    centers = best_params.reshape(N, 3)[:, :2]\n    radii = best_params.reshape(N, 3)[:, 2]\n    sum_radii = -res.fun\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:54:42.429484",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 335,
        "candidates_token_count": 1807,
        "thoughts_token_count": 22351
      },
      "response_text_len": 4549
    }
  },
  "llm_call_duration_s": 139.00298858294263,
  "eval_duration_s": 21.415156907052733
}