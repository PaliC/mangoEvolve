{
  "trial_id": "trial_3_3",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The method uses a force-directed (physics-based) approach to find a good initial\n    configuration, followed by a constrained optimization using SLSQP.\n    \"\"\"\n    N = 26\n\n    def get_halton(n, base):\n        \"\"\"Generates a Halton sequence for low-discrepancy initial positions.\"\"\"\n        seq = []\n        for i in range(1, n + 1):\n            f, r = 1, 0\n            while i > 0:\n                f /= base\n                r += f * (i % base)\n                i //= base\n            seq.append(r)\n        return np.array(seq)\n\n    # 1. Initialize 26 centers using a Halton sequence for even distribution\n    x = get_halton(N, 2)\n    y = get_halton(N, 3)\n    \n    # Start with a small radius for the force-directed phase\n    r_val = 0.05\n    \n    # 2. Force-directed simulation: repel circles from each other and the boundaries\n    # This phase spreads the circles to find a good structural layout for packing.\n    for _ in range(1000):\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        d_sq = dx**2 + dy**2\n        d = np.sqrt(d_sq) + 1e-12  # Avoid division by zero\n        \n        # During this phase, we assume equal radii to simplify structure finding\n        dr = 2 * r_val\n        overlap = dr - d\n        overlap[overlap < 0] = 0\n        \n        # Calculate repulsion forces between overlapping circles\n        mask = overlap > 0\n        fx = np.zeros(N)\n        fy = np.zeros(N)\n        if np.any(mask):\n            # Normalize force by distance to get a unit direction vector\n            fx = np.sum((overlap / d) * dx, axis=1)\n            fy = np.sum((overlap / d) * dy, axis=1)\n        \n        # Update positions based on forces\n        x += fx * 0.1\n        y += fy * 0.1\n        \n        # 3. Boundary constraints: Keep circle centers within [r, 1-r]\n        x = np.clip(x, r_val, 1 - r_val)\n        y = np.clip(y, r_val, 1 - r_val)\n        \n        # Gradually increase the 'natural' radius while resolving overlaps\n        if _ % 2 == 0:\n            r_val += 0.0001\n            \n    # 4. Refine the configuration using SLSQP optimization to maximize sum(radii)\n    # Variables: [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n    p0 = np.zeros(3*N)\n    p0[0::3] = x\n    p0[1::3] = y\n    p0[2::3] = r_val\n    \n    # Set bounds for all variables (x, y, r)\n    bounds = []\n    for _ in range(N):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n        \n    # Precompute indices for the 325 non-overlap constraints (pairs i, j)\n    triu_indices = np.triu_indices(N, k=1)\n\n    def objective(p):\n        # Minimize the negative sum of radii to maximize the sum\n        return -np.sum(p[2::3])\n\n    def constraints(p):\n        x_c = p[0::3]\n        y_c = p[1::3]\n        r_c = p[2::3]\n        \n        # Boundary constraints: Circle must be entirely inside the unit square\n        # x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_b = np.concatenate([x_c - r_c, 1 - x_c - r_c, y_c - r_c, 1 - y_c - r_c])\n        \n        # Non-overlap constraints: Distance between centers must be >= sum of radii\n        # Use squared distance (xi-xj)^2 + (yi-yj)^2 >= (ri+rj)^2 to avoid sqrt gradient issues\n        dx = x_c[:, None] - x_c[None, :]\n        dy = y_c[:, None] - y_c[None, :]\n        dr = r_c[:, None] + r_c[None, :]\n        dist_sq = dx**2 + dy**2\n        overlap_sq = dr**2\n        c_o = dist_sq[triu_indices] - overlap_sq[triu_indices]\n        \n        return np.concatenate([c_b, c_o])\n\n    # Run SLSQP (Sequential Least Squares Programming)\n    res = minimize(\n        objective, \n        p0, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-10}\n    )\n    \n    # Extract final centers, radii, and calculate the total sum\n    final_params = res.x\n    centers = final_params.reshape(N, 3)[:, :2]\n    radii = final_params.reshape(N, 3)[:, 2]\n    sum_radii = -res.fun\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.623775117219771,
    "eval_time": 0.8182170391082764,
    "error": null
  },
  "prompt": "\nImplement a force-directed (physics-based) approach to pack 26 circles in a unit square.\n1. Initialize 26 centers using a low-discrepancy sequence (e.g., Halton).\n2. Simulate a system where circles repel each other and the boundaries.\n3. Gradually increase the 'natural' radius of each circle while resolving overlaps.\n4. Once a stable configuration is found, use scipy.optimize.minimize (SLSQP) to maximize the sum of radii.\n5. The objective function is -sum(radii).\n6. Constraints: (x-xi)^2 + (y-yi)^2 >= (ri+rj)^2 and boundary constraints.\nEnsure the code is robust and handles the constraints strictly.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The method uses a force-directed (physics-based) approach to find a good initial\n    configuration, followed by a constrained optimization using SLSQP.\n    \"\"\"\n    N = 26\n\n    def get_halton(n, base):\n        \"\"\"Generates a Halton sequence for low-discrepancy initial positions.\"\"\"\n        seq = []\n        for i in range(1, n + 1):\n            f, r = 1, 0\n            while i > 0:\n                f /= base\n                r += f * (i % base)\n                i //= base\n            seq.append(r)\n        return np.array(seq)\n\n    # 1. Initialize 26 centers using a Halton sequence for even distribution\n    x = get_halton(N, 2)\n    y = get_halton(N, 3)\n    \n    # Start with a small radius for the force-directed phase\n    r_val = 0.05\n    \n    # 2. Force-directed simulation: repel circles from each other and the boundaries\n    # This phase spreads the circles to find a good structural layout for packing.\n    for _ in range(1000):\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        d_sq = dx**2 + dy**2\n        d = np.sqrt(d_sq) + 1e-12  # Avoid division by zero\n        \n        # During this phase, we assume equal radii to simplify structure finding\n        dr = 2 * r_val\n        overlap = dr - d\n        overlap[overlap < 0] = 0\n        \n        # Calculate repulsion forces between overlapping circles\n        mask = overlap > 0\n        fx = np.zeros(N)\n        fy = np.zeros(N)\n        if np.any(mask):\n            # Normalize force by distance to get a unit direction vector\n            fx = np.sum((overlap / d) * dx, axis=1)\n            fy = np.sum((overlap / d) * dy, axis=1)\n        \n        # Update positions based on forces\n        x += fx * 0.1\n        y += fy * 0.1\n        \n        # 3. Boundary constraints: Keep circle centers within [r, 1-r]\n        x = np.clip(x, r_val, 1 - r_val)\n        y = np.clip(y, r_val, 1 - r_val)\n        \n        # Gradually increase the 'natural' radius while resolving overlaps\n        if _ % 2 == 0:\n            r_val += 0.0001\n            \n    # 4. Refine the configuration using SLSQP optimization to maximize sum(radii)\n    # Variables: [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n    p0 = np.zeros(3*N)\n    p0[0::3] = x\n    p0[1::3] = y\n    p0[2::3] = r_val\n    \n    # Set bounds for all variables (x, y, r)\n    bounds = []\n    for _ in range(N):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n        \n    # Precompute indices for the 325 non-overlap constraints (pairs i, j)\n    triu_indices = np.triu_indices(N, k=1)\n\n    def objective(p):\n        # Minimize the negative sum of radii to maximize the sum\n        return -np.sum(p[2::3])\n\n    def constraints(p):\n        x_c = p[0::3]\n        y_c = p[1::3]\n        r_c = p[2::3]\n        \n        # Boundary constraints: Circle must be entirely inside the unit square\n        # x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_b = np.concatenate([x_c - r_c, 1 - x_c - r_c, y_c - r_c, 1 - y_c - r_c])\n        \n        # Non-overlap constraints: Distance between centers must be >= sum of radii\n        # Use squared distance (xi-xj)^2 + (yi-yj)^2 >= (ri+rj)^2 to avoid sqrt gradient issues\n        dx = x_c[:, None] - x_c[None, :]\n        dy = y_c[:, None] - y_c[None, :]\n        dr = r_c[:, None] + r_c[None, :]\n        dist_sq = dx**2 + dy**2\n        overlap_sq = dr**2\n        c_o = dist_sq[triu_indices] - overlap_sq[triu_indices]\n        \n        return np.concatenate([c_b, c_o])\n\n    # Run SLSQP (Sequential Least Squares Programming)\n    res = minimize(\n        objective, \n        p0, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-10}\n    )\n    \n    # Extract final centers, radii, and calculate the total sum\n    final_params = res.x\n    centers = final_params.reshape(N, 3)[:, :2]\n    radii = final_params.reshape(N, 3)[:, 2]\n    sum_radii = -res.fun\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = run_packing()\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:16:57.889724",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 391,
        "candidates_token_count": 1424,
        "thoughts_token_count": 13251
      },
      "response_text_len": 4225
    }
  },
  "llm_call_duration_s": 87.48289673996624,
  "eval_duration_s": 0.8182268480304629
}