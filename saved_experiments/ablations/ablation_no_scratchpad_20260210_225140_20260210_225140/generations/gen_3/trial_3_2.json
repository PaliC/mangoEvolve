{
  "trial_id": "trial_3_2",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a force-directed initialization followed by SLSQP optimization.\n    \"\"\"\n    N = 26\n    np.random.seed(42)\n\n    def halton(n, base):\n        res = []\n        for i in range(1, n + 1):\n            f, r = 1, 0\n            while i > 0:\n                f /= base\n                r += f * (i % base)\n                i //= base\n            res.append(r)\n        return np.array(res)\n\n    # 1. Initialization using Halton sequence\n    x = halton(N, 2)\n    y = halton(N, 3)\n    p = np.column_stack((x, y))\n    # Add small jitter to break symmetry\n    p += np.random.normal(0, 0.001, p.shape)\n    r = 0.01\n    \n    # 2. Force-directed simulation to find a good initial layout\n    # This phase aims for a stable equal-radius configuration.\n    for step in range(2000):\n        # Calculate all-pairs distances\n        dx = p[:, np.newaxis, 0] - p[np.newaxis, :, 0]\n        dy = p[:, np.newaxis, 1] - p[np.newaxis, :, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        # Upper triangle indices for pairs (i, j) where i < j\n        ii, jj = np.triu_indices(N, k=1)\n        \n        # Check for overlaps at current radius r\n        overlap = (2 * r) - dist[ii, jj]\n        mask = overlap > 0\n        \n        if np.any(mask):\n            mi = ii[mask]\n            mj = jj[mask]\n            for i, j in zip(mi, mj):\n                d_ij = dist[i, j]\n                if d_ij < 1e-9:\n                    # Resolve exact overlaps with random displacement\n                    p[i] += np.random.normal(0, 0.01, 2)\n                else:\n                    # Move circles apart proportionally\n                    push = (2 * r - d_ij) * (p[i] - p[j]) / d_ij * 0.5\n                    p[i] += push\n                    p[j] -= push\n        \n        # Gradually increase the radius while staying within the unit square\n        r += 0.000045\n        p = np.clip(p, r, 1 - r)\n\n    # 3. SLSQP Optimization to maximize the sum of radii\n    # Variables: [x1...x26, y1...y26, R1...R26]\n    x0 = np.concatenate([p[:, 0], p[:, 1], np.full(N, r)])\n\n    def objective(vars):\n        # Maximize sum(R_i) <=> Minimize -sum(R_i)\n        return -np.sum(vars[2*N:])\n\n    def jac_objective(vars):\n        jac = np.zeros(3*N)\n        jac[2*N:] = -1.0\n        return jac\n\n    def constraints(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        R = vars[2*N:]\n        \n        # Non-overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 - (R_i + R_j)^2 >= 0\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dR = R[:, np.newaxis] + R[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        ii, jj = np.triu_indices(N, k=1)\n        non_overlap = dist_sq[ii, jj] - dR[ii, jj]**2\n        \n        # Boundary constraints: x_i - R_i >= 0, 1 - x_i - R_i >= 0, etc.\n        b1 = x - R\n        b2 = 1.0 - x - R\n        b3 = y - R\n        b4 = 1.0 - y - R\n        \n        return np.concatenate([non_overlap, b1, b2, b3, b4])\n\n    def jac_constraints(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        R = vars[2*N:]\n        \n        num_non_overlap = N * (N - 1) // 2\n        jac = np.zeros((num_non_overlap + 4 * N, 3 * N))\n        \n        ii, jj = np.triu_indices(N, k=1)\n        dx = x[ii] - x[jj]\n        dy = y[ii] - y[jj]\n        dR = R[ii] + R[jj]\n        \n        # Jacobian for non-overlap constraints\n        rows = np.arange(num_non_overlap)\n        jac[rows, ii] = 2 * dx\n        jac[rows, jj] = -2 * dx\n        jac[rows, N + ii] = 2 * dy\n        jac[rows, N + jj] = -2 * dy\n        jac[rows, 2 * N + ii] = -2 * dR\n        jac[rows, 2 * N + jj] = -2 * dR\n        \n        # Jacobian for boundary constraints\n        row = num_non_overlap\n        for i in range(N):\n            # x_i - R_i >= 0\n            jac[row, i] = 1; jac[row, 2 * N + i] = -1; row += 1\n            # 1 - x_i - R_i >= 0\n            jac[row, i] = -1; jac[row, 2 * N + i] = -1; row += 1\n            # y_i - R_i >= 0\n            jac[row, N + i] = 1; jac[row, 2 * N + i] = -1; row += 1\n            # 1 - y_i - R_i >= 0\n            jac[row, N + i] = -1; jac[row, 2 * N + i] = -1; row += 1\n            \n        return jac\n\n    # Bounds for the variables\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n\n    # Run the optimization\n    res = minimize(objective, x0, method='SLSQP', jac=jac_objective,\n                   constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                   bounds=bounds,\n                   options={'maxiter': 1000, 'ftol': 1e-10})\n    \n    # Extract final configuration\n    final_vars = res.x\n    final_centers = np.column_stack((final_vars[:N], final_vars[N:2*N]))\n    final_radii = final_vars[2*N:]\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = run_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 7.224920272827148,
    "error": "Circle 0 at (0.9233449051067364, 0.41545816886477394) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "\nImplement a force-directed (physics-based) approach to pack 26 circles in a unit square.\n1. Initialize 26 centers using a low-discrepancy sequence (e.g., Halton).\n2. Simulate a system where circles repel each other and the boundaries.\n3. Gradually increase the 'natural' radius of each circle while resolving overlaps.\n4. Once a stable configuration is found, use scipy.optimize.minimize (SLSQP) to maximize the sum of radii.\n5. The objective function is -sum(radii).\n6. Constraints: (x-xi)^2 + (y-yi)^2 >= (ri+rj)^2 and boundary constraints.\nEnsure the code is robust and handles the constraints strictly.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a force-directed initialization followed by SLSQP optimization.\n    \"\"\"\n    N = 26\n    np.random.seed(42)\n\n    def halton(n, base):\n        res = []\n        for i in range(1, n + 1):\n            f, r = 1, 0\n            while i > 0:\n                f /= base\n                r += f * (i % base)\n                i //= base\n            res.append(r)\n        return np.array(res)\n\n    # 1. Initialization using Halton sequence\n    x = halton(N, 2)\n    y = halton(N, 3)\n    p = np.column_stack((x, y))\n    # Add small jitter to break symmetry\n    p += np.random.normal(0, 0.001, p.shape)\n    r = 0.01\n    \n    # 2. Force-directed simulation to find a good initial layout\n    # This phase aims for a stable equal-radius configuration.\n    for step in range(2000):\n        # Calculate all-pairs distances\n        dx = p[:, np.newaxis, 0] - p[np.newaxis, :, 0]\n        dy = p[:, np.newaxis, 1] - p[np.newaxis, :, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        # Upper triangle indices for pairs (i, j) where i < j\n        ii, jj = np.triu_indices(N, k=1)\n        \n        # Check for overlaps at current radius r\n        overlap = (2 * r) - dist[ii, jj]\n        mask = overlap > 0\n        \n        if np.any(mask):\n            mi = ii[mask]\n            mj = jj[mask]\n            for i, j in zip(mi, mj):\n                d_ij = dist[i, j]\n                if d_ij < 1e-9:\n                    # Resolve exact overlaps with random displacement\n                    p[i] += np.random.normal(0, 0.01, 2)\n                else:\n                    # Move circles apart proportionally\n                    push = (2 * r - d_ij) * (p[i] - p[j]) / d_ij * 0.5\n                    p[i] += push\n                    p[j] -= push\n        \n        # Gradually increase the radius while staying within the unit square\n        r += 0.000045\n        p = np.clip(p, r, 1 - r)\n\n    # 3. SLSQP Optimization to maximize the sum of radii\n    # Variables: [x1...x26, y1...y26, R1...R26]\n    x0 = np.concatenate([p[:, 0], p[:, 1], np.full(N, r)])\n\n    def objective(vars):\n        # Maximize sum(R_i) <=> Minimize -sum(R_i)\n        return -np.sum(vars[2*N:])\n\n    def jac_objective(vars):\n        jac = np.zeros(3*N)\n        jac[2*N:] = -1.0\n        return jac\n\n    def constraints(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        R = vars[2*N:]\n        \n        # Non-overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 - (R_i + R_j)^2 >= 0\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dR = R[:, np.newaxis] + R[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        ii, jj = np.triu_indices(N, k=1)\n        non_overlap = dist_sq[ii, jj] - dR[ii, jj]**2\n        \n        # Boundary constraints: x_i - R_i >= 0, 1 - x_i - R_i >= 0, etc.\n        b1 = x - R\n        b2 = 1.0 - x - R\n        b3 = y - R\n        b4 = 1.0 - y - R\n        \n        return np.concatenate([non_overlap, b1, b2, b3, b4])\n\n    def jac_constraints(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        R = vars[2*N:]\n        \n        num_non_overlap = N * (N - 1) // 2\n        jac = np.zeros((num_non_overlap + 4 * N, 3 * N))\n        \n        ii, jj = np.triu_indices(N, k=1)\n        dx = x[ii] - x[jj]\n        dy = y[ii] - y[jj]\n        dR = R[ii] + R[jj]\n        \n        # Jacobian for non-overlap constraints\n        rows = np.arange(num_non_overlap)\n        jac[rows, ii] = 2 * dx\n        jac[rows, jj] = -2 * dx\n        jac[rows, N + ii] = 2 * dy\n        jac[rows, N + jj] = -2 * dy\n        jac[rows, 2 * N + ii] = -2 * dR\n        jac[rows, 2 * N + jj] = -2 * dR\n        \n        # Jacobian for boundary constraints\n        row = num_non_overlap\n        for i in range(N):\n            # x_i - R_i >= 0\n            jac[row, i] = 1; jac[row, 2 * N + i] = -1; row += 1\n            # 1 - x_i - R_i >= 0\n            jac[row, i] = -1; jac[row, 2 * N + i] = -1; row += 1\n            # y_i - R_i >= 0\n            jac[row, N + i] = 1; jac[row, 2 * N + i] = -1; row += 1\n            # 1 - y_i - R_i >= 0\n            jac[row, N + i] = -1; jac[row, 2 * N + i] = -1; row += 1\n            \n        return jac\n\n    # Bounds for the variables\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n\n    # Run the optimization\n    res = minimize(objective, x0, method='SLSQP', jac=jac_objective,\n                   constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                   bounds=bounds,\n                   options={'maxiter': 1000, 'ftol': 1e-10})\n    \n    # Extract final configuration\n    final_vars = res.x\n    final_centers = np.column_stack((final_vars[:N], final_vars[N:2*N]))\n    final_radii = final_vars[2*N:]\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:17:36.282704",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 391,
        "candidates_token_count": 1825,
        "thoughts_token_count": 20195
      },
      "response_text_len": 5019
    }
  },
  "llm_call_duration_s": 119.46725115203299,
  "eval_duration_s": 7.224930881988257
}