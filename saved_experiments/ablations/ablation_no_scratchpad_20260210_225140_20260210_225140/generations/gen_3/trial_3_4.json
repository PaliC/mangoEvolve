{
  "trial_id": "trial_3_4",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii.\n    Uses a multi-start SLSQP strategy with shaking for local optimization.\n    \"\"\"\n    n_circles = 26\n    start_time = time.time()\n    \n    # Precompute indices for efficiency in constraint functions\n    idx_tri = np.triu_indices(n_circles, k=1)\n    n_overlap = n_circles * (n_circles - 1) // 2\n    k_idx = np.arange(n_overlap)\n    row_idx, col_idx = idx_tri\n\n    def objective(vars):\n        # vars: [x0...xn-1, y0...yn-1, r0...rn-1]\n        # Maximize sum of radii = Minimize -sum(radii)\n        return -np.sum(vars[2*n_circles:])\n\n    def con_func(vars):\n        x = vars[:n_circles]\n        y = vars[n_circles:2*n_circles]\n        r = vars[2*n_circles:]\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        dx = x[row_idx] - x[col_idx]\n        dy = y[row_idx] - y[col_idx]\n        dr = r[row_idx] + r[col_idx]\n        overlap_cons = dx**2 + dy**2 - dr**2\n        \n        # Boundary constraints:\n        # Each circle must be inside the square [0, 1]x[0, 1]\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        return np.concatenate([\n            overlap_cons,\n            x - r,\n            1.0 - x - r,\n            y - r,\n            1.0 - y - r\n        ])\n\n    def con_jac(vars):\n        x = vars[:n_circles]\n        y = vars[n_circles:2*n_circles]\n        r = vars[2*n_circles:]\n        \n        # Dense Jacobian matrix for SLSQP\n        jac = np.zeros((n_overlap + 4 * n_circles, 3 * n_circles))\n        \n        dx = x[row_idx] - x[col_idx]\n        dy = y[row_idx] - y[col_idx]\n        dr = r[row_idx] + r[col_idx]\n        \n        # Overlap jacobian entries (derivatives of dx^2 + dy^2 - dr^2)\n        jac[k_idx, row_idx] = 2 * dx\n        jac[k_idx, col_idx] = -2 * dx\n        jac[k_idx, n_circles + row_idx] = 2 * dy\n        jac[k_idx, n_circles + col_idx] = -2 * dy\n        jac[k_idx, 2 * n_circles + row_idx] = -2 * dr\n        jac[k_idx, 2 * n_circles + col_idx] = -2 * dr\n        \n        # Boundary jacobian entries\n        # x - r >= 0: dx=1, dr=-1\n        jac[n_overlap : n_overlap + n_circles, :n_circles] = np.eye(n_circles)\n        jac[n_overlap : n_overlap + n_circles, 2 * n_circles :] = -np.eye(n_circles)\n        \n        # 1 - x - r >= 0: dx=-1, dr=-1\n        jac[n_overlap + n_circles : n_overlap + 2 * n_circles, :n_circles] = -np.eye(n_circles)\n        jac[n_overlap + n_circles : n_overlap + 2 * n_circles, 2 * n_circles :] = -np.eye(n_circles)\n        \n        # y - r >= 0: dy=1, dr=-1\n        jac[n_overlap + 2 * n_circles : n_overlap + 3 * n_circles, n_circles : 2 * n_circles] = np.eye(n_circles)\n        jac[n_overlap + 2 * n_circles : n_overlap + 3 * n_circles, 2 * n_circles :] = -np.eye(n_circles)\n        \n        # 1 - y - r >= 0: dy=-1, dr=-1\n        jac[n_overlap + 3 * n_circles : n_overlap + 4 * n_circles, n_circles : 2 * n_circles] = -np.eye(n_circles)\n        jac[n_overlap + 3 * n_circles : n_overlap + 4 * n_circles, 2 * n_circles :] = -np.eye(n_circles)\n        \n        return jac\n\n    def get_grid_guess(nx, ny, n_total):\n        # Create a grid-based initial configuration\n        x_coords = np.linspace(0.1, 0.9, nx)\n        y_coords = np.linspace(0.1, 0.9, ny)\n        xv, yv = np.meshgrid(x_coords, y_coords)\n        xv = xv.flatten()\n        yv = yv.flatten()\n        # Initial radii small enough to avoid early infeasibility\n        rv = np.full(len(xv), 0.4 / max(nx, ny))\n        \n        if len(xv) > n_total:\n            xv, yv, rv = xv[:n_total], yv[:n_total], rv[:n_total]\n        elif len(xv) < n_total:\n            xv = np.concatenate([xv, np.random.uniform(0.1, 0.9, n_total - len(xv))])\n            yv = np.concatenate([yv, np.random.uniform(0.1, 0.9, n_total - len(yv))])\n            rv = np.concatenate([rv, np.full(n_total - len(rv), 0.02)])\n            \n        return np.concatenate([xv, yv, rv])\n\n    # Pre-generate multiple starting points\n    guesses = [\n        get_grid_guess(5, 5, n_circles),\n        get_grid_guess(4, 6, n_circles),\n        get_grid_guess(6, 4, n_circles)\n    ]\n    # Add random starts to break local minima\n    for _ in range(3):\n        x = np.random.uniform(0.1, 0.9, n_circles)\n        y = np.random.uniform(0.1, 0.9, n_circles)\n        r = np.random.uniform(0.01, 0.08, n_circles)\n        guesses.append(np.concatenate([x, y, r]))\n\n    best_vars = guesses[0]\n    best_sum = 0\n    bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n    obj_jac = np.concatenate([np.zeros(2 * n_circles), -np.ones(n_circles)])\n\n    # Multi-start SLSQP loop with shaking\n    for guess in guesses:\n        if time.time() - start_time > 260:\n            break\n            \n        res = minimize(\n            objective,\n            guess,\n            method='SLSQP',\n            jac=lambda x: obj_jac,\n            constraints={'type': 'ineq', 'fun': con_func, 'jac': con_jac},\n            bounds=bounds,\n            options={'ftol': 1e-8, 'maxiter': 400}\n        )\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n            \n        # Shaking step: perturb centers and re-optimize\n        current_best_vars = res.x\n        for sigma in [0.01, 0.005]:\n            if time.time() - start_time > 260:\n                break\n            \n            shaken = current_best_vars.copy()\n            shaken[:2*n_circles] += np.random.normal(0, sigma, 2*n_circles)\n            shaken[:2*n_circles] = np.clip(shaken[:2*n_circles], 0, 1)\n            \n            res_shaken = minimize(\n                objective,\n                shaken,\n                method='SLSQP',\n                jac=lambda x: obj_jac,\n                constraints={'type': 'ineq', 'fun': con_func, 'jac': con_jac},\n                bounds=bounds,\n                options={'ftol': 1e-8, 'maxiter': 400}\n            )\n            \n            if -res_shaken.fun > best_sum:\n                best_sum = -res_shaken.fun\n                best_vars = res_shaken.x\n                current_best_vars = res_shaken.x\n\n    # Final polish with high precision (ftol=1e-12)\n    res_final = minimize(\n        objective,\n        best_vars,\n        method='SLSQP',\n        jac=lambda x: obj_jac,\n        constraints={'type': 'ineq', 'fun': con_func, 'jac': con_jac},\n        bounds=bounds,\n        options={'ftol': 1e-12, 'maxiter': 1000}\n    )\n    \n    best_vars = res_final.x\n    best_sum = -res_final.fun\n    \n    # Prepare output format\n    centers = np.stack([best_vars[:n_circles], best_vars[n_circles:2*n_circles]], axis=1)\n    radii = best_vars[2*n_circles:]\n    \n    return centers, radii, best_sum",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 60.54314565658569,
    "error": "Circle 5 at (0.9948748365295176, 0.24306415142986285) with radius 0.005168600177768952 extends outside x-bounds"
  },
  "prompt": "\nImplement a 'Shaking' Multi-start SLSQP strategy:\n1. Generate an initial 'good' configuration (e.g., a perturbed 5x5 grid plus one circle).\n2. Run SLSQP to find a local optimum.\n3. 'Shake' the configuration by applying random perturbations to the centers.\n4. Re-optimize using SLSQP.\n5. Repeat this process, keeping the best configuration found.\n6. For the final optimization, use very high precision (ftol=1e-12).\n7. Maximize the sum of 26 radii.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii.\n    Uses a multi-start SLSQP strategy with shaking for local optimization.\n    \"\"\"\n    n_circles = 26\n    start_time = time.time()\n    \n    # Precompute indices for efficiency in constraint functions\n    idx_tri = np.triu_indices(n_circles, k=1)\n    n_overlap = n_circles * (n_circles - 1) // 2\n    k_idx = np.arange(n_overlap)\n    row_idx, col_idx = idx_tri\n\n    def objective(vars):\n        # vars: [x0...xn-1, y0...yn-1, r0...rn-1]\n        # Maximize sum of radii = Minimize -sum(radii)\n        return -np.sum(vars[2*n_circles:])\n\n    def con_func(vars):\n        x = vars[:n_circles]\n        y = vars[n_circles:2*n_circles]\n        r = vars[2*n_circles:]\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        dx = x[row_idx] - x[col_idx]\n        dy = y[row_idx] - y[col_idx]\n        dr = r[row_idx] + r[col_idx]\n        overlap_cons = dx**2 + dy**2 - dr**2\n        \n        # Boundary constraints:\n        # Each circle must be inside the square [0, 1]x[0, 1]\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        return np.concatenate([\n            overlap_cons,\n            x - r,\n            1.0 - x - r,\n            y - r,\n            1.0 - y - r\n        ])\n\n    def con_jac(vars):\n        x = vars[:n_circles]\n        y = vars[n_circles:2*n_circles]\n        r = vars[2*n_circles:]\n        \n        # Dense Jacobian matrix for SLSQP\n        jac = np.zeros((n_overlap + 4 * n_circles, 3 * n_circles))\n        \n        dx = x[row_idx] - x[col_idx]\n        dy = y[row_idx] - y[col_idx]\n        dr = r[row_idx] + r[col_idx]\n        \n        # Overlap jacobian entries (derivatives of dx^2 + dy^2 - dr^2)\n        jac[k_idx, row_idx] = 2 * dx\n        jac[k_idx, col_idx] = -2 * dx\n        jac[k_idx, n_circles + row_idx] = 2 * dy\n        jac[k_idx, n_circles + col_idx] = -2 * dy\n        jac[k_idx, 2 * n_circles + row_idx] = -2 * dr\n        jac[k_idx, 2 * n_circles + col_idx] = -2 * dr\n        \n        # Boundary jacobian entries\n        # x - r >= 0: dx=1, dr=-1\n        jac[n_overlap : n_overlap + n_circles, :n_circles] = np.eye(n_circles)\n        jac[n_overlap : n_overlap + n_circles, 2 * n_circles :] = -np.eye(n_circles)\n        \n        # 1 - x - r >= 0: dx=-1, dr=-1\n        jac[n_overlap + n_circles : n_overlap + 2 * n_circles, :n_circles] = -np.eye(n_circles)\n        jac[n_overlap + n_circles : n_overlap + 2 * n_circles, 2 * n_circles :] = -np.eye(n_circles)\n        \n        # y - r >= 0: dy=1, dr=-1\n        jac[n_overlap + 2 * n_circles : n_overlap + 3 * n_circles, n_circles : 2 * n_circles] = np.eye(n_circles)\n        jac[n_overlap + 2 * n_circles : n_overlap + 3 * n_circles, 2 * n_circles :] = -np.eye(n_circles)\n        \n        # 1 - y - r >= 0: dy=-1, dr=-1\n        jac[n_overlap + 3 * n_circles : n_overlap + 4 * n_circles, n_circles : 2 * n_circles] = -np.eye(n_circles)\n        jac[n_overlap + 3 * n_circles : n_overlap + 4 * n_circles, 2 * n_circles :] = -np.eye(n_circles)\n        \n        return jac\n\n    def get_grid_guess(nx, ny, n_total):\n        # Create a grid-based initial configuration\n        x_coords = np.linspace(0.1, 0.9, nx)\n        y_coords = np.linspace(0.1, 0.9, ny)\n        xv, yv = np.meshgrid(x_coords, y_coords)\n        xv = xv.flatten()\n        yv = yv.flatten()\n        # Initial radii small enough to avoid early infeasibility\n        rv = np.full(len(xv), 0.4 / max(nx, ny))\n        \n        if len(xv) > n_total:\n            xv, yv, rv = xv[:n_total], yv[:n_total], rv[:n_total]\n        elif len(xv) < n_total:\n            xv = np.concatenate([xv, np.random.uniform(0.1, 0.9, n_total - len(xv))])\n            yv = np.concatenate([yv, np.random.uniform(0.1, 0.9, n_total - len(yv))])\n            rv = np.concatenate([rv, np.full(n_total - len(rv), 0.02)])\n            \n        return np.concatenate([xv, yv, rv])\n\n    # Pre-generate multiple starting points\n    guesses = [\n        get_grid_guess(5, 5, n_circles),\n        get_grid_guess(4, 6, n_circles),\n        get_grid_guess(6, 4, n_circles)\n    ]\n    # Add random starts to break local minima\n    for _ in range(3):\n        x = np.random.uniform(0.1, 0.9, n_circles)\n        y = np.random.uniform(0.1, 0.9, n_circles)\n        r = np.random.uniform(0.01, 0.08, n_circles)\n        guesses.append(np.concatenate([x, y, r]))\n\n    best_vars = guesses[0]\n    best_sum = 0\n    bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n    obj_jac = np.concatenate([np.zeros(2 * n_circles), -np.ones(n_circles)])\n\n    # Multi-start SLSQP loop with shaking\n    for guess in guesses:\n        if time.time() - start_time > 260:\n            break\n            \n        res = minimize(\n            objective,\n            guess,\n            method='SLSQP',\n            jac=lambda x: obj_jac,\n            constraints={'type': 'ineq', 'fun': con_func, 'jac': con_jac},\n            bounds=bounds,\n            options={'ftol': 1e-8, 'maxiter': 400}\n        )\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n            \n        # Shaking step: perturb centers and re-optimize\n        current_best_vars = res.x\n        for sigma in [0.01, 0.005]:\n            if time.time() - start_time > 260:\n                break\n            \n            shaken = current_best_vars.copy()\n            shaken[:2*n_circles] += np.random.normal(0, sigma, 2*n_circles)\n            shaken[:2*n_circles] = np.clip(shaken[:2*n_circles], 0, 1)\n            \n            res_shaken = minimize(\n                objective,\n                shaken,\n                method='SLSQP',\n                jac=lambda x: obj_jac,\n                constraints={'type': 'ineq', 'fun': con_func, 'jac': con_jac},\n                bounds=bounds,\n                options={'ftol': 1e-8, 'maxiter': 400}\n            )\n            \n            if -res_shaken.fun > best_sum:\n                best_sum = -res_shaken.fun\n                best_vars = res_shaken.x\n                current_best_vars = res_shaken.x\n\n    # Final polish with high precision (ftol=1e-12)\n    res_final = minimize(\n        objective,\n        best_vars,\n        method='SLSQP',\n        jac=lambda x: obj_jac,\n        constraints={'type': 'ineq', 'fun': con_func, 'jac': con_jac},\n        bounds=bounds,\n        options={'ftol': 1e-12, 'maxiter': 1000}\n    )\n    \n    best_vars = res_final.x\n    best_sum = -res_final.fun\n    \n    # Prepare output format\n    centers = np.stack([best_vars[:n_circles], best_vars[n_circles:2*n_circles]], axis=1)\n    radii = best_vars[2*n_circles:]\n    \n    return centers, radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:18:48.291235",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 355,
        "candidates_token_count": 2442,
        "thoughts_token_count": 21913
      },
      "response_text_len": 6762
    }
  },
  "llm_call_duration_s": 138.1589044840075,
  "eval_duration_s": 60.54315602197312
}