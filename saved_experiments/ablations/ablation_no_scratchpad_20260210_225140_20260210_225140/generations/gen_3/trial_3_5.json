{
  "trial_id": "trial_3_5",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'Shaking' Multi-start SLSQP strategy.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for vectorized constraints\n    i_indices, j_indices = np.triu_indices(N, k=1)\n    num_overlap = N * (N - 1) // 2\n\n    def objective(v):\n        # Maximize sum(r) by minimizing -sum(r)\n        return -np.sum(v[2*N:])\n\n    # Objective Jacobian: [0, ..., 0, -1, ..., -1]\n    obj_jac = np.concatenate([np.zeros(2*N), -np.ones(N)])\n\n    def cons_func(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_boundary = np.zeros(4 * N)\n        c_boundary[0::4] = x - r\n        c_boundary[1::4] = 1.0 - x - r\n        c_boundary[2::4] = y - r\n        c_boundary[3::4] = 1.0 - y - r\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        c_overlap = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    def cons_jac(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        \n        jac = np.zeros((4 * N + num_overlap, 3 * N))\n        \n        # Boundary constraints derivatives\n        # x_i - r_i >= 0\n        jac[np.arange(0, 4*N, 4), np.arange(N)] = 1\n        jac[np.arange(0, 4*N, 4), np.arange(2*N, 3*N)] = -1\n        # 1 - x_i - r_i >= 0\n        jac[np.arange(1, 4*N, 4), np.arange(N)] = -1\n        jac[np.arange(1, 4*N, 4), np.arange(2*N, 3*N)] = -1\n        # y_i - r_i >= 0\n        jac[np.arange(2, 4*N, 4), np.arange(N, 2*N)] = 1\n        jac[np.arange(2, 4*N, 4), np.arange(2*N, 3*N)] = -1\n        # 1 - y_i - r_i >= 0\n        jac[np.arange(3, 4*N, 4), np.arange(N, 2*N)] = -1\n        jac[np.arange(3, 4*N, 4), np.arange(2*N, 3*N)] = -1\n        \n        # Overlap constraints derivatives\n        idx = 4 * N\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        \n        jac[idx + np.arange(num_overlap), i_indices] = 2 * dx\n        jac[idx + np.arange(num_overlap), j_indices] = -2 * dx\n        jac[idx + np.arange(num_overlap), N + i_indices] = 2 * dy\n        jac[idx + np.arange(num_overlap), N + j_indices] = -2 * dy\n        jac[idx + np.arange(num_overlap), 2 * N + i_indices] = -2 * dr\n        jac[idx + np.arange(num_overlap), 2 * N + j_indices] = -2 * dr\n        \n        return jac\n\n    # Variable bounds: (x, y in [0, 1], r in [0, 0.5])\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    cons = {'type': 'ineq', 'fun': cons_func, 'jac': cons_jac}\n\n    # Tracking the best solution\n    best_v = None\n    best_sum_r = -1.0\n\n    def update_best(v):\n        nonlocal best_v, best_sum_r\n        if v is None: return\n        c = cons_func(v)\n        if np.all(c >= -1e-8): # Ensure feasibility\n            sum_r = np.sum(v[2*N:])\n            if sum_r > best_sum_r:\n                best_sum_r = sum_r\n                best_v = v.copy()\n\n    # Initial Seeds\n    starts = []\n    \n    # Seed 1: 5x5 Grid + 1 circle\n    xs = np.linspace(0.1, 0.9, 5)\n    ys = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(xs, ys)\n    v1_x = np.append(xv.flatten(), 0.0)\n    v1_y = np.append(yv.flatten(), 0.0)\n    v1_r = np.append(np.full(25, 0.099), 0.0)\n    starts.append(np.concatenate([v1_x, v1_y, v1_r]))\n    \n    # Seed 2: 6x5 Grid (Partial)\n    xs = np.linspace(0.1, 0.9, 6)\n    ys = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(xs, ys)\n    v2_x = xv.flatten()[:26]\n    v2_y = yv.flatten()[:26]\n    v2_r = np.full(26, 0.079)\n    starts.append(np.concatenate([v2_x, v2_y, v2_r]))\n\n    # Seed 3: Random Spread\n    v3 = np.concatenate([np.random.uniform(0.1, 0.9, 2*N), np.full(N, 0.05)])\n    starts.append(v3)\n\n    # Initialize best_v with something feasible\n    update_best(starts[0])\n\n    # Initial optimization for all seeds\n    for v0 in starts:\n        res = minimize(objective, v0, jac=obj_jac, constraints=cons, method='SLSQP', bounds=bounds, options={'ftol': 1e-8, 'maxiter': 500})\n        if res.success or res.status == 0:\n            update_best(res.x)\n\n    # Shaking and Multi-start Loop\n    while time.time() - start_time < 265:\n        if best_v is not None and np.random.rand() < 0.75:\n            # Shake the current best\n            scale = np.random.uniform(0.005, 0.04)\n            v0 = best_v.copy()\n            v0[:2*N] += np.random.normal(0, scale, 2*N)\n            v0[2*N:] *= np.random.uniform(0.9, 0.98, N)\n        else:\n            # New random start\n            v0 = np.concatenate([np.random.uniform(0.1, 0.9, 2*N), np.full(N, 0.05)])\n        \n        v0[:2*N] = np.clip(v0[:2*N], 0, 1)\n        v0[2*N:] = np.clip(v0[2*N:], 0, 0.5)\n        \n        res = minimize(objective, v0, jac=obj_jac, constraints=cons, method='SLSQP', bounds=bounds, options={'ftol': 1e-8, 'maxiter': 400})\n        if res.success or res.status == 0:\n            update_best(res.x)\n\n    # Final Polish with high precision\n    if best_v is not None:\n        res = minimize(objective, best_v, jac=obj_jac, constraints=cons, method='SLSQP', bounds=bounds, options={'ftol': 1e-12, 'maxiter': 1000})\n        update_best(res.x)\n\n    # Prepare output\n    centers = np.column_stack([best_v[:N], best_v[N:2*N]])\n    radii = best_v[2*N:]\n    return centers, radii, best_sum_r",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 1.1282706260681152,
    "error": "ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()"
  },
  "prompt": "\nImplement a 'Shaking' Multi-start SLSQP strategy:\n1. Generate an initial 'good' configuration (e.g., a perturbed 5x5 grid plus one circle).\n2. Run SLSQP to find a local optimum.\n3. 'Shake' the configuration by applying random perturbations to the centers.\n4. Re-optimize using SLSQP.\n5. Repeat this process, keeping the best configuration found.\n6. For the final optimization, use very high precision (ftol=1e-12).\n7. Maximize the sum of 26 radii.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'Shaking' Multi-start SLSQP strategy.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for vectorized constraints\n    i_indices, j_indices = np.triu_indices(N, k=1)\n    num_overlap = N * (N - 1) // 2\n\n    def objective(v):\n        # Maximize sum(r) by minimizing -sum(r)\n        return -np.sum(v[2*N:])\n\n    # Objective Jacobian: [0, ..., 0, -1, ..., -1]\n    obj_jac = np.concatenate([np.zeros(2*N), -np.ones(N)])\n\n    def cons_func(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_boundary = np.zeros(4 * N)\n        c_boundary[0::4] = x - r\n        c_boundary[1::4] = 1.0 - x - r\n        c_boundary[2::4] = y - r\n        c_boundary[3::4] = 1.0 - y - r\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        c_overlap = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    def cons_jac(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        \n        jac = np.zeros((4 * N + num_overlap, 3 * N))\n        \n        # Boundary constraints derivatives\n        # x_i - r_i >= 0\n        jac[np.arange(0, 4*N, 4), np.arange(N)] = 1\n        jac[np.arange(0, 4*N, 4), np.arange(2*N, 3*N)] = -1\n        # 1 - x_i - r_i >= 0\n        jac[np.arange(1, 4*N, 4), np.arange(N)] = -1\n        jac[np.arange(1, 4*N, 4), np.arange(2*N, 3*N)] = -1\n        # y_i - r_i >= 0\n        jac[np.arange(2, 4*N, 4), np.arange(N, 2*N)] = 1\n        jac[np.arange(2, 4*N, 4), np.arange(2*N, 3*N)] = -1\n        # 1 - y_i - r_i >= 0\n        jac[np.arange(3, 4*N, 4), np.arange(N, 2*N)] = -1\n        jac[np.arange(3, 4*N, 4), np.arange(2*N, 3*N)] = -1\n        \n        # Overlap constraints derivatives\n        idx = 4 * N\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        \n        jac[idx + np.arange(num_overlap), i_indices] = 2 * dx\n        jac[idx + np.arange(num_overlap), j_indices] = -2 * dx\n        jac[idx + np.arange(num_overlap), N + i_indices] = 2 * dy\n        jac[idx + np.arange(num_overlap), N + j_indices] = -2 * dy\n        jac[idx + np.arange(num_overlap), 2 * N + i_indices] = -2 * dr\n        jac[idx + np.arange(num_overlap), 2 * N + j_indices] = -2 * dr\n        \n        return jac\n\n    # Variable bounds: (x, y in [0, 1], r in [0, 0.5])\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    cons = {'type': 'ineq', 'fun': cons_func, 'jac': cons_jac}\n\n    # Tracking the best solution\n    best_v = None\n    best_sum_r = -1.0\n\n    def update_best(v):\n        nonlocal best_v, best_sum_r\n        if v is None: return\n        c = cons_func(v)\n        if np.all(c >= -1e-8): # Ensure feasibility\n            sum_r = np.sum(v[2*N:])\n            if sum_r > best_sum_r:\n                best_sum_r = sum_r\n                best_v = v.copy()\n\n    # Initial Seeds\n    starts = []\n    \n    # Seed 1: 5x5 Grid + 1 circle\n    xs = np.linspace(0.1, 0.9, 5)\n    ys = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(xs, ys)\n    v1_x = np.append(xv.flatten(), 0.0)\n    v1_y = np.append(yv.flatten(), 0.0)\n    v1_r = np.append(np.full(25, 0.099), 0.0)\n    starts.append(np.concatenate([v1_x, v1_y, v1_r]))\n    \n    # Seed 2: 6x5 Grid (Partial)\n    xs = np.linspace(0.1, 0.9, 6)\n    ys = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(xs, ys)\n    v2_x = xv.flatten()[:26]\n    v2_y = yv.flatten()[:26]\n    v2_r = np.full(26, 0.079)\n    starts.append(np.concatenate([v2_x, v2_y, v2_r]))\n\n    # Seed 3: Random Spread\n    v3 = np.concatenate([np.random.uniform(0.1, 0.9, 2*N), np.full(N, 0.05)])\n    starts.append(v3)\n\n    # Initialize best_v with something feasible\n    update_best(starts[0])\n\n    # Initial optimization for all seeds\n    for v0 in starts:\n        res = minimize(objective, v0, jac=obj_jac, constraints=cons, method='SLSQP', bounds=bounds, options={'ftol': 1e-8, 'maxiter': 500})\n        if res.success or res.status == 0:\n            update_best(res.x)\n\n    # Shaking and Multi-start Loop\n    while time.time() - start_time < 265:\n        if best_v is not None and np.random.rand() < 0.75:\n            # Shake the current best\n            scale = np.random.uniform(0.005, 0.04)\n            v0 = best_v.copy()\n            v0[:2*N] += np.random.normal(0, scale, 2*N)\n            v0[2*N:] *= np.random.uniform(0.9, 0.98, N)\n        else:\n            # New random start\n            v0 = np.concatenate([np.random.uniform(0.1, 0.9, 2*N), np.full(N, 0.05)])\n        \n        v0[:2*N] = np.clip(v0[:2*N], 0, 1)\n        v0[2*N:] = np.clip(v0[2*N:], 0, 0.5)\n        \n        res = minimize(objective, v0, jac=obj_jac, constraints=cons, method='SLSQP', bounds=bounds, options={'ftol': 1e-8, 'maxiter': 400})\n        if res.success or res.status == 0:\n            update_best(res.x)\n\n    # Final Polish with high precision\n    if best_v is not None:\n        res = minimize(objective, best_v, jac=obj_jac, constraints=cons, method='SLSQP', bounds=bounds, options={'ftol': 1e-12, 'maxiter': 1000})\n        update_best(res.x)\n\n    # Prepare output\n    centers = np.column_stack([best_v[:N], best_v[N:2*N]])\n    radii = best_v[2*N:]\n    return centers, radii, best_sum_r\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:17:51.079604",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 355,
        "candidates_token_count": 2293,
        "thoughts_token_count": 21875
      },
      "response_text_len": 5576
    }
  },
  "llm_call_duration_s": 140.36164820904378,
  "eval_duration_s": 1.1282815940212458
}