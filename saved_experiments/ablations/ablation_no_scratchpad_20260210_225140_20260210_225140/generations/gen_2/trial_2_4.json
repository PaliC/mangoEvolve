{
  "trial_id": "trial_2_4",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii.\n    The strategy uses a multi-start local optimization approach (SLSQP) with \n    hexagonal and grid-based initializations, combined with a mutation-based \n    evolutionary search to find high-quality solutions.\n    \"\"\"\n    n = 26\n    iu_indices = np.triu_indices(n, k=1)\n    \n    def objective(params):\n        # params: [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n        # Objective is to maximize sum of radii, so minimize -sum(radii)\n        return -np.sum(params[2::3])\n\n    def grad_objective(params):\n        # Gradient of -sum(r_i) with respect to x_i, y_i, r_i\n        grad = np.zeros_like(params)\n        grad[2::3] = -1.0\n        return grad\n\n    def constraints(params):\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        c = np.zeros(4 * n + n * (n - 1) // 2)\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        for i in range(n):\n            c[4*i] = x[i] - r[i]\n            c[4*i+1] = 1.0 - x[i] - r[i]\n            c[4*i+2] = y[i] - r[i]\n            c[4*i+3] = 1.0 - y[i] - r[i]\n            \n        # Non-overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        row_idx = 4 * n\n        for i, j in zip(iu_indices[0], iu_indices[1]):\n            c[row_idx] = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n            row_idx += 1\n        return c\n\n    def jac_constraints(params):\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        num_overlap = n * (n - 1) // 2\n        jac = np.zeros((4 * n + num_overlap, 3 * n))\n        \n        # Boundary constraint gradients\n        for i in range(n):\n            # x[i] - r[i] >= 0\n            jac[4*i, 3*i], jac[4*i, 3*i+2] = 1.0, -1.0\n            # 1.0 - x[i] - r[i] >= 0\n            jac[4*i+1, 3*i], jac[4*i+1, 3*i+2] = -1.0, -1.0\n            # y[i] - r[i] >= 0\n            jac[4*i+2, 3*i+1], jac[4*i+2, 3*i+2] = 1.0, -1.0\n            # 1.0 - y[i] - r[i] >= 0\n            jac[4*i+3, 3*i+1], jac[4*i+3, 3*i+2] = -1.0, -1.0\n            \n        # Overlap constraint gradients\n        row_idx = 4 * n\n        for i, j in zip(iu_indices[0], iu_indices[1]):\n            dx, dy, dr = x[i] - x[j], y[i] - y[j], r[i] + r[j]\n            jac[row_idx, 3*i] = 2 * dx\n            jac[row_idx, 3*j] = -2 * dx\n            jac[row_idx, 3*i+1] = 2 * dy\n            jac[row_idx, 3*j+1] = -2 * dy\n            jac[row_idx, 3*i+2] = -2 * dr\n            jac[row_idx, 3*j+2] = -2 * dr\n            row_idx += 1\n        return jac\n\n    best_sum = 0\n    best_params = None\n    start_time = time.time()\n    bounds = [(0, 1)] * (3 * n)\n    \n    # Selection of heuristic initializations\n    seeds = []\n    \n    # 1. Hexagonal packing seeds (generally efficient for circle packing)\n    for r_guess in [0.098, 0.1, 0.101]:\n        points = []\n        y = r_guess\n        row = 0\n        while y <= 1 - r_guess and len(points) < n:\n            x = r_guess if row % 2 == 0 else 2 * r_guess\n            while x <= 1 - r_guess and len(points) < n:\n                points.append([x, y])\n                x += 2 * r_guess\n            y += np.sqrt(3) * r_guess\n            row += 1\n        if len(points) == n:\n            p0 = np.zeros(3 * n)\n            pts = np.array(points)\n            p0[0::3], p0[1::3], p0[2::3] = pts[:, 0], pts[:, 1], r_guess\n            seeds.append(p0)\n\n    # 2. Grid-based seed\n    x_grid = np.linspace(0.1, 0.9, 5)\n    y_grid = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x_grid, y_grid)\n    pts_grid = np.vstack([np.stack([xv.flatten(), yv.flatten()], axis=1), [0.5, 0.5]])\n    p_grid = np.zeros(3 * n)\n    p_grid[0::3], p_grid[1::3], p_grid[2::3] = pts_grid[:n, 0], pts_grid[:n, 1], 0.09\n    seeds.append(p_grid)\n\n    # Optimization loop\n    # Start with heuristic seeds, then move to random/mutated configurations\n    for seed_idx, p0 in enumerate(seeds):\n        if time.time() - start_time > 280: break\n        res = minimize(objective, p0, jac=grad_objective, \n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 200})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n\n    # Evolutionary multi-start with mutation\n    while time.time() - start_time < 270:\n        if best_params is not None and np.random.rand() > 0.4:\n            # Mutate the current best solution to explore the neighborhood\n            p0 = best_params + np.random.normal(0, 0.01, 3 * n)\n        else:\n            # Random restart to explore new regions of the search space\n            p0 = np.zeros(3 * n)\n            p0[0::3], p0[1::3], p0[2::3] = np.random.rand(n), np.random.rand(n), 0.08\n        \n        p0 = np.clip(p0, 0, 1)\n        res = minimize(objective, p0, jac=grad_objective, \n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 100})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n\n    # Final refinement of the best found solution\n    if best_params is not None:\n        res = minimize(objective, best_params, jac=grad_objective, \n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 500})\n        best_params = res.x\n        best_sum = -res.fun\n\n    # Extract final centers and radii\n    centers = np.zeros((n, 2))\n    centers[:, 0], centers[:, 1] = best_params[0::3], best_params[1::3]\n    radii = best_params[2::3]\n    \n    return centers, radii, best_sum",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 282.35231733322144,
    "error": "Circle 2 at (0.9611016568338667, 0.9055764205166742) with radius 0.4448844403946119 extends outside x-bounds"
  },
  "prompt": "\nImplement a circle packing strategy using a Covariance Matrix Adaptation Evolution Strategy (CMA-ES) or a similar evolutionary algorithm.\n1. Represent the state as 26*3 parameters (x, y, r).\n2. Use a penalty function to enforce non-overlapping and boundary constraints.\n3. The objective is to maximize sum(radii).\n4. Ensure the circles stay within the unit square [0,1]x[0,1].\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii.\n    The strategy uses a multi-start local optimization approach (SLSQP) with \n    hexagonal and grid-based initializations, combined with a mutation-based \n    evolutionary search to find high-quality solutions.\n    \"\"\"\n    n = 26\n    iu_indices = np.triu_indices(n, k=1)\n    \n    def objective(params):\n        # params: [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n        # Objective is to maximize sum of radii, so minimize -sum(radii)\n        return -np.sum(params[2::3])\n\n    def grad_objective(params):\n        # Gradient of -sum(r_i) with respect to x_i, y_i, r_i\n        grad = np.zeros_like(params)\n        grad[2::3] = -1.0\n        return grad\n\n    def constraints(params):\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        c = np.zeros(4 * n + n * (n - 1) // 2)\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n        for i in range(n):\n            c[4*i] = x[i] - r[i]\n            c[4*i+1] = 1.0 - x[i] - r[i]\n            c[4*i+2] = y[i] - r[i]\n            c[4*i+3] = 1.0 - y[i] - r[i]\n            \n        # Non-overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        row_idx = 4 * n\n        for i, j in zip(iu_indices[0], iu_indices[1]):\n            c[row_idx] = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n            row_idx += 1\n        return c\n\n    def jac_constraints(params):\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        num_overlap = n * (n - 1) // 2\n        jac = np.zeros((4 * n + num_overlap, 3 * n))\n        \n        # Boundary constraint gradients\n        for i in range(n):\n            # x[i] - r[i] >= 0\n            jac[4*i, 3*i], jac[4*i, 3*i+2] = 1.0, -1.0\n            # 1.0 - x[i] - r[i] >= 0\n            jac[4*i+1, 3*i], jac[4*i+1, 3*i+2] = -1.0, -1.0\n            # y[i] - r[i] >= 0\n            jac[4*i+2, 3*i+1], jac[4*i+2, 3*i+2] = 1.0, -1.0\n            # 1.0 - y[i] - r[i] >= 0\n            jac[4*i+3, 3*i+1], jac[4*i+3, 3*i+2] = -1.0, -1.0\n            \n        # Overlap constraint gradients\n        row_idx = 4 * n\n        for i, j in zip(iu_indices[0], iu_indices[1]):\n            dx, dy, dr = x[i] - x[j], y[i] - y[j], r[i] + r[j]\n            jac[row_idx, 3*i] = 2 * dx\n            jac[row_idx, 3*j] = -2 * dx\n            jac[row_idx, 3*i+1] = 2 * dy\n            jac[row_idx, 3*j+1] = -2 * dy\n            jac[row_idx, 3*i+2] = -2 * dr\n            jac[row_idx, 3*j+2] = -2 * dr\n            row_idx += 1\n        return jac\n\n    best_sum = 0\n    best_params = None\n    start_time = time.time()\n    bounds = [(0, 1)] * (3 * n)\n    \n    # Selection of heuristic initializations\n    seeds = []\n    \n    # 1. Hexagonal packing seeds (generally efficient for circle packing)\n    for r_guess in [0.098, 0.1, 0.101]:\n        points = []\n        y = r_guess\n        row = 0\n        while y <= 1 - r_guess and len(points) < n:\n            x = r_guess if row % 2 == 0 else 2 * r_guess\n            while x <= 1 - r_guess and len(points) < n:\n                points.append([x, y])\n                x += 2 * r_guess\n            y += np.sqrt(3) * r_guess\n            row += 1\n        if len(points) == n:\n            p0 = np.zeros(3 * n)\n            pts = np.array(points)\n            p0[0::3], p0[1::3], p0[2::3] = pts[:, 0], pts[:, 1], r_guess\n            seeds.append(p0)\n\n    # 2. Grid-based seed\n    x_grid = np.linspace(0.1, 0.9, 5)\n    y_grid = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x_grid, y_grid)\n    pts_grid = np.vstack([np.stack([xv.flatten(), yv.flatten()], axis=1), [0.5, 0.5]])\n    p_grid = np.zeros(3 * n)\n    p_grid[0::3], p_grid[1::3], p_grid[2::3] = pts_grid[:n, 0], pts_grid[:n, 1], 0.09\n    seeds.append(p_grid)\n\n    # Optimization loop\n    # Start with heuristic seeds, then move to random/mutated configurations\n    for seed_idx, p0 in enumerate(seeds):\n        if time.time() - start_time > 280: break\n        res = minimize(objective, p0, jac=grad_objective, \n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 200})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n\n    # Evolutionary multi-start with mutation\n    while time.time() - start_time < 270:\n        if best_params is not None and np.random.rand() > 0.4:\n            # Mutate the current best solution to explore the neighborhood\n            p0 = best_params + np.random.normal(0, 0.01, 3 * n)\n        else:\n            # Random restart to explore new regions of the search space\n            p0 = np.zeros(3 * n)\n            p0[0::3], p0[1::3], p0[2::3] = np.random.rand(n), np.random.rand(n), 0.08\n        \n        p0 = np.clip(p0, 0, 1)\n        res = minimize(objective, p0, jac=grad_objective, \n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 100})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n\n    # Final refinement of the best found solution\n    if best_params is not None:\n        res = minimize(objective, best_params, jac=grad_objective, \n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       method='SLSQP', bounds=bounds, options={'maxiter': 500})\n        best_params = res.x\n        best_sum = -res.fun\n\n    # Extract final centers and radii\n    centers = np.zeros((n, 2))\n    centers[:, 0], centers[:, 1] = best_params[0::3], best_params[1::3]\n    radii = best_params[2::3]\n    \n    return centers, radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:14:35.870105",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 326,
        "candidates_token_count": 2207,
        "thoughts_token_count": 20576
      },
      "response_text_len": 5865
    }
  },
  "llm_call_duration_s": 126.10509666707367,
  "eval_duration_s": 282.35232755099423
}