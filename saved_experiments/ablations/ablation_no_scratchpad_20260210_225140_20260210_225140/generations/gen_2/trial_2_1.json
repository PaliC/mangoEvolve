{
  "trial_id": "trial_2_1",
  "generation": 2,
  "parent_id": "trial_1_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy involves multi-start optimization using L-BFGS-B with a penalty method\n    to find candidate center configurations, followed by a linear programming step \n    to find the optimal radii for those fixed centers.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_centers = np.random.rand(n, 2)\n    best_radii = np.zeros(n)\n\n    def objective(vars, n, lam):\n        # Extract variables\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        \n        # Boundary penalties: r_i <= x_i, x_i + r_i <= 1, r_i <= y_i, y_i + r_i <= 1\n        b1 = r - x\n        b2 = x + r - 1\n        b3 = r - y\n        b4 = y + r - 1\n        p_bound = np.sum(np.maximum(0, b1)**2 + np.maximum(0, b2)**2 + \n                         np.maximum(0, b3)**2 + np.maximum(0, b4)**2)\n        \n        # Overlap penalties: r_i + r_j <= d_ij\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        d = np.sqrt(dx**2 + dy**2 + 1e-12)\n        rr = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = rr - d\n        mask = violation > 0\n        np.fill_diagonal(mask, False)\n        p_overlap = np.sum(violation[mask]**2) / 2\n        \n        return -np.sum(r) + lam * (p_bound + p_overlap)\n\n    def gradient(vars, n, lam):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        dx_vec, dy_vec, dr_vec = np.zeros(n), np.zeros(n), -np.ones(n)\n        \n        # Boundary gradients\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dx_vec += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_vec += 2 * lam * (-b3 * m3 + b4 * m4)\n        dr_vec += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        \n        # Overlap gradients\n        dx_mat = x[:, np.newaxis] - x[np.newaxis, :]\n        dy_mat = y[:, np.newaxis] - y[np.newaxis, :]\n        d_mat = np.sqrt(dx_mat**2 + dy_mat**2 + 1e-12)\n        rr_mat = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = rr_mat - d_mat\n        mask = violation > 0\n        np.fill_diagonal(mask, False)\n        \n        common = 2 * lam * violation * mask\n        dx_vec += np.sum(common * (-dx_mat / d_mat), axis=1)\n        dy_vec += np.sum(common * (-dy_mat / d_mat), axis=1)\n        dr_vec += np.sum(common, axis=1)\n        \n        return np.concatenate([dx_vec, dy_vec, dr_vec])\n\n    # Multi-start loop\n    iter_idx = 0\n    while time.time() - start_time < 280:\n        # Initialization strategy\n        if iter_idx == 0:\n            # Grid 5x5 + 1\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init = np.concatenate([xg.flatten(), [0.5]])\n            y_init = np.concatenate([yg.flatten(), [0.5]])\n            x_init += np.random.normal(0, 0.01, n)\n            y_init += np.random.normal(0, 0.01, n)\n        elif iter_idx == 1:\n            # Grid 6x4 + 2\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n            x_init = np.concatenate([xg.flatten(), [0.1, 0.9]])\n            y_init = np.concatenate([yg.flatten(), [0.5, 0.5]])\n            x_init += np.random.normal(0, 0.01, n)\n            y_init += np.random.normal(0, 0.01, n)\n        elif iter_idx % 5 == 0 and best_sum > 0:\n            # Perturb best found so far\n            x_init = best_centers[:, 0] + np.random.normal(0, 0.03, n)\n            y_init = best_centers[:, 1] + np.random.normal(0, 0.03, n)\n        else:\n            # Random initialization\n            x_init = np.random.uniform(0.05, 0.95, n)\n            y_init = np.random.uniform(0.05, 0.95, n)\n            \n        r_init = np.ones(n) * 0.08\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n        \n        # Optimization steps with increasing penalty lambda\n        for lam in [100, 1000, 5000]:\n            res = minimize(objective, vars_curr, args=(n, lam), jac=gradient, method='L-BFGS-B', \n                           bounds=[(0, 1)]*n + [(0, 1)]*n + [(0, 0.5)]*n, \n                           options={'maxiter': 400})\n            vars_curr = res.x\n            \n        # Final polish: Solve LP to find maximum possible radii for fixed centers\n        x_final = np.clip(vars_curr[:n], 0, 1)\n        y_final = np.clip(vars_curr[n:2*n], 0, 1)\n        \n        c_lp = -np.ones(n)\n        num_overlap = n * (n - 1) // 2\n        A_ub = np.zeros((num_overlap, n))\n        b_ub = np.zeros(num_overlap)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A_ub[k, i], A_ub[k, j] = 1, 1\n                b_ub[k] = np.sqrt((x_final[i] - x_final[j])**2 + (y_final[i] - y_final[j])**2)\n                k += 1\n        \n        # Boundary constraints for each radius\n        max_r_bound = np.minimum.reduce([x_final, 1 - x_final, y_final, 1 - y_final])\n        lp_bounds = [(0, max(0, b)) for b in max_r_bound]\n        \n        try:\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if lp_res.success:\n            current_sum = -lp_res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_radii = lp_res.x\n                best_centers = np.stack([x_final, y_final], axis=1)\n        \n        iter_idx += 1\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.630688474887074,
    "eval_time": 280.53987312316895,
    "error": null
  },
  "prompt": "\nImprove this high-performing circle packing solution (score 2.6309106659682073). \nThe current approach uses . \nTry to:\n1. Increase the number of iterations or refine the step size in the local search.\n2. Implement a more robust multi-start strategy with better-distributed initial points (e.g., Sobol sequences or Halton sets).\n3. Use a more sophisticated penalty method for the square boundaries and non-overlap constraints.\nCode:\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy involves multi-start optimization using L-BFGS-B with a penalty method,\n    followed by a linear programming step to find the optimal radii for the fixed centers.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_centers = np.random.rand(n, 2) * 0.8 + 0.1\n    best_radii = np.zeros(n)\n\n    def objective(vars, n, lam):\n        # Extract variables\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        \n        # Boundary penalties: r_i <= x_i, x_i + r_i <= 1, r_i <= y_i, y_i + r_i <= 1\n        b1 = np.maximum(0, r - x)\n        b2 = np.maximum(0, x + r - 1)\n        b3 = np.maximum(0, r - y)\n        b4 = np.maximum(0, y + r - 1)\n        p_bound = np.sum(b1**2 + b2**2 + b3**2 + b4**2)\n        \n        # Overlap penalties: r_i + r_j <= d_ij\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        # Small epsilon to avoid division by zero in gradient\n        d = np.sqrt(dx**2 + dy**2 + 1e-12)\n        rr = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = np.maximum(0, rr - d)\n        # Sum only upper triangle to avoid double counting\n        p_overlap = (np.sum(violation**2) - np.sum(np.diag(violation**2))) / 2\n        \n        return -np.sum(r) + lam * (p_bound + p_overlap)\n\n    def gradient(vars, n, lam):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        dx_vec, dy_vec, dr_vec = np.zeros(n), np.zeros(n), -np.ones(n)\n        \n        # Boundary gradients\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dx_vec += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_vec += 2 * lam * (-b3 * m3 + b4 * m4)\n        dr_vec += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        \n        # Overlap gradients\n        dx_mat = x[:, np.newaxis] - x[np.newaxis, :]\n        dy_mat = y[:, np.newaxis] - y[np.newaxis, :]\n        d_mat = np.sqrt(dx_mat**2 + dy_mat**2 + 1e-12)\n        rr_mat = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = rr_mat - d_mat\n        mask = violation > 0\n        np.fill_diagonal(mask, False)\n        \n        common = 2 * lam * violation * mask\n        # dx_mat[i,j] = x[i] - x[j]\n        dx_vec += np.sum(common * (-dx_mat / d_mat), axis=1)\n        dy_vec += np.sum(common * (-dy_mat / d_mat), axis=1)\n        dr_vec += np.sum(common, axis=1)\n        \n        return np.concatenate([dx_vec, dy_vec, dr_vec])\n\n    # Multi-start loop\n    iter_idx = 0\n    while time.time() - start_time < 280:\n        # Initialization\n        if iter_idx == 0:\n            # Start with a grid-like configuration\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init = np.concatenate([xg.flatten(), [0.5]])\n            y_init = np.concatenate([yg.flatten(), [0.5]])\n        else:\n            # Random initialization\n            x_init = np.random.uniform(0.1, 0.9, n)\n            y_init = np.random.uniform(0.1, 0.9, n)\n            \n        r_init = np.ones(n) * 0.08\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n        \n        # Optimization steps with increasing penalty lambda\n        for lam in [10, 100, 1000]:\n            res = minimize(objective, vars_curr, args=(n, lam), jac=gradient, method='L-BFGS-B', \n                           bounds=[(0, 1)]*2*n + [(0, 0.5)]*n, options={'maxiter': 500})\n            vars_curr = res.x\n            \n        # Extract centers and ensure they are within the unit square\n        x_final = np.clip(vars_curr[:n], 0, 1)\n        y_final = np.clip(vars_curr[n:2*n], 0, 1)\n        centers_final = np.stack([x_final, y_final], axis=1)\n        \n        # Final polish: Solve LP to find maximum possible radii for fixed centers\n        c_lp = -np.ones(n)\n        A_ub = np.zeros((n * (n - 1) // 2, n))\n        b_ub = np.zeros(n * (n - 1) // 2)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A_ub[k, i], A_ub[k, j] = 1, 1\n                b_ub[k] = np.sqrt((x_final[i] - x_final[j])**2 + (y_final[i] - y_final[j])**2)\n                k += 1\n        \n        # Boundary constraints for each radius\n        max_r_bound = np.minimum.reduce([x_final, 1 - x_final, y_final, 1 - y_final])\n        lp_bounds = [(0, max(0, b)) for b in max_r_bound]\n        \n        try:\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if lp_res.success:\n            current_sum = -lp_res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_radii = lp_res.x\n                best_centers = centers_final\n        \n        iter_idx += 1\n\n    return best_centers, best_radii, best_sum\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy involves multi-start optimization using L-BFGS-B with a penalty method\n    to find candidate center configurations, followed by a linear programming step \n    to find the optimal radii for those fixed centers.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = 0\n    best_centers = np.random.rand(n, 2)\n    best_radii = np.zeros(n)\n\n    def objective(vars, n, lam):\n        # Extract variables\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        \n        # Boundary penalties: r_i <= x_i, x_i + r_i <= 1, r_i <= y_i, y_i + r_i <= 1\n        b1 = r - x\n        b2 = x + r - 1\n        b3 = r - y\n        b4 = y + r - 1\n        p_bound = np.sum(np.maximum(0, b1)**2 + np.maximum(0, b2)**2 + \n                         np.maximum(0, b3)**2 + np.maximum(0, b4)**2)\n        \n        # Overlap penalties: r_i + r_j <= d_ij\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        d = np.sqrt(dx**2 + dy**2 + 1e-12)\n        rr = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = rr - d\n        mask = violation > 0\n        np.fill_diagonal(mask, False)\n        p_overlap = np.sum(violation[mask]**2) / 2\n        \n        return -np.sum(r) + lam * (p_bound + p_overlap)\n\n    def gradient(vars, n, lam):\n        x, y, r = vars[:n], vars[n:2*n], vars[2*n:]\n        dx_vec, dy_vec, dr_vec = np.zeros(n), np.zeros(n), -np.ones(n)\n        \n        # Boundary gradients\n        b1, b2, b3, b4 = r - x, x + r - 1, r - y, y + r - 1\n        m1, m2, m3, m4 = b1 > 0, b2 > 0, b3 > 0, b4 > 0\n        dx_vec += 2 * lam * (-b1 * m1 + b2 * m2)\n        dy_vec += 2 * lam * (-b3 * m3 + b4 * m4)\n        dr_vec += 2 * lam * (b1 * m1 + b2 * m2 + b3 * m3 + b4 * m4)\n        \n        # Overlap gradients\n        dx_mat = x[:, np.newaxis] - x[np.newaxis, :]\n        dy_mat = y[:, np.newaxis] - y[np.newaxis, :]\n        d_mat = np.sqrt(dx_mat**2 + dy_mat**2 + 1e-12)\n        rr_mat = r[:, np.newaxis] + r[np.newaxis, :]\n        violation = rr_mat - d_mat\n        mask = violation > 0\n        np.fill_diagonal(mask, False)\n        \n        common = 2 * lam * violation * mask\n        dx_vec += np.sum(common * (-dx_mat / d_mat), axis=1)\n        dy_vec += np.sum(common * (-dy_mat / d_mat), axis=1)\n        dr_vec += np.sum(common, axis=1)\n        \n        return np.concatenate([dx_vec, dy_vec, dr_vec])\n\n    # Multi-start loop\n    iter_idx = 0\n    while time.time() - start_time < 280:\n        # Initialization strategy\n        if iter_idx == 0:\n            # Grid 5x5 + 1\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            x_init = np.concatenate([xg.flatten(), [0.5]])\n            y_init = np.concatenate([yg.flatten(), [0.5]])\n            x_init += np.random.normal(0, 0.01, n)\n            y_init += np.random.normal(0, 0.01, n)\n        elif iter_idx == 1:\n            # Grid 6x4 + 2\n            xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n            x_init = np.concatenate([xg.flatten(), [0.1, 0.9]])\n            y_init = np.concatenate([yg.flatten(), [0.5, 0.5]])\n            x_init += np.random.normal(0, 0.01, n)\n            y_init += np.random.normal(0, 0.01, n)\n        elif iter_idx % 5 == 0 and best_sum > 0:\n            # Perturb best found so far\n            x_init = best_centers[:, 0] + np.random.normal(0, 0.03, n)\n            y_init = best_centers[:, 1] + np.random.normal(0, 0.03, n)\n        else:\n            # Random initialization\n            x_init = np.random.uniform(0.05, 0.95, n)\n            y_init = np.random.uniform(0.05, 0.95, n)\n            \n        r_init = np.ones(n) * 0.08\n        vars_curr = np.concatenate([x_init, y_init, r_init])\n        \n        # Optimization steps with increasing penalty lambda\n        for lam in [100, 1000, 5000]:\n            res = minimize(objective, vars_curr, args=(n, lam), jac=gradient, method='L-BFGS-B', \n                           bounds=[(0, 1)]*n + [(0, 1)]*n + [(0, 0.5)]*n, \n                           options={'maxiter': 400})\n            vars_curr = res.x\n            \n        # Final polish: Solve LP to find maximum possible radii for fixed centers\n        x_final = np.clip(vars_curr[:n], 0, 1)\n        y_final = np.clip(vars_curr[n:2*n], 0, 1)\n        \n        c_lp = -np.ones(n)\n        num_overlap = n * (n - 1) // 2\n        A_ub = np.zeros((num_overlap, n))\n        b_ub = np.zeros(num_overlap)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A_ub[k, i], A_ub[k, j] = 1, 1\n                b_ub[k] = np.sqrt((x_final[i] - x_final[j])**2 + (y_final[i] - y_final[j])**2)\n                k += 1\n        \n        # Boundary constraints for each radius\n        max_r_bound = np.minimum.reduce([x_final, 1 - x_final, y_final, 1 - y_final])\n        lp_bounds = [(0, max(0, b)) for b in max_r_bound]\n        \n        try:\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs')\n        except:\n            lp_res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds)\n            \n        if lp_res.success:\n            current_sum = -lp_res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_radii = lp_res.x\n                best_centers = np.stack([x_final, y_final], axis=1)\n        \n        iter_idx += 1\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:14:11.861110",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2230,
        "candidates_token_count": 2131,
        "thoughts_token_count": 16247
      },
      "response_text_len": 5608
    }
  },
  "llm_call_duration_s": 103.90749778202735,
  "eval_duration_s": 280.5398818521062
}