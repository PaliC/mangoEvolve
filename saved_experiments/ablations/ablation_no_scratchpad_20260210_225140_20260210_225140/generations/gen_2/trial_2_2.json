{
  "trial_id": "trial_2_2",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Basin-hopping combined with SLSQP for optimization.\n    \"\"\"\n    N = 26\n    i_idx, j_idx = np.triu_indices(N, k=1)\n\n    # --- Phase 1: Optimize for Equal Radii (Faster exploration) ---\n    def eq_objective(params):\n        return -params[-1]\n\n    def eq_jac_obj(params):\n        j = np.zeros(2 * N + 1)\n        j[-1] = -1.0\n        return j\n\n    def eq_constraints(params):\n        xy = params[:-1]\n        r = params[-1]\n        x = xy[0::2]\n        y = xy[1::2]\n        # Boundary constraints: circles must stay inside [0,1]x[0,1]\n        b_cons = np.zeros(4 * N)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1.0 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1.0 - y - r\n        # Overlap constraints: distance between centers >= sum of radii\n        o_cons = (x[i_idx]-x[j_idx])**2 + (y[i_idx]-y[j_idx])**2 - 4*r**2\n        return np.concatenate([b_cons, o_cons])\n\n    def eq_jac_cons(params):\n        xy = params[:-1]\n        r = params[-1]\n        x = xy[0::2]\n        y = xy[1::2]\n        jac = np.zeros((4 * N + len(i_idx), 2 * N + 1))\n        # Boundary constraints jacobian\n        rows_b = np.arange(4 * N)\n        jac[rows_b[0::4], 2*np.arange(N)] = 1\n        jac[rows_b[0::4], -1] = -1\n        jac[rows_b[1::4], 2*np.arange(N)] = -1\n        jac[rows_b[1::4], -1] = -1\n        jac[rows_b[2::4], 2*np.arange(N)+1] = 1\n        jac[rows_b[2::4], -1] = -1\n        jac[rows_b[3::4], 2*np.arange(N)+1] = -1\n        jac[rows_b[3::4], -1] = -1\n        # Overlap constraints jacobian\n        o_start = 4 * N\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        rows_o = np.arange(o_start, o_start + len(i_idx))\n        jac[rows_o, 2*i_idx] = 2 * dx\n        jac[rows_o, 2*j_idx] = -2 * dx\n        jac[rows_o, 2*i_idx+1] = 2 * dy\n        jac[rows_o, 2*j_idx+1] = -2 * dy\n        jac[rows_o, -1] = -8 * r\n        return jac\n\n    # Initialization: jittered 5x5 grid + one circle\n    np.random.seed(42)\n    x0_xy = []\n    for i in range(5):\n        for j in range(5):\n            x0_xy.extend([0.1 + i * 0.2, 0.1 + j * 0.2])\n    x0_xy.extend([0.95, 0.95])\n    x0_xy = np.array(x0_xy) + np.random.normal(0, 0.01, len(x0_xy))\n    x0_eq = np.concatenate([x0_xy, [0.08]])\n\n    bounds_eq = [(0, 1)] * (2 * N) + [(0, 0.5)]\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"jac\": eq_jac_obj,\n        \"constraints\": {\"type\": \"ineq\", \"fun\": eq_constraints, \"jac\": eq_jac_cons},\n        \"bounds\": bounds_eq,\n        \"options\": {\"maxiter\": 100}\n    }\n\n    # Global search using Basin-hopping\n    res_eq = basinhopping(eq_objective, x0_eq, minimizer_kwargs=minimizer_kwargs, niter=5, stepsize=0.02)\n\n    # --- Phase 2: Optimize individual radii (Polishing) ---\n    def diff_objective(params):\n        return -np.sum(params[2::3])\n\n    def diff_jac_obj(params):\n        j = np.zeros(3 * N)\n        j[2::3] = -1.0\n        return j\n\n    def diff_constraints(params):\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        b_cons = np.zeros(4 * N)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1.0 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1.0 - y - r\n        o_cons = (x[i_idx]-x[j_idx])**2 + (y[i_idx]-y[j_idx])**2 - (r[i_idx]+r[j_idx])**2\n        return np.concatenate([b_cons, o_cons])\n\n    def diff_jac_cons(params):\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        jac = np.zeros((4 * N + len(i_idx), 3 * N))\n        rows_b = np.arange(4 * N)\n        jac[rows_b[0::4], 3*np.arange(N)] = 1\n        jac[rows_b[0::4], 3*np.arange(N)+2] = -1\n        jac[rows_b[1::4], 3*np.arange(N)] = -1\n        jac[rows_b[1::4], 3*np.arange(N)+2] = -1\n        jac[rows_b[2::4], 3*np.arange(N)+1] = 1\n        jac[rows_b[2::4], 3*np.arange(N)+2] = -1\n        jac[rows_b[3::4], 3*np.arange(N)+1] = -1\n        jac[rows_b[3::4], 3*np.arange(N)+2] = -1\n        \n        o_start = 4 * N\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        rr = r[i_idx] + r[j_idx]\n        rows_o = np.arange(o_start, o_start + len(i_idx))\n        jac[rows_o, 3*i_idx] = 2 * dx\n        jac[rows_o, 3*j_idx] = -2 * dx\n        jac[rows_o, 3*i_idx+1] = 2 * dy\n        jac[rows_o, 3*j_idx+1] = -2 * dy\n        jac[rows_o, 3*i_idx+2] = -2 * rr\n        jac[rows_o, 3*j_idx+2] = -2 * rr\n        return jac\n\n    # Start Phase 2 from the best Equal Radii solution\n    x0_diff = np.zeros(3 * N)\n    x0_diff[0::3] = res_eq.x[0::2]\n    x0_diff[1::3] = res_eq.x[1::2]\n    x0_diff[2::3] = res_eq.x[-1]\n\n    bounds_diff = [(0, 1)] * (3 * N)\n    res_diff = minimize(diff_objective, x0_diff, jac=diff_jac_obj,\n                        constraints={\"type\": \"ineq\", \"fun\": diff_constraints, \"jac\": diff_jac_cons},\n                        method=\"SLSQP\", bounds=bounds_diff, options={\"maxiter\": 200})\n\n    # Final result construction\n    final_params = res_diff.x.reshape((N, 3))\n    centers = final_params[:, :2]\n    radii = final_params[:, 2]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 6.031782627105713,
    "error": "ValueError: could not broadcast input array from shape (27,) into shape (26,)"
  },
  "prompt": "\nCombine Basin-hopping with a high-precision local optimizer like SLSQP or L-BFGS-B.\n1. Use Basin-hopping for global exploration.\n2. In each 'hop', run a short SLSQP optimization to push circles against each other and the boundaries.\n3. Maximize the sum of radii for 26 circles in a [0,1]x[0,1] square.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Basin-hopping combined with SLSQP for optimization.\n    \"\"\"\n    N = 26\n    i_idx, j_idx = np.triu_indices(N, k=1)\n\n    # --- Phase 1: Optimize for Equal Radii (Faster exploration) ---\n    def eq_objective(params):\n        return -params[-1]\n\n    def eq_jac_obj(params):\n        j = np.zeros(2 * N + 1)\n        j[-1] = -1.0\n        return j\n\n    def eq_constraints(params):\n        xy = params[:-1]\n        r = params[-1]\n        x = xy[0::2]\n        y = xy[1::2]\n        # Boundary constraints: circles must stay inside [0,1]x[0,1]\n        b_cons = np.zeros(4 * N)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1.0 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1.0 - y - r\n        # Overlap constraints: distance between centers >= sum of radii\n        o_cons = (x[i_idx]-x[j_idx])**2 + (y[i_idx]-y[j_idx])**2 - 4*r**2\n        return np.concatenate([b_cons, o_cons])\n\n    def eq_jac_cons(params):\n        xy = params[:-1]\n        r = params[-1]\n        x = xy[0::2]\n        y = xy[1::2]\n        jac = np.zeros((4 * N + len(i_idx), 2 * N + 1))\n        # Boundary constraints jacobian\n        rows_b = np.arange(4 * N)\n        jac[rows_b[0::4], 2*np.arange(N)] = 1\n        jac[rows_b[0::4], -1] = -1\n        jac[rows_b[1::4], 2*np.arange(N)] = -1\n        jac[rows_b[1::4], -1] = -1\n        jac[rows_b[2::4], 2*np.arange(N)+1] = 1\n        jac[rows_b[2::4], -1] = -1\n        jac[rows_b[3::4], 2*np.arange(N)+1] = -1\n        jac[rows_b[3::4], -1] = -1\n        # Overlap constraints jacobian\n        o_start = 4 * N\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        rows_o = np.arange(o_start, o_start + len(i_idx))\n        jac[rows_o, 2*i_idx] = 2 * dx\n        jac[rows_o, 2*j_idx] = -2 * dx\n        jac[rows_o, 2*i_idx+1] = 2 * dy\n        jac[rows_o, 2*j_idx+1] = -2 * dy\n        jac[rows_o, -1] = -8 * r\n        return jac\n\n    # Initialization: jittered 5x5 grid + one circle\n    np.random.seed(42)\n    x0_xy = []\n    for i in range(5):\n        for j in range(5):\n            x0_xy.extend([0.1 + i * 0.2, 0.1 + j * 0.2])\n    x0_xy.extend([0.95, 0.95])\n    x0_xy = np.array(x0_xy) + np.random.normal(0, 0.01, len(x0_xy))\n    x0_eq = np.concatenate([x0_xy, [0.08]])\n\n    bounds_eq = [(0, 1)] * (2 * N) + [(0, 0.5)]\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"jac\": eq_jac_obj,\n        \"constraints\": {\"type\": \"ineq\", \"fun\": eq_constraints, \"jac\": eq_jac_cons},\n        \"bounds\": bounds_eq,\n        \"options\": {\"maxiter\": 100}\n    }\n\n    # Global search using Basin-hopping\n    res_eq = basinhopping(eq_objective, x0_eq, minimizer_kwargs=minimizer_kwargs, niter=5, stepsize=0.02)\n\n    # --- Phase 2: Optimize individual radii (Polishing) ---\n    def diff_objective(params):\n        return -np.sum(params[2::3])\n\n    def diff_jac_obj(params):\n        j = np.zeros(3 * N)\n        j[2::3] = -1.0\n        return j\n\n    def diff_constraints(params):\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        b_cons = np.zeros(4 * N)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1.0 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1.0 - y - r\n        o_cons = (x[i_idx]-x[j_idx])**2 + (y[i_idx]-y[j_idx])**2 - (r[i_idx]+r[j_idx])**2\n        return np.concatenate([b_cons, o_cons])\n\n    def diff_jac_cons(params):\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        jac = np.zeros((4 * N + len(i_idx), 3 * N))\n        rows_b = np.arange(4 * N)\n        jac[rows_b[0::4], 3*np.arange(N)] = 1\n        jac[rows_b[0::4], 3*np.arange(N)+2] = -1\n        jac[rows_b[1::4], 3*np.arange(N)] = -1\n        jac[rows_b[1::4], 3*np.arange(N)+2] = -1\n        jac[rows_b[2::4], 3*np.arange(N)+1] = 1\n        jac[rows_b[2::4], 3*np.arange(N)+2] = -1\n        jac[rows_b[3::4], 3*np.arange(N)+1] = -1\n        jac[rows_b[3::4], 3*np.arange(N)+2] = -1\n        \n        o_start = 4 * N\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        rr = r[i_idx] + r[j_idx]\n        rows_o = np.arange(o_start, o_start + len(i_idx))\n        jac[rows_o, 3*i_idx] = 2 * dx\n        jac[rows_o, 3*j_idx] = -2 * dx\n        jac[rows_o, 3*i_idx+1] = 2 * dy\n        jac[rows_o, 3*j_idx+1] = -2 * dy\n        jac[rows_o, 3*i_idx+2] = -2 * rr\n        jac[rows_o, 3*j_idx+2] = -2 * rr\n        return jac\n\n    # Start Phase 2 from the best Equal Radii solution\n    x0_diff = np.zeros(3 * N)\n    x0_diff[0::3] = res_eq.x[0::2]\n    x0_diff[1::3] = res_eq.x[1::2]\n    x0_diff[2::3] = res_eq.x[-1]\n\n    bounds_diff = [(0, 1)] * (3 * N)\n    res_diff = minimize(diff_objective, x0_diff, jac=diff_jac_obj,\n                        constraints={\"type\": \"ineq\", \"fun\": diff_constraints, \"jac\": diff_jac_cons},\n                        method=\"SLSQP\", bounds=bounds_diff, options={\"maxiter\": 200})\n\n    # Final result construction\n    final_params = res_diff.x.reshape((N, 3))\n    centers = final_params[:, :2]\n    radii = final_params[:, 2]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:10:08.000481",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 316,
        "candidates_token_count": 2198,
        "thoughts_token_count": 22359
      },
      "response_text_len": 5205
    }
  },
  "llm_call_duration_s": 134.55409436300397,
  "eval_duration_s": 6.031792237074114
}