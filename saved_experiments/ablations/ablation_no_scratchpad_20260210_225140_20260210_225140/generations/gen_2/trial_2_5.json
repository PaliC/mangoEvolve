{
  "trial_id": "trial_2_5",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.spatial.distance import pdist, squareform\nimport time\n\ndef solve_for_radii(centers):\n    \"\"\"\n    Given fixed centers, finds the radii that maximize the sum of radii.\n    This is a linear programming problem.\n    \"\"\"\n    N = len(centers)\n    # Ensure centers are within [0, 1]\n    centers = np.clip(centers, 0, 1)\n    \n    # Boundary constraints: 0 <= r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = []\n    for i in range(N):\n        max_ri = np.min([centers[i, 0], 1.0 - centers[i, 0], \n                         centers[i, 1], 1.0 - centers[i, 1]])\n        bounds.append((0, max(0.0, float(max_ri))))\n    \n    # Pairwise constraints: r_i + r_j <= dist_ij\n    dists = pdist(centers)\n    num_pairs = len(dists)\n    A_ub = np.zeros((num_pairs, N))\n    \n    k = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            A_ub[k, i] = 1.0\n            A_ub[k, j] = 1.0\n            k += 1\n    \n    # Objective: maximize sum of r_i (minimize -sum of r_i)\n    c = -np.ones(N)\n    \n    # Use the 'highs' method for efficiency\n    res = linprog(c, A_ub=A_ub, b_ub=dists, bounds=bounds, method='highs')\n    \n    if res.success:\n        return res.x, -res.fun\n    else:\n        # Fallback to zero radii if optimization fails\n        return np.zeros(N), 0.0\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of radii\n    using a shaking heuristic and pressure-based optimization.\n    \"\"\"\n    N = 26\n    best_centers = None\n    best_radii = None\n    best_sum = -1.0\n    \n    start_time = time.time()\n    \n    # Target radius for the repulsion phase (based on known best for N=26)\n    r_target = 0.10138404\n    \n    while time.time() - start_time < 280:\n        # Use a random start or jitter the current best configuration\n        if best_centers is not None and np.random.rand() > 0.6:\n            centers = best_centers + np.random.normal(0, 0.005, (N, 2))\n        else:\n            centers = np.random.rand(N, 2)\n        \n        # Repulsion-growth phase: resolve overlaps while pushing toward target radius\n        num_iterations = 1200\n        r_current = 0.08  # Start with a smaller radius\n        growth_rate = (r_target - 0.08) / num_iterations\n        \n        for i in range(num_iterations):\n            # Vectorized pairwise distances\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=-1))\n            \n            # Use a large value on diagonal to ignore self-distances\n            np.fill_diagonal(dists, 1e10)\n            \n            # Identify overlapping circles\n            mask = dists < 2 * r_current\n            if np.any(mask):\n                idx_i, idx_j = np.where(mask)\n                d = dists[idx_i, idx_j][:, np.newaxis]\n                overlap = 2 * r_current - d\n                direction = diffs[idx_i, idx_j] / (d + 1e-12)\n                \n                # Apply repulsive forces to centers\n                forces = np.zeros((N, 2))\n                # Symmetric mask counts each pair twice, so 0.5 factor is built-in\n                np.add.at(forces, idx_i, direction * overlap * 0.5)\n                \n                # Decay learning rate over iterations\n                lr = 0.15 * (1.0 - i / num_iterations)\n                centers += forces * lr\n            \n            # Constrain centers to stay within the box for the current radius\n            centers = np.clip(centers, r_current, 1.0 - r_current)\n            \n            # Gradually grow the effective radius\n            r_current += growth_rate\n            \n        # Refine the resulting configuration using Linear Programming for optimal radii\n        centers = np.clip(centers, 0, 1)\n        \n        # Quick check for feasibility/promise before running LP\n        dist_to_bounds = np.minimum(np.minimum(centers[:, 0], 1.0 - centers[:, 0]),\n                                    np.minimum(centers[:, 1], 1.0 - centers[:, 1]))\n        min_boundary_dist = np.min(dist_to_bounds)\n        min_pair_dist = np.min(pdist(centers))\n        r_equal_est = min(min_boundary_dist, min_pair_dist / 2.0)\n        \n        # Solve LP if the configuration is promising\n        if r_equal_est * N > best_sum * 0.98:\n            radii, sum_radii = solve_for_radii(centers)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n    # Final refinement on the best centers found\n    if best_centers is not None:\n        best_radii, best_sum = solve_for_radii(best_centers)\n        \n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.41396491661082,
    "eval_time": 280.6142039299011,
    "error": null
  },
  "prompt": "Try a 'shaking' heuristic: start with a dense packing, then repeatedly 'shake' the circles by adding small random noise and then applying a local pressure-based optimizer to resolve overlaps while expanding radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.spatial.distance import pdist, squareform\nimport time\n\ndef solve_for_radii(centers):\n    \"\"\"\n    Given fixed centers, finds the radii that maximize the sum of radii.\n    This is a linear programming problem.\n    \"\"\"\n    N = len(centers)\n    # Ensure centers are within [0, 1]\n    centers = np.clip(centers, 0, 1)\n    \n    # Boundary constraints: 0 <= r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = []\n    for i in range(N):\n        max_ri = np.min([centers[i, 0], 1.0 - centers[i, 0], \n                         centers[i, 1], 1.0 - centers[i, 1]])\n        bounds.append((0, max(0.0, float(max_ri))))\n    \n    # Pairwise constraints: r_i + r_j <= dist_ij\n    dists = pdist(centers)\n    num_pairs = len(dists)\n    A_ub = np.zeros((num_pairs, N))\n    \n    k = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            A_ub[k, i] = 1.0\n            A_ub[k, j] = 1.0\n            k += 1\n    \n    # Objective: maximize sum of r_i (minimize -sum of r_i)\n    c = -np.ones(N)\n    \n    # Use the 'highs' method for efficiency\n    res = linprog(c, A_ub=A_ub, b_ub=dists, bounds=bounds, method='highs')\n    \n    if res.success:\n        return res.x, -res.fun\n    else:\n        # Fallback to zero radii if optimization fails\n        return np.zeros(N), 0.0\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of radii\n    using a shaking heuristic and pressure-based optimization.\n    \"\"\"\n    N = 26\n    best_centers = None\n    best_radii = None\n    best_sum = -1.0\n    \n    start_time = time.time()\n    \n    # Target radius for the repulsion phase (based on known best for N=26)\n    r_target = 0.10138404\n    \n    while time.time() - start_time < 280:\n        # Use a random start or jitter the current best configuration\n        if best_centers is not None and np.random.rand() > 0.6:\n            centers = best_centers + np.random.normal(0, 0.005, (N, 2))\n        else:\n            centers = np.random.rand(N, 2)\n        \n        # Repulsion-growth phase: resolve overlaps while pushing toward target radius\n        num_iterations = 1200\n        r_current = 0.08  # Start with a smaller radius\n        growth_rate = (r_target - 0.08) / num_iterations\n        \n        for i in range(num_iterations):\n            # Vectorized pairwise distances\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=-1))\n            \n            # Use a large value on diagonal to ignore self-distances\n            np.fill_diagonal(dists, 1e10)\n            \n            # Identify overlapping circles\n            mask = dists < 2 * r_current\n            if np.any(mask):\n                idx_i, idx_j = np.where(mask)\n                d = dists[idx_i, idx_j][:, np.newaxis]\n                overlap = 2 * r_current - d\n                direction = diffs[idx_i, idx_j] / (d + 1e-12)\n                \n                # Apply repulsive forces to centers\n                forces = np.zeros((N, 2))\n                # Symmetric mask counts each pair twice, so 0.5 factor is built-in\n                np.add.at(forces, idx_i, direction * overlap * 0.5)\n                \n                # Decay learning rate over iterations\n                lr = 0.15 * (1.0 - i / num_iterations)\n                centers += forces * lr\n            \n            # Constrain centers to stay within the box for the current radius\n            centers = np.clip(centers, r_current, 1.0 - r_current)\n            \n            # Gradually grow the effective radius\n            r_current += growth_rate\n            \n        # Refine the resulting configuration using Linear Programming for optimal radii\n        centers = np.clip(centers, 0, 1)\n        \n        # Quick check for feasibility/promise before running LP\n        dist_to_bounds = np.minimum(np.minimum(centers[:, 0], 1.0 - centers[:, 0]),\n                                    np.minimum(centers[:, 1], 1.0 - centers[:, 1]))\n        min_boundary_dist = np.min(dist_to_bounds)\n        min_pair_dist = np.min(pdist(centers))\n        r_equal_est = min(min_boundary_dist, min_pair_dist / 2.0)\n        \n        # Solve LP if the configuration is promising\n        if r_equal_est * N > best_sum * 0.98:\n            radii, sum_radii = solve_for_radii(centers)\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                \n    # Final refinement on the best centers found\n    if best_centers is not None:\n        best_radii, best_sum = solve_for_radii(best_centers)\n        \n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:14:28.843609",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 270,
        "candidates_token_count": 1489,
        "thoughts_token_count": 19656
      },
      "response_text_len": 4793
    }
  },
  "llm_call_duration_s": 120.81748491199687,
  "eval_duration_s": 280.614212611923
}