{
  "trial_id": "trial_2_3",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii.\n    Uses Basin-hopping combined with SLSQP for global and local optimization.\n    \"\"\"\n    N = 26\n    \n    # Objective function: maximize sum of radii (minimize negative sum)\n    def objective(vars):\n        # vars is [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n        radii = vars[2::3]\n        return -np.sum(radii)\n\n    # Jacobian of the objective function for faster convergence\n    def obj_jac(vars):\n        jac = np.zeros(len(vars))\n        jac[2::3] = -1\n        return jac\n\n    # Constraint function: circles must be inside the square and must not overlap\n    def constraints(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        \n        # Boundary constraints (4 * N): radius must be within square limits\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        b_cons = np.empty(4 * N)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1 - y - r\n        \n        # Overlap constraints (N * (N-1) / 2): distance between centers >= sum of radii\n        # (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dr = r[:, np.newaxis] + r[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        overlap_sq = dr**2\n        \n        # Extract only the unique pairs (upper triangle of the distance matrix)\n        triu_indices = np.triu_indices(N, k=1)\n        o_cons = dist_sq[triu_indices] - overlap_sq[triu_indices]\n        \n        return np.concatenate([b_cons, o_cons])\n\n    # Jacobian of the constraints for SLSQP\n    def constraints_jac(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        num_overlap = N * (N - 1) // 2\n        jac = np.zeros((4 * N + num_overlap, 3 * N))\n        \n        # Boundary constraints Jacobian: 4 * N constraints\n        for i in range(N):\n            # x[i] - r[i]\n            jac[i*4 + 0, i*3 + 0] = 1; jac[i*4 + 0, i*3 + 2] = -1\n            # 1 - x[i] - r[i]\n            jac[i*4 + 1, i*3 + 0] = -1; jac[i*4 + 1, i*3 + 2] = -1\n            # y[i] - r[i]\n            jac[i*4 + 2, i*3 + 1] = 1; jac[i*4 + 2, i*3 + 2] = -1\n            # 1 - y[i] - r[i]\n            jac[i*4 + 3, i*3 + 1] = -1; jac[i*4 + 3, i*3 + 2] = -1\n            \n        # Overlap constraints Jacobian: N*(N-1)/2 constraints\n        idx = 4 * N\n        triu_i, triu_j = np.triu_indices(N, k=1)\n        for k in range(num_overlap):\n            i, j = triu_i[k], triu_j[k]\n            # Derivative of (x_i-x_j)^2 + (y_i-y_j)^2 - (r_i+r_j)^2\n            jac[idx, i*3 + 0] = 2 * (x[i] - x[j])\n            jac[idx, j*3 + 0] = -2 * (x[i] - x[j])\n            jac[idx, i*3 + 1] = 2 * (y[i] - y[j])\n            jac[idx, j*3 + 1] = -2 * (y[i] - y[j])\n            jac[idx, i*3 + 2] = -2 * (r[i] + r[j])\n            jac[idx, j*3 + 2] = -2 * (r[i] + r[j])\n            idx += 1\n        return jac\n\n    # Structured initial guess based on a 5x5 grid plus one circle\n    def get_initial_guess():\n        # 5x5 grid of centers\n        grid_coords = np.linspace(0.12, 0.88, 5)\n        x_grid, y_grid = np.meshgrid(grid_coords, grid_coords)\n        x_init = np.append(x_grid.flatten(), 0.5)\n        y_init = np.append(y_grid.flatten(), 0.5)\n        \n        # Add slight jitter to break symmetry\n        x_init += np.random.uniform(-0.01, 0.01, N)\n        y_init += np.random.uniform(-0.01, 0.01, N)\n        \n        # Initial radii set to a safe, non-overlapping value\n        r_init = np.full(N, 0.08)\n        \n        guess = np.zeros(3 * N)\n        guess[0::3] = x_init\n        guess[1::3] = y_init\n        guess[2::3] = r_init\n        return guess\n\n    # Optimization setup\n    initial_guess = get_initial_guess()\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"jac\": obj_jac,\n        \"constraints\": {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n        \"bounds\": [(0, 1), (0, 1), (0, 0.5)] * N,\n        \"options\": {\"maxiter\": 100}\n    }\n    \n    # Global search using Basin-hopping\n    # Limits iterations to ensure runtime is within the 300s window\n    res = basinhopping(objective, initial_guess, \n                       minimizer_kwargs=minimizer_kwargs,\n                       niter=10, \n                       stepsize=0.04)\n    \n    # Extract results\n    final_vars = res.x\n    final_centers = np.stack([final_vars[0::3], final_vars[1::3]], axis=1)\n    final_radii = final_vars[2::3]\n    final_sum = -res.fun\n    \n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6197135600647385,
    "eval_time": 3.3903937339782715,
    "error": null
  },
  "prompt": "\nCombine Basin-hopping with a high-precision local optimizer like SLSQP or L-BFGS-B.\n1. Use Basin-hopping for global exploration.\n2. In each 'hop', run a short SLSQP optimization to push circles against each other and the boundaries.\n3. Maximize the sum of radii for 26 circles in a [0,1]x[0,1] square.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1]x[0,1] to maximize the sum of their radii.\n    Uses Basin-hopping combined with SLSQP for global and local optimization.\n    \"\"\"\n    N = 26\n    \n    # Objective function: maximize sum of radii (minimize negative sum)\n    def objective(vars):\n        # vars is [x0, y0, r0, x1, y1, r1, ..., x25, y25, r25]\n        radii = vars[2::3]\n        return -np.sum(radii)\n\n    # Jacobian of the objective function for faster convergence\n    def obj_jac(vars):\n        jac = np.zeros(len(vars))\n        jac[2::3] = -1\n        return jac\n\n    # Constraint function: circles must be inside the square and must not overlap\n    def constraints(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        \n        # Boundary constraints (4 * N): radius must be within square limits\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        b_cons = np.empty(4 * N)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1 - y - r\n        \n        # Overlap constraints (N * (N-1) / 2): distance between centers >= sum of radii\n        # (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dr = r[:, np.newaxis] + r[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        overlap_sq = dr**2\n        \n        # Extract only the unique pairs (upper triangle of the distance matrix)\n        triu_indices = np.triu_indices(N, k=1)\n        o_cons = dist_sq[triu_indices] - overlap_sq[triu_indices]\n        \n        return np.concatenate([b_cons, o_cons])\n\n    # Jacobian of the constraints for SLSQP\n    def constraints_jac(vars):\n        x = vars[0::3]\n        y = vars[1::3]\n        r = vars[2::3]\n        num_overlap = N * (N - 1) // 2\n        jac = np.zeros((4 * N + num_overlap, 3 * N))\n        \n        # Boundary constraints Jacobian: 4 * N constraints\n        for i in range(N):\n            # x[i] - r[i]\n            jac[i*4 + 0, i*3 + 0] = 1; jac[i*4 + 0, i*3 + 2] = -1\n            # 1 - x[i] - r[i]\n            jac[i*4 + 1, i*3 + 0] = -1; jac[i*4 + 1, i*3 + 2] = -1\n            # y[i] - r[i]\n            jac[i*4 + 2, i*3 + 1] = 1; jac[i*4 + 2, i*3 + 2] = -1\n            # 1 - y[i] - r[i]\n            jac[i*4 + 3, i*3 + 1] = -1; jac[i*4 + 3, i*3 + 2] = -1\n            \n        # Overlap constraints Jacobian: N*(N-1)/2 constraints\n        idx = 4 * N\n        triu_i, triu_j = np.triu_indices(N, k=1)\n        for k in range(num_overlap):\n            i, j = triu_i[k], triu_j[k]\n            # Derivative of (x_i-x_j)^2 + (y_i-y_j)^2 - (r_i+r_j)^2\n            jac[idx, i*3 + 0] = 2 * (x[i] - x[j])\n            jac[idx, j*3 + 0] = -2 * (x[i] - x[j])\n            jac[idx, i*3 + 1] = 2 * (y[i] - y[j])\n            jac[idx, j*3 + 1] = -2 * (y[i] - y[j])\n            jac[idx, i*3 + 2] = -2 * (r[i] + r[j])\n            jac[idx, j*3 + 2] = -2 * (r[i] + r[j])\n            idx += 1\n        return jac\n\n    # Structured initial guess based on a 5x5 grid plus one circle\n    def get_initial_guess():\n        # 5x5 grid of centers\n        grid_coords = np.linspace(0.12, 0.88, 5)\n        x_grid, y_grid = np.meshgrid(grid_coords, grid_coords)\n        x_init = np.append(x_grid.flatten(), 0.5)\n        y_init = np.append(y_grid.flatten(), 0.5)\n        \n        # Add slight jitter to break symmetry\n        x_init += np.random.uniform(-0.01, 0.01, N)\n        y_init += np.random.uniform(-0.01, 0.01, N)\n        \n        # Initial radii set to a safe, non-overlapping value\n        r_init = np.full(N, 0.08)\n        \n        guess = np.zeros(3 * N)\n        guess[0::3] = x_init\n        guess[1::3] = y_init\n        guess[2::3] = r_init\n        return guess\n\n    # Optimization setup\n    initial_guess = get_initial_guess()\n    minimizer_kwargs = {\n        \"method\": \"SLSQP\",\n        \"jac\": obj_jac,\n        \"constraints\": {'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n        \"bounds\": [(0, 1), (0, 1), (0, 0.5)] * N,\n        \"options\": {\"maxiter\": 100}\n    }\n    \n    # Global search using Basin-hopping\n    # Limits iterations to ensure runtime is within the 300s window\n    res = basinhopping(objective, initial_guess, \n                       minimizer_kwargs=minimizer_kwargs,\n                       niter=10, \n                       stepsize=0.04)\n    \n    # Extract results\n    final_vars = res.x\n    final_centers = np.stack([final_vars[0::3], final_vars[1::3]], axis=1)\n    final_radii = final_vars[2::3]\n    final_sum = -res.fun\n    \n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:09:42.134719",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 316,
        "candidates_token_count": 1832,
        "thoughts_token_count": 18579
      },
      "response_text_len": 4824
    }
  },
  "llm_call_duration_s": 111.33034021500498,
  "eval_duration_s": 3.3904041490750387
}