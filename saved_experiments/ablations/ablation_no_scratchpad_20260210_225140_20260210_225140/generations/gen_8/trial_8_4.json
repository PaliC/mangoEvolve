{
  "trial_id": "trial_8_4",
  "generation": 8,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of a physics-based repulsion simulation and the SLSQP optimization method.\n    \"\"\"\n    n = 26\n    # Pre-calculate indices for non-overlap constraints\n    triu_indices = np.triu_indices(n, k=1)\n\n    def obj(V):\n        \"\"\"Objective function: minimize the negative sum of radii.\"\"\"\n        return -np.sum(V[2::3])\n\n    def obj_grad(V):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2::3] = -1.0\n        return grad\n\n    def cons(V):\n        \"\"\"Constraint function: returns an array of all inequality constraints.\"\"\"\n        x, y, r = V[0::3], V[1::3], V[2::3]\n        c = np.zeros(4*n + n*(n-1)//2)\n        \n        # Boundary constraints: x - r >= 0, 1 - x - r >= 0, etc.\n        c[0:n] = x - r\n        c[n:2*n] = 1 - x - r\n        c[2*n:3*n] = y - r\n        c[3*n:4*n] = 1 - y - r\n        \n        # Non-overlap constraints: (x_i-x_j)^2 + (y_i-y_j)^2 - (r_i+r_j)^2 >= 0\n        i_idx, j_idx = triu_indices\n        c[4*n:] = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        return c\n\n    def jac(V):\n        \"\"\"Jacobian of the constraint function.\"\"\"\n        x, y, r = V[0::3], V[1::3], V[2::3]\n        num_cons = 4*n + n*(n-1)//2\n        J = np.zeros((num_cons, 3*n))\n        \n        # Boundary constraint derivatives\n        idx = np.arange(n)\n        J[idx, 3*idx] = 1.0; J[idx, 3*idx+2] = -1.0\n        J[n+idx, 3*idx] = -1.0; J[n+idx, 3*idx+2] = -1.0\n        J[2*n+idx, 3*idx+1] = 1.0; J[2*n+idx, 3*idx+2] = -1.0\n        J[3*n+idx, 3*idx+1] = -1.0; J[3*n+idx, 3*idx+2] = -1.0\n            \n        # Pairwise non-overlap derivatives\n        i_idx, j_idx = triu_indices\n        k = np.arange(len(i_idx))\n        row = 4*n + k\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        \n        J[row, 3*i_idx] = 2*dx\n        J[row, 3*j_idx] = -2*dx\n        J[row, 3*i_idx+1] = 2*dy\n        J[row, 3*j_idx+1] = -2*dy\n        J[row, 3*i_idx+2] = -2*dr\n        J[row, 3*j_idx+2] = -2*dr\n        return J\n\n    # Define bounds for each variable: x in [0,1], y in [0,1], r in [0,0.5]\n    bounds = []\n    for _ in range(n):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n\n    best_sum = 0\n    best_V = None\n\n    # Try several starting configurations\n    # trial 0 is a modified grid, others are random\n    for trial in range(12):\n        if trial == 0:\n            # Grid-like start (5x5 grid plus one extra circle)\n            r_val = 0.09\n            x_vals = np.linspace(r_val, 1-r_val, 5)\n            y_vals = np.linspace(r_val, 1-r_val, 5)\n            xx, yy = np.meshgrid(x_vals, y_vals)\n            pos = np.column_stack([xx.ravel(), yy.ravel()])\n            pos = np.vstack([pos, [0.5, 0.5]])\n            pos += np.random.normal(0, 0.005, pos.shape)\n            radii = np.full(n, r_val)\n        else:\n            # Random initialization\n            pos = 0.1 + 0.8 * np.random.rand(n, 2)\n            radii = np.full(n, 0.05)\n\n        # Physics-based repulsion simulation to find a good starting layout\n        for _ in range(600):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist_sq = np.sum(diff**2, axis=-1)\n            dist = np.sqrt(dist_sq + np.eye(n)*1e-9)\n            r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n            overlap = np.maximum(0, r_sum - dist)\n            np.fill_diagonal(overlap, 0)\n            \n            # If no overlaps, slightly increase radii\n            if np.max(overlap) < 1e-6:\n                radii += 0.001\n            \n            # Apply repulsion force based on overlap\n            force_dir = diff / (dist[:, :, np.newaxis] + 1e-9)\n            pos += 0.03 * np.sum(overlap[:, :, np.newaxis] * force_dir, axis=1)\n            \n            # Boundary constraints: keep circles inside the box\n            for j in range(n):\n                pos[j, 0] = np.clip(pos[j, 0], radii[j], 1-radii[j])\n                pos[j, 1] = np.clip(pos[j, 1], radii[j], 1-radii[j])\n\n        # Initial vector for optimization\n        V = np.zeros(3*n)\n        V[0::3], V[1::3], V[2::3] = pos[:, 0], pos[:, 1], radii\n        \n        # Intermediate optimization with limited iterations\n        res = minimize(obj, V, method='SLSQP', jac=obj_grad,\n                       constraints={'type': 'ineq', 'fun': cons, 'jac': jac},\n                       bounds=bounds, options={'maxiter': 80, 'ftol': 1e-6})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_V = res.x\n\n    # Final refinement on the best configuration found\n    res = minimize(obj, best_V, method='SLSQP', jac=obj_grad,\n                   constraints={'type': 'ineq', 'fun': cons, 'jac': jac},\n                   bounds=bounds, options={'maxiter': 300, 'ftol': 1e-9})\n    \n    final_V = res.x\n    centers = np.column_stack((final_V[0::3], final_V[1::3]))\n    radii = final_V[2::3]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.5330641463295587,
    "eval_time": 3.1438984870910645,
    "error": null
  },
  "prompt": "Implement a physics-based simulation where 26 circles are treated as soft spheres that 'inflate' over time.\n    1. Start with small radii at random positions.\n    2. Apply repulsive forces between overlapping circles and from the boundaries.\n    3. Gradually increase the target radii (sum of radii objective) while using a damping force to stabilize the system.\n    4. Once the system reaches an equilibrium, use the configuration as a seed for scipy.optimize.minimize with the SLSQP method to get the exact maximum.\n    ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of a physics-based repulsion simulation and the SLSQP optimization method.\n    \"\"\"\n    n = 26\n    # Pre-calculate indices for non-overlap constraints\n    triu_indices = np.triu_indices(n, k=1)\n\n    def obj(V):\n        \"\"\"Objective function: minimize the negative sum of radii.\"\"\"\n        return -np.sum(V[2::3])\n\n    def obj_grad(V):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2::3] = -1.0\n        return grad\n\n    def cons(V):\n        \"\"\"Constraint function: returns an array of all inequality constraints.\"\"\"\n        x, y, r = V[0::3], V[1::3], V[2::3]\n        c = np.zeros(4*n + n*(n-1)//2)\n        \n        # Boundary constraints: x - r >= 0, 1 - x - r >= 0, etc.\n        c[0:n] = x - r\n        c[n:2*n] = 1 - x - r\n        c[2*n:3*n] = y - r\n        c[3*n:4*n] = 1 - y - r\n        \n        # Non-overlap constraints: (x_i-x_j)^2 + (y_i-y_j)^2 - (r_i+r_j)^2 >= 0\n        i_idx, j_idx = triu_indices\n        c[4*n:] = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        return c\n\n    def jac(V):\n        \"\"\"Jacobian of the constraint function.\"\"\"\n        x, y, r = V[0::3], V[1::3], V[2::3]\n        num_cons = 4*n + n*(n-1)//2\n        J = np.zeros((num_cons, 3*n))\n        \n        # Boundary constraint derivatives\n        idx = np.arange(n)\n        J[idx, 3*idx] = 1.0; J[idx, 3*idx+2] = -1.0\n        J[n+idx, 3*idx] = -1.0; J[n+idx, 3*idx+2] = -1.0\n        J[2*n+idx, 3*idx+1] = 1.0; J[2*n+idx, 3*idx+2] = -1.0\n        J[3*n+idx, 3*idx+1] = -1.0; J[3*n+idx, 3*idx+2] = -1.0\n            \n        # Pairwise non-overlap derivatives\n        i_idx, j_idx = triu_indices\n        k = np.arange(len(i_idx))\n        row = 4*n + k\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        \n        J[row, 3*i_idx] = 2*dx\n        J[row, 3*j_idx] = -2*dx\n        J[row, 3*i_idx+1] = 2*dy\n        J[row, 3*j_idx+1] = -2*dy\n        J[row, 3*i_idx+2] = -2*dr\n        J[row, 3*j_idx+2] = -2*dr\n        return J\n\n    # Define bounds for each variable: x in [0,1], y in [0,1], r in [0,0.5]\n    bounds = []\n    for _ in range(n):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n\n    best_sum = 0\n    best_V = None\n\n    # Try several starting configurations\n    # trial 0 is a modified grid, others are random\n    for trial in range(12):\n        if trial == 0:\n            # Grid-like start (5x5 grid plus one extra circle)\n            r_val = 0.09\n            x_vals = np.linspace(r_val, 1-r_val, 5)\n            y_vals = np.linspace(r_val, 1-r_val, 5)\n            xx, yy = np.meshgrid(x_vals, y_vals)\n            pos = np.column_stack([xx.ravel(), yy.ravel()])\n            pos = np.vstack([pos, [0.5, 0.5]])\n            pos += np.random.normal(0, 0.005, pos.shape)\n            radii = np.full(n, r_val)\n        else:\n            # Random initialization\n            pos = 0.1 + 0.8 * np.random.rand(n, 2)\n            radii = np.full(n, 0.05)\n\n        # Physics-based repulsion simulation to find a good starting layout\n        for _ in range(600):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist_sq = np.sum(diff**2, axis=-1)\n            dist = np.sqrt(dist_sq + np.eye(n)*1e-9)\n            r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n            overlap = np.maximum(0, r_sum - dist)\n            np.fill_diagonal(overlap, 0)\n            \n            # If no overlaps, slightly increase radii\n            if np.max(overlap) < 1e-6:\n                radii += 0.001\n            \n            # Apply repulsion force based on overlap\n            force_dir = diff / (dist[:, :, np.newaxis] + 1e-9)\n            pos += 0.03 * np.sum(overlap[:, :, np.newaxis] * force_dir, axis=1)\n            \n            # Boundary constraints: keep circles inside the box\n            for j in range(n):\n                pos[j, 0] = np.clip(pos[j, 0], radii[j], 1-radii[j])\n                pos[j, 1] = np.clip(pos[j, 1], radii[j], 1-radii[j])\n\n        # Initial vector for optimization\n        V = np.zeros(3*n)\n        V[0::3], V[1::3], V[2::3] = pos[:, 0], pos[:, 1], radii\n        \n        # Intermediate optimization with limited iterations\n        res = minimize(obj, V, method='SLSQP', jac=obj_grad,\n                       constraints={'type': 'ineq', 'fun': cons, 'jac': jac},\n                       bounds=bounds, options={'maxiter': 80, 'ftol': 1e-6})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_V = res.x\n\n    # Final refinement on the best configuration found\n    res = minimize(obj, best_V, method='SLSQP', jac=obj_grad,\n                   constraints={'type': 'ineq', 'fun': cons, 'jac': jac},\n                   bounds=bounds, options={'maxiter': 300, 'ftol': 1e-9})\n    \n    final_V = res.x\n    centers = np.column_stack((final_V[0::3], final_V[1::3]))\n    radii = final_V[2::3]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:58:33.352066",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 339,
        "candidates_token_count": 1948,
        "thoughts_token_count": 19405
      },
      "response_text_len": 5161
    }
  },
  "llm_call_duration_s": 128.0811896469677,
  "eval_duration_s": 3.1439066529273987
}