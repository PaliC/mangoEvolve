{
  "trial_id": "trial_8_2",
  "generation": 8,
  "parent_id": "trial_6_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid approach of grid-based initializations, random exploration, \n    and basin-hopping with SLSQP refinement.\n    \"\"\"\n    n = 26\n    \n    # The objective is to maximize the sum of radii, so we minimize its negative.\n    def objective(vars):\n        # vars: [x1...x26, y1...y26, r1...r26]\n        return -np.sum(vars[2*n:])\n\n    # Jacobian of the objective function.\n    def grad_objective(vars):\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0\n        return grad\n\n    # Inequality constraints: C(vars) >= 0\n    def constraints(vars):\n        x = vars[:n]\n        y = vars[n:2*n]\n        r = vars[2*n:]\n        \n        # Boundary constraints: circles must be entirely inside [0,1] x [0,1]\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0:n] = x - r\n        c_boundary[n:2*n] = 1.0 - x - r\n        c_boundary[2*n:3*n] = y - r\n        c_boundary[3*n:4*n] = 1.0 - y - r\n        \n        # Overlap constraints: distance between centers must be >= sum of radii\n        # (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        c_overlap = np.zeros(n * (n - 1) // 2)\n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                c_overlap[idx] = (x[i]-x[j])**2 + (y[i]-y[j])**2 - (r[i]+r[j])**2\n                idx += 1\n        return np.concatenate([c_boundary, c_overlap])\n\n    # Jacobian of the constraints matrix.\n    def jac_constraints(vars):\n        x = vars[:n]\n        y = vars[n:2*n]\n        r = vars[2*n:]\n        \n        # Boundary Jacobian (4n x 3n)\n        j_boundary = np.zeros((4 * n, 3 * n))\n        for i in range(n):\n            j_boundary[i, i] = 1.0; j_boundary[i, 2*n + i] = -1.0\n            j_boundary[n+i, i] = -1.0; j_boundary[n+i, 2*n + i] = -1.0\n            j_boundary[2*n+i, n+i] = 1.0; j_boundary[2*n+i, 2*n + i] = -1.0\n            j_boundary[3*n+i, n+i] = -1.0; j_boundary[3*n+i, 2*n + i] = -1.0\n        \n        # Overlap Jacobian (n(n-1)/2 x 3n)\n        num_overlap = n * (n - 1) // 2\n        j_overlap = np.zeros((num_overlap, 3 * n))\n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                rr = r[i] + r[j]\n                j_overlap[idx, i] = 2 * dx\n                j_overlap[idx, j] = -2 * dx\n                j_overlap[idx, n + i] = 2 * dy\n                j_overlap[idx, n + j] = -2 * dy\n                j_overlap[idx, 2 * n + i] = -2 * rr\n                j_overlap[idx, 2 * n + j] = -2 * rr\n                idx += 1\n        return np.vstack([j_boundary, j_overlap])\n\n    best_sum = 0\n    best_vars = None\n    \n    # 1. Initial grid-based starts\n    for nx, ny in [(5,5), (6,4), (4,6), (5,6), (6,5)]:\n        x_grid = np.linspace(1/(2*nx), 1-1/(2*nx), nx)\n        y_grid = np.linspace(1/(2*ny), 1-1/(2*ny), ny)\n        xx, yy = np.meshgrid(x_grid, y_grid)\n        cx, cy = xx.flatten(), yy.flatten()\n        if len(cx) > n:\n            cx, cy = cx[:n], cy[:n]\n        elif len(cx) < n:\n            cx = np.append(cx, np.random.uniform(0.1, 0.9, n - len(cx)))\n            cy = np.append(cy, np.random.uniform(0.1, 0.9, n - len(cy)))\n        \n        vars_init = np.concatenate([cx, cy, np.full(n, 0.01)])\n        res = minimize(\n            objective, vars_init, method='SLSQP', jac=grad_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            bounds=[(0, 1)] * (3 * n),\n            options={'maxiter': 70}\n        )\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n\n    # 2. Basin-hopping refinement with random exploration and shaking\n    start_time = time.time()\n    while time.time() - start_time < 260:\n        if np.random.rand() < 0.2:\n            # Random exploration start\n            cx_new = np.random.uniform(0.1, 0.9, n)\n            cy_new = np.random.uniform(0.1, 0.9, n)\n        else:\n            # Local shaking of current best centers\n            cx, cy = best_vars[:n], best_vars[n:2*n]\n            cx_new = np.clip(cx + np.random.normal(0, 0.08, n), 0, 1)\n            cy_new = np.clip(cy + np.random.normal(0, 0.08, n), 0, 1)\n        \n        # Start with small radii to increase feasibility chances\n        vars_init = np.concatenate([cx_new, cy_new, np.full(n, 0.01)])\n        res = minimize(\n            objective, vars_init, method='SLSQP', jac=grad_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            bounds=[(0, 1)] * (3 * n),\n            options={'maxiter': 70}\n        )\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n            \n    # 3. Final high-precision refinement of the overall best found solution\n    res = minimize(\n        objective, best_vars, method='SLSQP', jac=grad_objective,\n        constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n        bounds=[(0, 1)] * (3 * n),\n        options={'maxiter': 1000}\n    )\n    best_vars = res.x\n    best_sum = -res.fun\n    \n    # Extract centers and radii\n    centers = np.column_stack([best_vars[:n], best_vars[n:2*n]])\n    radii = best_vars[2*n:]\n    \n    return centers, radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.5753638890976704,
    "eval_time": 262.8036358356476,
    "error": null
  },
  "prompt": "The best score so far is 2.6359773947794705. \n    Try a hybrid approach:\n    1. Use CMA-ES (from scipy or a simple implementation) to explore the space of circle centers.\n    2. For each candidate set of centers, calculate the maximum possible radii that satisfy non-overlap and boundary constraints (this is a linear programming problem or can be solved greedily).\n    3. Use the best result from CMA-ES as a seed for a final Basin-Hopping + SLSQP refinement.\n    Refer to trial trial_6_1 for inspiration on the refinement step.\n    ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid approach of grid-based initializations, random exploration, \n    and basin-hopping with SLSQP refinement.\n    \"\"\"\n    n = 26\n    \n    # The objective is to maximize the sum of radii, so we minimize its negative.\n    def objective(vars):\n        # vars: [x1...x26, y1...y26, r1...r26]\n        return -np.sum(vars[2*n:])\n\n    # Jacobian of the objective function.\n    def grad_objective(vars):\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0\n        return grad\n\n    # Inequality constraints: C(vars) >= 0\n    def constraints(vars):\n        x = vars[:n]\n        y = vars[n:2*n]\n        r = vars[2*n:]\n        \n        # Boundary constraints: circles must be entirely inside [0,1] x [0,1]\n        # x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n        c_boundary = np.zeros(4 * n)\n        c_boundary[0:n] = x - r\n        c_boundary[n:2*n] = 1.0 - x - r\n        c_boundary[2*n:3*n] = y - r\n        c_boundary[3*n:4*n] = 1.0 - y - r\n        \n        # Overlap constraints: distance between centers must be >= sum of radii\n        # (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        c_overlap = np.zeros(n * (n - 1) // 2)\n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                c_overlap[idx] = (x[i]-x[j])**2 + (y[i]-y[j])**2 - (r[i]+r[j])**2\n                idx += 1\n        return np.concatenate([c_boundary, c_overlap])\n\n    # Jacobian of the constraints matrix.\n    def jac_constraints(vars):\n        x = vars[:n]\n        y = vars[n:2*n]\n        r = vars[2*n:]\n        \n        # Boundary Jacobian (4n x 3n)\n        j_boundary = np.zeros((4 * n, 3 * n))\n        for i in range(n):\n            j_boundary[i, i] = 1.0; j_boundary[i, 2*n + i] = -1.0\n            j_boundary[n+i, i] = -1.0; j_boundary[n+i, 2*n + i] = -1.0\n            j_boundary[2*n+i, n+i] = 1.0; j_boundary[2*n+i, 2*n + i] = -1.0\n            j_boundary[3*n+i, n+i] = -1.0; j_boundary[3*n+i, 2*n + i] = -1.0\n        \n        # Overlap Jacobian (n(n-1)/2 x 3n)\n        num_overlap = n * (n - 1) // 2\n        j_overlap = np.zeros((num_overlap, 3 * n))\n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                rr = r[i] + r[j]\n                j_overlap[idx, i] = 2 * dx\n                j_overlap[idx, j] = -2 * dx\n                j_overlap[idx, n + i] = 2 * dy\n                j_overlap[idx, n + j] = -2 * dy\n                j_overlap[idx, 2 * n + i] = -2 * rr\n                j_overlap[idx, 2 * n + j] = -2 * rr\n                idx += 1\n        return np.vstack([j_boundary, j_overlap])\n\n    best_sum = 0\n    best_vars = None\n    \n    # 1. Initial grid-based starts\n    for nx, ny in [(5,5), (6,4), (4,6), (5,6), (6,5)]:\n        x_grid = np.linspace(1/(2*nx), 1-1/(2*nx), nx)\n        y_grid = np.linspace(1/(2*ny), 1-1/(2*ny), ny)\n        xx, yy = np.meshgrid(x_grid, y_grid)\n        cx, cy = xx.flatten(), yy.flatten()\n        if len(cx) > n:\n            cx, cy = cx[:n], cy[:n]\n        elif len(cx) < n:\n            cx = np.append(cx, np.random.uniform(0.1, 0.9, n - len(cx)))\n            cy = np.append(cy, np.random.uniform(0.1, 0.9, n - len(cy)))\n        \n        vars_init = np.concatenate([cx, cy, np.full(n, 0.01)])\n        res = minimize(\n            objective, vars_init, method='SLSQP', jac=grad_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            bounds=[(0, 1)] * (3 * n),\n            options={'maxiter': 70}\n        )\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n\n    # 2. Basin-hopping refinement with random exploration and shaking\n    start_time = time.time()\n    while time.time() - start_time < 260:\n        if np.random.rand() < 0.2:\n            # Random exploration start\n            cx_new = np.random.uniform(0.1, 0.9, n)\n            cy_new = np.random.uniform(0.1, 0.9, n)\n        else:\n            # Local shaking of current best centers\n            cx, cy = best_vars[:n], best_vars[n:2*n]\n            cx_new = np.clip(cx + np.random.normal(0, 0.08, n), 0, 1)\n            cy_new = np.clip(cy + np.random.normal(0, 0.08, n), 0, 1)\n        \n        # Start with small radii to increase feasibility chances\n        vars_init = np.concatenate([cx_new, cy_new, np.full(n, 0.01)])\n        res = minimize(\n            objective, vars_init, method='SLSQP', jac=grad_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            bounds=[(0, 1)] * (3 * n),\n            options={'maxiter': 70}\n        )\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n            \n    # 3. Final high-precision refinement of the overall best found solution\n    res = minimize(\n        objective, best_vars, method='SLSQP', jac=grad_objective,\n        constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n        bounds=[(0, 1)] * (3 * n),\n        options={'maxiter': 1000}\n    )\n    best_vars = res.x\n    best_sum = -res.fun\n    \n    # Extract centers and radii\n    centers = np.column_stack([best_vars[:n], best_vars[n:2*n]])\n    radii = best_vars[2*n:]\n    \n    return centers, radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:02:58.405997",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 370,
        "candidates_token_count": 2019,
        "thoughts_token_count": 22946
      },
      "response_text_len": 5476
    }
  },
  "llm_call_duration_s": 133.47485320805572,
  "eval_duration_s": 262.80364682804793
}