{
  "trial_id": "trial_8_1",
  "generation": 8,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Barrier Method (Interior Point style) with L-BFGS-B optimization.\n    The potential function is -Sum(radii) - mu * sum(log(constraints)).\n    \"\"\"\n    n_circles = 26\n    \n    def get_initial_params(seed):\n        \"\"\"\n        Creates a slightly perturbed 5x5 grid plus one extra circle as an initial point.\n        \"\"\"\n        np.random.seed(seed)\n        # Create a grid-like structure for the initial centers\n        xs = np.linspace(0.15, 0.85, 5)\n        ys = np.linspace(0.15, 0.85, 5)\n        xv, yv = np.meshgrid(xs, ys)\n        centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n        # Add the 26th circle to the center\n        centers = np.vstack([centers, [0.5, 0.5]])\n        # Break symmetry with small random perturbations\n        centers += np.random.uniform(-0.03, 0.03, centers.shape)\n        # Ensure initial centers are within boundaries\n        centers = np.clip(centers, 0.1, 0.9)\n        # Set initial radii small enough to avoid any initial overlaps\n        radii = np.full(n_circles, 0.03)\n        \n        # Flatten parameters into a 1D array: [x0, y0, r0, x1, y1, r1, ...]\n        params = np.zeros(3 * n_circles)\n        params[0::3] = centers[:, 0]\n        params[1::3] = centers[:, 1]\n        params[2::3] = radii\n        return params\n\n    def objective(params, mu):\n        \"\"\"\n        The barrier objective function: -sum(radii) - mu * sum(log(constraints)).\n        Returns a very large value if constraints are violated.\n        \"\"\"\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        \n        # Boundary constraints: x-r > 0, 1-x-r > 0, y-r > 0, 1-y-r > 0, r > 0\n        c_boundary = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r, r])\n        \n        # Overlap constraints: dist(i,j) - (ri + rj) > 0\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12) # Small epsilon to avoid sqrt(0)\n        r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n        mask = np.triu(np.ones((n_circles, n_circles), dtype=bool), k=1)\n        c_overlap = dist[mask] - r_sum[mask]\n        \n        all_constraints = np.concatenate([c_boundary, c_overlap])\n        \n        # Barrier function: sum(log(constraint))\n        # If any constraint is violated, return a high penalty\n        if np.any(all_constraints <= 0):\n            return 1e12\n            \n        return -np.sum(r) - mu * np.sum(np.log(all_constraints))\n\n    def gradient(params, mu):\n        \"\"\"\n        The analytical gradient of the barrier objective function.\n        \"\"\"\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        grad = np.zeros_like(params)\n        gx, gy, gr = grad[0::3], grad[1::3], grad[2::3]\n        \n        # Derivative of the objective -sum(r)\n        gr -= 1.0\n        \n        # Derivatives of the boundary barrier terms: -mu * log(constraint)\n        # x - r\n        inv_c = mu / np.maximum(x - r, 1e-10)\n        gx -= inv_c; gr += inv_c\n        # 1 - x - r\n        inv_c = mu / np.maximum(1.0 - x - r, 1e-10)\n        gx += inv_c; gr += inv_c\n        # y - r\n        inv_c = mu / np.maximum(y - r, 1e-10)\n        gy -= inv_c; gr += inv_c\n        # 1 - y - r\n        inv_c = mu / np.maximum(1.0 - y - r, 1e-10)\n        gy += inv_c; gr += inv_c\n        # r\n        gr -= mu / np.maximum(r, 1e-10)\n        \n        # Derivatives of the overlap barrier terms: -mu * log(dist - (ri + rj))\n        dx_mat = x[:, np.newaxis] - x[np.newaxis, :]\n        dy_mat = y[:, np.newaxis] - y[np.newaxis, :]\n        dist = np.sqrt(dx_mat**2 + dy_mat**2 + 1e-12)\n        gap = dist - (r[:, np.newaxis] + r[np.newaxis, :])\n        \n        mask = np.triu(np.ones((n_circles, n_circles), dtype=bool), k=1)\n        inv_gap = np.zeros((n_circles, n_circles))\n        inv_gap[mask] = mu / np.maximum(gap[mask], 1e-10)\n        inv_gap_full = inv_gap + inv_gap.T\n        \n        dx_dist = dx_mat / dist\n        dy_dist = dy_mat / dist\n        \n        gx -= np.sum(dx_dist * inv_gap_full, axis=1)\n        gy -= np.sum(dy_dist * inv_gap_full, axis=1)\n        gr += np.sum(inv_gap_full, axis=1)\n        \n        return grad\n\n    best_params = None\n    best_sum_r = -1\n    \n    # Try multiple random initializations to avoid local optima\n    for seed in [42, 123, 789]:\n        current_params = get_initial_params(seed)\n        \n        # Iteratively decrease mu (Interior Point strategy)\n        for mu in [0.01, 0.001, 0.0001, 1e-6]:\n            res = minimize(\n                objective, \n                current_params, \n                args=(mu,), \n                method='L-BFGS-B', \n                jac=gradient, \n                bounds=[(0, 1)] * (3 * n_circles),\n                options={'maxiter': 400}\n            )\n            current_params = res.x\n            \n        final_sum_r = np.sum(current_params[2::3])\n        if final_sum_r > best_sum_r:\n            best_sum_r = final_sum_r\n            best_params = current_params\n            \n    # Reshape best parameters for the final output\n    final_params = best_params.reshape(n_circles, 3)\n    centers = final_params[:, :2]\n    radii = final_params[:, 2]\n    \n    return centers, radii, best_sum_r",
  "metrics": {
    "valid": true,
    "score": 2.237997458023929,
    "eval_time": 0.45363354682922363,
    "error": null
  },
  "prompt": "Pack 26 circles in a unit square to maximize the sum of radii. \n    Use a Barrier Method (Interior Point style) for optimization. \n    Define a potential function: Sum(radii) - mu * sum(log(constraints)), where constraints include \n    circle-circle distances and circle-boundary distances. \n    Iteratively decrease mu and solve using scipy.optimize.minimize (BFGS or L-BFGS-B).\n    Initialize with a high-density grid or a known good packing structure.\n    ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Barrier Method (Interior Point style) with L-BFGS-B optimization.\n    The potential function is -Sum(radii) - mu * sum(log(constraints)).\n    \"\"\"\n    n_circles = 26\n    \n    def get_initial_params(seed):\n        \"\"\"\n        Creates a slightly perturbed 5x5 grid plus one extra circle as an initial point.\n        \"\"\"\n        np.random.seed(seed)\n        # Create a grid-like structure for the initial centers\n        xs = np.linspace(0.15, 0.85, 5)\n        ys = np.linspace(0.15, 0.85, 5)\n        xv, yv = np.meshgrid(xs, ys)\n        centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n        # Add the 26th circle to the center\n        centers = np.vstack([centers, [0.5, 0.5]])\n        # Break symmetry with small random perturbations\n        centers += np.random.uniform(-0.03, 0.03, centers.shape)\n        # Ensure initial centers are within boundaries\n        centers = np.clip(centers, 0.1, 0.9)\n        # Set initial radii small enough to avoid any initial overlaps\n        radii = np.full(n_circles, 0.03)\n        \n        # Flatten parameters into a 1D array: [x0, y0, r0, x1, y1, r1, ...]\n        params = np.zeros(3 * n_circles)\n        params[0::3] = centers[:, 0]\n        params[1::3] = centers[:, 1]\n        params[2::3] = radii\n        return params\n\n    def objective(params, mu):\n        \"\"\"\n        The barrier objective function: -sum(radii) - mu * sum(log(constraints)).\n        Returns a very large value if constraints are violated.\n        \"\"\"\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        \n        # Boundary constraints: x-r > 0, 1-x-r > 0, y-r > 0, 1-y-r > 0, r > 0\n        c_boundary = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r, r])\n        \n        # Overlap constraints: dist(i,j) - (ri + rj) > 0\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12) # Small epsilon to avoid sqrt(0)\n        r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n        mask = np.triu(np.ones((n_circles, n_circles), dtype=bool), k=1)\n        c_overlap = dist[mask] - r_sum[mask]\n        \n        all_constraints = np.concatenate([c_boundary, c_overlap])\n        \n        # Barrier function: sum(log(constraint))\n        # If any constraint is violated, return a high penalty\n        if np.any(all_constraints <= 0):\n            return 1e12\n            \n        return -np.sum(r) - mu * np.sum(np.log(all_constraints))\n\n    def gradient(params, mu):\n        \"\"\"\n        The analytical gradient of the barrier objective function.\n        \"\"\"\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        grad = np.zeros_like(params)\n        gx, gy, gr = grad[0::3], grad[1::3], grad[2::3]\n        \n        # Derivative of the objective -sum(r)\n        gr -= 1.0\n        \n        # Derivatives of the boundary barrier terms: -mu * log(constraint)\n        # x - r\n        inv_c = mu / np.maximum(x - r, 1e-10)\n        gx -= inv_c; gr += inv_c\n        # 1 - x - r\n        inv_c = mu / np.maximum(1.0 - x - r, 1e-10)\n        gx += inv_c; gr += inv_c\n        # y - r\n        inv_c = mu / np.maximum(y - r, 1e-10)\n        gy -= inv_c; gr += inv_c\n        # 1 - y - r\n        inv_c = mu / np.maximum(1.0 - y - r, 1e-10)\n        gy += inv_c; gr += inv_c\n        # r\n        gr -= mu / np.maximum(r, 1e-10)\n        \n        # Derivatives of the overlap barrier terms: -mu * log(dist - (ri + rj))\n        dx_mat = x[:, np.newaxis] - x[np.newaxis, :]\n        dy_mat = y[:, np.newaxis] - y[np.newaxis, :]\n        dist = np.sqrt(dx_mat**2 + dy_mat**2 + 1e-12)\n        gap = dist - (r[:, np.newaxis] + r[np.newaxis, :])\n        \n        mask = np.triu(np.ones((n_circles, n_circles), dtype=bool), k=1)\n        inv_gap = np.zeros((n_circles, n_circles))\n        inv_gap[mask] = mu / np.maximum(gap[mask], 1e-10)\n        inv_gap_full = inv_gap + inv_gap.T\n        \n        dx_dist = dx_mat / dist\n        dy_dist = dy_mat / dist\n        \n        gx -= np.sum(dx_dist * inv_gap_full, axis=1)\n        gy -= np.sum(dy_dist * inv_gap_full, axis=1)\n        gr += np.sum(inv_gap_full, axis=1)\n        \n        return grad\n\n    best_params = None\n    best_sum_r = -1\n    \n    # Try multiple random initializations to avoid local optima\n    for seed in [42, 123, 789]:\n        current_params = get_initial_params(seed)\n        \n        # Iteratively decrease mu (Interior Point strategy)\n        for mu in [0.01, 0.001, 0.0001, 1e-6]:\n            res = minimize(\n                objective, \n                current_params, \n                args=(mu,), \n                method='L-BFGS-B', \n                jac=gradient, \n                bounds=[(0, 1)] * (3 * n_circles),\n                options={'maxiter': 400}\n            )\n            current_params = res.x\n            \n        final_sum_r = np.sum(current_params[2::3])\n        if final_sum_r > best_sum_r:\n            best_sum_r = final_sum_r\n            best_params = current_params\n            \n    # Reshape best parameters for the final output\n    final_params = best_params.reshape(n_circles, 3)\n    centers = final_params[:, :2]\n    radii = final_params[:, 2]\n    \n    return centers, radii, best_sum_r\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:58:15.642631",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 341,
        "candidates_token_count": 1855,
        "thoughts_token_count": 17828
      },
      "response_text_len": 5376
    }
  },
  "llm_call_duration_s": 113.06221843301319,
  "eval_duration_s": 0.4536418030038476
}