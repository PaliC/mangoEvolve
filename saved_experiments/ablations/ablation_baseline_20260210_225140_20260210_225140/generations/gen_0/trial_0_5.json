{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    \"\"\"\n    N = 26\n    \n    def objective(vars):\n        # Objective: minimize -sum(radii)\n        return -np.sum(vars[2*N:])\n\n    def jac_objective(vars):\n        # Gradient of -sum(radii)\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def cons_fun(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        \n        # Non-overlap constraints: dist(i, j) - (ri + rj) >= 0\n        i, j = np.triu_indices(N, k=1)\n        d = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n        non_overlap = d - (r[i] + r[j])\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        b1 = x - r\n        b2 = 1 - x - r\n        b3 = y - r\n        b4 = 1 - y - r\n        \n        return np.concatenate([non_overlap, b1, b2, b3, b4])\n\n    def cons_jac(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        i, j = np.triu_indices(N, k=1)\n        dx = x[i] - x[j]\n        dy = y[i] - y[j]\n        d = np.sqrt(dx**2 + dy**2)\n        d[d == 0] = 1e-9 # Avoid division by zero\n        \n        num_non_overlap = N * (N - 1) // 2\n        jac = np.zeros((num_non_overlap + 4 * N, 3 * N))\n        \n        # Non-overlap Jacobian\n        rows = np.arange(num_non_overlap)\n        jac[rows, i] = dx / d\n        jac[rows, j] = -dx / d\n        jac[rows, N + i] = dy / d\n        jac[rows, N + j] = -dy / d\n        jac[rows, 2 * N + i] = -1\n        jac[rows, 2 * N + j] = -1\n        \n        # Boundary Jacobian\n        for k in range(N):\n            # x[k] - r[k] >= 0\n            jac[num_non_overlap + 4*k, k] = 1\n            jac[num_non_overlap + 4*k, 2*N + k] = -1\n            # 1 - x[k] - r[k] >= 0\n            jac[num_non_overlap + 4*k + 1, k] = -1\n            jac[num_non_overlap + 4*k + 1, 2*N + k] = -1\n            # y[k] - r[k] >= 0\n            jac[num_non_overlap + 4*k + 2, N + k] = 1\n            jac[num_non_overlap + 4*k + 2, 2*N + k] = -1\n            # 1 - y[k] - r[k] >= 0\n            jac[num_non_overlap + 4*k + 3, N + k] = -1\n            jac[num_non_overlap + 4*k + 3, 2*N + k] = -1\n            \n        return jac\n\n    def repulsion_np(x, y, r, iterations=500):\n        # Move centers to reduce overlap and stay within boundaries\n        for _ in range(iterations):\n            dx = x[:, np.newaxis] - x[np.newaxis, :]\n            dy = y[:, np.newaxis] - y[np.newaxis, :]\n            dist = np.sqrt(dx**2 + dy**2)\n            r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n            overlap = r_sum - dist\n            mask = (overlap > 0) & (np.eye(N) == 0)\n            \n            if not np.any(mask):\n                break\n                \n            dist[dist == 0] = 1e-9\n            fx = (overlap * dx / dist) * mask\n            fy = (overlap * dy / dist) * mask\n            \n            x += np.sum(fx, axis=1) * 0.1\n            y += np.sum(fy, axis=1) * 0.1\n            \n            x = np.clip(x, r, 1 - r)\n            y = np.clip(y, r, 1 - r)\n        return x, y\n\n    best_sum = 0\n    best_vars = np.zeros(3*N)\n    \n    start_time = time.time()\n    \n    # Grid initialization\n    xs = np.linspace(0.1, 0.9, 5)\n    ys = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(xs, ys)\n    grid_x = np.append(xv.flatten(), 0.5)\n    grid_y = np.append(yv.flatten(), 0.5)\n    \n    # Run multiple starts using SLSQP refinement\n    for i in range(100):\n        if time.time() - start_time > 260: # Limit execution time\n            break\n            \n        if i == 0:\n            x, y = grid_x.copy(), grid_y.copy()\n            r = np.ones(N) * 0.098\n        else:\n            x = np.random.rand(N)\n            y = np.random.rand(N)\n            r = np.ones(N) * 0.09\n            \n        # Initial repulsion to get closer to a feasible configuration\n        x, y = repulsion_np(x, y, r)\n        vars_init = np.concatenate([x, y, r])\n        \n        # Refine with SLSQP\n        bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n        res = minimize(objective, vars_init, method='SLSQP', jac=jac_objective,\n                       constraints={'type': 'ineq', 'fun': cons_fun, 'jac': cons_jac},\n                       bounds=bounds, options={'maxiter': 100})\n        \n        # Store the best result\n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_vars = res.x\n            \n    # Final output preparation\n    final_x = best_vars[:N]\n    final_y = best_vars[N:2*N]\n    centers = np.column_stack([final_x, final_y])\n    radii = best_vars[2*N:]\n    \n    return centers, radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, total_r = run_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 262.02162194252014,
    "error": "Circle 0 at (0.0, 1.0) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "Maximize the sum of radii for 26 circles in a unit square.\n        Strategy: Repulsion-Refinement.\n        1. Treat the 26 circles as particles with a repulsive potential to spread them evenly in the square.\n        2. After a few iterations of spreading, use the resulting centers as an initial guess for scipy.optimize.minimize.\n        3. Objective: maximize sum of radii. Constraints: non-overlap and square boundaries.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    \"\"\"\n    N = 26\n    \n    def objective(vars):\n        # Objective: minimize -sum(radii)\n        return -np.sum(vars[2*N:])\n\n    def jac_objective(vars):\n        # Gradient of -sum(radii)\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def cons_fun(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        \n        # Non-overlap constraints: dist(i, j) - (ri + rj) >= 0\n        i, j = np.triu_indices(N, k=1)\n        d = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n        non_overlap = d - (r[i] + r[j])\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        b1 = x - r\n        b2 = 1 - x - r\n        b3 = y - r\n        b4 = 1 - y - r\n        \n        return np.concatenate([non_overlap, b1, b2, b3, b4])\n\n    def cons_jac(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        i, j = np.triu_indices(N, k=1)\n        dx = x[i] - x[j]\n        dy = y[i] - y[j]\n        d = np.sqrt(dx**2 + dy**2)\n        d[d == 0] = 1e-9 # Avoid division by zero\n        \n        num_non_overlap = N * (N - 1) // 2\n        jac = np.zeros((num_non_overlap + 4 * N, 3 * N))\n        \n        # Non-overlap Jacobian\n        rows = np.arange(num_non_overlap)\n        jac[rows, i] = dx / d\n        jac[rows, j] = -dx / d\n        jac[rows, N + i] = dy / d\n        jac[rows, N + j] = -dy / d\n        jac[rows, 2 * N + i] = -1\n        jac[rows, 2 * N + j] = -1\n        \n        # Boundary Jacobian\n        for k in range(N):\n            # x[k] - r[k] >= 0\n            jac[num_non_overlap + 4*k, k] = 1\n            jac[num_non_overlap + 4*k, 2*N + k] = -1\n            # 1 - x[k] - r[k] >= 0\n            jac[num_non_overlap + 4*k + 1, k] = -1\n            jac[num_non_overlap + 4*k + 1, 2*N + k] = -1\n            # y[k] - r[k] >= 0\n            jac[num_non_overlap + 4*k + 2, N + k] = 1\n            jac[num_non_overlap + 4*k + 2, 2*N + k] = -1\n            # 1 - y[k] - r[k] >= 0\n            jac[num_non_overlap + 4*k + 3, N + k] = -1\n            jac[num_non_overlap + 4*k + 3, 2*N + k] = -1\n            \n        return jac\n\n    def repulsion_np(x, y, r, iterations=500):\n        # Move centers to reduce overlap and stay within boundaries\n        for _ in range(iterations):\n            dx = x[:, np.newaxis] - x[np.newaxis, :]\n            dy = y[:, np.newaxis] - y[np.newaxis, :]\n            dist = np.sqrt(dx**2 + dy**2)\n            r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n            overlap = r_sum - dist\n            mask = (overlap > 0) & (np.eye(N) == 0)\n            \n            if not np.any(mask):\n                break\n                \n            dist[dist == 0] = 1e-9\n            fx = (overlap * dx / dist) * mask\n            fy = (overlap * dy / dist) * mask\n            \n            x += np.sum(fx, axis=1) * 0.1\n            y += np.sum(fy, axis=1) * 0.1\n            \n            x = np.clip(x, r, 1 - r)\n            y = np.clip(y, r, 1 - r)\n        return x, y\n\n    best_sum = 0\n    best_vars = np.zeros(3*N)\n    \n    start_time = time.time()\n    \n    # Grid initialization\n    xs = np.linspace(0.1, 0.9, 5)\n    ys = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(xs, ys)\n    grid_x = np.append(xv.flatten(), 0.5)\n    grid_y = np.append(yv.flatten(), 0.5)\n    \n    # Run multiple starts using SLSQP refinement\n    for i in range(100):\n        if time.time() - start_time > 260: # Limit execution time\n            break\n            \n        if i == 0:\n            x, y = grid_x.copy(), grid_y.copy()\n            r = np.ones(N) * 0.098\n        else:\n            x = np.random.rand(N)\n            y = np.random.rand(N)\n            r = np.ones(N) * 0.09\n            \n        # Initial repulsion to get closer to a feasible configuration\n        x, y = repulsion_np(x, y, r)\n        vars_init = np.concatenate([x, y, r])\n        \n        # Refine with SLSQP\n        bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n        res = minimize(objective, vars_init, method='SLSQP', jac=jac_objective,\n                       constraints={'type': 'ineq', 'fun': cons_fun, 'jac': cons_jac},\n                       bounds=bounds, options={'maxiter': 100})\n        \n        # Store the best result\n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_vars = res.x\n            \n    # Final output preparation\n    final_x = best_vars[:N]\n    final_y = best_vars[N:2*N]\n    centers = np.column_stack([final_x, final_y])\n    radii = best_vars[2*N:]\n    \n    return centers, radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, total_r = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:58:16.905323",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 323,
        "candidates_token_count": 1810,
        "thoughts_token_count": 19153
      },
      "response_text_len": 4806
    }
  },
  "llm_call_duration_s": 117.32637116895057,
  "eval_duration_s": 262.0216346370289
}