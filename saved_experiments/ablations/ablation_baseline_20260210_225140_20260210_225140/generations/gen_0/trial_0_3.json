{
  "trial_id": "trial_0_3",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid strategy of multi-start repulsion-growth and linear programming.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate the constraint matrix A for the linear programming problem.\n    # The LP variables are the radii r_1, r_2, ..., r_n.\n    # Constraints:\n    # 1. r_i <= min(x_i, 1-x_i, y_i, 1-y_i)  (Boundary)\n    # 2. r_i + r_j <= d_ij                  (Overlap)\n    A_list = []\n    # Boundary constraints: n constraints\n    for i in range(n):\n        row = np.zeros(n)\n        row[i] = 1\n        A_list.append(row)\n    # Overlap constraints: n*(n-1)/2 constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_list.append(row)\n    A = np.array(A_list)\n    \n    # Pre-calculate indices for the upper triangle of the distance matrix\n    triu_indices = np.triu_indices(n, k=1)\n    \n    def optimize_radii(centers):\n        \"\"\"\n        Given fixed centers, finds the radii that maximize the sum of radii\n        using linear programming.\n        \"\"\"\n        # Objective: Maximize sum(r_i) => Minimize -sum(r_i)\n        c = -np.ones(n)\n        b = []\n        \n        # Upper bounds for boundary constraints: r_i <= dist_to_wall\n        for i in range(n):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            b.append(max(0.0, float(max_r)))\n            \n        # Upper bounds for overlap constraints: r_i + r_j <= d_ij\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n        for i in range(n):\n            for j in range(i + 1, n):\n                b.append(float(dist_matrix[i, j]))\n        \n        # Solve the LP using the 'highs' method for speed\n        res = linprog(c, A_ub=A, b_ub=np.array(b), bounds=(0, 1), method='highs')\n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n), 0\n\n    def get_max_equal_r(centers, dist_matrix):\n        \"\"\"\n        Calculates the maximum possible equal radius for given centers.\n        \"\"\"\n        min_dist_half = np.min(dist_matrix[triu_indices]) / 2.0\n        min_bound = np.min([centers[:, 0], 1-centers[:, 0], centers[:, 1], 1-centers[:, 1]])\n        return max(0.0, min(min_dist_half, min_bound))\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Initial grid setup (5x5 grid + 1 extra circle)\n    grid_size = 5\n    grid = np.linspace(0.1, 0.9, grid_size)\n    xx, yy = np.meshgrid(grid, grid)\n    grid_centers = np.column_stack([xx.flatten(), yy.flatten()])\n    grid_centers = np.vstack([grid_centers, [0.5, 0.5]])\n\n    start_idx = 0\n    # Multi-start loop to search for the best configuration of centers\n    while time.time() - start_time < 280:\n        if start_idx == 0:\n            centers = grid_centers.copy()\n        elif start_idx % 8 == 0 and best_centers is not None:\n            # Perturb the best known configuration to explore locally\n            centers = best_centers + np.random.normal(0, 0.02, (n, 2))\n            centers = np.clip(centers, 0, 1)\n        elif start_idx < 10:\n            # Perturb the grid configuration\n            centers = grid_centers + np.random.normal(0, 0.1, (n, 2))\n            centers = np.clip(centers, 0, 1)\n        else:\n            # Completely random initialization\n            centers = np.random.rand(n, 2)\n        \n        # Initial radius for the repulsion-growth heuristic\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1) + 1e-9)\n        r = get_max_equal_r(centers, dist)\n        \n        # Iterative repulsion-growth heuristic\n        for i in range(600):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1) + 1e-9)\n            \n            # If circles overlap at target radius r, push them apart\n            mask = (dist < 2*r) & (dist > 0)\n            if np.any(mask):\n                force = (2*r - dist) * mask\n                force_vec = diff * (force / (dist + 1e-9))[:, :, np.newaxis]\n                centers += np.sum(force_vec, axis=1) * 0.05\n                centers = np.clip(centers, 0, 1)\n            \n            # Occasional small jitter to help escape local optima\n            if i % 200 == 0:\n                centers += np.random.normal(0, 0.001, centers.shape)\n                centers = np.clip(centers, 0, 1)\n\n            # Update the target radius for the next iteration (growth)\n            min_dist_half = np.min(dist[triu_indices]) / 2.0\n            min_bound = np.min([centers[:, 0], 1-centers[:, 0], centers[:, 1], 1-centers[:, 1]])\n            r = min(min_dist_half, min_bound) * 1.005 # Grow target slightly beyond current max\n        \n        # Final LP optimization for the current center configuration\n        radii, sum_r = optimize_radii(centers)\n        if sum_r > best_sum:\n            best_sum = sum_r\n            best_centers = centers.copy()\n            best_radii = radii\n        \n        start_idx += 1\n            \n    return best_centers, best_radii, float(best_sum)",
  "metrics": {
    "valid": true,
    "score": 2.382686655951646,
    "eval_time": 280.70887327194214,
    "error": null
  },
  "prompt": "Maximize the sum of radii for 26 circles in a unit square.\n        Strategy: Radius Growth.\n        1. Start with 26 random points (centers).\n        2. Set all radii to a very small value.\n        3. Use an iterative approach or an optimizer to 'grow' the radii.\n        4. Specifically, use scipy.optimize.minimize with the sum of radii as the objective.\n        5. Use a large number of random center restarts to find a good layout.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid strategy of multi-start repulsion-growth and linear programming.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate the constraint matrix A for the linear programming problem.\n    # The LP variables are the radii r_1, r_2, ..., r_n.\n    # Constraints:\n    # 1. r_i <= min(x_i, 1-x_i, y_i, 1-y_i)  (Boundary)\n    # 2. r_i + r_j <= d_ij                  (Overlap)\n    A_list = []\n    # Boundary constraints: n constraints\n    for i in range(n):\n        row = np.zeros(n)\n        row[i] = 1\n        A_list.append(row)\n    # Overlap constraints: n*(n-1)/2 constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_list.append(row)\n    A = np.array(A_list)\n    \n    # Pre-calculate indices for the upper triangle of the distance matrix\n    triu_indices = np.triu_indices(n, k=1)\n    \n    def optimize_radii(centers):\n        \"\"\"\n        Given fixed centers, finds the radii that maximize the sum of radii\n        using linear programming.\n        \"\"\"\n        # Objective: Maximize sum(r_i) => Minimize -sum(r_i)\n        c = -np.ones(n)\n        b = []\n        \n        # Upper bounds for boundary constraints: r_i <= dist_to_wall\n        for i in range(n):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            b.append(max(0.0, float(max_r)))\n            \n        # Upper bounds for overlap constraints: r_i + r_j <= d_ij\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n        for i in range(n):\n            for j in range(i + 1, n):\n                b.append(float(dist_matrix[i, j]))\n        \n        # Solve the LP using the 'highs' method for speed\n        res = linprog(c, A_ub=A, b_ub=np.array(b), bounds=(0, 1), method='highs')\n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n), 0\n\n    def get_max_equal_r(centers, dist_matrix):\n        \"\"\"\n        Calculates the maximum possible equal radius for given centers.\n        \"\"\"\n        min_dist_half = np.min(dist_matrix[triu_indices]) / 2.0\n        min_bound = np.min([centers[:, 0], 1-centers[:, 0], centers[:, 1], 1-centers[:, 1]])\n        return max(0.0, min(min_dist_half, min_bound))\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Initial grid setup (5x5 grid + 1 extra circle)\n    grid_size = 5\n    grid = np.linspace(0.1, 0.9, grid_size)\n    xx, yy = np.meshgrid(grid, grid)\n    grid_centers = np.column_stack([xx.flatten(), yy.flatten()])\n    grid_centers = np.vstack([grid_centers, [0.5, 0.5]])\n\n    start_idx = 0\n    # Multi-start loop to search for the best configuration of centers\n    while time.time() - start_time < 280:\n        if start_idx == 0:\n            centers = grid_centers.copy()\n        elif start_idx % 8 == 0 and best_centers is not None:\n            # Perturb the best known configuration to explore locally\n            centers = best_centers + np.random.normal(0, 0.02, (n, 2))\n            centers = np.clip(centers, 0, 1)\n        elif start_idx < 10:\n            # Perturb the grid configuration\n            centers = grid_centers + np.random.normal(0, 0.1, (n, 2))\n            centers = np.clip(centers, 0, 1)\n        else:\n            # Completely random initialization\n            centers = np.random.rand(n, 2)\n        \n        # Initial radius for the repulsion-growth heuristic\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1) + 1e-9)\n        r = get_max_equal_r(centers, dist)\n        \n        # Iterative repulsion-growth heuristic\n        for i in range(600):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1) + 1e-9)\n            \n            # If circles overlap at target radius r, push them apart\n            mask = (dist < 2*r) & (dist > 0)\n            if np.any(mask):\n                force = (2*r - dist) * mask\n                force_vec = diff * (force / (dist + 1e-9))[:, :, np.newaxis]\n                centers += np.sum(force_vec, axis=1) * 0.05\n                centers = np.clip(centers, 0, 1)\n            \n            # Occasional small jitter to help escape local optima\n            if i % 200 == 0:\n                centers += np.random.normal(0, 0.001, centers.shape)\n                centers = np.clip(centers, 0, 1)\n\n            # Update the target radius for the next iteration (growth)\n            min_dist_half = np.min(dist[triu_indices]) / 2.0\n            min_bound = np.min([centers[:, 0], 1-centers[:, 0], centers[:, 1], 1-centers[:, 1]])\n            r = min(min_dist_half, min_bound) * 1.005 # Grow target slightly beyond current max\n        \n        # Final LP optimization for the current center configuration\n        radii, sum_r = optimize_radii(centers)\n        if sum_r > best_sum:\n            best_sum = sum_r\n            best_centers = centers.copy()\n            best_radii = radii\n        \n        start_idx += 1\n            \n    return best_centers, best_radii, float(best_sum)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:58:52.699308",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 334,
        "candidates_token_count": 1742,
        "thoughts_token_count": 22711
      },
      "response_text_len": 5373
    }
  },
  "llm_call_duration_s": 134.434121635044,
  "eval_duration_s": 280.70888291101437
}