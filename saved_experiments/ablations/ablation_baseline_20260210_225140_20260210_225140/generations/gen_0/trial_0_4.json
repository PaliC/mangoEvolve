{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses multiple initial configurations (grid-based and random) and \n    optimizes them using Sequential Least Squares Programming (SLSQP).\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def objective(v):\n        # Objective function: -sum(radii) for minimization\n        return -np.sum(v[2*N:])\n    \n    def jac_objective(v):\n        # Jacobian of the objective function\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def cons_fn(v):\n        # Inequality constraints: all returned values must be >= 0\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        res = np.empty(4*N + N*(N-1)//2)\n        # Box constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        res[0:N] = x - r\n        res[N:2*N] = 1.0 - x - r\n        res[2*N:3*N] = y - r\n        res[3*N:4*N] = 1.0 - y - r\n        # Non-overlap constraints: dist(i, j)^2 >= (r_i + r_j)^2\n        idx = 4*N\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            dr = r[i] + r[i+1:]\n            res[idx:idx+N-1-i] = dx**2 + dy**2 - dr**2\n            idx += N-1-i\n        return res\n\n    def jac_cons(v):\n        # Jacobian of the constraints\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        num_cons = 4*N + N*(N-1)//2\n        jac = np.zeros((num_cons, 3*N))\n        # Jacobians for box constraints\n        for i in range(N):\n            jac[i, i] = 1.0; jac[i, 2*N+i] = -1.0\n            jac[N+i, i] = -1.0; jac[N+i, 2*N+i] = -1.0\n            jac[2*N+i, N+i] = 1.0; jac[2*N+i, 2*N+i] = -1.0\n            jac[3*N+i, N+i] = -1.0; jac[3*N+i, 2*N+i] = -1.0\n        \n        # Jacobians for distance constraints\n        idx = 4*N\n        for i in range(N):\n            for j in range(i+1, N):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                dr = r[i] + r[j]\n                jac[idx, i] = 2 * dx\n                jac[idx, j] = -2 * dx\n                jac[idx, N+i] = 2 * dy\n                jac[idx, N+j] = -2 * dy\n                jac[idx, 2*N+i] = -2 * dr\n                jac[idx, 2*N+j] = -2 * dr\n                idx += 1\n        return jac\n\n    # Bounds for x, y in [0, 1] and r in [0, 0.5]\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    best_sum = 0\n    best_v = None\n    \n    # Define several initial configurations\n    inits = []\n    \n    # Initialization 1: 5x5 Grid + 1 circle near a corner\n    np.random.seed(0)\n    g = np.linspace(0.1, 0.9, 5)\n    X, Y = np.meshgrid(g, g)\n    cx, cy = X.flatten(), Y.flatten()\n    cx = np.append(cx, 0.95)\n    cy = np.append(cy, 0.95)\n    # Add small noise to avoid exact overlaps during start\n    cx += np.random.normal(0, 0.001, N)\n    cy += np.random.normal(0, 0.001, N)\n    inits.append(np.concatenate([cx, cy, np.full(N, 0.08)]))\n    \n    # Initialization 2: 6x4 Grid + 2 circles\n    gx, gy = np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4)\n    X, Y = np.meshgrid(gx, gy)\n    cx, cy = X.flatten(), Y.flatten()\n    cx = np.append(cx, [0.1, 0.9])\n    cy = np.append(cy, [0.5, 0.5])\n    cx += np.random.normal(0, 0.001, N)\n    cy += np.random.normal(0, 0.001, N)\n    inits.append(np.concatenate([cx, cy, np.full(N, 0.07)]))\n\n    # Initialization 3: Random distributions\n    for s in range(42, 44):\n        np.random.seed(s)\n        inits.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.full(N, 0.05)]))\n    \n    # Run SLSQP optimization for each initialization\n    for init_v in inits:\n        if time.time() - start_time > 180: break\n        res = minimize(objective, init_v, method='SLSQP', jac=jac_objective,\n                       constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_cons},\n                       bounds=bounds, options={'maxiter': 100, 'ftol': 1e-7})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n            \n    # Refinement: Perform \"shaking\" (local perturbations) to explore nearby optima\n    if best_v is not None:\n        while time.time() - start_time < 270:\n            shaken_v = best_v + np.random.normal(0, 0.001, 3*N)\n            res = minimize(objective, shaken_v, method='SLSQP', jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_cons},\n                           bounds=bounds, options={'maxiter': 100, 'ftol': 1e-8})\n            if -res.fun > best_sum:\n                best_sum = -res.fun\n                best_v = res.x\n\n    # Ensure we have a valid result\n    if best_v is None:\n        best_v = inits[0]\n        best_sum = -objective(best_v)\n\n    # Format the results\n    centers = np.vstack([best_v[:N], best_v[N:2*N]]).T\n    radii = best_v[2*N:]\n    \n    return centers, radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.606840838027085,
    "eval_time": 270.6611876487732,
    "error": null
  },
  "prompt": "Maximize the sum of radii for 26 circles in a unit square.\n        Strategy: Two-stage optimization.\n        1. Stage 1: Solve the standard circle packing problem for 26 circles (maximize the minimum radius 'r' such that all circles have radius 'r').\n        2. Stage 2: Using the centers from Stage 1 as a starting point, allow the radii to vary independently (r1, r2, ..., r26) and maximize their sum using SLSQP.\n        3. This leverages known good structures for equal circles.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses multiple initial configurations (grid-based and random) and \n    optimizes them using Sequential Least Squares Programming (SLSQP).\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def objective(v):\n        # Objective function: -sum(radii) for minimization\n        return -np.sum(v[2*N:])\n    \n    def jac_objective(v):\n        # Jacobian of the objective function\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def cons_fn(v):\n        # Inequality constraints: all returned values must be >= 0\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        res = np.empty(4*N + N*(N-1)//2)\n        # Box constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        res[0:N] = x - r\n        res[N:2*N] = 1.0 - x - r\n        res[2*N:3*N] = y - r\n        res[3*N:4*N] = 1.0 - y - r\n        # Non-overlap constraints: dist(i, j)^2 >= (r_i + r_j)^2\n        idx = 4*N\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            dr = r[i] + r[i+1:]\n            res[idx:idx+N-1-i] = dx**2 + dy**2 - dr**2\n            idx += N-1-i\n        return res\n\n    def jac_cons(v):\n        # Jacobian of the constraints\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        num_cons = 4*N + N*(N-1)//2\n        jac = np.zeros((num_cons, 3*N))\n        # Jacobians for box constraints\n        for i in range(N):\n            jac[i, i] = 1.0; jac[i, 2*N+i] = -1.0\n            jac[N+i, i] = -1.0; jac[N+i, 2*N+i] = -1.0\n            jac[2*N+i, N+i] = 1.0; jac[2*N+i, 2*N+i] = -1.0\n            jac[3*N+i, N+i] = -1.0; jac[3*N+i, 2*N+i] = -1.0\n        \n        # Jacobians for distance constraints\n        idx = 4*N\n        for i in range(N):\n            for j in range(i+1, N):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                dr = r[i] + r[j]\n                jac[idx, i] = 2 * dx\n                jac[idx, j] = -2 * dx\n                jac[idx, N+i] = 2 * dy\n                jac[idx, N+j] = -2 * dy\n                jac[idx, 2*N+i] = -2 * dr\n                jac[idx, 2*N+j] = -2 * dr\n                idx += 1\n        return jac\n\n    # Bounds for x, y in [0, 1] and r in [0, 0.5]\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    best_sum = 0\n    best_v = None\n    \n    # Define several initial configurations\n    inits = []\n    \n    # Initialization 1: 5x5 Grid + 1 circle near a corner\n    np.random.seed(0)\n    g = np.linspace(0.1, 0.9, 5)\n    X, Y = np.meshgrid(g, g)\n    cx, cy = X.flatten(), Y.flatten()\n    cx = np.append(cx, 0.95)\n    cy = np.append(cy, 0.95)\n    # Add small noise to avoid exact overlaps during start\n    cx += np.random.normal(0, 0.001, N)\n    cy += np.random.normal(0, 0.001, N)\n    inits.append(np.concatenate([cx, cy, np.full(N, 0.08)]))\n    \n    # Initialization 2: 6x4 Grid + 2 circles\n    gx, gy = np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4)\n    X, Y = np.meshgrid(gx, gy)\n    cx, cy = X.flatten(), Y.flatten()\n    cx = np.append(cx, [0.1, 0.9])\n    cy = np.append(cy, [0.5, 0.5])\n    cx += np.random.normal(0, 0.001, N)\n    cy += np.random.normal(0, 0.001, N)\n    inits.append(np.concatenate([cx, cy, np.full(N, 0.07)]))\n\n    # Initialization 3: Random distributions\n    for s in range(42, 44):\n        np.random.seed(s)\n        inits.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.full(N, 0.05)]))\n    \n    # Run SLSQP optimization for each initialization\n    for init_v in inits:\n        if time.time() - start_time > 180: break\n        res = minimize(objective, init_v, method='SLSQP', jac=jac_objective,\n                       constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_cons},\n                       bounds=bounds, options={'maxiter': 100, 'ftol': 1e-7})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n            \n    # Refinement: Perform \"shaking\" (local perturbations) to explore nearby optima\n    if best_v is not None:\n        while time.time() - start_time < 270:\n            shaken_v = best_v + np.random.normal(0, 0.001, 3*N)\n            res = minimize(objective, shaken_v, method='SLSQP', jac=jac_objective,\n                           constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_cons},\n                           bounds=bounds, options={'maxiter': 100, 'ftol': 1e-8})\n            if -res.fun > best_sum:\n                best_sum = -res.fun\n                best_v = res.x\n\n    # Ensure we have a valid result\n    if best_v is None:\n        best_v = inits[0]\n        best_sum = -objective(best_v)\n\n    # Format the results\n    centers = np.vstack([best_v[:N], best_v[N:2*N]]).T\n    radii = best_v[2*N:]\n    \n    return centers, radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:58:48.345339",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 347,
        "candidates_token_count": 1886,
        "thoughts_token_count": 22252
      },
      "response_text_len": 4879
    }
  },
  "llm_call_duration_s": 140.12730016198475,
  "eval_duration_s": 270.661198690068
}