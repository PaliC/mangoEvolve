{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses multi-start SLSQP optimization with structured and random initializations.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n\n    # Objective: Minimize negative sum of radii to maximize the sum\n    def obj_func(vars, n):\n        return -np.sum(vars[2*n:])\n\n    # Jacobian of the objective function\n    def obj_jac(vars, n):\n        j = np.zeros(3*n)\n        j[2*n:] = -1\n        return j\n\n    # Constraint function: All must be >= 0\n    # Boundary: x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n    # Overlap: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n    def all_constraints(vars, n):\n        x = vars[:n]\n        y = vars[n:2*n]\n        r = vars[2*n:]\n        c = np.zeros(4*n + n*(n-1)//2)\n        c[0:n] = x - r\n        c[n:2*n] = 1 - x - r\n        c[2*n:3*n] = y - r\n        c[3*n:4*n] = 1 - y - r\n        i_idx, j_idx = np.triu_indices(n, k=1)\n        c[4*n:] = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        return c\n\n    # Jacobian of the constraint function\n    def all_constraints_jac(vars, n):\n        x = vars[:n]\n        y = vars[n:2*n]\n        r = vars[2*n:]\n        m = 4*n + n*(n-1)//2\n        jac = np.zeros((m, 3*n))\n        for i in range(n):\n            # Boundary derivatives\n            jac[i, i] = 1\n            jac[i, 2*n+i] = -1\n            jac[n+i, i] = -1\n            jac[n+i, 2*n+i] = -1\n            jac[2*n+i, n+i] = 1\n            jac[2*n+i, 2*n+i] = -1\n            jac[3*n+i, n+i] = -1\n            jac[3*n+i, 2*n+i] = -1\n        \n        # Overlap derivatives\n        i_idx, j_idx = np.triu_indices(n, k=1)\n        idx = 4*n\n        for k in range(len(i_idx)):\n            i, j = i_idx[k], j_idx[k]\n            dx = x[i] - x[j]\n            dy = y[i] - y[j]\n            dr = r[i] + r[j]\n            jac[idx, i] = 2*dx\n            jac[idx, j] = -2*dx\n            jac[idx, n+i] = 2*dy\n            jac[idx, n+j] = -2*dy\n            jac[idx, 2*n+i] = -2*dr\n            jac[idx, 2*n+j] = -2*dr\n            idx += 1\n        return jac\n\n    best_sum = 0\n    best_vars = None\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    cons = {'type': 'ineq', 'fun': all_constraints, 'jac': all_constraints_jac, 'args': (n,)}\n\n    mode = 0\n    # Multi-start optimization loop\n    while time.time() - start_time < 280:\n        # Different structured and random initializations\n        if mode == 0: nx, ny = 5, 6\n        elif mode == 1: nx, ny = 6, 5\n        elif mode == 2: nx, ny = 4, 7\n        elif mode == 3: nx, ny = 7, 4\n        \n        if mode < 4:\n            # Grid-based layouts\n            x_i = np.linspace(0.1, 0.9, nx)\n            y_i = np.linspace(0.1, 0.9, ny)\n            xv, yv = np.meshgrid(x_i, y_i)\n            xf, yf = xv.flatten(), yv.flatten()\n            idx = np.random.choice(len(xf), n, replace=False)\n            x0 = np.concatenate([xf[idx], yf[idx], np.full(n, 0.05)])\n        elif mode == 4:\n            # 5x5 grid plus one circle in the middle\n            x_i = np.linspace(0.1, 0.9, 5)\n            y_i = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(x_i, y_i)\n            xf = np.append(xv.flatten(), 0.5)\n            yf = np.append(yv.flatten(), 0.5)\n            x0 = np.concatenate([xf, yf, np.full(n, 0.05)])\n        else:\n            # Pure random layout\n            x0 = np.concatenate([np.random.rand(n), np.random.rand(n), np.full(n, 0.05)])\n        \n        # Add jitter to break symmetry\n        x0[:2*n] += np.random.normal(0, 0.01, 2*n)\n        mode = (mode + 1) % 6\n        \n        # Local optimization using SLSQP\n        res = minimize(obj_func, x0, args=(n,), method='SLSQP', jac=obj_jac, \n                       constraints=cons, bounds=bounds, options={'maxiter': 100, 'ftol': 1e-8})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n\n    # Final polish of the best found solution with higher precision\n    if best_vars is not None:\n        res = minimize(obj_func, best_vars, args=(n,), method='SLSQP', jac=obj_jac, \n                       constraints=cons, bounds=bounds, options={'maxiter': 200, 'ftol': 1e-10})\n        best_vars = res.x\n        best_sum = -res.fun\n    \n    centers = np.vstack([best_vars[:n], best_vars[n:2*n]]).T\n    radii = best_vars[2*n:]\n    \n    return (centers, radii, best_sum)",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 282.90720891952515,
    "error": "Circle 2 at (0.2798333496064774, 0.7201666503935227) with radius 0.36008332519676134 extends outside x-bounds"
  },
  "prompt": "Maximize the sum of radii for 26 circles in a unit square.\n        Strategy: Initialization by Grid.\n        1. Try different initial layouts: a 5x5 grid plus one circle, and a staggered/hexagonal-like layout.\n        2. For each layout, use scipy.optimize.minimize (SLSQP) to maximize the sum of radii while maintaining non-overlap and boundary constraints.\n        3. Return the best configuration.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses multi-start SLSQP optimization with structured and random initializations.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n\n    # Objective: Minimize negative sum of radii to maximize the sum\n    def obj_func(vars, n):\n        return -np.sum(vars[2*n:])\n\n    # Jacobian of the objective function\n    def obj_jac(vars, n):\n        j = np.zeros(3*n)\n        j[2*n:] = -1\n        return j\n\n    # Constraint function: All must be >= 0\n    # Boundary: x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n    # Overlap: (x_i - x_j)^2 + (y_i - y_j)^2 - (r_i + r_j)^2 >= 0\n    def all_constraints(vars, n):\n        x = vars[:n]\n        y = vars[n:2*n]\n        r = vars[2*n:]\n        c = np.zeros(4*n + n*(n-1)//2)\n        c[0:n] = x - r\n        c[n:2*n] = 1 - x - r\n        c[2*n:3*n] = y - r\n        c[3*n:4*n] = 1 - y - r\n        i_idx, j_idx = np.triu_indices(n, k=1)\n        c[4*n:] = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        return c\n\n    # Jacobian of the constraint function\n    def all_constraints_jac(vars, n):\n        x = vars[:n]\n        y = vars[n:2*n]\n        r = vars[2*n:]\n        m = 4*n + n*(n-1)//2\n        jac = np.zeros((m, 3*n))\n        for i in range(n):\n            # Boundary derivatives\n            jac[i, i] = 1\n            jac[i, 2*n+i] = -1\n            jac[n+i, i] = -1\n            jac[n+i, 2*n+i] = -1\n            jac[2*n+i, n+i] = 1\n            jac[2*n+i, 2*n+i] = -1\n            jac[3*n+i, n+i] = -1\n            jac[3*n+i, 2*n+i] = -1\n        \n        # Overlap derivatives\n        i_idx, j_idx = np.triu_indices(n, k=1)\n        idx = 4*n\n        for k in range(len(i_idx)):\n            i, j = i_idx[k], j_idx[k]\n            dx = x[i] - x[j]\n            dy = y[i] - y[j]\n            dr = r[i] + r[j]\n            jac[idx, i] = 2*dx\n            jac[idx, j] = -2*dx\n            jac[idx, n+i] = 2*dy\n            jac[idx, n+j] = -2*dy\n            jac[idx, 2*n+i] = -2*dr\n            jac[idx, 2*n+j] = -2*dr\n            idx += 1\n        return jac\n\n    best_sum = 0\n    best_vars = None\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    cons = {'type': 'ineq', 'fun': all_constraints, 'jac': all_constraints_jac, 'args': (n,)}\n\n    mode = 0\n    # Multi-start optimization loop\n    while time.time() - start_time < 280:\n        # Different structured and random initializations\n        if mode == 0: nx, ny = 5, 6\n        elif mode == 1: nx, ny = 6, 5\n        elif mode == 2: nx, ny = 4, 7\n        elif mode == 3: nx, ny = 7, 4\n        \n        if mode < 4:\n            # Grid-based layouts\n            x_i = np.linspace(0.1, 0.9, nx)\n            y_i = np.linspace(0.1, 0.9, ny)\n            xv, yv = np.meshgrid(x_i, y_i)\n            xf, yf = xv.flatten(), yv.flatten()\n            idx = np.random.choice(len(xf), n, replace=False)\n            x0 = np.concatenate([xf[idx], yf[idx], np.full(n, 0.05)])\n        elif mode == 4:\n            # 5x5 grid plus one circle in the middle\n            x_i = np.linspace(0.1, 0.9, 5)\n            y_i = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(x_i, y_i)\n            xf = np.append(xv.flatten(), 0.5)\n            yf = np.append(yv.flatten(), 0.5)\n            x0 = np.concatenate([xf, yf, np.full(n, 0.05)])\n        else:\n            # Pure random layout\n            x0 = np.concatenate([np.random.rand(n), np.random.rand(n), np.full(n, 0.05)])\n        \n        # Add jitter to break symmetry\n        x0[:2*n] += np.random.normal(0, 0.01, 2*n)\n        mode = (mode + 1) % 6\n        \n        # Local optimization using SLSQP\n        res = minimize(obj_func, x0, args=(n,), method='SLSQP', jac=obj_jac, \n                       constraints=cons, bounds=bounds, options={'maxiter': 100, 'ftol': 1e-8})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n\n    # Final polish of the best found solution with higher precision\n    if best_vars is not None:\n        res = minimize(obj_func, best_vars, args=(n,), method='SLSQP', jac=obj_jac, \n                       constraints=cons, bounds=bounds, options={'maxiter': 200, 'ftol': 1e-10})\n        best_vars = res.x\n        best_sum = -res.fun\n    \n    centers = np.vstack([best_vars[:n], best_vars[n:2*n]]).T\n    radii = best_vars[2*n:]\n    \n    return (centers, radii, best_sum)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:58:44.083609",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 323,
        "candidates_token_count": 1773,
        "thoughts_token_count": 20636
      },
      "response_text_len": 4528
    }
  },
  "llm_call_duration_s": 123.62057421496138,
  "eval_duration_s": 282.9072186029516
}