{
  "trial_id": "trial_8_4",
  "generation": 8,
  "parent_id": "trial_6_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses SLSQP for finding good topologies and LP-based coordinate descent for refinement.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # 1. SLSQP Global Search Functions\n    def objective(params):\n        # Maximize sum of radii = Minimize -sum of radii\n        return -np.sum(params[2*N:])\n\n    def grad_obj(params):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    def constraints_func(params):\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_boundary = np.zeros(4 * N)\n        c_boundary[0::4] = x - r\n        c_boundary[1::4] = 1.0 - x - r\n        c_boundary[2::4] = y - r\n        c_boundary[3::4] = 1.0 - y - r\n        \n        # Non-overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        dist_sq = (x[idx_i] - x[idx_j])**2 + (y[idx_i] - y[idx_j])**2\n        r_sum_sq = (r[idx_i] + r[idx_j])**2\n        c_overlap = dist_sq - r_sum_sq\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    def jacobian_func(params):\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        n_boundary = 4 * N\n        n_overlap = N * (N - 1) // 2\n        jac = np.zeros((n_boundary + n_overlap, 3 * N))\n        \n        # Boundary constraints Jacobian\n        idx = np.arange(N)\n        jac[4*idx, idx] = 1\n        jac[4*idx, 2*N+idx] = -1\n        jac[4*idx+1, idx] = -1\n        jac[4*idx+1, 2*N+idx] = -1\n        jac[4*idx+2, N+idx] = 1\n        jac[4*idx+2, 2*N+idx] = -1\n        jac[4*idx+3, N+idx] = -1\n        jac[4*idx+3, 2*N+idx] = -1\n        \n        # Overlap constraints Jacobian\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        overlap_rows = np.arange(n_boundary, n_boundary + n_overlap)\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        dr = r[idx_i] + r[idx_j]\n        \n        jac[overlap_rows, idx_i] = 2 * dx\n        jac[overlap_rows, idx_j] = -2 * dx\n        jac[overlap_rows, N + idx_i] = 2 * dy\n        jac[overlap_rows, N + idx_j] = -2 * dy\n        jac[overlap_rows, 2*N + idx_i] = -2 * dr\n        jac[overlap_rows, 2*N + idx_j] = -2 * dr\n        \n        return jac\n\n    def get_grid_guess():\n        # 5x5 grid plus one extra circle\n        side = 5\n        xs = np.linspace(0.12, 0.88, side)\n        ys = np.linspace(0.12, 0.88, side)\n        xv, yv = np.meshgrid(xs, ys)\n        x_init = np.append(xv.flatten(), [0.5])\n        y_init = np.append(yv.flatten(), [0.5])\n        r_init = np.full(N, 0.08)\n        return np.concatenate([x_init, y_init, r_init])\n\n    def get_random_guess():\n        x_init = np.random.uniform(0.1, 0.9, N)\n        y_init = np.random.uniform(0.1, 0.9, N)\n        r_init = np.full(N, 0.05)\n        return np.concatenate([x_init, y_init, r_init])\n\n    def shake(params):\n        new_params = params.copy()\n        new_params[:2*N] += np.random.uniform(-0.05, 0.05, 2*N)\n        new_params[2*N:] = 0.05\n        new_params[:2*N] = np.clip(new_params[:2*N], 0.05, 0.95)\n        return new_params\n\n    # 2. Global SLSQP Phase\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    best_params = get_grid_guess()\n    res = minimize(objective, best_params, method='SLSQP', jac=grad_obj,\n                   constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                   bounds=bounds, options={'maxiter': 150})\n    best_params = res.x\n    best_sum = -res.fun\n\n    while time.time() - start_time < 170:\n        if np.random.rand() < 0.7:\n            current_params = shake(best_params)\n        else:\n            current_params = get_random_guess()\n        \n        res = minimize(objective, current_params, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 100})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n\n    # 3. LP Refinement Phase (Coordinate Descent on Centers)\n    def solve_lp_fast(x, y):\n        # Boundary constraints as upper bounds on radii\n        b_boundary = np.minimum(np.minimum(x, 1-x), np.minimum(y, 1-y))\n        \n        # Overlap constraints: r_i + r_j <= d_ij\n        A_ub = []\n        b_ub = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                # Only include nearby circles to speed up LP\n                if d < 0.35:\n                    row = np.zeros(N)\n                    row[i] = 1\n                    row[j] = 1\n                    A_ub.append(row)\n                    b_ub.append(d - 1e-9) # Tiny epsilon for safety\n        \n        if not A_ub:\n            return np.sum(b_boundary), b_boundary\n\n        # Solve LP for optimal radii given fixed centers\n        res = linprog(-np.ones(N), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                      bounds=[(0, max(0, b)) for b in b_boundary], method='highs')\n        \n        if res.success:\n            return -res.fun, res.x\n        else:\n            return 0, np.zeros(N)\n\n    curr_x, curr_y = best_params[:N], best_params[N:2*N]\n    curr_sum, curr_r = solve_lp_fast(curr_x, curr_y)\n    \n    step = 0.002\n    while time.time() - start_time < 285:\n        improved = False\n        # Prioritize circles with the smallest radii\n        indices = np.argsort(curr_r)\n        \n        for i in indices:\n            for dx, dy in [(step, 0), (-step, 0), (0, step), (0, -step)]:\n                new_x, new_y = curr_x.copy(), curr_y.copy()\n                new_x[i] = np.clip(new_x[i] + dx, 0, 1)\n                new_y[i] = np.clip(new_y[i] + dy, 0, 1)\n                \n                s, r = solve_lp_fast(new_x, new_y)\n                if s > curr_sum + 1e-7:\n                    curr_sum, curr_r, curr_x, curr_y = s, r, new_x, new_y\n                    improved = True\n                    break\n            if improved: break\n        \n        if not improved:\n            step *= 0.5\n            if step < 1e-6:\n                break\n\n    # 4. Final Output Preparation\n    centers = np.column_stack((curr_x, curr_y))\n    radii = curr_r\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 0.0,
    "eval_time": 175.60716104507446,
    "error": null
  },
  "prompt": "Coordinate Descent Refinement for trial_6_4. Iterate through each circle. For the current circle, perform a small local grid search (or Nelder-Mead) on its (x, y) coordinates. For every test position, calculate the optimal radii for all 26 circles using LP. This is slow, so prioritize circles with the smallest radii or those near the boundaries. Code to improve:\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a targeted shaking strategy with SLSQP local optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # 1. Objective and Constraints\n    def objective(params):\n        # Maximize sum of radii = Minimize -sum of radii\n        return -np.sum(params[2*N:])\n\n    def grad_obj(params):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    def constraints_func(params):\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_boundary = np.zeros(4 * N)\n        c_boundary[0::4] = x - r\n        c_boundary[1::4] = 1.0 - x - r\n        c_boundary[2::4] = y - r\n        c_boundary[3::4] = 1.0 - y - r\n        \n        # Non-overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        dist_sq = (x[idx_i] - x[idx_j])**2 + (y[idx_i] - y[idx_j])**2\n        r_sum_sq = (r[idx_i] + r[idx_j])**2\n        c_overlap = dist_sq - r_sum_sq\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    def jacobian_func(params):\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        n_boundary = 4 * N\n        n_overlap = N * (N - 1) // 2\n        jac = np.zeros((n_boundary + n_overlap, 3 * N))\n        \n        # Boundary constraints Jacobian\n        idx = np.arange(N)\n        jac[4*idx, idx] = 1\n        jac[4*idx, 2*N+idx] = -1\n        jac[4*idx+1, idx] = -1\n        jac[4*idx+1, 2*N+idx] = -1\n        jac[4*idx+2, N+idx] = 1\n        jac[4*idx+2, 2*N+idx] = -1\n        jac[4*idx+3, N+idx] = -1\n        jac[4*idx+3, 2*N+idx] = -1\n        \n        # Overlap constraints Jacobian\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        overlap_rows = np.arange(n_boundary, n_boundary + n_overlap)\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        dr = r[idx_i] + r[idx_j]\n        \n        jac[overlap_rows, idx_i] = 2 * dx\n        jac[overlap_rows, idx_j] = -2 * dx\n        jac[overlap_rows, N + idx_i] = 2 * dy\n        jac[overlap_rows, N + idx_j] = -2 * dy\n        jac[overlap_rows, 2*N + idx_i] = -2 * dr\n        jac[overlap_rows, 2*N + idx_j] = -2 * dr\n        \n        return jac\n\n    # 2. Shaking and Guessing Helpers\n    def get_grid_guess():\n        # A 5x5 grid with one extra circle\n        xs = np.linspace(0.12, 0.88, 5)\n        ys = np.linspace(0.12, 0.88, 5)\n        xv, yv = np.meshgrid(xs, ys)\n        x_init = np.append(xv.flatten(), [0.5])\n        y_init = np.append(yv.flatten(), [0.5])\n        r_init = np.full(N, 0.08)\n        return np.concatenate([x_init, y_init, r_init])\n\n    def get_random_guess():\n        x_init = np.random.uniform(0.1, 0.9, N)\n        y_init = np.random.uniform(0.1, 0.9, N)\n        r_init = np.full(N, 0.05)\n        return np.concatenate([x_init, y_init, r_init])\n\n    def get_loose_circles(params, tol=1e-3):\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        contacts = np.zeros(N, dtype=int)\n        contacts += (x - r < tol) + (1.0 - x - r < tol) + (y - r < tol) + (1.0 - y - r < tol)\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        dist = np.sqrt((x[idx_i] - x[idx_j])**2 + (y[idx_i] - y[idx_j])**2)\n        is_contact = (dist - (r[idx_i] + r[idx_j]) < tol)\n        np.add.at(contacts, idx_i, is_contact)\n        np.add.at(contacts, idx_j, is_contact)\n        return np.where(contacts < 3)[0]\n\n    def shake_targeted(params):\n        loose_indices = get_loose_circles(params)\n        new_params = params.copy()\n        # Always add a tiny jitter to all positions\n        new_params[:2*N] += np.random.uniform(-0.005, 0.005, 2*N)\n        \n        if len(loose_indices) == 0:\n            loose_indices = np.random.choice(N, 3, replace=False)\n        \n        # For targeted loose circles, apply a more aggressive move\n        for idx in loose_indices:\n            if np.random.rand() < 0.6:\n                new_params[idx] = np.random.uniform(0.05, 0.95)\n                new_params[idx+N] = np.random.uniform(0.05, 0.95)\n            else:\n                new_params[idx] += np.random.uniform(-0.1, 0.1)\n                new_params[idx+N] += np.random.uniform(-0.1, 0.1)\n            new_params[idx+2*N] = 0.02\n        \n        new_params[:2*N] = np.clip(new_params[:2*N], 0, 1)\n        return new_params\n\n    # 3. Main Loop\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    best_params = get_grid_guess()\n    best_sum = 0\n    \n    # Initial optimization\n    res = minimize(objective, best_params, method='SLSQP', jac=grad_obj,\n                   constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                   bounds=bounds, options={'maxiter': 150})\n    if np.all(constraints_func(res.x) >= -1e-7):\n        best_params = res.x\n        best_sum = -res.fun\n\n    no_improvement = 0\n    while time.time() - start_time < 280:\n        if no_improvement > 15:\n            current_params = get_random_guess()\n            no_improvement = 0\n        else:\n            current_params = shake_targeted(best_params)\n        \n        res = minimize(objective, current_params, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 100})\n        \n        if np.all(constraints_func(res.x) >= -1e-7):\n            if -res.fun > best_sum + 1e-6:\n                best_sum = -res.fun\n                best_params = res.x\n                no_improvement = 0\n            else:\n                no_improvement += 1\n        else:\n            no_improvement += 1\n\n    # 4. Final Polish\n    res = minimize(objective, best_params, method='SLSQP', jac=grad_obj,\n                   constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                   bounds=bounds, options={'maxiter': 400, 'ftol': 1e-10})\n    \n    if np.all(constraints_func(res.x) >= -1e-7):\n        if -res.fun > best_sum:\n            best_params = res.x\n            best_sum = -res.fun\n\n    # Prepare output\n    x, y, r = best_params[:N], best_params[N:2*N], best_params[2*N:]\n    centers = np.column_stack((x, y))\n    radii = r\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses SLSQP for finding good topologies and LP-based coordinate descent for refinement.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # 1. SLSQP Global Search Functions\n    def objective(params):\n        # Maximize sum of radii = Minimize -sum of radii\n        return -np.sum(params[2*N:])\n\n    def grad_obj(params):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    def constraints_func(params):\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_boundary = np.zeros(4 * N)\n        c_boundary[0::4] = x - r\n        c_boundary[1::4] = 1.0 - x - r\n        c_boundary[2::4] = y - r\n        c_boundary[3::4] = 1.0 - y - r\n        \n        # Non-overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        dist_sq = (x[idx_i] - x[idx_j])**2 + (y[idx_i] - y[idx_j])**2\n        r_sum_sq = (r[idx_i] + r[idx_j])**2\n        c_overlap = dist_sq - r_sum_sq\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    def jacobian_func(params):\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        n_boundary = 4 * N\n        n_overlap = N * (N - 1) // 2\n        jac = np.zeros((n_boundary + n_overlap, 3 * N))\n        \n        # Boundary constraints Jacobian\n        idx = np.arange(N)\n        jac[4*idx, idx] = 1\n        jac[4*idx, 2*N+idx] = -1\n        jac[4*idx+1, idx] = -1\n        jac[4*idx+1, 2*N+idx] = -1\n        jac[4*idx+2, N+idx] = 1\n        jac[4*idx+2, 2*N+idx] = -1\n        jac[4*idx+3, N+idx] = -1\n        jac[4*idx+3, 2*N+idx] = -1\n        \n        # Overlap constraints Jacobian\n        idx_i, idx_j = np.triu_indices(N, k=1)\n        overlap_rows = np.arange(n_boundary, n_boundary + n_overlap)\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        dr = r[idx_i] + r[idx_j]\n        \n        jac[overlap_rows, idx_i] = 2 * dx\n        jac[overlap_rows, idx_j] = -2 * dx\n        jac[overlap_rows, N + idx_i] = 2 * dy\n        jac[overlap_rows, N + idx_j] = -2 * dy\n        jac[overlap_rows, 2*N + idx_i] = -2 * dr\n        jac[overlap_rows, 2*N + idx_j] = -2 * dr\n        \n        return jac\n\n    def get_grid_guess():\n        # 5x5 grid plus one extra circle\n        side = 5\n        xs = np.linspace(0.12, 0.88, side)\n        ys = np.linspace(0.12, 0.88, side)\n        xv, yv = np.meshgrid(xs, ys)\n        x_init = np.append(xv.flatten(), [0.5])\n        y_init = np.append(yv.flatten(), [0.5])\n        r_init = np.full(N, 0.08)\n        return np.concatenate([x_init, y_init, r_init])\n\n    def get_random_guess():\n        x_init = np.random.uniform(0.1, 0.9, N)\n        y_init = np.random.uniform(0.1, 0.9, N)\n        r_init = np.full(N, 0.05)\n        return np.concatenate([x_init, y_init, r_init])\n\n    def shake(params):\n        new_params = params.copy()\n        new_params[:2*N] += np.random.uniform(-0.05, 0.05, 2*N)\n        new_params[2*N:] = 0.05\n        new_params[:2*N] = np.clip(new_params[:2*N], 0.05, 0.95)\n        return new_params\n\n    # 2. Global SLSQP Phase\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    best_params = get_grid_guess()\n    res = minimize(objective, best_params, method='SLSQP', jac=grad_obj,\n                   constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                   bounds=bounds, options={'maxiter': 150})\n    best_params = res.x\n    best_sum = -res.fun\n\n    while time.time() - start_time < 170:\n        if np.random.rand() < 0.7:\n            current_params = shake(best_params)\n        else:\n            current_params = get_random_guess()\n        \n        res = minimize(objective, current_params, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 100})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n\n    # 3. LP Refinement Phase (Coordinate Descent on Centers)\n    def solve_lp_fast(x, y):\n        # Boundary constraints as upper bounds on radii\n        b_boundary = np.minimum(np.minimum(x, 1-x), np.minimum(y, 1-y))\n        \n        # Overlap constraints: r_i + r_j <= d_ij\n        A_ub = []\n        b_ub = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                # Only include nearby circles to speed up LP\n                if d < 0.35:\n                    row = np.zeros(N)\n                    row[i] = 1\n                    row[j] = 1\n                    A_ub.append(row)\n                    b_ub.append(d - 1e-9) # Tiny epsilon for safety\n        \n        if not A_ub:\n            return np.sum(b_boundary), b_boundary\n\n        # Solve LP for optimal radii given fixed centers\n        res = linprog(-np.ones(N), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                      bounds=[(0, max(0, b)) for b in b_boundary], method='highs')\n        \n        if res.success:\n            return -res.fun, res.x\n        else:\n            return 0, np.zeros(N)\n\n    curr_x, curr_y = best_params[:N], best_params[N:2*N]\n    curr_sum, curr_r = solve_lp_fast(curr_x, curr_y)\n    \n    step = 0.002\n    while time.time() - start_time < 285:\n        improved = False\n        # Prioritize circles with the smallest radii\n        indices = np.argsort(curr_r)\n        \n        for i in indices:\n            for dx, dy in [(step, 0), (-step, 0), (0, step), (0, -step)]:\n                new_x, new_y = curr_x.copy(), curr_y.copy()\n                new_x[i] = np.clip(new_x[i] + dx, 0, 1)\n                new_y[i] = np.clip(new_y[i] + dy, 0, 1)\n                \n                s, r = solve_lp_fast(new_x, new_y)\n                if s > curr_sum + 1e-7:\n                    curr_sum, curr_r, curr_x, curr_y = s, r, new_x, new_y\n                    improved = True\n                    break\n            if improved: break\n        \n        if not improved:\n            step *= 0.5\n            if step < 1e-6:\n                break\n\n    # 4. Final Output Preparation\n    centers = np.column_stack((curr_x, curr_y))\n    radii = curr_r\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:06:53.352501",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2704,
        "candidates_token_count": 2385,
        "thoughts_token_count": 14526
      },
      "response_text_len": 6509
    }
  },
  "llm_call_duration_s": 97.89506130106747,
  "eval_duration_s": 175.6071711370023
}