{
  "trial_id": "trial_5_3",
  "generation": 5,
  "parent_id": "trial_3_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-stage approach with penalty-based refinement followed by SLSQP.\n    \"\"\"\n    n = 26\n    \n    def get_initial_guess(seed_idx):\n        \"\"\"Generates various initial circle configurations as seeds for optimization.\"\"\"\n        np.random.seed(seed_idx)\n        if seed_idx == 0:\n            # 5x5 grid + 1 in middle\n            x_grid = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(x_grid, x_grid)\n            x, y = xx.flatten(), yy.flatten()\n            x, y = np.append(x, 0.5), np.append(y, 0.5)\n        elif seed_idx == 1:\n            # 5x5 grid + 1 at top-right corner\n            x_grid = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(x_grid, x_grid)\n            x, y = xx.flatten(), yy.flatten()\n            x, y = np.append(x, 0.95), np.append(y, 0.95)\n        elif seed_idx == 2:\n            # Spread out 5x5 grid + 1 at bottom-left corner\n            x_grid = np.linspace(0.05, 0.95, 5)\n            xx, yy = np.meshgrid(x_grid, x_grid)\n            x, y = xx.flatten(), yy.flatten()\n            x, y = np.append(x, 0.1), np.append(y, 0.1)\n        elif seed_idx == 3:\n            # 4x6 grid + 2 extra\n            x_grid = np.linspace(0.1, 0.9, 4)\n            y_grid = np.linspace(0.1, 0.9, 6)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            x, y = xx.flatten()[:26], yy.flatten()[:26]\n            if len(x) < 26:\n                x = np.append(x, np.random.rand(26-len(x)))\n                y = np.append(y, np.random.rand(26-len(y)))\n        elif seed_idx == 4:\n            # 6x4 grid + 2 extra\n            x_grid = np.linspace(0.1, 0.9, 6)\n            y_grid = np.linspace(0.1, 0.9, 4)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            x, y = xx.flatten()[:26], yy.flatten()[:26]\n            if len(x) < 26:\n                x = np.append(x, np.random.rand(26-len(x)))\n                y = np.append(y, np.random.rand(26-len(y)))\n        else:\n            # Random initialization\n            x = np.random.rand(n)\n            y = np.random.rand(n)\n        \n        # Ensure we have exactly n circles\n        x = x[:n]\n        y = y[:n]\n        # Apply jitter to break symmetry and allow for tighter packing\n        x += (np.random.rand(n) - 0.5) * 0.02\n        y += (np.random.rand(n) - 0.5) * 0.02\n        # Initialize with a plausible common radius\n        r = np.full(n, 0.09)\n        return np.concatenate([x, y, r])\n\n    def penalty_objective(params, weight):\n        \"\"\"Objective function that penalizes overlaps and boundary violations.\"\"\"\n        x = params[:n]\n        y = params[n:2*n]\n        r = params[2*n:3*n]\n        \n        # We want to maximize the sum of radii, so minimize the negative sum\n        obj = -np.sum(r)\n        \n        # Boundary penalties: circles must stay within [0, 1]\n        b_pen = np.sum(np.maximum(0, r - x)**2 + \n                       np.maximum(0, x + r - 1)**2 + \n                       np.maximum(0, r - y)**2 + \n                       np.maximum(0, y + r - 1)**2)\n        \n        # Overlap penalties: distance between centers must be >= sum of radii\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist_sq = dx**2 + dy**2\n        rr = r[:, None] + r[None, :]\n        indices = np.triu_indices(n, 1)\n        # Use squared distance penalty for smoothness\n        o_pen = np.sum(np.maximum(0, rr[indices] - np.sqrt(dist_sq[indices] + 1e-9))**2)\n        \n        return obj + weight * (b_pen + o_pen)\n\n    def slsqp_cons(p):\n        \"\"\"Vectorized hard constraints for SLSQP: boundary and non-overlap.\"\"\"\n        x = p[:n]\n        y = p[n:2*n]\n        r = p[2*n:]\n        # Pre-allocate constraint array for efficiency\n        c = np.empty(4*n + n*(n-1)//2)\n        # Boundary constraints: value >= 0\n        c[:n] = x - r\n        c[n:2*n] = 1 - x - r\n        c[2*n:3*n] = y - r\n        c[3*n:4*n] = 1 - y - r\n        # Non-overlap constraints: distance^2 - sum_radii^2 >= 0\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        rr = r[:, None] + r[None, :]\n        dist_sq = dx**2 + dy**2\n        indices = np.triu_indices(n, 1)\n        c[4*n:] = dist_sq[indices] - rr[indices]**2\n        return c\n\n    best_sum_radii = 0\n    best_params = None\n\n    # Explore multiple seeds to find a higher local maximum\n    for seed_idx in range(6):\n        params = get_initial_guess(seed_idx)\n        \n        # Stage 1: Penalty-based refinement using L-BFGS-B\n        # Gradually increase the weight to transition from soft to hard constraints\n        for weight in [10, 100, 1000]:\n            res = minimize(penalty_objective, params, args=(weight,), \n                           method='L-BFGS-B', \n                           bounds=[(0,1)]*(2*n) + [(0,0.5)]*n,\n                           options={'maxiter': 120})\n            params = res.x\n        \n        # Stage 2: Final refinement with SLSQP using hard constraints\n        res = minimize(lambda p: -np.sum(p[2*n:]), params, method='SLSQP',\n                       bounds=[(0,1)]*(2*n) + [(0,0.5)]*n,\n                       constraints={'type': 'ineq', 'fun': slsqp_cons},\n                       options={'maxiter': 250})\n        \n        current_sum = -res.fun\n        if current_sum > best_sum_radii:\n            best_sum_radii = current_sum\n            best_params = res.x\n\n    # Format the output data\n    centers = np.column_stack([best_params[:n], best_params[n:2*n]])\n    radii = best_params[2*n:3*n]\n    \n    return centers, radii, best_sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.635977394731598,
    "eval_time": 39.33563709259033,
    "error": null
  },
  "prompt": "Implement a 'Multi-Stage Annealing' approach for circle packing. Start with a penalty-based optimization (where overlaps are penalized in the objective) to allow circles to move through each other, then transition to a hard-constraint SLSQP refinement. Use trial_3_4 as one of the seeds.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-stage approach with penalty-based refinement followed by SLSQP.\n    \"\"\"\n    n = 26\n    \n    def get_initial_guess(seed_idx):\n        \"\"\"Generates various initial circle configurations as seeds for optimization.\"\"\"\n        np.random.seed(seed_idx)\n        if seed_idx == 0:\n            # 5x5 grid + 1 in middle\n            x_grid = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(x_grid, x_grid)\n            x, y = xx.flatten(), yy.flatten()\n            x, y = np.append(x, 0.5), np.append(y, 0.5)\n        elif seed_idx == 1:\n            # 5x5 grid + 1 at top-right corner\n            x_grid = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(x_grid, x_grid)\n            x, y = xx.flatten(), yy.flatten()\n            x, y = np.append(x, 0.95), np.append(y, 0.95)\n        elif seed_idx == 2:\n            # Spread out 5x5 grid + 1 at bottom-left corner\n            x_grid = np.linspace(0.05, 0.95, 5)\n            xx, yy = np.meshgrid(x_grid, x_grid)\n            x, y = xx.flatten(), yy.flatten()\n            x, y = np.append(x, 0.1), np.append(y, 0.1)\n        elif seed_idx == 3:\n            # 4x6 grid + 2 extra\n            x_grid = np.linspace(0.1, 0.9, 4)\n            y_grid = np.linspace(0.1, 0.9, 6)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            x, y = xx.flatten()[:26], yy.flatten()[:26]\n            if len(x) < 26:\n                x = np.append(x, np.random.rand(26-len(x)))\n                y = np.append(y, np.random.rand(26-len(y)))\n        elif seed_idx == 4:\n            # 6x4 grid + 2 extra\n            x_grid = np.linspace(0.1, 0.9, 6)\n            y_grid = np.linspace(0.1, 0.9, 4)\n            xx, yy = np.meshgrid(x_grid, y_grid)\n            x, y = xx.flatten()[:26], yy.flatten()[:26]\n            if len(x) < 26:\n                x = np.append(x, np.random.rand(26-len(x)))\n                y = np.append(y, np.random.rand(26-len(y)))\n        else:\n            # Random initialization\n            x = np.random.rand(n)\n            y = np.random.rand(n)\n        \n        # Ensure we have exactly n circles\n        x = x[:n]\n        y = y[:n]\n        # Apply jitter to break symmetry and allow for tighter packing\n        x += (np.random.rand(n) - 0.5) * 0.02\n        y += (np.random.rand(n) - 0.5) * 0.02\n        # Initialize with a plausible common radius\n        r = np.full(n, 0.09)\n        return np.concatenate([x, y, r])\n\n    def penalty_objective(params, weight):\n        \"\"\"Objective function that penalizes overlaps and boundary violations.\"\"\"\n        x = params[:n]\n        y = params[n:2*n]\n        r = params[2*n:3*n]\n        \n        # We want to maximize the sum of radii, so minimize the negative sum\n        obj = -np.sum(r)\n        \n        # Boundary penalties: circles must stay within [0, 1]\n        b_pen = np.sum(np.maximum(0, r - x)**2 + \n                       np.maximum(0, x + r - 1)**2 + \n                       np.maximum(0, r - y)**2 + \n                       np.maximum(0, y + r - 1)**2)\n        \n        # Overlap penalties: distance between centers must be >= sum of radii\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist_sq = dx**2 + dy**2\n        rr = r[:, None] + r[None, :]\n        indices = np.triu_indices(n, 1)\n        # Use squared distance penalty for smoothness\n        o_pen = np.sum(np.maximum(0, rr[indices] - np.sqrt(dist_sq[indices] + 1e-9))**2)\n        \n        return obj + weight * (b_pen + o_pen)\n\n    def slsqp_cons(p):\n        \"\"\"Vectorized hard constraints for SLSQP: boundary and non-overlap.\"\"\"\n        x = p[:n]\n        y = p[n:2*n]\n        r = p[2*n:]\n        # Pre-allocate constraint array for efficiency\n        c = np.empty(4*n + n*(n-1)//2)\n        # Boundary constraints: value >= 0\n        c[:n] = x - r\n        c[n:2*n] = 1 - x - r\n        c[2*n:3*n] = y - r\n        c[3*n:4*n] = 1 - y - r\n        # Non-overlap constraints: distance^2 - sum_radii^2 >= 0\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        rr = r[:, None] + r[None, :]\n        dist_sq = dx**2 + dy**2\n        indices = np.triu_indices(n, 1)\n        c[4*n:] = dist_sq[indices] - rr[indices]**2\n        return c\n\n    best_sum_radii = 0\n    best_params = None\n\n    # Explore multiple seeds to find a higher local maximum\n    for seed_idx in range(6):\n        params = get_initial_guess(seed_idx)\n        \n        # Stage 1: Penalty-based refinement using L-BFGS-B\n        # Gradually increase the weight to transition from soft to hard constraints\n        for weight in [10, 100, 1000]:\n            res = minimize(penalty_objective, params, args=(weight,), \n                           method='L-BFGS-B', \n                           bounds=[(0,1)]*(2*n) + [(0,0.5)]*n,\n                           options={'maxiter': 120})\n            params = res.x\n        \n        # Stage 2: Final refinement with SLSQP using hard constraints\n        res = minimize(lambda p: -np.sum(p[2*n:]), params, method='SLSQP',\n                       bounds=[(0,1)]*(2*n) + [(0,0.5)]*n,\n                       constraints={'type': 'ineq', 'fun': slsqp_cons},\n                       options={'maxiter': 250})\n        \n        current_sum = -res.fun\n        if current_sum > best_sum_radii:\n            best_sum_radii = current_sum\n            best_params = res.x\n\n    # Format the output data\n    centers = np.column_stack([best_params[:n], best_params[n:2*n]])\n    radii = best_params[2*n:3*n]\n    \n    return centers, radii, best_sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:40:10.880135",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 290,
        "candidates_token_count": 1975,
        "thoughts_token_count": 21469
      },
      "response_text_len": 5734
    }
  },
  "llm_call_duration_s": 130.94677864096593,
  "eval_duration_s": 39.33564756507985
}