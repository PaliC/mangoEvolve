{
  "trial_id": "trial_5_4",
  "generation": 5,
  "parent_id": "trial_3_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    # Set a random seed for reproducibility while exploring multiple starts\n    np.random.seed(42)\n    N = 26\n    start_time = time.time()\n    \n    # Precompute indices for overlap constraints to save time in the loop\n    idx1, idx2 = np.triu_indices(N, k=1)\n    num_overlap = len(idx1)\n\n    def objective(params):\n        # params: [x1...x26, y1...y26, r1...r26]\n        # Minimize -sum(radii) to maximize sum(radii)\n        return -np.sum(params[2*N:])\n\n    def obj_jac(params):\n        # Jacobian of objective: 0 for x and y, -1 for r\n        return np.concatenate([np.zeros(2*N), -np.ones(N)])\n\n    def constraints(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        # Wall constraints: x_i - r_i >= 0, 1 - r_i - x_i >= 0, etc.\n        c_wall = np.zeros(4 * N)\n        c_wall[0:N] = x - r\n        c_wall[N:2*N] = 1.0 - r - x\n        c_wall[2*N:3*N] = y - r\n        c_wall[3*N:4*N] = 1.0 - r - y\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        dr = r[idx1] + r[idx2]\n        c_overlap = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([c_wall, c_overlap])\n\n    def jac_constraints(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        jac = np.zeros((4 * N + num_overlap, 3 * N))\n        \n        # Wall constraints\n        indices = np.arange(N)\n        # d(x_i - r_i)/dx_i = 1, d(x_i - r_i)/dr_i = -1\n        jac[indices, indices] = 1\n        jac[indices, 2*N+indices] = -1\n        # d(1 - r_i - x_i)/dx_i = -1, d(1 - r_i - x_i)/dr_i = -1\n        jac[N+indices, indices] = -1\n        jac[N+indices, 2*N+indices] = -1\n        # d(y_i - r_i)/dy_i = 1, d(y_i - r_i)/dr_i = -1\n        jac[2*N+indices, N+indices] = 1\n        jac[2*N+indices, 2*N+indices] = -1\n        # d(1 - r_i - y_i)/dy_i = -1, d(1 - r_i - y_i)/dr_i = -1\n        jac[3*N+indices, N+indices] = -1\n        jac[3*N+indices, 2*N+indices] = -1\n        \n        # Overlap constraints derivatives\n        row_idx = 4 * N + np.arange(num_overlap)\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        dr = r[idx1] + r[idx2]\n        \n        jac[row_idx, idx1] = 2 * dx\n        jac[row_idx, idx2] = -2 * dx\n        jac[row_idx, N + idx1] = 2 * dy\n        jac[row_idx, N + idx2] = -2 * dy\n        jac[row_idx, 2 * N + idx1] = -2 * dr\n        jac[row_idx, 2 * N + idx2] = -2 * dr\n        \n        return jac\n\n    def shake(params, N):\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        eps = 1e-5\n        contacts = np.zeros(N)\n        # Wall contacts\n        contacts += (x - r < eps)\n        contacts += (1.0 - r - x < eps)\n        contacts += (y - r < eps)\n        contacts += (1.0 - r - y < eps)\n        # Circle contacts\n        dist_sq = (x[idx1]-x[idx2])**2 + (y[idx1]-y[idx2])**2\n        is_contact = np.abs(dist_sq - (r[idx1]+r[idx2])**2) < eps\n        for i, j in zip(idx1[is_contact], idx2[is_contact]):\n            contacts[i] += 1\n            contacts[j] += 1\n        \n        new_params = params.copy()\n        for i in range(N):\n            if contacts[i] < 3: # Perturb \"loose\" circles\n                new_params[i] += np.random.uniform(-0.03, 0.03)\n                new_params[N+i] += np.random.uniform(-0.03, 0.03)\n                new_params[2*N+i] *= 1.02 # Try growing slightly\n        # Clip to maintain basic feasibility bounds\n        new_params[:2*N] = np.clip(new_params[:2*N], 0.05, 0.95)\n        new_params[2*N:] = np.clip(new_params[2*N:], 0.01, 0.4)\n        return new_params\n\n    # Initialization strategies\n    guesses = []\n    # 1. Staggered/Hexagonal guess\n    xh, yh = [], []\n    for row in range(6):\n        num_cols = 5 if row % 2 == 0 else 4\n        for col in range(num_cols):\n            xh.append(0.1 + col * 0.2 + (0.1 if row % 2 == 1 else 0))\n            yh.append(0.1 + row * 0.16)\n    guesses.append(np.concatenate([np.array(xh[:N]), np.array(yh[:N]), np.full(N, 0.09)]))\n    \n    # 2. Grid guess\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    guesses.append(np.concatenate([np.append(xg.flatten(), 0.5)[:N], np.append(yg.flatten(), 0.5)[:N], np.full(N, 0.09)]))\n\n    best_sum = 0\n    best_params = guesses[0]\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n\n    # Main optimization loop\n    trial = 0\n    while time.time() - start_time < 250:\n        if trial < len(guesses):\n            initial_params = guesses[trial]\n        else:\n            # Random starts\n            x = np.random.uniform(0.1, 0.9, N)\n            y = np.random.uniform(0.1, 0.9, N)\n            r = np.random.uniform(0.05, 0.1, N)\n            initial_params = np.concatenate([x, y, r])\n        \n        res = minimize(objective, initial_params, method='SLSQP', \n                       jac=obj_jac,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=bounds, options={'maxiter': 80})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n            # Immediate shake and refine for promising results\n            for _ in range(2):\n                shaken = shake(best_params, N)\n                res_shaken = minimize(objective, shaken, method='SLSQP', \n                                      jac=obj_jac,\n                                      constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                                      bounds=bounds, options={'maxiter': 80})\n                if -res_shaken.fun > best_sum:\n                    best_sum = -res_shaken.fun\n                    best_params = res_shaken.x\n        trial += 1\n\n    # Final polish of the best found configuration\n    res_final = minimize(objective, best_params, method='SLSQP', \n                         jac=obj_jac,\n                         constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                         bounds=bounds, options={'maxiter': 500, 'ftol': 1e-9})\n    \n    if -res_final.fun > best_sum:\n        best_params = res_final.x\n        best_sum = -res_final.fun\n\n    centers = np.column_stack([best_params[:N], best_params[N:2*N]])\n    radii = best_params[2*N:]\n    \n    return centers, radii, best_sum",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 253.81450581550598,
    "error": "Circle 0 at (0.0, 1.0) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "Refine trial_3_4 by focusing on 'Loose Circles'. Identify circles that are not in contact with at least 3 other objects (circles or walls) and perturb only those circles while keeping the 'locked' circles fixed, then run a global SLSQP polish. Repeat this targeted shaking.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    # Set a random seed for reproducibility while exploring multiple starts\n    np.random.seed(42)\n    N = 26\n    start_time = time.time()\n    \n    # Precompute indices for overlap constraints to save time in the loop\n    idx1, idx2 = np.triu_indices(N, k=1)\n    num_overlap = len(idx1)\n\n    def objective(params):\n        # params: [x1...x26, y1...y26, r1...r26]\n        # Minimize -sum(radii) to maximize sum(radii)\n        return -np.sum(params[2*N:])\n\n    def obj_jac(params):\n        # Jacobian of objective: 0 for x and y, -1 for r\n        return np.concatenate([np.zeros(2*N), -np.ones(N)])\n\n    def constraints(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        # Wall constraints: x_i - r_i >= 0, 1 - r_i - x_i >= 0, etc.\n        c_wall = np.zeros(4 * N)\n        c_wall[0:N] = x - r\n        c_wall[N:2*N] = 1.0 - r - x\n        c_wall[2*N:3*N] = y - r\n        c_wall[3*N:4*N] = 1.0 - r - y\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        dr = r[idx1] + r[idx2]\n        c_overlap = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([c_wall, c_overlap])\n\n    def jac_constraints(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        jac = np.zeros((4 * N + num_overlap, 3 * N))\n        \n        # Wall constraints\n        indices = np.arange(N)\n        # d(x_i - r_i)/dx_i = 1, d(x_i - r_i)/dr_i = -1\n        jac[indices, indices] = 1\n        jac[indices, 2*N+indices] = -1\n        # d(1 - r_i - x_i)/dx_i = -1, d(1 - r_i - x_i)/dr_i = -1\n        jac[N+indices, indices] = -1\n        jac[N+indices, 2*N+indices] = -1\n        # d(y_i - r_i)/dy_i = 1, d(y_i - r_i)/dr_i = -1\n        jac[2*N+indices, N+indices] = 1\n        jac[2*N+indices, 2*N+indices] = -1\n        # d(1 - r_i - y_i)/dy_i = -1, d(1 - r_i - y_i)/dr_i = -1\n        jac[3*N+indices, N+indices] = -1\n        jac[3*N+indices, 2*N+indices] = -1\n        \n        # Overlap constraints derivatives\n        row_idx = 4 * N + np.arange(num_overlap)\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        dr = r[idx1] + r[idx2]\n        \n        jac[row_idx, idx1] = 2 * dx\n        jac[row_idx, idx2] = -2 * dx\n        jac[row_idx, N + idx1] = 2 * dy\n        jac[row_idx, N + idx2] = -2 * dy\n        jac[row_idx, 2 * N + idx1] = -2 * dr\n        jac[row_idx, 2 * N + idx2] = -2 * dr\n        \n        return jac\n\n    def shake(params, N):\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        eps = 1e-5\n        contacts = np.zeros(N)\n        # Wall contacts\n        contacts += (x - r < eps)\n        contacts += (1.0 - r - x < eps)\n        contacts += (y - r < eps)\n        contacts += (1.0 - r - y < eps)\n        # Circle contacts\n        dist_sq = (x[idx1]-x[idx2])**2 + (y[idx1]-y[idx2])**2\n        is_contact = np.abs(dist_sq - (r[idx1]+r[idx2])**2) < eps\n        for i, j in zip(idx1[is_contact], idx2[is_contact]):\n            contacts[i] += 1\n            contacts[j] += 1\n        \n        new_params = params.copy()\n        for i in range(N):\n            if contacts[i] < 3: # Perturb \"loose\" circles\n                new_params[i] += np.random.uniform(-0.03, 0.03)\n                new_params[N+i] += np.random.uniform(-0.03, 0.03)\n                new_params[2*N+i] *= 1.02 # Try growing slightly\n        # Clip to maintain basic feasibility bounds\n        new_params[:2*N] = np.clip(new_params[:2*N], 0.05, 0.95)\n        new_params[2*N:] = np.clip(new_params[2*N:], 0.01, 0.4)\n        return new_params\n\n    # Initialization strategies\n    guesses = []\n    # 1. Staggered/Hexagonal guess\n    xh, yh = [], []\n    for row in range(6):\n        num_cols = 5 if row % 2 == 0 else 4\n        for col in range(num_cols):\n            xh.append(0.1 + col * 0.2 + (0.1 if row % 2 == 1 else 0))\n            yh.append(0.1 + row * 0.16)\n    guesses.append(np.concatenate([np.array(xh[:N]), np.array(yh[:N]), np.full(N, 0.09)]))\n    \n    # 2. Grid guess\n    xg, yg = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    guesses.append(np.concatenate([np.append(xg.flatten(), 0.5)[:N], np.append(yg.flatten(), 0.5)[:N], np.full(N, 0.09)]))\n\n    best_sum = 0\n    best_params = guesses[0]\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n\n    # Main optimization loop\n    trial = 0\n    while time.time() - start_time < 250:\n        if trial < len(guesses):\n            initial_params = guesses[trial]\n        else:\n            # Random starts\n            x = np.random.uniform(0.1, 0.9, N)\n            y = np.random.uniform(0.1, 0.9, N)\n            r = np.random.uniform(0.05, 0.1, N)\n            initial_params = np.concatenate([x, y, r])\n        \n        res = minimize(objective, initial_params, method='SLSQP', \n                       jac=obj_jac,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=bounds, options={'maxiter': 80})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n            # Immediate shake and refine for promising results\n            for _ in range(2):\n                shaken = shake(best_params, N)\n                res_shaken = minimize(objective, shaken, method='SLSQP', \n                                      jac=obj_jac,\n                                      constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                                      bounds=bounds, options={'maxiter': 80})\n                if -res_shaken.fun > best_sum:\n                    best_sum = -res_shaken.fun\n                    best_params = res_shaken.x\n        trial += 1\n\n    # Final polish of the best found configuration\n    res_final = minimize(objective, best_params, method='SLSQP', \n                         jac=obj_jac,\n                         constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                         bounds=bounds, options={'maxiter': 500, 'ftol': 1e-9})\n    \n    if -res_final.fun > best_sum:\n        best_params = res_final.x\n        best_sum = -res_final.fun\n\n    centers = np.column_stack([best_params[:N], best_params[N:2*N]])\n    radii = best_params[2*N:]\n    \n    return centers, radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:43:40.419702",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 288,
        "candidates_token_count": 2344,
        "thoughts_token_count": 20495
      },
      "response_text_len": 6414
    }
  },
  "llm_call_duration_s": 126.00606071599759,
  "eval_duration_s": 253.81451487494633
}