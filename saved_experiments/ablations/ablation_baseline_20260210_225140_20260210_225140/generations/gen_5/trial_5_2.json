{
  "trial_id": "trial_5_2",
  "generation": 5,
  "parent_id": "trial_1_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start SLSQP approach with high-precision settings and vectorized derivatives.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for vectorized constraint calculations\n    # Overlap constraints index pairs (i, j) where i < j\n    triu_indices = np.triu_indices(N, k=1)\n    num_overlaps = N * (N - 1) // 2\n    num_boundary = 4 * N\n    total_cons = num_overlaps + num_boundary\n\n    def objective(x):\n        # x is a flat array: [x0, y0, r0, x1, y1, r1, ..., xN-1, yN-1, rN-1]\n        # Objective: Maximize sum(radii) => Minimize -sum(radii)\n        return -np.sum(x[2::3])\n\n    def grad_objective(x):\n        # Gradient of the objective function\n        g = np.zeros_like(x)\n        g[2::3] = -1.0\n        return g\n\n    def combined_constraints(x):\n        # xi, yi, ri represent the centers and radii of the N circles\n        xi, yi, ri = x[0::3], x[1::3], x[2::3]\n        idx_i, idx_j = triu_indices\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        overlaps = (xi[idx_i] - xi[idx_j])**2 + (yi[idx_i] - yi[idx_j])**2 - (ri[idx_i] + ri[idx_j])**2\n        \n        # Boundary constraints: circles must stay inside the unit square [0, 1]x[0, 1]\n        # x - r >= 0, 1 - (x + r) >= 0, y - r >= 0, 1 - (y + r) >= 0\n        b = np.zeros(num_boundary)\n        b[0::4] = xi - ri\n        b[1::4] = 1.0 - xi - ri\n        b[2::4] = yi - ri\n        b[3::4] = 1.0 - yi - ri\n        \n        return np.concatenate([overlaps, b])\n\n    def combined_constraints_jac(x):\n        # Jacobian of the combined constraint vector\n        xi, yi, ri = x[0::3], x[1::3], x[2::3]\n        idx_i, idx_j = triu_indices\n        \n        # Jacobian matrix of shape (number of constraints, number of variables)\n        jac = np.zeros((total_cons, 3 * N))\n        \n        # Overlap Jacobian components\n        rows = np.arange(num_overlaps)\n        jac[rows, 3 * idx_i] = 2 * (xi[idx_i] - xi[idx_j])\n        jac[rows, 3 * idx_j] = -2 * (xi[idx_i] - xi[idx_j])\n        jac[rows, 3 * idx_i + 1] = 2 * (yi[idx_i] - yi[idx_j])\n        jac[rows, 3 * idx_j + 1] = -2 * (yi[idx_i] - yi[idx_j])\n        jac[rows, 3 * idx_i + 2] = -2 * (ri[idx_i] + ri[idx_j])\n        jac[rows, 3 * idx_j + 2] = -2 * (ri[idx_i] + ri[idx_j])\n        \n        # Boundary Jacobian components\n        b_start = num_overlaps\n        for k in range(N):\n            # Partial derivatives for boundary constraints of circle k\n            jac[b_start + 4 * k, 3 * k] = 1\n            jac[b_start + 4 * k, 3 * k + 2] = -1\n            jac[b_start + 4 * k + 1, 3 * k] = -1\n            jac[b_start + 4 * k + 1, 3 * k + 2] = -1\n            jac[b_start + 4 * k + 2, 3 * k + 1] = 1\n            jac[b_start + 4 * k + 2, 3 * k + 2] = -1\n            jac[b_start + 4 * k + 3, 3 * k + 1] = -1\n            jac[b_start + 4 * k + 3, 3 * k + 2] = -1\n            \n        return jac\n\n    best_sum = 0\n    best_x = None\n    \n    # Initialization strategies\n    # Strategy 1: Grid-based packing for 25 circles + 1 extra\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid_5x5 = np.vstack([gx.flatten(), gy.flatten()]).T\n    grid_5x5 = np.vstack([grid_5x5, [0.5, 0.5]]) \n\n    iteration = 0\n    # Run optimization from different seeds until the time limit (300s) is near\n    while time.time() - start_time < 285:\n        if iteration == 0:\n            centers = grid_5x5.copy()\n            radii = np.ones(N) * 0.09\n        elif iteration % 5 == 0:\n            # Perturbed grid seed\n            centers = grid_5x5.copy() + np.random.normal(0, 0.05, (N, 2))\n            radii = np.random.rand(N) * 0.1\n        else:\n            # Completely random seed\n            centers = np.random.rand(N, 2)\n            radii = np.random.rand(N) * 0.1\n        \n        # Flatten initial guess\n        x0 = np.zeros(3 * N)\n        x0[0::3] = np.clip(centers[:, 0], 0.1, 0.9)\n        x0[1::3] = np.clip(centers[:, 1], 0.1, 0.9)\n        x0[2::3] = radii\n        \n        # Optimization using SLSQP with vectorized constraints and Jacobian\n        res = minimize(\n            objective, x0, method='SLSQP', jac=grad_objective,\n            constraints={'type': 'ineq', 'fun': combined_constraints, 'jac': combined_constraints_jac},\n            bounds=[(0, 1)] * (3 * N),\n            options={'ftol': 1e-15, 'maxiter': 600}\n        )\n        \n        # Evaluate performance and check feasibility\n        # SLSQP might return 'success: False' due to precision, so we check function value and constraints manually\n        if -res.fun > best_sum:\n            # Check feasibility with a small tolerance (1e-8)\n            if np.all(combined_constraints(res.x) >= -1e-8):\n                best_sum = -res.fun\n                best_x = res.x\n        \n        iteration += 1\n\n    # Final result extraction\n    if best_x is not None:\n        final_centers = np.column_stack((best_x[0::3], best_x[1::3]))\n        final_radii = best_x[2::3]\n        final_sum = -objective(best_x)\n    else:\n        # Fallback in case no solution found (unlikely)\n        final_centers = np.zeros((N, 2))\n        final_radii = np.zeros(N)\n        final_sum = 0.0\n\n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6198159255312,
    "eval_time": 286.89125084877014,
    "error": null
  },
  "prompt": "Improve the 'Growth and Repulsion' strategy from trial_1_2. Use it to generate multiple high-quality initial configurations, then refine each using the high-precision SLSQP settings found in trial_3_4 (ftol=1e-15, vectorized Jacobian).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start SLSQP approach with high-precision settings and vectorized derivatives.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for vectorized constraint calculations\n    # Overlap constraints index pairs (i, j) where i < j\n    triu_indices = np.triu_indices(N, k=1)\n    num_overlaps = N * (N - 1) // 2\n    num_boundary = 4 * N\n    total_cons = num_overlaps + num_boundary\n\n    def objective(x):\n        # x is a flat array: [x0, y0, r0, x1, y1, r1, ..., xN-1, yN-1, rN-1]\n        # Objective: Maximize sum(radii) => Minimize -sum(radii)\n        return -np.sum(x[2::3])\n\n    def grad_objective(x):\n        # Gradient of the objective function\n        g = np.zeros_like(x)\n        g[2::3] = -1.0\n        return g\n\n    def combined_constraints(x):\n        # xi, yi, ri represent the centers and radii of the N circles\n        xi, yi, ri = x[0::3], x[1::3], x[2::3]\n        idx_i, idx_j = triu_indices\n        \n        # Overlap constraints: (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2 >= 0\n        overlaps = (xi[idx_i] - xi[idx_j])**2 + (yi[idx_i] - yi[idx_j])**2 - (ri[idx_i] + ri[idx_j])**2\n        \n        # Boundary constraints: circles must stay inside the unit square [0, 1]x[0, 1]\n        # x - r >= 0, 1 - (x + r) >= 0, y - r >= 0, 1 - (y + r) >= 0\n        b = np.zeros(num_boundary)\n        b[0::4] = xi - ri\n        b[1::4] = 1.0 - xi - ri\n        b[2::4] = yi - ri\n        b[3::4] = 1.0 - yi - ri\n        \n        return np.concatenate([overlaps, b])\n\n    def combined_constraints_jac(x):\n        # Jacobian of the combined constraint vector\n        xi, yi, ri = x[0::3], x[1::3], x[2::3]\n        idx_i, idx_j = triu_indices\n        \n        # Jacobian matrix of shape (number of constraints, number of variables)\n        jac = np.zeros((total_cons, 3 * N))\n        \n        # Overlap Jacobian components\n        rows = np.arange(num_overlaps)\n        jac[rows, 3 * idx_i] = 2 * (xi[idx_i] - xi[idx_j])\n        jac[rows, 3 * idx_j] = -2 * (xi[idx_i] - xi[idx_j])\n        jac[rows, 3 * idx_i + 1] = 2 * (yi[idx_i] - yi[idx_j])\n        jac[rows, 3 * idx_j + 1] = -2 * (yi[idx_i] - yi[idx_j])\n        jac[rows, 3 * idx_i + 2] = -2 * (ri[idx_i] + ri[idx_j])\n        jac[rows, 3 * idx_j + 2] = -2 * (ri[idx_i] + ri[idx_j])\n        \n        # Boundary Jacobian components\n        b_start = num_overlaps\n        for k in range(N):\n            # Partial derivatives for boundary constraints of circle k\n            jac[b_start + 4 * k, 3 * k] = 1\n            jac[b_start + 4 * k, 3 * k + 2] = -1\n            jac[b_start + 4 * k + 1, 3 * k] = -1\n            jac[b_start + 4 * k + 1, 3 * k + 2] = -1\n            jac[b_start + 4 * k + 2, 3 * k + 1] = 1\n            jac[b_start + 4 * k + 2, 3 * k + 2] = -1\n            jac[b_start + 4 * k + 3, 3 * k + 1] = -1\n            jac[b_start + 4 * k + 3, 3 * k + 2] = -1\n            \n        return jac\n\n    best_sum = 0\n    best_x = None\n    \n    # Initialization strategies\n    # Strategy 1: Grid-based packing for 25 circles + 1 extra\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid_5x5 = np.vstack([gx.flatten(), gy.flatten()]).T\n    grid_5x5 = np.vstack([grid_5x5, [0.5, 0.5]]) \n\n    iteration = 0\n    # Run optimization from different seeds until the time limit (300s) is near\n    while time.time() - start_time < 285:\n        if iteration == 0:\n            centers = grid_5x5.copy()\n            radii = np.ones(N) * 0.09\n        elif iteration % 5 == 0:\n            # Perturbed grid seed\n            centers = grid_5x5.copy() + np.random.normal(0, 0.05, (N, 2))\n            radii = np.random.rand(N) * 0.1\n        else:\n            # Completely random seed\n            centers = np.random.rand(N, 2)\n            radii = np.random.rand(N) * 0.1\n        \n        # Flatten initial guess\n        x0 = np.zeros(3 * N)\n        x0[0::3] = np.clip(centers[:, 0], 0.1, 0.9)\n        x0[1::3] = np.clip(centers[:, 1], 0.1, 0.9)\n        x0[2::3] = radii\n        \n        # Optimization using SLSQP with vectorized constraints and Jacobian\n        res = minimize(\n            objective, x0, method='SLSQP', jac=grad_objective,\n            constraints={'type': 'ineq', 'fun': combined_constraints, 'jac': combined_constraints_jac},\n            bounds=[(0, 1)] * (3 * N),\n            options={'ftol': 1e-15, 'maxiter': 600}\n        )\n        \n        # Evaluate performance and check feasibility\n        # SLSQP might return 'success: False' due to precision, so we check function value and constraints manually\n        if -res.fun > best_sum:\n            # Check feasibility with a small tolerance (1e-8)\n            if np.all(combined_constraints(res.x) >= -1e-8):\n                best_sum = -res.fun\n                best_x = res.x\n        \n        iteration += 1\n\n    # Final result extraction\n    if best_x is not None:\n        final_centers = np.column_stack((best_x[0::3], best_x[1::3]))\n        final_radii = best_x[2::3]\n        final_sum = -objective(best_x)\n    else:\n        # Fallback in case no solution found (unlikely)\n        final_centers = np.zeros((N, 2))\n        final_radii = np.zeros(N)\n        final_sum = 0.0\n\n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:44:00.810679",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 286,
        "candidates_token_count": 1984,
        "thoughts_token_count": 17836
      },
      "response_text_len": 5465
    }
  },
  "llm_call_duration_s": 113.32962944102474,
  "eval_duration_s": 286.89126017002854
}