{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": "trial_0_1",
  "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize, differential_evolution\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The approach follows a two-stage optimization:\n    Stage 1: Global optimization (Differential Evolution) on circle centers.\n             For each set of centers, optimal radii are found using Linear Programming.\n    Stage 2: Local refinement (SLSQP) on both centers and radii.\n    \"\"\"\n    num_circles = 26\n    num_vars_centers = 2 * num_circles\n    \n    # Pre-calculate indices for overlap constraints (i < j)\n    idx1, idx2 = np.triu_indices(num_circles, k=1)\n    # LP constraint matrix for r_i + r_j <= d_ij\n    A_overlap = np.zeros((len(idx1), num_circles))\n    A_overlap[np.arange(len(idx1)), idx1] = 1\n    A_overlap[np.arange(len(idx1)), idx2] = 1\n\n    def solve_lp(centers):\n        \"\"\"Solve a Linear Program to find optimal radii for fixed centers.\"\"\"\n        # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n        c = -np.ones(num_circles)\n        \n        # Boundary constraints: r_i <= min(xi, 1-xi, yi, 1-yi)\n        # These become upper bounds on the variables r_i\n        bounds = [(0, max(0.0, min(xi, 1-xi, yi, 1-yi))) for xi, yi in centers]\n        \n        # Overlap constraints: r_i + r_j <= dist_ij\n        # dists is the vector of b_ub for the LP\n        dists = np.sqrt(np.maximum(1e-12, (centers[idx1, 0] - centers[idx2, 0])**2 + \n                                         (centers[idx1, 1] - centers[idx2, 1])**2))\n        \n        # Solve LP using the efficient 'highs' method\n        try:\n            res = linprog(c, A_ub=A_overlap, b_ub=dists, bounds=bounds, method='highs')\n        except (ValueError, ImportError):\n            # Fallback for environments with older scipy versions\n            res = linprog(c, A_ub=A_overlap, b_ub=dists, bounds=bounds)\n        \n        if res.success:\n            return -res.fun, res.x\n        else:\n            # If LP fails (unlikely), return a zero-radius solution\n            return 0.0, np.zeros(num_circles)\n\n    def stage1_objective(centers_flat):\n        \"\"\"Stage 1 objective function: negative sum of radii for given centers.\"\"\"\n        centers = centers_flat.reshape((num_circles, 2))\n        sum_radii, _ = solve_lp(centers)\n        return -sum_radii\n\n    def get_grid_centers():\n        \"\"\"Generates a 5x5 grid of centers plus one extra for the 26th circle.\"\"\"\n        xs = np.linspace(0.1, 0.9, 5)\n        ys = np.linspace(0.1, 0.9, 5)\n        xv, yv = np.meshgrid(xs, ys)\n        centers = np.stack([xv.ravel(), yv.ravel()], axis=1)\n        # Add a 26th circle at a reasonable starting point\n        centers = np.concatenate([centers, [[0.95, 0.95]]])\n        return centers.flatten()\n\n    # --- Stage 1: Global Optimization ---\n    # Parameters for Differential Evolution\n    pop_mult = 5\n    max_iter_de = 15\n    pop_size = pop_mult * num_vars_centers\n    \n    # Initialize population with a grid-based layout and random variations\n    initial_pop = np.random.rand(pop_size, num_vars_centers)\n    grid_centers = get_grid_centers()\n    initial_pop[0] = grid_centers\n    for i in range(1, min(25, pop_size)):\n        initial_pop[i] = np.clip(grid_centers + np.random.normal(0, 0.05, num_vars_centers), 0, 1)\n        \n    res_de = differential_evolution(\n        stage1_objective,\n        [(0, 1)] * num_vars_centers,\n        init=initial_pop,\n        maxiter=max_iter_de,\n        popsize=pop_mult,\n        polish=False,\n        disp=False\n    )\n    \n    # Extract best centers from Stage 1 and solve for their radii\n    best_centers_flat = res_de.x\n    best_centers = best_centers_flat.reshape((num_circles, 2))\n    _, best_radii = solve_lp(best_centers)\n    \n    # --- Stage 2: Local Refinement using SLSQP ---\n    def stage2_objective(v):\n        \"\"\"Maximize sum of radii.\"\"\"\n        return -np.sum(v[52:78])\n\n    def stage2_constraints(v):\n        \"\"\"Ensure circles stay inside square and do not overlap.\"\"\"\n        x = v[0:26]\n        y = v[26:52]\n        r = v[52:78]\n        \n        # Boundary constraints: x_i - r_i >= 0, etc. (104 constraints)\n        c_boundary = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Overlap constraints: dists^2 - (r_i + r_j)^2 >= 0 (325 constraints)\n        idx1_sq, idx2_sq = np.triu_indices(num_circles, k=1)\n        sq_dists = (x[idx1_sq] - x[idx2_sq])**2 + (y[idx1_sq] - y[idx2_sq])**2\n        c_overlap = sq_dists - (r[idx1_sq] + r[idx2_sq])**2\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    # Variables: [x1...x26, y1...y26, r1...r26]\n    initial_vars = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n    bounds_slsqp = [(0, 1)] * 52 + [(0, 0.5)] * 26\n    \n    res_slsqp = minimize(\n        stage2_objective,\n        initial_vars,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': stage2_constraints},\n        bounds=bounds_slsqp,\n        options={'maxiter': 500, 'disp': False}\n    )\n    \n    # Final result extraction\n    final_vars = res_slsqp.x\n    final_centers = np.stack([final_vars[0:26], final_vars[26:52]], axis=1)\n    final_radii = np.maximum(0, final_vars[52:78])\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum",
  "metrics": {
    "valid": true,
    "score": 2.6017990730357092,
    "eval_time": 11.521942377090454,
    "error": null
  },
  "prompt": "Implement a two-stage optimization approach:\n        Stage 1: Use a global optimizer (like Basin-hopping or Differential Evolution) to find good center positions. \n        In each iteration of the global optimizer, the objective function should:\n            a. Take center positions as input.\n            b. Solve a Linear Program (using scipy.optimize.linprog) to find the optimal radii for those fixed centers.\n            c. Return the negative sum of these radii.\n        Stage 2: Perform a local refinement on both centers and radii using SLSQP.\n        This separates the 'where to put them' from the 'how big can they be' logic.\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize, differential_evolution\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The approach follows a two-stage optimization:\n    Stage 1: Global optimization (Differential Evolution) on circle centers.\n             For each set of centers, optimal radii are found using Linear Programming.\n    Stage 2: Local refinement (SLSQP) on both centers and radii.\n    \"\"\"\n    num_circles = 26\n    num_vars_centers = 2 * num_circles\n    \n    # Pre-calculate indices for overlap constraints (i < j)\n    idx1, idx2 = np.triu_indices(num_circles, k=1)\n    # LP constraint matrix for r_i + r_j <= d_ij\n    A_overlap = np.zeros((len(idx1), num_circles))\n    A_overlap[np.arange(len(idx1)), idx1] = 1\n    A_overlap[np.arange(len(idx1)), idx2] = 1\n\n    def solve_lp(centers):\n        \"\"\"Solve a Linear Program to find optimal radii for fixed centers.\"\"\"\n        # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n        c = -np.ones(num_circles)\n        \n        # Boundary constraints: r_i <= min(xi, 1-xi, yi, 1-yi)\n        # These become upper bounds on the variables r_i\n        bounds = [(0, max(0.0, min(xi, 1-xi, yi, 1-yi))) for xi, yi in centers]\n        \n        # Overlap constraints: r_i + r_j <= dist_ij\n        # dists is the vector of b_ub for the LP\n        dists = np.sqrt(np.maximum(1e-12, (centers[idx1, 0] - centers[idx2, 0])**2 + \n                                         (centers[idx1, 1] - centers[idx2, 1])**2))\n        \n        # Solve LP using the efficient 'highs' method\n        try:\n            res = linprog(c, A_ub=A_overlap, b_ub=dists, bounds=bounds, method='highs')\n        except (ValueError, ImportError):\n            # Fallback for environments with older scipy versions\n            res = linprog(c, A_ub=A_overlap, b_ub=dists, bounds=bounds)\n        \n        if res.success:\n            return -res.fun, res.x\n        else:\n            # If LP fails (unlikely), return a zero-radius solution\n            return 0.0, np.zeros(num_circles)\n\n    def stage1_objective(centers_flat):\n        \"\"\"Stage 1 objective function: negative sum of radii for given centers.\"\"\"\n        centers = centers_flat.reshape((num_circles, 2))\n        sum_radii, _ = solve_lp(centers)\n        return -sum_radii\n\n    def get_grid_centers():\n        \"\"\"Generates a 5x5 grid of centers plus one extra for the 26th circle.\"\"\"\n        xs = np.linspace(0.1, 0.9, 5)\n        ys = np.linspace(0.1, 0.9, 5)\n        xv, yv = np.meshgrid(xs, ys)\n        centers = np.stack([xv.ravel(), yv.ravel()], axis=1)\n        # Add a 26th circle at a reasonable starting point\n        centers = np.concatenate([centers, [[0.95, 0.95]]])\n        return centers.flatten()\n\n    # --- Stage 1: Global Optimization ---\n    # Parameters for Differential Evolution\n    pop_mult = 5\n    max_iter_de = 15\n    pop_size = pop_mult * num_vars_centers\n    \n    # Initialize population with a grid-based layout and random variations\n    initial_pop = np.random.rand(pop_size, num_vars_centers)\n    grid_centers = get_grid_centers()\n    initial_pop[0] = grid_centers\n    for i in range(1, min(25, pop_size)):\n        initial_pop[i] = np.clip(grid_centers + np.random.normal(0, 0.05, num_vars_centers), 0, 1)\n        \n    res_de = differential_evolution(\n        stage1_objective,\n        [(0, 1)] * num_vars_centers,\n        init=initial_pop,\n        maxiter=max_iter_de,\n        popsize=pop_mult,\n        polish=False,\n        disp=False\n    )\n    \n    # Extract best centers from Stage 1 and solve for their radii\n    best_centers_flat = res_de.x\n    best_centers = best_centers_flat.reshape((num_circles, 2))\n    _, best_radii = solve_lp(best_centers)\n    \n    # --- Stage 2: Local Refinement using SLSQP ---\n    def stage2_objective(v):\n        \"\"\"Maximize sum of radii.\"\"\"\n        return -np.sum(v[52:78])\n\n    def stage2_constraints(v):\n        \"\"\"Ensure circles stay inside square and do not overlap.\"\"\"\n        x = v[0:26]\n        y = v[26:52]\n        r = v[52:78]\n        \n        # Boundary constraints: x_i - r_i >= 0, etc. (104 constraints)\n        c_boundary = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Overlap constraints: dists^2 - (r_i + r_j)^2 >= 0 (325 constraints)\n        idx1_sq, idx2_sq = np.triu_indices(num_circles, k=1)\n        sq_dists = (x[idx1_sq] - x[idx2_sq])**2 + (y[idx1_sq] - y[idx2_sq])**2\n        c_overlap = sq_dists - (r[idx1_sq] + r[idx2_sq])**2\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    # Variables: [x1...x26, y1...y26, r1...r26]\n    initial_vars = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n    bounds_slsqp = [(0, 1)] * 52 + [(0, 0.5)] * 26\n    \n    res_slsqp = minimize(\n        stage2_objective,\n        initial_vars,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': stage2_constraints},\n        bounds=bounds_slsqp,\n        options={'maxiter': 500, 'disp': False}\n    )\n    \n    # Final result extraction\n    final_vars = res_slsqp.x\n    final_centers = np.stack([final_vars[0:26], final_vars[26:52]], axis=1)\n    final_radii = np.maximum(0, final_vars[52:78])\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:03:46.881220",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 369,
        "candidates_token_count": 1801,
        "thoughts_token_count": 21107
      },
      "response_text_len": 5309
    }
  },
  "llm_call_duration_s": 128.82610910909716,
  "eval_duration_s": 11.521949314977974
}