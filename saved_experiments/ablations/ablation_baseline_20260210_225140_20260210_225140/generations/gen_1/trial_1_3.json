{
  "trial_id": "trial_1_3",
  "generation": 1,
  "parent_id": "trial_0_1",
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution, minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Uses Differential Evolution for global search and SLSQP for local refinement.\n    \"\"\"\n    n = 26\n    \n    # Objective function to maximize sum of radii (minimize negative sum)\n    def objective(v):\n        # v = [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n        return -np.sum(v[2::3])\n    \n    # Penalty-based objective function for Differential Evolution\n    def penalty_obj(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        r_sum_val = np.sum(r)\n        \n        # Boundary constraints: circles must stay inside [0, 1] x [0, 1]\n        # x - r >= 0, 1 - (x + r) >= 0, y - r >= 0, 1 - (y + r) >= 0\n        b_cons = np.concatenate([x - r, 1.0 - (x + r), y - r, 1.0 - (y + r)])\n        b_penalty = np.sum(np.maximum(0, -b_cons)**2)\n        \n        # Non-overlap constraints: dist(c_i, c_j) >= r_i + r_j\n        coords = np.stack([x, y], axis=1)\n        # Efficiently calculate squared distance matrix\n        diff = coords[:, np.newaxis, :] - coords[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        \n        r_sum = r[:, np.newaxis] + r[None, :, :]\n        r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n        r_sum_sq = r_sum**2\n        \n        # We only care about the upper triangle to avoid redundant checks\n        mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n        overlap = np.maximum(0, r_sum_sq[mask] - dist_sq[mask])\n        o_penalty = np.sum(overlap)\n        \n        # Objective combines the sum of radii with a large penalty for constraint violations\n        return -r_sum_val + 1e5 * (b_penalty + o_penalty)\n\n    # Search bounds for each variable: [x, y, r]\n    bounds = []\n    for _ in range(n):\n        bounds.extend([(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)])\n\n    # Heuristic initialization: 5x5 grid of equal circles (radius 0.1)\n    # This provides a strong starting point (Sum of radii = 2.5)\n    grid_size = 5\n    r_init = 1.0 / (2 * grid_size)\n    init_member = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            init_member.extend([(2*i+1)*r_init, (2*j+1)*r_init, r_init])\n    # Add 26th circle at center with radius 0\n    init_member.extend([0.5, 0.5, 0.0])\n    \n    popsize = 12\n    init_pop = np.random.rand(popsize, 3 * n)\n    init_pop[0] = np.array(init_member)\n\n    # Global optimization using Differential Evolution\n    # maxiter and popsize are balanced to fit within the 300s time limit\n    res_de = differential_evolution(\n        penalty_obj, \n        bounds, \n        popsize=popsize, \n        maxiter=180, \n        init=init_pop, \n        mutation=(0.5, 1.0), \n        recombination=0.7,\n        polish=False\n    )\n    \n    # Local optimization using SLSQP to satisfy constraints precisely\n    def slsqp_cons(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        c = []\n        # Boundary constraints\n        for i in range(n):\n            c.extend([x[i] - r[i], 1.0 - (x[i] + r[i]), y[i] - r[i], 1.0 - (y[i] + r[i])])\n        # Non-overlap constraints (squared distance to avoid sqrt derivative issues)\n        for i in range(n):\n            for j in range(i + 1, n):\n                c.append((x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2)\n        return np.array(c)\n        \n    res_final = minimize(\n        objective, \n        res_de.x, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': slsqp_cons},\n        bounds=bounds, \n        options={'maxiter': 500}\n    )\n    \n    # Final configuration extraction\n    v = res_final.x\n    centers = v.reshape(n, 3)[:, :2]\n    radii = v.reshape(n, 3)[:, 2]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.6293232440948486,
    "error": "IndexError: too many indices for array: array is 1-dimensional, but 2 were indexed"
  },
  "prompt": "Use Differential Evolution (scipy.optimize.differential_evolution) to maximize the sum of radii.\n        Differential Evolution is often more robust than Basin-hopping for high-dimensional non-convex problems.\n        1. Variable vector: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26] (length 78).\n        2. Bounds: [0, 1] for all.\n        3. Constraints: Use the 'constraints' parameter in differential_evolution to enforce non-overlap and boundary conditions.\n        4. Use a large population and sufficient iterations.\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution, minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Uses Differential Evolution for global search and SLSQP for local refinement.\n    \"\"\"\n    n = 26\n    \n    # Objective function to maximize sum of radii (minimize negative sum)\n    def objective(v):\n        # v = [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n        return -np.sum(v[2::3])\n    \n    # Penalty-based objective function for Differential Evolution\n    def penalty_obj(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        r_sum_val = np.sum(r)\n        \n        # Boundary constraints: circles must stay inside [0, 1] x [0, 1]\n        # x - r >= 0, 1 - (x + r) >= 0, y - r >= 0, 1 - (y + r) >= 0\n        b_cons = np.concatenate([x - r, 1.0 - (x + r), y - r, 1.0 - (y + r)])\n        b_penalty = np.sum(np.maximum(0, -b_cons)**2)\n        \n        # Non-overlap constraints: dist(c_i, c_j) >= r_i + r_j\n        coords = np.stack([x, y], axis=1)\n        # Efficiently calculate squared distance matrix\n        diff = coords[:, np.newaxis, :] - coords[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        \n        r_sum = r[:, np.newaxis] + r[None, :, :]\n        r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n        r_sum_sq = r_sum**2\n        \n        # We only care about the upper triangle to avoid redundant checks\n        mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n        overlap = np.maximum(0, r_sum_sq[mask] - dist_sq[mask])\n        o_penalty = np.sum(overlap)\n        \n        # Objective combines the sum of radii with a large penalty for constraint violations\n        return -r_sum_val + 1e5 * (b_penalty + o_penalty)\n\n    # Search bounds for each variable: [x, y, r]\n    bounds = []\n    for _ in range(n):\n        bounds.extend([(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)])\n\n    # Heuristic initialization: 5x5 grid of equal circles (radius 0.1)\n    # This provides a strong starting point (Sum of radii = 2.5)\n    grid_size = 5\n    r_init = 1.0 / (2 * grid_size)\n    init_member = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            init_member.extend([(2*i+1)*r_init, (2*j+1)*r_init, r_init])\n    # Add 26th circle at center with radius 0\n    init_member.extend([0.5, 0.5, 0.0])\n    \n    popsize = 12\n    init_pop = np.random.rand(popsize, 3 * n)\n    init_pop[0] = np.array(init_member)\n\n    # Global optimization using Differential Evolution\n    # maxiter and popsize are balanced to fit within the 300s time limit\n    res_de = differential_evolution(\n        penalty_obj, \n        bounds, \n        popsize=popsize, \n        maxiter=180, \n        init=init_pop, \n        mutation=(0.5, 1.0), \n        recombination=0.7,\n        polish=False\n    )\n    \n    # Local optimization using SLSQP to satisfy constraints precisely\n    def slsqp_cons(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        c = []\n        # Boundary constraints\n        for i in range(n):\n            c.extend([x[i] - r[i], 1.0 - (x[i] + r[i]), y[i] - r[i], 1.0 - (y[i] + r[i])])\n        # Non-overlap constraints (squared distance to avoid sqrt derivative issues)\n        for i in range(n):\n            for j in range(i + 1, n):\n                c.append((x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2)\n        return np.array(c)\n        \n    res_final = minimize(\n        objective, \n        res_de.x, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': slsqp_cons},\n        bounds=bounds, \n        options={'maxiter': 500}\n    )\n    \n    # Final configuration extraction\n    v = res_final.x\n    centers = v.reshape(n, 3)[:, :2]\n    radii = v.reshape(n, 3)[:, 2]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:03:29.633824",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 368,
        "candidates_token_count": 1363,
        "thoughts_token_count": 18954
      },
      "response_text_len": 3802
    }
  },
  "llm_call_duration_s": 122.47135521902237,
  "eval_duration_s": 0.6293313499772921
}