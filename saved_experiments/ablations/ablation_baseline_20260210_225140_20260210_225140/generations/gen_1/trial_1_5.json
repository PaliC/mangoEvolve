{
  "trial_id": "trial_1_5",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Penalty Method with L-BFGS-B and a final Linear Programming step to ensure\n    feasibility and maximize the sum of radii for the optimized circle centers.\n    \"\"\"\n    N = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    def get_objective_and_grad_vec(params, lam, N):\n        \"\"\"\n        Calculates the objective function and its gradient for the penalty method.\n        The objective is -sum(radii) + lambda * (boundary and overlap penalties).\n        \"\"\"\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        # Objective: minimize -sum(radii)\n        obj = -np.sum(r)\n        grad = np.zeros(3 * N)\n        grad[2*N:] = -1.0\n        \n        # Boundary constraints: r_i <= x_i, x_i + r_i <= 1, r_i <= y_i, y_i + r_i <= 1\n        # Penalty: max(0, g)^2\n        \n        # r - x <= 0\n        g1 = r - x\n        mask1 = g1 > 0\n        obj += lam * np.sum(g1[mask1]**2)\n        grad[:N] += mask1 * (lam * 2 * g1 * (-1))\n        grad[2*N:] += mask1 * (lam * 2 * g1 * (1))\n        \n        # x + r - 1 <= 0\n        g2 = x + r - 1\n        mask2 = g2 > 0\n        obj += lam * np.sum(g2[mask2]**2)\n        grad[:N] += mask2 * (lam * 2 * g2 * (1))\n        grad[2*N:] += mask2 * (lam * 2 * g2 * (1))\n        \n        # r - y <= 0\n        g3 = r - y\n        mask3 = g3 > 0\n        obj += lam * np.sum(g3[mask3]**2)\n        grad[N:2*N] += mask3 * (lam * 2 * g3 * (-1))\n        grad[2*N:] += mask3 * (lam * 2 * g3 * (1))\n        \n        # y + r - 1 <= 0\n        g4 = y + r - 1\n        mask4 = g4 > 0\n        obj += lam * np.sum(g4[mask4]**2)\n        grad[N:2*N] += mask4 * (lam * 2 * g4 * (1))\n        grad[2*N:] += mask4 * (lam * 2 * g4 * (1))\n        \n        # Overlap constraints: r_i + r_j <= dist_ij\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        dist = np.sqrt(dist_sq + 1e-12)\n        \n        r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n        gap = r_sum - dist\n        # Each pair (i, j) is counted twice (as i,j and j,i)\n        mask_overlap = (gap > 0) & (~np.eye(N, dtype=bool))\n        \n        obj += 0.5 * lam * np.sum(gap[mask_overlap]**2)\n        \n        # Gradient for overlaps\n        common = 2.0 * lam * gap[mask_overlap] / dist[mask_overlap]\n        grad_matrix_x = np.zeros((N, N))\n        grad_matrix_x[mask_overlap] = common * (-dx[mask_overlap])\n        grad[:N] += np.sum(grad_matrix_x, axis=1)\n        \n        grad_matrix_y = np.zeros((N, N))\n        grad_matrix_y[mask_overlap] = common * (-dy[mask_overlap])\n        grad[N:2*N] += np.sum(grad_matrix_y, axis=1)\n        \n        grad_matrix_r = np.zeros((N, N))\n        grad_matrix_r[mask_overlap] = 2.0 * lam * gap[mask_overlap]\n        grad[2*N:] += np.sum(grad_matrix_r, axis=1)\n        \n        return obj, grad\n\n    def solve_lp_for_radii(centers, N):\n        \"\"\"\n        Given circle centers, solves a Linear Program to find the radii that maximize\n        the sum of radii while ensuring all circles are in the unit square and do not overlap.\n        \"\"\"\n        x = centers[:, 0]\n        y = centers[:, 1]\n        c = -np.ones(N)\n        \n        num_overlap = N * (N - 1) // 2\n        A_ub = np.zeros((4 * N + num_overlap, N))\n        b_ub = np.zeros(4 * N + num_overlap)\n        \n        curr_con = 0\n        for i in range(N):\n            # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n            A_ub[curr_con, i] = 1\n            b_ub[curr_con] = x[i]\n            curr_con += 1\n            A_ub[curr_con, i] = 1\n            b_ub[curr_con] = 1 - x[i]\n            curr_con += 1\n            A_ub[curr_con, i] = 1\n            b_ub[curr_con] = y[i]\n            curr_con += 1\n            A_ub[curr_con, i] = 1\n            b_ub[curr_con] = 1 - y[i]\n            curr_con += 1\n            \n        for i in range(N):\n            for j in range(i + 1, N):\n                # r_i + r_j <= d_ij\n                A_ub[curr_con, i] = 1\n                A_ub[curr_con, j] = 1\n                b_ub[curr_con] = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                curr_con += 1\n        \n        # Solve LP\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=(0, 0.5), method='highs')\n        if res.success:\n            return res.x, -res.fun\n        else:\n            # Simple fallback if LP fails\n            r = np.zeros(N)\n            for i in range(N):\n                r[i] = min(max(0, x[i]), max(0, 1-x[i]), max(0, y[i]), max(0, 1-y[i]))\n            for i in range(N):\n                for j in range(i+1, N):\n                    d = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                    if r[i] + r[j] > d:\n                        scale = d / (r[i] + r[j]) if (r[i] + r[j]) > 0 else 0\n                        r[i] *= scale\n                        r[j] *= scale\n            return r, np.sum(r)\n\n    # Optimization strategy: try multiple initializations\n    starts = []\n    # 1. Grid-like initialization\n    grid_size = 5\n    grid_coords = np.linspace(0.1, 0.9, grid_size)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    xx = xx.flatten()\n    yy = yy.flatten()\n    # Add 26th circle and jitter\n    xx = np.append(xx, 0.5)\n    yy = np.append(yy, 0.5)\n    starts.append(np.concatenate([xx, yy, np.ones(N)*0.09]))\n    \n    # 2. Random initializations\n    for _ in range(3):\n        starts.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.ones(N)*0.05]))\n\n    for params in starts:\n        # Gradually increase penalty coefficient (continuation method)\n        for lam in [10, 100, 1000, 10000]:\n            res = minimize(get_objective_and_grad_vec, params, args=(lam, N), \n                           method='L-BFGS-B', jac=True, \n                           bounds=[(0,1)]*(2*N) + [(0,0.5)]*N,\n                           options={'maxiter': 400})\n            params = res.x\n        \n        # Final refinement with LP for the found centers\n        centers = params[:2*N].reshape(2, N).T\n        final_radii, final_sum = solve_lp_for_radii(centers, N)\n        \n        if final_sum > best_sum:\n            best_sum = final_sum\n            best_centers = centers\n            best_radii = final_radii\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.608796051224407,
    "eval_time": 31.350317239761353,
    "error": null
  },
  "prompt": "Implement a Penalty Method (or Barrier Method) for optimization.\n        Instead of hard constraints in SLSQP, use an unconstrained optimizer (like L-BFGS-B) on an objective function that includes:\n        - The negative sum of radii.\n        - A large penalty term for overlaps: sum(max(0, r_i + r_j - dist_ij)^2).\n        - A large penalty term for boundary violations.\n        Gradually increase the penalty weight (continuation method) to 'harden' the constraints.\n        This can help the optimization 'tunnel' through infeasible regions to find better optima.\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Penalty Method with L-BFGS-B and a final Linear Programming step to ensure\n    feasibility and maximize the sum of radii for the optimized circle centers.\n    \"\"\"\n    N = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    def get_objective_and_grad_vec(params, lam, N):\n        \"\"\"\n        Calculates the objective function and its gradient for the penalty method.\n        The objective is -sum(radii) + lambda * (boundary and overlap penalties).\n        \"\"\"\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        # Objective: minimize -sum(radii)\n        obj = -np.sum(r)\n        grad = np.zeros(3 * N)\n        grad[2*N:] = -1.0\n        \n        # Boundary constraints: r_i <= x_i, x_i + r_i <= 1, r_i <= y_i, y_i + r_i <= 1\n        # Penalty: max(0, g)^2\n        \n        # r - x <= 0\n        g1 = r - x\n        mask1 = g1 > 0\n        obj += lam * np.sum(g1[mask1]**2)\n        grad[:N] += mask1 * (lam * 2 * g1 * (-1))\n        grad[2*N:] += mask1 * (lam * 2 * g1 * (1))\n        \n        # x + r - 1 <= 0\n        g2 = x + r - 1\n        mask2 = g2 > 0\n        obj += lam * np.sum(g2[mask2]**2)\n        grad[:N] += mask2 * (lam * 2 * g2 * (1))\n        grad[2*N:] += mask2 * (lam * 2 * g2 * (1))\n        \n        # r - y <= 0\n        g3 = r - y\n        mask3 = g3 > 0\n        obj += lam * np.sum(g3[mask3]**2)\n        grad[N:2*N] += mask3 * (lam * 2 * g3 * (-1))\n        grad[2*N:] += mask3 * (lam * 2 * g3 * (1))\n        \n        # y + r - 1 <= 0\n        g4 = y + r - 1\n        mask4 = g4 > 0\n        obj += lam * np.sum(g4[mask4]**2)\n        grad[N:2*N] += mask4 * (lam * 2 * g4 * (1))\n        grad[2*N:] += mask4 * (lam * 2 * g4 * (1))\n        \n        # Overlap constraints: r_i + r_j <= dist_ij\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        dist = np.sqrt(dist_sq + 1e-12)\n        \n        r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n        gap = r_sum - dist\n        # Each pair (i, j) is counted twice (as i,j and j,i)\n        mask_overlap = (gap > 0) & (~np.eye(N, dtype=bool))\n        \n        obj += 0.5 * lam * np.sum(gap[mask_overlap]**2)\n        \n        # Gradient for overlaps\n        common = 2.0 * lam * gap[mask_overlap] / dist[mask_overlap]\n        grad_matrix_x = np.zeros((N, N))\n        grad_matrix_x[mask_overlap] = common * (-dx[mask_overlap])\n        grad[:N] += np.sum(grad_matrix_x, axis=1)\n        \n        grad_matrix_y = np.zeros((N, N))\n        grad_matrix_y[mask_overlap] = common * (-dy[mask_overlap])\n        grad[N:2*N] += np.sum(grad_matrix_y, axis=1)\n        \n        grad_matrix_r = np.zeros((N, N))\n        grad_matrix_r[mask_overlap] = 2.0 * lam * gap[mask_overlap]\n        grad[2*N:] += np.sum(grad_matrix_r, axis=1)\n        \n        return obj, grad\n\n    def solve_lp_for_radii(centers, N):\n        \"\"\"\n        Given circle centers, solves a Linear Program to find the radii that maximize\n        the sum of radii while ensuring all circles are in the unit square and do not overlap.\n        \"\"\"\n        x = centers[:, 0]\n        y = centers[:, 1]\n        c = -np.ones(N)\n        \n        num_overlap = N * (N - 1) // 2\n        A_ub = np.zeros((4 * N + num_overlap, N))\n        b_ub = np.zeros(4 * N + num_overlap)\n        \n        curr_con = 0\n        for i in range(N):\n            # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n            A_ub[curr_con, i] = 1\n            b_ub[curr_con] = x[i]\n            curr_con += 1\n            A_ub[curr_con, i] = 1\n            b_ub[curr_con] = 1 - x[i]\n            curr_con += 1\n            A_ub[curr_con, i] = 1\n            b_ub[curr_con] = y[i]\n            curr_con += 1\n            A_ub[curr_con, i] = 1\n            b_ub[curr_con] = 1 - y[i]\n            curr_con += 1\n            \n        for i in range(N):\n            for j in range(i + 1, N):\n                # r_i + r_j <= d_ij\n                A_ub[curr_con, i] = 1\n                A_ub[curr_con, j] = 1\n                b_ub[curr_con] = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                curr_con += 1\n        \n        # Solve LP\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=(0, 0.5), method='highs')\n        if res.success:\n            return res.x, -res.fun\n        else:\n            # Simple fallback if LP fails\n            r = np.zeros(N)\n            for i in range(N):\n                r[i] = min(max(0, x[i]), max(0, 1-x[i]), max(0, y[i]), max(0, 1-y[i]))\n            for i in range(N):\n                for j in range(i+1, N):\n                    d = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                    if r[i] + r[j] > d:\n                        scale = d / (r[i] + r[j]) if (r[i] + r[j]) > 0 else 0\n                        r[i] *= scale\n                        r[j] *= scale\n            return r, np.sum(r)\n\n    # Optimization strategy: try multiple initializations\n    starts = []\n    # 1. Grid-like initialization\n    grid_size = 5\n    grid_coords = np.linspace(0.1, 0.9, grid_size)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    xx = xx.flatten()\n    yy = yy.flatten()\n    # Add 26th circle and jitter\n    xx = np.append(xx, 0.5)\n    yy = np.append(yy, 0.5)\n    starts.append(np.concatenate([xx, yy, np.ones(N)*0.09]))\n    \n    # 2. Random initializations\n    for _ in range(3):\n        starts.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.ones(N)*0.05]))\n\n    for params in starts:\n        # Gradually increase penalty coefficient (continuation method)\n        for lam in [10, 100, 1000, 10000]:\n            res = minimize(get_objective_and_grad_vec, params, args=(lam, N), \n                           method='L-BFGS-B', jac=True, \n                           bounds=[(0,1)]*(2*N) + [(0,0.5)]*N,\n                           options={'maxiter': 400})\n            params = res.x\n        \n        # Final refinement with LP for the found centers\n        centers = params[:2*N].reshape(2, N).T\n        final_radii, final_sum = solve_lp_for_radii(centers, N)\n        \n        if final_sum > best_sum:\n            best_sum = final_sum\n            best_centers = centers\n            best_radii = final_radii\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:04:24.139462",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 363,
        "candidates_token_count": 2350,
        "thoughts_token_count": 22857
      },
      "response_text_len": 6411
    }
  },
  "llm_call_duration_s": 146.25607713498175,
  "eval_duration_s": 31.350325740058906
}