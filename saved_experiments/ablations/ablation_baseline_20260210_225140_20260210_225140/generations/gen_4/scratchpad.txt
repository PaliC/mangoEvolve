============================================================
SCRATCHPAD FOR GENERATION 4
============================================================


## Generation 0 Summary
- Best Score: 2.615866860608053 (trial_0_1) using Basin-hopping + SLSQP.
- trial_0_4 (2.5457) used a two-stage approach (equal radii then relaxation).
- Common failure: SLSQP constraint formatting and objective return types.
- Insight: For fixed centers, the optimal radii can be found via Linear Programming (LP).

## Strategy for Generation 1
- **Refinement**: Improve the best-performing basin-hopping approach (trial_0_1).
- **LP Integration**: Use LP to optimize radii for fixed centers, either as a final step or within the optimization loop.
- **Diversity**: Explore Differential Evolution and Penalty-based optimization to avoid local minima.
- **Initialization**: Use the best result from Gen 0 as a seed for further optimization.

## Generation 1 Insights
- Significant improvement: Best score jumped from 2.615 to 2.633 (trial_1_2).
- trial_1_2 used a "Growth and Repulsion" strategy followed by SLSQP. This suggests that a good physical-inspired initialization is superior to pure random or grid starts.
- trial_1_4 (score 2.624) used multiple grid initializations with SLSQP refinement.
- trial_1_3 (Differential Evolution) failed, likely due to the high dimensionality (78 variables) and complex constraints making the search space too difficult for DE without a better constraint handling mechanism.
- Bilevel optimization (LP for radii) in trial_1_1 was stable but didn't reach the top scores yet, possibly needing more iterations on the center positions.

## Strategy for Generation 2
- Combine the "Growth/Repulsion" initialization from trial_1_2 with the LP-based radii optimization.
- Explore "Basin-hopping" where the local minimization step is a full SLSQP run starting from a "Growth" phase.
- Investigate why trial_1_2 succeeded: was it the specific repulsion parameters or the simultaneous (x,y,r) optimization?

## Technical Deep Dive (Gen 1)
- **Jacobian Formulation**: trial_1_2 used squared distance constraints (xi-xj)^2 + (yi-yj)^2 >= (ri+rj)^2. This is more stable than sqrt(...) >= ri+rj.
- **Vectorization**: trial_1_2's use of np.triu_indices for Jacobian calculation significantly increased the number of optimization runs possible within the 300s limit.
- **Polishing**: trial_1_2's post-processing loop ensures that for fixed centers, radii are maximized to the point of contact. This is essentially a manual coordinate-descent version of the LP approach.
- **Multi-start vs Basin-hopping**: trial_1_2's random multi-start explored more basins than trial_1_0's basin-hopping, likely because the basin-hopping 'jumps' weren't as effective at finding new high-quality regions as fresh random starts.

## Plan for Gen 2
1. **Hybrid Strategy**: Use trial_1_2's vectorized SLSQP and squared-distance formulation but replace random starts with a mix of "Growth/Repulsion" starts and perturbed versions of the best known configuration.
2. **LP Radii**: Integrate a formal LP solver (scipy.optimize.linprog) for the final polishing step, as it is mathematically guaranteed to find the optimal radii for fixed centers.
3. **Adaptive Time Management**: Use the 300s budget more effectively - spend 200s on broad multi-start and 100s on intense refinement of the top 3 candidates.

## Generation 2 Analysis
- Best Trial: trial_1_2 (Score: 2.6330352288703494)
- Key Success Factor in 1_2: Vectorized Jacobian for SLSQP and a custom 'repulsion' initialization.
- Observation: The gap to the best known (2.6359) is very small. We need high-precision refinement.
- Strategy: Implement LP-based radii optimization for fixed centers to guarantee optimality of radii for any given center configuration.

## Generation 2 Insights
- HUGE SUCCESS: trial_2_4 achieved 2.635983, which is extremely close to the best known solution (2.635985).
- The 'shaking' strategy (local perturbations + SLSQP refinement) is clearly the winning metaheuristic.
- trial_2_0 and trial_2_5 also performed well (>2.63), confirming that high-quality initializations (perturbed bests or geometric patterns) are key.
- Failures in 2_1 and 2_3 were likely due to implementation errors in the MD simulation or the basin-hopping wrapper (check errors).
- Next Step: Focus on extreme refinement of trial_2_4. Try even smaller 'shaking' magnitudes and more iterations. Consider if the LP polishing from trial_2_0 can be integrated into the trial_2_4 loop.

## Generation 2 Recap
- trial_2_4 is the current state-of-the-art (2.635983).
- The strategy of 'shaking' (local perturbations) followed by SLSQP is extremely effective.
- The next frontier is high-precision refinement and potentially integrating Linear Programming (LP) for radii optimality within the loop.

## Strategy for Generation 3
1. **Precision Refinement**: Use trial_2_4 as the base. Decrease solver tolerances (ftol=1e-12) and increase max iterations.
2. **LP Integration**: Incorporate `scipy.optimize.linprog` to find the globally optimal radii for any set of centers produced by the shaking/SLSQP process.
3. **Adaptive Shaking**: Implement a cooling schedule or an adaptive step-size (like the 1/5th rule in Evolution Strategies) for the perturbations.
4. **Targeted Perturbations**: Identify 'loose' circles (those with fewer than 3 contacts) and perturb them more than 'locked' circles.
5. **Basin Hopping**: Use a formal Basin Hopping algorithm with the vectorized Jacobian from trial_2_4.

## Generation 3 Insights
- trial_3_4 matched the best score of trial_2_4 (2.635983). It seems we are hitting a precision limit or a very stable local optimum.
- trial_3_5 (Sequential Linear Programming) showed decent performance (2.634) and represents a different optimization flavor that might be worth hybridizing.
- trial_3_0 and trial_3_3 failed to improve, likely due to implementation complexities in the LP integration or the 'targeted' logic disrupting the SLSQP convergence.
- The 'shaking' magnitude and the number of iterations in the final refinement stage are the most sensitive parameters.
- Next: We need to focus on 'Micro-shaking'. If we are at 2.635983 and the goal is 2.635985, the perturbations should be in the range of 1e-6 to 1e-8.

## Generation 3 Recap
- Best score remains 2.635983 (trial_3_4, trial_2_4).
- We are in the final refinement stage (gap to best known is ~2e-6).
- The "shaking + SLSQP" method is robust but might need more precision or better radii handling.
- Strategy for Gen 4: Focus on micro-refinement, LP-based radii maximization, and adaptive perturbation.

## Gen 4 Analysis
The gap of **2e-6** between your results (~2.635983) and the best-known solution (2.635985) for $N=26$ is characteristic of two specific issues in circle packing optimization: **SLSQP convergence limits** and **basin trapping**.

### 1. Numerical Precision Issues
In both trials, the SLSQP optimizer is likely terminating early because the default tolerance (`ftol`) is usually $1e-6$ or $1e-7$. When the objective function is a sum of 26 variables, a change of $1e-8$ in each radius is "invisible" to the optimizer, yet it accounts for $2.6e-7$ of your total sum.

*   **The Fix:** You must explicitly set `tol` and `ftol` to much smaller values (e.g., $1e-12$).
*   **The Constraint Tolerance:** Your code uses `np.all(constraints_func(res.x) >= -1e-8)`. This is a "hard" rejection. If SLSQP finds a solution with a sum of 2.635986 but a violation of $1.1e-8$, it is discarded. It is better to allow slight violations during the search and "pull" them back in a final high-precision polish.

### 2. Shaking Strategy Modification
The current shaking strategy (randomly re-placing 1â€“3 circles) is a "Large Neighborhood Search." This is excellent for finding the general "basin" of a good packing. However, the final 2e-6 gap is often a "local geometry" problem where the circles are in the right relative positions but need to "settle" into a tighter configuration.

*   **The Fix:** Introduce **Gaussian Jitter**. Instead of just moving a circle to a completely new random spot, apply a tiny move ($1e-3$ or $1e-4$) to *all* centers. This helps the optimizer "hop" over small ridges in the constraint surface that SLSQP's gradient descent gets stuck on.

### 3. Recommended Hybrid Approach
The following code optimizes Trial 3_4 by:
1.  Tightening SLSQP tolerances to $1e-12$.
2.  Implementing a dual-mode shake: "Big Jumps" (to find new basins) and "Micro Jitters" (to refine the current basin).
3.  Using the LP-based radii optimizer more aggressively to ensure radii are always perfectly maximized for given centers.

```python
import numpy as np
from scipy.optimize import minimize, linprog
import time

def run_packing():
    N = 26
    start_time = time.time()
    
    # Pre-calculate for LP
    num_overlap = N * (N - 1) // 2
    A_ub = np.zeros((num_overlap, N))
    row = 0
    for i in range(N):
        for j in range(i + 1, N):
            A_ub[row, i] = 1
            A_ub[row, j] = 1
            row += 1

    def get_best_radii(centers):
        """Optimizes radii for fixed centers using Highs LP solver."""
        c = -np.ones(N)
        r_bounds = []
        for i in range(N):
            # Distance to boundaries
            d = min(centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1])
            r_bounds.append((0, max(0.0, d)))
        
        dx = centers[:, 0][:, np.newaxis] - centers[:, 0][np.newaxis, :]
        dy = centers[:, 1][:, np.newaxis] - centers[:, 1][np.newaxis, :]
        dist_matrix = np.sqrt(dx**2 + dy**2 + np.eye(N)) # Add eye to avoid 0 on diag
        b_ub = dist_matrix[np.triu_indices(N, k=1)]
        
        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=r_bounds, method='highs')
        if res.success:
            return res.x, -res.fun
        return None, 0.0

    def objective(params):
        return -np.sum(params[2*N:])

    def constraints_func(params):
        x, y, r = params[:N], params[N:2*N], params[2*N:]
        c_boundary = np.concatenate([x-r, 1-x-r, y-r, 1-y-r])
        dx = x[:, None] - x[None, :]
        dy = y[:, None] - y[None, :]
        dist_sq = dx**2 + dy**2
        dr_sq = (r[:, None] + r[None, :])**2
        c_overlap = (dist_sq - dr_sq)[np.triu_indices(N, k=1)]
        return np.concatenate([c_boundary, c_overlap])

    # Tightened SLSQP Polish
    def polish(params, maxiter=100):
        res = minimize(
            objective, params, method='SLSQP',
            constraints={'type': 'ineq', 'fun': constraints_func},
            bounds=[(0, 1)]*(2*N) + [(0, 0.5)]*N,
            options={'maxiter': maxiter, 'ftol': 1e-12}
        )
        return res

    # 1. Initial Seed (5x5 grid + 1)
    x_grid, y_grid = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))
    x_init = np.append(x_grid.flatten(), [0.5])
    y_init = np.append(y_grid.flatten(), [0.5])
    r_init = np.full(N, 0.05)
    best_params = np.concatenate([x_init, y_init, r_init])
    
    res = polish(best_params, 200)
    if res.success: best_params = res.x
    best_sum = -objective(best_params)

    # 2. Shaking Loop
    while time.time() - start_time < 275:
        current_params = best_params.copy()
        
        # Decide shake type: 80% Micro-jitter (refine), 20% Big Jump (explore)
        if np.random.random() < 0.8:
            # Micro-jitter: Nudge centers slightly
            current_params[:2*N] += np.random.normal(0, 0.002, 2*N)
        else:
            # Big Jump: Move 2 circles entirely
            idx = np.random.choice(N, 2, replace=False)
            current_params[idx] = np.random.uniform(0.1, 0.9, 2)
            current_params[idx+N] = np.random.uniform(0.1, 0.9, 2)

        # Quick settle
        res = minimize(objective, current_params, method='SLSQP',
                       constraints={'type': 'ineq', 'fun': constraints_func},
                       bounds=[(0,1)]*(2*N) + [(0,0.5)]*N,
                       options={'maxiter': 50, 'ftol': 1e-9})
        
        if res.success and -res.fun > best_sum - 1e-5: # Accept slightly worse to explore
            # High-precision check/refinement
            centers = res.x[:2*N].reshape(2, N).T
            new_radii, new_total = get_best_radii(centers)
            
            if new_total > best_sum + 1e-11:
                # Polish the new find
                polished_params = np.concatenate([centers.T.flatten(), new_radii])
                res_p = polish(polished_params, 100)
                if res_p.success and -res_p.fun > best_sum:
                    best_sum = -res_p.fun
                    best_params = res_p.x

    # Final Polish with extreme precision
    res = minimize(objective, best_params, method='SLSQP',
                   constraints={'type': 'ineq', 'fun': constraints_func},
                   bounds=[(0,1)]*(2*N) + [(0,0.5)]*N,
                   options={'maxiter': 500, 'ftol': 1e-14})
    
    final_params = res.x if res.success else best_params
    return final_params[:2*N].reshape(2, N).T, final_params[2*N:], -objective(final_params)
```

### Key Changes to Bridge the 2e-6 Gap:
1.  **`ftol: 1e-14`**: This forces the optimizer to keep moving even when the gains are infinitesimal.
2.  **`get_best_radii` (LP)**: This is used as a "correction" step. SLSQP often struggles to balance 26 radii simultaneously; the LP solver (`highs`) finds the mathematically optimal radii for any given center configuration instantly.
3.  **Gaussian Jitter (Micro-shakes)**: By adding `np.random.normal(0, 0.002)`, you allow the circles to "vibrate" out of local sub-optimal traps.
4.  **Soft Acceptance**: The line `if -res.fun > best_sum - 1e-5` allows the search to explore configurations that are nearly as good as the best, which often lead to better refinements after the LP/Polish step.
## Generation 4 Strategy
- Objective: Close the 2e-6 gap to 2.635985.
- Core Technique: High-precision refinement of trial_3_4 using Micro-jitter and LP-based radii optimization.
- Diversity: Explore adaptive step-sizes (1/5th rule) and different initialization seeds.

## Generation 4 Analysis (Corrected)
- Regressed in score: Best Gen 4 was 2.627 vs Gen 3's 2.63598.
- Analysis suggests that the LP integration might be too slow or the constraints in the LP formulation (like boundary conditions) might not perfectly match the SLSQP objective, leading to sub-optimal radii for the given centers.
- The 'highs' method in linprog is robust but might be overkill for 26 variables; perhaps a custom coordinate descent for radii is faster and allows more SLSQP iterations.
- Strategy for Gen 5: Focus on the 'shaking' logic of trial_3_4. Use much smaller perturbations and ensure the SLSQP solver has maximum time to converge.
