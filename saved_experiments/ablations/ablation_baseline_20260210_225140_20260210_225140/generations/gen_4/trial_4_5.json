{
  "trial_id": "trial_4_5",
  "generation": 4,
  "parent_id": "trial_1_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybridization of growth/repulsion initialization, MD-style relaxation, \n    and high-precision SLSQP and LP radii optimization.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for vectorized operations\n    i_tri, j_tri = np.triu_indices(n, 1)\n    num_overlap = len(i_tri)\n\n    def objective(params):\n        \"\"\"Negative sum of radii (to minimize).\"\"\"\n        return -np.sum(params[2*n:])\n\n    def grad_objective(params):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0\n        return grad\n\n    def constraints(params):\n        \"\"\"All inequality constraints (cons >= 0).\"\"\"\n        x, y, r = params[:n], params[n:2*n], params[2*n:]\n        \n        # Boundary constraints (4*n)\n        b_cons = np.zeros(4*n)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1.0 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1.0 - y - r\n        \n        # Overlap constraints (n*(n-1)/2)\n        o_cons = (x[i_tri] - x[j_tri])**2 + (y[i_tri] - y[j_tri])**2 - (r[i_tri] + r[j_tri])**2\n        \n        return np.concatenate([b_cons, o_cons])\n\n    def jac_constraints(params):\n        \"\"\"Jacobian matrix of the constraints.\"\"\"\n        x, y, r = params[:n], params[n:2*n], params[2*n:]\n        jac = np.zeros((4*n + num_overlap, 3*n))\n        \n        # Boundary constraints Jacobian\n        for k in range(n):\n            jac[4*k, k], jac[4*k, 2*n+k] = 1.0, -1.0\n            jac[4*k+1, k], jac[4*k+1, 2*n+k] = -1.0, -1.0\n            jac[4*k+2, n+k], jac[4*k+2, 2*n+k] = 1.0, -1.0\n            jac[4*k+3, n+k], jac[4*k+3, 2*n+k] = -1.0, -1.0\n            \n        # Overlap constraints Jacobian\n        dx, dy, dr = x[i_tri] - x[j_tri], y[i_tri] - y[j_tri], r[i_tri] + r[j_tri]\n        rows = np.arange(4*n, 4*n + num_overlap)\n        jac[rows, i_tri] = 2 * dx\n        jac[rows, j_tri] = -2 * dx\n        jac[rows, n+i_tri] = 2 * dy\n        jac[rows, n+j_tri] = -2 * dy\n        jac[rows, 2*n+i_tri] = -2 * dr\n        jac[rows, 2*n+j_tri] = -2 * dr\n        \n        return jac\n\n    def polish_radii(centers, n):\n        \"\"\"Linear programming to find optimal radii for fixed centers.\"\"\"\n        c = -np.ones(n)\n        A = np.zeros((n * (n - 1) // 2, n))\n        b = np.zeros(n * (n - 1) // 2)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A[k, i], A[k, j] = 1, 1\n                b[k] = np.linalg.norm(centers[i] - centers[j])\n                k += 1\n        bounds = [(0, min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])) for i in range(n)]\n        try:\n            res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n        except:\n            res = linprog(c, A_ub=A, b_ub=b, bounds=bounds)\n        return res.x if res.success else None\n\n    def get_relaxed_centers(centers, n, iterations=400):\n        \"\"\"Molecular Dynamics style relaxation with growth.\"\"\"\n        r_val = 0.06\n        for _ in range(iterations):\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.linalg.norm(diffs, axis=-1)\n            np.fill_diagonal(dists, 1.0)\n            overlap = (2 * r_val) - dists\n            overlap[overlap < 0] = 0\n            forces = np.sum(diffs * (overlap / (dists + 1e-9))[:, :, np.newaxis], axis=1)\n            centers += 0.15 * forces\n            centers = np.clip(centers, r_val, 1 - r_val)\n            r_val += 0.0001\n            if r_val > 0.10: r_val = 0.10\n        return centers, r_val\n\n    # Multi-start optimization\n    best_sum = 0\n    best_params = None\n    trial_count = 0\n\n    while time.time() - start_time < 260:\n        if trial_count == 0:\n            # Seed 1: 5x5 Grid plus one\n            grid_coords = np.linspace(0.1, 0.9, 5)\n            xs, ys = np.meshgrid(grid_coords, grid_coords)\n            c_init = np.vstack([xs.flatten(), ys.flatten()]).T\n            c_init = np.vstack([c_init, np.random.rand(2)])\n        else:\n            c_init = np.random.rand(n, 2)\n        \n        c_relaxed, r_relaxed = get_relaxed_centers(c_init, n)\n        params_init = np.concatenate([c_relaxed[:, 0], c_relaxed[:, 1], np.full(n, r_relaxed)])\n        \n        res = minimize(objective, params_init, method='SLSQP', jac=grad_objective,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       options={'maxiter': 250})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n        \n        trial_count += 1\n\n    # Final polish on the best result\n    if best_params is not None:\n        res = minimize(objective, best_params, method='SLSQP', jac=grad_objective,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       options={'maxiter': 800, 'ftol': 1e-12})\n        best_params = res.x\n        \n        # LP polish for radii\n        x, y, r = best_params[:n], best_params[n:2*n], best_params[2*n:]\n        centers = np.vstack([x, y]).T\n        r_polished = polish_radii(centers, n)\n        if r_polished is not None:\n            r = r_polished\n        \n        # Final strict feasibility enforcement\n        for i in range(n):\n            r[i] = min(r[i], x[i], 1 - x[i], y[i], 1 - y[i])\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                if r[i] + r[j] > dist:\n                    diff = (r[i] + r[j] - dist)\n                    r[i] -= diff / 2.0 + 1e-15\n                    r[j] -= diff / 2.0 + 1e-15\n        \n        r = np.maximum(r, 0)\n        best_sum = np.sum(r)\n        return centers, r, best_sum\n\n    return None, None, 0",
  "metrics": {
    "valid": true,
    "score": 0.7405174856621758,
    "eval_time": 270.0663137435913,
    "error": null
  },
  "prompt": "Hybridize the \"Growth/Repulsion\" and \"SLSQP\" strategies.\n1. Use the repulsion-based initialization from trial_1_2 but seed it with the centers from trial_2_4.\n2. Run a short \"Molecular Dynamics\" style relaxation where circles have a tiny attraction to each other (to keep the packing tight) but strong repulsion.\n3. Finish with the high-precision SLSQP and LP radii optimization.\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses SLSQP with a multi-start strategy and vectorized Jacobian for efficiency.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for vectorized operations\n    i_tri, j_tri = np.triu_indices(n, 1)\n    num_overlap = len(i_tri)\n\n    def objective(params):\n        \"\"\"Negative sum of radii (to minimize).\"\"\"\n        return -np.sum(params[2*n:])\n\n    def grad_objective(params):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0\n        return grad\n\n    def constraints(params):\n        \"\"\"All inequality constraints (cons >= 0).\"\"\"\n        x = params[:n]\n        y = params[n:2*n]\n        r = params[2*n:]\n        \n        # Boundary constraints (4*n)\n        b_cons = np.zeros(4*n)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1.0 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1.0 - y - r\n        \n        # Overlap constraints (n*(n-1)/2)\n        o_cons = (x[i_tri] - x[j_tri])**2 + (y[i_tri] - y[j_tri])**2 - (r[i_tri] + r[j_tri])**2\n        \n        return np.concatenate([b_cons, o_cons])\n\n    def jac_constraints(params):\n        \"\"\"Jacobian matrix of the constraints.\"\"\"\n        x = params[:n]\n        y = params[n:2*n]\n        r = params[2*n:]\n        \n        jac = np.zeros((4*n + num_overlap, 3*n))\n        \n        # Boundary constraints Jacobian\n        for k in range(n):\n            jac[4*k, k] = 1.0\n            jac[4*k, 2*n+k] = -1.0\n            jac[4*k+1, k] = -1.0\n            jac[4*k+1, 2*n+k] = -1.0\n            jac[4*k+2, n+k] = 1.0\n            jac[4*k+2, 2*n+k] = -1.0\n            jac[4*k+3, n+k] = -1.0\n            jac[4*k+3, 2*n+k] = -1.0\n            \n        # Overlap constraints Jacobian\n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        dr = r[i_tri] + r[j_tri]\n        \n        row_indices = np.arange(4*n, 4*n + num_overlap)\n        jac[row_indices, i_tri] = 2 * dx\n        jac[row_indices, j_tri] = -2 * dx\n        jac[row_indices, n+i_tri] = 2 * dy\n        jac[row_indices, n+j_tri] = -2 * dy\n        jac[row_indices, 2*n+i_tri] = -2 * dr\n        jac[row_indices, 2*n+j_tri] = -2 * dr\n        \n        return jac\n\n    # Optimization setup\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    cons = {'type': 'ineq', 'fun': constraints, 'jac': jac_constraints}\n    \n    best_sum = 0\n    best_params = None\n\n    # Trial 1: 5x5 Grid initialization with slight jitter\n    x_grid, y_grid = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    x_init = np.append(x_grid.flatten(), 0.5)\n    y_init = np.append(y_grid.flatten(), 0.5)\n    r_init = np.full(n, 0.09)\n    initial_params = np.concatenate([x_init, y_init, r_init])\n    \n    res = minimize(objective, initial_params, method='SLSQP', bounds=bounds, \n                   constraints=cons, jac=grad_objective, options={'maxiter': 500})\n    if -res.fun > best_sum:\n        best_sum = -res.fun\n        best_params = res.x\n\n    # Random trials to escape local minima\n    while time.time() - start_time < 260:\n        x_init = np.random.uniform(0.1, 0.9, n)\n        y_init = np.random.uniform(0.1, 0.9, n)\n        r_init = np.full(n, 0.05)\n        initial_params = np.concatenate([x_init, y_init, r_init])\n        \n        res = minimize(objective, initial_params, method='SLSQP', bounds=bounds, \n                       constraints=cons, jac=grad_objective, options={'maxiter': 300})\n        \n        if -res.fun > best_sum:\n            # Simple check for feasibility before accepting\n            if np.all(constraints(res.x) >= -1e-5):\n                best_sum = -res.fun\n                best_params = res.x\n\n    # Final polish step on the best result found\n    if best_params is not None:\n        res = minimize(objective, best_params, method='SLSQP', bounds=bounds, \n                       constraints=cons, jac=grad_objective, options={'maxiter': 1000, 'ftol': 1e-12})\n        best_params = res.x\n        best_sum = -res.fun\n\n    # Extract results and ensure strict feasibility\n    x = best_params[:n]\n    y = best_params[n:2*n]\n    r = best_params[2*n:]\n    \n    # Boundary adjustment\n    for i in range(n):\n        r[i] = min(r[i], x[i], 1 - x[i], y[i], 1 - y[i])\n        r[i] = max(r[i], 0)\n        \n    # Iterative overlap adjustment to push circles apart\n    for _ in range(20):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                if dist < (r[i] + r[j]):\n                    overlap = (r[i] + r[j]) - dist\n                    # Shrink radii slightly more than the overlap to ensure buffer\n                    r[i] -= overlap / 2 + 1e-13\n                    r[j] -= overlap / 2 + 1e-13\n                    r[i] = max(r[i], 0)\n                    r[j] = max(r[j], 0)\n\n    centers = np.vstack([x, y]).T\n    sum_radii = np.sum(r)\n    \n    return centers, r, sum_radii\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybridization of growth/repulsion initialization, MD-style relaxation, \n    and high-precision SLSQP and LP radii optimization.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for vectorized operations\n    i_tri, j_tri = np.triu_indices(n, 1)\n    num_overlap = len(i_tri)\n\n    def objective(params):\n        \"\"\"Negative sum of radii (to minimize).\"\"\"\n        return -np.sum(params[2*n:])\n\n    def grad_objective(params):\n        \"\"\"Gradient of the objective function.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0\n        return grad\n\n    def constraints(params):\n        \"\"\"All inequality constraints (cons >= 0).\"\"\"\n        x, y, r = params[:n], params[n:2*n], params[2*n:]\n        \n        # Boundary constraints (4*n)\n        b_cons = np.zeros(4*n)\n        b_cons[0::4] = x - r\n        b_cons[1::4] = 1.0 - x - r\n        b_cons[2::4] = y - r\n        b_cons[3::4] = 1.0 - y - r\n        \n        # Overlap constraints (n*(n-1)/2)\n        o_cons = (x[i_tri] - x[j_tri])**2 + (y[i_tri] - y[j_tri])**2 - (r[i_tri] + r[j_tri])**2\n        \n        return np.concatenate([b_cons, o_cons])\n\n    def jac_constraints(params):\n        \"\"\"Jacobian matrix of the constraints.\"\"\"\n        x, y, r = params[:n], params[n:2*n], params[2*n:]\n        jac = np.zeros((4*n + num_overlap, 3*n))\n        \n        # Boundary constraints Jacobian\n        for k in range(n):\n            jac[4*k, k], jac[4*k, 2*n+k] = 1.0, -1.0\n            jac[4*k+1, k], jac[4*k+1, 2*n+k] = -1.0, -1.0\n            jac[4*k+2, n+k], jac[4*k+2, 2*n+k] = 1.0, -1.0\n            jac[4*k+3, n+k], jac[4*k+3, 2*n+k] = -1.0, -1.0\n            \n        # Overlap constraints Jacobian\n        dx, dy, dr = x[i_tri] - x[j_tri], y[i_tri] - y[j_tri], r[i_tri] + r[j_tri]\n        rows = np.arange(4*n, 4*n + num_overlap)\n        jac[rows, i_tri] = 2 * dx\n        jac[rows, j_tri] = -2 * dx\n        jac[rows, n+i_tri] = 2 * dy\n        jac[rows, n+j_tri] = -2 * dy\n        jac[rows, 2*n+i_tri] = -2 * dr\n        jac[rows, 2*n+j_tri] = -2 * dr\n        \n        return jac\n\n    def polish_radii(centers, n):\n        \"\"\"Linear programming to find optimal radii for fixed centers.\"\"\"\n        c = -np.ones(n)\n        A = np.zeros((n * (n - 1) // 2, n))\n        b = np.zeros(n * (n - 1) // 2)\n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A[k, i], A[k, j] = 1, 1\n                b[k] = np.linalg.norm(centers[i] - centers[j])\n                k += 1\n        bounds = [(0, min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])) for i in range(n)]\n        try:\n            res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n        except:\n            res = linprog(c, A_ub=A, b_ub=b, bounds=bounds)\n        return res.x if res.success else None\n\n    def get_relaxed_centers(centers, n, iterations=400):\n        \"\"\"Molecular Dynamics style relaxation with growth.\"\"\"\n        r_val = 0.06\n        for _ in range(iterations):\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.linalg.norm(diffs, axis=-1)\n            np.fill_diagonal(dists, 1.0)\n            overlap = (2 * r_val) - dists\n            overlap[overlap < 0] = 0\n            forces = np.sum(diffs * (overlap / (dists + 1e-9))[:, :, np.newaxis], axis=1)\n            centers += 0.15 * forces\n            centers = np.clip(centers, r_val, 1 - r_val)\n            r_val += 0.0001\n            if r_val > 0.10: r_val = 0.10\n        return centers, r_val\n\n    # Multi-start optimization\n    best_sum = 0\n    best_params = None\n    trial_count = 0\n\n    while time.time() - start_time < 260:\n        if trial_count == 0:\n            # Seed 1: 5x5 Grid plus one\n            grid_coords = np.linspace(0.1, 0.9, 5)\n            xs, ys = np.meshgrid(grid_coords, grid_coords)\n            c_init = np.vstack([xs.flatten(), ys.flatten()]).T\n            c_init = np.vstack([c_init, np.random.rand(2)])\n        else:\n            c_init = np.random.rand(n, 2)\n        \n        c_relaxed, r_relaxed = get_relaxed_centers(c_init, n)\n        params_init = np.concatenate([c_relaxed[:, 0], c_relaxed[:, 1], np.full(n, r_relaxed)])\n        \n        res = minimize(objective, params_init, method='SLSQP', jac=grad_objective,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       options={'maxiter': 250})\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n        \n        trial_count += 1\n\n    # Final polish on the best result\n    if best_params is not None:\n        res = minimize(objective, best_params, method='SLSQP', jac=grad_objective,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       options={'maxiter': 800, 'ftol': 1e-12})\n        best_params = res.x\n        \n        # LP polish for radii\n        x, y, r = best_params[:n], best_params[n:2*n], best_params[2*n:]\n        centers = np.vstack([x, y]).T\n        r_polished = polish_radii(centers, n)\n        if r_polished is not None:\n            r = r_polished\n        \n        # Final strict feasibility enforcement\n        for i in range(n):\n            r[i] = min(r[i], x[i], 1 - x[i], y[i], 1 - y[i])\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                if r[i] + r[j] > dist:\n                    diff = (r[i] + r[j] - dist)\n                    r[i] -= diff / 2.0 + 1e-15\n                    r[j] -= diff / 2.0 + 1e-15\n        \n        r = np.maximum(r, 0)\n        best_sum = np.sum(r)\n        return centers, r, best_sum\n\n    return None, None, 0\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:33:22.758001",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2179,
        "candidates_token_count": 2208,
        "thoughts_token_count": 18613
      },
      "response_text_len": 6090
    }
  },
  "llm_call_duration_s": 119.79316076496616,
  "eval_duration_s": 270.06632377801
}