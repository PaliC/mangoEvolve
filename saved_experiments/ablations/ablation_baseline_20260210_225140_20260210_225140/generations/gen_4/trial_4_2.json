{
  "trial_id": "trial_4_2",
  "generation": 4,
  "parent_id": "trial_2_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start strategy followed by a shaking (basin-hopping) refinement phase.\n    \"\"\"\n    N = 26\n    \n    # Objective function: -sum of radii (since we want to maximize the sum)\n    def objective(params):\n        return -np.sum(params[2*N:])\n\n    # Gradient of the objective function\n    def grad_obj(params):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    # Constraints: circles must be inside the square and non-overlapping\n    # SLSQP expects constraints in the form fun(x) >= 0\n    def constraints_func(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        # Boundary constraints: 4 per circle (x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0)\n        c_boundary = np.zeros(4 * N)\n        idx = np.arange(N)\n        c_boundary[4*idx] = x - r\n        c_boundary[4*idx+1] = 1.0 - x - r\n        c_boundary[4*idx+2] = y - r\n        c_boundary[4*idx+3] = 1.0 - y - r\n        \n        # Non-overlap constraints: dist_sq - (r_i + r_j)**2 >= 0\n        row_indices, col_indices = np.triu_indices(N, k=1)\n        dx = x[row_indices] - x[col_indices]\n        dy = y[row_indices] - y[col_indices]\n        dr = r[row_indices] + r[col_indices]\n        c_overlap = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    # Jacobian of constraints for faster and more accurate optimization\n    def jacobian_func(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        n_overlap = N * (N - 1) // 2\n        n_boundary = 4 * N\n        jac = np.zeros((n_boundary + n_overlap, 3 * N))\n        \n        # Wall constraints gradients\n        idx = np.arange(N)\n        # x - r >= 0\n        jac[4*idx, idx] = 1\n        jac[4*idx, 2*N+idx] = -1\n        # 1 - x - r >= 0\n        jac[4*idx+1, idx] = -1\n        jac[4*idx+1, 2*N+idx] = -1\n        # y - r >= 0\n        jac[4*idx+2, N+idx] = 1\n        jac[4*idx+2, 2*N+idx] = -1\n        # 1 - y - r >= 0\n        jac[4*idx+3, N+idx] = -1\n        jac[4*idx+3, 2*N+idx] = -1\n        \n        # Overlap constraints gradients\n        row_indices, col_indices = np.triu_indices(N, k=1)\n        overlap_rows = np.arange(n_boundary, n_boundary + n_overlap)\n        dx = x[row_indices] - x[col_indices]\n        dy = y[row_indices] - y[col_indices]\n        dr = r[row_indices] + r[col_indices]\n        \n        jac[overlap_rows, row_indices] = 2 * dx\n        jac[overlap_rows, col_indices] = -2 * dx\n        jac[overlap_rows, N + row_indices] = 2 * dy\n        jac[overlap_rows, N + col_indices] = -2 * dy\n        jac[overlap_rows, 2*N + row_indices] = -2 * dr\n        jac[overlap_rows, 2*N + col_indices] = -2 * dr\n        \n        return jac\n\n    start_time = time.time()\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    # Initialize best parameters\n    best_params = None\n    best_sum = -1.0\n\n    # 1. Multi-start Phase: Explore different initial layouts\n    for i in range(15):\n        if time.time() - start_time > 60:\n            break\n        \n        if i == 0:\n            # Grid-based layout as a structured starting point\n            x_grid, y_grid = np.meshgrid(np.linspace(0.12, 0.88, 5), np.linspace(0.12, 0.88, 5))\n            x_init = np.concatenate([x_grid.flatten(), [0.05]])\n            y_init = np.concatenate([y_grid.flatten(), [0.05]])\n        else:\n            # Random starting points\n            x_init = np.random.uniform(0.1, 0.9, N)\n            y_init = np.random.uniform(0.1, 0.9, N)\n        \n        r_init = np.full(N, 0.03) # Start small to ensure initial feasibility\n        params_init = np.concatenate([x_init, y_init, r_init])\n        \n        res = minimize(objective, params_init, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 100})\n        \n        if -res.fun > best_sum:\n            if np.all(constraints_func(res.x) >= -1e-7):\n                best_sum = -res.fun\n                best_params = res.x\n\n    # 2. Refinement Phase (Basin-Hopping Style Shaking)\n    # Continually perturb and re-optimize to escape local maxima\n    while time.time() - start_time < 275:\n        if best_params is None: break\n        \n        current_params = best_params.copy()\n        x, y, r = current_params[:N], current_params[N:2*N], current_params[2*N:]\n        \n        # Shake strategy: Choose between targeted or global wiggling\n        shake_type = np.random.rand()\n        if shake_type < 0.2:\n            # Relocate 2 random circles to find new space\n            idx = np.random.choice(N, 2, replace=False)\n            current_params[idx] = np.random.uniform(0.1, 0.9, 2)\n            current_params[idx+N] = np.random.uniform(0.1, 0.9, 2)\n            current_params[idx+2*N] = 0.05\n        elif shake_type < 0.6:\n            # Targeted perturbation: Nudge \"loose\" circles more than \"locked\" ones\n            eps = 1e-6\n            wall_c = (x - r < eps).astype(int) + (1.0 - x - r < eps).astype(int) + \\\n                     (y - r < eps).astype(int) + (1.0 - y - r < eps).astype(int)\n            dist_sq = (x[:,None]-x[None,:])**2 + (y[:,None]-y[None,:])**2\n            dr_sq = (r[:,None]+r[None,:])**2\n            circle_c = np.sum((dist_sq - dr_sq < eps) & (dist_sq > 1e-9), axis=1)\n            loose = (wall_c + circle_c) < 3\n            \n            num_loose = np.sum(loose)\n            current_params[:N][loose] += np.random.normal(0, 0.1, num_loose)\n            current_params[N:2*N][loose] += np.random.normal(0, 0.1, num_loose)\n            current_params[:N][~loose] += np.random.normal(0, 0.01, N - num_loose)\n            current_params[N:2*N][~loose] += np.random.normal(0, 0.01, N - num_loose)\n            current_params[2*N:] *= 0.92\n        else:\n            # Simple global wiggle\n            current_params[:2*N] += np.random.normal(0, 0.02, 2*N)\n            current_params[2*N:] *= 0.95\n        \n        current_params[:2*N] = np.clip(current_params[:2*N], 0, 1)\n        current_params[2*N:] = np.clip(current_params[2*N:], 0, 0.5)\n\n        res = minimize(objective, current_params, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 150, 'ftol': 1e-7})\n        \n        if -res.fun > best_sum:\n            if np.all(constraints_func(res.x) >= -1e-7):\n                best_sum = -res.fun\n                best_params = res.x\n                \n    # 3. Final Polish: High-precision refinement of the best found solution\n    if best_params is not None:\n        res = minimize(objective, best_params, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 500, 'ftol': 1e-10})\n        if np.all(constraints_func(res.x) >= -1e-7):\n            best_params = res.x\n            best_sum = -res.fun\n\n    # Prepare final output\n    centers = best_params[:2*N].reshape(2, N).T\n    radii = best_params[2*N:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.626506015137096,
    "eval_time": 277.3848977088928,
    "error": null
  },
  "prompt": "Targeted perturbation for trial_2_4.\n1. Identify \"loose\" circles: calculate the distance between all pairs (i, j) and circles to walls.\n2. A circle is \"locked\" if it has 3 or more contacts (distance < 1e-8).\n3. In each iteration, perturb \"loose\" circles with a larger magnitude (1e-5) and \"locked\" circles with a very small magnitude (1e-8).\n4. Refine the whole configuration with SLSQP.\n5. This helps the packing \"settle\" by moving the parts that have room to move.\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'shaking' algorithm with SLSQP local optimization.\n    \"\"\"\n    N = 26\n    \n    # Objective function: -sum of radii (to minimize)\n    def objective(params):\n        return -np.sum(params[2*N:])\n\n    def grad_obj(params):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    # Constraints: circles inside square and non-overlapping\n    def constraints_func(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        # Boundary constraints: 4 per circle\n        c_boundary = np.zeros(4 * N)\n        idx = np.arange(N)\n        c_boundary[4*idx] = x - r\n        c_boundary[4*idx+1] = 1.0 - x - r\n        c_boundary[4*idx+2] = y - r\n        c_boundary[4*idx+3] = 1.0 - y - r\n        \n        # Non-overlap constraints: N*(N-1)/2\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dr = r[:, np.newaxis] + r[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        dr_sq = dr**2\n        indices = np.triu_indices(N, k=1)\n        c_overlap = dist_sq[indices] - dr_sq[indices]\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    # Jacobian of constraints for faster SLSQP convergence\n    def jacobian_func(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        n_overlap = N * (N - 1) // 2\n        n_boundary = 4 * N\n        jac = np.zeros((n_boundary + n_overlap, 3 * N))\n        \n        # Vectorized boundary gradients\n        idx = np.arange(N)\n        jac[4*idx, idx] = 1\n        jac[4*idx, 2*N+idx] = -1\n        jac[4*idx+1, idx] = -1\n        jac[4*idx+1, 2*N+idx] = -1\n        jac[4*idx+2, N+idx] = 1\n        jac[4*idx+2, 2*N+idx] = -1\n        jac[4*idx+3, N+idx] = -1\n        jac[4*idx+3, 2*N+idx] = -1\n        \n        # Vectorized overlap gradients\n        row_indices, col_indices = np.triu_indices(N, k=1)\n        overlap_rows = np.arange(n_boundary, n_boundary + n_overlap)\n        dx = x[row_indices] - x[col_indices]\n        dy = y[row_indices] - y[col_indices]\n        dr = r[row_indices] + r[col_indices]\n        \n        jac[overlap_rows, row_indices] = 2 * dx\n        jac[overlap_rows, col_indices] = -2 * dx\n        jac[overlap_rows, N + row_indices] = 2 * dy\n        jac[overlap_rows, N + col_indices] = -2 * dy\n        jac[overlap_rows, 2*N + row_indices] = -2 * dr\n        jac[overlap_rows, 2*N + col_indices] = -2 * dr\n        \n        return jac\n\n    start_time = time.time()\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    # 1. Initial Guess: Grid-based packing\n    # 5x5 grid plus one extra circle\n    x_grid = np.linspace(0.12, 0.88, 5)\n    y_grid = np.linspace(0.12, 0.88, 5)\n    xv, yv = np.meshgrid(x_grid, y_grid)\n    x_init = np.append(xv.flatten(), [0.5])\n    y_init = np.append(yv.flatten(), [0.5])\n    r_init = np.full(N, 0.08)\n    params_init = np.concatenate([x_init, y_init, r_init])\n    \n    best_params = params_init\n    best_sum = np.sum(r_init)\n\n    # Initial optimization\n    res = minimize(objective, params_init, method='SLSQP', jac=grad_obj,\n                   constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                   bounds=bounds, options={'maxiter': 150})\n    \n    if np.all(constraints_func(res.x) >= -1e-7):\n        best_params = res.x\n        best_sum = -res.fun\n\n    # 2. Shaking loop: Randomly perturb and settle\n    # Run for most of the allowed 300 seconds\n    while time.time() - start_time < 265:\n        current_params = best_params.copy()\n        # Shake: move 3 random circles to new positions and reset their radii\n        shake_indices = np.random.choice(N, 3, replace=False)\n        for idx in shake_indices:\n            current_params[idx] = np.random.uniform(0.1, 0.9)\n            current_params[idx+N] = np.random.uniform(0.1, 0.9)\n            current_params[idx+2*N] = 0.05\n        \n        # Local optimization (settle)\n        res = minimize(objective, current_params, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 60})\n        \n        # Keep if improved and feasible\n        if -res.fun > best_sum:\n            if np.all(constraints_func(res.x) >= -1e-7):\n                best_sum = -res.fun\n                best_params = res.x\n    \n    # 3. Final polish optimization\n    res = minimize(objective, best_params, method='SLSQP', jac=grad_obj,\n                   constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                   bounds=bounds, options={'maxiter': 300})\n    \n    if -res.fun > best_sum and np.all(constraints_func(res.x) >= -1e-7):\n        best_params = res.x\n        best_sum = -res.fun\n\n    # Prepare output\n    centers = best_params[:2*N].reshape(2, N).T\n    radii = best_params[2*N:]\n    sum_radii = best_sum\n    \n    return centers, radii, sum_radii\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start strategy followed by a shaking (basin-hopping) refinement phase.\n    \"\"\"\n    N = 26\n    \n    # Objective function: -sum of radii (since we want to maximize the sum)\n    def objective(params):\n        return -np.sum(params[2*N:])\n\n    # Gradient of the objective function\n    def grad_obj(params):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    # Constraints: circles must be inside the square and non-overlapping\n    # SLSQP expects constraints in the form fun(x) >= 0\n    def constraints_func(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        # Boundary constraints: 4 per circle (x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0)\n        c_boundary = np.zeros(4 * N)\n        idx = np.arange(N)\n        c_boundary[4*idx] = x - r\n        c_boundary[4*idx+1] = 1.0 - x - r\n        c_boundary[4*idx+2] = y - r\n        c_boundary[4*idx+3] = 1.0 - y - r\n        \n        # Non-overlap constraints: dist_sq - (r_i + r_j)**2 >= 0\n        row_indices, col_indices = np.triu_indices(N, k=1)\n        dx = x[row_indices] - x[col_indices]\n        dy = y[row_indices] - y[col_indices]\n        dr = r[row_indices] + r[col_indices]\n        c_overlap = dx**2 + dy**2 - dr**2\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    # Jacobian of constraints for faster and more accurate optimization\n    def jacobian_func(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        n_overlap = N * (N - 1) // 2\n        n_boundary = 4 * N\n        jac = np.zeros((n_boundary + n_overlap, 3 * N))\n        \n        # Wall constraints gradients\n        idx = np.arange(N)\n        # x - r >= 0\n        jac[4*idx, idx] = 1\n        jac[4*idx, 2*N+idx] = -1\n        # 1 - x - r >= 0\n        jac[4*idx+1, idx] = -1\n        jac[4*idx+1, 2*N+idx] = -1\n        # y - r >= 0\n        jac[4*idx+2, N+idx] = 1\n        jac[4*idx+2, 2*N+idx] = -1\n        # 1 - y - r >= 0\n        jac[4*idx+3, N+idx] = -1\n        jac[4*idx+3, 2*N+idx] = -1\n        \n        # Overlap constraints gradients\n        row_indices, col_indices = np.triu_indices(N, k=1)\n        overlap_rows = np.arange(n_boundary, n_boundary + n_overlap)\n        dx = x[row_indices] - x[col_indices]\n        dy = y[row_indices] - y[col_indices]\n        dr = r[row_indices] + r[col_indices]\n        \n        jac[overlap_rows, row_indices] = 2 * dx\n        jac[overlap_rows, col_indices] = -2 * dx\n        jac[overlap_rows, N + row_indices] = 2 * dy\n        jac[overlap_rows, N + col_indices] = -2 * dy\n        jac[overlap_rows, 2*N + row_indices] = -2 * dr\n        jac[overlap_rows, 2*N + col_indices] = -2 * dr\n        \n        return jac\n\n    start_time = time.time()\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    # Initialize best parameters\n    best_params = None\n    best_sum = -1.0\n\n    # 1. Multi-start Phase: Explore different initial layouts\n    for i in range(15):\n        if time.time() - start_time > 60:\n            break\n        \n        if i == 0:\n            # Grid-based layout as a structured starting point\n            x_grid, y_grid = np.meshgrid(np.linspace(0.12, 0.88, 5), np.linspace(0.12, 0.88, 5))\n            x_init = np.concatenate([x_grid.flatten(), [0.05]])\n            y_init = np.concatenate([y_grid.flatten(), [0.05]])\n        else:\n            # Random starting points\n            x_init = np.random.uniform(0.1, 0.9, N)\n            y_init = np.random.uniform(0.1, 0.9, N)\n        \n        r_init = np.full(N, 0.03) # Start small to ensure initial feasibility\n        params_init = np.concatenate([x_init, y_init, r_init])\n        \n        res = minimize(objective, params_init, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 100})\n        \n        if -res.fun > best_sum:\n            if np.all(constraints_func(res.x) >= -1e-7):\n                best_sum = -res.fun\n                best_params = res.x\n\n    # 2. Refinement Phase (Basin-Hopping Style Shaking)\n    # Continually perturb and re-optimize to escape local maxima\n    while time.time() - start_time < 275:\n        if best_params is None: break\n        \n        current_params = best_params.copy()\n        x, y, r = current_params[:N], current_params[N:2*N], current_params[2*N:]\n        \n        # Shake strategy: Choose between targeted or global wiggling\n        shake_type = np.random.rand()\n        if shake_type < 0.2:\n            # Relocate 2 random circles to find new space\n            idx = np.random.choice(N, 2, replace=False)\n            current_params[idx] = np.random.uniform(0.1, 0.9, 2)\n            current_params[idx+N] = np.random.uniform(0.1, 0.9, 2)\n            current_params[idx+2*N] = 0.05\n        elif shake_type < 0.6:\n            # Targeted perturbation: Nudge \"loose\" circles more than \"locked\" ones\n            eps = 1e-6\n            wall_c = (x - r < eps).astype(int) + (1.0 - x - r < eps).astype(int) + \\\n                     (y - r < eps).astype(int) + (1.0 - y - r < eps).astype(int)\n            dist_sq = (x[:,None]-x[None,:])**2 + (y[:,None]-y[None,:])**2\n            dr_sq = (r[:,None]+r[None,:])**2\n            circle_c = np.sum((dist_sq - dr_sq < eps) & (dist_sq > 1e-9), axis=1)\n            loose = (wall_c + circle_c) < 3\n            \n            num_loose = np.sum(loose)\n            current_params[:N][loose] += np.random.normal(0, 0.1, num_loose)\n            current_params[N:2*N][loose] += np.random.normal(0, 0.1, num_loose)\n            current_params[:N][~loose] += np.random.normal(0, 0.01, N - num_loose)\n            current_params[N:2*N][~loose] += np.random.normal(0, 0.01, N - num_loose)\n            current_params[2*N:] *= 0.92\n        else:\n            # Simple global wiggle\n            current_params[:2*N] += np.random.normal(0, 0.02, 2*N)\n            current_params[2*N:] *= 0.95\n        \n        current_params[:2*N] = np.clip(current_params[:2*N], 0, 1)\n        current_params[2*N:] = np.clip(current_params[2*N:], 0, 0.5)\n\n        res = minimize(objective, current_params, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 150, 'ftol': 1e-7})\n        \n        if -res.fun > best_sum:\n            if np.all(constraints_func(res.x) >= -1e-7):\n                best_sum = -res.fun\n                best_params = res.x\n                \n    # 3. Final Polish: High-precision refinement of the best found solution\n    if best_params is not None:\n        res = minimize(objective, best_params, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 500, 'ftol': 1e-10})\n        if np.all(constraints_func(res.x) >= -1e-7):\n            best_params = res.x\n            best_sum = -res.fun\n\n    # Prepare final output\n    centers = best_params[:2*N].reshape(2, N).T\n    radii = best_params[2*N:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:33:43.591582",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2161,
        "candidates_token_count": 2578,
        "thoughts_token_count": 20305
      },
      "response_text_len": 7399
    }
  },
  "llm_call_duration_s": 133.2964841159992,
  "eval_duration_s": 277.3849064819515
}