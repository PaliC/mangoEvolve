{
  "trial_id": "trial_6_3",
  "generation": 6,
  "parent_id": "trial_3_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Sequential Quadratic Programming (SQP) approach with linearized constraints\n    and a trust-region-like step penalty.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def get_initial_params(mode='random'):\n        if mode == 'grid':\n            r = 0.08\n            x = np.linspace(r, 1-r, 5)\n            y = np.linspace(r, 1-r, 5)\n            xv, yv = np.meshgrid(x, y)\n            x_init = np.concatenate([xv.flatten(), [0.5]])\n            y_init = np.concatenate([yv.flatten(), [0.5]])\n            r_init = np.full(N, r)\n            return np.concatenate([x_init, y_init, r_init])\n        else:\n            x_init = np.random.uniform(0.1, 0.9, N)\n            y_init = np.random.uniform(0.1, 0.9, N)\n            r_init = np.full(N, 0.05)\n            return np.concatenate([x_init, y_init, r_init])\n\n    def solve_qp_step(params_k, step_size, rho):\n        x_k = params_k[:N]\n        y_k = params_k[N:2*N]\n        r_k = params_k[2*N:]\n        \n        # QP objective: min -sum(delta_r) + rho/2 * ||delta||^2\n        def qp_obj(delta):\n            dr = delta[2*N:]\n            return -np.sum(dr) + (rho / 2.0) * np.sum(delta**2)\n        \n        def qp_grad(delta):\n            grad = rho * delta\n            grad[2*N:] -= 1.0\n            return grad\n        \n        # Linearize constraints: A @ delta >= b\n        A = []\n        b = []\n        \n        # Boundary constraints: x+dx-(r+dr) >= 0 => dx - dr >= -(x-r)\n        for i in range(N):\n            # x_i - r_i >= 0\n            row = np.zeros(3*N)\n            row[i] = 1.0\n            row[2*N+i] = -1.0\n            A.append(row)\n            b.append(-(x_k[i] - r_k[i]))\n            \n            # 1 - x_i - r_i >= 0\n            row = np.zeros(3*N)\n            row[i] = -1.0\n            row[2*N+i] = -1.0\n            A.append(row)\n            b.append(-(1.0 - x_k[i] - r_k[i]))\n            \n            # y_i - r_i >= 0\n            row = np.zeros(3*N)\n            row[N+i] = 1.0\n            row[2*N+i] = -1.0\n            A.append(row)\n            b.append(-(y_k[i] - r_k[i]))\n            \n            # 1 - y_i - r_i >= 0\n            row = np.zeros(3*N)\n            row[N+i] = -1.0\n            row[2*N+i] = -1.0\n            A.append(row)\n            b.append(-(1.0 - y_k[i] - r_k[i]))\n            \n            # r_i + delta_r_i >= 0\n            row = np.zeros(3*N)\n            row[2*N+i] = 1.0\n            A.append(row)\n            b.append(-r_k[i])\n\n        # Non-overlap constraints: linearized\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = x_k[i] - x_k[j]\n                dy = y_k[i] - y_k[j]\n                dr = r_k[i] + r_k[j]\n                dist_sq = dx**2 + dy**2\n                dr_sq = dr**2\n                \n                # Only linearize if they are somewhat close\n                if dist_sq < (dr + 0.1)**2:\n                    row = np.zeros(3*N)\n                    row[i] = 2 * dx\n                    row[j] = -2 * dx\n                    row[N+i] = 2 * dy\n                    row[N+j] = -2 * dy\n                    row[2*N+i] = -2 * dr\n                    row[2*N+j] = -2 * dr\n                    A.append(row)\n                    b.append(-(dist_sq - dr_sq))\n        \n        A = np.array(A)\n        b = np.array(b)\n        \n        # Trust region bounds\n        delta_bounds = [(-step_size, step_size)] * (3*N)\n        \n        res = minimize(qp_obj, np.zeros(3*N), jac=qp_grad,\n                       constraints={'type': 'ineq', 'fun': lambda d: A @ d - b, 'jac': lambda d: A},\n                       bounds=delta_bounds, method='SLSQP', options={'maxiter': 50})\n        \n        if res.success:\n            return res.x\n        else:\n            return np.zeros(3*N)\n\n    # Nonlinear constraints for the polish step\n    def nonlinear_constraints(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        c = []\n        for i in range(N):\n            c.extend([x[i] - r[i], 1.0 - x[i] - r[i], y[i] - r[i], 1.0 - y[i] - r[i], r[i]])\n        for i in range(N):\n            for j in range(i + 1, N):\n                c.append((x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2)\n        return np.array(c)\n\n    # Initial best solution\n    best_params = get_initial_params('grid')\n    best_sum = np.sum(best_params[2*N:])\n    \n    # Global Search Loop\n    trial_count = 0\n    while time.time() - start_time < 260:\n        if trial_count == 0:\n            params = get_initial_params('grid')\n        elif trial_count % 3 == 0:\n            # Shake the best solution\n            params = best_params.copy()\n            shake_indices = np.random.choice(N, 4, replace=False)\n            params[shake_indices] = np.random.uniform(0.1, 0.9, 4)\n            params[shake_indices + N] = np.random.uniform(0.1, 0.9, 4)\n            params[shake_indices + 2*N] = 0.02\n        else:\n            params = get_initial_params('random')\n            \n        # SQP iterations\n        step_size = 0.05\n        rho = 20.0\n        for sqp_iter in range(30):\n            delta = solve_qp_step(params, step_size, rho)\n            if np.all(np.abs(delta) < 1e-7):\n                break\n            params += delta\n            step_size *= 0.97 # Gradually reduce step size\n            rho *= 1.02 # Gradually increase penalty\n        \n        # Local refinement for this trial\n        res = minimize(lambda p: -np.sum(p[2*N:]), params, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': nonlinear_constraints},\n                       options={'maxiter': 60})\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n            \n        trial_count += 1\n\n    # Final polish on the best overall solution\n    res = minimize(lambda p: -np.sum(p[2*N:]), best_params, method='SLSQP',\n                   constraints={'type': 'ineq', 'fun': nonlinear_constraints},\n                   options={'maxiter': 200})\n    \n    if res.success:\n        best_params = res.x\n        best_sum = -res.fun\n\n    centers = np.column_stack((best_params[:N], best_params[N:2*N]))\n    radii = best_params[2*N:]\n    \n    return centers, radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.617884956998646,
    "eval_time": 261.7480411529541,
    "error": null
  },
  "prompt": "Implement a 'Sequential Quadratic Programming' (SQP) approach specifically tailored for trial_3_4. Instead of the standard scipy minimize, implement a loop that linearizes the constraints at the current point and solves the resulting quadratic program to find the next step. This can often handle the 'tight' constraints of circle packing better than general-purpose solvers when near the optimum. import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'shaking' algorithm with SLSQP local optimization.\n    \"\"\"\n    N = 26\n    \n    # Objective function: -sum of radii (to minimize)\n    def objective(params):\n        return -np.sum(params[2*N:])\n\n    def grad_obj(params):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    # Constraints: circles inside square and non-overlapping\n    def constraints_func(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        # Boundary constraints: 4 per circle\n        c_boundary = np.zeros(4 * N)\n        idx = np.arange(N)\n        c_boundary[4*idx] = x - r\n        c_boundary[4*idx+1] = 1.0 - x - r\n        c_boundary[4*idx+2] = y - r\n        c_boundary[4*idx+3] = 1.0 - y - r\n        \n        # Non-overlap constraints: N*(N-1)/2\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dr = r[:, np.newaxis] + r[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        dr_sq = dr**2\n        indices = np.triu_indices(N, k=1)\n        c_overlap = dist_sq[indices] - dr_sq[indices]\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    # Jacobian of constraints for faster SLSQP convergence\n    def jacobian_func(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        n_overlap = N * (N - 1) // 2\n        n_boundary = 4 * N\n        jac = np.zeros((n_boundary + n_overlap, 3 * N))\n        \n        # Vectorized boundary gradients\n        idx = np.arange(N)\n        jac[4*idx, idx] = 1\n        jac[4*idx, 2*N+idx] = -1\n        jac[4*idx+1, idx] = -1\n        jac[4*idx+1, 2*N+idx] = -1\n        jac[4*idx+2, N+idx] = 1\n        jac[4*idx+2, 2*N+idx] = -1\n        jac[4*idx+3, N+idx] = -1\n        jac[4*idx+3, 2*N+idx] = -1\n        \n        # Vectorized overlap gradients\n        row_indices, col_indices = np.triu_indices(N, k=1)\n        overlap_rows = np.arange(n_boundary, n_boundary + n_overlap)\n        dx = x[row_indices] - x[col_indices]\n        dy = y[row_indices] - y[col_indices]\n        dr = r[row_indices] + r[col_indices]\n        \n        jac[overlap_rows, row_indices] = 2 * dx\n        jac[overlap_rows, col_indices] = -2 * dx\n        jac[overlap_rows, N + row_indices] = 2 * dy\n        jac[overlap_rows, N + col_indices] = -2 * dy\n        jac[overlap_rows, 2*N + row_indices] = -2 * dr\n        jac[overlap_rows, 2*N + col_indices] = -2 * dr\n        \n        return jac\n\n    start_time = time.time()\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    # 1. Initial Guess: Grid-based packing\n    # 5x5 grid plus one extra circle\n    x_grid = np.linspace(0.12, 0.88, 5)\n    y_grid = np.linspace(0.12, 0.88, 5)\n    xv, yv = np.meshgrid(x_grid, y_grid)\n    x_init = np.append(xv.flatten(), [0.5])\n    y_init = np.append(yv.flatten(), [0.5])\n    r_init = np.full(N, 0.08)\n    params_init = np.concatenate([x_init, y_init, r_init])\n    \n    best_params = params_init\n    best_sum = np.sum(r_init)\n\n    # Initial optimization\n    res = minimize(objective, params_init, method='SLSQP', jac=grad_obj,\n                   constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                   bounds=bounds, options={'maxiter': 150})\n    \n    if np.all(constraints_func(res.x) >= -1e-7):\n        best_params = res.x\n        best_sum = -res.fun\n\n    # 2. Shaking loop: Randomly perturb and settle\n    # Run for most of the allowed 300 seconds\n    while time.time() - start_time < 265:\n        current_params = best_params.copy()\n        # Shake: move 3 random circles to new positions and reset their radii\n        shake_indices = np.random.choice(N, 3, replace=False)\n        for idx in shake_indices:\n            current_params[idx] = np.random.uniform(0.1, 0.9)\n            current_params[idx+N] = np.random.uniform(0.1, 0.9)\n            current_params[idx+2*N] = 0.05\n        \n        # Local optimization (settle)\n        res = minimize(objective, current_params, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 60})\n        \n        # Keep if improved and feasible\n        if -res.fun > best_sum:\n            if np.all(constraints_func(res.x) >= -1e-7):\n                best_sum = -res.fun\n                best_params = res.x\n    \n    # 3. Final polish optimization\n    res = minimize(objective, best_params, method='SLSQP', jac=grad_obj,\n                   constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                   bounds=bounds, options={'maxiter': 300})\n    \n    if -res.fun > best_sum and np.all(constraints_func(res.x) >= -1e-7):\n        best_params = res.x\n        best_sum = -res.fun\n\n    # Prepare output\n    centers = best_params[:2*N].reshape(2, N).T\n    radii = best_params[2*N:]\n    sum_radii = best_sum\n    \n    return centers, radii, sum_radii",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Sequential Quadratic Programming (SQP) approach with linearized constraints\n    and a trust-region-like step penalty.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def get_initial_params(mode='random'):\n        if mode == 'grid':\n            r = 0.08\n            x = np.linspace(r, 1-r, 5)\n            y = np.linspace(r, 1-r, 5)\n            xv, yv = np.meshgrid(x, y)\n            x_init = np.concatenate([xv.flatten(), [0.5]])\n            y_init = np.concatenate([yv.flatten(), [0.5]])\n            r_init = np.full(N, r)\n            return np.concatenate([x_init, y_init, r_init])\n        else:\n            x_init = np.random.uniform(0.1, 0.9, N)\n            y_init = np.random.uniform(0.1, 0.9, N)\n            r_init = np.full(N, 0.05)\n            return np.concatenate([x_init, y_init, r_init])\n\n    def solve_qp_step(params_k, step_size, rho):\n        x_k = params_k[:N]\n        y_k = params_k[N:2*N]\n        r_k = params_k[2*N:]\n        \n        # QP objective: min -sum(delta_r) + rho/2 * ||delta||^2\n        def qp_obj(delta):\n            dr = delta[2*N:]\n            return -np.sum(dr) + (rho / 2.0) * np.sum(delta**2)\n        \n        def qp_grad(delta):\n            grad = rho * delta\n            grad[2*N:] -= 1.0\n            return grad\n        \n        # Linearize constraints: A @ delta >= b\n        A = []\n        b = []\n        \n        # Boundary constraints: x+dx-(r+dr) >= 0 => dx - dr >= -(x-r)\n        for i in range(N):\n            # x_i - r_i >= 0\n            row = np.zeros(3*N)\n            row[i] = 1.0\n            row[2*N+i] = -1.0\n            A.append(row)\n            b.append(-(x_k[i] - r_k[i]))\n            \n            # 1 - x_i - r_i >= 0\n            row = np.zeros(3*N)\n            row[i] = -1.0\n            row[2*N+i] = -1.0\n            A.append(row)\n            b.append(-(1.0 - x_k[i] - r_k[i]))\n            \n            # y_i - r_i >= 0\n            row = np.zeros(3*N)\n            row[N+i] = 1.0\n            row[2*N+i] = -1.0\n            A.append(row)\n            b.append(-(y_k[i] - r_k[i]))\n            \n            # 1 - y_i - r_i >= 0\n            row = np.zeros(3*N)\n            row[N+i] = -1.0\n            row[2*N+i] = -1.0\n            A.append(row)\n            b.append(-(1.0 - y_k[i] - r_k[i]))\n            \n            # r_i + delta_r_i >= 0\n            row = np.zeros(3*N)\n            row[2*N+i] = 1.0\n            A.append(row)\n            b.append(-r_k[i])\n\n        # Non-overlap constraints: linearized\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = x_k[i] - x_k[j]\n                dy = y_k[i] - y_k[j]\n                dr = r_k[i] + r_k[j]\n                dist_sq = dx**2 + dy**2\n                dr_sq = dr**2\n                \n                # Only linearize if they are somewhat close\n                if dist_sq < (dr + 0.1)**2:\n                    row = np.zeros(3*N)\n                    row[i] = 2 * dx\n                    row[j] = -2 * dx\n                    row[N+i] = 2 * dy\n                    row[N+j] = -2 * dy\n                    row[2*N+i] = -2 * dr\n                    row[2*N+j] = -2 * dr\n                    A.append(row)\n                    b.append(-(dist_sq - dr_sq))\n        \n        A = np.array(A)\n        b = np.array(b)\n        \n        # Trust region bounds\n        delta_bounds = [(-step_size, step_size)] * (3*N)\n        \n        res = minimize(qp_obj, np.zeros(3*N), jac=qp_grad,\n                       constraints={'type': 'ineq', 'fun': lambda d: A @ d - b, 'jac': lambda d: A},\n                       bounds=delta_bounds, method='SLSQP', options={'maxiter': 50})\n        \n        if res.success:\n            return res.x\n        else:\n            return np.zeros(3*N)\n\n    # Nonlinear constraints for the polish step\n    def nonlinear_constraints(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        c = []\n        for i in range(N):\n            c.extend([x[i] - r[i], 1.0 - x[i] - r[i], y[i] - r[i], 1.0 - y[i] - r[i], r[i]])\n        for i in range(N):\n            for j in range(i + 1, N):\n                c.append((x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2)\n        return np.array(c)\n\n    # Initial best solution\n    best_params = get_initial_params('grid')\n    best_sum = np.sum(best_params[2*N:])\n    \n    # Global Search Loop\n    trial_count = 0\n    while time.time() - start_time < 260:\n        if trial_count == 0:\n            params = get_initial_params('grid')\n        elif trial_count % 3 == 0:\n            # Shake the best solution\n            params = best_params.copy()\n            shake_indices = np.random.choice(N, 4, replace=False)\n            params[shake_indices] = np.random.uniform(0.1, 0.9, 4)\n            params[shake_indices + N] = np.random.uniform(0.1, 0.9, 4)\n            params[shake_indices + 2*N] = 0.02\n        else:\n            params = get_initial_params('random')\n            \n        # SQP iterations\n        step_size = 0.05\n        rho = 20.0\n        for sqp_iter in range(30):\n            delta = solve_qp_step(params, step_size, rho)\n            if np.all(np.abs(delta) < 1e-7):\n                break\n            params += delta\n            step_size *= 0.97 # Gradually reduce step size\n            rho *= 1.02 # Gradually increase penalty\n        \n        # Local refinement for this trial\n        res = minimize(lambda p: -np.sum(p[2*N:]), params, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': nonlinear_constraints},\n                       options={'maxiter': 60})\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_params = res.x\n            \n        trial_count += 1\n\n    # Final polish on the best overall solution\n    res = minimize(lambda p: -np.sum(p[2*N:]), best_params, method='SLSQP',\n                   constraints={'type': 'ineq', 'fun': nonlinear_constraints},\n                   options={'maxiter': 200})\n    \n    if res.success:\n        best_params = res.x\n        best_sum = -res.fun\n\n    centers = np.column_stack((best_params[:N], best_params[N:2*N]))\n    radii = best_params[2*N:]\n    \n    return centers, radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:52:00.080786",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2102,
        "candidates_token_count": 2197,
        "thoughts_token_count": 18737
      },
      "response_text_len": 6356
    }
  },
  "llm_call_duration_s": 121.38468468294013,
  "eval_duration_s": 261.7480505289277
}