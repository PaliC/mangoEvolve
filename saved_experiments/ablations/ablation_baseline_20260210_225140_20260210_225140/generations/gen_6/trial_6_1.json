{
  "trial_id": "trial_6_1",
  "generation": 6,
  "parent_id": "trial_3_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport itertools\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a bilevel optimization approach:\n    - Inner loop: Solves a Linear Program (LP) to find the optimal radii for fixed centers.\n    - Outer loop: Optimizes center positions using L-BFGS-B, guided by the dual variables\n      (shadow prices) of the LP to calculate the exact gradient of the sum of radii.\n    \"\"\"\n    N = 26\n    \n    # Precompute overlap pairs (all unique pairs of circles)\n    overlap_pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            overlap_pairs.append([i, j])\n    overlap_pairs = np.array(overlap_pairs)\n    num_overlap = len(overlap_pairs)\n    \n    # Precompute LP matrices\n    # Objective: maximize sum(r_i) => minimize -sum(r_i)\n    c_lp = -np.ones(N)\n    \n    # Inequality constraints matrix A_ub for linprog:\n    # 1. Non-overlap constraints: r_i + r_j <= d_ij\n    # 2. Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    A_overlap = np.zeros((num_overlap, N))\n    for k, (i, j) in enumerate(overlap_pairs):\n        A_overlap[k, i] = 1\n        A_overlap[k, j] = 1\n    \n    A_boundary = np.eye(N)\n    # Total A_ub shape: (num_overlap + 4*N, N) = (325 + 104, 26) = (429, 26)\n    A_ub = np.vstack([A_overlap, A_boundary, A_boundary, A_boundary, A_boundary])\n    \n    def get_sum_radii_and_grad(centers_flat):\n        \"\"\"\n        Calculates the maximum sum of radii for given center positions and its gradient.\n        \"\"\"\n        centers = centers_flat.reshape((N, 2))\n        x, y = centers[:, 0], centers[:, 1]\n        \n        # Calculate distances between centers for non-overlap bounds\n        dx = x[overlap_pairs[:, 0]] - x[overlap_pairs[:, 1]]\n        dy = y[overlap_pairs[:, 0]] - y[overlap_pairs[:, 1]]\n        # Small epsilon to prevent division by zero in gradient calculations\n        d_ij = np.sqrt(dx**2 + dy**2 + 1e-12)\n        \n        # Upper bounds for radii (overlap and boundary)\n        b_ub = np.concatenate([d_ij, x, 1.0 - x, y, 1.0 - y])\n        \n        # Solve LP using the fast HiGHS solver\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, method='highs', options={'presolve': True})\n        \n        if not res.success:\n            return 0.0, np.zeros(2 * N)\n        \n        # sum_radii = -res.fun (since objective was -sum(r))\n        sum_radii = -res.fun\n        lambdas = res.ineqlin.marginals # Dual variables (Lagrange multipliers)\n        \n        # Gradient calculation using dual variables:\n        # The sensitivity of the optimal sum to a bound b_k is exactly the dual variable lambda_k.\n        lam_overlap = lambdas[:num_overlap]\n        lam_x1 = lambdas[num_overlap : num_overlap + N]\n        lam_x2 = lambdas[num_overlap + N : num_overlap + 2 * N]\n        lam_y1 = lambdas[num_overlap + 2 * N : num_overlap + 3 * N]\n        lam_y2 = lambdas[num_overlap + 3 * N : num_overlap + 4 * N]\n        \n        grad_x = np.zeros(N)\n        grad_y = np.zeros(N)\n        \n        # Gradient contribution from distance constraints: lambda_ij * d(d_ij)/dx\n        term_x = lam_overlap * dx / d_ij\n        term_y = lam_overlap * dy / d_ij\n        \n        np.add.at(grad_x, overlap_pairs[:, 0], term_x)\n        np.subtract.at(grad_x, overlap_pairs[:, 1], term_x)\n        np.add.at(grad_y, overlap_pairs[:, 0], term_y)\n        np.subtract.at(grad_y, overlap_pairs[:, 1], term_y)\n        \n        # Gradient contribution from boundary constraints\n        grad_x += lam_x1 - lam_x2\n        grad_y += lam_y1 - lam_y2\n        \n        # Return negative values for minimization\n        return -sum_radii, -np.concatenate([grad_x, grad_y])\n\n    best_sum = 0\n    best_centers = None\n    start_time = time.time()\n    \n    # 1. Strategic Initial Guesses (Grids)\n    grids = [(5, 5), (4, 6), (2, 13)]\n    for rows, cols in grids:\n        if time.time() - start_time > 280: break\n        \n        x_grid = np.linspace(0.1, 0.9, cols)\n        y_grid = np.linspace(0.1, 0.9, rows)\n        xv, yv = np.meshgrid(x_grid, y_grid)\n        x_init, y_init = xv.flatten(), yv.flatten()\n        \n        # Adjust size to exactly N\n        if len(x_init) < N:\n            x_init = np.append(x_init, np.random.uniform(0.1, 0.9, N - len(x_init)))\n            y_init = np.append(y_init, np.random.uniform(0.1, 0.9, N - len(y_init)))\n        else:\n            x_init, y_init = x_init[:N], y_init[:N]\n            \n        params_init = np.concatenate([x_init, y_init]) + np.random.normal(0, 0.01, 2 * N)\n        params_init = np.clip(params_init, 0, 1)\n        \n        res = minimize(get_sum_radii_and_grad, params_init, method='L-BFGS-B', \n                       jac=True, bounds=[(0, 1)] * (2 * N))\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = res.x\n\n    # 2. Random Restarts to explore other basins\n    while time.time() - start_time < 260:\n        params_init = np.random.uniform(0.1, 0.9, 2 * N)\n        res = minimize(get_sum_radii_and_grad, params_init, method='L-BFGS-B', \n                       jac=True, bounds=[(0, 1)] * (2 * N))\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = res.x\n\n    # If no optimization finished successfully, use a random fallback\n    if best_centers is None:\n        best_centers = np.random.uniform(0.1, 0.9, 2 * N)\n\n    # Final Radii Calculation for the best centers found\n    centers = best_centers.reshape((N, 2))\n    x, y = centers[:, 0], centers[:, 1]\n    dx = x[overlap_pairs[:, 0]] - x[overlap_pairs[:, 1]]\n    dy = y[overlap_pairs[:, 0]] - y[overlap_pairs[:, 1]]\n    d_ij = np.sqrt(dx**2 + dy**2 + 1e-12)\n    b_ub = np.concatenate([d_ij, x, 1.0 - x, y, 1.0 - y])\n    res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, method='highs')\n    radii = res.x\n    sum_radii = -res.fun\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "score": 1.8328637575220743,
    "eval_time": 260.55164217948914,
    "error": null
  },
  "prompt": "Refine the best solution (trial_3_4) using a 'Bilevel Optimization' approach. The outer loop optimizes center positions using small steps. The inner loop calculates the mathematically optimal radii for those fixed centers using an iterative coordinate-descent or a fast LP solver (scipy.optimize.linprog with method='highs'). Since the radii sum is the objective, use the dual variables of the LP (if possible) or finite differences to guide the center movements. import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'shaking' algorithm with SLSQP local optimization.\n    \"\"\"\n    N = 26\n    \n    # Objective function: -sum of radii (to minimize)\n    def objective(params):\n        return -np.sum(params[2*N:])\n\n    def grad_obj(params):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    # Constraints: circles inside square and non-overlapping\n    def constraints_func(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        \n        # Boundary constraints: 4 per circle\n        c_boundary = np.zeros(4 * N)\n        idx = np.arange(N)\n        c_boundary[4*idx] = x - r\n        c_boundary[4*idx+1] = 1.0 - x - r\n        c_boundary[4*idx+2] = y - r\n        c_boundary[4*idx+3] = 1.0 - y - r\n        \n        # Non-overlap constraints: N*(N-1)/2\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dr = r[:, np.newaxis] + r[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        dr_sq = dr**2\n        indices = np.triu_indices(N, k=1)\n        c_overlap = dist_sq[indices] - dr_sq[indices]\n        \n        return np.concatenate([c_boundary, c_overlap])\n\n    # Jacobian of constraints for faster SLSQP convergence\n    def jacobian_func(params):\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:]\n        n_overlap = N * (N - 1) // 2\n        n_boundary = 4 * N\n        jac = np.zeros((n_boundary + n_overlap, 3 * N))\n        \n        # Vectorized boundary gradients\n        idx = np.arange(N)\n        jac[4*idx, idx] = 1\n        jac[4*idx, 2*N+idx] = -1\n        jac[4*idx+1, idx] = -1\n        jac[4*idx+1, 2*N+idx] = -1\n        jac[4*idx+2, N+idx] = 1\n        jac[4*idx+2, 2*N+idx] = -1\n        jac[4*idx+3, N+idx] = -1\n        jac[4*idx+3, 2*N+idx] = -1\n        \n        # Vectorized overlap gradients\n        row_indices, col_indices = np.triu_indices(N, k=1)\n        overlap_rows = np.arange(n_boundary, n_boundary + n_overlap)\n        dx = x[row_indices] - x[col_indices]\n        dy = y[row_indices] - y[col_indices]\n        dr = r[row_indices] + r[col_indices]\n        \n        jac[overlap_rows, row_indices] = 2 * dx\n        jac[overlap_rows, col_indices] = -2 * dx\n        jac[overlap_rows, N + row_indices] = 2 * dy\n        jac[overlap_rows, N + col_indices] = -2 * dy\n        jac[overlap_rows, 2*N + row_indices] = -2 * dr\n        jac[overlap_rows, 2*N + col_indices] = -2 * dr\n        \n        return jac\n\n    start_time = time.time()\n    bounds = [(0, 1)] * (2*N) + [(0, 0.5)] * N\n    \n    # 1. Initial Guess: Grid-based packing\n    # 5x5 grid plus one extra circle\n    x_grid = np.linspace(0.12, 0.88, 5)\n    y_grid = np.linspace(0.12, 0.88, 5)\n    xv, yv = np.meshgrid(x_grid, y_grid)\n    x_init = np.append(xv.flatten(), [0.5])\n    y_init = np.append(yv.flatten(), [0.5])\n    r_init = np.full(N, 0.08)\n    params_init = np.concatenate([x_init, y_init, r_init])\n    \n    best_params = params_init\n    best_sum = np.sum(r_init)\n\n    # Initial optimization\n    res = minimize(objective, params_init, method='SLSQP', jac=grad_obj,\n                   constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                   bounds=bounds, options={'maxiter': 150})\n    \n    if np.all(constraints_func(res.x) >= -1e-7):\n        best_params = res.x\n        best_sum = -res.fun\n\n    # 2. Shaking loop: Randomly perturb and settle\n    # Run for most of the allowed 300 seconds\n    while time.time() - start_time < 265:\n        current_params = best_params.copy()\n        # Shake: move 3 random circles to new positions and reset their radii\n        shake_indices = np.random.choice(N, 3, replace=False)\n        for idx in shake_indices:\n            current_params[idx] = np.random.uniform(0.1, 0.9)\n            current_params[idx+N] = np.random.uniform(0.1, 0.9)\n            current_params[idx+2*N] = 0.05\n        \n        # Local optimization (settle)\n        res = minimize(objective, current_params, method='SLSQP', jac=grad_obj,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                       bounds=bounds, options={'maxiter': 60})\n        \n        # Keep if improved and feasible\n        if -res.fun > best_sum:\n            if np.all(constraints_func(res.x) >= -1e-7):\n                best_sum = -res.fun\n                best_params = res.x\n    \n    # 3. Final polish optimization\n    res = minimize(objective, best_params, method='SLSQP', jac=grad_obj,\n                   constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n                   bounds=bounds, options={'maxiter': 300})\n    \n    if -res.fun > best_sum and np.all(constraints_func(res.x) >= -1e-7):\n        best_params = res.x\n        best_sum = -res.fun\n\n    # Prepare output\n    centers = best_params[:2*N].reshape(2, N).T\n    radii = best_params[2*N:]\n    sum_radii = best_sum\n    \n    return centers, radii, sum_radii",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport itertools\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a bilevel optimization approach:\n    - Inner loop: Solves a Linear Program (LP) to find the optimal radii for fixed centers.\n    - Outer loop: Optimizes center positions using L-BFGS-B, guided by the dual variables\n      (shadow prices) of the LP to calculate the exact gradient of the sum of radii.\n    \"\"\"\n    N = 26\n    \n    # Precompute overlap pairs (all unique pairs of circles)\n    overlap_pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            overlap_pairs.append([i, j])\n    overlap_pairs = np.array(overlap_pairs)\n    num_overlap = len(overlap_pairs)\n    \n    # Precompute LP matrices\n    # Objective: maximize sum(r_i) => minimize -sum(r_i)\n    c_lp = -np.ones(N)\n    \n    # Inequality constraints matrix A_ub for linprog:\n    # 1. Non-overlap constraints: r_i + r_j <= d_ij\n    # 2. Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    A_overlap = np.zeros((num_overlap, N))\n    for k, (i, j) in enumerate(overlap_pairs):\n        A_overlap[k, i] = 1\n        A_overlap[k, j] = 1\n    \n    A_boundary = np.eye(N)\n    # Total A_ub shape: (num_overlap + 4*N, N) = (325 + 104, 26) = (429, 26)\n    A_ub = np.vstack([A_overlap, A_boundary, A_boundary, A_boundary, A_boundary])\n    \n    def get_sum_radii_and_grad(centers_flat):\n        \"\"\"\n        Calculates the maximum sum of radii for given center positions and its gradient.\n        \"\"\"\n        centers = centers_flat.reshape((N, 2))\n        x, y = centers[:, 0], centers[:, 1]\n        \n        # Calculate distances between centers for non-overlap bounds\n        dx = x[overlap_pairs[:, 0]] - x[overlap_pairs[:, 1]]\n        dy = y[overlap_pairs[:, 0]] - y[overlap_pairs[:, 1]]\n        # Small epsilon to prevent division by zero in gradient calculations\n        d_ij = np.sqrt(dx**2 + dy**2 + 1e-12)\n        \n        # Upper bounds for radii (overlap and boundary)\n        b_ub = np.concatenate([d_ij, x, 1.0 - x, y, 1.0 - y])\n        \n        # Solve LP using the fast HiGHS solver\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, method='highs', options={'presolve': True})\n        \n        if not res.success:\n            return 0.0, np.zeros(2 * N)\n        \n        # sum_radii = -res.fun (since objective was -sum(r))\n        sum_radii = -res.fun\n        lambdas = res.ineqlin.marginals # Dual variables (Lagrange multipliers)\n        \n        # Gradient calculation using dual variables:\n        # The sensitivity of the optimal sum to a bound b_k is exactly the dual variable lambda_k.\n        lam_overlap = lambdas[:num_overlap]\n        lam_x1 = lambdas[num_overlap : num_overlap + N]\n        lam_x2 = lambdas[num_overlap + N : num_overlap + 2 * N]\n        lam_y1 = lambdas[num_overlap + 2 * N : num_overlap + 3 * N]\n        lam_y2 = lambdas[num_overlap + 3 * N : num_overlap + 4 * N]\n        \n        grad_x = np.zeros(N)\n        grad_y = np.zeros(N)\n        \n        # Gradient contribution from distance constraints: lambda_ij * d(d_ij)/dx\n        term_x = lam_overlap * dx / d_ij\n        term_y = lam_overlap * dy / d_ij\n        \n        np.add.at(grad_x, overlap_pairs[:, 0], term_x)\n        np.subtract.at(grad_x, overlap_pairs[:, 1], term_x)\n        np.add.at(grad_y, overlap_pairs[:, 0], term_y)\n        np.subtract.at(grad_y, overlap_pairs[:, 1], term_y)\n        \n        # Gradient contribution from boundary constraints\n        grad_x += lam_x1 - lam_x2\n        grad_y += lam_y1 - lam_y2\n        \n        # Return negative values for minimization\n        return -sum_radii, -np.concatenate([grad_x, grad_y])\n\n    best_sum = 0\n    best_centers = None\n    start_time = time.time()\n    \n    # 1. Strategic Initial Guesses (Grids)\n    grids = [(5, 5), (4, 6), (2, 13)]\n    for rows, cols in grids:\n        if time.time() - start_time > 280: break\n        \n        x_grid = np.linspace(0.1, 0.9, cols)\n        y_grid = np.linspace(0.1, 0.9, rows)\n        xv, yv = np.meshgrid(x_grid, y_grid)\n        x_init, y_init = xv.flatten(), yv.flatten()\n        \n        # Adjust size to exactly N\n        if len(x_init) < N:\n            x_init = np.append(x_init, np.random.uniform(0.1, 0.9, N - len(x_init)))\n            y_init = np.append(y_init, np.random.uniform(0.1, 0.9, N - len(y_init)))\n        else:\n            x_init, y_init = x_init[:N], y_init[:N]\n            \n        params_init = np.concatenate([x_init, y_init]) + np.random.normal(0, 0.01, 2 * N)\n        params_init = np.clip(params_init, 0, 1)\n        \n        res = minimize(get_sum_radii_and_grad, params_init, method='L-BFGS-B', \n                       jac=True, bounds=[(0, 1)] * (2 * N))\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = res.x\n\n    # 2. Random Restarts to explore other basins\n    while time.time() - start_time < 260:\n        params_init = np.random.uniform(0.1, 0.9, 2 * N)\n        res = minimize(get_sum_radii_and_grad, params_init, method='L-BFGS-B', \n                       jac=True, bounds=[(0, 1)] * (2 * N))\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = res.x\n\n    # If no optimization finished successfully, use a random fallback\n    if best_centers is None:\n        best_centers = np.random.uniform(0.1, 0.9, 2 * N)\n\n    # Final Radii Calculation for the best centers found\n    centers = best_centers.reshape((N, 2))\n    x, y = centers[:, 0], centers[:, 1]\n    dx = x[overlap_pairs[:, 0]] - x[overlap_pairs[:, 1]]\n    dy = y[overlap_pairs[:, 0]] - y[overlap_pairs[:, 1]]\n    d_ij = np.sqrt(dx**2 + dy**2 + 1e-12)\n    b_ub = np.concatenate([d_ij, x, 1.0 - x, y, 1.0 - y])\n    res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, method='highs')\n    radii = res.x\n    sum_radii = -res.fun\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:52:03.723768",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 2124,
        "candidates_token_count": 2117,
        "thoughts_token_count": 19448
      },
      "response_text_len": 6045
    }
  },
  "llm_call_duration_s": 126.22386664105579,
  "eval_duration_s": 260.5516519959783
}