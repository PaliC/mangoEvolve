{
  "trial_id": "trial_9_5",
  "generation": 9,
  "parent_id": "trial_6_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start strategy with buckled grid initializations and SLSQP optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    np.random.seed(42)\n\n    # Objective: Maximize sum of radii -> Minimize -sum(radii)\n    def objective(vars):\n        return -np.sum(vars[2*N:3*N])\n\n    def objective_jac(vars):\n        jac = np.zeros(3*N)\n        jac[2*N:3*N] = -1.0\n        return jac\n\n    # Pre-calculated indices for distance constraints\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_dist = len(idx_i)\n\n    def constraints(vars):\n        x = vars[0:N]\n        y = vars[N:2*N]\n        r = vars[2*N:3*N]\n        \n        # Boundary constraints: circles must stay within [0, 1] x [0, 1]\n        c = np.empty(4*N + num_dist)\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        \n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        c[4*N:] = np.sqrt(dx*dx + dy*dy) - (r[idx_i] + r[idx_j])\n        return c\n\n    def constraints_jac(vars):\n        x = vars[0:N]\n        y = vars[N:2*N]\n        r = vars[2*N:3*N]\n        jac = np.zeros((4 * N + num_dist, 3 * N))\n        \n        # Jacobian for boundary constraints\n        # Rows 0 to N-1: x_i - r_i >= 0\n        jac[np.arange(N), np.arange(N)] = 1.0\n        jac[np.arange(N), 2*N + np.arange(N)] = -1.0\n        # Rows N to 2N-1: 1 - x_i - r_i >= 0\n        jac[N + np.arange(N), np.arange(N)] = -1.0\n        jac[N + np.arange(N), 2*N + np.arange(N)] = -1.0\n        # Rows 2N to 3N-1: y_i - r_i >= 0\n        jac[2*N + np.arange(N), N + np.arange(N)] = 1.0\n        jac[2*N + np.arange(N), 2*N + np.arange(N)] = -1.0\n        # Rows 3N to 4N-1: 1 - y_i - r_i >= 0\n        jac[3*N + np.arange(N), N + np.arange(N)] = -1.0\n        jac[3*N + np.arange(N), 2*N + np.arange(N)] = -1.0\n        \n        # Jacobian for non-overlap constraints\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        d = np.sqrt(dx*dx + dy*dy)\n        d[d < 1e-9] = 1e-9  # Avoid division by zero\n        inv_d = 1.0 / d\n        \n        row_idx = np.arange(num_dist) + 4 * N\n        jac[row_idx, idx_i] = dx * inv_d\n        jac[row_idx, idx_j] = -dx * inv_d\n        jac[row_idx, N + idx_i] = dy * inv_d\n        jac[row_idx, N + idx_j] = -dy * inv_d\n        jac[row_idx, 2*N + idx_i] = -1.0\n        jac[row_idx, 2*N + idx_j] = -1.0\n        return jac\n\n    def get_buckled_grid(nx, ny, offset):\n        \"\"\"Generates an initial configuration based on a shifted grid.\"\"\"\n        extra = N - nx * ny\n        x_b = []\n        y_b = []\n        for i in range(nx):\n            for j in range(ny):\n                x_b.append((i + 0.5) / nx)\n                y_b.append((j + 0.5) / ny + (offset if i % 2 == 0 else -offset))\n        for _ in range(extra):\n            x_b.append(np.random.rand())\n            y_b.append(np.random.rand())\n        \n        x_b = np.array(x_b) + np.random.normal(0, 0.01, N)\n        y_b = np.array(y_b) + np.random.normal(0, 0.01, N)\n        x_b = np.clip(x_b, 0.05, 0.95)\n        y_b = np.clip(y_b, 0.05, 0.95)\n        r_b = np.full(N, 0.03)\n        return np.concatenate([x_b, y_b, r_b])\n\n    # 1. Generate multi-start initial configurations\n    configs = []\n    # Buckled grid variations\n    for offset in [0, 0.01, 0.02, 0.03, 0.05]:\n        configs.append(get_buckled_grid(5, 5, offset))\n        configs.append(get_buckled_grid(6, 4, offset))\n        configs.append(get_buckled_grid(4, 6, offset))\n    # Random variations\n    for _ in range(5):\n        configs.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.full(N, 0.03)]))\n\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n    results = []\n\n    # 2. First pass: Fast SLSQP search for local optima\n    for conf in configs:\n        if time.time() - start_time > 220:\n            break\n        res = minimize(objective, conf, jac=objective_jac, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                       bounds=bounds, options={'maxiter': 100, 'ftol': 1e-7})\n        if not np.isnan(res.fun):\n            results.append(res)\n    \n    if not results:\n        return None, None, 0\n\n    # 3. Final Squeeze: Refine the best results with high precision\n    results.sort(key=lambda r: r.fun)\n    best_res = results[0]\n    for i in range(min(3, len(results))):\n        if time.time() - start_time > 280:\n            break\n        res = minimize(objective, results[i].x, jac=objective_jac, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                       bounds=bounds, options={'maxiter': 1000, 'ftol': 1e-15})\n        if res.fun < best_res.fun:\n            best_res = res\n    \n    # 4. Format and return results\n    final_vars = best_res.x\n    centers = np.stack([final_vars[0:N], final_vars[N:2*N]], axis=1)\n    radii = final_vars[2*N:3*N]\n    sum_radii = -best_res.fun\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.628553897704184,
    "eval_time": 1.6610643863677979,
    "error": null
  },
  "prompt": "Try a 'Multi-start Buckled Grid' approach.\n        \n        Strategy:\n        1. The best known solution (2.635985) is likely a 'buckled' 5x5 grid.\n        2. Generate 50 different 'buckled' initializations by taking a 5x5 grid + 1 circle and applying random row/column shifts (staggering).\n        3. Run a fast SLSQP on each to find promising basins.\n        4. For the top 3 results, perform the 'Final Squeeze' (iterative SLSQP with ftol=1e-15).\n        5. This explores whether trial_6_4 is in the best possible basin or if a slightly different staggering is superior.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start strategy with buckled grid initializations and SLSQP optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    np.random.seed(42)\n\n    # Objective: Maximize sum of radii -> Minimize -sum(radii)\n    def objective(vars):\n        return -np.sum(vars[2*N:3*N])\n\n    def objective_jac(vars):\n        jac = np.zeros(3*N)\n        jac[2*N:3*N] = -1.0\n        return jac\n\n    # Pre-calculated indices for distance constraints\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_dist = len(idx_i)\n\n    def constraints(vars):\n        x = vars[0:N]\n        y = vars[N:2*N]\n        r = vars[2*N:3*N]\n        \n        # Boundary constraints: circles must stay within [0, 1] x [0, 1]\n        c = np.empty(4*N + num_dist)\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        \n        # Non-overlap constraints: dist(i, j) >= r_i + r_j\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        c[4*N:] = np.sqrt(dx*dx + dy*dy) - (r[idx_i] + r[idx_j])\n        return c\n\n    def constraints_jac(vars):\n        x = vars[0:N]\n        y = vars[N:2*N]\n        r = vars[2*N:3*N]\n        jac = np.zeros((4 * N + num_dist, 3 * N))\n        \n        # Jacobian for boundary constraints\n        # Rows 0 to N-1: x_i - r_i >= 0\n        jac[np.arange(N), np.arange(N)] = 1.0\n        jac[np.arange(N), 2*N + np.arange(N)] = -1.0\n        # Rows N to 2N-1: 1 - x_i - r_i >= 0\n        jac[N + np.arange(N), np.arange(N)] = -1.0\n        jac[N + np.arange(N), 2*N + np.arange(N)] = -1.0\n        # Rows 2N to 3N-1: y_i - r_i >= 0\n        jac[2*N + np.arange(N), N + np.arange(N)] = 1.0\n        jac[2*N + np.arange(N), 2*N + np.arange(N)] = -1.0\n        # Rows 3N to 4N-1: 1 - y_i - r_i >= 0\n        jac[3*N + np.arange(N), N + np.arange(N)] = -1.0\n        jac[3*N + np.arange(N), 2*N + np.arange(N)] = -1.0\n        \n        # Jacobian for non-overlap constraints\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        d = np.sqrt(dx*dx + dy*dy)\n        d[d < 1e-9] = 1e-9  # Avoid division by zero\n        inv_d = 1.0 / d\n        \n        row_idx = np.arange(num_dist) + 4 * N\n        jac[row_idx, idx_i] = dx * inv_d\n        jac[row_idx, idx_j] = -dx * inv_d\n        jac[row_idx, N + idx_i] = dy * inv_d\n        jac[row_idx, N + idx_j] = -dy * inv_d\n        jac[row_idx, 2*N + idx_i] = -1.0\n        jac[row_idx, 2*N + idx_j] = -1.0\n        return jac\n\n    def get_buckled_grid(nx, ny, offset):\n        \"\"\"Generates an initial configuration based on a shifted grid.\"\"\"\n        extra = N - nx * ny\n        x_b = []\n        y_b = []\n        for i in range(nx):\n            for j in range(ny):\n                x_b.append((i + 0.5) / nx)\n                y_b.append((j + 0.5) / ny + (offset if i % 2 == 0 else -offset))\n        for _ in range(extra):\n            x_b.append(np.random.rand())\n            y_b.append(np.random.rand())\n        \n        x_b = np.array(x_b) + np.random.normal(0, 0.01, N)\n        y_b = np.array(y_b) + np.random.normal(0, 0.01, N)\n        x_b = np.clip(x_b, 0.05, 0.95)\n        y_b = np.clip(y_b, 0.05, 0.95)\n        r_b = np.full(N, 0.03)\n        return np.concatenate([x_b, y_b, r_b])\n\n    # 1. Generate multi-start initial configurations\n    configs = []\n    # Buckled grid variations\n    for offset in [0, 0.01, 0.02, 0.03, 0.05]:\n        configs.append(get_buckled_grid(5, 5, offset))\n        configs.append(get_buckled_grid(6, 4, offset))\n        configs.append(get_buckled_grid(4, 6, offset))\n    # Random variations\n    for _ in range(5):\n        configs.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.full(N, 0.03)]))\n\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n    results = []\n\n    # 2. First pass: Fast SLSQP search for local optima\n    for conf in configs:\n        if time.time() - start_time > 220:\n            break\n        res = minimize(objective, conf, jac=objective_jac, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                       bounds=bounds, options={'maxiter': 100, 'ftol': 1e-7})\n        if not np.isnan(res.fun):\n            results.append(res)\n    \n    if not results:\n        return None, None, 0\n\n    # 3. Final Squeeze: Refine the best results with high precision\n    results.sort(key=lambda r: r.fun)\n    best_res = results[0]\n    for i in range(min(3, len(results))):\n        if time.time() - start_time > 280:\n            break\n        res = minimize(objective, results[i].x, jac=objective_jac, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                       bounds=bounds, options={'maxiter': 1000, 'ftol': 1e-15})\n        if res.fun < best_res.fun:\n            best_res = res\n    \n    # 4. Format and return results\n    final_vars = best_res.x\n    centers = np.stack([final_vars[0:N], final_vars[N:2*N]], axis=1)\n    radii = final_vars[2*N:3*N]\n    sum_radii = -best_res.fun\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:12:11.826611",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 392,
        "candidates_token_count": 2049,
        "thoughts_token_count": 22548
      },
      "response_text_len": 5241
    }
  },
  "llm_call_duration_s": 136.02737820404582,
  "eval_duration_s": 1.6610744829522446
}