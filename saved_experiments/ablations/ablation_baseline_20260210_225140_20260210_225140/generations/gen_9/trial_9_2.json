{
  "trial_id": "trial_9_2",
  "generation": 9,
  "parent_id": "trial_6_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Implements a 'Targeted Rattle' strategy on high-quality initial configurations.\n    \"\"\"\n    N = 26\n    np.random.seed(42)\n    \n    def solve(x_in, y_in, r_in):\n        \"\"\"Helper to run high-precision SLSQP optimization.\"\"\"\n        def objective(vars):\n            # Maximize sum of radii\n            return -np.sum(vars[2*N:])\n        \n        def constraints(vars):\n            xc, yc, rc = vars[:N], vars[N:2*N], vars[2*N:]\n            # 4 constraints per circle (walls) + N(N-1)/2 constraints (overlaps)\n            c = np.zeros(4*N + N*(N-1)//2)\n            c[:N] = xc - rc\n            c[N:2*N] = 1.0 - xc - rc\n            c[2*N:3*N] = yc - rc\n            c[3*N:4*N] = 1.0 - yc - rc\n            idx = 4*N\n            for i in range(N):\n                # Vectorized distance constraints\n                d_sq = (xc[i] - xc[i+1:])**2 + (yc[i] - yc[i+1:])**2\n                c[idx:idx+N-1-i] = np.sqrt(d_sq + 1e-12) - (rc[i] + rc[i+1:])\n                idx += N-1-i\n            return c\n\n        # Constraints on x, y, and r\n        bounds = [(0, 1)] * (2 * N) + [(0.01, 0.5)] * N\n        init_vars = np.concatenate([x_in, y_in, r_in])\n        \n        res = minimize(\n            objective, \n            init_vars, \n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=bounds,\n            options={'ftol': 1e-14, 'maxiter': 500}\n        )\n        return res\n\n    # 1. Generate candidate layouts focusing on the '26th circle' problem\n    layouts = []\n    \n    # Layout A: 5-5-6-5-5 columns (6 circles in the middle column)\n    x1, y1 = [], []\n    for i in [0, 1, 3, 4]:\n        for j in range(5):\n            x1.append(0.1 + 0.2*i)\n            y1.append(0.1 + 0.2*j)\n    for j in range(6):\n        x1.append(0.5)\n        y1.append(0.08 + 0.168*j)\n    layouts.append((np.array(x1), np.array(y1)))\n    \n    # Layout B: 5-5-6-5-5 rows (6 circles in the middle row)\n    x2, y2 = [], []\n    for j in [0, 1, 3, 4]:\n        for i in range(5):\n            x2.append(0.1 + 0.2*i)\n            y2.append(0.1 + 0.2*j)\n    for i in range(6):\n        y2.append(0.5)\n        x2.append(0.08 + 0.168*i)\n    layouts.append((np.array(x2), np.array(y2)))\n    \n    # Layout C: Standard 5x5 grid + 1 circle in the middle\n    x3, y3 = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    x3, y3 = x3.flatten(), y3.flatten()\n    x3 = np.append(x3, 0.5)\n    y3 = np.append(y3, 0.5)\n    layouts.append((x3, y3))\n\n    # Initialize best configuration\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # 2. Iterate through layouts and apply the Targeted Rattle strategy\n    for x_init, y_init in layouts:\n        # Initial jitter to break symmetry\n        x_init = x_init + np.random.normal(0, 0.001, N)\n        y_init = y_init + np.random.normal(0, 0.001, N)\n        r_init = np.ones(N) * 0.095\n        \n        res = solve(x_init, y_init, r_init)\n        \n        # Track best solution found so far\n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = res.x[:2*N].reshape(2, N).T\n            best_radii = res.x[2*N:]\n        \n        # Apply Targeted Rattle (multiple iterations)\n        for _ in range(2):\n            xc, yc, rc = res.x[:N], res.x[N:2*N], res.x[2*N:]\n            \n            # Identify 'loose' circles (fewer than 3 contacts)\n            contacts = np.zeros(N)\n            for i in range(N):\n                # Wall contacts\n                if xc[i] - rc[i] < 1e-4: contacts[i] += 1\n                if 1.0 - xc[i] - rc[i] < 1e-4: contacts[i] += 1\n                if yc[i] - rc[i] < 1e-4: contacts[i] += 1\n                if 1.0 - yc[i] - rc[i] < 1e-4: contacts[i] += 1\n                # Circle-circle contacts\n                d_sq = (xc[i] - xc)**2 + (yc[i] - yc)**2\n                # Exclude self (d_sq > 1e-12) and check proximity\n                contacts[i] += np.sum((d_sq > 1e-12) & (d_sq < (rc[i] + rc + 1e-4)**2))\n            \n            # Apply perturbations based on locking state\n            x_rat, y_rat = xc.copy(), yc.copy()\n            for i in range(N):\n                sigma = 1e-3 if contacts[i] < 3 else 1e-7\n                x_rat[i] += np.random.normal(0, sigma)\n                y_rat[i] += np.random.normal(0, sigma)\n                # Ensure rattle doesn't push centers outside valid bounds\n                x_rat[i] = np.clip(x_rat[i], rc[i], 1.0 - rc[i])\n                y_rat[i] = np.clip(y_rat[i], rc[i], 1.0 - rc[i])\n            \n            # Re-optimize from rattled configuration\n            res = solve(x_rat, y_rat, rc)\n            if -res.fun > best_sum:\n                best_sum = -res.fun\n                best_centers = res.x[:2*N].reshape(2, N).T\n                best_radii = res.x[2*N:]\n                \n    return best_centers, best_radii, float(best_sum)",
  "metrics": {
    "valid": true,
    "score": 2.624821772095873,
    "eval_time": 2.1021640300750732,
    "error": null
  },
  "prompt": "Implement a 'Targeted Rattle' strategy on trial_6_4 (score=2.6359830849359622).\n        \n        Strategy:\n        1. Identify 'loose' circles (those with fewer than 3 contacts).\n        2. Apply a larger perturbation to loose circles (sigma=1e-3) and a tiny perturbation to 'locked' circles (sigma=1e-7).\n        3. Run a high-precision SLSQP (ftol=1e-14) on the rattled configuration.\n        4. If the score improves, update the best configuration.\n        5. Focus on the '26th circle' problem\u2014try to find if moving one specific circle to a different gap in the 5x5 grid yields a better basin.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Implements a 'Targeted Rattle' strategy on high-quality initial configurations.\n    \"\"\"\n    N = 26\n    np.random.seed(42)\n    \n    def solve(x_in, y_in, r_in):\n        \"\"\"Helper to run high-precision SLSQP optimization.\"\"\"\n        def objective(vars):\n            # Maximize sum of radii\n            return -np.sum(vars[2*N:])\n        \n        def constraints(vars):\n            xc, yc, rc = vars[:N], vars[N:2*N], vars[2*N:]\n            # 4 constraints per circle (walls) + N(N-1)/2 constraints (overlaps)\n            c = np.zeros(4*N + N*(N-1)//2)\n            c[:N] = xc - rc\n            c[N:2*N] = 1.0 - xc - rc\n            c[2*N:3*N] = yc - rc\n            c[3*N:4*N] = 1.0 - yc - rc\n            idx = 4*N\n            for i in range(N):\n                # Vectorized distance constraints\n                d_sq = (xc[i] - xc[i+1:])**2 + (yc[i] - yc[i+1:])**2\n                c[idx:idx+N-1-i] = np.sqrt(d_sq + 1e-12) - (rc[i] + rc[i+1:])\n                idx += N-1-i\n            return c\n\n        # Constraints on x, y, and r\n        bounds = [(0, 1)] * (2 * N) + [(0.01, 0.5)] * N\n        init_vars = np.concatenate([x_in, y_in, r_in])\n        \n        res = minimize(\n            objective, \n            init_vars, \n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=bounds,\n            options={'ftol': 1e-14, 'maxiter': 500}\n        )\n        return res\n\n    # 1. Generate candidate layouts focusing on the '26th circle' problem\n    layouts = []\n    \n    # Layout A: 5-5-6-5-5 columns (6 circles in the middle column)\n    x1, y1 = [], []\n    for i in [0, 1, 3, 4]:\n        for j in range(5):\n            x1.append(0.1 + 0.2*i)\n            y1.append(0.1 + 0.2*j)\n    for j in range(6):\n        x1.append(0.5)\n        y1.append(0.08 + 0.168*j)\n    layouts.append((np.array(x1), np.array(y1)))\n    \n    # Layout B: 5-5-6-5-5 rows (6 circles in the middle row)\n    x2, y2 = [], []\n    for j in [0, 1, 3, 4]:\n        for i in range(5):\n            x2.append(0.1 + 0.2*i)\n            y2.append(0.1 + 0.2*j)\n    for i in range(6):\n        y2.append(0.5)\n        x2.append(0.08 + 0.168*i)\n    layouts.append((np.array(x2), np.array(y2)))\n    \n    # Layout C: Standard 5x5 grid + 1 circle in the middle\n    x3, y3 = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    x3, y3 = x3.flatten(), y3.flatten()\n    x3 = np.append(x3, 0.5)\n    y3 = np.append(y3, 0.5)\n    layouts.append((x3, y3))\n\n    # Initialize best configuration\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # 2. Iterate through layouts and apply the Targeted Rattle strategy\n    for x_init, y_init in layouts:\n        # Initial jitter to break symmetry\n        x_init = x_init + np.random.normal(0, 0.001, N)\n        y_init = y_init + np.random.normal(0, 0.001, N)\n        r_init = np.ones(N) * 0.095\n        \n        res = solve(x_init, y_init, r_init)\n        \n        # Track best solution found so far\n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = res.x[:2*N].reshape(2, N).T\n            best_radii = res.x[2*N:]\n        \n        # Apply Targeted Rattle (multiple iterations)\n        for _ in range(2):\n            xc, yc, rc = res.x[:N], res.x[N:2*N], res.x[2*N:]\n            \n            # Identify 'loose' circles (fewer than 3 contacts)\n            contacts = np.zeros(N)\n            for i in range(N):\n                # Wall contacts\n                if xc[i] - rc[i] < 1e-4: contacts[i] += 1\n                if 1.0 - xc[i] - rc[i] < 1e-4: contacts[i] += 1\n                if yc[i] - rc[i] < 1e-4: contacts[i] += 1\n                if 1.0 - yc[i] - rc[i] < 1e-4: contacts[i] += 1\n                # Circle-circle contacts\n                d_sq = (xc[i] - xc)**2 + (yc[i] - yc)**2\n                # Exclude self (d_sq > 1e-12) and check proximity\n                contacts[i] += np.sum((d_sq > 1e-12) & (d_sq < (rc[i] + rc + 1e-4)**2))\n            \n            # Apply perturbations based on locking state\n            x_rat, y_rat = xc.copy(), yc.copy()\n            for i in range(N):\n                sigma = 1e-3 if contacts[i] < 3 else 1e-7\n                x_rat[i] += np.random.normal(0, sigma)\n                y_rat[i] += np.random.normal(0, sigma)\n                # Ensure rattle doesn't push centers outside valid bounds\n                x_rat[i] = np.clip(x_rat[i], rc[i], 1.0 - rc[i])\n                y_rat[i] = np.clip(y_rat[i], rc[i], 1.0 - rc[i])\n            \n            # Re-optimize from rattled configuration\n            res = solve(x_rat, y_rat, rc)\n            if -res.fun > best_sum:\n                best_sum = -res.fun\n                best_centers = res.x[:2*N].reshape(2, N).T\n                best_radii = res.x[2*N:]\n                \n    return best_centers, best_radii, float(best_sum)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:12:26.306657",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 404,
        "candidates_token_count": 1854,
        "thoughts_token_count": 25331
      },
      "response_text_len": 5037
    }
  },
  "llm_call_duration_s": 150.0617082050303,
  "eval_duration_s": 2.102171803941019
}