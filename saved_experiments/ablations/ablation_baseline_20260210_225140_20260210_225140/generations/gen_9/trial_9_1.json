{
  "trial_id": "trial_9_1",
  "generation": 9,
  "parent_id": "trial_6_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid SLSQP and Linear Programming (LP) approach to optimize centers and radii.\n    \"\"\"\n    n = 26\n    iu = np.triu_indices(n, k=1)\n\n    def solve_lp_radii(centers):\n        \"\"\"Maximize the sum of radii for fixed circle centers using LP.\"\"\"\n        c = -np.ones(n)\n        # 4 boundary constraints per circle + n*(n-1)/2 overlap constraints\n        num_constraints = 4 * n + n * (n - 1) // 2\n        A_ub = np.zeros((num_constraints, n))\n        b_ub = np.zeros(num_constraints)\n        \n        # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        for i in range(n):\n            A_ub[4 * i, i] = 1\n            b_ub[4 * i] = centers[i, 0]\n            A_ub[4 * i + 1, i] = 1\n            b_ub[4 * i + 1] = 1 - centers[i, 0]\n            A_ub[4 * i + 2, i] = 1\n            b_ub[4 * i + 2] = centers[i, 1]\n            A_ub[4 * i + 3, i] = 1\n            b_ub[4 * i + 3] = 1 - centers[i, 1]\n            \n        # Overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        curr = 4 * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                A_ub[curr, i] = 1\n                A_ub[curr, j] = 1\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                b_ub[curr] = dist\n                curr += 1\n                \n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=(0, 0.5), method='highs')\n            if res.success:\n                return res.x\n        except:\n            pass\n        return None\n\n    def objective(params):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        return -np.sum(params[2::3])\n\n    def constraints_func(params):\n        \"\"\"Vectorized boundary and overlap constraints for SLSQP.\"\"\"\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        # Boundary: r_i <= x_i, r_i <= 1-x_i, etc.\n        b = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        # Overlap: dist(c_i, c_j) - (r_i + r_j) >= 0\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        o = (dist - r_sum)[iu]\n        return np.concatenate([b, o])\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    start_time = time.time()\n    \n    # Generate initial seeds\n    seeds = []\n    \n    # Seed 1: 5x5 grid + 1 circle\n    centers_5x5 = []\n    for i in range(5):\n        for j in range(5):\n            centers_5x5.append([0.1 + 0.2 * i, 0.1 + 0.2 * j])\n    centers_5x5.append([0.5, 0.5])\n    seeds.append(np.array(centers_5x5))\n    \n    # Seed 2: Slightly shifted 5x5 grid\n    centers_shifted = np.array(centers_5x5)\n    centers_shifted[-1] = [0.01, 0.01]\n    seeds.append(centers_shifted)\n\n    # Seed 3: Randomized grids\n    for _ in range(2):\n        seeds.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    # Main optimization loop\n    for base_centers in seeds:\n        if time.time() - start_time > 280:\n            break\n            \n        centers = base_centers.copy()\n        radii = solve_lp_radii(centers)\n        if radii is None:\n            radii = np.ones(n) * 0.05\n            \n        params = np.zeros(3 * n)\n        params[0::3], params[1::3], params[2::3] = centers[:, 0], centers[:, 1], radii\n        \n        # Bilevel optimization: SLSQP to move centers, LP to maximize radii\n        for cycle in range(12):\n            if time.time() - start_time > 280:\n                break\n                \n            res = minimize(objective, params, method='SLSQP', \n                           constraints={'type': 'ineq', 'fun': constraints_func},\n                           options={'maxiter': 80, 'ftol': 1e-9})\n            params = res.x\n            \n            # LP refinement for fixed centers\n            current_centers = np.stack([params[0::3], params[1::3]], axis=1)\n            new_radii = solve_lp_radii(current_centers)\n            if new_radii is not None:\n                params[2::3] = new_radii\n            \n            # Update best solution found\n            curr_sum = np.sum(params[2::3])\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_centers = current_centers.copy()\n                best_radii = params[2::3].copy()\n                \n            # If SLSQP converges, add a tiny perturbation to centers and continue\n            if res.success:\n                params[0::3] += np.random.normal(0, 0.001, n)\n                params[1::3] += np.random.normal(0, 0.001, n)\n\n    # Final polish of the best found centers\n    if best_centers is not None:\n        best_radii = solve_lp_radii(best_centers)\n        best_sum = np.sum(best_radii)\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.604682222682873,
    "eval_time": 1.908677339553833,
    "error": null
  },
  "prompt": "Refine trial_6_4 (score=2.6359830849359622) by integrating Linear Programming (LP) for radii.\n        \n        Strategy:\n        1. Use SLSQP to optimize (x, y, r) simultaneously as a 'global' step.\n        2. Every 10 iterations or after SLSQP converges, use scipy.optimize.linprog (method='highs') to find the mathematically optimal radii for the current fixed centers.\n        3. Replace the current radii with the LP-optimized radii and restart SLSQP.\n        4. This 'Bilevel' approach ensures that for any set of centers found by SLSQP, the radii are maximized to their theoretical limit.\n        5. Use the configuration from trial_6_4 as the seed.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid SLSQP and Linear Programming (LP) approach to optimize centers and radii.\n    \"\"\"\n    n = 26\n    iu = np.triu_indices(n, k=1)\n\n    def solve_lp_radii(centers):\n        \"\"\"Maximize the sum of radii for fixed circle centers using LP.\"\"\"\n        c = -np.ones(n)\n        # 4 boundary constraints per circle + n*(n-1)/2 overlap constraints\n        num_constraints = 4 * n + n * (n - 1) // 2\n        A_ub = np.zeros((num_constraints, n))\n        b_ub = np.zeros(num_constraints)\n        \n        # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        for i in range(n):\n            A_ub[4 * i, i] = 1\n            b_ub[4 * i] = centers[i, 0]\n            A_ub[4 * i + 1, i] = 1\n            b_ub[4 * i + 1] = 1 - centers[i, 0]\n            A_ub[4 * i + 2, i] = 1\n            b_ub[4 * i + 2] = centers[i, 1]\n            A_ub[4 * i + 3, i] = 1\n            b_ub[4 * i + 3] = 1 - centers[i, 1]\n            \n        # Overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        curr = 4 * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                A_ub[curr, i] = 1\n                A_ub[curr, j] = 1\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                b_ub[curr] = dist\n                curr += 1\n                \n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=(0, 0.5), method='highs')\n            if res.success:\n                return res.x\n        except:\n            pass\n        return None\n\n    def objective(params):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        return -np.sum(params[2::3])\n\n    def constraints_func(params):\n        \"\"\"Vectorized boundary and overlap constraints for SLSQP.\"\"\"\n        x, y, r = params[0::3], params[1::3], params[2::3]\n        # Boundary: r_i <= x_i, r_i <= 1-x_i, etc.\n        b = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        # Overlap: dist(c_i, c_j) - (r_i + r_j) >= 0\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        r_sum = r[:, None] + r[None, :]\n        o = (dist - r_sum)[iu]\n        return np.concatenate([b, o])\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    start_time = time.time()\n    \n    # Generate initial seeds\n    seeds = []\n    \n    # Seed 1: 5x5 grid + 1 circle\n    centers_5x5 = []\n    for i in range(5):\n        for j in range(5):\n            centers_5x5.append([0.1 + 0.2 * i, 0.1 + 0.2 * j])\n    centers_5x5.append([0.5, 0.5])\n    seeds.append(np.array(centers_5x5))\n    \n    # Seed 2: Slightly shifted 5x5 grid\n    centers_shifted = np.array(centers_5x5)\n    centers_shifted[-1] = [0.01, 0.01]\n    seeds.append(centers_shifted)\n\n    # Seed 3: Randomized grids\n    for _ in range(2):\n        seeds.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    # Main optimization loop\n    for base_centers in seeds:\n        if time.time() - start_time > 280:\n            break\n            \n        centers = base_centers.copy()\n        radii = solve_lp_radii(centers)\n        if radii is None:\n            radii = np.ones(n) * 0.05\n            \n        params = np.zeros(3 * n)\n        params[0::3], params[1::3], params[2::3] = centers[:, 0], centers[:, 1], radii\n        \n        # Bilevel optimization: SLSQP to move centers, LP to maximize radii\n        for cycle in range(12):\n            if time.time() - start_time > 280:\n                break\n                \n            res = minimize(objective, params, method='SLSQP', \n                           constraints={'type': 'ineq', 'fun': constraints_func},\n                           options={'maxiter': 80, 'ftol': 1e-9})\n            params = res.x\n            \n            # LP refinement for fixed centers\n            current_centers = np.stack([params[0::3], params[1::3]], axis=1)\n            new_radii = solve_lp_radii(current_centers)\n            if new_radii is not None:\n                params[2::3] = new_radii\n            \n            # Update best solution found\n            curr_sum = np.sum(params[2::3])\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_centers = current_centers.copy()\n                best_radii = params[2::3].copy()\n                \n            # If SLSQP converges, add a tiny perturbation to centers and continue\n            if res.success:\n                params[0::3] += np.random.normal(0, 0.001, n)\n                params[1::3] += np.random.normal(0, 0.001, n)\n\n    # Final polish of the best found centers\n    if best_centers is not None:\n        best_radii = solve_lp_radii(best_centers)\n        best_sum = np.sum(best_radii)\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:11:54.237102",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 404,
        "candidates_token_count": 1682,
        "thoughts_token_count": 19887
      },
      "response_text_len": 4914
    }
  },
  "llm_call_duration_s": 118.19423736201134,
  "eval_duration_s": 1.9086864440469071
}