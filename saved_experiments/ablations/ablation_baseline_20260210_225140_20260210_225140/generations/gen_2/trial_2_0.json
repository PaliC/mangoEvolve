{
  "trial_id": "trial_2_0",
  "generation": 2,
  "parent_id": "trial_1_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Constraints: circles must be entirely inside the square, no overlaps, and radii >= 0.\n    \"\"\"\n    n = 26\n    \n    def solve_lp(centers):\n        \"\"\"\n        Solves a linear programming problem to find the optimal radii for a fixed set of centers.\n        \"\"\"\n        n_circles = centers.shape[0]\n        # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n        c_lp = -np.ones(n_circles)\n        \n        A_ub = []\n        b_ub = []\n        \n        # Overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                row = np.zeros(n_circles)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        bounds_lp = []\n        for i in range(n_circles):\n            xi, yi = centers[i]\n            max_r = min(xi, 1-xi, yi, 1-yi)\n            bounds_lp.append((0, max(0.0, max_r)))\n        \n        # Using the Highs method for efficiency if available\n        try:\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n            if res.success:\n                return res.x, -res.fun\n        except:\n            try:\n                # Fallback to default method\n                res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp)\n                if res.success:\n                    return res.x, -res.fun\n            except:\n                pass\n        return np.zeros(n_circles), 0.0\n\n    def objective(vars):\n        return -np.sum(vars[2*n:])\n\n    def jac_objective(vars):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    def constraints_fn(vars):\n        centers = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        \n        # Overlap constraints: dist^2 - (r_i + r_j)^2 >= 0\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        r_sum_sq = r_sum**2\n        indices = np.triu_indices(n, k=1)\n        overlap_cons = dist_sq[indices] - r_sum_sq[indices]\n        \n        # Boundary constraints: x_i - r_i >= 0, etc.\n        boundary_cons = np.zeros(4*n)\n        boundary_cons[0::4] = centers[:, 0] - radii\n        boundary_cons[1::4] = 1.0 - centers[:, 0] - radii\n        boundary_cons[2::4] = centers[:, 1] - radii\n        boundary_cons[3::4] = 1.0 - centers[:, 1] - radii\n        \n        return np.concatenate([overlap_cons, boundary_cons])\n\n    def jac_constraints_fn(vars):\n        centers = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        \n        num_overlap = n * (n - 1) // 2\n        num_boundary = 4 * n\n        jac = np.zeros((num_overlap + num_boundary, 3 * n))\n        \n        # Overlap part\n        row_idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                jac[row_idx, 2*i] = 2 * dx\n                jac[row_idx, 2*i+1] = 2 * dy\n                jac[row_idx, 2*j] = -2 * dx\n                jac[row_idx, 2*j+1] = -2 * dy\n                rs = radii[i] + radii[j]\n                jac[row_idx, 2*n + i] = -2 * rs\n                jac[row_idx, 2*n + j] = -2 * rs\n                row_idx += 1\n        \n        # Boundary part\n        for i in range(n):\n            jac[row_idx, 2*i] = 1\n            jac[row_idx, 2*n + i] = -1\n            row_idx += 1\n            jac[row_idx, 2*i] = -1\n            jac[row_idx, 2*n + i] = -1\n            row_idx += 1\n            jac[row_idx, 2*i+1] = 1\n            jac[row_idx, 2*n + i] = -1\n            row_idx += 1\n            jac[row_idx, 2*i+1] = -1\n            jac[row_idx, 2*n + i] = -1\n            row_idx += 1\n            \n        return jac\n\n    start_time = time.time()\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Pre-defined starting grids\n    guesses = []\n    \n    # 5x5 Grid + 1 circle\n    xs5 = np.linspace(0.1, 0.9, 5)\n    g1 = np.array([[x, y] for x in xs5 for y in xs5])\n    g1 = np.vstack([g1, [0.05, 0.05]])\n    guesses.append(g1)\n    \n    # 6x4 Grid + 2 circles\n    xs6 = np.linspace(0.1, 0.9, 6)\n    ys4 = np.linspace(0.1, 0.9, 4)\n    g2 = np.array([[x, y] for x in xs6 for y in ys4])\n    g2 = np.vstack([g2, [[0.05, 0.05], [0.95, 0.95]]])\n    guesses.append(g2)\n\n    # Multi-start optimization loop\n    guess_idx = 0\n    while time.time() - start_time < 260:\n        if guess_idx < len(guesses):\n            centers = guesses[guess_idx].flatten()\n            guess_idx += 1\n        elif best_centers is not None:\n            # Perturb the current best result to find local improvements\n            centers = best_centers.flatten() + np.random.normal(0, 0.02, size=n*2)\n            centers = np.clip(centers, 0, 1)\n        else:\n            # Random starts\n            centers = np.random.uniform(0.1, 0.9, size=n*2)\n        \n        # Initial radii for the chosen centers using LP\n        radii_init, _ = solve_lp(centers.reshape((n, 2)))\n        init_vars = np.concatenate([centers, radii_init])\n        \n        # Non-linear optimization with SLSQP\n        res = minimize(\n            objective, init_vars, method='SLSQP', \n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints_fn, 'jac': jac_constraints_fn},\n            bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n            options={'maxiter': 100}\n        )\n        \n        # Polish the centers found by SLSQP using LP to get optimal radii\n        final_centers = np.clip(res.x[:2*n].reshape((n, 2)), 0, 1)\n        final_radii, final_sum = solve_lp(final_centers)\n        \n        if final_sum > best_sum:\n            best_sum = final_sum\n            best_centers = final_centers\n            best_radii = final_radii\n            \n    if best_centers is None:\n        # Fallback in case of unexpected failure\n        best_centers = g1\n        best_radii, best_sum = solve_lp(g1)\n\n    return best_centers, best_radii, float(best_sum)",
  "metrics": {
    "valid": true,
    "score": 2.631936944996393,
    "eval_time": 260.82720589637756,
    "error": null
  },
  "prompt": "Improve trial_1_2 by adding a final 'polishing' step using scipy.optimize.linprog to maximize radii for the final fixed centers. Also, instead of purely random starts, include 'perturbed' versions of the current best result (score 2.6330352288703494) in the multi-start pool to exploit the known good basin.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Constraints: circles must be entirely inside the square, no overlaps, and radii >= 0.\n    \"\"\"\n    n = 26\n    \n    def solve_lp(centers):\n        \"\"\"\n        Solves a linear programming problem to find the optimal radii for a fixed set of centers.\n        \"\"\"\n        n_circles = centers.shape[0]\n        # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n        c_lp = -np.ones(n_circles)\n        \n        A_ub = []\n        b_ub = []\n        \n        # Overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                row = np.zeros(n_circles)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        bounds_lp = []\n        for i in range(n_circles):\n            xi, yi = centers[i]\n            max_r = min(xi, 1-xi, yi, 1-yi)\n            bounds_lp.append((0, max(0.0, max_r)))\n        \n        # Using the Highs method for efficiency if available\n        try:\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n            if res.success:\n                return res.x, -res.fun\n        except:\n            try:\n                # Fallback to default method\n                res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds_lp)\n                if res.success:\n                    return res.x, -res.fun\n            except:\n                pass\n        return np.zeros(n_circles), 0.0\n\n    def objective(vars):\n        return -np.sum(vars[2*n:])\n\n    def jac_objective(vars):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    def constraints_fn(vars):\n        centers = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        \n        # Overlap constraints: dist^2 - (r_i + r_j)^2 >= 0\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        r_sum_sq = r_sum**2\n        indices = np.triu_indices(n, k=1)\n        overlap_cons = dist_sq[indices] - r_sum_sq[indices]\n        \n        # Boundary constraints: x_i - r_i >= 0, etc.\n        boundary_cons = np.zeros(4*n)\n        boundary_cons[0::4] = centers[:, 0] - radii\n        boundary_cons[1::4] = 1.0 - centers[:, 0] - radii\n        boundary_cons[2::4] = centers[:, 1] - radii\n        boundary_cons[3::4] = 1.0 - centers[:, 1] - radii\n        \n        return np.concatenate([overlap_cons, boundary_cons])\n\n    def jac_constraints_fn(vars):\n        centers = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        \n        num_overlap = n * (n - 1) // 2\n        num_boundary = 4 * n\n        jac = np.zeros((num_overlap + num_boundary, 3 * n))\n        \n        # Overlap part\n        row_idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                jac[row_idx, 2*i] = 2 * dx\n                jac[row_idx, 2*i+1] = 2 * dy\n                jac[row_idx, 2*j] = -2 * dx\n                jac[row_idx, 2*j+1] = -2 * dy\n                rs = radii[i] + radii[j]\n                jac[row_idx, 2*n + i] = -2 * rs\n                jac[row_idx, 2*n + j] = -2 * rs\n                row_idx += 1\n        \n        # Boundary part\n        for i in range(n):\n            jac[row_idx, 2*i] = 1\n            jac[row_idx, 2*n + i] = -1\n            row_idx += 1\n            jac[row_idx, 2*i] = -1\n            jac[row_idx, 2*n + i] = -1\n            row_idx += 1\n            jac[row_idx, 2*i+1] = 1\n            jac[row_idx, 2*n + i] = -1\n            row_idx += 1\n            jac[row_idx, 2*i+1] = -1\n            jac[row_idx, 2*n + i] = -1\n            row_idx += 1\n            \n        return jac\n\n    start_time = time.time()\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Pre-defined starting grids\n    guesses = []\n    \n    # 5x5 Grid + 1 circle\n    xs5 = np.linspace(0.1, 0.9, 5)\n    g1 = np.array([[x, y] for x in xs5 for y in xs5])\n    g1 = np.vstack([g1, [0.05, 0.05]])\n    guesses.append(g1)\n    \n    # 6x4 Grid + 2 circles\n    xs6 = np.linspace(0.1, 0.9, 6)\n    ys4 = np.linspace(0.1, 0.9, 4)\n    g2 = np.array([[x, y] for x in xs6 for y in ys4])\n    g2 = np.vstack([g2, [[0.05, 0.05], [0.95, 0.95]]])\n    guesses.append(g2)\n\n    # Multi-start optimization loop\n    guess_idx = 0\n    while time.time() - start_time < 260:\n        if guess_idx < len(guesses):\n            centers = guesses[guess_idx].flatten()\n            guess_idx += 1\n        elif best_centers is not None:\n            # Perturb the current best result to find local improvements\n            centers = best_centers.flatten() + np.random.normal(0, 0.02, size=n*2)\n            centers = np.clip(centers, 0, 1)\n        else:\n            # Random starts\n            centers = np.random.uniform(0.1, 0.9, size=n*2)\n        \n        # Initial radii for the chosen centers using LP\n        radii_init, _ = solve_lp(centers.reshape((n, 2)))\n        init_vars = np.concatenate([centers, radii_init])\n        \n        # Non-linear optimization with SLSQP\n        res = minimize(\n            objective, init_vars, method='SLSQP', \n            jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints_fn, 'jac': jac_constraints_fn},\n            bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n            options={'maxiter': 100}\n        )\n        \n        # Polish the centers found by SLSQP using LP to get optimal radii\n        final_centers = np.clip(res.x[:2*n].reshape((n, 2)), 0, 1)\n        final_radii, final_sum = solve_lp(final_centers)\n        \n        if final_sum > best_sum:\n            best_sum = final_sum\n            best_centers = final_centers\n            best_radii = final_radii\n            \n    if best_centers is None:\n        # Fallback in case of unexpected failure\n        best_centers = g1\n        best_radii, best_sum = solve_lp(g1)\n\n    return best_centers, best_radii, float(best_sum)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:15:47.943830",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 312,
        "candidates_token_count": 2235,
        "thoughts_token_count": 17446
      },
      "response_text_len": 6394
    }
  },
  "llm_call_duration_s": 108.0304357559653,
  "eval_duration_s": 260.8272136449814
}