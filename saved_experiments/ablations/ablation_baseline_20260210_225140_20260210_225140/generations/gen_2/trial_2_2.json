{
  "trial_id": "trial_2_2",
  "generation": 2,
  "parent_id": "trial_1_1",
  "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a bilevel optimization approach: \n    - Outer loop: Optimizes circle center coordinates (x, y) using L-BFGS-B.\n    - Inner loop: Calculates optimal radii for those centers using Linear Programming (LP).\n    The gradient of the LP objective with respect to the centers is computed using dual variables.\n    \"\"\"\n    start_time = time.time()\n    N = 26\n    \n    # Pre-calculate indices and LP matrix\n    i_idx, j_idx = np.triu_indices(N, k=1)\n    num_dist = len(i_idx)\n    num_bound = 4 * N\n    \n    # A_ub matrix for LP: sum(r_i) constraints\n    # Constraints: r_i + r_j <= d_ij (num_dist)\n    #             r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i (4*N)\n    A_ub = np.zeros((num_dist + num_bound, N))\n    k = 0\n    for i, j in zip(i_idx, j_idx):\n        A_ub[k, i] = 1\n        A_ub[k, j] = 1\n        k += 1\n    for i in range(N):\n        A_ub[k, i] = 1   # x_i\n        A_ub[k+1, i] = 1 # 1-x_i\n        A_ub[k+2, i] = 1 # y_i\n        A_ub[k+3, i] = 1 # 1-y_i\n        k += 4\n    \n    # Objective for LP: Minimize -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(N)\n\n    def get_score(centers_flat):\n        \"\"\"\n        Calculates the negative sum of radii and its gradient for a given set of centers.\n        The gradient is derived from the dual variables of the linear program.\n        \"\"\"\n        centers = centers_flat.reshape((N, 2))\n        \n        # Calculate distances between centers\n        diffs = centers[i_idx] - centers[j_idx]\n        dists = np.sqrt(np.sum(diffs**2, axis=1))\n        \n        # Calculate boundary distances\n        bounds = np.zeros((N, 4))\n        bounds[:, 0] = centers[:, 0]\n        bounds[:, 1] = 1 - centers[:, 0]\n        bounds[:, 2] = centers[:, 1]\n        bounds[:, 3] = 1 - centers[:, 1]\n        \n        # Build the b vector for LP constraints: Ar <= b\n        b = np.concatenate([dists, bounds.flatten()])\n        b = np.maximum(b, 0) # Ensure non-negativity for numerical stability\n        \n        try:\n            # Solve the LP to maximize the sum of radii\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b, bounds=(0, None), method='highs')\n            if res.fun is None or res.ineqlin is None:\n                return 0.0, np.zeros(2 * N)\n            \n            # Use dual variables (marginals) to compute the gradient with respect to b\n            y_star = res.ineqlin.marginals\n            y_star_dist = y_star[:num_dist]\n            y_star_bound = y_star[num_dist:].reshape((N, 4))\n            \n            # Gradient of objective f = -sum(r_i) with respect to centers\n            grad = np.zeros((N, 2))\n            dists_safe = np.maximum(dists, 1e-8)\n            dist_grad = y_star_dist[:, np.newaxis] * diffs / dists_safe[:, np.newaxis]\n            \n            # Vectorized updates to the gradient\n            np.add.at(grad, i_idx, dist_grad)\n            np.subtract.at(grad, j_idx, dist_grad)\n            \n            # Boundary contributions to the gradient\n            grad[:, 0] += y_star_bound[:, 0]\n            grad[:, 0] -= y_star_bound[:, 1]\n            grad[:, 1] += y_star_bound[:, 2]\n            grad[:, 1] -= y_star_bound[:, 3]\n            \n            return res.fun, grad.flatten()\n        except Exception:\n            # Fallback for unexpected numerical issues\n            return 0.0, np.zeros(2 * N)\n\n    best_sum = -1.0\n    best_centers = None\n\n    # Initializations for the centers\n    # 1. 5x5 grid plus one extra point\n    x_grid = np.linspace(0.1, 0.9, 5)\n    y_grid = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x_grid, y_grid)\n    grid55 = np.vstack([xv.ravel(), yv.ravel()]).T\n    \n    init_centers_list = [\n        np.vstack([grid55, [0.5, 0.5]]), \n        np.vstack([grid55, [0.01, 0.01]]),\n        np.vstack([grid55, [0.99, 0.99]]),\n        np.random.uniform(0.05, 0.95, (N, 2))\n    ]\n    \n    # Global optimization loop\n    idx = 0\n    while time.time() - start_time < 240:\n        if idx < len(init_centers_list):\n            c_init = init_centers_list[idx]\n        else:\n            c_init = np.random.uniform(0.05, 0.95, (N, 2))\n        idx += 1\n        \n        res = minimize(get_score, c_init.flatten(), jac=True, method='L-BFGS-B', \n                       bounds=[(0, 1)] * (2 * N), options={'maxiter': 80})\n        \n        if res.fun is not None and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = res.x.reshape((N, 2))\n\n    # Refinement and Shaking to escape local optima\n    if best_centers is not None:\n        # Long refinement run\n        res = minimize(get_score, best_centers.flatten(), jac=True, method='L-BFGS-B', \n                       bounds=[(0, 1)] * (2 * N), options={'maxiter': 200})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = res.x.reshape((N, 2))\n        \n        # Shake and re-optimize\n        for _ in range(5):\n            if time.time() - start_time > 290:\n                break\n            c_shake = best_centers + np.random.normal(0, 0.005, best_centers.shape)\n            c_shake = np.clip(c_shake, 0, 1)\n            res_shake = minimize(get_score, c_shake.flatten(), jac=True, method='L-BFGS-B', \n                                 bounds=[(0, 1)] * (2 * N), options={'maxiter': 100})\n            if res_shake.fun is not None and -res_shake.fun > best_sum:\n                best_sum = -res_shake.fun\n                best_centers = res_shake.x.reshape((N, 2))\n\n        # Final LP solve to extract the radii for the best centers found\n        diffs = best_centers[i_idx] - best_centers[j_idx]\n        dists = np.sqrt(np.sum(diffs**2, axis=1))\n        bounds = np.zeros((N, 4))\n        bounds[:, 0] = best_centers[:, 0]\n        bounds[:, 1] = 1 - best_centers[:, 0]\n        bounds[:, 2] = best_centers[:, 1]\n        bounds[:, 3] = 1 - best_centers[:, 1]\n        b = np.concatenate([dists, bounds.flatten()])\n        b = np.maximum(b, 0)\n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b, bounds=(0, None), method='highs')\n        \n        if res_lp.success:\n            best_radii = res_lp.x\n            best_sum = np.sum(best_radii)\n        else:\n            # Fallback to zero if something went wrong\n            best_radii = np.zeros(N)\n            best_sum = 0.0\n            \n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.5200982273905086,
    "eval_time": 246.79032468795776,
    "error": null
  },
  "prompt": "Try a bilevel optimization approach. The outer loop optimizes the 52 center coordinates (x, y) using a gradient-free method or a simple hill-climber with perturbations. The inner loop calculates the optimal radii for those centers using linear programming (scipy.optimize.linprog). This ensures we are always evaluating the 'best possible' score for any set of centers.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a bilevel optimization approach: \n    - Outer loop: Optimizes circle center coordinates (x, y) using L-BFGS-B.\n    - Inner loop: Calculates optimal radii for those centers using Linear Programming (LP).\n    The gradient of the LP objective with respect to the centers is computed using dual variables.\n    \"\"\"\n    start_time = time.time()\n    N = 26\n    \n    # Pre-calculate indices and LP matrix\n    i_idx, j_idx = np.triu_indices(N, k=1)\n    num_dist = len(i_idx)\n    num_bound = 4 * N\n    \n    # A_ub matrix for LP: sum(r_i) constraints\n    # Constraints: r_i + r_j <= d_ij (num_dist)\n    #             r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i (4*N)\n    A_ub = np.zeros((num_dist + num_bound, N))\n    k = 0\n    for i, j in zip(i_idx, j_idx):\n        A_ub[k, i] = 1\n        A_ub[k, j] = 1\n        k += 1\n    for i in range(N):\n        A_ub[k, i] = 1   # x_i\n        A_ub[k+1, i] = 1 # 1-x_i\n        A_ub[k+2, i] = 1 # y_i\n        A_ub[k+3, i] = 1 # 1-y_i\n        k += 4\n    \n    # Objective for LP: Minimize -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(N)\n\n    def get_score(centers_flat):\n        \"\"\"\n        Calculates the negative sum of radii and its gradient for a given set of centers.\n        The gradient is derived from the dual variables of the linear program.\n        \"\"\"\n        centers = centers_flat.reshape((N, 2))\n        \n        # Calculate distances between centers\n        diffs = centers[i_idx] - centers[j_idx]\n        dists = np.sqrt(np.sum(diffs**2, axis=1))\n        \n        # Calculate boundary distances\n        bounds = np.zeros((N, 4))\n        bounds[:, 0] = centers[:, 0]\n        bounds[:, 1] = 1 - centers[:, 0]\n        bounds[:, 2] = centers[:, 1]\n        bounds[:, 3] = 1 - centers[:, 1]\n        \n        # Build the b vector for LP constraints: Ar <= b\n        b = np.concatenate([dists, bounds.flatten()])\n        b = np.maximum(b, 0) # Ensure non-negativity for numerical stability\n        \n        try:\n            # Solve the LP to maximize the sum of radii\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b, bounds=(0, None), method='highs')\n            if res.fun is None or res.ineqlin is None:\n                return 0.0, np.zeros(2 * N)\n            \n            # Use dual variables (marginals) to compute the gradient with respect to b\n            y_star = res.ineqlin.marginals\n            y_star_dist = y_star[:num_dist]\n            y_star_bound = y_star[num_dist:].reshape((N, 4))\n            \n            # Gradient of objective f = -sum(r_i) with respect to centers\n            grad = np.zeros((N, 2))\n            dists_safe = np.maximum(dists, 1e-8)\n            dist_grad = y_star_dist[:, np.newaxis] * diffs / dists_safe[:, np.newaxis]\n            \n            # Vectorized updates to the gradient\n            np.add.at(grad, i_idx, dist_grad)\n            np.subtract.at(grad, j_idx, dist_grad)\n            \n            # Boundary contributions to the gradient\n            grad[:, 0] += y_star_bound[:, 0]\n            grad[:, 0] -= y_star_bound[:, 1]\n            grad[:, 1] += y_star_bound[:, 2]\n            grad[:, 1] -= y_star_bound[:, 3]\n            \n            return res.fun, grad.flatten()\n        except Exception:\n            # Fallback for unexpected numerical issues\n            return 0.0, np.zeros(2 * N)\n\n    best_sum = -1.0\n    best_centers = None\n\n    # Initializations for the centers\n    # 1. 5x5 grid plus one extra point\n    x_grid = np.linspace(0.1, 0.9, 5)\n    y_grid = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x_grid, y_grid)\n    grid55 = np.vstack([xv.ravel(), yv.ravel()]).T\n    \n    init_centers_list = [\n        np.vstack([grid55, [0.5, 0.5]]), \n        np.vstack([grid55, [0.01, 0.01]]),\n        np.vstack([grid55, [0.99, 0.99]]),\n        np.random.uniform(0.05, 0.95, (N, 2))\n    ]\n    \n    # Global optimization loop\n    idx = 0\n    while time.time() - start_time < 240:\n        if idx < len(init_centers_list):\n            c_init = init_centers_list[idx]\n        else:\n            c_init = np.random.uniform(0.05, 0.95, (N, 2))\n        idx += 1\n        \n        res = minimize(get_score, c_init.flatten(), jac=True, method='L-BFGS-B', \n                       bounds=[(0, 1)] * (2 * N), options={'maxiter': 80})\n        \n        if res.fun is not None and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = res.x.reshape((N, 2))\n\n    # Refinement and Shaking to escape local optima\n    if best_centers is not None:\n        # Long refinement run\n        res = minimize(get_score, best_centers.flatten(), jac=True, method='L-BFGS-B', \n                       bounds=[(0, 1)] * (2 * N), options={'maxiter': 200})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_centers = res.x.reshape((N, 2))\n        \n        # Shake and re-optimize\n        for _ in range(5):\n            if time.time() - start_time > 290:\n                break\n            c_shake = best_centers + np.random.normal(0, 0.005, best_centers.shape)\n            c_shake = np.clip(c_shake, 0, 1)\n            res_shake = minimize(get_score, c_shake.flatten(), jac=True, method='L-BFGS-B', \n                                 bounds=[(0, 1)] * (2 * N), options={'maxiter': 100})\n            if res_shake.fun is not None and -res_shake.fun > best_sum:\n                best_sum = -res_shake.fun\n                best_centers = res_shake.x.reshape((N, 2))\n\n        # Final LP solve to extract the radii for the best centers found\n        diffs = best_centers[i_idx] - best_centers[j_idx]\n        dists = np.sqrt(np.sum(diffs**2, axis=1))\n        bounds = np.zeros((N, 4))\n        bounds[:, 0] = best_centers[:, 0]\n        bounds[:, 1] = 1 - best_centers[:, 0]\n        bounds[:, 2] = best_centers[:, 1]\n        bounds[:, 3] = 1 - best_centers[:, 1]\n        b = np.concatenate([dists, bounds.flatten()])\n        b = np.maximum(b, 0)\n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b, bounds=(0, None), method='highs')\n        \n        if res_lp.success:\n            best_radii = res_lp.x\n            best_sum = np.sum(best_radii)\n        else:\n            # Fallback to zero if something went wrong\n            best_radii = np.zeros(N)\n            best_sum = 0.0\n            \n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:16:28.308693",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 306,
        "candidates_token_count": 2218,
        "thoughts_token_count": 27785
      },
      "response_text_len": 6457
    }
  },
  "llm_call_duration_s": 162.44328644499183,
  "eval_duration_s": 246.79033441399224
}