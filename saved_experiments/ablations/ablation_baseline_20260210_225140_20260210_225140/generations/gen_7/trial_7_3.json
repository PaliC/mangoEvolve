{
  "trial_id": "trial_7_3",
  "generation": 7,
  "parent_id": "trial_6_4",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef solve_lp(centers, A, n):\n    \"\"\"\n    Solves the Linear Programming problem to find the optimal radii for fixed centers.\n    Maximize sum(R_i) subject to:\n    1. R_i <= x_i, R_i <= 1-x_i, R_i <= y_i, R_i <= 1-y_i (circles inside the unit square)\n    2. R_i + R_j <= distance(C_i, C_j) (no overlaps between circles)\n    3. R_i >= 0\n    \"\"\"\n    x, y = centers[:, 0], centers[:, 1]\n    \n    # Distance to walls: each circle's radius is bounded by its distance to the nearest edge\n    d_wall = np.maximum(0, np.minimum(np.minimum(x, 1-x), np.minimum(y, 1-y)))\n    \n    # Pairwise distances between all centers\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    dists = np.sqrt(dx**2 + dy**2)\n    \n    # Extract the upper triangle of the distance matrix (n*(n-1)/2 values)\n    # This matches the structure of the precomputed constraint matrix A\n    b = dists[np.triu_indices(n, k=1)]\n    \n    # Objective: Maximize sum(R_i) -> Minimize -sum(R_i)\n    c = -np.ones(n)\n    \n    # Bounds for each R_i: 0 <= R_i <= d_wall[i]\n    bounds = [(0, d) for d in d_wall]\n    \n    # Solve the linear program using the HiGHS solver\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n    \n    if res.success:\n        return res.x, -res.fun\n    else:\n        # In case of failure, return zero radii\n        return np.zeros(n), 0.0\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a [0,1] x [0,1] square to maximize the sum of their radii.\n    Employs Stochastic Hill Climbing on center positions, optimizing radii via LP.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    \n    # Precompute the A_ub matrix for the LP constraints (R_i + R_j <= d_ij)\n    # This matrix is fixed for a given number of circles n.\n    num_constraints = n * (n - 1) // 2\n    A = np.zeros((num_constraints, n))\n    rows, cols = np.triu_indices(n, k=1)\n    for k in range(num_constraints):\n        A[k, rows[k]] = 1\n        A[k, cols[k]] = 1\n                \n    # Initial center configuration: a 6x4 grid plus two extra points.\n    # This provides a well-distributed starting point in the unit square.\n    xs = np.linspace(1/12, 11/12, 6)\n    ys = np.linspace(1/8, 7/8, 4)\n    centers_list = [[x, y] for x in xs for y in ys]\n    centers_list.append([0.5, 0.5])\n    centers_list.append([0.45, 0.55])\n    best_centers = np.array(centers_list)\n    \n    # Initialize the best known solution\n    best_radii, best_sum = solve_lp(best_centers, A, n)\n    \n    # Stochastic Hill Climbing parameters\n    sigma = 0.01  # Initial standard deviation for Gaussian perturbations\n    \n    # Optimization loop: continues for approximately 285 seconds\n    while time.time() - start_time < 285:\n        # Generate new candidate centers by applying small Gaussian perturbations\n        # All 52 coordinates (26 centers * 2) are perturbed simultaneously.\n        noise = np.random.normal(0, sigma, (n, 2))\n        new_centers = np.clip(best_centers + noise, 0, 1)\n        \n        # Calculate the optimal radii for the current set of centers using LP\n        radii, current_sum = solve_lp(new_centers, A, n)\n        \n        # If the new configuration yields a higher sum of radii, update the best state\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii\n            best_centers = new_centers\n            # On success, slightly increase sigma to explore broader neighborhoods\n            sigma = min(sigma * 1.05, 0.05)\n        else:\n            # On failure, decrease sigma to refine the search locally\n            sigma *= 0.95\n            \n        # Reset sigma if it becomes too small to prevent stagnation\n        if sigma < 1e-7:\n            sigma = 0.01\n                    \n    # Ensure numerical robustness: radii must be non-negative\n    best_radii = np.maximum(0, best_radii)\n    \n    # Final result: centers (26, 2), radii (26,), and the total sum\n    return best_centers, best_radii, float(best_sum)\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.1469440464500895,
    "eval_time": 285.46200037002563,
    "error": null
  },
  "prompt": "Use a 'Stochastic Hill Climbing' approach on the center positions of trial_6_4.\n1. The state space is the 52 coordinates (x, y) of the 26 centers.\n2. The evaluation function is the optimal sum of radii for those centers, calculated via LP (scipy.optimize.linprog).\n3. Use very small Gaussian perturbations on all centers simultaneously.\n4. If the LP returns a higher sum, accept the move.\n5. This focuses the search entirely on the center manifold while guaranteeing radius optimality.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef solve_lp(centers, A, n):\n    \"\"\"\n    Solves the Linear Programming problem to find the optimal radii for fixed centers.\n    Maximize sum(R_i) subject to:\n    1. R_i <= x_i, R_i <= 1-x_i, R_i <= y_i, R_i <= 1-y_i (circles inside the unit square)\n    2. R_i + R_j <= distance(C_i, C_j) (no overlaps between circles)\n    3. R_i >= 0\n    \"\"\"\n    x, y = centers[:, 0], centers[:, 1]\n    \n    # Distance to walls: each circle's radius is bounded by its distance to the nearest edge\n    d_wall = np.maximum(0, np.minimum(np.minimum(x, 1-x), np.minimum(y, 1-y)))\n    \n    # Pairwise distances between all centers\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    dists = np.sqrt(dx**2 + dy**2)\n    \n    # Extract the upper triangle of the distance matrix (n*(n-1)/2 values)\n    # This matches the structure of the precomputed constraint matrix A\n    b = dists[np.triu_indices(n, k=1)]\n    \n    # Objective: Maximize sum(R_i) -> Minimize -sum(R_i)\n    c = -np.ones(n)\n    \n    # Bounds for each R_i: 0 <= R_i <= d_wall[i]\n    bounds = [(0, d) for d in d_wall]\n    \n    # Solve the linear program using the HiGHS solver\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n    \n    if res.success:\n        return res.x, -res.fun\n    else:\n        # In case of failure, return zero radii\n        return np.zeros(n), 0.0\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a [0,1] x [0,1] square to maximize the sum of their radii.\n    Employs Stochastic Hill Climbing on center positions, optimizing radii via LP.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    \n    # Precompute the A_ub matrix for the LP constraints (R_i + R_j <= d_ij)\n    # This matrix is fixed for a given number of circles n.\n    num_constraints = n * (n - 1) // 2\n    A = np.zeros((num_constraints, n))\n    rows, cols = np.triu_indices(n, k=1)\n    for k in range(num_constraints):\n        A[k, rows[k]] = 1\n        A[k, cols[k]] = 1\n                \n    # Initial center configuration: a 6x4 grid plus two extra points.\n    # This provides a well-distributed starting point in the unit square.\n    xs = np.linspace(1/12, 11/12, 6)\n    ys = np.linspace(1/8, 7/8, 4)\n    centers_list = [[x, y] for x in xs for y in ys]\n    centers_list.append([0.5, 0.5])\n    centers_list.append([0.45, 0.55])\n    best_centers = np.array(centers_list)\n    \n    # Initialize the best known solution\n    best_radii, best_sum = solve_lp(best_centers, A, n)\n    \n    # Stochastic Hill Climbing parameters\n    sigma = 0.01  # Initial standard deviation for Gaussian perturbations\n    \n    # Optimization loop: continues for approximately 285 seconds\n    while time.time() - start_time < 285:\n        # Generate new candidate centers by applying small Gaussian perturbations\n        # All 52 coordinates (26 centers * 2) are perturbed simultaneously.\n        noise = np.random.normal(0, sigma, (n, 2))\n        new_centers = np.clip(best_centers + noise, 0, 1)\n        \n        # Calculate the optimal radii for the current set of centers using LP\n        radii, current_sum = solve_lp(new_centers, A, n)\n        \n        # If the new configuration yields a higher sum of radii, update the best state\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii\n            best_centers = new_centers\n            # On success, slightly increase sigma to explore broader neighborhoods\n            sigma = min(sigma * 1.05, 0.05)\n        else:\n            # On failure, decrease sigma to refine the search locally\n            sigma *= 0.95\n            \n        # Reset sigma if it becomes too small to prevent stagnation\n        if sigma < 1e-7:\n            sigma = 0.01\n                    \n    # Ensure numerical robustness: radii must be non-negative\n    best_radii = np.maximum(0, best_radii)\n    \n    # Final result: centers (26, 2), radii (26,), and the total sum\n    return best_centers, best_radii, float(best_sum)\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:00:36.893463",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 345,
        "candidates_token_count": 1335,
        "thoughts_token_count": 19851
      },
      "response_text_len": 4121
    }
  },
  "llm_call_duration_s": 119.49333910294808,
  "eval_duration_s": 285.46200901898555
}