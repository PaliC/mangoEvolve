{
  "trial_id": "trial_7_5",
  "generation": 7,
  "parent_id": "trial_6_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start strategy with SLSQP optimization followed by LP-based radii refinement.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    def get_initial_configs(n):\n        \"\"\"Generates diverse initial configurations based on grids and random offsets.\"\"\"\n        configs = []\n        # Systematic grid-based initializations\n        grids = [(5, 5), (6, 4), (4, 6), (5, 6), (6, 5), (7, 4), (4, 7)]\n        for r_c, c_c in grids:\n            # Create a grid and adjust it to exactly n circles\n            x_grid, y_grid = np.meshgrid(np.linspace(0.1, 0.9, c_c), np.linspace(0.1, 0.9, r_c))\n            x_f, y_f = x_grid.flatten(), y_grid.flatten()\n            \n            if len(x_f) > n:\n                # Randomly select n circles from the grid\n                idx = np.random.choice(len(x_f), n, replace=False)\n                x, y = x_f[idx], y_f[idx]\n            elif len(x_f) < n:\n                # Add random circles to reach n\n                x, y = x_f, y_f\n                while len(x) < n:\n                    x = np.append(x, np.random.uniform(0.1, 0.9))\n                    y = np.append(y, np.random.uniform(0.1, 0.9))\n            else:\n                x, y = x_f, y_f\n            \n            # Apply slight jitter to break symmetry\n            x += np.random.normal(0, 0.01, n)\n            y += np.random.normal(0, 0.01, n)\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            configs.append(np.concatenate([x, y, np.full(n, 0.05)]))\n        \n        # Purely random starts\n        for _ in range(5):\n            x = np.random.uniform(0.1, 0.9, n)\n            y = np.random.uniform(0.1, 0.9, n)\n            configs.append(np.concatenate([x, y, np.full(n, 0.05)]))\n        return configs\n\n    # Precompute indices for vectorized distance and Jacobian calculations\n    iu = np.triu_indices(n, 1)\n    num_pairwise = len(iu[0])\n    idx_p = 4 * n + np.arange(num_pairwise)\n    i_indices = iu[0]\n    j_indices = iu[1]\n\n    def obj(v):\n        \"\"\"Objective function: Minimize negative sum of radii.\"\"\"\n        return -np.sum(v[2*n:])\n    \n    def obj_jac(v):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        j = np.zeros(3*n)\n        j[2*n:] = -1\n        return j\n\n    def cons_vectorized(v):\n        \"\"\"Vectorized constraints: Boundary and pairwise distance.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        c = np.zeros(4*n + num_pairwise)\n        # Boundary constraints: r_i <= x_i <= 1-r_i\n        c[:n] = x - r\n        c[n:2*n] = 1.0 - x - r\n        c[2*n:3*n] = y - r\n        c[3*n:4*n] = 1.0 - y - r\n        \n        # Pairwise distance constraints: (x_i-x_j)^2 + (y_i-y_j)^2 >= (r_i+r_j)^2\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        c[4*n:] = dx**2 + dy**2 - dr**2\n        return c\n\n    def cons_jac_vectorized(v):\n        \"\"\"Efficient Jacobian of the vectorized constraints.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        jac = np.zeros((4 * n + num_pairwise, 3 * n))\n        \n        # Boundary jacobians (mapping derivatives to correct indices)\n        idx_n = np.arange(n)\n        jac[idx_n, idx_n] = 1; jac[idx_n, 2*n + idx_n] = -1\n        jac[n + idx_n, idx_n] = -1; jac[n + idx_n, 2*n + idx_n] = -1\n        jac[2*n + idx_n, n + idx_n] = 1; jac[2*n + idx_n, 2*n + idx_n] = -1\n        jac[3*n + idx_n, n + idx_n] = -1; jac[3*n + idx_n, 2*n + idx_n] = -1\n        \n        # Pairwise jacobians\n        dx = 2.0 * (x[i_indices] - x[j_indices])\n        dy = 2.0 * (y[i_indices] - y[j_indices])\n        dr = -2.0 * (r[i_indices] + r[j_indices])\n        \n        jac[idx_p, i_indices] = dx\n        jac[idx_p, j_indices] = -dx\n        jac[idx_p, n + i_indices] = dy\n        jac[idx_p, n + j_indices] = -dy\n        jac[idx_p, 2*n + i_indices] = dr\n        jac[idx_p, 2*n + j_indices] = dr\n        return jac\n\n    def refine_radii(centers, n):\n        \"\"\"For fixed centers, solves a Linear Program to find the optimal radii.\"\"\"\n        centers = np.clip(centers, 0, 1)\n        c = -np.ones(n) # Maximize sum of r_i\n        \n        # Distance between centers\n        dist_sq = np.sum((centers[i_indices] - centers[j_indices])**2, axis=1)\n        dist = np.sqrt(np.maximum(dist_sq, 0))\n        \n        # Linear inequality matrix A_ub for r_i + r_j <= dist_ij\n        A_ub = np.zeros((num_pairwise, n))\n        A_ub[np.arange(num_pairwise), i_indices] = 1\n        A_ub[np.arange(num_pairwise), j_indices] = 1\n        b_ub = dist\n        \n        # Bounds for each r_i based on square boundaries\n        bounds = []\n        for i in range(n):\n            limit = min(centers[i,0], 1.0 - centers[i,0], centers[i,1], 1.0 - centers[i,1])\n            bounds.append((0, max(0, limit)))\n            \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return None, 0\n\n    # Optimization loop\n    best_v = None\n    best_sum = -1\n    best_centers = None\n    best_radii = None\n    \n    configs = get_initial_configs(n)\n    cons_dict = {'type': 'ineq', 'fun': cons_vectorized, 'jac': cons_jac_vectorized}\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    for config in configs:\n        # Respect the 300s time constraint\n        if time.time() - start_time > 260:\n            break\n        \n        # Stage 1: Fast local optimization\n        res = minimize(obj, config, method='SLSQP', jac=obj_jac, \n                       constraints=cons_dict, bounds=bounds,\n                       options={'maxiter': 100})\n        \n        centers = np.zeros((n, 2))\n        centers[:, 0] = res.x[:n]\n        centers[:, 1] = res.x[n:2*n]\n        # Stage 2: LP Refinement\n        radii, current_sum = refine_radii(centers, n)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers\n            best_radii = radii\n            best_v = np.concatenate([centers[:, 0], centers[:, 1], radii])\n\n    # Final Stage: Deep refinement of the best found configuration\n    if best_v is not None:\n        res = minimize(obj, best_v, method='SLSQP', jac=obj_jac, \n                       constraints=cons_dict, bounds=bounds,\n                       options={'maxiter': 500})\n        centers = np.zeros((n, 2))\n        centers[:, 0] = res.x[:n]\n        centers[:, 1] = res.x[n:2*n]\n        radii, current_sum = refine_radii(centers, n)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers\n            best_radii = radii\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.6262667125801733,
    "eval_time": 3.4760162830352783,
    "error": null
  },
  "prompt": "Try a fresh 'Multi-Start' strategy with a focus on 'Symmetry Breaking'.\n1. Generate initial configurations that are near-grids but with random offsets.\n2. Use a two-stage optimization: first, a low-precision 'fast' SLSQP to find promising basins.\n3. For the top 5% of results, run a high-precision refinement with LP-based radii maximization.\n4. Use vectorized distance calculations for speed.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a multi-start strategy with SLSQP optimization followed by LP-based radii refinement.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    def get_initial_configs(n):\n        \"\"\"Generates diverse initial configurations based on grids and random offsets.\"\"\"\n        configs = []\n        # Systematic grid-based initializations\n        grids = [(5, 5), (6, 4), (4, 6), (5, 6), (6, 5), (7, 4), (4, 7)]\n        for r_c, c_c in grids:\n            # Create a grid and adjust it to exactly n circles\n            x_grid, y_grid = np.meshgrid(np.linspace(0.1, 0.9, c_c), np.linspace(0.1, 0.9, r_c))\n            x_f, y_f = x_grid.flatten(), y_grid.flatten()\n            \n            if len(x_f) > n:\n                # Randomly select n circles from the grid\n                idx = np.random.choice(len(x_f), n, replace=False)\n                x, y = x_f[idx], y_f[idx]\n            elif len(x_f) < n:\n                # Add random circles to reach n\n                x, y = x_f, y_f\n                while len(x) < n:\n                    x = np.append(x, np.random.uniform(0.1, 0.9))\n                    y = np.append(y, np.random.uniform(0.1, 0.9))\n            else:\n                x, y = x_f, y_f\n            \n            # Apply slight jitter to break symmetry\n            x += np.random.normal(0, 0.01, n)\n            y += np.random.normal(0, 0.01, n)\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            configs.append(np.concatenate([x, y, np.full(n, 0.05)]))\n        \n        # Purely random starts\n        for _ in range(5):\n            x = np.random.uniform(0.1, 0.9, n)\n            y = np.random.uniform(0.1, 0.9, n)\n            configs.append(np.concatenate([x, y, np.full(n, 0.05)]))\n        return configs\n\n    # Precompute indices for vectorized distance and Jacobian calculations\n    iu = np.triu_indices(n, 1)\n    num_pairwise = len(iu[0])\n    idx_p = 4 * n + np.arange(num_pairwise)\n    i_indices = iu[0]\n    j_indices = iu[1]\n\n    def obj(v):\n        \"\"\"Objective function: Minimize negative sum of radii.\"\"\"\n        return -np.sum(v[2*n:])\n    \n    def obj_jac(v):\n        \"\"\"Jacobian of the objective function.\"\"\"\n        j = np.zeros(3*n)\n        j[2*n:] = -1\n        return j\n\n    def cons_vectorized(v):\n        \"\"\"Vectorized constraints: Boundary and pairwise distance.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        c = np.zeros(4*n + num_pairwise)\n        # Boundary constraints: r_i <= x_i <= 1-r_i\n        c[:n] = x - r\n        c[n:2*n] = 1.0 - x - r\n        c[2*n:3*n] = y - r\n        c[3*n:4*n] = 1.0 - y - r\n        \n        # Pairwise distance constraints: (x_i-x_j)^2 + (y_i-y_j)^2 >= (r_i+r_j)^2\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dr = r[i_indices] + r[j_indices]\n        c[4*n:] = dx**2 + dy**2 - dr**2\n        return c\n\n    def cons_jac_vectorized(v):\n        \"\"\"Efficient Jacobian of the vectorized constraints.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        jac = np.zeros((4 * n + num_pairwise, 3 * n))\n        \n        # Boundary jacobians (mapping derivatives to correct indices)\n        idx_n = np.arange(n)\n        jac[idx_n, idx_n] = 1; jac[idx_n, 2*n + idx_n] = -1\n        jac[n + idx_n, idx_n] = -1; jac[n + idx_n, 2*n + idx_n] = -1\n        jac[2*n + idx_n, n + idx_n] = 1; jac[2*n + idx_n, 2*n + idx_n] = -1\n        jac[3*n + idx_n, n + idx_n] = -1; jac[3*n + idx_n, 2*n + idx_n] = -1\n        \n        # Pairwise jacobians\n        dx = 2.0 * (x[i_indices] - x[j_indices])\n        dy = 2.0 * (y[i_indices] - y[j_indices])\n        dr = -2.0 * (r[i_indices] + r[j_indices])\n        \n        jac[idx_p, i_indices] = dx\n        jac[idx_p, j_indices] = -dx\n        jac[idx_p, n + i_indices] = dy\n        jac[idx_p, n + j_indices] = -dy\n        jac[idx_p, 2*n + i_indices] = dr\n        jac[idx_p, 2*n + j_indices] = dr\n        return jac\n\n    def refine_radii(centers, n):\n        \"\"\"For fixed centers, solves a Linear Program to find the optimal radii.\"\"\"\n        centers = np.clip(centers, 0, 1)\n        c = -np.ones(n) # Maximize sum of r_i\n        \n        # Distance between centers\n        dist_sq = np.sum((centers[i_indices] - centers[j_indices])**2, axis=1)\n        dist = np.sqrt(np.maximum(dist_sq, 0))\n        \n        # Linear inequality matrix A_ub for r_i + r_j <= dist_ij\n        A_ub = np.zeros((num_pairwise, n))\n        A_ub[np.arange(num_pairwise), i_indices] = 1\n        A_ub[np.arange(num_pairwise), j_indices] = 1\n        b_ub = dist\n        \n        # Bounds for each r_i based on square boundaries\n        bounds = []\n        for i in range(n):\n            limit = min(centers[i,0], 1.0 - centers[i,0], centers[i,1], 1.0 - centers[i,1])\n            bounds.append((0, max(0, limit)))\n            \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return None, 0\n\n    # Optimization loop\n    best_v = None\n    best_sum = -1\n    best_centers = None\n    best_radii = None\n    \n    configs = get_initial_configs(n)\n    cons_dict = {'type': 'ineq', 'fun': cons_vectorized, 'jac': cons_jac_vectorized}\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    for config in configs:\n        # Respect the 300s time constraint\n        if time.time() - start_time > 260:\n            break\n        \n        # Stage 1: Fast local optimization\n        res = minimize(obj, config, method='SLSQP', jac=obj_jac, \n                       constraints=cons_dict, bounds=bounds,\n                       options={'maxiter': 100})\n        \n        centers = np.zeros((n, 2))\n        centers[:, 0] = res.x[:n]\n        centers[:, 1] = res.x[n:2*n]\n        # Stage 2: LP Refinement\n        radii, current_sum = refine_radii(centers, n)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers\n            best_radii = radii\n            best_v = np.concatenate([centers[:, 0], centers[:, 1], radii])\n\n    # Final Stage: Deep refinement of the best found configuration\n    if best_v is not None:\n        res = minimize(obj, best_v, method='SLSQP', jac=obj_jac, \n                       constraints=cons_dict, bounds=bounds,\n                       options={'maxiter': 500})\n        centers = np.zeros((n, 2))\n        centers[:, 0] = res.x[:n]\n        centers[:, 1] = res.x[n:2*n]\n        radii, current_sum = refine_radii(centers, n)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers\n            best_radii = radii\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:56:18.257504",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 323,
        "candidates_token_count": 2427,
        "thoughts_token_count": 21589
      },
      "response_text_len": 6834
    }
  },
  "llm_call_duration_s": 142.86810146505013,
  "eval_duration_s": 3.47602546797134
}