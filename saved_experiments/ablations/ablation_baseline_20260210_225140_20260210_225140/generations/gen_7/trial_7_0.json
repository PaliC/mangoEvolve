{
  "trial_id": "trial_7_0",
  "generation": 7,
  "parent_id": "trial_6_4",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.sparse import csr_matrix\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses 'Micro-Coordinate Descent' with Linear Programming to optimize radii for fixed centers.\n    \"\"\"\n    start_time = time.time()\n    N = 26\n    \n    # Precompute LP components for efficiency\n    num_pairs = N * (N - 1) // 2\n    A_ub_data = np.ones(2 * num_pairs)\n    A_ub_indices = np.zeros(2 * num_pairs, dtype=int)\n    A_ub_indptr = np.arange(0, 2 * num_pairs + 1, 2)\n    \n    idx = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            A_ub_indices[2 * idx] = i\n            A_ub_indices[2 * idx + 1] = j\n            idx += 1\n    A_ub_sparse = csr_matrix((A_ub_data, A_ub_indices, A_ub_indptr), shape=(num_pairs, N))\n    c = -np.ones(N)\n    triu_idx = np.triu_indices(N, k=1)\n\n    def solve_lp(centers):\n        \"\"\"Solves the Linear Programming problem to find optimal radii for fixed centers.\"\"\"\n        # Distance constraints: Ri + Rj <= dist(Ci, Cj)\n        dist_matrix = np.sqrt(np.sum((centers[:, None, :] - centers[None, :, :])**2, axis=-1))\n        b_ub = dist_matrix[triu_idx]\n        \n        # Boundary constraints: Ri <= min(xi, 1-xi, yi, 1-yi)\n        max_r = np.min(np.column_stack([centers[:, 0], 1-centers[:, 0], centers[:, 1], 1-centers[:, 1]]), axis=1)\n        max_r = np.maximum(max_r, 0)\n        \n        # Solving LP with 'highs' method\n        res = linprog(c, A_ub=A_ub_sparse, b_ub=b_ub, bounds=list(zip(np.zeros(N), max_r)), method='highs')\n        if res.success:\n            return -res.fun, res.x\n        return 0.0, np.zeros(N)\n\n    best_overall_sum = 0.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Try several initial configurations to explore different local optima\n    seeds = [0, 1, 2, 3]\n    for seed in seeds:\n        if time.time() - start_time > 280:\n            break\n            \n        np.random.seed(seed)\n        if seed == 0:\n            # 5x5 grid + 1 circle\n            centers = np.array([[x, y] for x in np.linspace(0.1, 0.9, 5) for y in np.linspace(0.1, 0.9, 5)])\n            centers = np.vstack([centers, [0.5, 0.5]])\n        elif seed == 1:\n            # 4x6 grid + 2 circles\n            centers = np.array([[x, y] for x in np.linspace(0.1, 0.9, 4) for y in np.linspace(0.1, 0.9, 6)])\n            centers = np.vstack([centers, [[0.2, 0.5], [0.8, 0.5]]])\n        elif seed == 2:\n            # 6x4 grid + 2 circles\n            centers = np.array([[x, y] for x in np.linspace(0.1, 0.9, 6) for y in np.linspace(0.1, 0.9, 4)])\n            centers = np.vstack([centers, [[0.5, 0.2], [0.5, 0.8]]])\n        else:\n            # Random initialization\n            centers = np.random.rand(N, 2)\n        \n        # Jitter the initial centers and keep them slightly away from boundaries\n        centers = 0.05 + 0.9 * centers\n        centers += np.random.normal(0, 0.02, centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n        \n        current_sum, current_radii = solve_lp(centers)\n        \n        # Micro-Coordinate Descent refinement\n        epsilons = [0.01, 0.001, 0.0001, 0.00001]\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n        \n        for eps in epsilons:\n            if time.time() - start_time > 280:\n                break\n            for _ in range(2):  # Two passes per epsilon\n                if time.time() - start_time > 280:\n                    break\n                for i in range(N):\n                    for dx, dy in directions:\n                        old_center = centers[i].copy()\n                        # Move the center\n                        centers[i] = np.clip(centers[i] + [dx * eps, dy * eps], 1e-9, 1.0 - 1e-9)\n                        new_sum, new_radii = solve_lp(centers)\n                        \n                        if new_sum > current_sum + 1e-8:\n                            current_sum = new_sum\n                            current_radii = new_radii\n                            # Greedy line search in the successful direction\n                            while True:\n                                if time.time() - start_time > 280:\n                                    break\n                                next_center = np.clip(centers[i] + [dx * eps, dy * eps], 1e-9, 1.0 - 1e-9)\n                                next_sum, next_radii = solve_lp(np.vstack([centers[:i], next_center[None, :], centers[i+1:]]))\n                                if next_sum > current_sum + 1e-8:\n                                    current_sum = next_sum\n                                    current_radii = next_radii\n                                    centers[i] = next_center\n                                else:\n                                    break\n                        else:\n                            # Revert if no improvement\n                            centers[i] = old_center\n                            \n        # Update global best result\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = current_radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum",
  "metrics": {
    "valid": true,
    "score": 2.399972667679253,
    "eval_time": 19.264224529266357,
    "error": null
  },
  "prompt": "Improve the best result trial_6_4 (score 2.6359830849359622) by implementing a 'Micro-Coordinate Descent'.\n1. Take the best configuration from {top_trials[0].trial_id}.\n2. For each circle i (1 to 26), perturb its center (xi, yi) by a tiny amount (e.g., 1e-7) in multiple directions.\n3. For each perturbation, solve for the mathematically optimal radii using scipy.optimize.linprog(method='highs').\n4. If the sum of radii increases, keep the move.\n5. This 'greedy' approach on centers should navigate the rigid constraint space more precisely than SLSQP.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.sparse import csr_matrix\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses 'Micro-Coordinate Descent' with Linear Programming to optimize radii for fixed centers.\n    \"\"\"\n    start_time = time.time()\n    N = 26\n    \n    # Precompute LP components for efficiency\n    num_pairs = N * (N - 1) // 2\n    A_ub_data = np.ones(2 * num_pairs)\n    A_ub_indices = np.zeros(2 * num_pairs, dtype=int)\n    A_ub_indptr = np.arange(0, 2 * num_pairs + 1, 2)\n    \n    idx = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            A_ub_indices[2 * idx] = i\n            A_ub_indices[2 * idx + 1] = j\n            idx += 1\n    A_ub_sparse = csr_matrix((A_ub_data, A_ub_indices, A_ub_indptr), shape=(num_pairs, N))\n    c = -np.ones(N)\n    triu_idx = np.triu_indices(N, k=1)\n\n    def solve_lp(centers):\n        \"\"\"Solves the Linear Programming problem to find optimal radii for fixed centers.\"\"\"\n        # Distance constraints: Ri + Rj <= dist(Ci, Cj)\n        dist_matrix = np.sqrt(np.sum((centers[:, None, :] - centers[None, :, :])**2, axis=-1))\n        b_ub = dist_matrix[triu_idx]\n        \n        # Boundary constraints: Ri <= min(xi, 1-xi, yi, 1-yi)\n        max_r = np.min(np.column_stack([centers[:, 0], 1-centers[:, 0], centers[:, 1], 1-centers[:, 1]]), axis=1)\n        max_r = np.maximum(max_r, 0)\n        \n        # Solving LP with 'highs' method\n        res = linprog(c, A_ub=A_ub_sparse, b_ub=b_ub, bounds=list(zip(np.zeros(N), max_r)), method='highs')\n        if res.success:\n            return -res.fun, res.x\n        return 0.0, np.zeros(N)\n\n    best_overall_sum = 0.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Try several initial configurations to explore different local optima\n    seeds = [0, 1, 2, 3]\n    for seed in seeds:\n        if time.time() - start_time > 280:\n            break\n            \n        np.random.seed(seed)\n        if seed == 0:\n            # 5x5 grid + 1 circle\n            centers = np.array([[x, y] for x in np.linspace(0.1, 0.9, 5) for y in np.linspace(0.1, 0.9, 5)])\n            centers = np.vstack([centers, [0.5, 0.5]])\n        elif seed == 1:\n            # 4x6 grid + 2 circles\n            centers = np.array([[x, y] for x in np.linspace(0.1, 0.9, 4) for y in np.linspace(0.1, 0.9, 6)])\n            centers = np.vstack([centers, [[0.2, 0.5], [0.8, 0.5]]])\n        elif seed == 2:\n            # 6x4 grid + 2 circles\n            centers = np.array([[x, y] for x in np.linspace(0.1, 0.9, 6) for y in np.linspace(0.1, 0.9, 4)])\n            centers = np.vstack([centers, [[0.5, 0.2], [0.5, 0.8]]])\n        else:\n            # Random initialization\n            centers = np.random.rand(N, 2)\n        \n        # Jitter the initial centers and keep them slightly away from boundaries\n        centers = 0.05 + 0.9 * centers\n        centers += np.random.normal(0, 0.02, centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n        \n        current_sum, current_radii = solve_lp(centers)\n        \n        # Micro-Coordinate Descent refinement\n        epsilons = [0.01, 0.001, 0.0001, 0.00001]\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n        \n        for eps in epsilons:\n            if time.time() - start_time > 280:\n                break\n            for _ in range(2):  # Two passes per epsilon\n                if time.time() - start_time > 280:\n                    break\n                for i in range(N):\n                    for dx, dy in directions:\n                        old_center = centers[i].copy()\n                        # Move the center\n                        centers[i] = np.clip(centers[i] + [dx * eps, dy * eps], 1e-9, 1.0 - 1e-9)\n                        new_sum, new_radii = solve_lp(centers)\n                        \n                        if new_sum > current_sum + 1e-8:\n                            current_sum = new_sum\n                            current_radii = new_radii\n                            # Greedy line search in the successful direction\n                            while True:\n                                if time.time() - start_time > 280:\n                                    break\n                                next_center = np.clip(centers[i] + [dx * eps, dy * eps], 1e-9, 1.0 - 1e-9)\n                                next_sum, next_radii = solve_lp(np.vstack([centers[:i], next_center[None, :], centers[i+1:]]))\n                                if next_sum > current_sum + 1e-8:\n                                    current_sum = next_sum\n                                    current_radii = next_radii\n                                    centers[i] = next_center\n                                else:\n                                    break\n                        else:\n                            # Revert if no improvement\n                            centers[i] = old_center\n                            \n        # Update global best result\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = current_radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:56:35.884647",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 390,
        "candidates_token_count": 1702,
        "thoughts_token_count": 22429
      },
      "response_text_len": 5344
    }
  },
  "llm_call_duration_s": 144.6863111279672,
  "eval_duration_s": 19.26423255109694
}