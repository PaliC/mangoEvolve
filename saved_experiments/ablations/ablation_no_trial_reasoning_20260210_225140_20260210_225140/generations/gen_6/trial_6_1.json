{
  "trial_id": "trial_6_1",
  "generation": 6,
  "parent_id": "trial_5_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid approach of SLSQP for center optimization and Linear Programming for \n    optimal radius calculation.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    idx1, idx2 = np.triu_indices(N, k=1)\n    \n    def get_optimal_radii(centers):\n        \"\"\"\n        For fixed centers, calculates the optimal radii that maximize the sum of radii \n        using Linear Programming.\n        \"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        dists = np.sqrt(dx**2 + dy**2)\n        \n        # Linear constraints: r_i + r_j <= distance between centers\n        A = np.zeros((len(idx1), N))\n        A[np.arange(len(idx1)), idx1] = 1\n        A[np.arange(len(idx1)), idx2] = 1\n        b = dists\n        \n        # Boundary constraints: r_i <= distance to nearest edge\n        upper_bounds = np.minimum.reduce([x, 1-x, y, 1-y, np.full(N, 0.5)])\n        bounds = [(0, max(0.0, ub)) for ub in upper_bounds]\n        \n        # Maximize sum(r_i) <=> Minimize -sum(r_i)\n        res = linprog(-np.ones(N), A_ub=A, b_ub=b, bounds=bounds, method='highs')\n        \n        if res.success:\n            return res.x\n        else:\n            return np.zeros(N)\n\n    def objective(params):\n        # Minimize -sum(radii)\n        return -np.sum(params[2*N:])\n\n    def objective_jac(params):\n        # Gradient of objective: 0 for centers, -1 for radii\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1\n        return grad\n\n    def constraints_fun(params):\n        \"\"\"\n        Constraints for SLSQP:\n        1. Circle must be within square boundaries.\n        2. No overlap between circles.\n        All constraints must be >= 0.\n        \"\"\"\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        res = np.zeros(4*N + len(idx1))\n        \n        # Boundary constraints (x-r >= 0, 1-x-r >= 0, etc.)\n        res[0:N] = x - r\n        res[N:2*N] = 1 - x - r\n        res[2*N:3*N] = y - r\n        res[3*N:4*N] = 1 - y - r\n        \n        # Non-overlap constraints (dist_ij - (r_i + r_j) >= 0)\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        dists = np.sqrt(dx**2 + dy**2 + 1e-10)\n        res[4*N:] = dists - (r[idx1] + r[idx2])\n        return res\n\n    def constraints_jac(params):\n        \"\"\"\n        Analytical Jacobian for the constraints.\n        \"\"\"\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        jac = np.zeros((4*N + len(idx1), 3*N))\n        \n        # Boundary constraints Jacobian\n        indices = np.arange(N)\n        jac[indices, indices] = 1\n        jac[indices, 2*N + indices] = -1\n        \n        jac[N + indices, indices] = -1\n        jac[N + indices, 2*N + indices] = -1\n        \n        jac[2*N + indices, N + indices] = 1\n        jac[2*N + indices, 2*N + indices] = -1\n        \n        jac[3*N + indices, N + indices] = -1\n        jac[3*N + indices, 2*N + indices] = -1\n        \n        # Pairwise non-overlap Jacobian\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        dists = np.sqrt(dx**2 + dy**2 + 1e-10)\n        \n        row_idx = 4*N + np.arange(len(idx1))\n        jac[row_idx, idx1] = dx / dists\n        jac[row_idx, idx2] = -dx / dists\n        jac[row_idx, N + idx1] = dy / dists\n        jac[row_idx, N + idx2] = -dy / dists\n        jac[row_idx, 2*N + idx1] = -1\n        jac[row_idx, 2*N + idx2] = -1\n        \n        return jac\n\n    best_sum = 0.0\n    best_centers = None\n    best_radii = None\n    \n    iteration = 0\n    # Run optimization with multiple starts within the time limit\n    while time.time() - start_time < 280:\n        if iteration == 0:\n            # First attempt: Start near a 5x5 grid\n            grid = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(grid, grid)\n            x_init = np.append(xx.flatten(), 0.5)\n            y_init = np.append(yy.flatten(), 0.5)\n            x_init += np.random.normal(0, 0.01, N)\n            y_init += np.random.normal(0, 0.01, N)\n        else:\n            # Subsequent attempts: Random starts\n            x_init = np.random.uniform(0.1, 0.9, N)\n            y_init = np.random.uniform(0.1, 0.9, N)\n            \n        x_init = np.clip(x_init, 0.0, 1.0)\n        y_init = np.clip(y_init, 0.0, 1.0)\n        \n        # Initialize radii optimally for the starting centers\n        r_init = get_optimal_radii(np.column_stack((x_init, y_init)))\n        params = np.concatenate([x_init, y_init, r_init])\n        \n        # Run SLSQP optimization\n        res = minimize(\n            objective, params, jac=objective_jac,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac},\n            bounds=[(0, 1)]*2*N + [(0, 0.5)]*N,\n            options={'ftol': 1e-8, 'maxiter': 400}\n        )\n        \n        # Final refinement of radii for the optimized centers\n        final_params = res.x\n        centers = np.column_stack((final_params[:N], final_params[N:2*N]))\n        radii = get_optimal_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Update the global best solution\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers\n            best_radii = radii\n            \n        iteration += 1\n        \n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.628595991318123,
    "eval_time": 281.02297592163086,
    "error": null
  },
  "prompt": "\nImplement a hybrid approach for circle packing (N=26).\n1. The objective is to maximize sum of radii. For fixed centers (x, y), the optimal radii can be found using Linear Programming (scipy.optimize.linprog).\n2. Use SLSQP to optimize the centers. In each step or every few steps, 'reset' the radii by solving the LP.\n3. Use the Jacobian from trial_5_0 to guide the SLSQP solver.\n4. Incorporate the 'targeted removal' (removing smallest circles) from trial_5_0's shaking logic.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid approach of SLSQP for center optimization and Linear Programming for \n    optimal radius calculation.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    idx1, idx2 = np.triu_indices(N, k=1)\n    \n    def get_optimal_radii(centers):\n        \"\"\"\n        For fixed centers, calculates the optimal radii that maximize the sum of radii \n        using Linear Programming.\n        \"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        dists = np.sqrt(dx**2 + dy**2)\n        \n        # Linear constraints: r_i + r_j <= distance between centers\n        A = np.zeros((len(idx1), N))\n        A[np.arange(len(idx1)), idx1] = 1\n        A[np.arange(len(idx1)), idx2] = 1\n        b = dists\n        \n        # Boundary constraints: r_i <= distance to nearest edge\n        upper_bounds = np.minimum.reduce([x, 1-x, y, 1-y, np.full(N, 0.5)])\n        bounds = [(0, max(0.0, ub)) for ub in upper_bounds]\n        \n        # Maximize sum(r_i) <=> Minimize -sum(r_i)\n        res = linprog(-np.ones(N), A_ub=A, b_ub=b, bounds=bounds, method='highs')\n        \n        if res.success:\n            return res.x\n        else:\n            return np.zeros(N)\n\n    def objective(params):\n        # Minimize -sum(radii)\n        return -np.sum(params[2*N:])\n\n    def objective_jac(params):\n        # Gradient of objective: 0 for centers, -1 for radii\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1\n        return grad\n\n    def constraints_fun(params):\n        \"\"\"\n        Constraints for SLSQP:\n        1. Circle must be within square boundaries.\n        2. No overlap between circles.\n        All constraints must be >= 0.\n        \"\"\"\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        res = np.zeros(4*N + len(idx1))\n        \n        # Boundary constraints (x-r >= 0, 1-x-r >= 0, etc.)\n        res[0:N] = x - r\n        res[N:2*N] = 1 - x - r\n        res[2*N:3*N] = y - r\n        res[3*N:4*N] = 1 - y - r\n        \n        # Non-overlap constraints (dist_ij - (r_i + r_j) >= 0)\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        dists = np.sqrt(dx**2 + dy**2 + 1e-10)\n        res[4*N:] = dists - (r[idx1] + r[idx2])\n        return res\n\n    def constraints_jac(params):\n        \"\"\"\n        Analytical Jacobian for the constraints.\n        \"\"\"\n        x, y, r = params[:N], params[N:2*N], params[2*N:]\n        jac = np.zeros((4*N + len(idx1), 3*N))\n        \n        # Boundary constraints Jacobian\n        indices = np.arange(N)\n        jac[indices, indices] = 1\n        jac[indices, 2*N + indices] = -1\n        \n        jac[N + indices, indices] = -1\n        jac[N + indices, 2*N + indices] = -1\n        \n        jac[2*N + indices, N + indices] = 1\n        jac[2*N + indices, 2*N + indices] = -1\n        \n        jac[3*N + indices, N + indices] = -1\n        jac[3*N + indices, 2*N + indices] = -1\n        \n        # Pairwise non-overlap Jacobian\n        dx = x[idx1] - x[idx2]\n        dy = y[idx1] - y[idx2]\n        dists = np.sqrt(dx**2 + dy**2 + 1e-10)\n        \n        row_idx = 4*N + np.arange(len(idx1))\n        jac[row_idx, idx1] = dx / dists\n        jac[row_idx, idx2] = -dx / dists\n        jac[row_idx, N + idx1] = dy / dists\n        jac[row_idx, N + idx2] = -dy / dists\n        jac[row_idx, 2*N + idx1] = -1\n        jac[row_idx, 2*N + idx2] = -1\n        \n        return jac\n\n    best_sum = 0.0\n    best_centers = None\n    best_radii = None\n    \n    iteration = 0\n    # Run optimization with multiple starts within the time limit\n    while time.time() - start_time < 280:\n        if iteration == 0:\n            # First attempt: Start near a 5x5 grid\n            grid = np.linspace(0.1, 0.9, 5)\n            xx, yy = np.meshgrid(grid, grid)\n            x_init = np.append(xx.flatten(), 0.5)\n            y_init = np.append(yy.flatten(), 0.5)\n            x_init += np.random.normal(0, 0.01, N)\n            y_init += np.random.normal(0, 0.01, N)\n        else:\n            # Subsequent attempts: Random starts\n            x_init = np.random.uniform(0.1, 0.9, N)\n            y_init = np.random.uniform(0.1, 0.9, N)\n            \n        x_init = np.clip(x_init, 0.0, 1.0)\n        y_init = np.clip(y_init, 0.0, 1.0)\n        \n        # Initialize radii optimally for the starting centers\n        r_init = get_optimal_radii(np.column_stack((x_init, y_init)))\n        params = np.concatenate([x_init, y_init, r_init])\n        \n        # Run SLSQP optimization\n        res = minimize(\n            objective, params, jac=objective_jac,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac},\n            bounds=[(0, 1)]*2*N + [(0, 0.5)]*N,\n            options={'ftol': 1e-8, 'maxiter': 400}\n        )\n        \n        # Final refinement of radii for the optimized centers\n        final_params = res.x\n        centers = np.column_stack((final_params[:N], final_params[N:2*N]))\n        radii = get_optimal_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Update the global best solution\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers\n            best_radii = radii\n            \n        iteration += 1\n        \n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:46:44.865148",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 355,
        "candidates_token_count": 1897,
        "thoughts_token_count": 21000
      },
      "response_text_len": 5485
    }
  },
  "llm_call_duration_s": 131.97722888400313,
  "eval_duration_s": 281.02298404998146
}