{
  "trial_id": "trial_6_4",
  "generation": 6,
  "parent_id": "trial_5_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a (1+1)-ES (Evolution Strategy) on top of the SLSQP solver.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Precompute indices for vectorized Jacobian\n    IU = np.triu_indices(N, k=1)\n    \n    def objective(v):\n        # We want to maximize the sum of radii, so we minimize -sum(radii)\n        return -np.sum(v[2*N:])\n    \n    def jac_objective(v):\n        # Gradient of the objective: 0 for x and y, -1 for r\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def constraints(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        \n        c = np.zeros(4*N + N*(N-1)//2)\n        # Boundary constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        \n        # Overlap constraints: (x_i-x_j)^2 + (y_i-y_j)^2 >= (r_i+r_j)^2\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dr = r[:, None] + r[None, :]\n        dist_sq = dx**2 + dy**2 - dr**2\n        \n        c[4*N:] = dist_sq[IU]\n        return c\n\n    def jac_constraints(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        jac = np.zeros((4*N + N*(N-1)//2, 3*N))\n        \n        # Boundary constraints derivatives\n        idx_n = np.arange(N)\n        # d/dx_i (x_i - r_i) = 1, d/dr_i = -1\n        jac[idx_n, idx_n] = 1.0\n        jac[idx_n, 2*N + idx_n] = -1.0\n        # d/dx_i (1 - x_i - r_i) = -1, d/dr_i = -1\n        jac[N + idx_n, idx_n] = -1.0\n        jac[N + idx_n, 2*N + idx_n] = -1.0\n        # d/dy_i (y_i - r_i) = 1, d/dr_i = -1\n        jac[2*N + idx_n, N + idx_n] = 1.0\n        jac[2*N + idx_n, 2*N + idx_n] = -1.0\n        # d/dy_i (1 - y_i - r_i) = -1, d/dr_i = -1\n        jac[3*N + idx_n, N + idx_n] = -1.0\n        jac[3*N + idx_n, 2*N + idx_n] = -1.0\n        \n        # Overlap constraints derivatives\n        idx_overlap = 4*N\n        i, j = IU\n        dx = x[i] - x[j]\n        dy = y[i] - y[j]\n        dr = r[i] + r[j]\n        \n        rows = idx_overlap + np.arange(len(i))\n        # d/dx_i = 2(x_i-x_j), d/dx_j = -2(x_i-x_j)\n        jac[rows, i] = 2*dx\n        jac[rows, j] = -2*dx\n        # d/dy_i = 2(y_i-y_j), d/dy_j = -2(y_i-y_j)\n        jac[rows, N+i] = 2*dy\n        jac[rows, N+j] = -2*dy\n        # d/dr_i = -2(r_i+r_j), d/dr_j = -2(r_i+r_j)\n        jac[rows, 2*N+i] = -2*dr\n        jac[rows, 2*N+j] = -2*dr\n        return jac\n\n    def refine(v, maxiter=50):\n        bounds = [(0, 1)]*N + [(0, 1)]*N + [(0, 0.5)]*N\n        res = minimize(\n            objective, v, method='SLSQP', jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            bounds=bounds,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        return res.x\n\n    def random_init():\n        x = np.random.rand(N)\n        y = np.random.rand(N)\n        r = np.full(N, 0.01)\n        return np.concatenate([x, y, r])\n\n    def grid_init():\n        # 5x5 grid + 1 extra circle\n        coords = np.linspace(0.1, 0.9, 5)\n        xx, yy = np.meshgrid(coords, coords)\n        x = np.concatenate([xx.flatten(), [0.5]])\n        y = np.concatenate([yy.flatten(), [0.5]])\n        r = np.full(N, 0.01)\n        return np.concatenate([x, y, r])\n\n    def mutate(v, sigma):\n        x = v[:N].copy()\n        y = v[N:2*N].copy()\n        r = v[2*N:].copy()\n        \n        # Jitter positions and radii\n        x += np.random.randn(N) * sigma\n        y += np.random.randn(N) * sigma\n        r += np.random.randn(N) * sigma * 0.1\n        \n        # Targeted removal of the smallest radii circles\n        num_to_remove = np.random.randint(1, 3)\n        # Add tiny noise to avoid picking the same indices if radii are equal\n        idx_to_remove = np.argsort(r + np.random.randn(N) * 1e-9)[:num_to_remove]\n        x[idx_to_remove] = np.random.rand(num_to_remove)\n        y[idx_to_remove] = np.random.rand(num_to_remove)\n        r[idx_to_remove] = 0.01\n        \n        return np.concatenate([np.clip(x, 0, 1), np.clip(y, 0, 1), np.clip(r, 0, 0.5)])\n\n    # Initialize with a grid and several random starts\n    best_v = refine(grid_init(), maxiter=100)\n    current_sum = np.sum(best_v[2*N:])\n    \n    for _ in range(3):\n        v_rand = random_init()\n        v_refined = refine(v_rand, maxiter=50)\n        s = np.sum(v_refined[2*N:])\n        if s > current_sum:\n            best_v = v_refined\n            current_sum = s\n\n    # ES optimization loop\n    initial_sigma = 0.05\n    iteration = 0\n    while time.time() - start_time < 270:\n        sigma = initial_sigma * (0.985 ** iteration)\n        v_mutant = mutate(best_v, sigma)\n        v_refined = refine(v_mutant, maxiter=60)\n        \n        new_sum = np.sum(v_refined[2*N:])\n        if new_sum > current_sum:\n            best_v = v_refined\n            current_sum = new_sum\n        iteration += 1\n\n    # Final high-precision refinement\n    bounds = [(0, 1)]*N + [(0, 1)]*N + [(0, 0.5)]*N\n    final_res = minimize(\n        objective, best_v, method='SLSQP', jac=jac_objective,\n        constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n        bounds=bounds,\n        options={'maxiter': 400, 'ftol': 1e-12}\n    )\n    best_v = final_res.x\n    \n    centers = np.column_stack((best_v[:N], best_v[N:2*N]))\n    radii = best_v[2*N:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.563782947681953,
    "eval_time": 270.99770283699036,
    "error": null
  },
  "prompt": "\nImplement a simple (1+1)-ES (Evolution Strategy) on top of the SLSQP solver.\n1. Maintain a 'best' configuration.\n2. Generate a 'mutant' by applying the shaking logic from trial_5_0 (targeted removal + jitter).\n3. Refine the mutant using SLSQP with high precision.\n4. If the mutant is better, it becomes the new 'best'.\n5. Use a cooling schedule for the jitter magnitude.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a (1+1)-ES (Evolution Strategy) on top of the SLSQP solver.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Precompute indices for vectorized Jacobian\n    IU = np.triu_indices(N, k=1)\n    \n    def objective(v):\n        # We want to maximize the sum of radii, so we minimize -sum(radii)\n        return -np.sum(v[2*N:])\n    \n    def jac_objective(v):\n        # Gradient of the objective: 0 for x and y, -1 for r\n        j = np.zeros(3*N)\n        j[2*N:] = -1.0\n        return j\n\n    def constraints(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        \n        c = np.zeros(4*N + N*(N-1)//2)\n        # Boundary constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        \n        # Overlap constraints: (x_i-x_j)^2 + (y_i-y_j)^2 >= (r_i+r_j)^2\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dr = r[:, None] + r[None, :]\n        dist_sq = dx**2 + dy**2 - dr**2\n        \n        c[4*N:] = dist_sq[IU]\n        return c\n\n    def jac_constraints(v):\n        x = v[:N]\n        y = v[N:2*N]\n        r = v[2*N:]\n        jac = np.zeros((4*N + N*(N-1)//2, 3*N))\n        \n        # Boundary constraints derivatives\n        idx_n = np.arange(N)\n        # d/dx_i (x_i - r_i) = 1, d/dr_i = -1\n        jac[idx_n, idx_n] = 1.0\n        jac[idx_n, 2*N + idx_n] = -1.0\n        # d/dx_i (1 - x_i - r_i) = -1, d/dr_i = -1\n        jac[N + idx_n, idx_n] = -1.0\n        jac[N + idx_n, 2*N + idx_n] = -1.0\n        # d/dy_i (y_i - r_i) = 1, d/dr_i = -1\n        jac[2*N + idx_n, N + idx_n] = 1.0\n        jac[2*N + idx_n, 2*N + idx_n] = -1.0\n        # d/dy_i (1 - y_i - r_i) = -1, d/dr_i = -1\n        jac[3*N + idx_n, N + idx_n] = -1.0\n        jac[3*N + idx_n, 2*N + idx_n] = -1.0\n        \n        # Overlap constraints derivatives\n        idx_overlap = 4*N\n        i, j = IU\n        dx = x[i] - x[j]\n        dy = y[i] - y[j]\n        dr = r[i] + r[j]\n        \n        rows = idx_overlap + np.arange(len(i))\n        # d/dx_i = 2(x_i-x_j), d/dx_j = -2(x_i-x_j)\n        jac[rows, i] = 2*dx\n        jac[rows, j] = -2*dx\n        # d/dy_i = 2(y_i-y_j), d/dy_j = -2(y_i-y_j)\n        jac[rows, N+i] = 2*dy\n        jac[rows, N+j] = -2*dy\n        # d/dr_i = -2(r_i+r_j), d/dr_j = -2(r_i+r_j)\n        jac[rows, 2*N+i] = -2*dr\n        jac[rows, 2*N+j] = -2*dr\n        return jac\n\n    def refine(v, maxiter=50):\n        bounds = [(0, 1)]*N + [(0, 1)]*N + [(0, 0.5)]*N\n        res = minimize(\n            objective, v, method='SLSQP', jac=jac_objective,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            bounds=bounds,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        return res.x\n\n    def random_init():\n        x = np.random.rand(N)\n        y = np.random.rand(N)\n        r = np.full(N, 0.01)\n        return np.concatenate([x, y, r])\n\n    def grid_init():\n        # 5x5 grid + 1 extra circle\n        coords = np.linspace(0.1, 0.9, 5)\n        xx, yy = np.meshgrid(coords, coords)\n        x = np.concatenate([xx.flatten(), [0.5]])\n        y = np.concatenate([yy.flatten(), [0.5]])\n        r = np.full(N, 0.01)\n        return np.concatenate([x, y, r])\n\n    def mutate(v, sigma):\n        x = v[:N].copy()\n        y = v[N:2*N].copy()\n        r = v[2*N:].copy()\n        \n        # Jitter positions and radii\n        x += np.random.randn(N) * sigma\n        y += np.random.randn(N) * sigma\n        r += np.random.randn(N) * sigma * 0.1\n        \n        # Targeted removal of the smallest radii circles\n        num_to_remove = np.random.randint(1, 3)\n        # Add tiny noise to avoid picking the same indices if radii are equal\n        idx_to_remove = np.argsort(r + np.random.randn(N) * 1e-9)[:num_to_remove]\n        x[idx_to_remove] = np.random.rand(num_to_remove)\n        y[idx_to_remove] = np.random.rand(num_to_remove)\n        r[idx_to_remove] = 0.01\n        \n        return np.concatenate([np.clip(x, 0, 1), np.clip(y, 0, 1), np.clip(r, 0, 0.5)])\n\n    # Initialize with a grid and several random starts\n    best_v = refine(grid_init(), maxiter=100)\n    current_sum = np.sum(best_v[2*N:])\n    \n    for _ in range(3):\n        v_rand = random_init()\n        v_refined = refine(v_rand, maxiter=50)\n        s = np.sum(v_refined[2*N:])\n        if s > current_sum:\n            best_v = v_refined\n            current_sum = s\n\n    # ES optimization loop\n    initial_sigma = 0.05\n    iteration = 0\n    while time.time() - start_time < 270:\n        sigma = initial_sigma * (0.985 ** iteration)\n        v_mutant = mutate(best_v, sigma)\n        v_refined = refine(v_mutant, maxiter=60)\n        \n        new_sum = np.sum(v_refined[2*N:])\n        if new_sum > current_sum:\n            best_v = v_refined\n            current_sum = new_sum\n        iteration += 1\n\n    # Final high-precision refinement\n    bounds = [(0, 1)]*N + [(0, 1)]*N + [(0, 0.5)]*N\n    final_res = minimize(\n        objective, best_v, method='SLSQP', jac=jac_objective,\n        constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n        bounds=bounds,\n        options={'maxiter': 400, 'ftol': 1e-12}\n    )\n    best_v = final_res.x\n    \n    centers = np.column_stack((best_v[:N], best_v[N:2*N]))\n    radii = best_v[2*N:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:46:23.656472",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 329,
        "candidates_token_count": 2260,
        "thoughts_token_count": 19646
      },
      "response_text_len": 5588
    }
  },
  "llm_call_duration_s": 120.78862444905099,
  "eval_duration_s": 270.99770981504116
}