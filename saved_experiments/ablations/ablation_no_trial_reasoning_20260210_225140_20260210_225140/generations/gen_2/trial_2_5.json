{
  "trial_id": "trial_2_5",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Shrink-and-Expand strategy with multiple initializations and local optimizations.\n    \"\"\"\n    n = 26\n    iu2 = np.triu_indices(n, k=1)\n    num_overlap = n * (n - 1) // 2\n    \n    # Precompute row and col indices for the Jacobian of overlap constraints\n    row_idx_overlap = np.repeat(np.arange(4 * n, 4 * n + num_overlap), 6)\n    col_idx_overlap = np.zeros(num_overlap * 6, dtype=int)\n    col_idx_overlap[0::6] = iu2[0]\n    col_idx_overlap[1::6] = iu2[1]\n    col_idx_overlap[2::6] = n + iu2[0]\n    col_idx_overlap[3::6] = n + iu2[1]\n    col_idx_overlap[4::6] = 2 * n + iu2[0]\n    col_idx_overlap[5::6] = 2 * n + iu2[1]\n\n    def objective(p):\n        # Minimize the negative sum to maximize the sum\n        return -np.sum(p[2*n:])\n\n    def grad_objective(p):\n        g = np.zeros(3*n)\n        g[2*n:] = -1.0\n        return g\n\n    def all_cons(p, L):\n        x, y, r = p[:n], p[n:2*n], p[2*n:]\n        c = np.zeros(4 * n + num_overlap)\n        # Boundary constraints: x_i - r_i >= 0, L - x_i - r_i >= 0, etc.\n        c[0:n] = x - r\n        c[n:2*n] = L - x - r\n        c[2*n:3*n] = y - r\n        c[3*n:4*n] = L - y - r\n        # Overlap constraints: (x_i-x_j)^2 + (y_i-y_j)^2 - (r_i+r_j)^2 >= 0\n        dx = x[iu2[0]] - x[iu2[1]]\n        dy = y[iu2[0]] - y[iu2[1]]\n        dr = r[iu2[0]] + r[iu2[1]]\n        c[4*n:] = dx**2 + dy**2 - dr**2\n        return c\n\n    def jac_all_cons(p, L):\n        x, y, r = p[:n], p[n:2*n], p[2*n:]\n        jac = np.zeros((4 * n + num_overlap, 3 * n))\n        # Boundary constraints derivatives\n        idx_n = np.arange(n)\n        jac[idx_n, idx_n] = 1.0; jac[idx_n, 2*n+idx_n] = -1.0\n        jac[n+idx_n, idx_n] = -1.0; jac[n+idx_n, 2*n+idx_n] = -1.0\n        jac[2*n+idx_n, n+idx_n] = 1.0; jac[2*n+idx_n, 2*n+idx_n] = -1.0\n        jac[3*n+idx_n, n+idx_n] = -1.0; jac[3*n+idx_n, 2*n+idx_n] = -1.0\n        \n        # Overlap constraints derivatives\n        i_idx, j_idx = iu2[0], iu2[1]\n        dx, dy, dr = x[i_idx]-x[j_idx], y[i_idx]-y[j_idx], r[i_idx]+r[j_idx]\n        data = np.zeros(num_overlap * 6)\n        data[0::6], data[1::6] = 2*dx, -2*dx\n        data[2::6], data[3::6] = 2*dy, -2*dy\n        data[4::6], data[5::6] = -2*dr, -2*dr\n        jac[row_idx_overlap, col_idx_overlap] = data\n        return jac\n\n    def repel(p, L):\n        # Heuristic to resolve initial overlaps and boundary violations\n        x, y, r = p[:n].copy(), p[n:2*n].copy(), p[2*n:].copy()\n        for _ in range(150):\n            dx, dy = x[iu2[0]]-x[iu2[1]], y[iu2[0]]-y[iu2[1]]\n            d = np.sqrt(dx**2 + dy**2)\n            dr = r[iu2[0]] + r[iu2[1]]\n            mask = d < dr\n            if not np.any(mask): break\n            for k in np.where(mask)[0]:\n                i, j = iu2[0][k], iu2[1][k]\n                if d[k] > 1e-9:\n                    push = (dr[k] - d[k]) / 2\n                    x[i] += dx[k]/d[k] * push; y[i] += dy[k]/d[k] * push\n                    x[j] -= dx[k]/d[k] * push; y[j] -= dy[k]/d[k] * push\n                else:\n                    x[i] += np.random.normal(0, 0.01)\n                    y[i] += np.random.normal(0, 0.01)\n            for i in range(n):\n                x[i] = np.clip(x[i], r[i], L - r[i])\n                y[i] = np.clip(y[i], r[i], L - r[i])\n        return np.concatenate([x, y, r])\n\n    def get_start(trial):\n        # Various initialization strategies to find diverse packings\n        if trial == 0:\n            xs, ys = np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5)\n            X, Y = np.meshgrid(xs, ys); x, y = X.flatten(), Y.flatten()\n            x, y = np.append(x, 0.5), np.append(y, 0.5)\n        elif trial == 1:\n            xs, ys = np.linspace(0.1, 0.9, 4), np.linspace(0.1, 0.9, 6)\n            X, Y = np.meshgrid(xs, ys); x, y = X.flatten(), Y.flatten()\n            x, y = np.append(x, [0.2, 0.8]), np.append(y, [0.2, 0.8])\n        elif trial == 2:\n            xs, ys = np.linspace(0.1, 0.9, 2), np.linspace(0.05, 0.95, 13)\n            X, Y = np.meshgrid(xs, ys); x, y = X.flatten(), Y.flatten()\n        elif trial == 3:\n            xs, ys = np.linspace(0.1, 0.9, 3), np.linspace(0.05, 0.95, 9)\n            X, Y = np.meshgrid(xs, ys); x, y = X.flatten()[:26], Y.flatten()[:26]\n        else:\n            x, y = np.random.rand(n), np.random.rand(n)\n        r = np.ones(n) * 0.08\n        x += np.random.normal(0, 0.01, n)\n        y += np.random.normal(0, 0.01, n)\n        return np.concatenate([x, y, r])\n\n    best_sum = 0\n    best_p = None\n    # Run multiple trials with different starting configurations\n    for trial in range(8):\n        p = get_start(trial)\n        # Squeeze boundary from L=1.1 to L=1.0\n        for L in [1.1, 1.05, 1.02, 1.0]:\n            if L == 1.1: p = repel(p, L)\n            bounds = [(0, L)] * (2*n) + [(0.001, L/2)] * n\n            res = minimize(objective, p, jac=grad_objective,\n                           constraints={'type': 'ineq', 'fun': all_cons, 'jac': jac_all_cons, 'args': (L,)},\n                           bounds=bounds, method='SLSQP', \n                           options={'maxiter': 100 if L > 1.0 else 500, 'ftol': 1e-8})\n            p = res.x\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_p = p\n\n    # Ensure feasibility with a final post-processing step\n    x, y, r = best_p[:n], best_p[n:2*n], best_p[2*n:]\n    for i in range(n):\n        r[i] = max(0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n    for _ in range(30):\n        dx, dy = x[iu2[0]]-x[iu2[1]], y[iu2[0]]-y[iu2[1]]\n        d = np.sqrt(dx**2 + dy**2)\n        dr = r[iu2[0]] + r[iu2[1]]\n        mask = d < dr\n        if not np.any(mask): break\n        for k in np.where(mask)[0]:\n            i, j = iu2[0][k], iu2[1][k]\n            if dr[k] > 0:\n                ratio = d[k] / dr[k]\n                r[i] *= (ratio + 0.999999999) / 2\n                r[j] *= (ratio + 0.999999999) / 2\n    \n    centers = np.stack([x, y], axis=1)\n    return centers, r, np.sum(r)",
  "metrics": {
    "valid": true,
    "score": 0.06921770870481192,
    "eval_time": 36.191253662109375,
    "error": null
  },
  "prompt": "Implement a \"Shrink-and-Expand\" strategy.\n1. Start by packing 26 circles in a slightly larger square (e.g., [0, 1.05] x [0, 1.05]) or with slightly reduced radii requirements.\n2. Gradually \"squeeze\" the boundary back to [0, 1] x [0, 1] while running local optimizations.\n3. This often helps circles find their way past each other into a more optimal global configuration.\n4. Use the best results from previous trials as starting points for this process.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Shrink-and-Expand strategy with multiple initializations and local optimizations.\n    \"\"\"\n    n = 26\n    iu2 = np.triu_indices(n, k=1)\n    num_overlap = n * (n - 1) // 2\n    \n    # Precompute row and col indices for the Jacobian of overlap constraints\n    row_idx_overlap = np.repeat(np.arange(4 * n, 4 * n + num_overlap), 6)\n    col_idx_overlap = np.zeros(num_overlap * 6, dtype=int)\n    col_idx_overlap[0::6] = iu2[0]\n    col_idx_overlap[1::6] = iu2[1]\n    col_idx_overlap[2::6] = n + iu2[0]\n    col_idx_overlap[3::6] = n + iu2[1]\n    col_idx_overlap[4::6] = 2 * n + iu2[0]\n    col_idx_overlap[5::6] = 2 * n + iu2[1]\n\n    def objective(p):\n        # Minimize the negative sum to maximize the sum\n        return -np.sum(p[2*n:])\n\n    def grad_objective(p):\n        g = np.zeros(3*n)\n        g[2*n:] = -1.0\n        return g\n\n    def all_cons(p, L):\n        x, y, r = p[:n], p[n:2*n], p[2*n:]\n        c = np.zeros(4 * n + num_overlap)\n        # Boundary constraints: x_i - r_i >= 0, L - x_i - r_i >= 0, etc.\n        c[0:n] = x - r\n        c[n:2*n] = L - x - r\n        c[2*n:3*n] = y - r\n        c[3*n:4*n] = L - y - r\n        # Overlap constraints: (x_i-x_j)^2 + (y_i-y_j)^2 - (r_i+r_j)^2 >= 0\n        dx = x[iu2[0]] - x[iu2[1]]\n        dy = y[iu2[0]] - y[iu2[1]]\n        dr = r[iu2[0]] + r[iu2[1]]\n        c[4*n:] = dx**2 + dy**2 - dr**2\n        return c\n\n    def jac_all_cons(p, L):\n        x, y, r = p[:n], p[n:2*n], p[2*n:]\n        jac = np.zeros((4 * n + num_overlap, 3 * n))\n        # Boundary constraints derivatives\n        idx_n = np.arange(n)\n        jac[idx_n, idx_n] = 1.0; jac[idx_n, 2*n+idx_n] = -1.0\n        jac[n+idx_n, idx_n] = -1.0; jac[n+idx_n, 2*n+idx_n] = -1.0\n        jac[2*n+idx_n, n+idx_n] = 1.0; jac[2*n+idx_n, 2*n+idx_n] = -1.0\n        jac[3*n+idx_n, n+idx_n] = -1.0; jac[3*n+idx_n, 2*n+idx_n] = -1.0\n        \n        # Overlap constraints derivatives\n        i_idx, j_idx = iu2[0], iu2[1]\n        dx, dy, dr = x[i_idx]-x[j_idx], y[i_idx]-y[j_idx], r[i_idx]+r[j_idx]\n        data = np.zeros(num_overlap * 6)\n        data[0::6], data[1::6] = 2*dx, -2*dx\n        data[2::6], data[3::6] = 2*dy, -2*dy\n        data[4::6], data[5::6] = -2*dr, -2*dr\n        jac[row_idx_overlap, col_idx_overlap] = data\n        return jac\n\n    def repel(p, L):\n        # Heuristic to resolve initial overlaps and boundary violations\n        x, y, r = p[:n].copy(), p[n:2*n].copy(), p[2*n:].copy()\n        for _ in range(150):\n            dx, dy = x[iu2[0]]-x[iu2[1]], y[iu2[0]]-y[iu2[1]]\n            d = np.sqrt(dx**2 + dy**2)\n            dr = r[iu2[0]] + r[iu2[1]]\n            mask = d < dr\n            if not np.any(mask): break\n            for k in np.where(mask)[0]:\n                i, j = iu2[0][k], iu2[1][k]\n                if d[k] > 1e-9:\n                    push = (dr[k] - d[k]) / 2\n                    x[i] += dx[k]/d[k] * push; y[i] += dy[k]/d[k] * push\n                    x[j] -= dx[k]/d[k] * push; y[j] -= dy[k]/d[k] * push\n                else:\n                    x[i] += np.random.normal(0, 0.01)\n                    y[i] += np.random.normal(0, 0.01)\n            for i in range(n):\n                x[i] = np.clip(x[i], r[i], L - r[i])\n                y[i] = np.clip(y[i], r[i], L - r[i])\n        return np.concatenate([x, y, r])\n\n    def get_start(trial):\n        # Various initialization strategies to find diverse packings\n        if trial == 0:\n            xs, ys = np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5)\n            X, Y = np.meshgrid(xs, ys); x, y = X.flatten(), Y.flatten()\n            x, y = np.append(x, 0.5), np.append(y, 0.5)\n        elif trial == 1:\n            xs, ys = np.linspace(0.1, 0.9, 4), np.linspace(0.1, 0.9, 6)\n            X, Y = np.meshgrid(xs, ys); x, y = X.flatten(), Y.flatten()\n            x, y = np.append(x, [0.2, 0.8]), np.append(y, [0.2, 0.8])\n        elif trial == 2:\n            xs, ys = np.linspace(0.1, 0.9, 2), np.linspace(0.05, 0.95, 13)\n            X, Y = np.meshgrid(xs, ys); x, y = X.flatten(), Y.flatten()\n        elif trial == 3:\n            xs, ys = np.linspace(0.1, 0.9, 3), np.linspace(0.05, 0.95, 9)\n            X, Y = np.meshgrid(xs, ys); x, y = X.flatten()[:26], Y.flatten()[:26]\n        else:\n            x, y = np.random.rand(n), np.random.rand(n)\n        r = np.ones(n) * 0.08\n        x += np.random.normal(0, 0.01, n)\n        y += np.random.normal(0, 0.01, n)\n        return np.concatenate([x, y, r])\n\n    best_sum = 0\n    best_p = None\n    # Run multiple trials with different starting configurations\n    for trial in range(8):\n        p = get_start(trial)\n        # Squeeze boundary from L=1.1 to L=1.0\n        for L in [1.1, 1.05, 1.02, 1.0]:\n            if L == 1.1: p = repel(p, L)\n            bounds = [(0, L)] * (2*n) + [(0.001, L/2)] * n\n            res = minimize(objective, p, jac=grad_objective,\n                           constraints={'type': 'ineq', 'fun': all_cons, 'jac': jac_all_cons, 'args': (L,)},\n                           bounds=bounds, method='SLSQP', \n                           options={'maxiter': 100 if L > 1.0 else 500, 'ftol': 1e-8})\n            p = res.x\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_p = p\n\n    # Ensure feasibility with a final post-processing step\n    x, y, r = best_p[:n], best_p[n:2*n], best_p[2*n:]\n    for i in range(n):\n        r[i] = max(0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n    for _ in range(30):\n        dx, dy = x[iu2[0]]-x[iu2[1]], y[iu2[0]]-y[iu2[1]]\n        d = np.sqrt(dx**2 + dy**2)\n        dr = r[iu2[0]] + r[iu2[1]]\n        mask = d < dr\n        if not np.any(mask): break\n        for k in np.where(mask)[0]:\n            i, j = iu2[0][k], iu2[1][k]\n            if dr[k] > 0:\n                ratio = d[k] / dr[k]\n                r[i] *= (ratio + 0.999999999) / 2\n                r[j] *= (ratio + 0.999999999) / 2\n    \n    centers = np.stack([x, y], axis=1)\n    return centers, r, np.sum(r)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:10:52.441599",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 352,
        "candidates_token_count": 2576,
        "thoughts_token_count": 25999
      },
      "response_text_len": 6084
    }
  },
  "llm_call_duration_s": 167.00987699104007,
  "eval_duration_s": 36.19126062002033
}