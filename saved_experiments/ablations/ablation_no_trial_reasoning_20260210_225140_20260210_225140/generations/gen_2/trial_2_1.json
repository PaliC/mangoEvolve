{
  "trial_id": "trial_2_1",
  "generation": 2,
  "parent_id": "trial_1_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(centers):\n    \"\"\"\n    Solves the linear program to maximize the sum of radii for fixed circle centers.\n    \"\"\"\n    N = len(centers)\n    c = -np.ones(N)  # Objective: maximize sum(r_i)\n    \n    # Boundary constraints using variable bounds: 0 <= r_i <= min(x, 1-x, y, 1-y)\n    bounds = []\n    for i in range(N):\n        x, y = centers[i]\n        max_r = min(x, 1 - x, y, 1 - y)\n        bounds.append((0, max(0.0, float(max_r))))\n        \n    # Overlap constraints: r_i + r_j <= d_ij\n    num_overlap = N * (N - 1) // 2\n    A_ub = np.zeros((num_overlap, N))\n    b_ub = np.zeros(num_overlap)\n    \n    curr = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            d_ij = np.linalg.norm(centers[i] - centers[j])\n            A_ub[curr, i] = 1\n            A_ub[curr, j] = 1\n            b_ub[curr] = float(d_ij)\n            curr += 1\n            \n    # Try multiple linprog methods for robustness\n    res = None\n    for method in ['highs', 'revised simplex', 'interior-point']:\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=method)\n            if res.success:\n                break\n        except:\n            continue\n            \n    if res is not None and res.success:\n        radii = np.maximum(0, res.x)\n        return radii, float(np.sum(radii))\n    return np.zeros(N), 0.0\n\ndef energy(c_flat, N, r_t):\n    \"\"\"\n    A heuristic energy function to push circles apart and away from boundaries.\n    \"\"\"\n    c = c_flat.reshape((N, 2))\n    # Boundary penalty\n    e = np.sum(np.maximum(0, r_t - c)**2) + np.sum(np.maximum(0, c - (1 - r_t))**2)\n    # Overlap penalty\n    for i in range(N):\n        dists = np.linalg.norm(c[i] - c[i+1:], axis=1)\n        e += np.sum(np.maximum(0, 2 * r_t - dists)**2)\n    return e\n\ndef run_packing():\n    N = 26\n    # Best known equal radius for 26 circles in a unit square\n    r_target = 0.10138404061979463\n    \n    best_sum = 0.0\n    best_centers = None\n    best_radii = None\n    \n    # 1. Generate initial configurations\n    configs = []\n    \n    # Configuration A: 5x5 grid plus one circle\n    xs5 = np.linspace(0.1, 0.9, 5)\n    ys5 = np.linspace(0.1, 0.9, 5)\n    xi5, yi5 = np.meshgrid(xs5, ys5)\n    c55 = np.column_stack([xi5.flatten(), yi5.flatten()])\n    configs.append(np.vstack([c55, [0.5, 0.5]]))\n    \n    # Configuration B: 6x4 grid plus two circles\n    xs6 = np.linspace(0.1, 0.9, 6)\n    ys4 = np.linspace(0.1, 0.9, 4)\n    xi6, yi4 = np.meshgrid(xs6, ys4)\n    c64 = np.column_stack([xi6.flatten(), yi4.flatten()])\n    configs.append(np.vstack([c64, [0.5, 0.5], [0.51, 0.51]]))\n    \n    # Configuration C: Random starts\n    for _ in range(10):\n        configs.append(np.random.rand(N, 2))\n\n    # 2. Optimize each configuration using Energy Minimization + LP Refinement\n    for centers in configs:\n        # Annealing-like refinement of centers\n        current_c = centers.flatten()\n        for r_val in [0.08, 0.09, 0.1, r_target]:\n            res_e = minimize(energy, current_c, args=(N, r_val), method='L-BFGS-B', options={'maxiter': 400})\n            current_c = res_e.x\n        \n        refined_centers = np.clip(current_c.reshape((N, 2)), 0, 1)\n        radii, current_sum = solve_lp(refined_centers)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = refined_centers.copy()\n            best_radii = radii.copy()\n\n    # 3. Hybrid SLSQP Refinement on the best result found\n    if best_centers is not None:\n        # Variables: [x1, y1, ..., xN, yN, r1, ..., rN]\n        x0 = np.concatenate([best_centers.flatten(), best_radii])\n        \n        def obj_func(vars):\n            return -np.sum(vars[2*N:])\n            \n        def constraints_func(vars):\n            c = vars[:2*N].reshape((N, 2))\n            r = vars[2*N:]\n            # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n            b_cons = np.concatenate([c.flatten() - np.repeat(r, 2), 1.0 - c.flatten() - np.repeat(r, 2)])\n            # Overlap constraints: d_ij - (r_i + r_j) >= 0\n            idx1, idx2 = np.triu_indices(N, k=1)\n            dists = np.sqrt(np.sum((c[idx1] - c[idx2])**2, axis=1))\n            o_cons = dists - (r[idx1] + r[idx2])\n            return np.concatenate([b_cons, o_cons])\n        \n        res_slsqp = minimize(obj_func, x0, constraints={'type': 'ineq', 'fun': constraints_func}, \n                             method='SLSQP', options={'maxiter': 150})\n        \n        if res_slsqp.success:\n            final_centers = res_slsqp.x[:2*N].reshape((N, 2))\n            # Final LP Polish to ensure optimal radii for the final centers\n            final_radii, final_sum = solve_lp(final_centers)\n            if final_sum > best_sum:\n                best_sum = final_sum\n                best_centers = final_centers\n                best_radii = final_radii\n                \n    return best_centers, best_radii, float(best_sum)",
  "metrics": {
    "valid": true,
    "score": 2.621002512631316,
    "eval_time": 108.08188104629517,
    "error": null
  },
  "prompt": "Take the best configuration from trial_1_3 and implement a \"Hybrid LP-SLSQP\" approach.\nThe objective is to maximize sum(radii). For any fixed set of centers (x, y), the optimal radii can be found exactly using Linear Programming (scipy.optimize.linprog).\n1. Use SLSQP to optimize the centers (x, y).\n2. Inside the objective function or as a frequent polishing step, solve the LP to find the best radii for those centers.\n3. This decouples the non-convex center placement from the linear radii maximization.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(centers):\n    \"\"\"\n    Solves the linear program to maximize the sum of radii for fixed circle centers.\n    \"\"\"\n    N = len(centers)\n    c = -np.ones(N)  # Objective: maximize sum(r_i)\n    \n    # Boundary constraints using variable bounds: 0 <= r_i <= min(x, 1-x, y, 1-y)\n    bounds = []\n    for i in range(N):\n        x, y = centers[i]\n        max_r = min(x, 1 - x, y, 1 - y)\n        bounds.append((0, max(0.0, float(max_r))))\n        \n    # Overlap constraints: r_i + r_j <= d_ij\n    num_overlap = N * (N - 1) // 2\n    A_ub = np.zeros((num_overlap, N))\n    b_ub = np.zeros(num_overlap)\n    \n    curr = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            d_ij = np.linalg.norm(centers[i] - centers[j])\n            A_ub[curr, i] = 1\n            A_ub[curr, j] = 1\n            b_ub[curr] = float(d_ij)\n            curr += 1\n            \n    # Try multiple linprog methods for robustness\n    res = None\n    for method in ['highs', 'revised simplex', 'interior-point']:\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=method)\n            if res.success:\n                break\n        except:\n            continue\n            \n    if res is not None and res.success:\n        radii = np.maximum(0, res.x)\n        return radii, float(np.sum(radii))\n    return np.zeros(N), 0.0\n\ndef energy(c_flat, N, r_t):\n    \"\"\"\n    A heuristic energy function to push circles apart and away from boundaries.\n    \"\"\"\n    c = c_flat.reshape((N, 2))\n    # Boundary penalty\n    e = np.sum(np.maximum(0, r_t - c)**2) + np.sum(np.maximum(0, c - (1 - r_t))**2)\n    # Overlap penalty\n    for i in range(N):\n        dists = np.linalg.norm(c[i] - c[i+1:], axis=1)\n        e += np.sum(np.maximum(0, 2 * r_t - dists)**2)\n    return e\n\ndef run_packing():\n    N = 26\n    # Best known equal radius for 26 circles in a unit square\n    r_target = 0.10138404061979463\n    \n    best_sum = 0.0\n    best_centers = None\n    best_radii = None\n    \n    # 1. Generate initial configurations\n    configs = []\n    \n    # Configuration A: 5x5 grid plus one circle\n    xs5 = np.linspace(0.1, 0.9, 5)\n    ys5 = np.linspace(0.1, 0.9, 5)\n    xi5, yi5 = np.meshgrid(xs5, ys5)\n    c55 = np.column_stack([xi5.flatten(), yi5.flatten()])\n    configs.append(np.vstack([c55, [0.5, 0.5]]))\n    \n    # Configuration B: 6x4 grid plus two circles\n    xs6 = np.linspace(0.1, 0.9, 6)\n    ys4 = np.linspace(0.1, 0.9, 4)\n    xi6, yi4 = np.meshgrid(xs6, ys4)\n    c64 = np.column_stack([xi6.flatten(), yi4.flatten()])\n    configs.append(np.vstack([c64, [0.5, 0.5], [0.51, 0.51]]))\n    \n    # Configuration C: Random starts\n    for _ in range(10):\n        configs.append(np.random.rand(N, 2))\n\n    # 2. Optimize each configuration using Energy Minimization + LP Refinement\n    for centers in configs:\n        # Annealing-like refinement of centers\n        current_c = centers.flatten()\n        for r_val in [0.08, 0.09, 0.1, r_target]:\n            res_e = minimize(energy, current_c, args=(N, r_val), method='L-BFGS-B', options={'maxiter': 400})\n            current_c = res_e.x\n        \n        refined_centers = np.clip(current_c.reshape((N, 2)), 0, 1)\n        radii, current_sum = solve_lp(refined_centers)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = refined_centers.copy()\n            best_radii = radii.copy()\n\n    # 3. Hybrid SLSQP Refinement on the best result found\n    if best_centers is not None:\n        # Variables: [x1, y1, ..., xN, yN, r1, ..., rN]\n        x0 = np.concatenate([best_centers.flatten(), best_radii])\n        \n        def obj_func(vars):\n            return -np.sum(vars[2*N:])\n            \n        def constraints_func(vars):\n            c = vars[:2*N].reshape((N, 2))\n            r = vars[2*N:]\n            # Boundary constraints: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n            b_cons = np.concatenate([c.flatten() - np.repeat(r, 2), 1.0 - c.flatten() - np.repeat(r, 2)])\n            # Overlap constraints: d_ij - (r_i + r_j) >= 0\n            idx1, idx2 = np.triu_indices(N, k=1)\n            dists = np.sqrt(np.sum((c[idx1] - c[idx2])**2, axis=1))\n            o_cons = dists - (r[idx1] + r[idx2])\n            return np.concatenate([b_cons, o_cons])\n        \n        res_slsqp = minimize(obj_func, x0, constraints={'type': 'ineq', 'fun': constraints_func}, \n                             method='SLSQP', options={'maxiter': 150})\n        \n        if res_slsqp.success:\n            final_centers = res_slsqp.x[:2*N].reshape((N, 2))\n            # Final LP Polish to ensure optimal radii for the final centers\n            final_radii, final_sum = solve_lp(final_centers)\n            if final_sum > best_sum:\n                best_sum = final_sum\n                best_centers = final_centers\n                best_radii = final_radii\n                \n    return best_centers, best_radii, float(best_sum)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:11:42.556280",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 351,
        "candidates_token_count": 1776,
        "thoughts_token_count": 24899
      },
      "response_text_len": 4969
    }
  },
  "llm_call_duration_s": 145.23253672593273,
  "eval_duration_s": 108.08188997895923
}