{
  "trial_id": "trial_2_2",
  "generation": 2,
  "parent_id": "trial_1_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of Force-Directed initialization and SLSQP refinement.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for distance constraints to speed up Jacobian computation\n    i_indices, j_indices = np.triu_indices(n, k=1)\n    num_dist = n * (n - 1) // 2\n    row_idx = np.arange(num_dist)\n    obj_jac = np.concatenate([np.zeros(2 * n), -np.ones(n)])\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    def get_cons_and_jac(v):\n        \"\"\"Calculates the constraint values and their Jacobian.\"\"\"\n        x, y, r = v[:n], v[n:2 * n], v[2 * n:]\n        cons = np.zeros(4 * n + num_dist)\n        jac = np.zeros((4 * n + num_dist, 3 * n))\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        idx = np.arange(n)\n        cons[0:n] = x - r\n        jac[0:n, idx] = 1\n        jac[0:n, 2 * n + idx] = -1\n        \n        cons[n:2 * n] = 1.0 - x - r\n        jac[n:2 * n, idx] = -1\n        jac[n:2 * n, 2 * n + idx] = -1\n        \n        cons[2 * n:3 * n] = y - r\n        jac[2 * n:3 * n, n + idx] = 1\n        jac[2 * n:3 * n, 2 * n + idx] = -1\n        \n        cons[3 * n:4 * n] = 1.0 - y - r\n        jac[3 * n:4 * n, n + idx] = -1\n        jac[3 * n:4 * n, 2 * n + idx] = -1\n        \n        # Distance constraints: sqrt((xi-xj)^2 + (yi-yj)^2) - (ri+rj) >= 0\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dists = np.sqrt(dx**2 + dy**2 + 1e-12)\n        cons[4 * n:] = dists - (r[i_indices] + r[j_indices])\n        \n        inv_dists = 1.0 / dists\n        jac_dist = jac[4 * n:]\n        jac_dist[row_idx, i_indices] = dx * inv_dists\n        jac_dist[row_idx, j_indices] = -dx * inv_dists\n        jac_dist[row_idx, n + i_indices] = dy * inv_dists\n        jac_dist[row_idx, n + j_indices] = -dy * inv_dists\n        jac_dist[row_idx, 2 * n + i_indices] = -1\n        jac_dist[row_idx, 2 * n + j_indices] = -1\n        \n        return cons, jac\n\n    # Caching mechanism for SLSQP which calls cons and jac separately\n    _cache_v, _cache_res = None, None\n    def cons_fn(v):\n        nonlocal _cache_v, _cache_res\n        if _cache_v is not None and np.array_equal(v, _cache_v):\n            return _cache_res[0]\n        _cache_v, _cache_res = v.copy(), get_cons_and_jac(v)\n        return _cache_res[0]\n\n    def jac_fn(v):\n        nonlocal _cache_v, _cache_res\n        if _cache_v is not None and np.array_equal(v, _cache_v):\n            return _cache_res[1]\n        _cache_v, _cache_res = v.copy(), get_cons_and_jac(v)\n        return _cache_res[1]\n\n    # Strategy: Start with a grid, then try many force-directed starts, then refine the best.\n    best_sum = 0\n    best_v = None\n\n    # 1. Grid-based initialization\n    grid_side = int(np.ceil(np.sqrt(n)))\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, grid_side), np.linspace(0.1, 0.9, grid_side))\n    v_grid = np.concatenate([gx.flatten()[:n], gy.flatten()[:n], np.full(n, 0.05)])\n    res = minimize(lambda v: -np.sum(v[2 * n:]), v_grid, jac=lambda v: obj_jac, method='SLSQP',\n                  constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_fn}, bounds=bounds,\n                  options={'ftol': 1e-7, 'maxiter': 100})\n    if -res.fun > best_sum:\n        best_sum, best_v = -res.fun, res.x\n\n    # 2. Force-directed random starts\n    start_count = 0\n    while time.time() - start_time < 140:\n        # Simple force-directed spread to get diverse center configurations\n        centers = np.random.rand(n, 2)\n        for _ in range(40):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = centers[i] - centers[j]\n                    dist_sq = np.sum(d**2) + 1e-9\n                    if dist_sq < 0.04:  # Interaction radius\n                        move = 0.01 * d / np.sqrt(dist_sq)\n                        centers[i] += move\n                        centers[j] -= move\n            centers = np.clip(centers, 0.05, 0.95)\n        \n        v_init = np.concatenate([centers[:, 0], centers[:, 1], np.full(n, 0.04)])\n        res = minimize(lambda v: -np.sum(v[2 * n:]), v_init, jac=lambda v: obj_jac, method='SLSQP',\n                      constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_fn}, bounds=bounds,\n                      options={'ftol': 1e-7, 'maxiter': 150})\n        \n        if -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n        start_count += 1\n\n    # 3. Iterative refinement (Basin-hopping)\n    while time.time() - start_time < 285:\n        # Shake the current best configuration and re-optimize\n        v_shake = best_v.copy()\n        v_shake[:2 * n] += np.random.normal(0, 0.005, 2 * n)\n        # Randomly adjust radii slightly to allow for new local optima\n        v_shake[2 * n:] *= (0.9 + 0.2 * np.random.rand(n))\n        \n        res = minimize(lambda v: -np.sum(v[2 * n:]), v_shake, jac=lambda v: obj_jac, method='SLSQP',\n                      constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_fn}, bounds=bounds,\n                      options={'ftol': 1e-8, 'maxiter': 300})\n        \n        if -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # Final result preparation\n    final_centers = np.vstack([best_v[:n], best_v[n:2 * n]]).T\n    final_radii = best_v[2 * n:]\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 285.7871494293213,
    "error": "Circle 0 at (0.5715151877963559, 0.3036780714314995) with radius 0.4030243314910607 extends outside y-bounds"
  },
  "prompt": "Combine the Force-Directed approach from trial_1_4 with the Iterative Refinement of trial_1_3.\n1. Use the force-directed physics simulation to generate diverse, well-spread initial center configurations.\n2. For the best configurations found by the physics model, run the iterative shaking + SLSQP refinement.\n3. Experiment with different force constants (repulsion vs. boundary pressure) to find a better starting point for the 26-circle problem.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of Force-Directed initialization and SLSQP refinement.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for distance constraints to speed up Jacobian computation\n    i_indices, j_indices = np.triu_indices(n, k=1)\n    num_dist = n * (n - 1) // 2\n    row_idx = np.arange(num_dist)\n    obj_jac = np.concatenate([np.zeros(2 * n), -np.ones(n)])\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    def get_cons_and_jac(v):\n        \"\"\"Calculates the constraint values and their Jacobian.\"\"\"\n        x, y, r = v[:n], v[n:2 * n], v[2 * n:]\n        cons = np.zeros(4 * n + num_dist)\n        jac = np.zeros((4 * n + num_dist, 3 * n))\n        \n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        idx = np.arange(n)\n        cons[0:n] = x - r\n        jac[0:n, idx] = 1\n        jac[0:n, 2 * n + idx] = -1\n        \n        cons[n:2 * n] = 1.0 - x - r\n        jac[n:2 * n, idx] = -1\n        jac[n:2 * n, 2 * n + idx] = -1\n        \n        cons[2 * n:3 * n] = y - r\n        jac[2 * n:3 * n, n + idx] = 1\n        jac[2 * n:3 * n, 2 * n + idx] = -1\n        \n        cons[3 * n:4 * n] = 1.0 - y - r\n        jac[3 * n:4 * n, n + idx] = -1\n        jac[3 * n:4 * n, 2 * n + idx] = -1\n        \n        # Distance constraints: sqrt((xi-xj)^2 + (yi-yj)^2) - (ri+rj) >= 0\n        dx = x[i_indices] - x[j_indices]\n        dy = y[i_indices] - y[j_indices]\n        dists = np.sqrt(dx**2 + dy**2 + 1e-12)\n        cons[4 * n:] = dists - (r[i_indices] + r[j_indices])\n        \n        inv_dists = 1.0 / dists\n        jac_dist = jac[4 * n:]\n        jac_dist[row_idx, i_indices] = dx * inv_dists\n        jac_dist[row_idx, j_indices] = -dx * inv_dists\n        jac_dist[row_idx, n + i_indices] = dy * inv_dists\n        jac_dist[row_idx, n + j_indices] = -dy * inv_dists\n        jac_dist[row_idx, 2 * n + i_indices] = -1\n        jac_dist[row_idx, 2 * n + j_indices] = -1\n        \n        return cons, jac\n\n    # Caching mechanism for SLSQP which calls cons and jac separately\n    _cache_v, _cache_res = None, None\n    def cons_fn(v):\n        nonlocal _cache_v, _cache_res\n        if _cache_v is not None and np.array_equal(v, _cache_v):\n            return _cache_res[0]\n        _cache_v, _cache_res = v.copy(), get_cons_and_jac(v)\n        return _cache_res[0]\n\n    def jac_fn(v):\n        nonlocal _cache_v, _cache_res\n        if _cache_v is not None and np.array_equal(v, _cache_v):\n            return _cache_res[1]\n        _cache_v, _cache_res = v.copy(), get_cons_and_jac(v)\n        return _cache_res[1]\n\n    # Strategy: Start with a grid, then try many force-directed starts, then refine the best.\n    best_sum = 0\n    best_v = None\n\n    # 1. Grid-based initialization\n    grid_side = int(np.ceil(np.sqrt(n)))\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, grid_side), np.linspace(0.1, 0.9, grid_side))\n    v_grid = np.concatenate([gx.flatten()[:n], gy.flatten()[:n], np.full(n, 0.05)])\n    res = minimize(lambda v: -np.sum(v[2 * n:]), v_grid, jac=lambda v: obj_jac, method='SLSQP',\n                  constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_fn}, bounds=bounds,\n                  options={'ftol': 1e-7, 'maxiter': 100})\n    if -res.fun > best_sum:\n        best_sum, best_v = -res.fun, res.x\n\n    # 2. Force-directed random starts\n    start_count = 0\n    while time.time() - start_time < 140:\n        # Simple force-directed spread to get diverse center configurations\n        centers = np.random.rand(n, 2)\n        for _ in range(40):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = centers[i] - centers[j]\n                    dist_sq = np.sum(d**2) + 1e-9\n                    if dist_sq < 0.04:  # Interaction radius\n                        move = 0.01 * d / np.sqrt(dist_sq)\n                        centers[i] += move\n                        centers[j] -= move\n            centers = np.clip(centers, 0.05, 0.95)\n        \n        v_init = np.concatenate([centers[:, 0], centers[:, 1], np.full(n, 0.04)])\n        res = minimize(lambda v: -np.sum(v[2 * n:]), v_init, jac=lambda v: obj_jac, method='SLSQP',\n                      constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_fn}, bounds=bounds,\n                      options={'ftol': 1e-7, 'maxiter': 150})\n        \n        if -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n        start_count += 1\n\n    # 3. Iterative refinement (Basin-hopping)\n    while time.time() - start_time < 285:\n        # Shake the current best configuration and re-optimize\n        v_shake = best_v.copy()\n        v_shake[:2 * n] += np.random.normal(0, 0.005, 2 * n)\n        # Randomly adjust radii slightly to allow for new local optima\n        v_shake[2 * n:] *= (0.9 + 0.2 * np.random.rand(n))\n        \n        res = minimize(lambda v: -np.sum(v[2 * n:]), v_shake, jac=lambda v: obj_jac, method='SLSQP',\n                      constraints={'type': 'ineq', 'fun': cons_fn, 'jac': jac_fn}, bounds=bounds,\n                      options={'ftol': 1e-8, 'maxiter': 300})\n        \n        if -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # Final result preparation\n    final_centers = np.vstack([best_v[:n], best_v[n:2 * n]]).T\n    final_radii = best_v[2 * n:]\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:14:11.654787",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 327,
        "candidates_token_count": 2071,
        "thoughts_token_count": 19148
      },
      "response_text_len": 5617
    }
  },
  "llm_call_duration_s": 116.62670668307692,
  "eval_duration_s": 285.78715866804123
}