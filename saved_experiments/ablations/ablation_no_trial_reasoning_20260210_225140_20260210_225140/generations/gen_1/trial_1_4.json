{
  "trial_id": "trial_1_4",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of a penalty-based L-BFGS-B optimizer and Linear Programming\n    to find the optimal radii for a given set of centers.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def objective(params, C):\n        \"\"\"Penalty-based objective function for L-BFGS-B.\"\"\"\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:3*N]\n        obj = -np.sum(r)\n        \n        penalty = 0\n        # Boundary violations: r_i <= x_i, r_i <= 1-x_i, etc.\n        penalty += np.sum(np.maximum(0, r - x)**2)\n        penalty += np.sum(np.maximum(0, x + r - 1)**2)\n        penalty += np.sum(np.maximum(0, r - y)**2)\n        penalty += np.sum(np.maximum(0, y + r - 1)**2)\n        \n        # Overlap violations: r_i + r_j <= d_ij\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                d = np.sqrt(dx*dx + dy*dy)\n                if d < 1e-9:\n                    penalty += (r[i] + r[j])**2\n                elif r[i] + r[j] > d:\n                    penalty += (r[i] + r[j] - d)**2\n        return obj + C * penalty\n\n    def gradient(params, C):\n        \"\"\"Gradient of the penalty-based objective function.\"\"\"\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:3*N]\n        \n        grad_x = np.zeros(N)\n        grad_y = np.zeros(N)\n        grad_r = -np.ones(N)\n        \n        # Boundary gradients\n        mask = r > x\n        grad_r[mask] += 2 * C * (r[mask] - x[mask])\n        grad_x[mask] -= 2 * C * (r[mask] - x[mask])\n        \n        mask = x + r > 1\n        grad_r[mask] += 2 * C * (x[mask] + r[mask] - 1)\n        grad_x[mask] += 2 * C * (x[mask] + r[mask] - 1)\n        \n        mask = r > y\n        grad_r[mask] += 2 * C * (r[mask] - y[mask])\n        grad_y[mask] -= 2 * C * (r[mask] - y[mask])\n        \n        mask = y + r > 1\n        grad_r[mask] += 2 * C * (y[mask] + r[mask] - 1)\n        grad_y[mask] += 2 * C * (y[mask] + r[mask] - 1)\n        \n        # Overlap gradients\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                d = np.sqrt(dx*dx + dy*dy)\n                if r[i] + r[j] > d:\n                    if d < 1e-9:\n                        grad_r[i] += 2 * C * (r[i] + r[j])\n                        grad_r[j] += 2 * C * (r[i] + r[j])\n                        continue\n                    overlap = r[i] + r[j] - d\n                    common = 2 * C * overlap\n                    grad_r[i] += common\n                    grad_r[j] += common\n                    grad_x[i] -= common * (dx / d)\n                    grad_x[j] += common * (dx / d)\n                    grad_y[i] -= common * (dy / d)\n                    grad_y[j] += common * (dy / d)\n        \n        return np.concatenate([grad_x, grad_y, grad_r])\n\n    best_sum = 0\n    best_centers = np.zeros((N, 2))\n    best_radii = np.zeros(N)\n    \n    # Initialize several starting configurations\n    # 1. Near-grid start\n    grid_size = 5\n    xs = np.linspace(0.1, 0.9, grid_size)\n    ys = np.linspace(0.1, 0.9, grid_size)\n    xi, yi = np.meshgrid(xs, ys)\n    x_grid = np.append(xi.flatten(), 0.5)\n    y_grid = np.append(yi.flatten(), 0.5)\n    r_grid = np.full(N, 0.09)\n    \n    starts = [np.concatenate([x_grid, y_grid, r_grid])]\n    # 2. Random starts\n    for _ in range(15):\n        starts.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.random.rand(N)*0.1]))\n\n    # Main optimization loop\n    for params in starts:\n        if time.time() - start_time > 280: # Time limit safety\n            break\n        \n        # Gradually increase penalty coefficient C\n        for C in [10, 100, 1000]:\n            res = minimize(objective, params, args=(C,), method='L-BFGS-B', \n                           jac=gradient, bounds=[(0, 1)]*(2*N) + [(0, 0.5)]*N, \n                           options={'maxiter': 200})\n            params = res.x\n        \n        # Refine radii using Linear Programming for the found centers\n        x, y = params[:N], params[N:2*N]\n        c_lp = -np.ones(N)\n        num_constraints = N * (N - 1) // 2\n        A_ub = np.zeros((num_constraints, N))\n        b_ub = np.zeros(num_constraints)\n        idx = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                A_ub[idx, i] = 1\n                A_ub[idx, j] = 1\n                b_ub[idx] = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                idx += 1\n        \n        # Radius bounds based on distance to square edges\n        r_bounds = []\n        for i in range(N):\n            limit = min(x[i], 1-x[i], y[i], 1-y[i])\n            r_bounds.append((0, max(0, limit)))\n            \n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=r_bounds, method='highs')\n        \n        if res_lp.success:\n            current_sum = -res_lp.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_radii = res_lp.x\n                best_centers = np.stack([x, y], axis=1)\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.6268049112492644,
    "eval_time": 14.023131608963013,
    "error": null
  },
  "prompt": "Use a 'Force-Directed' approach where circles are treated as particles with repulsive potentials. However, modify the objective: we want to maximize sum(r_i). Define a potential that penalizes overlap and boundary violations. Use a gradient-based optimizer (like L-BFGS-B) on this potential, and periodically update the 'target radii' to encourage growth in areas with more space.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a combination of a penalty-based L-BFGS-B optimizer and Linear Programming\n    to find the optimal radii for a given set of centers.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def objective(params, C):\n        \"\"\"Penalty-based objective function for L-BFGS-B.\"\"\"\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:3*N]\n        obj = -np.sum(r)\n        \n        penalty = 0\n        # Boundary violations: r_i <= x_i, r_i <= 1-x_i, etc.\n        penalty += np.sum(np.maximum(0, r - x)**2)\n        penalty += np.sum(np.maximum(0, x + r - 1)**2)\n        penalty += np.sum(np.maximum(0, r - y)**2)\n        penalty += np.sum(np.maximum(0, y + r - 1)**2)\n        \n        # Overlap violations: r_i + r_j <= d_ij\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                d = np.sqrt(dx*dx + dy*dy)\n                if d < 1e-9:\n                    penalty += (r[i] + r[j])**2\n                elif r[i] + r[j] > d:\n                    penalty += (r[i] + r[j] - d)**2\n        return obj + C * penalty\n\n    def gradient(params, C):\n        \"\"\"Gradient of the penalty-based objective function.\"\"\"\n        x = params[:N]\n        y = params[N:2*N]\n        r = params[2*N:3*N]\n        \n        grad_x = np.zeros(N)\n        grad_y = np.zeros(N)\n        grad_r = -np.ones(N)\n        \n        # Boundary gradients\n        mask = r > x\n        grad_r[mask] += 2 * C * (r[mask] - x[mask])\n        grad_x[mask] -= 2 * C * (r[mask] - x[mask])\n        \n        mask = x + r > 1\n        grad_r[mask] += 2 * C * (x[mask] + r[mask] - 1)\n        grad_x[mask] += 2 * C * (x[mask] + r[mask] - 1)\n        \n        mask = r > y\n        grad_r[mask] += 2 * C * (r[mask] - y[mask])\n        grad_y[mask] -= 2 * C * (r[mask] - y[mask])\n        \n        mask = y + r > 1\n        grad_r[mask] += 2 * C * (y[mask] + r[mask] - 1)\n        grad_y[mask] += 2 * C * (y[mask] + r[mask] - 1)\n        \n        # Overlap gradients\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                d = np.sqrt(dx*dx + dy*dy)\n                if r[i] + r[j] > d:\n                    if d < 1e-9:\n                        grad_r[i] += 2 * C * (r[i] + r[j])\n                        grad_r[j] += 2 * C * (r[i] + r[j])\n                        continue\n                    overlap = r[i] + r[j] - d\n                    common = 2 * C * overlap\n                    grad_r[i] += common\n                    grad_r[j] += common\n                    grad_x[i] -= common * (dx / d)\n                    grad_x[j] += common * (dx / d)\n                    grad_y[i] -= common * (dy / d)\n                    grad_y[j] += common * (dy / d)\n        \n        return np.concatenate([grad_x, grad_y, grad_r])\n\n    best_sum = 0\n    best_centers = np.zeros((N, 2))\n    best_radii = np.zeros(N)\n    \n    # Initialize several starting configurations\n    # 1. Near-grid start\n    grid_size = 5\n    xs = np.linspace(0.1, 0.9, grid_size)\n    ys = np.linspace(0.1, 0.9, grid_size)\n    xi, yi = np.meshgrid(xs, ys)\n    x_grid = np.append(xi.flatten(), 0.5)\n    y_grid = np.append(yi.flatten(), 0.5)\n    r_grid = np.full(N, 0.09)\n    \n    starts = [np.concatenate([x_grid, y_grid, r_grid])]\n    # 2. Random starts\n    for _ in range(15):\n        starts.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.random.rand(N)*0.1]))\n\n    # Main optimization loop\n    for params in starts:\n        if time.time() - start_time > 280: # Time limit safety\n            break\n        \n        # Gradually increase penalty coefficient C\n        for C in [10, 100, 1000]:\n            res = minimize(objective, params, args=(C,), method='L-BFGS-B', \n                           jac=gradient, bounds=[(0, 1)]*(2*N) + [(0, 0.5)]*N, \n                           options={'maxiter': 200})\n            params = res.x\n        \n        # Refine radii using Linear Programming for the found centers\n        x, y = params[:N], params[N:2*N]\n        c_lp = -np.ones(N)\n        num_constraints = N * (N - 1) // 2\n        A_ub = np.zeros((num_constraints, N))\n        b_ub = np.zeros(num_constraints)\n        idx = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                A_ub[idx, i] = 1\n                A_ub[idx, j] = 1\n                b_ub[idx] = np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2)\n                idx += 1\n        \n        # Radius bounds based on distance to square edges\n        r_bounds = []\n        for i in range(N):\n            limit = min(x[i], 1-x[i], y[i], 1-y[i])\n            r_bounds.append((0, max(0, limit)))\n            \n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=r_bounds, method='highs')\n        \n        if res_lp.success:\n            current_sum = -res_lp.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_radii = res_lp.x\n                best_centers = np.stack([x, y], axis=1)\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:02:05.163397",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 309,
        "candidates_token_count": 1880,
        "thoughts_token_count": 18322
      },
      "response_text_len": 5271
    }
  },
  "llm_call_duration_s": 116.10256404895335,
  "eval_duration_s": 14.023140451055951
}