{
  "trial_id": "trial_1_5",
  "generation": 1,
  "parent_id": "trial_0_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid initialization, center relaxation, and a two-stage SLSQP optimization.\n    \"\"\"\n    N = 26\n    # Pre-compute upper triangle indices for efficient constraint calculation\n    TRIU_I, TRIU_J = np.triu_indices(N, k=1)\n\n    def get_initial_centers(trial_idx):\n        if trial_idx == 0:\n            # 5x5 grid + 1 point at the center\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            centers = np.stack([x.ravel(), y.ravel()], axis=1)\n            centers = np.vstack([centers, [0.5, 0.5]])\n        else:\n            # Random initialization\n            centers = np.random.uniform(0.1, 0.9, size=(N, 2))\n        # Add slight jitter\n        centers += np.random.uniform(-0.01, 0.01, size=(N, 2))\n        return np.clip(centers, 0.01, 0.99)\n\n    def relax_centers(centers, iterations=20):\n        \"\"\"Simple force-directed relaxation to spread centers.\"\"\"\n        for _ in range(iterations):\n            for i in range(N):\n                diff = centers[i] - centers\n                dist_sq = np.sum(diff**2, axis=1)\n                dist_sq[i] = 1.0  # Avoid self-repulsion\n                # Repulsion from other points (inverse square)\n                mask = dist_sq < 0.04  # 0.2 distance threshold\n                if np.any(mask):\n                    force = np.sum(diff[mask] / (dist_sq[mask, None] + 0.001), axis=0)\n                    centers[i] += 0.002 * force\n            centers = np.clip(centers, 0.05, 0.95)\n        return centers\n\n    def constraints_equal(p):\n        x, y, r = p[:N], p[N:2*N], p[-1]\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        dx = x[TRIU_I] - x[TRIU_J]\n        dy = y[TRIU_I] - y[TRIU_J]\n        dist_sq = dx**2 + dy**2\n        o_cons = dist_sq - 4 * r**2\n        return np.concatenate([b_cons, o_cons])\n\n    def constraints_equal_jac(p):\n        x, y, r = p[:N], p[N:2*N], p[-1]\n        num_b = 4 * N\n        num_o = N * (N - 1) // 2\n        jac = np.zeros((num_b + num_o, 2 * N + 1))\n        # Boundary constraints\n        for i in range(N):\n            jac[i, i] = 1; jac[i, -1] = -1\n            jac[N+i, i] = -1; jac[N+i, -1] = -1\n            jac[2*N+i, N+i] = 1; jac[2*N+i, -1] = -1\n            jac[3*N+i, N+i] = -1; jac[3*N+i, -1] = -1\n        # Overlap constraints\n        row_indices = np.arange(num_b, num_b + num_o)\n        jac[row_indices, TRIU_I] = 2 * (x[TRIU_I] - x[TRIU_J])\n        jac[row_indices, TRIU_J] = -2 * (x[TRIU_I] - x[TRIU_J])\n        jac[row_indices, N + TRIU_I] = 2 * (y[TRIU_I] - y[TRIU_J])\n        jac[row_indices, N + TRIU_J] = -2 * (y[TRIU_I] - y[TRIU_J])\n        jac[row_indices, -1] = -8 * r\n        return jac\n\n    def constraints_sum(p):\n        x, y, r = p[:N], p[N:2*N], p[2*N:]\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        dx = x[TRIU_I] - x[TRIU_J]\n        dy = y[TRIU_I] - y[TRIU_J]\n        dist_sq = dx**2 + dy**2\n        r_sum_sq = (r[TRIU_I] + r[TRIU_J])**2\n        o_cons = dist_sq - r_sum_sq\n        return np.concatenate([b_cons, o_cons])\n\n    def constraints_sum_jac(p):\n        x, y, r = p[:N], p[N:2*N], p[2*N:]\n        num_b = 4 * N\n        num_o = N * (N - 1) // 2\n        jac = np.zeros((num_b + num_o, 3 * N))\n        for i in range(N):\n            jac[i, i] = 1; jac[i, 2*N+i] = -1\n            jac[N+i, i] = -1; jac[N+i, 2*N+i] = -1\n            jac[2*N+i, N+i] = 1; jac[2*N+i, 2*N+i] = -1\n            jac[3*N+i, N+i] = -1; jac[3*N+i, 2*N+i] = -1\n        row_indices = np.arange(num_b, num_b + num_o)\n        jac[row_indices, TRIU_I] = 2 * (x[TRIU_I] - x[TRIU_J])\n        jac[row_indices, TRIU_J] = -2 * (x[TRIU_I] - x[TRIU_J])\n        jac[row_indices, N + TRIU_I] = 2 * (y[TRIU_I] - y[TRIU_J])\n        jac[row_indices, N + TRIU_J] = -2 * (y[TRIU_I] - y[TRIU_J])\n        jac[row_indices, 2*N + TRIU_I] = -2 * (r[TRIU_I] + r[TRIU_J])\n        jac[row_indices, 2*N + TRIU_J] = -2 * (r[TRIU_I] + r[TRIU_J])\n        return jac\n\n    def make_feasible(centers, radii):\n        \"\"\"Ensures radii satisfy all constraints after numerical optimization.\"\"\"\n        for i in range(N):\n            radii[i] = max(0, min(radii[i], centers[i, 0], 1 - centers[i, 0], \n                                 centers[i, 1], 1 - centers[i, 1]))\n        for _ in range(10):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    d = np.linalg.norm(centers[i] - centers[j])\n                    if radii[i] + radii[j] > d + 1e-13:\n                        shrink = (radii[i] + radii[j] - d) / 2\n                        radii[i] = max(0, radii[i] - shrink)\n                        radii[j] = max(0, radii[j] - shrink)\n        return radii\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Run multiple trials with different initializations\n    for trial in range(6):\n        centers = get_initial_centers(trial)\n        centers = relax_centers(centers)\n\n        # Stage 1: Maximize a common radius R\n        x0_1 = np.concatenate([centers[:, 0], centers[:, 1], [0.05]])\n        res1 = minimize(lambda p: -p[-1], x0_1, method='SLSQP',\n                        jac=lambda p: np.concatenate([np.zeros(2*N), [-1]]),\n                        constraints={'type': 'ineq', 'fun': constraints_equal, 'jac': constraints_equal_jac},\n                        bounds=[(0, 1)] * (2*N) + [(0, 0.5)],\n                        options={'maxiter': 100, 'ftol': 1e-8})\n\n        # Stage 2: Maximize the sum of radii starting from Stage 1 result\n        p1 = res1.x\n        x0_2 = np.concatenate([p1[:2*N], [p1[-1]] * N])\n        res2 = minimize(lambda p: -np.sum(p[2*N:]), x0_2, method='SLSQP',\n                        jac=lambda p: np.concatenate([np.zeros(2*N), -np.ones(N)]),\n                        constraints={'type': 'ineq', 'fun': constraints_sum, 'jac': constraints_sum_jac},\n                        bounds=[(0, 1)] * (2*N) + [(0, 0.5)] * N,\n                        options={'maxiter': 200, 'ftol': 1e-9})\n        \n        p2 = res2.x\n        current_centers = np.stack([p2[:N], p2[N:2*N]], axis=1)\n        current_radii = make_feasible(current_centers, p2[2*N:])\n        current_sum = np.sum(current_radii)\n\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = current_centers\n            best_radii = current_radii\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.625325845152521,
    "eval_time": 15.931809186935425,
    "error": null
  },
  "prompt": "Explore a 'Hybrid Grid-Random' initialization. Start with a 5x5 grid plus one extra circle, but then apply a Voronoi-based relaxation (Lloyd's algorithm) to distribute the centers more evenly before running a final SLSQP optimization to maximize the sum of radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a hybrid initialization, center relaxation, and a two-stage SLSQP optimization.\n    \"\"\"\n    N = 26\n    # Pre-compute upper triangle indices for efficient constraint calculation\n    TRIU_I, TRIU_J = np.triu_indices(N, k=1)\n\n    def get_initial_centers(trial_idx):\n        if trial_idx == 0:\n            # 5x5 grid + 1 point at the center\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            centers = np.stack([x.ravel(), y.ravel()], axis=1)\n            centers = np.vstack([centers, [0.5, 0.5]])\n        else:\n            # Random initialization\n            centers = np.random.uniform(0.1, 0.9, size=(N, 2))\n        # Add slight jitter\n        centers += np.random.uniform(-0.01, 0.01, size=(N, 2))\n        return np.clip(centers, 0.01, 0.99)\n\n    def relax_centers(centers, iterations=20):\n        \"\"\"Simple force-directed relaxation to spread centers.\"\"\"\n        for _ in range(iterations):\n            for i in range(N):\n                diff = centers[i] - centers\n                dist_sq = np.sum(diff**2, axis=1)\n                dist_sq[i] = 1.0  # Avoid self-repulsion\n                # Repulsion from other points (inverse square)\n                mask = dist_sq < 0.04  # 0.2 distance threshold\n                if np.any(mask):\n                    force = np.sum(diff[mask] / (dist_sq[mask, None] + 0.001), axis=0)\n                    centers[i] += 0.002 * force\n            centers = np.clip(centers, 0.05, 0.95)\n        return centers\n\n    def constraints_equal(p):\n        x, y, r = p[:N], p[N:2*N], p[-1]\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        dx = x[TRIU_I] - x[TRIU_J]\n        dy = y[TRIU_I] - y[TRIU_J]\n        dist_sq = dx**2 + dy**2\n        o_cons = dist_sq - 4 * r**2\n        return np.concatenate([b_cons, o_cons])\n\n    def constraints_equal_jac(p):\n        x, y, r = p[:N], p[N:2*N], p[-1]\n        num_b = 4 * N\n        num_o = N * (N - 1) // 2\n        jac = np.zeros((num_b + num_o, 2 * N + 1))\n        # Boundary constraints\n        for i in range(N):\n            jac[i, i] = 1; jac[i, -1] = -1\n            jac[N+i, i] = -1; jac[N+i, -1] = -1\n            jac[2*N+i, N+i] = 1; jac[2*N+i, -1] = -1\n            jac[3*N+i, N+i] = -1; jac[3*N+i, -1] = -1\n        # Overlap constraints\n        row_indices = np.arange(num_b, num_b + num_o)\n        jac[row_indices, TRIU_I] = 2 * (x[TRIU_I] - x[TRIU_J])\n        jac[row_indices, TRIU_J] = -2 * (x[TRIU_I] - x[TRIU_J])\n        jac[row_indices, N + TRIU_I] = 2 * (y[TRIU_I] - y[TRIU_J])\n        jac[row_indices, N + TRIU_J] = -2 * (y[TRIU_I] - y[TRIU_J])\n        jac[row_indices, -1] = -8 * r\n        return jac\n\n    def constraints_sum(p):\n        x, y, r = p[:N], p[N:2*N], p[2*N:]\n        b_cons = np.concatenate([x - r, 1 - x - r, y - r, 1 - y - r])\n        dx = x[TRIU_I] - x[TRIU_J]\n        dy = y[TRIU_I] - y[TRIU_J]\n        dist_sq = dx**2 + dy**2\n        r_sum_sq = (r[TRIU_I] + r[TRIU_J])**2\n        o_cons = dist_sq - r_sum_sq\n        return np.concatenate([b_cons, o_cons])\n\n    def constraints_sum_jac(p):\n        x, y, r = p[:N], p[N:2*N], p[2*N:]\n        num_b = 4 * N\n        num_o = N * (N - 1) // 2\n        jac = np.zeros((num_b + num_o, 3 * N))\n        for i in range(N):\n            jac[i, i] = 1; jac[i, 2*N+i] = -1\n            jac[N+i, i] = -1; jac[N+i, 2*N+i] = -1\n            jac[2*N+i, N+i] = 1; jac[2*N+i, 2*N+i] = -1\n            jac[3*N+i, N+i] = -1; jac[3*N+i, 2*N+i] = -1\n        row_indices = np.arange(num_b, num_b + num_o)\n        jac[row_indices, TRIU_I] = 2 * (x[TRIU_I] - x[TRIU_J])\n        jac[row_indices, TRIU_J] = -2 * (x[TRIU_I] - x[TRIU_J])\n        jac[row_indices, N + TRIU_I] = 2 * (y[TRIU_I] - y[TRIU_J])\n        jac[row_indices, N + TRIU_J] = -2 * (y[TRIU_I] - y[TRIU_J])\n        jac[row_indices, 2*N + TRIU_I] = -2 * (r[TRIU_I] + r[TRIU_J])\n        jac[row_indices, 2*N + TRIU_J] = -2 * (r[TRIU_I] + r[TRIU_J])\n        return jac\n\n    def make_feasible(centers, radii):\n        \"\"\"Ensures radii satisfy all constraints after numerical optimization.\"\"\"\n        for i in range(N):\n            radii[i] = max(0, min(radii[i], centers[i, 0], 1 - centers[i, 0], \n                                 centers[i, 1], 1 - centers[i, 1]))\n        for _ in range(10):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    d = np.linalg.norm(centers[i] - centers[j])\n                    if radii[i] + radii[j] > d + 1e-13:\n                        shrink = (radii[i] + radii[j] - d) / 2\n                        radii[i] = max(0, radii[i] - shrink)\n                        radii[j] = max(0, radii[j] - shrink)\n        return radii\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Run multiple trials with different initializations\n    for trial in range(6):\n        centers = get_initial_centers(trial)\n        centers = relax_centers(centers)\n\n        # Stage 1: Maximize a common radius R\n        x0_1 = np.concatenate([centers[:, 0], centers[:, 1], [0.05]])\n        res1 = minimize(lambda p: -p[-1], x0_1, method='SLSQP',\n                        jac=lambda p: np.concatenate([np.zeros(2*N), [-1]]),\n                        constraints={'type': 'ineq', 'fun': constraints_equal, 'jac': constraints_equal_jac},\n                        bounds=[(0, 1)] * (2*N) + [(0, 0.5)],\n                        options={'maxiter': 100, 'ftol': 1e-8})\n\n        # Stage 2: Maximize the sum of radii starting from Stage 1 result\n        p1 = res1.x\n        x0_2 = np.concatenate([p1[:2*N], [p1[-1]] * N])\n        res2 = minimize(lambda p: -np.sum(p[2*N:]), x0_2, method='SLSQP',\n                        jac=lambda p: np.concatenate([np.zeros(2*N), -np.ones(N)]),\n                        constraints={'type': 'ineq', 'fun': constraints_sum, 'jac': constraints_sum_jac},\n                        bounds=[(0, 1)] * (2*N) + [(0, 0.5)] * N,\n                        options={'maxiter': 200, 'ftol': 1e-9})\n        \n        p2 = res2.x\n        current_centers = np.stack([p2[:N], p2[N:2*N]], axis=1)\n        current_radii = make_feasible(current_centers, p2[2*N:])\n        current_sum = np.sum(current_radii)\n\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = current_centers\n            best_radii = current_radii\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:02:32.623509",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 287,
        "candidates_token_count": 2492,
        "thoughts_token_count": 21721
      },
      "response_text_len": 6515
    }
  },
  "llm_call_duration_s": 141.65299441094976,
  "eval_duration_s": 15.931816466967575
}