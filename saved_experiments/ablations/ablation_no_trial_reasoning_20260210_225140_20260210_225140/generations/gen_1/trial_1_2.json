{
  "trial_id": "trial_1_2",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'Greedy Growth' approach with force-directed displacement derived from \n    the dual variables of a Linear Programming optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Pre-construct A matrix for the Linear Programming problem\n    # Constraints: \n    # 1. r_i + r_j <= dist(c_i, c_j) for all i < j\n    # 2. r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    num_inter = N * (N - 1) // 2\n    num_bound = 4 * N\n    A = np.zeros((num_inter + num_bound, N))\n    idx = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            A[idx, i] = 1\n            A[idx, j] = 1\n            idx += 1\n    for i in range(N):\n        A[num_inter + 4 * i + 0, i] = 1\n        A[num_inter + 4 * i + 1, i] = 1\n        A[num_inter + 4 * i + 2, i] = 1\n        A[num_inter + 4 * i + 3, i] = 1\n        \n    # Objective: Maximize sum(r_i) => Minimize -sum(r_i)\n    c = -np.ones(N)\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    init_idx = 0\n    # Main optimization loop with restarts\n    while time.time() - start_time < 280:\n        # Initialization strategies\n        if init_idx == 0:\n            # 5x5 grid + 1 extra circle\n            x = np.linspace(0.1, 0.9, 5)\n            y = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(x, y)\n            centers = np.vstack([xv.ravel(), yv.ravel()]).T\n            centers = np.vstack([centers, [0.5, 0.5]])\n        elif init_idx == 1:\n            # 4x6 grid + 2 extra circles\n            x = np.linspace(0.1, 0.9, 4)\n            y = np.linspace(0.1, 0.9, 6)\n            xv, yv = np.meshgrid(x, y)\n            centers = np.vstack([xv.ravel(), yv.ravel()]).T\n            centers = np.vstack([centers, [[0.2, 0.5], [0.8, 0.5]]])\n        else:\n            # Random initialization\n            centers = np.random.rand(N, 2)\n        \n        # Add small initial noise and clip to square boundaries\n        centers = np.clip(centers + np.random.normal(0, 0.01, centers.shape), 0.001, 0.999)\n        init_idx += 1\n        \n        step_size = 0.02\n        temperature = 1.0\n        \n        # Iterative growth and displacement\n        for iteration in range(150):\n            # Update constraint vector b based on current centers\n            b = np.zeros(num_inter + num_bound)\n            idx = 0\n            for i in range(N):\n                for j in range(i + 1, N):\n                    # Distance between centers\n                    b[idx] = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    idx += 1\n            for i in range(N):\n                x, y = centers[i]\n                # Distance to boundaries\n                b[num_inter + 4 * i + 0] = x\n                b[num_inter + 4 * i + 1] = 1 - x\n                b[num_inter + 4 * i + 2] = y\n                b[num_inter + 4 * i + 3] = 1 - y\n            \n            # Solve the Linear Programming problem for optimal radii\n            res = linprog(c, A_ub=A, b_ub=b, bounds=(0, 1), method='highs')\n            \n            if not res.success or not hasattr(res, 'ineqlin') or res.ineqlin is None:\n                break\n            \n            radii = res.x\n            current_sum = -res.fun\n            marginals = res.ineqlin.marginals\n            \n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            \n            # Compute gradient from dual variables (shadow prices)\n            # Dual variables indicate how much the sum of radii can increase \n            # if a specific center-to-center or center-to-boundary distance increases.\n            lambda_inter = -marginals[:num_inter]\n            mu_bound = -marginals[num_inter:]\n            \n            grad = np.zeros((N, 2))\n            idx = 0\n            for i in range(N):\n                for j in range(i + 1, N):\n                    lam = lambda_inter[idx]\n                    if lam > 1e-7:\n                        diff = centers[i] - centers[j]\n                        dist = np.sqrt(np.sum(diff**2))\n                        if dist < 1e-9: dist = 1e-9\n                        # Force pushes centers apart proportionally to the dual value\n                        force = lam * diff / dist\n                        grad[i] += force\n                        grad[j] -= force\n                    idx += 1\n            \n            for i in range(N):\n                # Forces from boundaries\n                grad[i, 0] += mu_bound[4 * i + 0]  # Push from x=0\n                grad[i, 0] -= mu_bound[4 * i + 1]  # Push from x=1\n                grad[i, 1] += mu_bound[4 * i + 2]  # Push from y=0\n                grad[i, 1] -= mu_bound[4 * i + 3]  # Push from y=1\n            \n            # Update center positions using gradient ascent and thermal noise\n            centers += step_size * grad\n            if temperature > 0.01:\n                centers += np.random.normal(0, 0.002 * temperature, (N, 2))\n            centers = np.clip(centers, 0, 1)\n            \n            # Simulated Annealing: gradually decrease step size and noise\n            temperature *= 0.96\n            step_size *= 0.99\n            \n            # Check time limit\n            if time.time() - start_time > 280:\n                break\n                \n    # Fallback in case of solver failure\n    if best_centers is None:\n        best_centers = np.random.rand(N, 2)\n        best_radii = np.zeros(N)\n        best_sum = 0.0\n        \n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.5748574533969966,
    "eval_time": 280.533917427063,
    "error": null
  },
  "prompt": "Develop a 'Greedy Growth' algorithm. Start with 26 small circles. Iteratively: 1) Optimize the sum of radii for current centers. 2) Perturb the centers using a small 'thermal' noise or force-directed displacement to reduce 'pressure' (overlap potential). 3) Gradually decrease the noise (simulated annealing). Focus on maximizing the sum of radii.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'Greedy Growth' approach with force-directed displacement derived from \n    the dual variables of a Linear Programming optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Pre-construct A matrix for the Linear Programming problem\n    # Constraints: \n    # 1. r_i + r_j <= dist(c_i, c_j) for all i < j\n    # 2. r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    num_inter = N * (N - 1) // 2\n    num_bound = 4 * N\n    A = np.zeros((num_inter + num_bound, N))\n    idx = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            A[idx, i] = 1\n            A[idx, j] = 1\n            idx += 1\n    for i in range(N):\n        A[num_inter + 4 * i + 0, i] = 1\n        A[num_inter + 4 * i + 1, i] = 1\n        A[num_inter + 4 * i + 2, i] = 1\n        A[num_inter + 4 * i + 3, i] = 1\n        \n    # Objective: Maximize sum(r_i) => Minimize -sum(r_i)\n    c = -np.ones(N)\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    init_idx = 0\n    # Main optimization loop with restarts\n    while time.time() - start_time < 280:\n        # Initialization strategies\n        if init_idx == 0:\n            # 5x5 grid + 1 extra circle\n            x = np.linspace(0.1, 0.9, 5)\n            y = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(x, y)\n            centers = np.vstack([xv.ravel(), yv.ravel()]).T\n            centers = np.vstack([centers, [0.5, 0.5]])\n        elif init_idx == 1:\n            # 4x6 grid + 2 extra circles\n            x = np.linspace(0.1, 0.9, 4)\n            y = np.linspace(0.1, 0.9, 6)\n            xv, yv = np.meshgrid(x, y)\n            centers = np.vstack([xv.ravel(), yv.ravel()]).T\n            centers = np.vstack([centers, [[0.2, 0.5], [0.8, 0.5]]])\n        else:\n            # Random initialization\n            centers = np.random.rand(N, 2)\n        \n        # Add small initial noise and clip to square boundaries\n        centers = np.clip(centers + np.random.normal(0, 0.01, centers.shape), 0.001, 0.999)\n        init_idx += 1\n        \n        step_size = 0.02\n        temperature = 1.0\n        \n        # Iterative growth and displacement\n        for iteration in range(150):\n            # Update constraint vector b based on current centers\n            b = np.zeros(num_inter + num_bound)\n            idx = 0\n            for i in range(N):\n                for j in range(i + 1, N):\n                    # Distance between centers\n                    b[idx] = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                    idx += 1\n            for i in range(N):\n                x, y = centers[i]\n                # Distance to boundaries\n                b[num_inter + 4 * i + 0] = x\n                b[num_inter + 4 * i + 1] = 1 - x\n                b[num_inter + 4 * i + 2] = y\n                b[num_inter + 4 * i + 3] = 1 - y\n            \n            # Solve the Linear Programming problem for optimal radii\n            res = linprog(c, A_ub=A, b_ub=b, bounds=(0, 1), method='highs')\n            \n            if not res.success or not hasattr(res, 'ineqlin') or res.ineqlin is None:\n                break\n            \n            radii = res.x\n            current_sum = -res.fun\n            marginals = res.ineqlin.marginals\n            \n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            \n            # Compute gradient from dual variables (shadow prices)\n            # Dual variables indicate how much the sum of radii can increase \n            # if a specific center-to-center or center-to-boundary distance increases.\n            lambda_inter = -marginals[:num_inter]\n            mu_bound = -marginals[num_inter:]\n            \n            grad = np.zeros((N, 2))\n            idx = 0\n            for i in range(N):\n                for j in range(i + 1, N):\n                    lam = lambda_inter[idx]\n                    if lam > 1e-7:\n                        diff = centers[i] - centers[j]\n                        dist = np.sqrt(np.sum(diff**2))\n                        if dist < 1e-9: dist = 1e-9\n                        # Force pushes centers apart proportionally to the dual value\n                        force = lam * diff / dist\n                        grad[i] += force\n                        grad[j] -= force\n                    idx += 1\n            \n            for i in range(N):\n                # Forces from boundaries\n                grad[i, 0] += mu_bound[4 * i + 0]  # Push from x=0\n                grad[i, 0] -= mu_bound[4 * i + 1]  # Push from x=1\n                grad[i, 1] += mu_bound[4 * i + 2]  # Push from y=0\n                grad[i, 1] -= mu_bound[4 * i + 3]  # Push from y=1\n            \n            # Update center positions using gradient ascent and thermal noise\n            centers += step_size * grad\n            if temperature > 0.01:\n                centers += np.random.normal(0, 0.002 * temperature, (N, 2))\n            centers = np.clip(centers, 0, 1)\n            \n            # Simulated Annealing: gradually decrease step size and noise\n            temperature *= 0.96\n            step_size *= 0.99\n            \n            # Check time limit\n            if time.time() - start_time > 280:\n                break\n                \n    # Fallback in case of solver failure\n    if best_centers is None:\n        best_centers = np.random.rand(N, 2)\n        best_radii = np.zeros(N)\n        best_sum = 0.0\n        \n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:06:25.424130",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 308,
        "candidates_token_count": 1803,
        "thoughts_token_count": 18285
      },
      "response_text_len": 5709
    }
  },
  "llm_call_duration_s": 109.85327189194504,
  "eval_duration_s": 280.5339255530853
}