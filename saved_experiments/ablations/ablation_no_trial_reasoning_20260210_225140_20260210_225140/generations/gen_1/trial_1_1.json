{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": "trial_0_3",
  "code": "import numpy as np\nfrom scipy.optimize import linprog, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Uses 'Center-only' optimization where the objective function is the maximum \n    sum of radii for a given set of centers, solved as a Linear Programming problem.\n    The gradient of the objective function is computed using the dual variables (marginals)\n    from the LP solver, allowing efficient global optimization with Basin-hopping.\n    \"\"\"\n    N = 26\n    n_pairs = N * (N - 1) // 2\n    pair_indices = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pair_indices.append((i, j))\n    \n    # Precompute the constraint matrix A_ub for the LP.\n    # There are n_pairs constraints for circle-circle overlaps (r_i + r_j <= d_ij)\n    # and N constraints for circle-wall boundaries (r_i <= b_i).\n    A_ub = np.zeros((n_pairs + N, N))\n    for idx, (i, j) in enumerate(pair_indices):\n        A_ub[idx, i] = 1\n        A_ub[idx, j] = 1\n    for i in range(N):\n        A_ub[n_pairs + i, i] = 1\n        \n    # Objective for LP: minimize -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(N)\n\n    def objective(centers_flat):\n        \"\"\"\n        Calculates the maximum sum of radii for fixed centers using LP\n        and returns the gradient with respect to centers using dual variables.\n        \"\"\"\n        centers = centers_flat.reshape((N, 2))\n        \n        # Calculate distance to nearest boundary for each center b_i\n        b_i = np.zeros(N)\n        db_i_dx = np.zeros(N)\n        db_i_dy = np.zeros(N)\n        for i in range(N):\n            x, y = centers[i]\n            vals = [x, 1 - x, y, 1 - y]\n            min_val = min(vals)\n            b_i[i] = min_val\n            if min_val == vals[0]:\n                db_i_dx[i] = 1\n            elif min_val == vals[1]:\n                db_i_dx[i] = -1\n            elif min_val == vals[2]:\n                db_i_dy[i] = 1\n            else:\n                db_i_dy[i] = -1\n        \n        # Calculate pairwise distances d_ij\n        d_ij = np.zeros(n_pairs)\n        for idx, (i, j) in enumerate(pair_indices):\n            d_ij[idx] = np.linalg.norm(centers[i] - centers[j])\n        \n        # Right-hand side of the LP constraints: r_i + r_j <= d_ij and r_i <= b_i\n        b_ub = np.concatenate([d_ij, b_i])\n        \n        # Solve the LP using the HiGHS method which provides marginals (dual variables)\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, None), method='highs')\n        \n        if not res.success:\n            # Return a high value if the LP fails (though it should remain feasible)\n            return 1e6, np.zeros_like(centers_flat)\n        \n        # Extract dual variables (marginals) to compute the gradient\n        if hasattr(res, 'ineqlin') and res.ineqlin is not None and hasattr(res.ineqlin, 'marginals'):\n            marginals = res.ineqlin.marginals\n            if marginals is None:\n                return res.fun, np.zeros_like(centers_flat)\n            \n            lambdas = marginals[:n_pairs]\n            mus = marginals[n_pairs:]\n            \n            # Gradient calculation based on the sensitivity of the LP objective to RHS changes\n            grad = np.zeros((N, 2))\n            for idx, (i, j) in enumerate(pair_indices):\n                if lambdas[idx] < -1e-8:\n                    dist = d_ij[idx]\n                    if dist > 1e-9:\n                        diff = centers[i] - centers[j]\n                        grad[i] += lambdas[idx] * diff / dist\n                        grad[j] -= lambdas[idx] * diff / dist\n            \n            for i in range(N):\n                if mus[i] < -1e-8:\n                    grad[i, 0] += mus[i] * db_i_dx[i]\n                    grad[i, 1] += mus[i] * db_i_dy[i]\n            \n            return res.fun, grad.flatten()\n        else:\n            # Fallback for Scipy versions where marginals are not available\n            return res.fun, np.zeros_like(centers_flat)\n\n    # Initializations: Grid-based and random\n    # A 5x5 grid provides a solid baseline of 25 circles with r=0.1\n    xs = np.linspace(0.1, 0.9, 5)\n    ys = np.linspace(0.1, 0.9, 5)\n    x0_grid = []\n    for x in xs:\n        for y in ys:\n            x0_grid.append([x, y])\n    x0_grid.append([0.5, 0.5]) # 26th circle\n    x0_grid = np.array(x0_grid).flatten()\n    \n    best_fun = 1e6\n    best_x = x0_grid\n    \n    # Global optimization using Basin-hopping with L-BFGS-B local search\n    # We perform a few global iterations to balance time and search quality\n    try:\n        res_bh = basinhopping(objective, x0_grid, niter=25, T=0.005, \n                              minimizer_kwargs={'jac': True, 'method': 'L-BFGS-B', 'bounds': [(0, 1)]*52},\n                              stepsize=0.03)\n        if res_bh.fun < best_fun:\n            best_fun = res_bh.fun\n            best_x = res_bh.x\n    except:\n        pass\n        \n    # Attempt a second run from a random starting point to increase search space\n    try:\n        x0_rand = np.random.rand(52)\n        res_bh_rand = basinhopping(objective, x0_rand, niter=10, T=0.005, \n                                   minimizer_kwargs={'jac': True, 'method': 'L-BFGS-B', 'bounds': [(0, 1)]*52},\n                                   stepsize=0.03)\n        if res_bh_rand.fun < best_fun:\n            best_fun = res_bh_rand.fun\n            best_x = res_bh_rand.x\n    except:\n        pass\n\n    # Final extraction of centers and optimal radii\n    centers = best_x.reshape((N, 2))\n    b_i = np.minimum(np.minimum(centers[:, 0], 1 - centers[:, 0]),\n                     np.minimum(centers[:, 1], 1 - centers[:, 1]))\n    d_ij = [np.linalg.norm(centers[i] - centers[j]) for i, j in pair_indices]\n    b_ub_final = np.concatenate([d_ij, b_i])\n    res_final = linprog(c_lp, A_ub=A_ub, b_ub=b_ub_final, bounds=(0, None), method='highs')\n    \n    radii = res_final.x\n    sum_radii = -res_final.fun\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6121263300940534,
    "eval_time": 236.0577642917633,
    "error": null
  },
  "prompt": "Implement a 'Center-only' optimization using Basin-hopping or CMA-ES. The objective function for the optimizer should be the maximum sum of radii for a given set of centers. Since maximizing the sum of radii for fixed centers is a Linear Programming problem, use scipy.optimize.linprog inside the objective function to find the optimal radii for each set of centers proposed by the global optimizer.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, basinhopping\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Uses 'Center-only' optimization where the objective function is the maximum \n    sum of radii for a given set of centers, solved as a Linear Programming problem.\n    The gradient of the objective function is computed using the dual variables (marginals)\n    from the LP solver, allowing efficient global optimization with Basin-hopping.\n    \"\"\"\n    N = 26\n    n_pairs = N * (N - 1) // 2\n    pair_indices = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            pair_indices.append((i, j))\n    \n    # Precompute the constraint matrix A_ub for the LP.\n    # There are n_pairs constraints for circle-circle overlaps (r_i + r_j <= d_ij)\n    # and N constraints for circle-wall boundaries (r_i <= b_i).\n    A_ub = np.zeros((n_pairs + N, N))\n    for idx, (i, j) in enumerate(pair_indices):\n        A_ub[idx, i] = 1\n        A_ub[idx, j] = 1\n    for i in range(N):\n        A_ub[n_pairs + i, i] = 1\n        \n    # Objective for LP: minimize -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(N)\n\n    def objective(centers_flat):\n        \"\"\"\n        Calculates the maximum sum of radii for fixed centers using LP\n        and returns the gradient with respect to centers using dual variables.\n        \"\"\"\n        centers = centers_flat.reshape((N, 2))\n        \n        # Calculate distance to nearest boundary for each center b_i\n        b_i = np.zeros(N)\n        db_i_dx = np.zeros(N)\n        db_i_dy = np.zeros(N)\n        for i in range(N):\n            x, y = centers[i]\n            vals = [x, 1 - x, y, 1 - y]\n            min_val = min(vals)\n            b_i[i] = min_val\n            if min_val == vals[0]:\n                db_i_dx[i] = 1\n            elif min_val == vals[1]:\n                db_i_dx[i] = -1\n            elif min_val == vals[2]:\n                db_i_dy[i] = 1\n            else:\n                db_i_dy[i] = -1\n        \n        # Calculate pairwise distances d_ij\n        d_ij = np.zeros(n_pairs)\n        for idx, (i, j) in enumerate(pair_indices):\n            d_ij[idx] = np.linalg.norm(centers[i] - centers[j])\n        \n        # Right-hand side of the LP constraints: r_i + r_j <= d_ij and r_i <= b_i\n        b_ub = np.concatenate([d_ij, b_i])\n        \n        # Solve the LP using the HiGHS method which provides marginals (dual variables)\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, None), method='highs')\n        \n        if not res.success:\n            # Return a high value if the LP fails (though it should remain feasible)\n            return 1e6, np.zeros_like(centers_flat)\n        \n        # Extract dual variables (marginals) to compute the gradient\n        if hasattr(res, 'ineqlin') and res.ineqlin is not None and hasattr(res.ineqlin, 'marginals'):\n            marginals = res.ineqlin.marginals\n            if marginals is None:\n                return res.fun, np.zeros_like(centers_flat)\n            \n            lambdas = marginals[:n_pairs]\n            mus = marginals[n_pairs:]\n            \n            # Gradient calculation based on the sensitivity of the LP objective to RHS changes\n            grad = np.zeros((N, 2))\n            for idx, (i, j) in enumerate(pair_indices):\n                if lambdas[idx] < -1e-8:\n                    dist = d_ij[idx]\n                    if dist > 1e-9:\n                        diff = centers[i] - centers[j]\n                        grad[i] += lambdas[idx] * diff / dist\n                        grad[j] -= lambdas[idx] * diff / dist\n            \n            for i in range(N):\n                if mus[i] < -1e-8:\n                    grad[i, 0] += mus[i] * db_i_dx[i]\n                    grad[i, 1] += mus[i] * db_i_dy[i]\n            \n            return res.fun, grad.flatten()\n        else:\n            # Fallback for Scipy versions where marginals are not available\n            return res.fun, np.zeros_like(centers_flat)\n\n    # Initializations: Grid-based and random\n    # A 5x5 grid provides a solid baseline of 25 circles with r=0.1\n    xs = np.linspace(0.1, 0.9, 5)\n    ys = np.linspace(0.1, 0.9, 5)\n    x0_grid = []\n    for x in xs:\n        for y in ys:\n            x0_grid.append([x, y])\n    x0_grid.append([0.5, 0.5]) # 26th circle\n    x0_grid = np.array(x0_grid).flatten()\n    \n    best_fun = 1e6\n    best_x = x0_grid\n    \n    # Global optimization using Basin-hopping with L-BFGS-B local search\n    # We perform a few global iterations to balance time and search quality\n    try:\n        res_bh = basinhopping(objective, x0_grid, niter=25, T=0.005, \n                              minimizer_kwargs={'jac': True, 'method': 'L-BFGS-B', 'bounds': [(0, 1)]*52},\n                              stepsize=0.03)\n        if res_bh.fun < best_fun:\n            best_fun = res_bh.fun\n            best_x = res_bh.x\n    except:\n        pass\n        \n    # Attempt a second run from a random starting point to increase search space\n    try:\n        x0_rand = np.random.rand(52)\n        res_bh_rand = basinhopping(objective, x0_rand, niter=10, T=0.005, \n                                   minimizer_kwargs={'jac': True, 'method': 'L-BFGS-B', 'bounds': [(0, 1)]*52},\n                                   stepsize=0.03)\n        if res_bh_rand.fun < best_fun:\n            best_fun = res_bh_rand.fun\n            best_x = res_bh_rand.x\n    except:\n        pass\n\n    # Final extraction of centers and optimal radii\n    centers = best_x.reshape((N, 2))\n    b_i = np.minimum(np.minimum(centers[:, 0], 1 - centers[:, 0]),\n                     np.minimum(centers[:, 1], 1 - centers[:, 1]))\n    d_ij = [np.linalg.norm(centers[i] - centers[j]) for i, j in pair_indices]\n    b_ub_final = np.concatenate([d_ij, b_i])\n    res_final = linprog(c_lp, A_ub=A_ub, b_ub=b_ub_final, bounds=(0, None), method='highs')\n    \n    radii = res_final.x\n    sum_radii = -res_final.fun\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:05:38.090654",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 307,
        "candidates_token_count": 1927,
        "thoughts_token_count": 16313
      },
      "response_text_len": 5973
    }
  },
  "llm_call_duration_s": 106.9956642939942,
  "eval_duration_s": 236.0577746850904
}