{
  "trial_id": "trial_4_5",
  "generation": 4,
  "parent_id": "trial_1_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses multiple initializations (grid-based, circular, and random),\n    followed by SLSQP optimization and a shaking loop to avoid local optima.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Vectorized constraints for efficiency\n    # Constraints ensure each circle is within the [0,1]x[0,1] square\n    # and that no two circles overlap.\n    def constraints(vars):\n        c = vars[:2*N].reshape((N, 2))\n        r = vars[2*N:]\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - r_i - x_i >= 0, etc.\n        b_res = np.zeros(4 * N)\n        b_res[0:N] = c[:, 0] - r\n        b_res[N:2*N] = 1 - r - c[:, 0]\n        b_res[2*N:3*N] = c[:, 1] - r\n        b_res[3*N:4*N] = 1 - r - c[:, 1]\n        \n        # Overlap constraints: dist(i, j)^2 - (r_i + r_j)^2 >= 0\n        i, j = np.triu_indices(N, k=1)\n        dists_sq = (c[i, 0] - c[j, 0])**2 + (c[i, 1] - c[j, 1])**2\n        radii_sum_sq = (r[i] + r[j])**2\n        o_res = dists_sq - radii_sum_sq\n            \n        return np.concatenate([b_res, o_res])\n\n    def objective(vars):\n        # Minimize the negative sum of radii to maximize the sum\n        return -np.sum(vars[2*N:])\n\n    def get_initial_vars(mode):\n        if mode == 'grid1': # 5x5 grid + 1 circle\n            x, y = np.meshgrid(np.linspace(0.15, 0.85, 5), np.linspace(0.15, 0.85, 5))\n            c = np.vstack([x.ravel(), y.ravel()]).T\n            c = np.vstack([c, [0.5, 0.5]])\n        elif mode == 'grid2': # 6x5 grid, take 26\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 5))\n            c = np.vstack([x.ravel(), y.ravel()]).T\n            c = c[:N]\n        elif mode == 'circle': # Concentric circular arrangement\n            angles1 = np.linspace(0, 2*np.pi, 18, endpoint=False)\n            c1 = np.vstack([0.5 + 0.35*np.cos(angles1), 0.5 + 0.35*np.sin(angles1)]).T\n            angles2 = np.linspace(0, 2*np.pi, 7, endpoint=False)\n            c2 = np.vstack([0.5 + 0.15*np.cos(angles2), 0.5 + 0.15*np.sin(angles2)]).T\n            c = np.vstack([c1, c2, [0.5, 0.5]])\n        else: # Random initialization\n            c = np.random.rand(N, 2)\n        \n        # Start with a conservative radius to remain feasible\n        r = np.full(N, 0.05)\n        return np.hstack([c.ravel(), r])\n\n    # Variables: 26 (x,y) centers and 26 radii = 78 total\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n    \n    best_vars = None\n    best_sum = -1\n    \n    # Stage 1: Explore different structured initializations\n    for mode in ['grid1', 'grid2', 'circle', 'random']:\n        if time.time() - start_time > 200: break\n        v = get_initial_vars(mode)\n        res = minimize(objective, v, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints},\n                       bounds=bounds,\n                       options={'maxiter': 250, 'ftol': 1e-7})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n            \n    # Stage 2: Shaking and local refinement loop\n    # Perturb the best solution found so far and re-optimize to escape local maxima\n    while time.time() - start_time < 260:\n        c = best_vars[:2*N].reshape((N, 2))\n        r = best_vars[2*N:]\n        # Apply small random perturbations to centers\n        c_shaken = c + np.random.uniform(-0.03, 0.03, c.shape)\n        c_shaken = np.clip(c_shaken, 0, 1)\n        v_shaken = np.hstack([c_shaken.ravel(), r])\n        \n        res = minimize(objective, v_shaken, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints},\n                       bounds=bounds,\n                       options={'maxiter': 300, 'ftol': 1e-8})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n            \n    # Stage 3: High-precision final refinement\n    res = minimize(objective, best_vars, method='SLSQP',\n                   constraints={'type': 'ineq', 'fun': constraints},\n                   bounds=bounds,\n                   options={'maxiter': 1000, 'ftol': 1e-12})\n    \n    final_vars = res.x\n    final_centers = final_vars[:2*N].reshape((N, 2))\n    final_radii = final_vars[2*N:]\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, total_r = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5770686211679936,
    "eval_time": 271.6815354824066,
    "error": null
  },
  "prompt": "\n        Try a 'Tiled Initialization' strategy.\n        1. Start with several structured initializations: a 5x5 grid plus one circle, a hexagonal packing, and a few random ones.\n        2. For each, apply the 'shaking' and SLSQP refinement from trial_1_3.\n        3. Use a very tight tolerance (tol=1e-12) and a high number of max iterations in SLSQP to capture the best possible local sum.\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Pack 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The strategy uses multiple initializations (grid-based, circular, and random),\n    followed by SLSQP optimization and a shaking loop to avoid local optima.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Vectorized constraints for efficiency\n    # Constraints ensure each circle is within the [0,1]x[0,1] square\n    # and that no two circles overlap.\n    def constraints(vars):\n        c = vars[:2*N].reshape((N, 2))\n        r = vars[2*N:]\n        \n        # Boundary constraints: x_i - r_i >= 0, 1 - r_i - x_i >= 0, etc.\n        b_res = np.zeros(4 * N)\n        b_res[0:N] = c[:, 0] - r\n        b_res[N:2*N] = 1 - r - c[:, 0]\n        b_res[2*N:3*N] = c[:, 1] - r\n        b_res[3*N:4*N] = 1 - r - c[:, 1]\n        \n        # Overlap constraints: dist(i, j)^2 - (r_i + r_j)^2 >= 0\n        i, j = np.triu_indices(N, k=1)\n        dists_sq = (c[i, 0] - c[j, 0])**2 + (c[i, 1] - c[j, 1])**2\n        radii_sum_sq = (r[i] + r[j])**2\n        o_res = dists_sq - radii_sum_sq\n            \n        return np.concatenate([b_res, o_res])\n\n    def objective(vars):\n        # Minimize the negative sum of radii to maximize the sum\n        return -np.sum(vars[2*N:])\n\n    def get_initial_vars(mode):\n        if mode == 'grid1': # 5x5 grid + 1 circle\n            x, y = np.meshgrid(np.linspace(0.15, 0.85, 5), np.linspace(0.15, 0.85, 5))\n            c = np.vstack([x.ravel(), y.ravel()]).T\n            c = np.vstack([c, [0.5, 0.5]])\n        elif mode == 'grid2': # 6x5 grid, take 26\n            x, y = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 5))\n            c = np.vstack([x.ravel(), y.ravel()]).T\n            c = c[:N]\n        elif mode == 'circle': # Concentric circular arrangement\n            angles1 = np.linspace(0, 2*np.pi, 18, endpoint=False)\n            c1 = np.vstack([0.5 + 0.35*np.cos(angles1), 0.5 + 0.35*np.sin(angles1)]).T\n            angles2 = np.linspace(0, 2*np.pi, 7, endpoint=False)\n            c2 = np.vstack([0.5 + 0.15*np.cos(angles2), 0.5 + 0.15*np.sin(angles2)]).T\n            c = np.vstack([c1, c2, [0.5, 0.5]])\n        else: # Random initialization\n            c = np.random.rand(N, 2)\n        \n        # Start with a conservative radius to remain feasible\n        r = np.full(N, 0.05)\n        return np.hstack([c.ravel(), r])\n\n    # Variables: 26 (x,y) centers and 26 radii = 78 total\n    bounds = [(0, 1)] * (2 * N) + [(0, 0.5)] * N\n    \n    best_vars = None\n    best_sum = -1\n    \n    # Stage 1: Explore different structured initializations\n    for mode in ['grid1', 'grid2', 'circle', 'random']:\n        if time.time() - start_time > 200: break\n        v = get_initial_vars(mode)\n        res = minimize(objective, v, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints},\n                       bounds=bounds,\n                       options={'maxiter': 250, 'ftol': 1e-7})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n            \n    # Stage 2: Shaking and local refinement loop\n    # Perturb the best solution found so far and re-optimize to escape local maxima\n    while time.time() - start_time < 260:\n        c = best_vars[:2*N].reshape((N, 2))\n        r = best_vars[2*N:]\n        # Apply small random perturbations to centers\n        c_shaken = c + np.random.uniform(-0.03, 0.03, c.shape)\n        c_shaken = np.clip(c_shaken, 0, 1)\n        v_shaken = np.hstack([c_shaken.ravel(), r])\n        \n        res = minimize(objective, v_shaken, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints},\n                       bounds=bounds,\n                       options={'maxiter': 300, 'ftol': 1e-8})\n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_vars = res.x\n            \n    # Stage 3: High-precision final refinement\n    res = minimize(objective, best_vars, method='SLSQP',\n                   constraints={'type': 'ineq', 'fun': constraints},\n                   bounds=bounds,\n                   options={'maxiter': 1000, 'ftol': 1e-12})\n    \n    final_vars = res.x\n    final_centers = final_vars[:2*N].reshape((N, 2))\n    final_radii = final_vars[2*N:]\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, total_r = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:30:24.579729",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 332,
        "candidates_token_count": 1610,
        "thoughts_token_count": 20885
      },
      "response_text_len": 4513
    }
  },
  "llm_call_duration_s": 123.1558792310534,
  "eval_duration_s": 271.68154283601325
}