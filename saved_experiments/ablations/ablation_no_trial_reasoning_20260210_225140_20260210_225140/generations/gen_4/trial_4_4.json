{
  "trial_id": "trial_4_4",
  "generation": 4,
  "parent_id": "trial_1_4",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Force-Directed initialization followed by SLSQP optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for the upper triangle of the distance matrix\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_overlap = N * (N - 1) // 2\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Objective: maximize sum of radii (minimize negative sum)\n    def objective(vars):\n        return -np.sum(vars[2*N:])\n    \n    def objective_jac(vars):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n    \n    # Constraints: walls and no-overlap\n    def constraints_func(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        \n        c = np.zeros(4*N + num_overlap)\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        \n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        c[4*N:] = np.sqrt(dx*dx + dy*dy + 1e-12) - (r[idx_i] + r[idx_j])\n        return c\n\n    def constraints_jac(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        \n        jac = np.zeros((4*N + num_overlap, 3*N))\n        \n        # Wall constraints gradients\n        for i in range(N):\n            jac[i, i], jac[i, 2*N+i] = 1.0, -1.0\n            jac[N+i, i], jac[N+i, 2*N+i] = -1.0, -1.0\n            jac[2*N+i, N+i], jac[2*N+i, 2*N+i] = 1.0, -1.0\n            jac[3*N+i, N+i], jac[3*N+i, 2*N+i] = -1.0, -1.0\n            \n        # Overlap constraints gradients\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        dist = np.sqrt(dx*dx + dy*dy + 1e-12)\n        \n        row_idx = 4*N + np.arange(num_overlap)\n        jac[row_idx, idx_i] = dx / dist\n        jac[row_idx, idx_j] = -dx / dist\n        jac[row_idx, N + idx_i] = dy / dist\n        jac[row_idx, N + idx_j] = -dy / dist\n        jac[row_idx, 2*N + idx_i] = -1.0\n        jac[row_idx, 2*N + idx_j] = -1.0\n        \n        return jac\n\n    seed = 0\n    # Run until nearly out of time\n    while time.time() - start_time < 280:\n        np.random.seed(seed)\n        \n        # 1. Force-Directed Phase: Spread points using repulsion\n        p = np.random.rand(N, 2) * 0.8 + 0.1\n        for _ in range(150):\n            # Wall repulsion\n            fw_x = 0.01 / np.maximum(p[:, 0], 1e-3)**2 - 0.01 / np.maximum(1.0 - p[:, 0], 1e-3)**2\n            fw_y = 0.01 / np.maximum(p[:, 1], 1e-3)**2 - 0.01 / np.maximum(1.0 - p[:, 1], 1e-3)**2\n            \n            # Pairwise particle repulsion\n            dx = p[:, 0][:, np.newaxis] - p[:, 0]\n            dy = p[:, 1][:, np.newaxis] - p[:, 1]\n            dist2 = dx**2 + dy**2 + 1e-4\n            fx = np.sum(dx / dist2, axis=1)\n            fy = np.sum(dy / dist2, axis=1)\n            \n            # Update positions\n            strength = 0.002 * (1 + seed % 5)\n            p[:, 0] += strength * np.clip(fw_x + fx, -10, 10)\n            p[:, 1] += strength * np.clip(fw_y + fy, -10, 10)\n            p = np.clip(p, 0.01, 0.99)\n            \n        # 2. Optimization Phase: SLSQP with analytical Jacobians\n        # Initial radii guess\n        r_init = np.full(N, 0.07 + 0.03 * (seed % 3 / 2.0))\n        initial_guess = np.concatenate([p[:, 0], p[:, 1], r_init])\n        \n        res = minimize(\n            objective, \n            initial_guess, \n            method='SLSQP', \n            jac=objective_jac,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n            bounds=[(0, 1)]*2*N + [(0, 0.5)]*N,\n            options={'maxiter': 100}\n        )\n        \n        # Process the result\n        if res.fun < 0:\n            x_res, y_res, r_res = res.x[:N], res.x[N:2*N], res.x[2*N:]\n            \n            # Enforce strict feasibility via scaling\n            r_feas = np.minimum.reduce([r_res, x_res, 1.0 - x_res, y_res, 1.0 - y_res])\n            for _ in range(10):\n                dx = x_res[idx_i] - x_res[idx_j]\n                dy = y_res[idx_i] - y_res[idx_j]\n                dist = np.sqrt(dx*dx + dy*dy + 1e-15)\n                overlap = (r_feas[idx_i] + r_feas[idx_j]) - dist\n                mask = overlap > 0\n                if not np.any(mask):\n                    break\n                for k in np.where(mask)[0]:\n                    i, j = idx_i[k], idx_j[k]\n                    # Scale radii down to resolve overlap with a tiny safety margin\n                    s = (dist[k] / (r_feas[i] + r_feas[j])) * (1.0 - 1e-13)\n                    r_feas[i] *= s\n                    r_feas[j] *= s\n            \n            cur_sum = np.sum(r_feas)\n            if cur_sum > best_sum:\n                best_sum = cur_sum\n                best_centers = np.column_stack((x_res, y_res))\n                best_radii = r_feas\n                \n        seed += 1\n\n    # Final check if no valid solution was found\n    if best_centers is None:\n        best_radii = np.full(N, 0.01)\n        best_centers = np.random.rand(N, 2) * 0.8 + 0.1\n        best_sum = np.sum(best_radii)\n\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.6112612053080833,
    "eval_time": 286.37393522262573,
    "error": null
  },
  "prompt": "\n        Optimize the packing of 26 circles using a 'Force-Directed' initialization followed by a high-precision SLSQP.\n        The force-directed phase should treat circles as repulsive particles to find a good 'topology'.\n        Then, use SLSQP with analytical Jacobians to maximize the sum of radii.\n        Repeat this process with different random seeds and varying repulsion strengths.\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a Force-Directed initialization followed by SLSQP optimization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Pre-calculate indices for the upper triangle of the distance matrix\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_overlap = N * (N - 1) // 2\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Objective: maximize sum of radii (minimize negative sum)\n    def objective(vars):\n        return -np.sum(vars[2*N:])\n    \n    def objective_jac(vars):\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n    \n    # Constraints: walls and no-overlap\n    def constraints_func(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        \n        c = np.zeros(4*N + num_overlap)\n        c[0:N] = x - r\n        c[N:2*N] = 1.0 - x - r\n        c[2*N:3*N] = y - r\n        c[3*N:4*N] = 1.0 - y - r\n        \n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        c[4*N:] = np.sqrt(dx*dx + dy*dy + 1e-12) - (r[idx_i] + r[idx_j])\n        return c\n\n    def constraints_jac(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        \n        jac = np.zeros((4*N + num_overlap, 3*N))\n        \n        # Wall constraints gradients\n        for i in range(N):\n            jac[i, i], jac[i, 2*N+i] = 1.0, -1.0\n            jac[N+i, i], jac[N+i, 2*N+i] = -1.0, -1.0\n            jac[2*N+i, N+i], jac[2*N+i, 2*N+i] = 1.0, -1.0\n            jac[3*N+i, N+i], jac[3*N+i, 2*N+i] = -1.0, -1.0\n            \n        # Overlap constraints gradients\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        dist = np.sqrt(dx*dx + dy*dy + 1e-12)\n        \n        row_idx = 4*N + np.arange(num_overlap)\n        jac[row_idx, idx_i] = dx / dist\n        jac[row_idx, idx_j] = -dx / dist\n        jac[row_idx, N + idx_i] = dy / dist\n        jac[row_idx, N + idx_j] = -dy / dist\n        jac[row_idx, 2*N + idx_i] = -1.0\n        jac[row_idx, 2*N + idx_j] = -1.0\n        \n        return jac\n\n    seed = 0\n    # Run until nearly out of time\n    while time.time() - start_time < 280:\n        np.random.seed(seed)\n        \n        # 1. Force-Directed Phase: Spread points using repulsion\n        p = np.random.rand(N, 2) * 0.8 + 0.1\n        for _ in range(150):\n            # Wall repulsion\n            fw_x = 0.01 / np.maximum(p[:, 0], 1e-3)**2 - 0.01 / np.maximum(1.0 - p[:, 0], 1e-3)**2\n            fw_y = 0.01 / np.maximum(p[:, 1], 1e-3)**2 - 0.01 / np.maximum(1.0 - p[:, 1], 1e-3)**2\n            \n            # Pairwise particle repulsion\n            dx = p[:, 0][:, np.newaxis] - p[:, 0]\n            dy = p[:, 1][:, np.newaxis] - p[:, 1]\n            dist2 = dx**2 + dy**2 + 1e-4\n            fx = np.sum(dx / dist2, axis=1)\n            fy = np.sum(dy / dist2, axis=1)\n            \n            # Update positions\n            strength = 0.002 * (1 + seed % 5)\n            p[:, 0] += strength * np.clip(fw_x + fx, -10, 10)\n            p[:, 1] += strength * np.clip(fw_y + fy, -10, 10)\n            p = np.clip(p, 0.01, 0.99)\n            \n        # 2. Optimization Phase: SLSQP with analytical Jacobians\n        # Initial radii guess\n        r_init = np.full(N, 0.07 + 0.03 * (seed % 3 / 2.0))\n        initial_guess = np.concatenate([p[:, 0], p[:, 1], r_init])\n        \n        res = minimize(\n            objective, \n            initial_guess, \n            method='SLSQP', \n            jac=objective_jac,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n            bounds=[(0, 1)]*2*N + [(0, 0.5)]*N,\n            options={'maxiter': 100}\n        )\n        \n        # Process the result\n        if res.fun < 0:\n            x_res, y_res, r_res = res.x[:N], res.x[N:2*N], res.x[2*N:]\n            \n            # Enforce strict feasibility via scaling\n            r_feas = np.minimum.reduce([r_res, x_res, 1.0 - x_res, y_res, 1.0 - y_res])\n            for _ in range(10):\n                dx = x_res[idx_i] - x_res[idx_j]\n                dy = y_res[idx_i] - y_res[idx_j]\n                dist = np.sqrt(dx*dx + dy*dy + 1e-15)\n                overlap = (r_feas[idx_i] + r_feas[idx_j]) - dist\n                mask = overlap > 0\n                if not np.any(mask):\n                    break\n                for k in np.where(mask)[0]:\n                    i, j = idx_i[k], idx_j[k]\n                    # Scale radii down to resolve overlap with a tiny safety margin\n                    s = (dist[k] / (r_feas[i] + r_feas[j])) * (1.0 - 1e-13)\n                    r_feas[i] *= s\n                    r_feas[j] *= s\n            \n            cur_sum = np.sum(r_feas)\n            if cur_sum > best_sum:\n                best_sum = cur_sum\n                best_centers = np.column_stack((x_res, y_res))\n                best_radii = r_feas\n                \n        seed += 1\n\n    # Final check if no valid solution was found\n    if best_centers is None:\n        best_radii = np.full(N, 0.01)\n        best_centers = np.random.rand(N, 2) * 0.8 + 0.1\n        best_sum = np.sum(best_radii)\n\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:30:34.217187",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 309,
        "candidates_token_count": 1999,
        "thoughts_token_count": 20151
      },
      "response_text_len": 5273
    }
  },
  "llm_call_duration_s": 118.09833612001967,
  "eval_duration_s": 286.3739428559784
}