{
  "trial_id": "trial_4_1",
  "generation": 4,
  "parent_id": "trial_1_3",
  "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'Decoupled Center-Radii' approach by optimizing center positions with SLSQP\n    and solving for optimal radii using Linear Programming (LP).\n    The gradient of the sum of radii with respect to the centers is computed using\n    the dual variables of the LP.\n    \"\"\"\n    start_time = time.time()\n    N = 26\n    \n    # Pre-calculate the constraint matrix A_ub for the LP\n    # Variables: r_1, r_2, ..., r_26\n    # Constraints:\n    # 1. r_i + r_j <= d_ij (pairwise distance constraints)\n    # 2. r_i <= x_i\n    # 3. r_i <= 1 - x_i\n    # 4. r_i <= y_i\n    # 5. r_i <= 1 - y_i\n    \n    A_list = []\n    # Pairwise constraints: r_i + r_j <= d_ij\n    for i in range(N):\n        for j in range(i + 1, N):\n            row = np.zeros(N)\n            row[i] = 1\n            row[j] = 1\n            A_list.append(row)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    for k in range(4):\n        for i in range(N):\n            row = np.zeros(N)\n            row[i] = 1\n            A_list.append(row)\n    \n    A_ub = np.array(A_list)\n    # Objective: Maximize sum(r_i) <=> Minimize -sum(r_i)\n    c_lp = -np.ones(N)\n    \n    # Cache to store LP results for given center positions\n    _cache = {}\n\n    def _solve_at(centers_flat):\n        \"\"\"Solves the LP for fixed centers and computes the gradient via dual variables.\"\"\"\n        key = tuple(np.round(centers_flat, 10))\n        if key in _cache:\n            return _cache[key]\n        \n        centers = centers_flat.reshape((N, 2))\n        x = centers[:, 0]\n        y = centers[:, 1]\n        \n        # Calculate pairwise distances in the same order as A_ub\n        d_ij = pdist(centers)\n        \n        # Right-hand side of the constraints vector b\n        b = np.concatenate([d_ij, x, 1 - x, y, 1 - y])\n        \n        # Solve the LP using the HiGHS method for speed and dual marginals\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b, method='highs', bounds=(0, None))\n        \n        if not res.success or res.ineqlin.marginals is None:\n            # Fallback for numerical failures\n            _cache[key] = (0.0, np.zeros(52), np.zeros(N))\n            return _cache[key]\n        \n        sum_radii = -res.fun\n        radii = res.x\n        y_star = res.ineqlin.marginals # Sensitivity of res.fun to b (d(res.fun)/db)\n        \n        # Gradient of sum_radii S w.r.t. centers:\n        # S = -res.fun\n        # dS/dX = -d(res.fun)/dX = - (d(res.fun)/db * db/dX) = - (y_star * db/dX)\n        grad = np.zeros((N, 2))\n        \n        # dS/d(d_ij) = -y_star[idx]\n        idx = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if y_star[idx] != 0:\n                    dist = d_ij[idx]\n                    if dist < 1e-9: dist = 1e-9\n                    val_x = -y_star[idx] * (x[i] - x[j]) / dist\n                    val_y = -y_star[idx] * (y[i] - y[j]) / dist\n                    grad[i, 0] += val_x\n                    grad[i, 1] += val_y\n                    grad[j, 0] -= val_x\n                    grad[j, 1] -= val_y\n                idx += 1\n        \n        # dS/d(x_i), dS/d(1-x_i), etc.\n        for i in range(N):\n            # Indices for x_i, 1-x_i, y_i, 1-y_i in b: 325+i, 351+i, 377+i, 403+i\n            grad[i, 0] += -y_star[325 + i]      # dS/db[325+i] * db[325+i]/dx_i\n            grad[i, 0] -= -y_star[351 + i]      # dS/db[351+i] * db[351+i]/dx_i\n            grad[i, 1] += -y_star[377 + i]      # dS/db[377+i] * db[377+i]/dy_i\n            grad[i, 1] -= -y_star[403 + i]      # dS/db[403+i] * db[403+i]/dy_i\n            \n        _cache[key] = (sum_radii, grad.flatten(), radii)\n        return _cache[key]\n\n    def objective(centers_flat):\n        s, _, _ = _solve_at(centers_flat)\n        return -s # Minimize negative sum of radii\n\n    def grad_objective(centers_flat):\n        _, g, _ = _solve_at(centers_flat)\n        return -g # Gradient of negative sum of radii\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Initialization 1: A 5x5 grid (25 circles) + 1 extra circle\n    grid = np.linspace(0.1, 0.9, 5)\n    xx, yy = np.meshgrid(grid, grid)\n    centers_grid = np.vstack([xx.flatten(), yy.flatten()]).T\n    centers_grid = np.vstack([centers_grid, [0.01, 0.01]])\n    \n    starts = [centers_grid.flatten()]\n    \n    # Additional random starts for global search\n    np.random.seed(42)\n    for _ in range(15):\n        starts.append(np.random.rand(52))\n        \n    for start_centers in starts:\n        # Respect the 300-second time limit\n        if time.time() - start_time > 280:\n            break\n            \n        res = minimize(objective, start_centers, jac=grad_objective, \n                       method='SLSQP', bounds=[(0, 1)]*52, options={'maxiter': 100})\n        \n        curr_sum, _, curr_radii = _solve_at(res.x)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_centers = res.x.reshape((N, 2))\n            best_radii = curr_radii\n            \n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "score": 2.571528364860777,
    "eval_time": 145.6015853881836,
    "error": null
  },
  "prompt": "\n        Implement a 'Decoupled Center-Radii' optimization.\n        1. For a fixed set of 26 centers (x, y), the problem of maximizing the sum of radii is a Linear Programming (LP) problem.\n        2. Use `scipy.optimize.linprog` to solve for radii given centers.\n        3. Use a global optimizer (like Basin-Hopping or a Multi-start SLSQP) to optimize the center positions (x, y).\n        4. The objective function for the center optimizer should be the sum of radii returned by the LP solver.\n        5. This decouples the non-convex geometry (centers) from the convex optimization (radii).\n        ",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses a 'Decoupled Center-Radii' approach by optimizing center positions with SLSQP\n    and solving for optimal radii using Linear Programming (LP).\n    The gradient of the sum of radii with respect to the centers is computed using\n    the dual variables of the LP.\n    \"\"\"\n    start_time = time.time()\n    N = 26\n    \n    # Pre-calculate the constraint matrix A_ub for the LP\n    # Variables: r_1, r_2, ..., r_26\n    # Constraints:\n    # 1. r_i + r_j <= d_ij (pairwise distance constraints)\n    # 2. r_i <= x_i\n    # 3. r_i <= 1 - x_i\n    # 4. r_i <= y_i\n    # 5. r_i <= 1 - y_i\n    \n    A_list = []\n    # Pairwise constraints: r_i + r_j <= d_ij\n    for i in range(N):\n        for j in range(i + 1, N):\n            row = np.zeros(N)\n            row[i] = 1\n            row[j] = 1\n            A_list.append(row)\n    \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    for k in range(4):\n        for i in range(N):\n            row = np.zeros(N)\n            row[i] = 1\n            A_list.append(row)\n    \n    A_ub = np.array(A_list)\n    # Objective: Maximize sum(r_i) <=> Minimize -sum(r_i)\n    c_lp = -np.ones(N)\n    \n    # Cache to store LP results for given center positions\n    _cache = {}\n\n    def _solve_at(centers_flat):\n        \"\"\"Solves the LP for fixed centers and computes the gradient via dual variables.\"\"\"\n        key = tuple(np.round(centers_flat, 10))\n        if key in _cache:\n            return _cache[key]\n        \n        centers = centers_flat.reshape((N, 2))\n        x = centers[:, 0]\n        y = centers[:, 1]\n        \n        # Calculate pairwise distances in the same order as A_ub\n        d_ij = pdist(centers)\n        \n        # Right-hand side of the constraints vector b\n        b = np.concatenate([d_ij, x, 1 - x, y, 1 - y])\n        \n        # Solve the LP using the HiGHS method for speed and dual marginals\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b, method='highs', bounds=(0, None))\n        \n        if not res.success or res.ineqlin.marginals is None:\n            # Fallback for numerical failures\n            _cache[key] = (0.0, np.zeros(52), np.zeros(N))\n            return _cache[key]\n        \n        sum_radii = -res.fun\n        radii = res.x\n        y_star = res.ineqlin.marginals # Sensitivity of res.fun to b (d(res.fun)/db)\n        \n        # Gradient of sum_radii S w.r.t. centers:\n        # S = -res.fun\n        # dS/dX = -d(res.fun)/dX = - (d(res.fun)/db * db/dX) = - (y_star * db/dX)\n        grad = np.zeros((N, 2))\n        \n        # dS/d(d_ij) = -y_star[idx]\n        idx = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if y_star[idx] != 0:\n                    dist = d_ij[idx]\n                    if dist < 1e-9: dist = 1e-9\n                    val_x = -y_star[idx] * (x[i] - x[j]) / dist\n                    val_y = -y_star[idx] * (y[i] - y[j]) / dist\n                    grad[i, 0] += val_x\n                    grad[i, 1] += val_y\n                    grad[j, 0] -= val_x\n                    grad[j, 1] -= val_y\n                idx += 1\n        \n        # dS/d(x_i), dS/d(1-x_i), etc.\n        for i in range(N):\n            # Indices for x_i, 1-x_i, y_i, 1-y_i in b: 325+i, 351+i, 377+i, 403+i\n            grad[i, 0] += -y_star[325 + i]      # dS/db[325+i] * db[325+i]/dx_i\n            grad[i, 0] -= -y_star[351 + i]      # dS/db[351+i] * db[351+i]/dx_i\n            grad[i, 1] += -y_star[377 + i]      # dS/db[377+i] * db[377+i]/dy_i\n            grad[i, 1] -= -y_star[403 + i]      # dS/db[403+i] * db[403+i]/dy_i\n            \n        _cache[key] = (sum_radii, grad.flatten(), radii)\n        return _cache[key]\n\n    def objective(centers_flat):\n        s, _, _ = _solve_at(centers_flat)\n        return -s # Minimize negative sum of radii\n\n    def grad_objective(centers_flat):\n        _, g, _ = _solve_at(centers_flat)\n        return -g # Gradient of negative sum of radii\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Initialization 1: A 5x5 grid (25 circles) + 1 extra circle\n    grid = np.linspace(0.1, 0.9, 5)\n    xx, yy = np.meshgrid(grid, grid)\n    centers_grid = np.vstack([xx.flatten(), yy.flatten()]).T\n    centers_grid = np.vstack([centers_grid, [0.01, 0.01]])\n    \n    starts = [centers_grid.flatten()]\n    \n    # Additional random starts for global search\n    np.random.seed(42)\n    for _ in range(15):\n        starts.append(np.random.rand(52))\n        \n    for start_centers in starts:\n        # Respect the 300-second time limit\n        if time.time() - start_time > 280:\n            break\n            \n        res = minimize(objective, start_centers, jac=grad_objective, \n                       method='SLSQP', bounds=[(0, 1)]*52, options={'maxiter': 100})\n        \n        curr_sum, _, curr_radii = _solve_at(res.x)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_centers = res.x.reshape((N, 2))\n            best_radii = curr_radii\n            \n    return best_centers, best_radii, best_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:28:19.101453",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 379,
        "candidates_token_count": 1922,
        "thoughts_token_count": 19680
      },
      "response_text_len": 5314
    }
  },
  "llm_call_duration_s": 123.7565106669208,
  "eval_duration_s": 145.60159292607568
}