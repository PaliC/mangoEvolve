{
  "trial_id": "trial_5_2",
  "generation": 5,
  "parent_id": "trial_1_3",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The approach uses Basin-Hopping/Coordinate Descent on the circle centers, \n    solving a Linear Programming (LP) problem at each step to determine the \n    optimal radii for a given center configuration.\n    \"\"\"\n    N = 26\n    \n    # Pre-calculate the coefficient matrix for the LP constraints.\n    # The objective is to maximize the sum of radii r_i, subject to:\n    # 1. r_i + r_j <= distance between centers i and j (no overlap)\n    # 2. r_i <= distance to the nearest boundary (stay inside the square)\n    # 3. r_i >= 0\n    #\n    # The A_ub matrix corresponds to the r_i + r_j constraints.\n    # There are N*(N-1)/2 pairs of circles.\n    A_ub = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            row = np.zeros(N)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n    A_ub = np.array(A_ub)\n    \n    # Objective function coefficients for linprog (minimizing -sum(r_i))\n    c = -np.ones(N)\n\n    def solve_lp(centers):\n        \"\"\"\n        Solves the Linear Program to find the optimal radii for fixed centers.\n        \"\"\"\n        try:\n            # Pairwise distances between centers\n            b_ub = pdist(centers)\n            # Distance of each center to the boundaries of the [0,1]x[0,1] square\n            b_boundary = np.min(np.hstack([centers, 1 - centers]), axis=1)\n            # Upper bounds for each r_i based on boundary constraints\n            bounds = [(0, max(0, b)) for b in b_boundary]\n            \n            # Using 'highs' method for efficient linear programming\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                return -res.fun, res.x\n        except Exception:\n            pass\n        return 0.0, np.zeros(N)\n\n    # Global best trackers\n    best_sum = 0.0\n    best_centers = np.zeros((N, 2))\n    best_radii = np.zeros(N)\n\n    start_time = time.time()\n    \n    # Try different initialization strategies to cover the search space\n    # 1. 'grid': Regular 5x5 grid plus one extra circle\n    # 2. 'grid_perturbed': A grid with some random noise\n    # 3. 'random': Completely random center positions\n    start_types = ['grid', 'grid_perturbed', 'random']\n    \n    for start_type in start_types:\n        # Respect the 300-second time limit\n        if time.time() - start_time > 280:\n            break\n            \n        if start_type == 'grid':\n            grid_vals = np.linspace(0.1, 0.9, 5)\n            xi, yi = np.meshgrid(grid_vals, grid_vals)\n            centers = np.stack([xi.flatten(), yi.flatten()], axis=1)\n            # Add 26th circle at a spare location\n            centers = np.vstack([centers, [0.05, 0.05]])\n        elif start_type == 'grid_perturbed':\n            grid_vals = np.linspace(0.1, 0.9, 5)\n            xi, yi = np.meshgrid(grid_vals, grid_vals)\n            centers = np.stack([xi.flatten(), yi.flatten()], axis=1)\n            centers = np.vstack([centers, [0.05, 0.05]])\n            centers += np.random.normal(0, 0.015, (N, 2))\n            centers = np.clip(centers, 0, 1)\n        else:\n            centers = np.random.rand(N, 2)\n        \n        current_sum, current_radii = solve_lp(centers)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = current_radii.copy()\n\n        # Local search: Optimize the center positions iteratively\n        inner_start_time = time.time()\n        # Allocate roughly 90 seconds for each initialization type\n        while time.time() - inner_start_time < 90 and time.time() - start_time < 285:\n            changed = False\n            # Coordinate-descent-like approach: move one center at a time\n            for i in range(N):\n                old_pos = centers[i].copy()\n                # Try a few small random moves for the current center\n                for _ in range(2):\n                    # Step size for local perturbation\n                    perturbation = np.random.normal(0, 0.015, 2)\n                    centers[i] = np.clip(old_pos + perturbation, 0, 1)\n                    \n                    new_sum, new_radii = solve_lp(centers)\n                    if new_sum > current_sum:\n                        current_sum = new_sum\n                        current_radii = new_radii\n                        changed = True\n                        if current_sum > best_sum:\n                            best_sum = current_sum\n                            best_centers = centers.copy()\n                            best_radii = current_radii.copy()\n                        break # Found an improvement for this circle\n                    else:\n                        centers[i] = old_pos\n            \n            # If no improvement was found in the entire set of circles, \n            # jump to a perturbed version of the current best to escape local optima.\n            if not changed:\n                centers = np.clip(best_centers + np.random.normal(0, 0.02, (N, 2)), 0, 1)\n                current_sum, current_radii = solve_lp(centers)\n\n    # Return the best configuration found\n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 2.5041844829508566,
    "eval_time": 270.67665910720825,
    "error": null
  },
  "prompt": "Implement a Basin-Hopping approach where the objective function is the optimal sum of radii for a given set of centers. For any center configuration (x, y), the optimal radii can be found using Linear Programming (scipy.optimize.linprog). The Basin-Hopping should move centers, and for each step, solve the LP to get the score. This decouples center placement from radii sizing.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.spatial.distance import pdist\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The approach uses Basin-Hopping/Coordinate Descent on the circle centers, \n    solving a Linear Programming (LP) problem at each step to determine the \n    optimal radii for a given center configuration.\n    \"\"\"\n    N = 26\n    \n    # Pre-calculate the coefficient matrix for the LP constraints.\n    # The objective is to maximize the sum of radii r_i, subject to:\n    # 1. r_i + r_j <= distance between centers i and j (no overlap)\n    # 2. r_i <= distance to the nearest boundary (stay inside the square)\n    # 3. r_i >= 0\n    #\n    # The A_ub matrix corresponds to the r_i + r_j constraints.\n    # There are N*(N-1)/2 pairs of circles.\n    A_ub = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            row = np.zeros(N)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n    A_ub = np.array(A_ub)\n    \n    # Objective function coefficients for linprog (minimizing -sum(r_i))\n    c = -np.ones(N)\n\n    def solve_lp(centers):\n        \"\"\"\n        Solves the Linear Program to find the optimal radii for fixed centers.\n        \"\"\"\n        try:\n            # Pairwise distances between centers\n            b_ub = pdist(centers)\n            # Distance of each center to the boundaries of the [0,1]x[0,1] square\n            b_boundary = np.min(np.hstack([centers, 1 - centers]), axis=1)\n            # Upper bounds for each r_i based on boundary constraints\n            bounds = [(0, max(0, b)) for b in b_boundary]\n            \n            # Using 'highs' method for efficient linear programming\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                return -res.fun, res.x\n        except Exception:\n            pass\n        return 0.0, np.zeros(N)\n\n    # Global best trackers\n    best_sum = 0.0\n    best_centers = np.zeros((N, 2))\n    best_radii = np.zeros(N)\n\n    start_time = time.time()\n    \n    # Try different initialization strategies to cover the search space\n    # 1. 'grid': Regular 5x5 grid plus one extra circle\n    # 2. 'grid_perturbed': A grid with some random noise\n    # 3. 'random': Completely random center positions\n    start_types = ['grid', 'grid_perturbed', 'random']\n    \n    for start_type in start_types:\n        # Respect the 300-second time limit\n        if time.time() - start_time > 280:\n            break\n            \n        if start_type == 'grid':\n            grid_vals = np.linspace(0.1, 0.9, 5)\n            xi, yi = np.meshgrid(grid_vals, grid_vals)\n            centers = np.stack([xi.flatten(), yi.flatten()], axis=1)\n            # Add 26th circle at a spare location\n            centers = np.vstack([centers, [0.05, 0.05]])\n        elif start_type == 'grid_perturbed':\n            grid_vals = np.linspace(0.1, 0.9, 5)\n            xi, yi = np.meshgrid(grid_vals, grid_vals)\n            centers = np.stack([xi.flatten(), yi.flatten()], axis=1)\n            centers = np.vstack([centers, [0.05, 0.05]])\n            centers += np.random.normal(0, 0.015, (N, 2))\n            centers = np.clip(centers, 0, 1)\n        else:\n            centers = np.random.rand(N, 2)\n        \n        current_sum, current_radii = solve_lp(centers)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = current_radii.copy()\n\n        # Local search: Optimize the center positions iteratively\n        inner_start_time = time.time()\n        # Allocate roughly 90 seconds for each initialization type\n        while time.time() - inner_start_time < 90 and time.time() - start_time < 285:\n            changed = False\n            # Coordinate-descent-like approach: move one center at a time\n            for i in range(N):\n                old_pos = centers[i].copy()\n                # Try a few small random moves for the current center\n                for _ in range(2):\n                    # Step size for local perturbation\n                    perturbation = np.random.normal(0, 0.015, 2)\n                    centers[i] = np.clip(old_pos + perturbation, 0, 1)\n                    \n                    new_sum, new_radii = solve_lp(centers)\n                    if new_sum > current_sum:\n                        current_sum = new_sum\n                        current_radii = new_radii\n                        changed = True\n                        if current_sum > best_sum:\n                            best_sum = current_sum\n                            best_centers = centers.copy()\n                            best_radii = current_radii.copy()\n                        break # Found an improvement for this circle\n                    else:\n                        centers[i] = old_pos\n            \n            # If no improvement was found in the entire set of circles, \n            # jump to a perturbed version of the current best to escape local optima.\n            if not changed:\n                centers = np.clip(best_centers + np.random.normal(0, 0.02, (N, 2)), 0, 1)\n                current_sum, current_radii = solve_lp(centers)\n\n    # Return the best configuration found\n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:38:25.688629",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 310,
        "candidates_token_count": 1529,
        "thoughts_token_count": 21668
      },
      "response_text_len": 5364
    }
  },
  "llm_call_duration_s": 140.7845890239114,
  "eval_duration_s": 270.6766658910783
}