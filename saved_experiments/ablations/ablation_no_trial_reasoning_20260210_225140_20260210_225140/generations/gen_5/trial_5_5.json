{
  "trial_id": "trial_5_5",
  "generation": 5,
  "parent_id": "trial_1_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP with analytical Jacobians and Sobol sequence initialization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Objective function: Minimize negative sum of radii to maximize the sum\n    def obj_func(v):\n        return -np.sum(v[2::3])\n\n    def obj_jac(v):\n        # Gradient is -1 for all r_i and 0 for all x_i, y_i\n        j = np.zeros(3 * N)\n        j[2::3] = -1.0\n        return j\n\n    # Constraints: circles must be inside the square and not overlap\n    def con_func(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_boundary = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Non-overlap constraints: (x_i-x_j)^2 + (y_i-y_j)^2 - (r_i+r_j)^2 >= 0\n        c_overlap = np.zeros(N * (N - 1) // 2)\n        idx = 0\n        for i in range(N):\n            js = np.arange(i + 1, N)\n            c_overlap[idx : idx + len(js)] = (x[i] - x[js])**2 + (y[i] - y[js])**2 - (r[i] + r[js])**2\n            idx += len(js)\n        return np.concatenate([c_boundary, c_overlap])\n\n    def con_jac(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        M = 4 * N + N * (N - 1) // 2\n        jac = np.zeros((M, 3 * N))\n        \n        # Boundary constraints\n        idx_N = np.arange(N)\n        # x-r >= 0\n        jac[idx_N, 3 * idx_N] = 1.0\n        jac[idx_N, 3 * idx_N + 2] = -1.0\n        # 1-x-r >= 0\n        jac[N + idx_N, 3 * idx_N] = -1.0\n        jac[N + idx_N, 3 * idx_N + 2] = -1.0\n        # y-r >= 0\n        jac[2 * N + idx_N, 3 * idx_N + 1] = 1.0\n        jac[2 * N + idx_N, 3 * idx_N + 2] = -1.0\n        # 1-y-r >= 0\n        jac[3 * N + idx_N, 3 * idx_N + 1] = -1.0\n        jac[3 * N + idx_N, 3 * idx_N + 2] = -1.0\n        \n        # Non-overlap constraints\n        row_idx = 4 * N\n        for i in range(N):\n            js = np.arange(i + 1, N)\n            dx, dy, dr = x[i] - x[js], y[i] - y[js], r[i] + r[js]\n            rows = np.arange(row_idx, row_idx + len(js))\n            \n            jac[rows, 3 * i] = 2 * dx\n            jac[rows, 3 * js] = -2 * dx\n            jac[rows, 3 * i + 1] = 2 * dy\n            jac[rows, 3 * js + 1] = -2 * dy\n            jac[rows, 3 * i + 2] = -2 * dr\n            jac[rows, 3 * js + 2] = -2 * dr\n            row_idx += len(js)\n        return jac\n\n    # Variable bounds: (x, y) in [0, 1], r in [0, 0.5]\n    bounds = []\n    for _ in range(N):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n\n    # Initialize different starting points\n    starts = []\n    \n    # 1. 5x5 Grid initialization (25 circles) + 1 extra\n    v55 = np.zeros(3 * N)\n    xs = np.linspace(0.1, 0.9, 5)\n    ys = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(xs, ys)\n    v55[0:75:3] = xv.flatten() + np.random.uniform(-0.005, 0.005, 25)\n    v55[1:75:3] = yv.flatten() + np.random.uniform(-0.005, 0.005, 25)\n    v55[2:75:3] = 0.099\n    v55[75:78] = [np.random.uniform(0, 1), np.random.uniform(0, 1), 0.01]\n    starts.append(np.clip(v55, 0, 1))\n\n    # 2. 4x6 Grid initialization (24 circles) + 2 extra\n    v46 = np.zeros(3 * N)\n    xs = np.linspace(1/8, 7/8, 4)\n    ys = np.linspace(1/12, 11/12, 6)\n    xv, yv = np.meshgrid(xs, ys)\n    v46[0:72:3] = xv.flatten() + np.random.uniform(-0.005, 0.005, 24)\n    v46[1:72:3] = yv.flatten() + np.random.uniform(-0.005, 0.005, 24)\n    v46[2:72:3] = 0.082\n    v46[72:75] = [np.random.uniform(0, 1), np.random.uniform(0, 1), 0.01]\n    v46[75:78] = [np.random.uniform(0, 1), np.random.uniform(0, 1), 0.01]\n    starts.append(np.clip(v46, 0, 1))\n\n    # 3. Sobol Sequence or Random initialization\n    try:\n        from scipy.stats import qmc\n        sampler = qmc.Sobol(d=3 * N, scramble=True)\n        samples = sampler.random(40)\n    except (ImportError, AttributeError):\n        samples = np.random.rand(40, 3 * N)\n    \n    for s in samples:\n        s[2::3] *= 0.15 # Scale radii to be more realistic\n        starts.append(s)\n\n    best_v = starts[0]\n    best_sum = -1.0\n\n    # Multi-start optimization\n    for v0 in starts:\n        if time.time() - start_time > 280:\n            break\n        \n        # Optimization pass\n        res = minimize(obj_func, v0, jac=obj_jac, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': con_func, 'jac': con_jac},\n                       bounds=bounds, options={'maxiter': 100, 'ftol': 1e-4})\n        \n        res = minimize(obj_func, res.x, jac=obj_jac, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': con_func, 'jac': con_jac},\n                       bounds=bounds, options={'maxiter': 150, 'ftol': 1e-8})\n        \n        # Feasibility check and update best result\n        if np.all(con_func(res.x) >= -1e-7):\n            current_sum = np.sum(res.x[2::3])\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_v = res.x.copy()\n\n    # Final result extraction\n    centers = best_v.reshape(N, 3)[:, :2]\n    radii = best_v.reshape(N, 3)[:, 2]\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6239283780412674,
    "eval_time": 92.97924208641052,
    "error": null
  },
  "prompt": "Focus on a high-iteration Multi-start SLSQP with very refined constraints. Use Sobol sequences for initialization to cover the space better than random sampling. For each start, use a two-pass SLSQP: first with a loose tolerance to find the basin, then with a very tight tolerance and analytical Jacobians for the final result.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses multi-start SLSQP with analytical Jacobians and Sobol sequence initialization.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Objective function: Minimize negative sum of radii to maximize the sum\n    def obj_func(v):\n        return -np.sum(v[2::3])\n\n    def obj_jac(v):\n        # Gradient is -1 for all r_i and 0 for all x_i, y_i\n        j = np.zeros(3 * N)\n        j[2::3] = -1.0\n        return j\n\n    # Constraints: circles must be inside the square and not overlap\n    def con_func(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        # Boundary constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        c_boundary = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Non-overlap constraints: (x_i-x_j)^2 + (y_i-y_j)^2 - (r_i+r_j)^2 >= 0\n        c_overlap = np.zeros(N * (N - 1) // 2)\n        idx = 0\n        for i in range(N):\n            js = np.arange(i + 1, N)\n            c_overlap[idx : idx + len(js)] = (x[i] - x[js])**2 + (y[i] - y[js])**2 - (r[i] + r[js])**2\n            idx += len(js)\n        return np.concatenate([c_boundary, c_overlap])\n\n    def con_jac(v):\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        M = 4 * N + N * (N - 1) // 2\n        jac = np.zeros((M, 3 * N))\n        \n        # Boundary constraints\n        idx_N = np.arange(N)\n        # x-r >= 0\n        jac[idx_N, 3 * idx_N] = 1.0\n        jac[idx_N, 3 * idx_N + 2] = -1.0\n        # 1-x-r >= 0\n        jac[N + idx_N, 3 * idx_N] = -1.0\n        jac[N + idx_N, 3 * idx_N + 2] = -1.0\n        # y-r >= 0\n        jac[2 * N + idx_N, 3 * idx_N + 1] = 1.0\n        jac[2 * N + idx_N, 3 * idx_N + 2] = -1.0\n        # 1-y-r >= 0\n        jac[3 * N + idx_N, 3 * idx_N + 1] = -1.0\n        jac[3 * N + idx_N, 3 * idx_N + 2] = -1.0\n        \n        # Non-overlap constraints\n        row_idx = 4 * N\n        for i in range(N):\n            js = np.arange(i + 1, N)\n            dx, dy, dr = x[i] - x[js], y[i] - y[js], r[i] + r[js]\n            rows = np.arange(row_idx, row_idx + len(js))\n            \n            jac[rows, 3 * i] = 2 * dx\n            jac[rows, 3 * js] = -2 * dx\n            jac[rows, 3 * i + 1] = 2 * dy\n            jac[rows, 3 * js + 1] = -2 * dy\n            jac[rows, 3 * i + 2] = -2 * dr\n            jac[rows, 3 * js + 2] = -2 * dr\n            row_idx += len(js)\n        return jac\n\n    # Variable bounds: (x, y) in [0, 1], r in [0, 0.5]\n    bounds = []\n    for _ in range(N):\n        bounds.extend([(0, 1), (0, 1), (0, 0.5)])\n\n    # Initialize different starting points\n    starts = []\n    \n    # 1. 5x5 Grid initialization (25 circles) + 1 extra\n    v55 = np.zeros(3 * N)\n    xs = np.linspace(0.1, 0.9, 5)\n    ys = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(xs, ys)\n    v55[0:75:3] = xv.flatten() + np.random.uniform(-0.005, 0.005, 25)\n    v55[1:75:3] = yv.flatten() + np.random.uniform(-0.005, 0.005, 25)\n    v55[2:75:3] = 0.099\n    v55[75:78] = [np.random.uniform(0, 1), np.random.uniform(0, 1), 0.01]\n    starts.append(np.clip(v55, 0, 1))\n\n    # 2. 4x6 Grid initialization (24 circles) + 2 extra\n    v46 = np.zeros(3 * N)\n    xs = np.linspace(1/8, 7/8, 4)\n    ys = np.linspace(1/12, 11/12, 6)\n    xv, yv = np.meshgrid(xs, ys)\n    v46[0:72:3] = xv.flatten() + np.random.uniform(-0.005, 0.005, 24)\n    v46[1:72:3] = yv.flatten() + np.random.uniform(-0.005, 0.005, 24)\n    v46[2:72:3] = 0.082\n    v46[72:75] = [np.random.uniform(0, 1), np.random.uniform(0, 1), 0.01]\n    v46[75:78] = [np.random.uniform(0, 1), np.random.uniform(0, 1), 0.01]\n    starts.append(np.clip(v46, 0, 1))\n\n    # 3. Sobol Sequence or Random initialization\n    try:\n        from scipy.stats import qmc\n        sampler = qmc.Sobol(d=3 * N, scramble=True)\n        samples = sampler.random(40)\n    except (ImportError, AttributeError):\n        samples = np.random.rand(40, 3 * N)\n    \n    for s in samples:\n        s[2::3] *= 0.15 # Scale radii to be more realistic\n        starts.append(s)\n\n    best_v = starts[0]\n    best_sum = -1.0\n\n    # Multi-start optimization\n    for v0 in starts:\n        if time.time() - start_time > 280:\n            break\n        \n        # Optimization pass\n        res = minimize(obj_func, v0, jac=obj_jac, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': con_func, 'jac': con_jac},\n                       bounds=bounds, options={'maxiter': 100, 'ftol': 1e-4})\n        \n        res = minimize(obj_func, res.x, jac=obj_jac, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': con_func, 'jac': con_jac},\n                       bounds=bounds, options={'maxiter': 150, 'ftol': 1e-8})\n        \n        # Feasibility check and update best result\n        if np.all(con_func(res.x) >= -1e-7):\n            current_sum = np.sum(res.x[2::3])\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_v = res.x.copy()\n\n    # Final result extraction\n    centers = best_v.reshape(N, 3)[:, :2]\n    radii = best_v.reshape(N, 3)[:, 2]\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:35:53.072593",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 296,
        "candidates_token_count": 2179,
        "thoughts_token_count": 28447
      },
      "response_text_len": 5233
    }
  },
  "llm_call_duration_s": 165.85242484603077,
  "eval_duration_s": 92.97924941894598
}