{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses SLSQP optimization with multiple initial configurations, including a 5x5 grid\n    plus one circle and hexagonal-inspired layouts.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Objective function: maximize sum of radii (minimize negative sum)\n    def objective(x):\n        return -np.sum(x[:n])\n    \n    # Gradient of the objective function\n    def objective_jac(x):\n        grad = np.zeros(3*n)\n        grad[:n] = -1.0\n        return grad\n\n    # Nonlinear constraints: box boundaries and non-overlap\n    def constraints_func(x):\n        r = x[:n]\n        xs = x[n:2*n]\n        ys = x[2*n:3*n]\n        # Total number of constraints: 4*n (box) + n*(n-1)//2 (overlap)\n        res = np.zeros(4*n + n*(n-1)//2)\n        \n        # Box constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        res[0:n] = xs - r\n        res[n:2*n] = 1.0 - xs - r\n        res[2*n:3*n] = ys - r\n        res[3*n:4*n] = 1.0 - ys - r\n        \n        # Non-overlap: dist^2 >= (ri + rj)^2\n        idx = 4*n\n        for i in range(n):\n            for j in range(i+1, n):\n                res[idx] = (xs[i]-xs[j])**2 + (ys[i]-ys[j])**2 - (r[i]+r[j])**2\n                idx += 1\n        return res\n\n    # Jacobian of the nonlinear constraints\n    def constraints_jac(x):\n        r = x[:n]\n        xs = x[n:2*n]\n        ys = x[2*n:3*n]\n        num_cons = 4*n + n*(n-1)//2\n        jac = np.zeros((num_cons, 3*n))\n        \n        # Box gradients\n        for i in range(n):\n            jac[i, i] = -1.0; jac[i, n+i] = 1.0\n            jac[n+i, i] = -1.0; jac[n+i, n+i] = -1.0\n            jac[2*n+i, i] = -1.0; jac[2*n+i, 2*n+i] = 1.0\n            jac[3*n+i, i] = -1.0; jac[3*n+i, 2*n+i] = -1.0\n            \n        # Separation gradients\n        idx = 4*n\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = xs[i] - xs[j]\n                dy = ys[i] - ys[j]\n                dr = r[i] + r[j]\n                \n                jac[idx, i] = -2*dr\n                jac[idx, j] = -2*dr\n                jac[idx, n+i] = 2*dx\n                jac[idx, n+j] = -2*dx\n                jac[idx, 2*n+i] = 2*dy\n                jac[idx, 2*n+j] = -2*dy\n                idx += 1\n        return jac\n\n    # Prepare seeds for optimization\n    seeds_c = []\n    \n    # 1. 5x5 Grid plus one extra circle in a gap\n    c1 = []\n    for i in range(5):\n        for j in range(5):\n            c1.append([0.2*i + 0.1, 0.2*j + 0.1])\n    c1.append([0.2, 0.2]) # Placed in a gap between (0.1,0.1) and (0.3,0.3)\n    seeds_c.append(np.array(c1))\n    \n    # 2. Hexagonal-inspired layout (5x6 grid truncated to 26)\n    c2 = []\n    for i in range(5):\n        for j in range(6):\n            if len(c2) < 26:\n                c2.append([(j + 0.5*(i%2))/5.5, (i+0.5)/5.0])\n    seeds_c.append(np.array(c2))\n    \n    # 3. Hexagonal-inspired layout (6x5 grid truncated to 26)\n    c3 = []\n    for i in range(6):\n        for j in range(5):\n            if len(c3) < 26:\n                c3.append([(j + 0.5*(i%2))/5.0, (i+0.5)/5.5])\n    seeds_c.append(np.array(c3))\n    \n    # 4. Random layout\n    seeds_c.append(np.random.rand(n, 2) * 0.8 + 0.1)\n\n    best_sum = 0\n    best_x = None\n    bounds = [(0, 0.5)] * n + [(0, 1)] * (2 * n)\n\n    # Run SLSQP for each seed\n    for c in seeds_c:\n        # Add small jitter to break symmetry\n        c = c + np.random.normal(0, 0.005, c.shape)\n        c = np.clip(c, 0.05, 0.95)\n        \n        # Initial radii\n        r_init = np.full(n, 0.09)\n        x0 = np.concatenate([r_init, c[:, 0], c[:, 1]])\n        \n        res = minimize(\n            objective, x0, jac=objective_jac,\n            method='SLSQP',\n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n            options={'maxiter': 500, 'ftol': 1e-9}\n        )\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_x = res.x\n\n    # Extract results\n    final_radii = best_x[:n]\n    final_centers = np.vstack([best_x[n:2*n], best_x[2*n:3*n]]).T\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6180682559609894,
    "eval_time": 1.0139522552490234,
    "error": null
  },
  "prompt": "Start with a 5x5 grid of circles plus one extra circle in the largest gap. Use this as an initial configuration for a high-precision SLSQP optimization to maximize the sum of radii. Also try a hexagonal-inspired layout for 26 circles.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses SLSQP optimization with multiple initial configurations, including a 5x5 grid\n    plus one circle and hexagonal-inspired layouts.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Objective function: maximize sum of radii (minimize negative sum)\n    def objective(x):\n        return -np.sum(x[:n])\n    \n    # Gradient of the objective function\n    def objective_jac(x):\n        grad = np.zeros(3*n)\n        grad[:n] = -1.0\n        return grad\n\n    # Nonlinear constraints: box boundaries and non-overlap\n    def constraints_func(x):\n        r = x[:n]\n        xs = x[n:2*n]\n        ys = x[2*n:3*n]\n        # Total number of constraints: 4*n (box) + n*(n-1)//2 (overlap)\n        res = np.zeros(4*n + n*(n-1)//2)\n        \n        # Box constraints: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        res[0:n] = xs - r\n        res[n:2*n] = 1.0 - xs - r\n        res[2*n:3*n] = ys - r\n        res[3*n:4*n] = 1.0 - ys - r\n        \n        # Non-overlap: dist^2 >= (ri + rj)^2\n        idx = 4*n\n        for i in range(n):\n            for j in range(i+1, n):\n                res[idx] = (xs[i]-xs[j])**2 + (ys[i]-ys[j])**2 - (r[i]+r[j])**2\n                idx += 1\n        return res\n\n    # Jacobian of the nonlinear constraints\n    def constraints_jac(x):\n        r = x[:n]\n        xs = x[n:2*n]\n        ys = x[2*n:3*n]\n        num_cons = 4*n + n*(n-1)//2\n        jac = np.zeros((num_cons, 3*n))\n        \n        # Box gradients\n        for i in range(n):\n            jac[i, i] = -1.0; jac[i, n+i] = 1.0\n            jac[n+i, i] = -1.0; jac[n+i, n+i] = -1.0\n            jac[2*n+i, i] = -1.0; jac[2*n+i, 2*n+i] = 1.0\n            jac[3*n+i, i] = -1.0; jac[3*n+i, 2*n+i] = -1.0\n            \n        # Separation gradients\n        idx = 4*n\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = xs[i] - xs[j]\n                dy = ys[i] - ys[j]\n                dr = r[i] + r[j]\n                \n                jac[idx, i] = -2*dr\n                jac[idx, j] = -2*dr\n                jac[idx, n+i] = 2*dx\n                jac[idx, n+j] = -2*dx\n                jac[idx, 2*n+i] = 2*dy\n                jac[idx, 2*n+j] = -2*dy\n                idx += 1\n        return jac\n\n    # Prepare seeds for optimization\n    seeds_c = []\n    \n    # 1. 5x5 Grid plus one extra circle in a gap\n    c1 = []\n    for i in range(5):\n        for j in range(5):\n            c1.append([0.2*i + 0.1, 0.2*j + 0.1])\n    c1.append([0.2, 0.2]) # Placed in a gap between (0.1,0.1) and (0.3,0.3)\n    seeds_c.append(np.array(c1))\n    \n    # 2. Hexagonal-inspired layout (5x6 grid truncated to 26)\n    c2 = []\n    for i in range(5):\n        for j in range(6):\n            if len(c2) < 26:\n                c2.append([(j + 0.5*(i%2))/5.5, (i+0.5)/5.0])\n    seeds_c.append(np.array(c2))\n    \n    # 3. Hexagonal-inspired layout (6x5 grid truncated to 26)\n    c3 = []\n    for i in range(6):\n        for j in range(5):\n            if len(c3) < 26:\n                c3.append([(j + 0.5*(i%2))/5.0, (i+0.5)/5.5])\n    seeds_c.append(np.array(c3))\n    \n    # 4. Random layout\n    seeds_c.append(np.random.rand(n, 2) * 0.8 + 0.1)\n\n    best_sum = 0\n    best_x = None\n    bounds = [(0, 0.5)] * n + [(0, 1)] * (2 * n)\n\n    # Run SLSQP for each seed\n    for c in seeds_c:\n        # Add small jitter to break symmetry\n        c = c + np.random.normal(0, 0.005, c.shape)\n        c = np.clip(c, 0.05, 0.95)\n        \n        # Initial radii\n        r_init = np.full(n, 0.09)\n        x0 = np.concatenate([r_init, c[:, 0], c[:, 1]])\n        \n        res = minimize(\n            objective, x0, jac=objective_jac,\n            method='SLSQP',\n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n            options={'maxiter': 500, 'ftol': 1e-9}\n        )\n        \n        if -res.fun > best_sum:\n            best_sum = -res.fun\n            best_x = res.x\n\n    # Extract results\n    final_radii = best_x[:n]\n    final_centers = np.vstack([best_x[n:2*n], best_x[2*n:3*n]]).T\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:53:52.643201",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 281,
        "candidates_token_count": 1685,
        "thoughts_token_count": 18364
      },
      "response_text_len": 4283
    }
  },
  "llm_call_duration_s": 108.34062202298082,
  "eval_duration_s": 1.013962236000225
}