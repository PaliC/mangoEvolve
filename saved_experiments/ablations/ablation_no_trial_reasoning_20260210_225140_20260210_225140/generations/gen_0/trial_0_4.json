{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The goal is to reach a sum of radii around 2.635985.\n    \"\"\"\n    N = 26\n    \n    # Energy function for initial overlap resolution\n    def soft_sphere_energy_and_jac(centers_flat, r_fixed):\n        centers = centers_flat.reshape((N, 2))\n        # Pairwise distances\n        dists = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(dists**2, axis=2)\n        dist = np.sqrt(dist_sq + 1e-12)\n        r_sum = r_fixed[:, np.newaxis] + r_fixed[np.newaxis, :]\n        \n        # Overlap energy\n        overlap = np.maximum(0, r_sum - dist)\n        np.fill_diagonal(overlap, 0)\n        energy = np.sum(overlap**2)\n        \n        # Overlap gradient\n        grad_pairwise = -2 * overlap[:, :, np.newaxis] * dists / dist[:, :, np.newaxis]\n        jac = np.sum(grad_pairwise, axis=1)\n        \n        # Boundary energy and gradient\n        low_overlap = np.maximum(0, r_fixed[:, np.newaxis] - centers)\n        high_overlap = np.maximum(0, centers + r_fixed[:, np.newaxis] - 1)\n        energy += np.sum(low_overlap**2) + np.sum(high_overlap**2)\n        jac -= 2 * low_overlap\n        jac += 2 * high_overlap\n        \n        return energy, jac.flatten()\n\n    # Objective: maximize sum of radii (minimize -sum(r_i))\n    def objective(vars):\n        return -np.sum(vars[2::3])\n\n    def objective_jac(vars):\n        jac = np.zeros(len(vars))\n        jac[2::3] = -1.0\n        return jac\n\n    # Constraints: boundaries and non-overlapping circles\n    def constraints(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        num_pairwise = N * (N - 1) // 2\n        c = np.zeros(4 * N + num_pairwise)\n        # Boundary constraints\n        for i in range(N):\n            c[4 * i] = x[i] - r[i]\n            c[4 * i + 1] = 1 - x[i] - r[i]\n            c[4 * i + 2] = y[i] - r[i]\n            c[4 * i + 3] = 1 - y[i] - r[i]\n        # Pairwise distance constraints\n        row = 4 * N\n        for i in range(N):\n            for j in range(i + 1, N):\n                c[row] = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n                row += 1\n        return c\n\n    def constraints_jac(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        num_pairwise = N * (N - 1) // 2\n        jac = np.zeros((4 * N + num_pairwise, 3 * N))\n        # Boundary constraints Jacobian\n        for i in range(N):\n            jac[4 * i, 3 * i] = 1.0\n            jac[4 * i, 3 * i + 2] = -1.0\n            jac[4 * i + 1, 3 * i] = -1.0\n            jac[4 * i + 1, 3 * i + 2] = -1.0\n            jac[4 * i + 2, 3 * i + 1] = 1.0\n            jac[4 * i + 2, 3 * i + 2] = -1.0\n            jac[4 * i + 3, 3 * i + 1] = -1.0\n            jac[4 * i + 3, 3 * i + 2] = -1.0\n        # Pairwise constraints Jacobian\n        row = 4 * N\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx, dy, dr_sum = x[i] - x[j], y[i] - y[j], r[i] + r[j]\n                jac[row, 3 * i], jac[row, 3 * j] = 2 * dx, -2 * dx\n                jac[row, 3 * i + 1], jac[row, 3 * j + 1] = 2 * dy, -2 * dy\n                jac[row, 3 * i + 2], jac[row, 3 * j + 2] = -2 * dr_sum, -2 * dr_sum\n                row += 1\n        return jac\n\n    best_res = None\n    best_sum = 0\n    r_start = 0.101  # Good starting radius for N=26\n\n    # Attempt multiple random initializations to find a good global optimum\n    for attempt in range(15):\n        # Random initial centers\n        centers = np.random.rand(N, 2) * (1 - 2 * r_start) + r_start\n        \n        # Polish centers with soft-sphere repulsion to reduce initial overlaps\n        res_init = minimize(soft_sphere_energy_and_jac, centers.flatten(), \n                            args=(np.full(N, r_start),), jac=True, method='L-BFGS-B', \n                            bounds=[(0, 1)] * (2 * N), options={'maxiter': 200})\n        \n        # Construct initial vector for SLSQP: [x1, y1, r1, x2, y2, r2, ...]\n        x0 = np.zeros(3 * N)\n        coords = res_init.x.reshape((N, 2))\n        x0[0::3], x0[1::3], x0[2::3] = coords[:, 0], coords[:, 1], r_start\n        \n        # Optimization using SLSQP\n        res = minimize(objective, x0, jac=objective_jac,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                       method='SLSQP', options={'maxiter': 500, 'ftol': 1e-11},\n                       bounds=[(0, 1), (0, 1), (0, 0.5)] * N)\n        \n        # Update best solution found so far\n        if best_res is None or -res.fun > best_sum:\n            best_sum = -res.fun\n            best_res = res\n        \n        # Break early if a sufficiently high sum is found\n        if best_sum > 2.635985:\n            break\n            \n    final_vars = best_res.x\n    final_centers = np.stack([final_vars[0::3], final_vars[1::3]], axis=1)\n    final_radii = final_vars[2::3]\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 7.4917683601379395,
    "error": "Circle 0 at (0.0, 1.0) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "Use a force-directed/repulsion approach. Treat circles as growing bubbles that push each other and the boundaries. Slowly increase a 'growth' pressure while resolving overlaps using a simple gradient descent on an energy function. Finally, polish the result with SLSQP.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    The goal is to reach a sum of radii around 2.635985.\n    \"\"\"\n    N = 26\n    \n    # Energy function for initial overlap resolution\n    def soft_sphere_energy_and_jac(centers_flat, r_fixed):\n        centers = centers_flat.reshape((N, 2))\n        # Pairwise distances\n        dists = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(dists**2, axis=2)\n        dist = np.sqrt(dist_sq + 1e-12)\n        r_sum = r_fixed[:, np.newaxis] + r_fixed[np.newaxis, :]\n        \n        # Overlap energy\n        overlap = np.maximum(0, r_sum - dist)\n        np.fill_diagonal(overlap, 0)\n        energy = np.sum(overlap**2)\n        \n        # Overlap gradient\n        grad_pairwise = -2 * overlap[:, :, np.newaxis] * dists / dist[:, :, np.newaxis]\n        jac = np.sum(grad_pairwise, axis=1)\n        \n        # Boundary energy and gradient\n        low_overlap = np.maximum(0, r_fixed[:, np.newaxis] - centers)\n        high_overlap = np.maximum(0, centers + r_fixed[:, np.newaxis] - 1)\n        energy += np.sum(low_overlap**2) + np.sum(high_overlap**2)\n        jac -= 2 * low_overlap\n        jac += 2 * high_overlap\n        \n        return energy, jac.flatten()\n\n    # Objective: maximize sum of radii (minimize -sum(r_i))\n    def objective(vars):\n        return -np.sum(vars[2::3])\n\n    def objective_jac(vars):\n        jac = np.zeros(len(vars))\n        jac[2::3] = -1.0\n        return jac\n\n    # Constraints: boundaries and non-overlapping circles\n    def constraints(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        num_pairwise = N * (N - 1) // 2\n        c = np.zeros(4 * N + num_pairwise)\n        # Boundary constraints\n        for i in range(N):\n            c[4 * i] = x[i] - r[i]\n            c[4 * i + 1] = 1 - x[i] - r[i]\n            c[4 * i + 2] = y[i] - r[i]\n            c[4 * i + 3] = 1 - y[i] - r[i]\n        # Pairwise distance constraints\n        row = 4 * N\n        for i in range(N):\n            for j in range(i + 1, N):\n                c[row] = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n                row += 1\n        return c\n\n    def constraints_jac(vars):\n        x, y, r = vars[0::3], vars[1::3], vars[2::3]\n        num_pairwise = N * (N - 1) // 2\n        jac = np.zeros((4 * N + num_pairwise, 3 * N))\n        # Boundary constraints Jacobian\n        for i in range(N):\n            jac[4 * i, 3 * i] = 1.0\n            jac[4 * i, 3 * i + 2] = -1.0\n            jac[4 * i + 1, 3 * i] = -1.0\n            jac[4 * i + 1, 3 * i + 2] = -1.0\n            jac[4 * i + 2, 3 * i + 1] = 1.0\n            jac[4 * i + 2, 3 * i + 2] = -1.0\n            jac[4 * i + 3, 3 * i + 1] = -1.0\n            jac[4 * i + 3, 3 * i + 2] = -1.0\n        # Pairwise constraints Jacobian\n        row = 4 * N\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx, dy, dr_sum = x[i] - x[j], y[i] - y[j], r[i] + r[j]\n                jac[row, 3 * i], jac[row, 3 * j] = 2 * dx, -2 * dx\n                jac[row, 3 * i + 1], jac[row, 3 * j + 1] = 2 * dy, -2 * dy\n                jac[row, 3 * i + 2], jac[row, 3 * j + 2] = -2 * dr_sum, -2 * dr_sum\n                row += 1\n        return jac\n\n    best_res = None\n    best_sum = 0\n    r_start = 0.101  # Good starting radius for N=26\n\n    # Attempt multiple random initializations to find a good global optimum\n    for attempt in range(15):\n        # Random initial centers\n        centers = np.random.rand(N, 2) * (1 - 2 * r_start) + r_start\n        \n        # Polish centers with soft-sphere repulsion to reduce initial overlaps\n        res_init = minimize(soft_sphere_energy_and_jac, centers.flatten(), \n                            args=(np.full(N, r_start),), jac=True, method='L-BFGS-B', \n                            bounds=[(0, 1)] * (2 * N), options={'maxiter': 200})\n        \n        # Construct initial vector for SLSQP: [x1, y1, r1, x2, y2, r2, ...]\n        x0 = np.zeros(3 * N)\n        coords = res_init.x.reshape((N, 2))\n        x0[0::3], x0[1::3], x0[2::3] = coords[:, 0], coords[:, 1], r_start\n        \n        # Optimization using SLSQP\n        res = minimize(objective, x0, jac=objective_jac,\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': constraints_jac},\n                       method='SLSQP', options={'maxiter': 500, 'ftol': 1e-11},\n                       bounds=[(0, 1), (0, 1), (0, 0.5)] * N)\n        \n        # Update best solution found so far\n        if best_res is None or -res.fun > best_sum:\n            best_sum = -res.fun\n            best_res = res\n        \n        # Break early if a sufficiently high sum is found\n        if best_sum > 2.635985:\n            break\n            \n    final_vars = best_res.x\n    final_centers = np.stack([final_vars[0::3], final_vars[1::3]], axis=1)\n    final_radii = final_vars[2::3]\n    final_sum = np.sum(final_radii)\n    \n    return final_centers, final_radii, final_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T22:54:06.520418",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 280,
        "candidates_token_count": 1817,
        "thoughts_token_count": 19475
      },
      "response_text_len": 5060
    }
  },
  "llm_call_duration_s": 115.73908987804316,
  "eval_duration_s": 7.491775828995742
}