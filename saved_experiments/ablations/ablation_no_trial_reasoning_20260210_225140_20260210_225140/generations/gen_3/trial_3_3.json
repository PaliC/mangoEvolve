{
  "trial_id": "trial_3_3",
  "generation": 3,
  "parent_id": "trial_1_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Uses a multi-start approach with LP-based radius initialization and \n    global SLSQP optimization with analytical Jacobians.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def objective(vars):\n        # Minimize -sum(radii) to maximize sum(radii)\n        return -np.sum(vars[2*N:])\n\n    def grad_objective(vars):\n        # Gradient of -sum(radii)\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    def constraints_func(vars):\n        # x, y, r extraction\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        \n        res = []\n        # Pairwise distance constraints: d_ij >= r_i + r_j\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            d = np.sqrt(dx**2 + dy**2)\n            res.extend(d - (r[i] + r[i+1:]))\n        \n        # Boundary constraints: r_i <= x_i <= 1-r_i, r_i <= y_i <= 1-r_i\n        for i in range(N):\n            res.extend([x[i] - r[i], 1.0 - x[i] - r[i], y[i] - r[i], 1.0 - y[i] - r[i]])\n            \n        return np.array(res)\n\n    def jacobian_func(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        \n        num_dist = N * (N - 1) // 2\n        num_bound = 4 * N\n        jac = np.zeros((num_dist + num_bound, 3 * N))\n        \n        idx = 0\n        # Jacobian for distance constraints\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            d = np.sqrt(dx**2 + dy**2)\n            d = np.maximum(d, 1e-12) # Avoid division by zero\n            n = len(dx)\n            if n > 0:\n                indices = np.arange(i+1, N)\n                jac[idx:idx+n, i] = dx / d\n                jac[idx:idx+n, indices] = -dx / d\n                jac[idx:idx+n, N + i] = dy / d\n                jac[idx:idx+n, N + indices] = -dy / d\n                jac[idx:idx+n, 2 * N + i] = -1.0\n                jac[idx:idx+n, 2 * N + indices] = -1.0\n                idx += n\n        \n        # Jacobian for boundary constraints\n        for i in range(N):\n            # x[i] - r[i] >= 0\n            jac[idx, i] = 1.0; jac[idx, 2 * N + i] = -1.0; idx += 1\n            # 1.0 - x[i] - r[i] >= 0\n            jac[idx, i] = -1.0; jac[idx, 2 * N + i] = -1.0; idx += 1\n            # y[i] - r[i] >= 0\n            jac[idx, N + i] = 1.0; jac[idx, 2 * N + i] = -1.0; idx += 1\n            # 1.0 - y[i] - r[i] >= 0\n            jac[idx, N + i] = -1.0; jac[idx, 2 * N + i] = -1.0; idx += 1\n            \n        return jac\n\n    def get_optimal_radii(centers):\n        \"\"\"Solve Linear Programming to find optimal radii for fixed centers.\"\"\"\n        num_dist = N * (N - 1) // 2\n        num_bound = 4 * N\n        A_ub = np.zeros((num_dist + num_bound, N))\n        b_ub = np.zeros(num_dist + num_bound)\n        \n        idx = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                A_ub[idx, i] = 1; A_ub[idx, j] = 1; b_ub[idx] = d; idx += 1\n        \n        for i in range(N):\n            cx, cy = centers[i]\n            A_ub[idx, i] = 1; b_ub[idx] = cx; idx += 1\n            A_ub[idx, i] = 1; b_ub[idx] = 1.0 - cx; idx += 1\n            A_ub[idx, i] = 1; b_ub[idx] = cy; idx += 1\n            A_ub[idx, i] = 1; b_ub[idx] = 1.0 - cy; idx += 1\n            \n        res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=(0, 0.5), method='highs')\n        return res.x if res.success else np.zeros(N)\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    iteration = 0\n    # Run for up to 280 seconds\n    while time.time() - start_time < 280:\n        if iteration == 0:\n            # Start 1: Jittered 5x5 grid\n            centers = []\n            for i in range(5):\n                for j in range(5):\n                    centers.append([0.1 + 0.2*i, 0.1 + 0.2*j])\n            centers.append([0.5, 0.5])\n            centers = np.array(centers) + np.random.normal(0, 0.01, (N, 2))\n            centers = np.clip(centers, 0.0, 1.0)\n        elif iteration == 1:\n            # Start 2: 4x6 grid layout\n            centers = []\n            for i in range(4):\n                for j in range(6):\n                    centers.append([0.125 + 0.25*i, 0.08 + 0.168*j])\n            while len(centers) < N:\n                centers.append(np.random.rand(2))\n            centers = np.array(centers)\n        else:\n            # Starts 3+: Random distribution\n            centers = 0.05 + 0.9 * np.random.rand(N, 2)\n        \n        # Initialize radii using LP for fixed centers\n        radii_init = get_optimal_radii(centers)\n        x0 = np.concatenate([centers[:, 0], centers[:, 1], radii_init])\n        \n        # Local optimization using SLSQP\n        res = minimize(\n            objective, x0,\n            method='SLSQP',\n            jac=grad_objective,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n            bounds=[(0, 1)] * (2*N) + [(0, 0.5)] * N,\n            options={'maxiter': 100}\n        )\n        \n        # Extract results and verify validity\n        current_centers = np.stack([res.x[:N], res.x[N:2*N]], axis=1)\n        current_radii = get_optimal_radii(current_centers)\n        current_sum = np.sum(current_radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = current_centers\n            best_radii = current_radii\n            \n        iteration += 1\n        \n    return best_centers, best_radii, best_sum",
  "metrics": {
    "valid": true,
    "score": 0.856068241586045,
    "eval_time": 281.7508215904236,
    "error": null
  },
  "prompt": "Implement a 'Voronoi-Constrained' optimization. Start with a random configuration, compute the Voronoi cells (clipped to the unit square), and optimize each circle's position and radius within its own Voronoi cell. Then run a global SLSQP to polish.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Uses a multi-start approach with LP-based radius initialization and \n    global SLSQP optimization with analytical Jacobians.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def objective(vars):\n        # Minimize -sum(radii) to maximize sum(radii)\n        return -np.sum(vars[2*N:])\n\n    def grad_objective(vars):\n        # Gradient of -sum(radii)\n        grad = np.zeros(3*N)\n        grad[2*N:] = -1.0\n        return grad\n\n    def constraints_func(vars):\n        # x, y, r extraction\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        \n        res = []\n        # Pairwise distance constraints: d_ij >= r_i + r_j\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            d = np.sqrt(dx**2 + dy**2)\n            res.extend(d - (r[i] + r[i+1:]))\n        \n        # Boundary constraints: r_i <= x_i <= 1-r_i, r_i <= y_i <= 1-r_i\n        for i in range(N):\n            res.extend([x[i] - r[i], 1.0 - x[i] - r[i], y[i] - r[i], 1.0 - y[i] - r[i]])\n            \n        return np.array(res)\n\n    def jacobian_func(vars):\n        x = vars[:N]\n        y = vars[N:2*N]\n        r = vars[2*N:]\n        \n        num_dist = N * (N - 1) // 2\n        num_bound = 4 * N\n        jac = np.zeros((num_dist + num_bound, 3 * N))\n        \n        idx = 0\n        # Jacobian for distance constraints\n        for i in range(N):\n            dx = x[i] - x[i+1:]\n            dy = y[i] - y[i+1:]\n            d = np.sqrt(dx**2 + dy**2)\n            d = np.maximum(d, 1e-12) # Avoid division by zero\n            n = len(dx)\n            if n > 0:\n                indices = np.arange(i+1, N)\n                jac[idx:idx+n, i] = dx / d\n                jac[idx:idx+n, indices] = -dx / d\n                jac[idx:idx+n, N + i] = dy / d\n                jac[idx:idx+n, N + indices] = -dy / d\n                jac[idx:idx+n, 2 * N + i] = -1.0\n                jac[idx:idx+n, 2 * N + indices] = -1.0\n                idx += n\n        \n        # Jacobian for boundary constraints\n        for i in range(N):\n            # x[i] - r[i] >= 0\n            jac[idx, i] = 1.0; jac[idx, 2 * N + i] = -1.0; idx += 1\n            # 1.0 - x[i] - r[i] >= 0\n            jac[idx, i] = -1.0; jac[idx, 2 * N + i] = -1.0; idx += 1\n            # y[i] - r[i] >= 0\n            jac[idx, N + i] = 1.0; jac[idx, 2 * N + i] = -1.0; idx += 1\n            # 1.0 - y[i] - r[i] >= 0\n            jac[idx, N + i] = -1.0; jac[idx, 2 * N + i] = -1.0; idx += 1\n            \n        return jac\n\n    def get_optimal_radii(centers):\n        \"\"\"Solve Linear Programming to find optimal radii for fixed centers.\"\"\"\n        num_dist = N * (N - 1) // 2\n        num_bound = 4 * N\n        A_ub = np.zeros((num_dist + num_bound, N))\n        b_ub = np.zeros(num_dist + num_bound)\n        \n        idx = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                A_ub[idx, i] = 1; A_ub[idx, j] = 1; b_ub[idx] = d; idx += 1\n        \n        for i in range(N):\n            cx, cy = centers[i]\n            A_ub[idx, i] = 1; b_ub[idx] = cx; idx += 1\n            A_ub[idx, i] = 1; b_ub[idx] = 1.0 - cx; idx += 1\n            A_ub[idx, i] = 1; b_ub[idx] = cy; idx += 1\n            A_ub[idx, i] = 1; b_ub[idx] = 1.0 - cy; idx += 1\n            \n        res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=(0, 0.5), method='highs')\n        return res.x if res.success else np.zeros(N)\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    iteration = 0\n    # Run for up to 280 seconds\n    while time.time() - start_time < 280:\n        if iteration == 0:\n            # Start 1: Jittered 5x5 grid\n            centers = []\n            for i in range(5):\n                for j in range(5):\n                    centers.append([0.1 + 0.2*i, 0.1 + 0.2*j])\n            centers.append([0.5, 0.5])\n            centers = np.array(centers) + np.random.normal(0, 0.01, (N, 2))\n            centers = np.clip(centers, 0.0, 1.0)\n        elif iteration == 1:\n            # Start 2: 4x6 grid layout\n            centers = []\n            for i in range(4):\n                for j in range(6):\n                    centers.append([0.125 + 0.25*i, 0.08 + 0.168*j])\n            while len(centers) < N:\n                centers.append(np.random.rand(2))\n            centers = np.array(centers)\n        else:\n            # Starts 3+: Random distribution\n            centers = 0.05 + 0.9 * np.random.rand(N, 2)\n        \n        # Initialize radii using LP for fixed centers\n        radii_init = get_optimal_radii(centers)\n        x0 = np.concatenate([centers[:, 0], centers[:, 1], radii_init])\n        \n        # Local optimization using SLSQP\n        res = minimize(\n            objective, x0,\n            method='SLSQP',\n            jac=grad_objective,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jacobian_func},\n            bounds=[(0, 1)] * (2*N) + [(0, 0.5)] * N,\n            options={'maxiter': 100}\n        )\n        \n        # Extract results and verify validity\n        current_centers = np.stack([res.x[:N], res.x[N:2*N]], axis=1)\n        current_radii = get_optimal_radii(current_centers)\n        current_sum = np.sum(current_radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = current_centers\n            best_radii = current_radii\n            \n        iteration += 1\n        \n    return best_centers, best_radii, best_sum\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-10T23:22:29.667482",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 285,
        "candidates_token_count": 2052,
        "thoughts_token_count": 23750
      },
      "response_text_len": 5682
    }
  },
  "llm_call_duration_s": 141.1455703660613,
  "eval_duration_s": 281.7508300699992
}