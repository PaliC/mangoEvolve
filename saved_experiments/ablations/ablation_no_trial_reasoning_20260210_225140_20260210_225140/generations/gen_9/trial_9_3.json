{
  "trial_id": "trial_9_3",
  "generation": 9,
  "parent_id": "trial_5_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Monte Carlo Farthest Point Sampling for initial placement, SLSQP for optimization,\n    and a 'Shake' phase to escape local optima.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def get_initial_centers(n_points=10000):\n        # Monte Carlo sampling: 10,000 candidate points\n        pts = np.random.rand(n_points, 2)\n        centers = np.zeros((N, 2))\n        # Farthest Point Sampling (FPS) to spread circles\n        centers[0] = pts[np.random.randint(n_points)]\n        dists = np.sum((pts - centers[0])**2, axis=1)\n        for i in range(1, N):\n            centers[i] = pts[np.argmax(dists)]\n            new_dists = np.sum((pts - centers[i])**2, axis=1)\n            dists = np.minimum(dists, new_dists)\n        return centers\n\n    def get_max_equal_r(centers):\n        # Find the maximum possible equal radius for the given set of centers\n        idx1, idx2 = np.triu_indices(N, k=1)\n        d_sq = np.sum((centers[idx1] - centers[idx2])**2, axis=1)\n        r_overlap = np.min(np.sqrt(d_sq)) / 2.0\n        r_boundary = np.min([centers[:, 0], 1.0 - centers[:, 0], centers[:, 1], 1.0 - centers[:, 1]])\n        return min(r_overlap, r_boundary)\n\n    def objective(x):\n        # Maximize sum of radii -> minimize -sum of radii\n        return -np.sum(x[2::3])\n\n    def objective_grad(x):\n        # Gradient of -sum(r_i)\n        grad = np.zeros(3 * N)\n        grad[2::3] = -1.0\n        return grad\n\n    def constraints_func(x):\n        # Boundary and overlap constraints\n        xi, yi, ri = x[0::3], x[1::3], x[2::3]\n        boundary = np.empty(4 * N)\n        boundary[0::4] = xi - ri\n        boundary[1::4] = 1.0 - xi - ri\n        boundary[2::4] = yi - ri\n        boundary[3::4] = 1.0 - yi - ri\n        \n        idx1, idx2 = np.triu_indices(N, k=1)\n        overlap = (xi[idx1]-xi[idx2])**2 + (yi[idx1]-yi[idx2])**2 - (ri[idx1]+ri[idx2])**2\n        return np.concatenate([boundary, overlap])\n\n    def constraints_jac(x):\n        # Jacobian of constraints_func\n        xi, yi, ri = x[0::3], x[1::3], x[2::3]\n        jac = np.zeros((4 * N + (N * (N - 1) // 2), 3 * N))\n        \n        # Boundary constraints\n        for i in range(N):\n            jac[4*i, 3*i] = 1; jac[4*i, 3*i+2] = -1\n            jac[4*i+1, 3*i] = -1; jac[4*i+1, 3*i+2] = -1\n            jac[4*i+2, 3*i+1] = 1; jac[4*i+2, 3*i+2] = -1\n            jac[4*i+3, 3*i+1] = -1; jac[4*i+3, 3*i+2] = -1\n            \n        # Overlap constraints\n        idx1, idx2 = np.triu_indices(N, k=1)\n        dx, dy, dr = xi[idx1]-xi[idx2], yi[idx1]-yi[idx2], ri[idx1]+ri[idx2]\n        row = np.arange(4 * N, 4 * N + (N * (N - 1) // 2))\n        jac[row, 3*idx1] = 2*dx; jac[row, 3*idx2] = -2*dx\n        jac[row, 3*idx1+1] = 2*dy; jac[row, 3*idx2+1] = -2*dy\n        jac[row, 3*idx1+2] = -2*dr; jac[row, 3*idx2+2] = -2*dr\n        return jac\n\n    best_x = None\n    best_sum_radii = -1.0\n\n    # Initial trials from different FPS starting points\n    for _ in range(2):\n        centers = get_initial_centers(10000)\n        r_start = get_max_equal_r(centers)\n        x0 = np.zeros(3 * N)\n        x0[0::3], x0[1::3] = centers.T\n        x0[2::3] = r_start * 0.95 # Start slightly below max to avoid immediate boundary violations\n        \n        res = minimize(objective, x0, method='SLSQP', jac=objective_grad,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n                       bounds=[(0, 1), (0, 1), (0, 0.5)] * N,\n                       options={'tol': 1e-12, 'maxiter': 1000})\n        \n        if -res.fun > best_sum_radii:\n            if np.all(constraints_func(res.x) >= -1e-10):\n                best_sum_radii = -res.fun\n                best_x = res.x\n\n    # Shake phase: Perturb best known solution and re-optimize\n    it = 0\n    while time.time() - start_time < 270:\n        if best_x is None: break\n        \n        x_shaken = best_x.copy()\n        noise_scale = 0.02 / (1 + it * 0.1)\n        x_shaken[0::3] += np.random.normal(0, noise_scale, N)\n        x_shaken[1::3] += np.random.normal(0, noise_scale, N)\n        x_shaken[2::3] *= 0.95 # Slightly shrink radii to provide room for movement\n        \n        res = minimize(objective, x_shaken, method='SLSQP', jac=objective_grad,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n                       bounds=[(0, 1), (0, 1), (0, 0.5)] * N,\n                       options={'tol': 1e-12, 'maxiter': 1000})\n        \n        if -res.fun > best_sum_radii:\n            if np.all(constraints_func(res.x) >= -1e-10):\n                best_sum_radii = -res.fun\n                best_x = res.x\n        it += 1\n\n    # Format the final output\n    if best_x is None:\n        # Fallback in case of total failure (highly unlikely)\n        final_radii = np.full(N, 0.01)\n        final_centers = np.random.rand(N, 2) * 0.8 + 0.1\n        return final_centers, final_radii, np.sum(final_radii)\n        \n    final_centers = best_x.reshape((N, 3))[:, :2]\n    final_radii = best_x.reshape((N, 3))[:, 2]\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6235851109366624,
    "eval_time": 270.7701904773712,
    "error": null
  },
  "prompt": "Improve trial_5_0 by increasing the Monte Carlo sampling from 3000 to 10000 points and setting the SLSQP tolerance to 1e-12. Focus on the 'Shake' phase.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square [0,1] x [0,1] to maximize the sum of their radii.\n    Uses Monte Carlo Farthest Point Sampling for initial placement, SLSQP for optimization,\n    and a 'Shake' phase to escape local optima.\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    def get_initial_centers(n_points=10000):\n        # Monte Carlo sampling: 10,000 candidate points\n        pts = np.random.rand(n_points, 2)\n        centers = np.zeros((N, 2))\n        # Farthest Point Sampling (FPS) to spread circles\n        centers[0] = pts[np.random.randint(n_points)]\n        dists = np.sum((pts - centers[0])**2, axis=1)\n        for i in range(1, N):\n            centers[i] = pts[np.argmax(dists)]\n            new_dists = np.sum((pts - centers[i])**2, axis=1)\n            dists = np.minimum(dists, new_dists)\n        return centers\n\n    def get_max_equal_r(centers):\n        # Find the maximum possible equal radius for the given set of centers\n        idx1, idx2 = np.triu_indices(N, k=1)\n        d_sq = np.sum((centers[idx1] - centers[idx2])**2, axis=1)\n        r_overlap = np.min(np.sqrt(d_sq)) / 2.0\n        r_boundary = np.min([centers[:, 0], 1.0 - centers[:, 0], centers[:, 1], 1.0 - centers[:, 1]])\n        return min(r_overlap, r_boundary)\n\n    def objective(x):\n        # Maximize sum of radii -> minimize -sum of radii\n        return -np.sum(x[2::3])\n\n    def objective_grad(x):\n        # Gradient of -sum(r_i)\n        grad = np.zeros(3 * N)\n        grad[2::3] = -1.0\n        return grad\n\n    def constraints_func(x):\n        # Boundary and overlap constraints\n        xi, yi, ri = x[0::3], x[1::3], x[2::3]\n        boundary = np.empty(4 * N)\n        boundary[0::4] = xi - ri\n        boundary[1::4] = 1.0 - xi - ri\n        boundary[2::4] = yi - ri\n        boundary[3::4] = 1.0 - yi - ri\n        \n        idx1, idx2 = np.triu_indices(N, k=1)\n        overlap = (xi[idx1]-xi[idx2])**2 + (yi[idx1]-yi[idx2])**2 - (ri[idx1]+ri[idx2])**2\n        return np.concatenate([boundary, overlap])\n\n    def constraints_jac(x):\n        # Jacobian of constraints_func\n        xi, yi, ri = x[0::3], x[1::3], x[2::3]\n        jac = np.zeros((4 * N + (N * (N - 1) // 2), 3 * N))\n        \n        # Boundary constraints\n        for i in range(N):\n            jac[4*i, 3*i] = 1; jac[4*i, 3*i+2] = -1\n            jac[4*i+1, 3*i] = -1; jac[4*i+1, 3*i+2] = -1\n            jac[4*i+2, 3*i+1] = 1; jac[4*i+2, 3*i+2] = -1\n            jac[4*i+3, 3*i+1] = -1; jac[4*i+3, 3*i+2] = -1\n            \n        # Overlap constraints\n        idx1, idx2 = np.triu_indices(N, k=1)\n        dx, dy, dr = xi[idx1]-xi[idx2], yi[idx1]-yi[idx2], ri[idx1]+ri[idx2]\n        row = np.arange(4 * N, 4 * N + (N * (N - 1) // 2))\n        jac[row, 3*idx1] = 2*dx; jac[row, 3*idx2] = -2*dx\n        jac[row, 3*idx1+1] = 2*dy; jac[row, 3*idx2+1] = -2*dy\n        jac[row, 3*idx1+2] = -2*dr; jac[row, 3*idx2+2] = -2*dr\n        return jac\n\n    best_x = None\n    best_sum_radii = -1.0\n\n    # Initial trials from different FPS starting points\n    for _ in range(2):\n        centers = get_initial_centers(10000)\n        r_start = get_max_equal_r(centers)\n        x0 = np.zeros(3 * N)\n        x0[0::3], x0[1::3] = centers.T\n        x0[2::3] = r_start * 0.95 # Start slightly below max to avoid immediate boundary violations\n        \n        res = minimize(objective, x0, method='SLSQP', jac=objective_grad,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n                       bounds=[(0, 1), (0, 1), (0, 0.5)] * N,\n                       options={'tol': 1e-12, 'maxiter': 1000})\n        \n        if -res.fun > best_sum_radii:\n            if np.all(constraints_func(res.x) >= -1e-10):\n                best_sum_radii = -res.fun\n                best_x = res.x\n\n    # Shake phase: Perturb best known solution and re-optimize\n    it = 0\n    while time.time() - start_time < 270:\n        if best_x is None: break\n        \n        x_shaken = best_x.copy()\n        noise_scale = 0.02 / (1 + it * 0.1)\n        x_shaken[0::3] += np.random.normal(0, noise_scale, N)\n        x_shaken[1::3] += np.random.normal(0, noise_scale, N)\n        x_shaken[2::3] *= 0.95 # Slightly shrink radii to provide room for movement\n        \n        res = minimize(objective, x_shaken, method='SLSQP', jac=objective_grad,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': constraints_jac},\n                       bounds=[(0, 1), (0, 1), (0, 0.5)] * N,\n                       options={'tol': 1e-12, 'maxiter': 1000})\n        \n        if -res.fun > best_sum_radii:\n            if np.all(constraints_func(res.x) >= -1e-10):\n                best_sum_radii = -res.fun\n                best_x = res.x\n        it += 1\n\n    # Format the final output\n    if best_x is None:\n        # Fallback in case of total failure (highly unlikely)\n        final_radii = np.full(N, 0.01)\n        final_centers = np.random.rand(N, 2) * 0.8 + 0.1\n        return final_centers, final_radii, np.sum(final_radii)\n        \n    final_centers = best_x.reshape((N, 3))[:, :2]\n    final_radii = best_x.reshape((N, 3))[:, 2]\n    sum_radii = np.sum(final_radii)\n    \n    return final_centers, final_radii, sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:13:16.942145",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 276,
        "candidates_token_count": 1981,
        "thoughts_token_count": 23692
      },
      "response_text_len": 5298
    }
  },
  "llm_call_duration_s": 146.87379001593217,
  "eval_duration_s": 270.77019937196746
}