{
  "trial_id": "trial_9_4",
  "generation": 9,
  "parent_id": "trial_5_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Combines inflation-like optimization (SLSQP) with replacement logic\n    to escape local optima, followed by a Linear Programming polish.\n    \"\"\"\n    N = 26\n    triu_idx = np.triu_indices(N, k=1)\n    \n    # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n    def obj(v):\n        return -np.sum(v[2*N:])\n    \n    # Constraints: No overlaps and stay within [0,1]x[0,1]\n    def cons(v):\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        # Equivalent to: x_i - r_i >= 0, 1 - x_i - r_i >= 0, ...\n        b = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        r_sum_sq = (r[:, np.newaxis] + r[np.newaxis, :])**2\n        o = (dist_sq - r_sum_sq)[triu_idx]\n        return np.concatenate([b, o])\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    start_time = time.time()\n    \n    # Generate several initial layouts to diversify search\n    layouts = []\n    \n    # Layout 1: Slightly jittered 5x5 grid + 1 extra circle\n    x5, y5 = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    x_init = np.append(x5.flatten(), 0.5)\n    y_init = np.append(y5.flatten(), 0.5)\n    # Add small jitter to break symmetry\n    x_init += np.random.normal(0, 0.01, N)\n    y_init += np.random.normal(0, 0.01, N)\n    layouts.append(np.concatenate([np.clip(x_init, 0, 1), np.clip(y_init, 0, 1), np.full(N, 0.05)]))\n    \n    # Layout 2: 4x6 grid + 2 extra circles\n    x4, y6 = np.meshgrid(np.linspace(0.1, 0.9, 4), np.linspace(0.1, 0.9, 6))\n    x_init2 = np.append(x4.flatten(), [0.2, 0.8])\n    y_init2 = np.append(y6.flatten(), [0.5, 0.5])\n    layouts.append(np.concatenate([np.clip(x_init2, 0, 1), np.clip(y_init2, 0, 1), np.full(N, 0.04)]))\n    \n    # Layout 3-4: Purely random starts\n    for _ in range(2):\n        layouts.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.full(N, 0.03)]))\n        \n    # Optimization Loop\n    for v_init in layouts:\n        if time.time() - start_time > 220:\n            break\n        \n        v_curr = v_init\n        for step in range(6):  # Replacement steps per layout\n            if time.time() - start_time > 250:\n                break\n            \n            # Non-linear optimization for centers and radii\n            res = minimize(obj, v_curr, method='SLSQP', constraints={'type': 'ineq', 'fun': cons}, \n                           options={'maxiter': 120})\n            v_curr = res.x\n            \n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = np.stack([v_curr[:N], v_curr[N:2*N]], axis=1)\n                best_radii = v_curr[2*N:]\n            \n            # Replacement logic: identify the smallest circle and move it to a random location\n            idx = np.argmin(v_curr[2*N:])\n            v_curr[idx] = np.random.rand()\n            v_curr[N+idx] = np.random.rand()\n            v_curr[2*N+idx] = 0.01  # Reset its radius to a small value to allow regrowth\n\n    # Final Polish: Fix centers and use Linear Programming to find the absolute optimal radii\n    if best_centers is not None:\n        # Objective for linprog: Maximize sum(r_i)\n        c_lp = -np.ones(N)\n        \n        # Overlap constraints: r_i + r_j <= distance_ij\n        A_ub = []\n        b_ub = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.sqrt(np.sum((best_centers[i] - best_centers[j])**2))\n                row = np.zeros(N)\n                row[i], row[j] = 1, 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Boundary constraints as variable bounds: 0 <= r_i <= min(x, 1-x, y, 1-y)\n        bounds = []\n        for i in range(N):\n            x, y = best_centers[i]\n            max_r = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max(0.0, max_r)))\n            \n        # Solve the LP\n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res_lp.success:\n            best_radii = res_lp.x\n            best_sum = np.sum(best_radii)\n            \n    # Final check to prevent tiny constraint violations from numerical errors\n    for i in range(N):\n        best_radii[i] = max(0, min(best_radii[i], best_centers[i, 0], 1.0 - best_centers[i, 0], \n                                   best_centers[i, 1], 1.0 - best_centers[i, 1]))\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = np.linalg.norm(best_centers[i] - best_centers[j])\n            if best_radii[i] + best_radii[j] > dist:\n                overlap = (best_radii[i] + best_radii[j]) - dist\n                # Shrink radii proportionally\n                total_r = best_radii[i] + best_radii[j]\n                if total_r > 0:\n                    best_radii[i] -= overlap * (best_radii[i] / total_r)\n                    best_radii[j] -= overlap * (best_radii[j] / total_r)\n                else:\n                    best_radii[i] = best_radii[j] = 0\n\n    return best_centers, best_radii, np.sum(best_radii)",
  "metrics": {
    "valid": true,
    "score": 2.6227627294828966,
    "eval_time": 13.67807936668396,
    "error": null
  },
  "prompt": "Combine the 'Inflation' logic from trial_7_3 with the 'Replacement' logic from trial_5_0. Use LP for the final polish.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef run_packing():\n    \"\"\"\n    Packs 26 circles into a unit square to maximize the sum of their radii.\n    Combines inflation-like optimization (SLSQP) with replacement logic\n    to escape local optima, followed by a Linear Programming polish.\n    \"\"\"\n    N = 26\n    triu_idx = np.triu_indices(N, k=1)\n    \n    # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n    def obj(v):\n        return -np.sum(v[2*N:])\n    \n    # Constraints: No overlaps and stay within [0,1]x[0,1]\n    def cons(v):\n        x, y, r = v[:N], v[N:2*N], v[2*N:]\n        # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        # Equivalent to: x_i - r_i >= 0, 1 - x_i - r_i >= 0, ...\n        b = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        \n        # Overlap constraints: (x_i - x_j)^2 + (y_i - y_j)^2 >= (r_i + r_j)^2\n        dx = x[:, np.newaxis] - x[np.newaxis, :]\n        dy = y[:, np.newaxis] - y[np.newaxis, :]\n        dist_sq = dx**2 + dy**2\n        r_sum_sq = (r[:, np.newaxis] + r[np.newaxis, :])**2\n        o = (dist_sq - r_sum_sq)[triu_idx]\n        return np.concatenate([b, o])\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    start_time = time.time()\n    \n    # Generate several initial layouts to diversify search\n    layouts = []\n    \n    # Layout 1: Slightly jittered 5x5 grid + 1 extra circle\n    x5, y5 = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    x_init = np.append(x5.flatten(), 0.5)\n    y_init = np.append(y5.flatten(), 0.5)\n    # Add small jitter to break symmetry\n    x_init += np.random.normal(0, 0.01, N)\n    y_init += np.random.normal(0, 0.01, N)\n    layouts.append(np.concatenate([np.clip(x_init, 0, 1), np.clip(y_init, 0, 1), np.full(N, 0.05)]))\n    \n    # Layout 2: 4x6 grid + 2 extra circles\n    x4, y6 = np.meshgrid(np.linspace(0.1, 0.9, 4), np.linspace(0.1, 0.9, 6))\n    x_init2 = np.append(x4.flatten(), [0.2, 0.8])\n    y_init2 = np.append(y6.flatten(), [0.5, 0.5])\n    layouts.append(np.concatenate([np.clip(x_init2, 0, 1), np.clip(y_init2, 0, 1), np.full(N, 0.04)]))\n    \n    # Layout 3-4: Purely random starts\n    for _ in range(2):\n        layouts.append(np.concatenate([np.random.rand(N), np.random.rand(N), np.full(N, 0.03)]))\n        \n    # Optimization Loop\n    for v_init in layouts:\n        if time.time() - start_time > 220:\n            break\n        \n        v_curr = v_init\n        for step in range(6):  # Replacement steps per layout\n            if time.time() - start_time > 250:\n                break\n            \n            # Non-linear optimization for centers and radii\n            res = minimize(obj, v_curr, method='SLSQP', constraints={'type': 'ineq', 'fun': cons}, \n                           options={'maxiter': 120})\n            v_curr = res.x\n            \n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = np.stack([v_curr[:N], v_curr[N:2*N]], axis=1)\n                best_radii = v_curr[2*N:]\n            \n            # Replacement logic: identify the smallest circle and move it to a random location\n            idx = np.argmin(v_curr[2*N:])\n            v_curr[idx] = np.random.rand()\n            v_curr[N+idx] = np.random.rand()\n            v_curr[2*N+idx] = 0.01  # Reset its radius to a small value to allow regrowth\n\n    # Final Polish: Fix centers and use Linear Programming to find the absolute optimal radii\n    if best_centers is not None:\n        # Objective for linprog: Maximize sum(r_i)\n        c_lp = -np.ones(N)\n        \n        # Overlap constraints: r_i + r_j <= distance_ij\n        A_ub = []\n        b_ub = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.sqrt(np.sum((best_centers[i] - best_centers[j])**2))\n                row = np.zeros(N)\n                row[i], row[j] = 1, 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Boundary constraints as variable bounds: 0 <= r_i <= min(x, 1-x, y, 1-y)\n        bounds = []\n        for i in range(N):\n            x, y = best_centers[i]\n            max_r = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max(0.0, max_r)))\n            \n        # Solve the LP\n        res_lp = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res_lp.success:\n            best_radii = res_lp.x\n            best_sum = np.sum(best_radii)\n            \n    # Final check to prevent tiny constraint violations from numerical errors\n    for i in range(N):\n        best_radii[i] = max(0, min(best_radii[i], best_centers[i, 0], 1.0 - best_centers[i, 0], \n                                   best_centers[i, 1], 1.0 - best_centers[i, 1]))\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = np.linalg.norm(best_centers[i] - best_centers[j])\n            if best_radii[i] + best_radii[j] > dist:\n                overlap = (best_radii[i] + best_radii[j]) - dist\n                # Shrink radii proportionally\n                total_r = best_radii[i] + best_radii[j]\n                if total_r > 0:\n                    best_radii[i] -= overlap * (best_radii[i] / total_r)\n                    best_radii[j] -= overlap * (best_radii[j] / total_r)\n                else:\n                    best_radii[i] = best_radii[j] = 0\n\n    return best_centers, best_radii, np.sum(best_radii)\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T00:08:52.940953",
  "cost_data": null,
  "model_config": {
    "model": "gemini-3-flash-preview",
    "temperature": 0.7,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 260,
        "candidates_token_count": 1984,
        "thoughts_token_count": 23259
      },
      "response_text_len": 5480
    }
  },
  "llm_call_duration_s": 140.0006620628992,
  "eval_duration_s": 13.67808684206102
}