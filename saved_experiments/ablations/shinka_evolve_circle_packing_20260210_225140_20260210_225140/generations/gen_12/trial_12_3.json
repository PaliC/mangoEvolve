{
  "trial_id": "trial_12_3",
  "generation": 12,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    def create_hex_grid(n_circles):\n        # Create stretched hexagonal lattice biased toward edges\n        rows = int(np.ceil(np.sqrt(n_circles / 0.866)))\n        cols = int(np.ceil(n_circles / rows))\n        \n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n_circles:\n                    break\n                x = j / (cols - 1) if cols > 1 else 0.5\n                y = i / (rows - 1) if rows > 1 else 0.5\n                \n                # Hex offset\n                if i % 2 == 1:\n                    x += 0.5 / cols\n                \n                # Bias toward edges\n                x = x * 0.8 + 0.1\n                y = y * 0.8 + 0.1\n                \n                centers.append([x, y])\n        \n        return np.array(centers[:n_circles])\n    \n    def get_neighbors(centers, k=6):\n        n = len(centers)\n        dists = squareform(pdist(centers))\n        neighbors = []\n        for i in range(n):\n            # Get k nearest neighbors (excluding self)\n            idx = np.argsort(dists[i])\n            neighbors.append(idx[1:k+1])\n        return neighbors\n    \n    def project_boundaries(centers, target_radii):\n        # Clamp centers to ensure boundary feasibility\n        new_centers = centers.copy()\n        for i in range(len(centers)):\n            r = target_radii[i]\n            new_centers[i, 0] = np.clip(centers[i, 0], r, 1 - r)\n            new_centers[i, 1] = np.clip(centers[i, 1], r, 1 - r)\n        return new_centers\n    \n    def project_overlaps(centers, target_radii, neighbors):\n        # Dykstra-like projection for overlaps\n        new_centers = centers.copy()\n        n = len(centers)\n        \n        for i in range(n):\n            for j in neighbors[i]:\n                if j <= i:\n                    continue\n                    \n                dist = np.linalg.norm(centers[i] - centers[j])\n                required_dist = target_radii[i] + target_radii[j] + 1e-6\n                \n                if dist < required_dist and dist > 1e-10:\n                    # Push apart proportionally\n                    direction = (centers[i] - centers[j]) / dist\n                    gap = required_dist - dist\n                    \n                    # Move proportional to radii\n                    total_r = target_radii[i] + target_radii[j]\n                    if total_r > 1e-10:\n                        move_i = gap * target_radii[j] / total_r / 2\n                        move_j = gap * target_radii[i] / total_r / 2\n                    else:\n                        move_i = move_j = gap / 4\n                    \n                    new_centers[i] += move_i * direction\n                    new_centers[j] -= move_j * direction\n        \n        return new_centers\n    \n    def estimate_radii_lp(centers):\n        n = len(centers)\n        \n        # Boundary clearances\n        boundary_caps = np.minimum.reduce([\n            centers[:, 0], centers[:, 1], \n            1 - centers[:, 0], 1 - centers[:, 1]\n        ])\n        \n        # Distance constraints\n        dists = squareform(pdist(centers))\n        \n        # LP setup\n        c = -np.ones(n)  # Minimize -sum(r)\n        bounds = [(0, boundary_caps[i]) for i in range(n)]\n        \n        # Inequality constraints: r_i + r_j <= dist_ij - 1e-6\n        A_ub = []\n        b_ub = []\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                constraint[j] = 1\n                A_ub.append(constraint)\n                b_ub.append(dists[i, j] - 1e-6)\n        \n        if A_ub:\n            A_ub = np.array(A_ub)\n            b_ub = np.array(b_ub)\n            \n            # Ensure feasibility\n            if np.any(b_ub <= 0):\n                return np.zeros(n)\n            \n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if result.success:\n                return result.x\n        \n        return boundary_caps * 0.1\n    \n    def smooth_objective(x, target_radii):\n        centers = x.reshape(-1, 2)\n        n = len(centers)\n        \n        # Boundary penalties\n        boundary_penalty = 0\n        for i in range(n):\n            r = target_radii[i]\n            penalty = 0\n            penalty += max(0, r - centers[i, 0])**2\n            penalty += max(0, r - centers[i, 1])**2\n            penalty += max(0, r - (1 - centers[i, 0]))**2\n            penalty += max(0, r - (1 - centers[i, 1]))**2\n            boundary_penalty += penalty\n        \n        # Overlap penalties\n        overlap_penalty = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required = target_radii[i] + target_radii[j] + 1e-6\n                if dist < required:\n                    overlap_penalty += (required - dist)**2\n        \n        return boundary_penalty + overlap_penalty\n    \n    def smooth_gradient(x, target_radii):\n        centers = x.reshape(-1, 2)\n        n = len(centers)\n        grad = np.zeros_like(centers)\n        \n        # Boundary gradient\n        for i in range(n):\n            r = target_radii[i]\n            if centers[i, 0] < r:\n                grad[i, 0] -= 2 * (r - centers[i, 0])\n            if centers[i, 1] < r:\n                grad[i, 1] -= 2 * (r - centers[i, 1])\n            if centers[i, 0] > 1 - r:\n                grad[i, 0] += 2 * (centers[i, 0] - (1 - r))\n            if centers[i, 1] > 1 - r:\n                grad[i, 1] += 2 * (centers[i, 1] - (1 - r))\n        \n        # Overlap gradient\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                required = target_radii[i] + target_radii[j] + 1e-6\n                \n                if dist < required and dist > 1e-10:\n                    factor = -2 * (required - dist) / dist\n                    grad[i] += factor * diff\n                    grad[j] -= factor * diff\n        \n        return grad.flatten()\n    \n    def alternating_projections(centers, max_iter=50):\n        n = len(centers)\n        current_centers = centers.copy()\n        \n        for iteration in range(max_iter):\n            # Estimate target radii\n            target_radii = estimate_radii_lp(current_centers)\n            \n            if iteration % 5 == 0:\n                neighbors = get_neighbors(current_centers, k=6)\n            \n            # Project boundaries\n            current_centers = project_boundaries(current_centers, target_radii)\n            \n            # Project overlaps\n            for _ in range(3):\n                current_centers = project_overlaps(current_centers, target_radii, neighbors)\n                current_centers = project_boundaries(current_centers, target_radii)\n        \n        return current_centers, target_radii\n    \n    def final_lp(centers):\n        n = len(centers)\n        dists = squareform(pdist(centers))\n        \n        # Boundary constraints\n        boundary_caps = np.minimum.reduce([\n            centers[:, 0], centers[:, 1],\n            1 - centers[:, 0], 1 - centers[:, 1]\n        ])\n        \n        # LP setup\n        c = -np.ones(n)\n        bounds = [(0, boundary_caps[i]) for i in range(n)]\n        \n        A_ub = []\n        b_ub = []\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                constraint[j] = 1\n                A_ub.append(constraint)\n                b_ub.append(dists[i, j] - 1e-6)\n        \n        if A_ub:\n            A_ub = np.array(A_ub)\n            b_ub = np.array(b_ub)\n            \n            # Ensure strict feasibility\n            if np.any(b_ub <= 0):\n                scale = 0.99\n                centers_scaled = centers * scale + (1 - scale) * 0.5\n                return final_lp(centers_scaled)\n            \n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if result.success and result.x is not None:\n                return result.x\n        \n        return np.zeros(n)\n    \n    # Main algorithm\n    best_sum = 0\n    best_result = None\n    \n    for trial in range(5):\n        # Initialize\n        if trial == 0:\n            centers = create_hex_grid(26)\n        else:\n            centers = np.random.uniform(0.1, 0.9, (26, 2))\n        \n        # Alternating projections\n        centers, target_radii = alternating_projections(centers)\n        \n        # Gradient polish\n        def obj_wrapper(x):\n            return smooth_objective(x, target_radii)\n        \n        def grad_wrapper(x):\n            return smooth_gradient(x, target_radii)\n        \n        bounds_opt = [(target_radii[i], 1 - target_radii[i]) for i in range(26)]\n        bounds_opt = [(max(b[0], 0.01), min(b[1], 0.99)) for b in bounds_opt]\n        bounds_opt = bounds_opt + bounds_opt  # For x and y coordinates\n        \n        try:\n            result = minimize(obj_wrapper, centers.flatten(), \n                            method='L-BFGS-B', jac=grad_wrapper,\n                            bounds=bounds_opt, options={'maxiter': 100})\n            if result.success:\n                centers = result.x.reshape(-1, 2)\n        except:\n            pass\n        \n        # Final LP\n        radii = final_lp(centers)\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_result = (centers.copy(), radii.copy(), sum_radii)\n    \n    if best_result is None:\n        centers = create_hex_grid(26)\n        radii = np.zeros(26)\n        return centers, radii, 0.0\n    \n    return best_result",
  "metrics": {
    "valid": true,
    "score": 2.3124576944346873,
    "eval_time": 1.0246789455413818,
    "error": null
  },
  "prompt": "\nYou must return Python code only, no prose.\nImplement construct_packing() that returns a strictly feasible packing of 26 circles\ninside [0,1]^2 maximizing sum of radii. Allowed modules: numpy, scipy.\nReturn (centers, radii, sum_radii) with shapes (26,2), (26,), float.\n\nHard constraints:\n- All circles inside the unit square (x_i in [r_i, 1-r_i], y_i in [r_i, 1-r_i])\n- No overlaps: ||c_i - c_j|| >= r_i + r_j + 1e-6 for all i<j\n- Radii >= 0\n- Exactly 26 circles\n\nCore pattern to use:\n- Optimize centers (and possibly radii) via a smooth penalized objective using analytic gradients.\n  Use epsilon stabilization only in divisions (not in penalties) to avoid bias.\n- After continuous optimization, solve a linear program (LP) to maximize sum(r) subject to:\n  0 <= r_i <= r_i_current, r_i <= x_i, y_i, 1-x_i, 1-y_i and r_i + r_j <= dist_ij - 1e-6.\n  Use scipy.optimize.linprog (HiGHS). Return the LP-feasible final solution.\n\nPerformance requirements:\n- No prints. Runtime-conscious (<=300s).\n- Use vectorized gradients for boundary and pairwise penalties.\n- Multiple random/deterministic starts and keep the best.\n\nConstructive algorithm:\n- Initialize centers via stretched hex lattice biased toward edges and corners.\n- Alternating projections:\n  - Project onto boundary-feasible set by clamping centers given target radii estimates.\n  - For pairs i<j, if overlap occurs for target radii, push centers along the line of centers proportionally (Dykstra-like cycle).\n- Target radii updated every few passes using LP with caps tied to local clearance.\n- After cycles, run a short L-BFGS-B gradient polish on centers with a smooth overlap penalty, then final LP.\n- Use neighbor lists (k=6) to accelerate projections.\nReturn strictly feasible LP result.\n\nLP details:\n- Variables: r (26,)\n- Objective: maximize sum(r) => minimize -sum(r)\n- Bounds: 0 <= r_i <= r_cap_i (cap_i from current candidate radii or from boundary clearance)\n- Inequalities:\n  For each i: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n  For each i<j: r_i + r_j <= dist_ij - 1e-6\nEnsure strict feasibility: if any dist_ij - 1e-6 <= 0, slightly shrink by a small global factor before LP.\n\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    def create_hex_grid(n_circles):\n        # Create stretched hexagonal lattice biased toward edges\n        rows = int(np.ceil(np.sqrt(n_circles / 0.866)))\n        cols = int(np.ceil(n_circles / rows))\n        \n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n_circles:\n                    break\n                x = j / (cols - 1) if cols > 1 else 0.5\n                y = i / (rows - 1) if rows > 1 else 0.5\n                \n                # Hex offset\n                if i % 2 == 1:\n                    x += 0.5 / cols\n                \n                # Bias toward edges\n                x = x * 0.8 + 0.1\n                y = y * 0.8 + 0.1\n                \n                centers.append([x, y])\n        \n        return np.array(centers[:n_circles])\n    \n    def get_neighbors(centers, k=6):\n        n = len(centers)\n        dists = squareform(pdist(centers))\n        neighbors = []\n        for i in range(n):\n            # Get k nearest neighbors (excluding self)\n            idx = np.argsort(dists[i])\n            neighbors.append(idx[1:k+1])\n        return neighbors\n    \n    def project_boundaries(centers, target_radii):\n        # Clamp centers to ensure boundary feasibility\n        new_centers = centers.copy()\n        for i in range(len(centers)):\n            r = target_radii[i]\n            new_centers[i, 0] = np.clip(centers[i, 0], r, 1 - r)\n            new_centers[i, 1] = np.clip(centers[i, 1], r, 1 - r)\n        return new_centers\n    \n    def project_overlaps(centers, target_radii, neighbors):\n        # Dykstra-like projection for overlaps\n        new_centers = centers.copy()\n        n = len(centers)\n        \n        for i in range(n):\n            for j in neighbors[i]:\n                if j <= i:\n                    continue\n                    \n                dist = np.linalg.norm(centers[i] - centers[j])\n                required_dist = target_radii[i] + target_radii[j] + 1e-6\n                \n                if dist < required_dist and dist > 1e-10:\n                    # Push apart proportionally\n                    direction = (centers[i] - centers[j]) / dist\n                    gap = required_dist - dist\n                    \n                    # Move proportional to radii\n                    total_r = target_radii[i] + target_radii[j]\n                    if total_r > 1e-10:\n                        move_i = gap * target_radii[j] / total_r / 2\n                        move_j = gap * target_radii[i] / total_r / 2\n                    else:\n                        move_i = move_j = gap / 4\n                    \n                    new_centers[i] += move_i * direction\n                    new_centers[j] -= move_j * direction\n        \n        return new_centers\n    \n    def estimate_radii_lp(centers):\n        n = len(centers)\n        \n        # Boundary clearances\n        boundary_caps = np.minimum.reduce([\n            centers[:, 0], centers[:, 1], \n            1 - centers[:, 0], 1 - centers[:, 1]\n        ])\n        \n        # Distance constraints\n        dists = squareform(pdist(centers))\n        \n        # LP setup\n        c = -np.ones(n)  # Minimize -sum(r)\n        bounds = [(0, boundary_caps[i]) for i in range(n)]\n        \n        # Inequality constraints: r_i + r_j <= dist_ij - 1e-6\n        A_ub = []\n        b_ub = []\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                constraint[j] = 1\n                A_ub.append(constraint)\n                b_ub.append(dists[i, j] - 1e-6)\n        \n        if A_ub:\n            A_ub = np.array(A_ub)\n            b_ub = np.array(b_ub)\n            \n            # Ensure feasibility\n            if np.any(b_ub <= 0):\n                return np.zeros(n)\n            \n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if result.success:\n                return result.x\n        \n        return boundary_caps * 0.1\n    \n    def smooth_objective(x, target_radii):\n        centers = x.reshape(-1, 2)\n        n = len(centers)\n        \n        # Boundary penalties\n        boundary_penalty = 0\n        for i in range(n):\n            r = target_radii[i]\n            penalty = 0\n            penalty += max(0, r - centers[i, 0])**2\n            penalty += max(0, r - centers[i, 1])**2\n            penalty += max(0, r - (1 - centers[i, 0]))**2\n            penalty += max(0, r - (1 - centers[i, 1]))**2\n            boundary_penalty += penalty\n        \n        # Overlap penalties\n        overlap_penalty = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required = target_radii[i] + target_radii[j] + 1e-6\n                if dist < required:\n                    overlap_penalty += (required - dist)**2\n        \n        return boundary_penalty + overlap_penalty\n    \n    def smooth_gradient(x, target_radii):\n        centers = x.reshape(-1, 2)\n        n = len(centers)\n        grad = np.zeros_like(centers)\n        \n        # Boundary gradient\n        for i in range(n):\n            r = target_radii[i]\n            if centers[i, 0] < r:\n                grad[i, 0] -= 2 * (r - centers[i, 0])\n            if centers[i, 1] < r:\n                grad[i, 1] -= 2 * (r - centers[i, 1])\n            if centers[i, 0] > 1 - r:\n                grad[i, 0] += 2 * (centers[i, 0] - (1 - r))\n            if centers[i, 1] > 1 - r:\n                grad[i, 1] += 2 * (centers[i, 1] - (1 - r))\n        \n        # Overlap gradient\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                required = target_radii[i] + target_radii[j] + 1e-6\n                \n                if dist < required and dist > 1e-10:\n                    factor = -2 * (required - dist) / dist\n                    grad[i] += factor * diff\n                    grad[j] -= factor * diff\n        \n        return grad.flatten()\n    \n    def alternating_projections(centers, max_iter=50):\n        n = len(centers)\n        current_centers = centers.copy()\n        \n        for iteration in range(max_iter):\n            # Estimate target radii\n            target_radii = estimate_radii_lp(current_centers)\n            \n            if iteration % 5 == 0:\n                neighbors = get_neighbors(current_centers, k=6)\n            \n            # Project boundaries\n            current_centers = project_boundaries(current_centers, target_radii)\n            \n            # Project overlaps\n            for _ in range(3):\n                current_centers = project_overlaps(current_centers, target_radii, neighbors)\n                current_centers = project_boundaries(current_centers, target_radii)\n        \n        return current_centers, target_radii\n    \n    def final_lp(centers):\n        n = len(centers)\n        dists = squareform(pdist(centers))\n        \n        # Boundary constraints\n        boundary_caps = np.minimum.reduce([\n            centers[:, 0], centers[:, 1],\n            1 - centers[:, 0], 1 - centers[:, 1]\n        ])\n        \n        # LP setup\n        c = -np.ones(n)\n        bounds = [(0, boundary_caps[i]) for i in range(n)]\n        \n        A_ub = []\n        b_ub = []\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                constraint[j] = 1\n                A_ub.append(constraint)\n                b_ub.append(dists[i, j] - 1e-6)\n        \n        if A_ub:\n            A_ub = np.array(A_ub)\n            b_ub = np.array(b_ub)\n            \n            # Ensure strict feasibility\n            if np.any(b_ub <= 0):\n                scale = 0.99\n                centers_scaled = centers * scale + (1 - scale) * 0.5\n                return final_lp(centers_scaled)\n            \n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if result.success and result.x is not None:\n                return result.x\n        \n        return np.zeros(n)\n    \n    # Main algorithm\n    best_sum = 0\n    best_result = None\n    \n    for trial in range(5):\n        # Initialize\n        if trial == 0:\n            centers = create_hex_grid(26)\n        else:\n            centers = np.random.uniform(0.1, 0.9, (26, 2))\n        \n        # Alternating projections\n        centers, target_radii = alternating_projections(centers)\n        \n        # Gradient polish\n        def obj_wrapper(x):\n            return smooth_objective(x, target_radii)\n        \n        def grad_wrapper(x):\n            return smooth_gradient(x, target_radii)\n        \n        bounds_opt = [(target_radii[i], 1 - target_radii[i]) for i in range(26)]\n        bounds_opt = [(max(b[0], 0.01), min(b[1], 0.99)) for b in bounds_opt]\n        bounds_opt = bounds_opt + bounds_opt  # For x and y coordinates\n        \n        try:\n            result = minimize(obj_wrapper, centers.flatten(), \n                            method='L-BFGS-B', jac=grad_wrapper,\n                            bounds=bounds_opt, options={'maxiter': 100})\n            if result.success:\n                centers = result.x.reshape(-1, 2)\n        except:\n            pass\n        \n        # Final LP\n        radii = final_lp(centers)\n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_result = (centers.copy(), radii.copy(), sum_radii)\n    \n    if best_result is None:\n        centers = create_hex_grid(26)\n        radii = np.zeros(26)\n        return centers, radii, 0.0\n    \n    return best_result\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T02:49:07.633336",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4",
    "temperature": 0.35
  },
  "llm_call_duration_s": 36.14023498597089,
  "eval_duration_s": 1.024684934061952
}