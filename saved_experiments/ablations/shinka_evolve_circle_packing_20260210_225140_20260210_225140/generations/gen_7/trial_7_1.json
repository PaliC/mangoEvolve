{
  "trial_id": "trial_7_1",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.special import expit\n\ndef optimize_centers(seed, stages):\n    n = seed.shape[0]\n    x0 = seed.ravel()\n    ii, jj = np.triu_indices(n, 1)\n    def make_fun_grad(alpha, tau):\n        def fun_grad(x):\n            X = x.reshape(-1, 2)\n            b = np.minimum.reduce([X[:,0], X[:,1], 1-X[:,0], 1-X[:,1]])\n            diff = X[ii] - X[jj]  # (m,2)\n            d2 = np.sum(diff**2, axis=1)\n            dist = np.sqrt(d2)\n            target = alpha * (b[ii] + b[jj])\n            Z = (target - dist) / tau\n            # phi\n            phi = np.where(Z > 50, tau*Z, tau * np.log1p(np.exp(Z)))\n            f = np.sum(phi)\n            # gradient\n            Sig = expit(Z)  # (m,)\n            inv_d = 1.0 / (dist + 1e-6)\n            grad = np.zeros_like(X)\n            w = Sig * inv_d  # (m,)\n            contrib = diff * w[:,None]\n            # for ii\n            np.add.at(grad, ii, -contrib)\n            # for jj\n            np.add.at(grad, jj, contrib)\n            return f, grad.ravel()\n        return fun_grad\n\n    bounds = [(0.0, 1.0)] * (seed.size)\n    x = x0.copy()\n    for alpha, tau in stages:\n        res = minimize(make_fun_grad(alpha, tau), x, jac=True, bounds=bounds,\n                       method='L-BFGS-B', options={'maxiter': 100, 'ftol': 1e-6})\n        x = res.x\n    return x.reshape(-1,2)\n\ndef solve_radii(centers):\n    n = centers.shape[0]\n    ii, jj = np.triu_indices(n, 1)\n    m_pairs = len(ii)\n    diff = centers[ii] - centers[jj]\n    dist = np.sqrt(np.sum(diff**2, axis=1))\n    eps_sep = 1e-6\n    # LP: maximize sum(r) => minimize c^T r with c = -1\n    c = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    # boundary constraints\n    x = centers[:,0]; y = centers[:,1]\n    for i in range(n):\n        A = np.zeros(n); A[i] = 1.0\n        A_ub.append(A); b_ub.append(x[i])\n        A_ub.append(A); b_ub.append(y[i])\n        A_ub.append(A); b_ub.append(1 - x[i])\n        A_ub.append(A); b_ub.append(1 - y[i])\n    # pairwise\n    for k in range(m_pairs):\n        A = np.zeros(n)\n        A[ii[k]] = 1.0; A[jj[k]] = 1.0\n        A_ub.append(A); b_ub.append(dist[k] - eps_sep)\n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n    bounds = [(0.0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    if not res.success:\n        # fallback small radii\n        r = np.full(n, 1e-3)\n    else:\n        r = res.x\n    return r, res.fun\n\ndef construct_packing():\n    rng = np.random.RandomState(0)\n    n = 26\n    seeds = []\n    # seed 0: hex grid jitter\n    rows, cols = 5, 6\n    pts = []\n    for r in range(rows):\n        for c in range(cols):\n            x = (c + 0.5*(r%2)) / cols\n            y = r / (rows-1)\n            pts.append((x,y))\n    pts = np.array(pts[:n])\n    pts += rng.uniform(-0.01,0.01,size=pts.shape)\n    seeds.append(np.clip(pts, 0, 1))\n    # seed 1: edge-biased\n    pts = np.zeros((n,2))\n    for i in range(n):\n        if i < n//2:\n            side = rng.choice([0,1])\n            pts[i,0] = side*(1 - rng.rand()*0.02)\n            pts[i,1] = rng.rand()\n        else:\n            side = rng.choice([0,1])\n            pts[i,1] = side*(1 - rng.rand()*0.02)\n            pts[i,0] = rng.rand()\n    seeds.append(pts)\n    # seed 2: cluster center\n    pts = 0.5 + 0.1 * rng.randn(n,2)\n    seeds.append(np.clip(pts,0,1))\n    # seed 3: ring\n    angles = np.linspace(0, 2*np.pi, n, endpoint=False)\n    pts = 0.5 + 0.4 * np.vstack((np.cos(angles), np.sin(angles))).T\n    seeds.append(np.clip(pts,0,1))\n    # seeds 4-7: random uniform\n    for s in range(4):\n        seeds.append(rng.rand(n,2))\n    # optimization stages\n    stages = [(0.9,0.05),(0.95,0.03),(1.0,0.02),(1.05,0.01)]\n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    for seed in seeds:\n        C = optimize_centers(seed, stages)\n        r, fun = solve_radii(C)\n        s = r.sum()\n        if s > best_sum:\n            best_sum = s\n            best_centers = C\n            best_radii = r\n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.3983194828033447,
    "error": "Circle 0 at (0.0, 0.0) with radius 0.001 extends outside x-bounds"
  },
  "prompt": "You are writing a single Python file that exposes:\n\n- construct_packing() -> (centers, radii, sum_radii)\n- Optional: run_packing() for internal testing\n\nRequirements:\n- Exactly 26 circles.\n- centers: np.array shape (26,2), radii: np.array shape (26,), sum_radii: float\n- All circles strictly inside [0,1]^2; no overlaps with tolerance 1e-6.\n- Maximize sum(radii).\n- Allowed modules: numpy, scipy only.\n- No prints or extraneous output.\n- Return a strictly feasible packing.\n- Keep runtime <= 300s.\n\nImplementation preferences:\n- Use vectorized NumPy wherever possible.\n- For any smooth penalty, apply eps only to divisions (not to the penalty itself) to avoid bias.\n- Use LP feasibilization at the end to guarantee feasibility and maximize sum of radii:\n  Maximize sum(r) subject to:\n    r_i >= 0\n    r_i <= r_i_current\n    r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    r_i + r_j <= dist_ij - 1e-6 for all i<j\n  Solve with scipy.optimize.linprog, using -ones as objective (maximize sum by minimizing -sum).\n- Ensure numerical stability; avoid adding eps into the penalty value (only in denominators).\n- Deterministic seeds for any stochastic components.\n- Output only a single Python code block with the program (no prose).\n\nImplement a force-directed centers optimizer followed by LP for radii.\n\nMethod:\n- Maintain centers only; provisional radii handled implicitly via local boundary distances.\n- Smooth repulsion between centers based on desired spacing ~ local boundary-limited radii:\n  target_ij = alpha * (b_i + b_j) where b_i = min(x_i, y_i, 1-x_i, 1-y_i).\n- Use a soft penalty: phi(d) = softplus(target_ij - d, tau), gradient w.r.t. centers.\n- Anneal tau from 0.05 -> 0.01 and alpha from 0.9 -> 1.05 over stages to push centers apart realistically.\n- Optimize centers with L-BFGS-B (box bounds [0,1]) using analytic gradients (vectorized).\n- Multi-start with 8 seeds: hex-like grid + small jitters and edge-biased distributions.\n- After centers optimization, compute LP for radii as described to get strict feasibility and maximize sum.\n- Keep the best LP result.\n- Deterministic seeding.\n\nInclude fully vectorized pairwise computations; eps only in divisions.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.special import expit\n\ndef optimize_centers(seed, stages):\n    n = seed.shape[0]\n    x0 = seed.ravel()\n    ii, jj = np.triu_indices(n, 1)\n    def make_fun_grad(alpha, tau):\n        def fun_grad(x):\n            X = x.reshape(-1, 2)\n            b = np.minimum.reduce([X[:,0], X[:,1], 1-X[:,0], 1-X[:,1]])\n            diff = X[ii] - X[jj]  # (m,2)\n            d2 = np.sum(diff**2, axis=1)\n            dist = np.sqrt(d2)\n            target = alpha * (b[ii] + b[jj])\n            Z = (target - dist) / tau\n            # phi\n            phi = np.where(Z > 50, tau*Z, tau * np.log1p(np.exp(Z)))\n            f = np.sum(phi)\n            # gradient\n            Sig = expit(Z)  # (m,)\n            inv_d = 1.0 / (dist + 1e-6)\n            grad = np.zeros_like(X)\n            w = Sig * inv_d  # (m,)\n            contrib = diff * w[:,None]\n            # for ii\n            np.add.at(grad, ii, -contrib)\n            # for jj\n            np.add.at(grad, jj, contrib)\n            return f, grad.ravel()\n        return fun_grad\n\n    bounds = [(0.0, 1.0)] * (seed.size)\n    x = x0.copy()\n    for alpha, tau in stages:\n        res = minimize(make_fun_grad(alpha, tau), x, jac=True, bounds=bounds,\n                       method='L-BFGS-B', options={'maxiter': 100, 'ftol': 1e-6})\n        x = res.x\n    return x.reshape(-1,2)\n\ndef solve_radii(centers):\n    n = centers.shape[0]\n    ii, jj = np.triu_indices(n, 1)\n    m_pairs = len(ii)\n    diff = centers[ii] - centers[jj]\n    dist = np.sqrt(np.sum(diff**2, axis=1))\n    eps_sep = 1e-6\n    # LP: maximize sum(r) => minimize c^T r with c = -1\n    c = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    # boundary constraints\n    x = centers[:,0]; y = centers[:,1]\n    for i in range(n):\n        A = np.zeros(n); A[i] = 1.0\n        A_ub.append(A); b_ub.append(x[i])\n        A_ub.append(A); b_ub.append(y[i])\n        A_ub.append(A); b_ub.append(1 - x[i])\n        A_ub.append(A); b_ub.append(1 - y[i])\n    # pairwise\n    for k in range(m_pairs):\n        A = np.zeros(n)\n        A[ii[k]] = 1.0; A[jj[k]] = 1.0\n        A_ub.append(A); b_ub.append(dist[k] - eps_sep)\n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n    bounds = [(0.0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    if not res.success:\n        # fallback small radii\n        r = np.full(n, 1e-3)\n    else:\n        r = res.x\n    return r, res.fun\n\ndef construct_packing():\n    rng = np.random.RandomState(0)\n    n = 26\n    seeds = []\n    # seed 0: hex grid jitter\n    rows, cols = 5, 6\n    pts = []\n    for r in range(rows):\n        for c in range(cols):\n            x = (c + 0.5*(r%2)) / cols\n            y = r / (rows-1)\n            pts.append((x,y))\n    pts = np.array(pts[:n])\n    pts += rng.uniform(-0.01,0.01,size=pts.shape)\n    seeds.append(np.clip(pts, 0, 1))\n    # seed 1: edge-biased\n    pts = np.zeros((n,2))\n    for i in range(n):\n        if i < n//2:\n            side = rng.choice([0,1])\n            pts[i,0] = side*(1 - rng.rand()*0.02)\n            pts[i,1] = rng.rand()\n        else:\n            side = rng.choice([0,1])\n            pts[i,1] = side*(1 - rng.rand()*0.02)\n            pts[i,0] = rng.rand()\n    seeds.append(pts)\n    # seed 2: cluster center\n    pts = 0.5 + 0.1 * rng.randn(n,2)\n    seeds.append(np.clip(pts,0,1))\n    # seed 3: ring\n    angles = np.linspace(0, 2*np.pi, n, endpoint=False)\n    pts = 0.5 + 0.4 * np.vstack((np.cos(angles), np.sin(angles))).T\n    seeds.append(np.clip(pts,0,1))\n    # seeds 4-7: random uniform\n    for s in range(4):\n        seeds.append(rng.rand(n,2))\n    # optimization stages\n    stages = [(0.9,0.05),(0.95,0.03),(1.0,0.02),(1.05,0.01)]\n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    for seed in seeds:\n        C = optimize_centers(seed, stages)\n        r, fun = solve_radii(C)\n        s = r.sum()\n        if s > best_sum:\n            best_sum = s\n            best_centers = C\n            best_radii = r\n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```\n\n",
  "reasoning": "",
  "timestamp": "2026-02-11T01:45:15.753635",
  "cost_data": null,
  "model_config": {
    "model": "openai/o4-mini",
    "temperature": 0.4
  },
  "llm_call_duration_s": 41.834140110062435,
  "eval_duration_s": 0.3983265639981255
}