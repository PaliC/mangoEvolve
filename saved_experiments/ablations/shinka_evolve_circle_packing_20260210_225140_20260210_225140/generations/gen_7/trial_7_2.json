{
  "trial_id": "trial_7_2",
  "generation": 7,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping, minimize, linprog\nfrom scipy.spatial.distance import cdist # For pairwise distances\n\n# Constants\nN_CIRCLES = 26\nTOLERANCE = 1e-6 # For overlap and boundary checks in LP\n\n# Penalty coefficients for L-BFGS-B\nC_OVERLAP = 1000.0\nC_BOUNDARY = 1000.0\nC_NONNEG_R = 1000.0 # Penalty for negative radii in L-BFGS-B\n\n# Basin-hopping parameters\nN_HOPS_PER_START = 40\nN_STARTS = 4\nBH_TEMP = 1.0 # Initial temperature for accepting uphill moves\nBH_STEP_SIZE = 0.05 # Initial step size for random perturbations\n\n# Global variables to store the best result found across all basin-hopping runs\nbest_sum_radii = -np.inf\nbest_centers = None\nbest_radii = None\n\n# --- Objective Function and Gradient for L-BFGS-B ---\n\ndef _get_centers_radii(x_flat):\n    \"\"\"Extract centers and radii from the flattened optimization variable x_flat.\"\"\"\n    centers = x_flat.reshape(-1, 3)[:, :2]\n    radii = x_flat.reshape(-1, 3)[:, 2]\n    return centers, radii\n\ndef objective_and_gradient(x_flat):\n    \"\"\"\n    Calculates the penalized objective function value and its gradient.\n    x_flat: flattened array [cx1, cy1, r1, cx2, cy2, r2, ...]\n    \"\"\"\n    centers, radii = _get_centers_radii(x_flat)\n\n    # --- Objective: Maximize sum of radii (minimize -sum_radii) ---\n    obj_val = -np.sum(radii)\n    grad_obj = np.zeros_like(x_flat)\n    grad_obj[2::3] = -1.0 # Gradient for -sum(radii)\n\n    # --- Penalties ---\n    penalty_val = 0.0\n\n    # P_nonneg_r: Penalty for negative radii\n    # L-BFGS-B bounds should handle non-negativity, but this penalty helps guide\n    # the gradient if radii try to go negative within the optimizer's steps.\n    neg_radii_mask = radii < 0\n    penalty_nonneg_r = np.sum(np.maximum(0, -radii[neg_radii_mask])**2)\n    penalty_val += C_NONNEG_R * penalty_nonneg_r\n    grad_nonneg_r = np.zeros_like(radii)\n    grad_nonneg_r[neg_radii_mask] = C_NONNEG_R * 2 * (-radii[neg_radii_mask]) * (-1)\n    grad_obj[2::3] += grad_nonneg_r\n\n    # P_boundary: Penalty for circles extending beyond boundaries\n    # max(0, r - x)^2 + max(0, r - y)^2 + max(0, r - (1-x))^2 + max(0, r - (1-y))^2\n    \n    # Calculate terms for boundary penalty\n    r_minus_x = radii - centers[:, 0]\n    r_minus_y = radii - centers[:, 1]\n    r_minus_one_minus_x = radii - (1 - centers[:, 0])\n    r_minus_one_minus_y = radii - (1 - centers[:, 1])\n\n    # Penalty values\n    p_boundary_terms = np.maximum(0, r_minus_x)**2 + \\\n                       np.maximum(0, r_minus_y)**2 + \\\n                       np.maximum(0, r_minus_one_minus_x)**2 + \\\n                       np.maximum(0, r_minus_one_minus_y)**2\n    penalty_boundary = np.sum(p_boundary_terms)\n    penalty_val += C_BOUNDARY * penalty_boundary\n\n    # Gradients for boundary penalty\n    grad_cx_boundary = np.zeros(N_CIRCLES)\n    grad_cy_boundary = np.zeros(N_CIRCLES)\n    grad_r_boundary = np.zeros(N_CIRCLES)\n\n    # dP/dx_i\n    grad_cx_boundary += 2 * np.maximum(0, r_minus_x) * (-1)\n    grad_cx_boundary += 2 * np.maximum(0, r_minus_one_minus_x) * (1)\n\n    # dP/dy_i\n    grad_cy_boundary += 2 * np.maximum(0, r_minus_y) * (-1)\n    grad_cy_boundary += 2 * np.maximum(0, r_minus_one_minus_y) * (1)\n\n    # dP/dr_i\n    grad_r_boundary += 2 * np.maximum(0, r_minus_x)\n    grad_r_boundary += 2 * np.maximum(0, r_minus_y)\n    grad_r_boundary += 2 * np.maximum(0, r_minus_one_minus_x)\n    grad_r_boundary += 2 * np.maximum(0, r_minus_one_minus_y)\n\n    grad_obj[0::3] += C_BOUNDARY * grad_cx_boundary\n    grad_obj[1::3] += C_BOUNDARY * grad_cy_boundary\n    grad_obj[2::3] += C_BOUNDARY * grad_r_boundary\n\n    # P_overlap: Penalty for overlapping circles\n    # d_ij = sqrt((x_i-x_j)^2 + (y_i-y_j)^2)\n    # p_ij = max(0, r_i + r_j - d_ij)^2\n    \n    # Compute pairwise distances\n    distances_matrix = cdist(centers, centers)\n    np.fill_diagonal(distances_matrix, np.inf) # Ignore self-distance\n\n    # Create a matrix of r_i + r_j\n    radii_sum_matrix = radii[:, np.newaxis] + radii[np.newaxis, :]\n\n    # term_ij = r_i + r_j - d_ij\n    overlap_terms = radii_sum_matrix - distances_matrix\n    \n    # Only consider upper triangle for unique pairs\n    upper_tri_indices = np.triu_indices(N_CIRCLES, k=1)\n    overlap_values = overlap_terms[upper_tri_indices]\n\n    # Penalty values\n    penalty_overlap = np.sum(np.maximum(0, overlap_values)**2)\n    penalty_val += C_OVERLAP * penalty_overlap\n\n    # Gradients for overlap penalty\n    grad_cx_overlap = np.zeros(N_CIRCLES)\n    grad_cy_overlap = np.zeros(N_CIRCLES)\n    grad_r_overlap = np.zeros(N_CIRCLES)\n\n    # Only process pairs that actually overlap\n    overlapping_mask = overlap_values > 0\n    if np.any(overlapping_mask):\n        # Extract relevant pairs\n        i_indices = upper_tri_indices[0][overlapping_mask]\n        j_indices = upper_tri_indices[1][overlapping_mask]\n        \n        # Overlap value for these pairs\n        active_overlap_values = overlap_values[overlapping_mask]\n        \n        # Distances for these pairs (add small epsilon to denominator for stability)\n        active_distances = distances_matrix[i_indices, j_indices]\n        \n        # Calculate common factor for gradient: 2 * max(0, term_ij)\n        common_factor = C_OVERLAP * 2 * active_overlap_values\n        \n        # Differences in coordinates\n        dx = centers[i_indices, 0] - centers[j_indices, 0]\n        dy = centers[i_indices, 1] - centers[j_indices, 1]\n        \n        # Gradient contributions for cx_i, cy_i, r_i\n        grad_cx_i_contrib = common_factor * (-dx / (active_distances + 1e-10))\n        grad_cy_i_contrib = common_factor * (-dy / (active_distances + 1e-10))\n        grad_r_i_contrib = common_factor * (1)\n\n        # Accumulate contributions for circle i\n        np.add.at(grad_cx_overlap, i_indices, grad_cx_i_contrib)\n        np.add.at(grad_cy_overlap, i_indices, grad_cy_i_contrib)\n        np.add.at(grad_r_overlap, i_indices, grad_r_i_contrib)\n\n        # Gradient contributions for cx_j, cy_j, r_j\n        grad_cx_j_contrib = common_factor * (dx / (active_distances + 1e-10))\n        grad_cy_j_contrib = common_factor * (dy / (active_distances + 1e-10))\n        grad_r_j_contrib = common_factor * (1)\n\n        # Accumulate contributions for circle j\n        np.add.at(grad_cx_overlap, j_indices, grad_cx_j_contrib)\n        np.add.at(grad_cy_overlap, j_indices, grad_cy_j_contrib)\n        np.add.at(grad_r_overlap, j_indices, grad_r_j_contrib)\n\n    grad_obj[0::3] += grad_cx_overlap\n    grad_obj[1::3] += grad_cy_overlap\n    grad_obj[2::3] += grad_r_overlap\n    \n    total_objective = obj_val + penalty_val\n    return total_objective, grad_obj\n\n# --- LP Feasibilization ---\n\ndef lp_feasibilization(centers_fixed, radii_current):\n    \"\"\"\n    Maximizes sum of radii given fixed centers, ensuring feasibility.\n    Updates global best_sum_radii, best_centers, best_radii if a better solution is found.\n    \"\"\"\n    global best_sum_radii, best_centers, best_radii\n\n    N = N_CIRCLES\n    \n    # Objective: Maximize sum(r_i) => Minimize -sum(r_i)\n    c = -np.ones(N)\n\n    # A_ub @ r_lp <= b_ub\n    A_ub = []\n    b_ub = []\n\n    # 1. r_i <= r_i_current (upper bound from L-BFGS-B result)\n    for i in range(N):\n        row = np.zeros(N)\n        row[i] = 1\n        A_ub.append(row)\n        b_ub.append(radii_current[i])\n\n    # 2. Boundary constraints: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    # Subtract TOLERANCE to ensure strict containment\n    for i in range(N):\n        row_x = np.zeros(N)\n        row_x[i] = 1\n        A_ub.append(row_x)\n        b_ub.append(centers_fixed[i, 0] - TOLERANCE)\n\n        row_y = np.zeros(N)\n        row_y[i] = 1\n        A_ub.append(row_y)\n        b_ub.append(centers_fixed[i, 1] - TOLERANCE)\n\n        row_1_minus_x = np.zeros(N)\n        row_1_minus_x[i] = 1\n        A_ub.append(row_1_minus_x)\n        b_ub.append(1 - centers_fixed[i, 0] - TOLERANCE)\n\n        row_1_minus_y = np.zeros(N)\n        row_1_minus_y[i] = 1\n        A_ub.append(row_1_minus_y)\n        b_ub.append(1 - centers_fixed[i, 1] - TOLERANCE)\n\n    # 3. Overlap constraints: r_i + r_j <= dist_ij - TOLERANCE\n    distances = cdist(centers_fixed, centers_fixed)\n    for i in range(N):\n        for j in range(i + 1, N):\n            row_overlap = np.zeros(N)\n            row_overlap[i] = 1\n            row_overlap[j] = 1\n            A_ub.append(row_overlap)\n            b_ub.append(distances[i, j] - TOLERANCE)\n\n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n\n    # Bounds for radii: r_i >= 0\n    r_bounds = [(0, None)] * N # (lower_bound, upper_bound)\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=r_bounds, method='highs')\n\n    if res.success:\n        final_radii = res.x\n        final_sum_radii = np.sum(final_radii)\n        \n        if final_sum_radii > best_sum_radii:\n            best_sum_radii = final_sum_radii\n            best_centers = centers_fixed.copy()\n            best_radii = final_radii.copy()\n        return final_sum_radii, final_radii\n    else:\n        return -np.inf, None\n\n# --- Basin-hopping callback ---\n\nclass BasinHoppingCallback:\n    \"\"\"\n    Callback function for basin-hopping.\n    Called after each local minimization.\n    \"\"\"\n    def __call__(self, x_local_min, f_local_min, accepted):\n        # x_local_min is the result of the local minimizer\n        centers, radii = _get_centers_radii(x_local_min)\n        \n        # Ensure radii are non-negative before LP (L-BFGS-B bounds should help, but safeguard)\n        radii_clamped = np.maximum(radii, 0)\n\n        # Apply LP feasibilization and update global best result\n        lp_feasibilization(centers, radii_clamped)\n        \n        # Return False to stop basin-hopping early if needed (not used here)\n        return False\n\n# --- Initial Guess Generation ---\n\ndef generate_initial_guess(seed, strategy_type):\n    \"\"\"\n    Generates an initial configuration of centers and radii based on a strategy.\n    \"\"\"\n    np.random.seed(seed)\n    \n    initial_x_flat = np.zeros(N_CIRCLES * 3)\n\n    if strategy_type == \"grid\":\n        # For N=26, a 5x5 grid + 1 extra circle\n        num_rows = 5\n        num_cols = 5\n        \n        x_coords = np.linspace(0.15, 0.85, num_cols)\n        y_coords = np.linspace(0.15, 0.85, num_rows)\n        \n        centers = []\n        for y in y_coords:\n            for x in x_coords:\n                centers.append([x, y])\n        \n        # Add one more center, e.g., in the middle\n        centers.append([0.5, 0.5]) \n        centers = np.array(centers[:N_CIRCLES]) # Take exactly N_CIRCLES\n        \n        # Perturb slightly\n        centers += np.random.uniform(-0.02, 0.02, centers.shape)\n        centers = np.clip(centers, 0.05, 0.95) # Keep within bounds\n        \n        initial_r = 0.5 / np.sqrt(N_CIRCLES) * 0.8 # Initial radius\n        radii = np.full(N_CIRCLES, initial_r)\n        \n        initial_x_flat[0::3] = centers[:, 0]\n        initial_x_flat[1::3] = centers[:, 1]\n        initial_x_flat[2::3] = radii\n\n    elif strategy_type == \"hexagonal\":\n        # Approximate hexagonal packing\n        centers = []\n        r_hex_approx = 0.5 / np.sqrt(N_CIRCLES)\n        \n        # Central circle\n        centers.append([0.5, 0.5])\n        \n        # Layers around it\n        # Distance between centers of adjacent circles in a perfect hex grid\n        layer_dist_unit = 2 * r_hex_approx * np.sqrt(3)/2 \n        \n        # Generate points for up to 3 layers (1+6+12+18 = 37 points)\n        for layer in range(1, 4): \n            current_layer_dist = layer * layer_dist_unit * 1.1 # Slightly larger spacing\n            num_in_layer = 6 * layer\n            for i in range(num_in_layer):\n                angle = 2 * np.pi * i / num_in_layer\n                cx = 0.5 + current_layer_dist * np.cos(angle)\n                cy = 0.5 + current_layer_dist * np.sin(angle)\n                centers.append([cx, cy])\n        \n        centers = np.array(centers)\n        \n        # Select N_CIRCLES centers, prioritizing those closer to the center\n        if len(centers) > N_CIRCLES:\n            distances_from_center = np.linalg.norm(centers - 0.5, axis=1)\n            sorted_indices = np.argsort(distances_from_center)\n            centers = centers[sorted_indices[:N_CIRCLES]]\n        elif len(centers) < N_CIRCLES:\n            # If not enough points, fill remaining with random ones\n            remaining = N_CIRCLES - len(centers)\n            random_centers = np.random.uniform(0.1, 0.9, (remaining, 2))\n            centers = np.vstack([centers, random_centers])\n\n        centers += np.random.uniform(-0.02, 0.02, centers.shape)\n        centers = np.clip(centers, 0.05, 0.95)\n\n        initial_r = 0.5 / np.sqrt(N_CIRCLES) * 0.8\n        radii = np.full(N_CIRCLES, initial_r)\n        \n        initial_x_flat[0::3] = centers[:, 0]\n        initial_x_flat[1::3] = centers[:, 1]\n        initial_x_flat[2::3] = radii\n\n    elif strategy_type == \"random\":\n        initial_x_flat[0::3] = np.random.uniform(0.1, 0.9, N_CIRCLES)\n        initial_x_flat[1::3] = np.random.uniform(0.1, 0.9, N_CIRCLES)\n        initial_x_flat[2::3] = np.random.uniform(0.01, 0.05, N_CIRCLES) # Small radii\n\n    elif strategy_type == \"clustered\":\n        # All circles initially near the center\n        initial_x_flat[0::3] = np.random.uniform(0.4, 0.6, N_CIRCLES)\n        initial_x_flat[1::3] = np.random.uniform(0.4, 0.6, N_CIRCLES)\n        initial_x_flat[2::3] = np.random.uniform(0.01, 0.05, N_CIRCLES) # Small radii\n    \n    return initial_x_flat\n\n# --- Main Packing Function ---\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 non-overlapping circles into a unit square\n    to maximize the sum of their radii.\n    \"\"\"\n    global best_sum_radii, best_centers, best_radii\n    \n    # Reset global bests for a fresh run\n    best_sum_radii = -np.inf\n    best_centers = None\n    best_radii = None\n\n    # Bounds for L-BFGS-B: (min_val, max_val) for each variable\n    # cx, cy in [0, 1], r in [0, 0.5] (max possible radius for a circle in unit square)\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N_CIRCLES\n\n    # Minimizer arguments for L-BFGS-B\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"jac\": True,  # We provide the gradient\n        \"bounds\": bounds,\n        \"options\": {\"maxiter\": 1000, \"ftol\": 1e-7, \"gtol\": 1e-5} # Tuned options for L-BFGS-B\n    }\n\n    # Deterministic seeds for initial guesses and basin-hopping\n    initial_guess_seeds = [42, 123, 789, 555]\n    strategy_types = [\"grid\", \"hexagonal\", \"random\", \"clustered\"]\n\n    for i in range(N_STARTS):\n        seed = initial_guess_seeds[i]\n        strategy = strategy_types[i % len(strategy_types)] # Cycle through strategies\n        \n        initial_x = generate_initial_guess(seed, strategy)\n        \n        # Ensure initial radii are positive (L-BFGS-B bounds also enforce this)\n        initial_x[2::3] = np.maximum(initial_x[2::3], 1e-6)\n\n        # Basin-hopping\n        # Use a deterministic seed for basin-hopping's internal random perturbations\n        # Add offsets to seeds to ensure distinct random sequences for different starts\n        np.random.seed(seed + 1000) \n        \n        # Create a callback instance for this run\n        bh_callback = BasinHoppingCallback()\n\n        basinhopping(\n            func=objective_and_gradient,\n            x0=initial_x,\n            niter=N_HOPS_PER_START,\n            T=BH_TEMP,\n            stepsize=BH_STEP_SIZE,\n            minimizer_kwargs=minimizer_kwargs,\n            callback=bh_callback,\n            seed=seed + 2000 # Seed for basinhopping's internal random generator\n        )\n        \n        # The `best_sum_radii` global variable is updated by the callback\n        # after each local minimization, so no explicit action needed here.\n        \n    return best_centers, best_radii, best_sum_radii\n\n# --- For internal testing (optional) ---\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Final sum of radii: {sum_radii:.6f}\")\n    \n    # Basic validation\n    if centers is None or radii is None:\n        print(\"No valid packing found.\")\n        return centers, radii, sum_radii\n\n    N = len(radii)\n    print(f\"Number of circles: {N}\")\n\n    # 1. Check if all circles are within the unit square\n    min_x = centers[:, 0] - radii\n    max_x = centers[:, 0] + radii\n    min_y = centers[:, 1] - radii\n    max_y = centers[:, 1] + radii\n\n    # Allow a small tolerance for boundary checks, consistent with LP\n    boundary_ok = (np.all(min_x >= -TOLERANCE) and np.all(max_x <= 1 + TOLERANCE) and\n                   np.all(min_y >= -TOLERANCE) and np.all(max_y <= 1 + TOLERANCE))\n    if not boundary_ok:\n        print(\"Validation FAILED: Some circles are outside the unit square.\")\n        print(f\"  min_x: {np.min(min_x):.6f}, max_x: {np.max(max_x):.6f}, min_y: {np.min(min_y):.6f}, max_y: {np.max(max_y):.6f}\")\n    else:\n        print(\"Validation PASSED: All circles are within the unit square.\")\n\n    # 2. Check for overlaps\n    distances = cdist(centers, centers)\n    np.fill_diagonal(distances, np.inf) # Ignore self-distance\n\n    radii_sum_matrix = radii[:, np.newaxis] + radii[np.newaxis, :]\n    \n    overlaps = radii_sum_matrix - distances\n    \n    if np.any(overlaps > TOLERANCE):\n        print(\"Validation FAILED: Overlapping circles detected.\")\n        max_overlap = np.max(overlaps)\n        print(f\"  Max overlap: {max_overlap:.6f}\")\n    else:\n        print(\"Validation PASSED: No overlapping circles.\")\n\n    # 3. Check for non-negative radii\n    if np.any(radii < -TOLERANCE):\n        print(\"Validation FAILED: Negative radii detected.\")\n    else:\n        print(\"Validation PASSED: All radii are non-negative.\")\n\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.6264807921490343,
    "eval_time": 12.98149561882019,
    "error": null
  },
  "prompt": "You are writing a single Python file that exposes:\n\n- construct_packing() -> (centers, radii, sum_radii)\n- Optional: run_packing() for internal testing\n\nRequirements:\n- Exactly 26 circles.\n- centers: np.array shape (26,2), radii: np.array shape (26,), sum_radii: float\n- All circles strictly inside [0,1]^2; no overlaps with tolerance 1e-6.\n- Maximize sum(radii).\n- Allowed modules: numpy, scipy only.\n- No prints or extraneous output.\n- Return a strictly feasible packing.\n- Keep runtime <= 300s.\n\nImplementation preferences:\n- Use vectorized NumPy wherever possible.\n- For any smooth penalty, apply eps only to divisions (not to the penalty itself) to avoid bias.\n- Use LP feasibilization at the end to guarantee feasibility and maximize sum of radii:\n  Maximize sum(r) subject to:\n    r_i >= 0\n    r_i <= r_i_current\n    r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    r_i + r_j <= dist_ij - 1e-6 for all i<j\n  Solve with scipy.optimize.linprog, using -ones as objective (maximize sum by minimizing -sum).\n- Ensure numerical stability; avoid adding eps into the penalty value (only in denominators).\n- Deterministic seeds for any stochastic components.\n- Output only a single Python code block with the program (no prose).\n\nCreate a basin-hopping strategy:\n- Variables: centers and provisional radii.\n- Local minimizer: L-BFGS-B on a smooth penalized objective with analytic gradients; eps only in denominators.\n- Basin-hopping: ~40 hops per start, 4 deterministic starts (different structured seeds), with adaptive step size.\n- Use temperature schedule to accept uphill moves occasionally.\n- After each local minimum, apply LP feasibilization to produce strict feasibility and improve sum of radii.\n- Keep the best LP result across all hops/starts.\n- Vectorized gradient for:\n  * Boundary hinge: max(0, r - min(x,y,1-x,1-y))\n  * Overlaps: max(0, r_i + r_j - d_ij), gradient via pairwise diffs\n- Ensure radii nonnegative during optimization.\n\nBe careful with runtime; keep implementation efficient and vectorized.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize, linprog\nfrom scipy.spatial.distance import cdist # For pairwise distances\n\n# Constants\nN_CIRCLES = 26\nTOLERANCE = 1e-6 # For overlap and boundary checks in LP\n\n# Penalty coefficients for L-BFGS-B\nC_OVERLAP = 1000.0\nC_BOUNDARY = 1000.0\nC_NONNEG_R = 1000.0 # Penalty for negative radii in L-BFGS-B\n\n# Basin-hopping parameters\nN_HOPS_PER_START = 40\nN_STARTS = 4\nBH_TEMP = 1.0 # Initial temperature for accepting uphill moves\nBH_STEP_SIZE = 0.05 # Initial step size for random perturbations\n\n# Global variables to store the best result found across all basin-hopping runs\nbest_sum_radii = -np.inf\nbest_centers = None\nbest_radii = None\n\n# --- Objective Function and Gradient for L-BFGS-B ---\n\ndef _get_centers_radii(x_flat):\n    \"\"\"Extract centers and radii from the flattened optimization variable x_flat.\"\"\"\n    centers = x_flat.reshape(-1, 3)[:, :2]\n    radii = x_flat.reshape(-1, 3)[:, 2]\n    return centers, radii\n\ndef objective_and_gradient(x_flat):\n    \"\"\"\n    Calculates the penalized objective function value and its gradient.\n    x_flat: flattened array [cx1, cy1, r1, cx2, cy2, r2, ...]\n    \"\"\"\n    centers, radii = _get_centers_radii(x_flat)\n\n    # --- Objective: Maximize sum of radii (minimize -sum_radii) ---\n    obj_val = -np.sum(radii)\n    grad_obj = np.zeros_like(x_flat)\n    grad_obj[2::3] = -1.0 # Gradient for -sum(radii)\n\n    # --- Penalties ---\n    penalty_val = 0.0\n\n    # P_nonneg_r: Penalty for negative radii\n    # L-BFGS-B bounds should handle non-negativity, but this penalty helps guide\n    # the gradient if radii try to go negative within the optimizer's steps.\n    neg_radii_mask = radii < 0\n    penalty_nonneg_r = np.sum(np.maximum(0, -radii[neg_radii_mask])**2)\n    penalty_val += C_NONNEG_R * penalty_nonneg_r\n    grad_nonneg_r = np.zeros_like(radii)\n    grad_nonneg_r[neg_radii_mask] = C_NONNEG_R * 2 * (-radii[neg_radii_mask]) * (-1)\n    grad_obj[2::3] += grad_nonneg_r\n\n    # P_boundary: Penalty for circles extending beyond boundaries\n    # max(0, r - x)^2 + max(0, r - y)^2 + max(0, r - (1-x))^2 + max(0, r - (1-y))^2\n    \n    # Calculate terms for boundary penalty\n    r_minus_x = radii - centers[:, 0]\n    r_minus_y = radii - centers[:, 1]\n    r_minus_one_minus_x = radii - (1 - centers[:, 0])\n    r_minus_one_minus_y = radii - (1 - centers[:, 1])\n\n    # Penalty values\n    p_boundary_terms = np.maximum(0, r_minus_x)**2 + \\\n                       np.maximum(0, r_minus_y)**2 + \\\n                       np.maximum(0, r_minus_one_minus_x)**2 + \\\n                       np.maximum(0, r_minus_one_minus_y)**2\n    penalty_boundary = np.sum(p_boundary_terms)\n    penalty_val += C_BOUNDARY * penalty_boundary\n\n    # Gradients for boundary penalty\n    grad_cx_boundary = np.zeros(N_CIRCLES)\n    grad_cy_boundary = np.zeros(N_CIRCLES)\n    grad_r_boundary = np.zeros(N_CIRCLES)\n\n    # dP/dx_i\n    grad_cx_boundary += 2 * np.maximum(0, r_minus_x) * (-1)\n    grad_cx_boundary += 2 * np.maximum(0, r_minus_one_minus_x) * (1)\n\n    # dP/dy_i\n    grad_cy_boundary += 2 * np.maximum(0, r_minus_y) * (-1)\n    grad_cy_boundary += 2 * np.maximum(0, r_minus_one_minus_y) * (1)\n\n    # dP/dr_i\n    grad_r_boundary += 2 * np.maximum(0, r_minus_x)\n    grad_r_boundary += 2 * np.maximum(0, r_minus_y)\n    grad_r_boundary += 2 * np.maximum(0, r_minus_one_minus_x)\n    grad_r_boundary += 2 * np.maximum(0, r_minus_one_minus_y)\n\n    grad_obj[0::3] += C_BOUNDARY * grad_cx_boundary\n    grad_obj[1::3] += C_BOUNDARY * grad_cy_boundary\n    grad_obj[2::3] += C_BOUNDARY * grad_r_boundary\n\n    # P_overlap: Penalty for overlapping circles\n    # d_ij = sqrt((x_i-x_j)^2 + (y_i-y_j)^2)\n    # p_ij = max(0, r_i + r_j - d_ij)^2\n    \n    # Compute pairwise distances\n    distances_matrix = cdist(centers, centers)\n    np.fill_diagonal(distances_matrix, np.inf) # Ignore self-distance\n\n    # Create a matrix of r_i + r_j\n    radii_sum_matrix = radii[:, np.newaxis] + radii[np.newaxis, :]\n\n    # term_ij = r_i + r_j - d_ij\n    overlap_terms = radii_sum_matrix - distances_matrix\n    \n    # Only consider upper triangle for unique pairs\n    upper_tri_indices = np.triu_indices(N_CIRCLES, k=1)\n    overlap_values = overlap_terms[upper_tri_indices]\n\n    # Penalty values\n    penalty_overlap = np.sum(np.maximum(0, overlap_values)**2)\n    penalty_val += C_OVERLAP * penalty_overlap\n\n    # Gradients for overlap penalty\n    grad_cx_overlap = np.zeros(N_CIRCLES)\n    grad_cy_overlap = np.zeros(N_CIRCLES)\n    grad_r_overlap = np.zeros(N_CIRCLES)\n\n    # Only process pairs that actually overlap\n    overlapping_mask = overlap_values > 0\n    if np.any(overlapping_mask):\n        # Extract relevant pairs\n        i_indices = upper_tri_indices[0][overlapping_mask]\n        j_indices = upper_tri_indices[1][overlapping_mask]\n        \n        # Overlap value for these pairs\n        active_overlap_values = overlap_values[overlapping_mask]\n        \n        # Distances for these pairs (add small epsilon to denominator for stability)\n        active_distances = distances_matrix[i_indices, j_indices]\n        \n        # Calculate common factor for gradient: 2 * max(0, term_ij)\n        common_factor = C_OVERLAP * 2 * active_overlap_values\n        \n        # Differences in coordinates\n        dx = centers[i_indices, 0] - centers[j_indices, 0]\n        dy = centers[i_indices, 1] - centers[j_indices, 1]\n        \n        # Gradient contributions for cx_i, cy_i, r_i\n        grad_cx_i_contrib = common_factor * (-dx / (active_distances + 1e-10))\n        grad_cy_i_contrib = common_factor * (-dy / (active_distances + 1e-10))\n        grad_r_i_contrib = common_factor * (1)\n\n        # Accumulate contributions for circle i\n        np.add.at(grad_cx_overlap, i_indices, grad_cx_i_contrib)\n        np.add.at(grad_cy_overlap, i_indices, grad_cy_i_contrib)\n        np.add.at(grad_r_overlap, i_indices, grad_r_i_contrib)\n\n        # Gradient contributions for cx_j, cy_j, r_j\n        grad_cx_j_contrib = common_factor * (dx / (active_distances + 1e-10))\n        grad_cy_j_contrib = common_factor * (dy / (active_distances + 1e-10))\n        grad_r_j_contrib = common_factor * (1)\n\n        # Accumulate contributions for circle j\n        np.add.at(grad_cx_overlap, j_indices, grad_cx_j_contrib)\n        np.add.at(grad_cy_overlap, j_indices, grad_cy_j_contrib)\n        np.add.at(grad_r_overlap, j_indices, grad_r_j_contrib)\n\n    grad_obj[0::3] += grad_cx_overlap\n    grad_obj[1::3] += grad_cy_overlap\n    grad_obj[2::3] += grad_r_overlap\n    \n    total_objective = obj_val + penalty_val\n    return total_objective, grad_obj\n\n# --- LP Feasibilization ---\n\ndef lp_feasibilization(centers_fixed, radii_current):\n    \"\"\"\n    Maximizes sum of radii given fixed centers, ensuring feasibility.\n    Updates global best_sum_radii, best_centers, best_radii if a better solution is found.\n    \"\"\"\n    global best_sum_radii, best_centers, best_radii\n\n    N = N_CIRCLES\n    \n    # Objective: Maximize sum(r_i) => Minimize -sum(r_i)\n    c = -np.ones(N)\n\n    # A_ub @ r_lp <= b_ub\n    A_ub = []\n    b_ub = []\n\n    # 1. r_i <= r_i_current (upper bound from L-BFGS-B result)\n    for i in range(N):\n        row = np.zeros(N)\n        row[i] = 1\n        A_ub.append(row)\n        b_ub.append(radii_current[i])\n\n    # 2. Boundary constraints: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    # Subtract TOLERANCE to ensure strict containment\n    for i in range(N):\n        row_x = np.zeros(N)\n        row_x[i] = 1\n        A_ub.append(row_x)\n        b_ub.append(centers_fixed[i, 0] - TOLERANCE)\n\n        row_y = np.zeros(N)\n        row_y[i] = 1\n        A_ub.append(row_y)\n        b_ub.append(centers_fixed[i, 1] - TOLERANCE)\n\n        row_1_minus_x = np.zeros(N)\n        row_1_minus_x[i] = 1\n        A_ub.append(row_1_minus_x)\n        b_ub.append(1 - centers_fixed[i, 0] - TOLERANCE)\n\n        row_1_minus_y = np.zeros(N)\n        row_1_minus_y[i] = 1\n        A_ub.append(row_1_minus_y)\n        b_ub.append(1 - centers_fixed[i, 1] - TOLERANCE)\n\n    # 3. Overlap constraints: r_i + r_j <= dist_ij - TOLERANCE\n    distances = cdist(centers_fixed, centers_fixed)\n    for i in range(N):\n        for j in range(i + 1, N):\n            row_overlap = np.zeros(N)\n            row_overlap[i] = 1\n            row_overlap[j] = 1\n            A_ub.append(row_overlap)\n            b_ub.append(distances[i, j] - TOLERANCE)\n\n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n\n    # Bounds for radii: r_i >= 0\n    r_bounds = [(0, None)] * N # (lower_bound, upper_bound)\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=r_bounds, method='highs')\n\n    if res.success:\n        final_radii = res.x\n        final_sum_radii = np.sum(final_radii)\n        \n        if final_sum_radii > best_sum_radii:\n            best_sum_radii = final_sum_radii\n            best_centers = centers_fixed.copy()\n            best_radii = final_radii.copy()\n        return final_sum_radii, final_radii\n    else:\n        return -np.inf, None\n\n# --- Basin-hopping callback ---\n\nclass BasinHoppingCallback:\n    \"\"\"\n    Callback function for basin-hopping.\n    Called after each local minimization.\n    \"\"\"\n    def __call__(self, x_local_min, f_local_min, accepted):\n        # x_local_min is the result of the local minimizer\n        centers, radii = _get_centers_radii(x_local_min)\n        \n        # Ensure radii are non-negative before LP (L-BFGS-B bounds should help, but safeguard)\n        radii_clamped = np.maximum(radii, 0)\n\n        # Apply LP feasibilization and update global best result\n        lp_feasibilization(centers, radii_clamped)\n        \n        # Return False to stop basin-hopping early if needed (not used here)\n        return False\n\n# --- Initial Guess Generation ---\n\ndef generate_initial_guess(seed, strategy_type):\n    \"\"\"\n    Generates an initial configuration of centers and radii based on a strategy.\n    \"\"\"\n    np.random.seed(seed)\n    \n    initial_x_flat = np.zeros(N_CIRCLES * 3)\n\n    if strategy_type == \"grid\":\n        # For N=26, a 5x5 grid + 1 extra circle\n        num_rows = 5\n        num_cols = 5\n        \n        x_coords = np.linspace(0.15, 0.85, num_cols)\n        y_coords = np.linspace(0.15, 0.85, num_rows)\n        \n        centers = []\n        for y in y_coords:\n            for x in x_coords:\n                centers.append([x, y])\n        \n        # Add one more center, e.g., in the middle\n        centers.append([0.5, 0.5]) \n        centers = np.array(centers[:N_CIRCLES]) # Take exactly N_CIRCLES\n        \n        # Perturb slightly\n        centers += np.random.uniform(-0.02, 0.02, centers.shape)\n        centers = np.clip(centers, 0.05, 0.95) # Keep within bounds\n        \n        initial_r = 0.5 / np.sqrt(N_CIRCLES) * 0.8 # Initial radius\n        radii = np.full(N_CIRCLES, initial_r)\n        \n        initial_x_flat[0::3] = centers[:, 0]\n        initial_x_flat[1::3] = centers[:, 1]\n        initial_x_flat[2::3] = radii\n\n    elif strategy_type == \"hexagonal\":\n        # Approximate hexagonal packing\n        centers = []\n        r_hex_approx = 0.5 / np.sqrt(N_CIRCLES)\n        \n        # Central circle\n        centers.append([0.5, 0.5])\n        \n        # Layers around it\n        # Distance between centers of adjacent circles in a perfect hex grid\n        layer_dist_unit = 2 * r_hex_approx * np.sqrt(3)/2 \n        \n        # Generate points for up to 3 layers (1+6+12+18 = 37 points)\n        for layer in range(1, 4): \n            current_layer_dist = layer * layer_dist_unit * 1.1 # Slightly larger spacing\n            num_in_layer = 6 * layer\n            for i in range(num_in_layer):\n                angle = 2 * np.pi * i / num_in_layer\n                cx = 0.5 + current_layer_dist * np.cos(angle)\n                cy = 0.5 + current_layer_dist * np.sin(angle)\n                centers.append([cx, cy])\n        \n        centers = np.array(centers)\n        \n        # Select N_CIRCLES centers, prioritizing those closer to the center\n        if len(centers) > N_CIRCLES:\n            distances_from_center = np.linalg.norm(centers - 0.5, axis=1)\n            sorted_indices = np.argsort(distances_from_center)\n            centers = centers[sorted_indices[:N_CIRCLES]]\n        elif len(centers) < N_CIRCLES:\n            # If not enough points, fill remaining with random ones\n            remaining = N_CIRCLES - len(centers)\n            random_centers = np.random.uniform(0.1, 0.9, (remaining, 2))\n            centers = np.vstack([centers, random_centers])\n\n        centers += np.random.uniform(-0.02, 0.02, centers.shape)\n        centers = np.clip(centers, 0.05, 0.95)\n\n        initial_r = 0.5 / np.sqrt(N_CIRCLES) * 0.8\n        radii = np.full(N_CIRCLES, initial_r)\n        \n        initial_x_flat[0::3] = centers[:, 0]\n        initial_x_flat[1::3] = centers[:, 1]\n        initial_x_flat[2::3] = radii\n\n    elif strategy_type == \"random\":\n        initial_x_flat[0::3] = np.random.uniform(0.1, 0.9, N_CIRCLES)\n        initial_x_flat[1::3] = np.random.uniform(0.1, 0.9, N_CIRCLES)\n        initial_x_flat[2::3] = np.random.uniform(0.01, 0.05, N_CIRCLES) # Small radii\n\n    elif strategy_type == \"clustered\":\n        # All circles initially near the center\n        initial_x_flat[0::3] = np.random.uniform(0.4, 0.6, N_CIRCLES)\n        initial_x_flat[1::3] = np.random.uniform(0.4, 0.6, N_CIRCLES)\n        initial_x_flat[2::3] = np.random.uniform(0.01, 0.05, N_CIRCLES) # Small radii\n    \n    return initial_x_flat\n\n# --- Main Packing Function ---\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 non-overlapping circles into a unit square\n    to maximize the sum of their radii.\n    \"\"\"\n    global best_sum_radii, best_centers, best_radii\n    \n    # Reset global bests for a fresh run\n    best_sum_radii = -np.inf\n    best_centers = None\n    best_radii = None\n\n    # Bounds for L-BFGS-B: (min_val, max_val) for each variable\n    # cx, cy in [0, 1], r in [0, 0.5] (max possible radius for a circle in unit square)\n    bounds = [(0, 1), (0, 1), (0, 0.5)] * N_CIRCLES\n\n    # Minimizer arguments for L-BFGS-B\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"jac\": True,  # We provide the gradient\n        \"bounds\": bounds,\n        \"options\": {\"maxiter\": 1000, \"ftol\": 1e-7, \"gtol\": 1e-5} # Tuned options for L-BFGS-B\n    }\n\n    # Deterministic seeds for initial guesses and basin-hopping\n    initial_guess_seeds = [42, 123, 789, 555]\n    strategy_types = [\"grid\", \"hexagonal\", \"random\", \"clustered\"]\n\n    for i in range(N_STARTS):\n        seed = initial_guess_seeds[i]\n        strategy = strategy_types[i % len(strategy_types)] # Cycle through strategies\n        \n        initial_x = generate_initial_guess(seed, strategy)\n        \n        # Ensure initial radii are positive (L-BFGS-B bounds also enforce this)\n        initial_x[2::3] = np.maximum(initial_x[2::3], 1e-6)\n\n        # Basin-hopping\n        # Use a deterministic seed for basin-hopping's internal random perturbations\n        # Add offsets to seeds to ensure distinct random sequences for different starts\n        np.random.seed(seed + 1000) \n        \n        # Create a callback instance for this run\n        bh_callback = BasinHoppingCallback()\n\n        basinhopping(\n            func=objective_and_gradient,\n            x0=initial_x,\n            niter=N_HOPS_PER_START,\n            T=BH_TEMP,\n            stepsize=BH_STEP_SIZE,\n            minimizer_kwargs=minimizer_kwargs,\n            callback=bh_callback,\n            seed=seed + 2000 # Seed for basinhopping's internal random generator\n        )\n        \n        # The `best_sum_radii` global variable is updated by the callback\n        # after each local minimization, so no explicit action needed here.\n        \n    return best_centers, best_radii, best_sum_radii\n\n# --- For internal testing (optional) ---\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Final sum of radii: {sum_radii:.6f}\")\n    \n    # Basic validation\n    if centers is None or radii is None:\n        print(\"No valid packing found.\")\n        return centers, radii, sum_radii\n\n    N = len(radii)\n    print(f\"Number of circles: {N}\")\n\n    # 1. Check if all circles are within the unit square\n    min_x = centers[:, 0] - radii\n    max_x = centers[:, 0] + radii\n    min_y = centers[:, 1] - radii\n    max_y = centers[:, 1] + radii\n\n    # Allow a small tolerance for boundary checks, consistent with LP\n    boundary_ok = (np.all(min_x >= -TOLERANCE) and np.all(max_x <= 1 + TOLERANCE) and\n                   np.all(min_y >= -TOLERANCE) and np.all(max_y <= 1 + TOLERANCE))\n    if not boundary_ok:\n        print(\"Validation FAILED: Some circles are outside the unit square.\")\n        print(f\"  min_x: {np.min(min_x):.6f}, max_x: {np.max(max_x):.6f}, min_y: {np.min(min_y):.6f}, max_y: {np.max(max_y):.6f}\")\n    else:\n        print(\"Validation PASSED: All circles are within the unit square.\")\n\n    # 2. Check for overlaps\n    distances = cdist(centers, centers)\n    np.fill_diagonal(distances, np.inf) # Ignore self-distance\n\n    radii_sum_matrix = radii[:, np.newaxis] + radii[np.newaxis, :]\n    \n    overlaps = radii_sum_matrix - distances\n    \n    if np.any(overlaps > TOLERANCE):\n        print(\"Validation FAILED: Overlapping circles detected.\")\n        max_overlap = np.max(overlaps)\n        print(f\"  Max overlap: {max_overlap:.6f}\")\n    else:\n        print(\"Validation PASSED: No overlapping circles.\")\n\n    # 3. Check for non-negative radii\n    if np.any(radii < -TOLERANCE):\n        print(\"Validation FAILED: Negative radii detected.\")\n    else:\n        print(\"Validation PASSED: All radii are non-negative.\")\n\n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T01:46:21.365767",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.5-flash",
    "temperature": 0.45,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 795,
        "candidates_token_count": 5983,
        "thoughts_token_count": 19283
      },
      "response_text_len": 17555
    }
  },
  "llm_call_duration_s": 94.86405086598825,
  "eval_duration_s": 12.981501166941598
}