{
  "trial_id": "trial_16_4",
  "generation": 16,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.special import expit, logit\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 non-overlapping circles into the unit square [0,1]^2.\n    Returns (centers, radii, sum_radii)\n      - centers: (26,2) ndarray with coordinates in [0,1]\n      - radii: (26,) ndarray, non-negative\n      - sum_radii: float sum of radii\n\n    Approach:\n      - Optimize centers only in unconstrained z-space via logistic mapping centers = sigmoid(z)\n      - Penalized objective (centers only) encourages pairwise separation and distance from boundaries\n        using smooth vectorized repulsive potentials. Analytic gradients computed and chain-ruled\n        through the sigmoid mapping.\n      - Multi-start optimization (several hex/row patterns) with an annealing schedule on penalty\n        strength. L-BFGS-B optimizes z for each stage.\n      - Final strict LP (no caps) maximizes sum(r) for the returned centers with eps_pair = 1e-6.\n      - If LP fails, fallback attempts use eps=0 then a conservative scaling to guarantee feasibility.\n    \"\"\"\n    np.random.seed(42)\n    N = 26\n\n    # ---------------- Utilities ----------------\n    def _pairwise_diffs_and_dist(centers):\n        # centers: (N,2)\n        diff = centers[:, None, :] - centers[None, :, :]  # (N,N,2)\n        d = np.sqrt(np.sum(diff * diff, axis=2))  # (N,N)\n        return diff, d\n\n    def _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n        assert sum(rows) == N\n        max_cols = max(rows)\n        nrows = len(rows)\n        dx_base = (1.0 - 2 * margin) / (max_cols - 1) if max_cols > 1 else 0.0\n        dy_base = (1.0 - 2 * margin) / (nrows - 1) if nrows > 1 else 0.0\n\n        centers = []\n        rng = np.random.default_rng(seed)\n        for ri, cols in enumerate(rows):\n            y = margin + ri * dy_base if nrows > 1 else 0.5\n            if cols > 1:\n                row_width = (cols - 1) * dx_base\n                startx = 0.5 - row_width / 2.0\n                if ri % 2 == 1:\n                    startx += dx_base / 2.0\n            else:\n                startx = 0.5\n            for k in range(cols):\n                x = startx + (k * dx_base if cols > 1 else 0.0)\n                centers.append([x, y])\n        centers = np.array(centers, dtype=float)\n        jitter = rng.normal(scale=jitter_scale, size=centers.shape)\n        centers = centers + jitter\n        centers = np.clip(centers, 1e-4, 1.0 - 1e-4)\n        return centers\n\n    def _multi_start_inits():\n        patterns = [\n            [6, 5, 6, 5, 4],\n            [6, 5, 5, 5, 5],\n            [5, 6, 5, 5, 5],\n            [6, 6, 6, 4, 4],\n            [7, 6, 6, 7],  # larger rows (will be jitter-clipped)\n            [5, 5, 5, 5, 6],\n            [6, 6, 5, 4, 5]\n        ]\n        params = [\n            (0.03, 0.02),\n            (0.05, 0.03),\n            (0.07, 0.03),\n            (0.045, 0.02)\n        ]\n        inits = []\n        seed = 0\n        for pat in patterns:\n            for (m, j) in params:\n                try:\n                    c = _hex_initial_centers_from_rows(pat, margin=m, jitter_scale=j, seed=seed)\n                    if c.shape[0] == N:\n                        inits.append(c)\n                except Exception:\n                    pass\n                seed += 1\n                if len(inits) >= 10:\n                    return inits\n        # If not enough, fill with repeated canonical pattern with varied jitter\n        while len(inits) < 8:\n            inits.append(_hex_initial_centers_from_rows([6,5,6,5,4], margin=0.05, jitter_scale=0.02, seed=100+len(inits)))\n        return inits\n\n    # ---------------- Penalized objective (centers only) ----------------\n    # We map z (unbounded) to centers via sigmoid: c = expit(z)\n    # Objective (to minimize): P * (w_o * pairwise_repulsion + w_b * boundary_repulsion)\n    # Pairwise repulsion: sum_{i<j} 1 / (d_ij + delta)^{p}\n    # Boundary repulsion: sum_i [ 1/(x_i+delta)^p + 1/(y_i+delta)^p + 1/(1-x_i+delta)^p + 1/(1-y_i+delta)^p ]\n    # Gradients are computed analytically and then chain-ruled by dc/dz = c*(1-c).\n\n    def _objective_and_grad_z(z, P=100.0, w_o=1.0, w_b=1.0, p=2, delta=0.02, delta_b=0.02):\n        # z: (2N,) vector representing unconstrained coordinates; returns (f, grad_z)\n        c = expit(z)  # (2N,) values in (0,1)\n        centers = c.reshape(2, N).T  # shape (N,2) (we expect z arranged [x0..xN-1, y0..yN-1])\n        # Note: ensure we accept either ordering; above we assume first N entries are x then N y.\n        # But in our usage we will arrange z as [x0..xN-1, y0..yN-1] as typical.\n\n        # Pairwise\n        diff, d = _pairwise_diffs_and_dist(centers)  # diff (N,N,2), d (N,N)\n        tiny = 1e-12\n        iu = np.triu_indices(N, 1)\n        dij = d[iu]  # (M,)\n        diffij = diff[iu]  # (M,2)\n        d_safe = np.maximum(dij, tiny)\n        denom = (dij + delta) ** p  # (M,)\n        # pairwise potential\n        pen_o = np.sum(1.0 / denom)\n\n        # gradient wrt centers due to pairwise term\n        # For each pair (i,j): derivative of (d+delta)^{-p} wrt center_i is:\n        # -p * (d+delta)^{-p-1} * (center_i - center_j) / d\n        coeff = -p * (d_safe + delta) ** (-p - 1)  # use d_safe in division\n        # careful: (d_safe + delta) == (dij + delta) but we avoid zero by using d_safe in division.\n        # contribution vector per pair for i is coeff * (center_i - center_j) / d_safe\n        with np.errstate(divide='ignore', invalid='ignore'):\n            invd = 1.0 / d_safe\n            vec = (coeff * invd)[:, None] * diffij  # (M,2), sign such that grad_i += vec, grad_j -= vec\n            # accumulate into gradient arrays\n        grad_centers_pair = np.zeros_like(centers)  # (N,2)\n        np.add.at(grad_centers_pair, iu[0], vec)\n        np.add.at(grad_centers_pair, iu[1], -vec)\n\n        # Boundary penalties\n        x = centers[:, 0]\n        y = centers[:, 1]\n        xb = x + delta_b\n        yb = y + delta_b\n        xb2 = (1.0 - x) + delta_b\n        yb2 = (1.0 - y) + delta_b\n        pen_b_terms = (xb ** (-p)) + (yb ** (-p)) + (xb2 ** (-p)) + (yb2 ** (-p))\n        pen_b = np.sum(pen_b_terms)\n\n        # Gradients wrt centers from boundary terms:\n        # d/dx of xb^{-p} = -p * xb^{-p-1} * d(xb)/dx = -p * xb^{-p-1}\n        grad_x_b = -p * xb ** (-p - 1) + p * xb2 ** (-p - 1)  # second term because derivative of (1-x) is -1, sign flips\n        grad_y_b = -p * yb ** (-p - 1) + p * yb2 ** (-p - 1)\n\n        grad_centers_boundary = np.zeros_like(centers)\n        grad_centers_boundary[:, 0] = grad_x_b\n        grad_centers_boundary[:, 1] = grad_y_b\n\n        # Total center gradient\n        grad_centers = w_o * grad_centers_pair + w_b * grad_centers_boundary\n\n        # Objective scalar\n        f = P * (w_o * pen_o + w_b * pen_b)\n\n        # Chain rule through sigmoid: c' = c*(1-c)\n        c_der = c * (1.0 - c)  # (2N,)\n        # grad_centers flattened in same ordering as z: first x coords then y coords\n        grad_centers_flat = np.concatenate([grad_centers[:, 0], grad_centers[:, 1]])  # (2N,)\n        # d f / d z = P * grad_centers_flat * dc/dz\n        grad_z = P * grad_centers_flat * c_der\n\n        # Return scalar and gradient\n        return float(f), grad_z\n\n    # ---------------- LP to maximize radii for fixed centers ----------------\n    def _lp_maximize_radii(centers, eps_pair=1e-6):\n        # centers: (N,2)\n        Nloc = centers.shape[0]\n        x = centers[:, 0]\n        y = centers[:, 1]\n\n        A_rows = []\n        b_vals = []\n\n        # boundary constraints: r_i <= x_i - eps, r_i <= y_i - eps, r_i <= 1-x_i - eps, r_i <= 1-y_i - eps\n        for i in range(Nloc):\n            e = np.zeros(Nloc)\n            e[i] = 1.0\n            A_rows.append(e.copy()); b_vals.append(x[i] - eps_pair)\n            A_rows.append(e.copy()); b_vals.append(y[i] - eps_pair)\n            A_rows.append(e.copy()); b_vals.append(1.0 - x[i] - eps_pair)\n            A_rows.append(e.copy()); b_vals.append(1.0 - y[i] - eps_pair)\n\n        # pairwise constraints: r_i + r_j <= dist - eps\n        _, d = _pairwise_diffs_and_dist(centers)\n        for i in range(Nloc):\n            for j in range(i + 1, Nloc):\n                e = np.zeros(Nloc)\n                e[i] = 1.0; e[j] = 1.0\n                A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n\n        # bounds for radii\n        bounds = [(0.0, 0.5) for _ in range(Nloc)]\n        c = -np.ones(Nloc)  # minimize -sum(r) -> maximize sum(r)\n\n        if len(A_rows) > 0:\n            A_ub = np.array(A_rows)\n            b_ub = np.array(b_vals)\n        else:\n            A_ub = None\n            b_ub = None\n\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return np.clip(res.x, 0.0, 0.5)\n\n        # Fallback: try with eps=0 to get base solution then scale down to satisfy eps_pair\n        # Build A_ub0\n        A_rows2 = []\n        b_vals2 = []\n        for i in range(Nloc):\n            e = np.zeros(Nloc); e[i] = 1.0\n            A_rows2.append(e.copy()); b_vals2.append(x[i])\n            A_rows2.append(e.copy()); b_vals2.append(y[i])\n            A_rows2.append(e.copy()); b_vals2.append(1.0 - x[i])\n            A_rows2.append(e.copy()); b_vals2.append(1.0 - y[i])\n\n        for i in range(Nloc):\n            for j in range(i + 1, Nloc):\n                e = np.zeros(Nloc); e[i] = 1.0; e[j] = 1.0\n                A_rows2.append(e); b_vals2.append(d[i, j])\n\n        A_ub2 = np.array(A_rows2)\n        b_ub2 = np.array(b_vals2)\n        res2 = linprog(c, A_ub=A_ub2, b_ub=b_ub2, bounds=bounds, method='highs')\n        if not res2.success:\n            # as last resort return zeros\n            return np.zeros(Nloc)\n\n        r_base = np.clip(res2.x, 0.0, 0.5)\n\n        # scale r_base to satisfy eps_pair\n        dmat = d\n        denom_pairs = r_base[:, None] + r_base[None, :]\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio_pairs = np.where(denom_pairs > 1e-12, (dmat - eps_pair) / denom_pairs, np.inf)\n        iu2 = np.triu_indices(Nloc, 1)\n        s_pairs = np.min(ratio_pairs[iu2]) if ratio_pairs[iu2].size > 0 else 1.0\n        if not np.isfinite(s_pairs):\n            s_pairs = 1.0\n        s_pairs = max(0.0, min(1.0, s_pairs))\n\n        # boundary scaling\n        with np.errstate(divide='ignore', invalid='ignore'):\n            s_x_min = np.where(r_base > 1e-12, (x - eps_pair) / r_base, np.inf)\n            s_y_min = np.where(r_base > 1e-12, (y - eps_pair) / r_base, np.inf)\n            s_x_max = np.where(r_base > 1e-12, (1.0 - x - eps_pair) / r_base, np.inf)\n            s_y_max = np.where(r_base > 1e-12, (1.0 - y - eps_pair) / r_base, np.inf)\n        s_boundary = np.min([np.min(s_x_min), np.min(s_y_min), np.min(s_x_max), np.min(s_y_max)])\n        if not np.isfinite(s_boundary):\n            s_boundary = 1.0\n        s_boundary = max(0.0, min(1.0, s_boundary))\n\n        s = min(s_pairs, s_boundary)\n        r = s * r_base\n        return np.clip(r, 0.0, 0.5)\n\n    # ---------------- Verification ----------------\n    def _verify(centers, radii, tol_pair=1e-6):\n        if centers.shape != (N, 2): return False\n        if radii.shape != (N,): return False\n        if np.any(radii < -1e-12): return False\n        x = centers[:, 0]; y = centers[:, 1]\n        # boundary\n        if np.any(x - radii < tol_pair): return False\n        if np.any(y - radii < tol_pair): return False\n        if np.any(x + radii > 1.0 - tol_pair): return False\n        if np.any(y + radii > 1.0 - tol_pair): return False\n        _, d = _pairwise_diffs_and_dist(centers)\n        iu = np.triu_indices(N, 1)\n        lhs = radii[:, None] + radii[None, :]\n        viol = lhs[iu] - d[iu] + tol_pair\n        if np.any(viol > 1e-12):\n            return False\n        return True\n\n    # ---------------- Multi-start optimization ----------------\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n    inits = _multi_start_inits()\n\n    # Annealing schedule for penalty P (increasing)\n    P_schedule = [5.0, 50.0, 300.0, 1500.0, 6000.0]\n    maxiter_stage = [60, 70, 80, 100, 120]\n\n    # We arrange z as [x0..xN-1, y0..yN-1]\n    for init_idx, centers0 in enumerate(inits[:10]):\n        # Convert centers to z initial via logit (clip to avoid infinities)\n        c0 = centers0.copy()\n        c0 = np.clip(c0, 1e-6, 1.0 - 1e-6)\n        z0 = np.concatenate([logit(c0[:, 0]), logit(c0[:, 1])])  # (2N,)\n        # add small gaussian noise in z-space to diversify starts\n        rng = np.random.default_rng(1000 + init_idx)\n        z = z0 + rng.normal(scale=0.5, size=z0.shape)\n\n        # Staged optimization\n        for si, P in enumerate(P_schedule):\n            opts = {'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8}\n            # minimize penalized objective wrt z\n            fun = lambda zz: _objective_and_grad_z(zz, P=P, w_o=1.0, w_b=1.0, p=2, delta=0.02, delta_b=0.02)\n            try:\n                res = minimize(fun=fun, x0=z, method='L-BFGS-B', jac=True, options=opts)\n                z = res.x\n            except Exception:\n                # keep previous z if optimizer fails\n                pass\n\n            # Quick local center-only polish with slightly higher penalty to encourage spacing\n            # (we simply perform a short L-BFGS-B inner run with increased P)\n            try:\n                res2 = minimize(fun=lambda zz: _objective_and_grad_z(zz, P=max(P * 5.0, 200.0), w_o=1.0, w_b=1.0, p=2, delta=0.02, delta_b=0.02),\n                                x0=z, method='L-BFGS-B', jac=True, options={'maxiter': 30, 'ftol': 1e-12})\n                z = res2.x\n            except Exception:\n                pass\n\n        # After annealing stages, map to centers and run final LP (strict) to get radii\n        centers_candidate = expit(z).reshape(2, N).T\n        centers_candidate = np.clip(centers_candidate, 1e-6, 1.0 - 1e-6)\n        r_lp = _lp_maximize_radii(centers_candidate, eps_pair=1e-6)\n\n        if _verify(centers_candidate, r_lp, tol_pair=1e-6):\n            s = float(np.sum(r_lp))\n            if s > best['sum']:\n                best['centers'] = centers_candidate.copy()\n                best['radii'] = r_lp.copy()\n                best['sum'] = s\n        else:\n            # try fallback: solve LP with eps=0 then scale down slightly to meet eps_pair\n            r0 = _lp_maximize_radii(centers_candidate, eps_pair=0.0)\n            if r0.sum() > 0:\n                # compute scaling needed\n                dmat = _pairwise_diffs_and_dist(centers_candidate)[1]\n                denom_pairs = r0[:, None] + r0[None, :]\n                with np.errstate(divide='ignore', invalid='ignore'):\n                    ratio_pairs = np.where(denom_pairs > 1e-12, (dmat - 1e-6) / denom_pairs, np.inf)\n                iu2 = np.triu_indices(N, 1)\n                s_pairs = np.min(ratio_pairs[iu2]) if ratio_pairs[iu2].size > 0 else 1.0\n                if not np.isfinite(s_pairs):\n                    s_pairs = 1.0\n                s_pairs = max(0.0, min(1.0, s_pairs))\n                # boundary scaling\n                bx = np.minimum.reduce([centers_candidate[:, 0], centers_candidate[:, 1], 1.0 - centers_candidate[:, 0], 1.0 - centers_candidate[:, 1]])\n                with np.errstate(divide='ignore', invalid='ignore'):\n                    scale_b = np.min(np.where(r0 > 1e-12, (bx - 1e-6) / r0, np.inf))\n                if not np.isfinite(scale_b):\n                    scale_b = 1.0\n                scale_b = max(0.0, min(1.0, scale_b))\n                s = min(s_pairs, scale_b)\n                r_try = np.clip(s * r0, 0.0, 0.5)\n                if _verify(centers_candidate, r_try, tol_pair=1e-6):\n                    ssum = float(np.sum(r_try))\n                    if ssum > best['sum']:\n                        best['centers'] = centers_candidate.copy()\n                        best['radii'] = r_try.copy()\n                        best['sum'] = ssum\n\n    # If no valid solution from multi-starts, fallback to a deterministic hex layout and LP\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6, 5, 6, 5, 4], margin=0.06, jitter_scale=0.02, seed=123)\n        centers_fb = np.clip(centers_fb, 1e-6, 1.0 - 1e-6)\n        r_fb = _lp_maximize_radii(centers_fb, eps_pair=1e-6)\n        if not _verify(centers_fb, r_fb, tol_pair=1e-6):\n            # try scaling down a bit\n            r_fb = 0.95 * r_fb\n        best['centers'] = centers_fb\n        best['radii'] = np.clip(r_fb, 0.0, 0.5)\n        best['sum'] = float(np.sum(best['radii']))\n\n    # Final strict LP hardening with slightly stricter epsilon\n    radii_strict = _lp_maximize_radii(best['centers'], eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        final_radii = radii_strict\n    else:\n        final_radii = best['radii']\n        # Last resort: if still infeasible, compute conservative uniform scaling\n        if not _verify(best['centers'], final_radii, tol_pair=1e-6):\n            dmat = _pairwise_diffs_and_dist(best['centers'])[1]\n            denom = final_radii[:, None] + final_radii[None, :]\n            with np.errstate(divide='ignore', invalid='ignore'):\n                ratio_pairs = np.where(denom > 1e-12, (dmat - 1e-6) / denom, np.inf)\n            iu = np.triu_indices(N, 1)\n            s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n            if not np.isfinite(s_pairs):\n                s_pairs = 1.0\n            s_pairs = max(0.0, min(1.0, s_pairs))\n            bx = np.minimum.reduce([best['centers'][:, 0], best['centers'][:, 1], 1.0 - best['centers'][:, 0], 1.0 - best['centers'][:, 1]])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                scale_b = np.min(np.where(final_radii > 1e-12, (bx - 1e-6) / final_radii, np.inf))\n            if not np.isfinite(scale_b):\n                scale_b = 1.0\n            scale_b = max(0.0, min(1.0, scale_b))\n            s_final = min(s_pairs, scale_b)\n            final_radii = np.clip(s_final * final_radii, 0.0, 0.5)\n\n    centers_out = best['centers'].astype(float)\n    radii_out = np.clip(final_radii.astype(float), 0.0, 0.5)\n    sum_radii = float(np.sum(radii_out))\n\n    # Final verification: if infeasible, shrink uniformly slightly until feasible (very small loop)\n    if not _verify(centers_out, radii_out, tol_pair=1e-6):\n        factor = 0.999\n        for _ in range(5000):\n            radii_out = radii_out * factor\n            if _verify(centers_out, radii_out, tol_pair=1e-6):\n                break\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\n\n# Optional helper to run directly\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.315756069552332,
    "eval_time": 0.5482425689697266,
    "error": null
  },
  "prompt": "\nImplement an unconstrained reparameterization:\n- Variables z -> centers via sigmoid/tanh mapping to [0,1]^2. Optimize only centers; radii obtained from final LP.\n- Penalized objective on centers only: smooth pairwise overlaps + boundary hinge; analytic vectorized gradients; eps only in divisions.\n- Multi-start in z-space; L-BFGS-B on z with penalty annealing; 6-10 starts.\n- Final: strict LP maximize (no caps) to get radii and return feasible result.\n\nReference good implementations:\n# trial_10_2 (score=2.635919655314255)\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.optimize import linprog\n\ndef _pairwise_distances(centers):\n    \"\"\"\n    Calculates pairwise Euclidean distances between centers.\n    Returns distance matrix, and matrices of dx and dy.\n    \"\"\"\n    diff = centers[:, None, :] - centers[None, :, :]\n    d = np.sqrt(np.sum(diff**2, axis=2))\n    return d, diff[..., 0], diff[..., 1]\n\ndef _objective_and_grad(z, N, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective function and its gradient for joint optimization of centers (x,y) and radii (r).\n    z = [x_0..x_N-1, y_0..y_N-1, r_0..r_N-1]\n    Objective: -sum(r) + P * (w_b * boundary_penalty + w_o * overlap_penalty)\n    Penalties are squared hinge functions.\n    \"\"\"\n    x = z[:N]\n    y = z[N:2*N]\n    r = z[2*N:]\n    tiny = 1e-12 # Small value to prevent division by zero\n\n    # Boundary penalties: hinges for r - x, r - y, r + x - 1, r + y - 1\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap penalties: hinges for r_i + r_j - d_ij\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1) # Upper triangle indices for unique pairs (i, j where i < j)\n    dab = d[iu] # Distances for unique pairs\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny) # Use tiny to prevent division by zero in gradients\n    hij = r[iu[0]] + r[iu[1]] - dab # Overlap amount for each pair\n    hpos = np.maximum(0.0, hij) # Positive part of overlap (hinge)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    # Total objective function value\n    f = -np.sum(r) + P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients for boundary penalties\n    dr_b = h1 + h2 + h3 + h4\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n\n    # Overlap gradients (accumulate with np.add.at for efficiency)\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    dr_o = np.zeros(N, dtype=float)\n\n    # Gradient contribution for centers (x, y)\n    # For a pair (a, b), the force on 'a' is in direction (c_b - c_a), force on 'b' is (c_a - c_b)\n    # grad_x_a += -h * (dxab/d), grad_x_b += +h * (dxab/d)\n    coeff = hpos / d_safe # h / d\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx) # For circle i\n    np.add.at(dx_o, iu[1], +cx) # For circle j\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n    \n    # Gradient contribution for radii (r)\n    # grad_r_a += h, grad_r_b += h\n    np.add.at(dr_o, iu[0], hpos)\n    np.add.at(dr_o, iu[1], hpos)\n\n    # Combine all gradients\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    dr_total = -1.0 + P * (w_b * dr_b + w_o * dr_o) # -1.0 from -sum(r)\n\n    grad = np.concatenate([dx_total, dy_total, dr_total])\n    return f, grad\n\ndef _objective_centers_only(z_xy, r_fixed, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective function and its gradient for optimizing centers (x,y) only, with fixed radii.\n    z_xy = [x_0..x_N-1, y_0..y_N-1]\n    Objective: P * (w_b * boundary_penalty + w_o * overlap_penalty)\n    \"\"\"\n    N = r_fixed.shape[0]\n    x = z_xy[:N]\n    y = z_xy[N:2*N]\n    r = r_fixed\n    tiny = 1e-12\n\n    # Boundary hinges\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap hinges\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    f = P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients wrt x,y only\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    coeff = hpos / d_safe\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx)\n    np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    g = np.concatenate([dx_total, dy_total])\n    return f, g\n\ndef _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n    \"\"\"\n    Maximizes sum(r) for given centers using linear programming, ensuring feasibility.\n    Constraints:\n      r_i >= 0\n      r_i <= r_max[i] (if provided)\n      r_i <= x_i - eps_pair, r_i <= y_i - eps_pair, r_i <= 1-x_i - eps_pair, r_i <= 1-y_i - eps_pair\n      r_i + r_j <= dist(c_i,c_j) - eps_pair\n    Includes a retry mechanism if the initial LP with eps_pair is infeasible.\n    \"\"\"\n    N = centers.shape[0]\n    x = centers[:, 0]\n    y = centers[:, 1]\n\n    A_rows = []\n    b_vals = []\n\n    # Boundary constraints: r_i <= c_k - eps_pair\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows.append(e.copy()); b_vals.append(x[i] - eps_pair)\n        A_rows.append(e.copy()); b_vals.append(y[i] - eps_pair)\n        A_rows.append(e.copy()); b_vals.append(1.0 - x[i] - eps_pair)\n        A_rows.append(e.copy()); b_vals.append(1.0 - y[i] - eps_pair)\n\n    # Pairwise overlap constraints: r_i + r_j <= dist(c_i,c_j) - eps_pair\n    d, _, _ = _pairwise_distances(centers)\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n\n    # Optional upper bounds r_i <= r_max[i]\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows.append(e); b_vals.append(r_max[i])\n\n    A_ub = np.array(A_rows)\n    b_ub = np.array(b_vals)\n\n    # Radii bounds: [0, 0.5] (max possible radius in unit square)\n    bounds = [(0.0, 0.5) for _ in range(N)]\n    c = -np.ones(N) # Objective for linprog is to minimize c.T @ x, so -sum(r) means maximize sum(r)\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    if res.success:\n        return np.clip(res.x, 0.0, 0.5)\n\n    # Fallback: If LP with eps_pair is infeasible, try with eps_pair = 0 to get a base solution,\n    # then scale radii down to satisfy the eps_pair.\n    b_vals2 = []\n    A_rows2 = []\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows2.append(e.copy()); b_vals2.append(x[i])\n        A_rows2.append(e.copy()); b_vals2.append(y[i])\n        A_rows2.append(e.copy()); b_vals2.append(1.0 - x[i])\n        A_rows2.append(e.copy()); b_vals2.append(1.0 - y[i])\n\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows2.append(e); b_vals2.append(d[i, j])\n\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows2.append(e); b_vals2.append(r_max[i])\n\n    A_ub2 = np.array(A_rows2)\n    b_ub2 = np.array(b_vals2)\n\n    res2 = linprog(c, A_ub=A_ub2, b_ub=b_ub2, bounds=bounds, method='highs')\n    if not res2.success:\n        return np.zeros(N) # If even without epsilon, no solution, return zero radii\n\n    r_base = np.clip(res2.x, 0.0, 0.5)\n    \n    # Scale r_base to satisfy eps_pair for both pairwise and boundary constraints\n    d, _, _ = _pairwise_distances(centers)\n    \n    # Scaling factor for pairwise overlaps: s * (r_i + r_j) <= d_ij - eps_pair\n    denom_pairs = r_base[:, None] + r_base[None, :]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        ratio_pairs = np.where(denom_pairs > 1e-9, (d - eps_pair) / denom_pairs, np.inf)\n    iu = np.triu_indices(N, 1)\n    s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n    if not np.isfinite(s_pairs): s_pairs = 1.0\n    s_pairs = max(0.0, min(1.0, s_pairs))\n\n    # Scaling factor for boundary constraints: s * r_i <= c_k - eps_pair\n    with np.errstate(divide='ignore', invalid='ignore'):\n        s_boundary_x_min = np.where(r_base > 1e-9, (x - eps_pair) / r_base, np.inf)\n        s_boundary_y_min = np.where(r_base > 1e-9, (y - eps_pair) / r_base, np.inf)\n        s_boundary_x_max = np.where(r_base > 1e-9, (1.0 - x - eps_pair) / r_base, np.inf)\n        s_boundary_y_max = np.where(r_base > 1e-9, (1.0 - y - eps_pair) / r_base, np.inf)\n\n    s_boundary = np.min([s_boundary_x_min, s_boundary_y_min, s_boundary_x_max, s_boundary_y_max])\n    if not np.isfinite(s_boundary): s_boundary = 1.0\n    s_boundary = max(0.0, min(1.0, s_boundary))\n\n    s = min(s_pairs, s_boundary)\n    r = s * r_base\n    return np.clip(r, 0.0, 0.5)\n\ndef _verify(centers, radii, tol_pair=1e-6):\n    \"\"\"\n    Verifies if a given packing is strictly feasible within the unit square\n    and without overlaps, considering a tolerance.\n    \"\"\"\n    N = len(radii)\n    x = centers[:, 0]\n    y = centers[:, 1]\n    \n    if centers.shape != (N, 2): return False\n    if np.any(radii < -1e-12): return False # Radii must be non-negative\n\n    # Check boundary constraints: r_i <= c_k - tol_pair\n    if np.any(x - radii < tol_pair): return False # x_i - r_i >= tol_pair\n    if np.any(y - radii < tol_pair): return False # y_i - r_i >= tol_pair\n    if np.any(x + radii > 1.0 - tol_pair): return False # x_i + r_i <= 1 - tol_pair\n    if np.any(y + radii > 1.0 - tol_pair): return False # y_i + r_i <= 1 - tol_pair\n    \n    # Check pairwise overlap constraints: r_i + r_j <= dist(c_i,c_j) - tol_pair\n    d, _, _ = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    lhs = radii[:, None] + radii[None, :]\n    viol = lhs[iu] - d[iu] + tol_pair # Should be <= 0 for no overlap\n    if np.any(viol > 1e-12): return False # Allow a tiny buffer for float precision\n    \n    return True\n\ndef _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n    \"\"\"\n    Generates initial centers in a hexagonal-like grid pattern.\n    Rows is a list of circle counts per row, e.g., [6,5,6,5,4].\n    \"\"\"\n    assert sum(rows) == 26\n    max_cols = max(rows)\n    nrows = len(rows)\n    \n    # Calculate base spacing based on max columns and rows\n    dx_base = (1.0 - 2*margin) / (max_cols - 1) if max_cols > 1 else 0.0\n    dy_base = (1.0 - 2*margin) / (nrows - 1) if nrows > 1 else 0.0\n\n    centers = []\n    rng = np.random.default_rng(seed)\n    for ri, cols in enumerate(rows):\n        y = margin + ri * dy_base if nrows > 1 else 0.5\n        \n        # Calculate starting x to center the row, applying hex offset for alternating rows\n        if cols > 1:\n            row_width = (cols - 1) * dx_base\n            startx = 0.5 - row_width / 2.0\n            if ri % 2 == 1: # Apply hex offset\n                startx += dx_base / 2.0\n        else: # Single circle in row, center it\n            startx = 0.5\n\n        for k in range(cols):\n            x = startx + (k * dx_base if cols > 1 else 0.0)\n            centers.append([x, y])\n    centers = np.array(centers)\n    \n    # Add jitter and clip to ensure centers are within bounds\n    jitter = rng.normal(scale=jitter_scale, size=centers.shape)\n    centers = centers + jitter\n    centers = np.clip(centers, 1e-3, 1 - 1e-3) # Keep centers slightly away from boundary\n    return centers\n\ndef _multi_start_inits(N):\n    \"\"\"\n    Generates a list of diverse initial center configurations using various\n    hexagonal patterns, margins, and jitter scales.\n    \"\"\"\n    # A selected subset of diverse patterns and parameters for N=26\n    patterns = [\n        [6, 5, 6, 5, 4], # 5 rows\n        [6, 5, 5, 5, 5],\n        [5, 6, 5, 5, 5],\n        [7, 6, 6, 7],   # 4 rows\n        [6, 7, 6, 7],\n        [5, 5, 5, 5, 6], # 5 rows, different distribution\n        [6, 6, 6, 4, 4],\n    ]\n    params = [\n        (0.03, 0.02), (0.05, 0.03), (0.07, 0.03), (0.045, 0.02)\n    ]\n    inits = []\n    seed = 0\n    for pat in patterns:\n        for (m, j) in params:\n            inits.append(_hex_initial_centers_from_rows(pat, margin=m, jitter_scale=j, seed=seed))\n            seed += 1\n    return inits\n\ndef _center_only_relax(centers, r_fixed, P=2000.0, w_b=1.0, w_o=1.0, iters=80):\n    \"\"\"\n    Performs a short optimization run on centers only, with fixed radii,\n    to relax the configuration and potentially open up space.\n    \"\"\"\n    N = centers.shape[0]\n    z0 = np.concatenate([centers[:, 0], centers[:, 1]])\n    bounds_xy = [(0.0, 1.0)] * (2 * N) # Centers must stay within [0,1]\n    res = minimize(\n        fun=lambda zz: _objective_centers_only(zz, r_fixed, P, w_b, w_o),\n        x0=z0,\n        method='L-BFGS-B',\n        jac=True,\n        bounds=bounds_xy,\n        options={'maxiter': iters, 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 20}\n    )\n    z = res.x\n    centers_new = np.stack([z[:N], z[N:2*N]], axis=1)\n    return centers_new\n\ndef construct_packing():\n    N = 26\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n\n    # Penalty annealing schedule and max iterations per stage\n    P_schedule = [10.0, 100.0, 1000.0, 5000.0, 20000.0, 50000.0] # Increasing penalty\n    maxiter_stage = [70, 80, 90, 100, 110, 120] # Iterations per stage\n    \n    # Bounds for x, y, r. Radii must be non-negative and max 0.5.\n    bounds = [(0.0, 1.0)] * (2*N) + [(0.0, 0.5)] * N \n\n    w_b = 1.0 # Weight for boundary penalty\n    w_o = 1.0 # Weight for overlap penalty\n\n    selected_inits = _multi_start_inits(N)\n    \n    # Fallback if selected_inits is empty (shouldn't happen with the above logic)\n    if not selected_inits:\n        selected_inits = [_hex_initial_centers_from_rows([6,5,6,5,4], margin=0.05, jitter_scale=0.03, seed=42)]\n\n\n    for init_idx, centers0 in enumerate(selected_inits):\n        x0 = centers0[:, 0]\n        y0 = centers0[:, 1]\n        # Initialize radii to a small value, respecting boundary constraints\n        base_bound = np.minimum.reduce([x0, y0, 1 - x0, 1 - y0])\n        r0 = 0.05 * base_bound # Start with small radii\n        z = np.concatenate([x0, y0, r0])\n\n        # Annealing optimization loop\n        for si, P in enumerate(P_schedule):\n            # Stage 1: Joint optimization of (x, y, r) using penalty method\n            res = minimize(\n                fun=lambda zz: _objective_and_grad(zz, N, P, w_b, w_o),\n                x0=z,\n                method='L-BFGS-B',\n                jac=True,\n                bounds=bounds,\n                options={'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 30}\n            )\n            z = res.x\n            centers_tmp = np.stack([z[:N], z[N:2*N]], axis=1)\n            r_cur = np.clip(z[2*N:], 0.0, 0.5)\n            \n            # Stage 2: LP Feasibilization with a radius cap\n            # The cap prevents radii from growing too aggressively too early, allowing centers to adjust.\n            cap_factor = 1.05 if si < len(P_schedule) - 1 else 1.10 # Slightly smaller cap factor\n            r_cap = np.minimum(0.5, cap_factor * np.maximum(1e-9, r_cur))\n            r_lp = _lp_feasibilize(centers_tmp, r_max=r_cap, eps_pair=1e-6)\n            \n            # Stage 3: Center-only relaxation\n            # Move centers slightly with fixed (LP-derived) radii to open up space.\n            centers_relaxed = _center_only_relax(centers_tmp, r_lp, P=max(1000.0, P), w_b=w_b, w_o=w_o, iters=70)\n            \n            # Stage 4: Final LP for this stage (no cap)\n            # Maximize radii again for the relaxed centers.\n            r_lp2 = _lp_feasibilize(centers_relaxed, r_max=None, eps_pair=1e-6)\n            \n            # Update the state (z) for the next annealing stage\n            z = np.concatenate([centers_relaxed[:, 0], centers_relaxed[:, 1], np.clip(r_lp2, 0.0, 0.5)])\n\n        # After all annealing stages, perform a final LP to get the best possible radii\n        centers_final_opt = np.stack([z[:N], z[N:2*N]], axis=1)\n        r_final = _lp_feasibilize(centers_final_opt, r_max=None, eps_pair=1e-6)\n\n        # Verify the solution and update the best found packing\n        if _verify(centers_final_opt, r_final, tol_pair=1e-6):\n            s = float(np.sum(r_final))\n            if s > best['sum']:\n                best['centers'] = centers_final_opt.copy()\n                best['radii'] = r_final.copy()\n                best['sum'] = s\n        else:\n            # If the solution is not strictly feasible, try to scale down radii\n            # to achieve feasibility. This is a \"hardening\" step.\n            d, _, _ = _pairwise_distances(centers_final_opt)\n            \n            # Calculate scaling factor for pairwise overlaps\n            denom_pairs = r_final[:, None] + r_final[None, :]\n            with np.errstate(divide='ignore', invalid='ignore'):\n                ratio_pairs = np.where(denom_pairs > 1e-9, (d - 1.0e-6) / denom_pairs, np.inf)\n            iu = np.triu_indices(N, 1)\n            s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n            if not np.isfinite(s_pairs): s_pairs = 1.0\n            s_pairs = max(0.0, min(1.0, s_pairs))\n\n            # Calculate scaling factor for boundary constraints\n            bx = np.minimum.reduce([centers_final_opt[:,0], centers_final_opt[:,1], 1-centers_final_opt[:,0], 1-centers_final_opt[:,1]])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                scale_b = np.min(np.where(r_final > 1e-9, (bx - 1e-6) / r_final, np.inf))\n            scale_b = min(1.0, scale_b if np.isfinite(scale_b) else 1.0)\n            scale_b = max(0.0, scale_b)\n\n            r_try = min(s_pairs, scale_b) * r_final\n            \n            if _verify(centers_final_opt, r_try, tol_pair=1e-6):\n                s = float(np.sum(r_try))\n                if s > best['sum']:\n                    best['centers'] = centers_final_opt.copy()\n                    best['radii'] = r_try.copy()\n                    best['sum'] = s\n\n    # Fallback mechanism: if no valid solution was found after all multi-starts,\n    # generate a simple hexagonal pattern and run LP on it.\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        r_fb = _lp_feasibilize(centers_fb, r_max=None, eps_pair=1e-6)\n        # If still not feasible, shrink a bit more\n        if not _verify(centers_fb, r_fb, tol_pair=1e-6):\n            r_fb = 0.95 * r_fb \n        best['centers'] = centers_fb\n        best['radii'] = np.clip(r_fb, 0.0, 0.5)\n        best['sum'] = float(np.sum(best['radii']))\n\n    # Final hardening step to guarantee strict feasibility for the returned solution.\n    # Re-run LP with a slightly stricter epsilon.\n    radii_strict = _lp_feasibilize(best['centers'], r_max=None, eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        radii = radii_strict\n    else:\n        # If stricter LP fails, use the best found radii and apply a final scaling if needed.\n        radii = best['radii']\n        if not _verify(best['centers'], radii, tol_pair=1e-6):\n            d, _, _ = _pairwise_distances(best['centers'])\n            \n            denom = radii[:, None] + radii[None, :]\n            with np.errstate(divide='ignore', invalid='ignore'):\n                s_pairs = np.min(np.where(denom > 1e-9, (d - 1e-6) / denom, np.inf)[np.triu_indices(N, 1)])\n            s_pairs = min(1.0, s_pairs if np.isfinite(s_pairs) else 1.0)\n            s_pairs = max(0.0, s_pairs)\n            \n            bx = np.minimum.reduce([best['centers'][:,0], best['centers'][:,1], 1-best['centers'][:,0], 1-best['centers'][:,1]])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                scale_b = np.min(np.where(radii > 1e-9, (bx - 1e-6) / radii, np.inf))\n            scale_b = min(1.0, scale_b if np.isfinite(scale_b) else 1.0)\n            scale_b = max(0.0, scale_b)\n            \n            radii = min(s_pairs, scale_b) * radii\n\n    centers = best['centers']\n    radii = np.clip(radii, 0.0, 0.5) # Final clip to ensure radii are non-negative and within max possible\n    sum_radii = float(np.sum(radii))\n    return centers.astype(float), radii.astype(float), sum_radii\n\n# trial_7_7 (score=2.6358676293444767)\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.optimize import linprog\n\ndef _pairwise_distances(centers):\n    \"\"\"\n    Calculates pairwise Euclidean distances between centers.\n    Returns distance matrix, and matrices of dx and dy.\n    \"\"\"\n    diff = centers[:, None, :] - centers[None, :, :]\n    d = np.sqrt(np.sum(diff**2, axis=2))\n    return d, diff[..., 0], diff[..., 1]\n\ndef _objective_and_grad(z, N, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective function and its gradient for joint optimization of centers (x,y) and radii (r).\n    z = [x_0..x_N-1, y_0..y_N-1, r_0..r_N-1]\n    Objective: -sum(r) + P * (w_b * boundary_penalty + w_o * overlap_penalty)\n    Penalties are squared hinge functions.\n    \"\"\"\n    x = z[:N]\n    y = z[N:2*N]\n    r = z[2*N:]\n    tiny = 1e-12 # Small value to prevent division by zero\n\n    # Boundary penalties: hinges for r - x, r - y, r + x - 1, r + y - 1\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap penalties: hinges for r_i + r_j - d_ij\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1) # Upper triangle indices for unique pairs (i, j where i < j)\n    dab = d[iu] # Distances for unique pairs\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny) # Use tiny to prevent division by zero in gradients\n    hij = r[iu[0]] + r[iu[1]] - dab # Overlap amount for each pair\n    hpos = np.maximum(0.0, hij) # Positive part of overlap (hinge)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    # Total objective function value\n    f = -np.sum(r) + P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients for boundary penalties\n    dr_b = h1 + h2 + h3 + h4\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n\n    # Overlap gradients (accumulate with np.add.at for efficiency)\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    dr_o = np.zeros(N, dtype=float)\n\n    # Gradient contribution for centers (x, y)\n    # For a pair (a, b), the force on 'a' is in direction (c_b - c_a), force on 'b' is (c_a - c_b)\n    # grad_x_a += -h * (dxab/d), grad_x_b += +h * (dxab/d)\n    coeff = hpos / d_safe # h / d\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx) # For circle i\n    np.add.at(dx_o, iu[1], +cx) # For circle j\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n    \n    # Gradient contribution for radii (r)\n    # grad_r_a += h, grad_r_b += h\n    np.add.at(dr_o, iu[0], hpos)\n    np.add.at(dr_o, iu[1], hpos)\n\n    # Combine all gradients\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    dr_total = -1.0 + P * (w_b * dr_b + w_o * dr_o) # -1.0 from -sum(r)\n\n    grad = np.concatenate([dx_total, dy_total, dr_total])\n    return f, grad\n\ndef _objective_centers_only(z_xy, r_fixed, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective function and its gradient for optimizing centers (x,y) only, with fixed radii.\n    z_xy = [x_0..x_N-1, y_0..y_N-1]\n    Objective: P * (w_b * boundary_penalty + w_o * overlap_penalty)\n    \"\"\"\n    N = r_fixed.shape[0]\n    x = z_xy[:N]\n    y = z_xy[N:2*N]\n    r = r_fixed\n    tiny = 1e-12\n\n    # Boundary hinges\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap hinges\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    f = P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients wrt x,y only\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    coeff = hpos / d_safe\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx)\n    np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    g = np.concatenate([dx_total, dy_total])\n    return f, g\n\ndef _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n    \"\"\"\n    Maximizes sum(r) for given centers using linear programming, ensuring feasibility.\n    Constraints:\n      r_i >= 0\n      r_i <= r_max[i] (if provided)\n      r_i <= x_i - eps_pair, r_i <= y_i - eps_pair, r_i <= 1-x_i - eps_pair, r_i <= 1-y_i - eps_pair\n      r_i + r_j <= dist(c_i,c_j) - eps_pair\n    Includes a retry mechanism if the initial LP with eps_pair is infeasible.\n    \"\"\"\n    N = centers.shape[0]\n    x = centers[:, 0]\n    y = centers[:, 1]\n\n    A_rows = []\n    b_vals = []\n\n    # Boundary constraints: r_i <= c_k - eps_pair\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows.append(e.copy()); b_vals.append(x[i] - eps_pair)\n        A_rows.append(e.copy()); b_vals.append(y[i] - eps_pair)\n        A_rows.append(e.copy()); b_vals.append(1.0 - x[i] - eps_pair)\n        A_rows.append(e.copy()); b_vals.append(1.0 - y[i] - eps_pair)\n\n    # Pairwise overlap constraints: r_i + r_j <= dist(c_i,c_j) - eps_pair\n    d, _, _ = _pairwise_distances(centers)\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n\n    # Optional upper bounds r_i <= r_max[i]\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows.append(e); b_vals.append(r_max[i])\n\n    A_ub = np.array(A_rows)\n    b_ub = np.array(b_vals)\n\n    # Radii bounds: [0, 0.5] (max possible radius in unit square)\n    bounds = [(0.0, 0.5) for _ in range(N)]\n    c = -np.ones(N) # Objective for linprog is to minimize c.T @ x, so -sum(r) means maximize sum(r)\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    if res.success:\n        return np.clip(res.x, 0.0, 0.5)\n\n    # Fallback: If LP with eps_pair is infeasible, try with eps_pair = 0 to get a base solution,\n    # then scale radii down to satisfy the eps_pair.\n    b_vals2 = []\n    A_rows2 = []\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows2.append(e.copy()); b_vals2.append(x[i])\n        A_rows2.append(e.copy()); b_vals2.append(y[i])\n        A_rows2.append(e.copy()); b_vals2.append(1.0 - x[i])\n        A_rows2.append(e.copy()); b_vals2.append(1.0 - y[i])\n\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows2.append(e); b_vals2.append(d[i, j])\n\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows2.append(e); b_vals2.append(r_max[i])\n\n    A_ub2 = np.array(A_rows2)\n    b_ub2 = np.array(b_vals2)\n\n    res2 = linprog(c, A_ub=A_ub2, b_ub=b_ub2, bounds=bounds, method='highs')\n    if not res2.success:\n        return np.zeros(N) # If even without epsilon, no solution, return zero radii\n\n    r_base = np.clip(res2.x, 0.0, 0.5)\n    \n    # Scale r_base to satisfy eps_pair for both pairwise and boundary constraints\n    d, _, _ = _pairwise_distances(centers)\n    \n    # Scaling factor for pairwise overlaps: s * (r_i + r_j) <= d_ij - eps_pair\n    denom_pairs = r_base[:, None] + r_base[None, :]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        ratio_pairs = np.where(denom_pairs > 1e-9, (d - eps_pair) / denom_pairs, np.inf)\n    iu = np.triu_indices(N, 1)\n    s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n    if not np.isfinite(s_pairs): s_pairs = 1.0\n    s_pairs = max(0.0, min(1.0, s_pairs))\n\n    # Scaling factor for boundary constraints: s * r_i <= c_k - eps_pair\n    with np.errstate(divide='ignore', invalid='ignore'):\n        s_boundary_x_min = np.where(r_base > 1e-9, (x - eps_pair) / r_base, np.inf)\n        s_boundary_y_min = np.where(r_base > 1e-9, (y - eps_pair) / r_base, np.inf)\n        s_boundary_x_max = np.where(r_base > 1e-9, (1.0 - x - eps_pair) / r_base, np.inf)\n        s_boundary_y_max = np.where(r_base > 1e-9, (1.0 - y - eps_pair) / r_base, np.inf)\n\n    s_boundary = np.min([s_boundary_x_min, s_boundary_y_min, s_boundary_x_max, s_boundary_y_max])\n    if not np.isfinite(s_boundary): s_boundary = 1.0\n    s_boundary = max(0.0, min(1.0, s_boundary))\n\n    s = min(s_pairs, s_boundary)\n    r = s * r_base\n    return np.clip(r, 0.0, 0.5)\n\ndef _verify(centers, radii, tol_pair=1e-6):\n    \"\"\"\n    Verifies if a given packing is strictly feasible within the unit square\n    and without overlaps, considering a tolerance.\n    \"\"\"\n    N = len(radii)\n    x = centers[:, 0]\n    y = centers[:, 1]\n    \n    if centers.shape != (N, 2): return False\n    if np.any(radii < -1e-12): return False # Radii must be non-negative\n\n    # Check boundary constraints: r_i <= c_k - tol_pair\n    if np.any(x - radii < tol_pair): return False # x_i - r_i >= tol_pair\n    if np.any(y - radii < tol_pair): return False # y_i - r_i >= tol_pair\n    if np.any(x + radii > 1.0 - tol_pair): return False # x_i + r_i <= 1 - tol_pair\n    if np.any(y + radii > 1.0 - tol_pair): return False # y_i + r_i <= 1 - tol_pair\n    \n    # Check pairwise overlap constraints: r_i + r_j <= dist(c_i,c_j) - tol_pair\n    d, _, _ = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    lhs = radii[:, None] + radii[None, :]\n    viol = lhs[iu] - d[iu] + tol_pair # Should be <= 0 for no overlap\n    if np.any(viol > 1e-12): return False # Allow a tiny buffer for float precision\n    \n    return True\n\ndef _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n    \"\"\"\n    Generates initial centers in a hexagonal-like grid pattern.\n    Rows is a list of circle counts per row, e.g., [6,5,6,5,4].\n    \"\"\"\n    assert sum(rows) == 26\n    max_cols = max(rows)\n    nrows = len(rows)\n    \n    # Calculate base spacing based on max columns and rows\n    dx_base = (1.0 - 2*margin) / (max_cols - 1) if max_cols > 1 else 0.0\n    dy_base = (1.0 - 2*margin) / (nrows - 1) if nrows > 1 else 0.0\n\n    centers = []\n    rng = np.random.default_rng(seed)\n    for ri, cols in enumerate(rows):\n        y = margin + ri * dy_base if nrows > 1 else 0.5\n        \n        # Calculate starting x to center the row, applying hex offset for alternating rows\n        if cols > 1:\n            row_width = (cols - 1) * dx_base\n            startx = 0.5 - row_width / 2.0\n            if ri % 2 == 1: # Apply hex offset\n                startx += dx_base / 2.0\n        else: # Single circle in row, center it\n            startx = 0.5\n\n        for k in range(cols):\n            x = startx + (k * dx_base if cols > 1 else 0.0)\n            centers.append([x, y])\n    centers = np.array(centers)\n    \n    # Add jitter and clip to ensure centers are within bounds\n    jitter = rng.normal(scale=jitter_scale, size=centers.shape)\n    centers = centers + jitter\n    centers = np.clip(centers, 1e-3, 1 - 1e-3) # Keep centers slightly away from boundary\n    return centers\n\ndef _multi_start_inits(N):\n    \"\"\"\n    Generates a list of diverse initial center configurations using various\n    hexagonal patterns, margins, and jitter scales.\n    \"\"\"\n    # Various row patterns summing to 26\n    patterns = [\n        [6, 5, 6, 5, 4], [6, 5, 5, 5, 5], [5, 6, 5, 5, 5],\n        [5, 5, 6, 5, 5], [6, 6, 5, 5, 4], [5, 6, 6, 5, 4],\n        [6, 5, 6, 4, 5], [5, 5, 5, 5, 6], [4, 5, 6, 5, 6],\n        [5, 4, 5, 6, 6], [5, 6, 4, 6, 5],\n    ]\n    # Various margin and jitter scale parameters\n    params = [\n        (0.03, 0.02), (0.04, 0.03), (0.05, 0.03),\n        (0.06, 0.02), (0.07, 0.03), (0.05, 0.04),\n        (0.04, 0.025), (0.055, 0.035), (0.065, 0.025)\n    ]\n    inits = []\n    seed = 0\n    for pat in patterns:\n        for (m, j) in params:\n            inits.append(_hex_initial_centers_from_rows(pat, margin=m, jitter_scale=j, seed=seed))\n            seed += 1\n    return inits\n\ndef _center_only_relax(centers, r_fixed, P=2000.0, w_b=1.0, w_o=1.0, iters=80):\n    \"\"\"\n    Performs a short optimization run on centers only, with fixed radii,\n    to relax the configuration and potentially open up space.\n    \"\"\"\n    N = centers.shape[0]\n    z0 = np.concatenate([centers[:, 0], centers[:, 1]])\n    bounds_xy = [(0.0, 1.0)] * (2 * N) # Centers must stay within [0,1]\n    res = minimize(\n        fun=lambda zz: _objective_centers_only(zz, r_fixed, P, w_b, w_o),\n        x0=z0,\n        method='L-BFGS-B',\n        jac=True,\n        bounds=bounds_xy,\n        options={'maxiter': iters, 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 20}\n    )\n    z = res.x\n    centers_new = np.stack([z[:N], z[N:2*N]], axis=1)\n    return centers_new\n\ndef construct_packing():\n    N = 26\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n\n    # Penalty annealing schedule and max iterations per stage\n    P_schedule = [8.0, 80.0, 800.0, 3000.0, 10000.0, 20000.0] # Increasing penalty\n    maxiter_stage = [90, 100, 110, 120, 130, 140] # Iterations per stage\n    bounds = [(0.0, 1.0)] * (2*N) + [(0.0, 0.5)] * N # Bounds for x, y, r\n\n    w_b = 1.0 # Weight for boundary penalty\n    w_o = 1.0 # Weight for overlap penalty\n\n    # Generate multiple initial configurations\n    inits = _multi_start_inits(N)\n    if not inits: # Fallback if initializations list is empty\n        inits = [_hex_initial_centers_from_rows([6,5,6,5,4], margin=0.05, jitter_scale=0.03, seed=42)]\n\n    for init_idx, centers0 in enumerate(inits):\n        x0 = centers0[:, 0]\n        y0 = centers0[:, 1]\n        # Initialize radii to a small value, respecting boundary constraints\n        base_bound = np.minimum.reduce([x0, y0, 1 - x0, 1 - y0])\n        r0 = 0.05 * base_bound\n        z = np.concatenate([x0, y0, r0])\n\n        # Annealing optimization loop\n        for si, P in enumerate(P_schedule):\n            # Stage 1: Joint optimization of (x, y, r) using penalty method\n            res = minimize(\n                fun=lambda zz: _objective_and_grad(zz, N, P, w_b, w_o),\n                x0=z,\n                method='L-BFGS-B',\n                jac=True,\n                bounds=bounds,\n                options={'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 30}\n            )\n            z = res.x\n            centers_tmp = np.stack([z[:N], z[N:2*N]], axis=1)\n            r_cur = np.clip(z[2*N:], 0.0, 0.5)\n            \n            # Stage 2: LP Feasibilization with a radius cap\n            # The cap prevents radii from growing too aggressively too early, allowing centers to adjust.\n            cap_factor = 1.08 if si < len(P_schedule) - 1 else 1.15\n            r_cap = np.minimum(0.5, cap_factor * np.maximum(1e-9, r_cur))\n            r_lp = _lp_feasibilize(centers_tmp, r_max=r_cap, eps_pair=1e-6)\n            \n            # Stage 3: Center-only relaxation\n            # Move centers slightly with fixed (LP-derived) radii to open up space.\n            centers_relaxed = _center_only_relax(centers_tmp, r_lp, P=max(1000.0, P), w_b=w_b, w_o=w_o, iters=70)\n            \n            # Stage 4: Final LP for this stage (no cap)\n            # Maximize radii again for the relaxed centers.\n            r_lp2 = _lp_feasibilize(centers_relaxed, r_max=None, eps_pair=1e-6)\n            \n            # Update the state (z) for the next annealing stage\n            z = np.concatenate([centers_relaxed[:, 0], centers_relaxed[:, 1], np.clip(r_lp2, 0.0, 0.5)])\n\n        # After all annealing stages, perform a final LP to get the best possible radii\n        centers_final_opt = np.stack([z[:N], z[N:2*N]], axis=1)\n        r_final = _lp_feasibilize(centers_final_opt, r_max=None, eps_pair=1e-6)\n\n        # Verify the solution and update the best found packing\n        if _verify(centers_final_opt, r_final, tol_pair=1e-6):\n            s = float(np.sum(r_final))\n            if s > best['sum']:\n                best['centers'] = centers_final_opt.copy()\n                best['radii'] = r_final.copy()\n                best['sum'] = s\n        else:\n            # If the solution is not strictly feasible, try to scale down radii\n            # to achieve feasibility. This is a \"hardening\" step.\n            d, _, _ = _pairwise_distances(centers_final_opt)\n            denom = r_final[:, None] + r_final[None, :]\n            with np.errstate(divide='ignore', invalid='ignore'):\n                ratio_pairs = np.where(denom > 1e-9, (d - 1.0e-6) / denom, np.inf)\n            iu = np.triu_indices(N, 1)\n            s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n            if not np.isfinite(s_pairs): s_pairs = 1.0\n            s_pairs = max(0.0, min(1.0, s_pairs))\n            \n            bx = np.minimum.reduce([centers_final_opt[:,0], centers_final_opt[:,1], 1-centers_final_opt[:,0], 1-centers_final_opt[:,1]])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                scale_b = np.min(np.where(r_final > 1e-9, (bx - 1e-6) / r_final, 1.0))\n            scale_b = min(1.0, scale_b if np.isfinite(scale_b) else 1.0)\n            scale_b = max(0.0, scale_b)\n\n            r_try = min(s_pairs, scale_b) * r_final\n            \n            if _verify(centers_final_opt, r_try, tol_pair=1e-6):\n                s = float(np.sum(r_try))\n                if s > best['sum']:\n                    best['centers'] = centers_final_opt.copy()\n                    best['radii'] = r_try.copy()\n                    best['sum'] = s\n\n    # Fallback mechanism: if no valid solution was found after all multi-starts,\n    # generate a simple hexagonal pattern and run LP on it.\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        r_fb = _lp_feasibilize(centers_fb, r_max=None, eps_pair=1e-6)\n        if not _verify(centers_fb, r_fb, tol_pair=1e-6):\n            r_fb = 0.95 * r_fb # Shrink a bit more if still not feasible\n        best['centers'] = centers_fb\n        best['radii'] = np.clip(r_fb, 0.0, 0.5)\n        best['sum'] = float(np.sum(best['radii']))\n\n    # Final hardening step to guarantee strict feasibility for the returned solution.\n    # Re-run LP with a slightly stricter epsilon.\n    radii_strict = _lp_feasibilize(best['centers'], r_max=None, eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        radii = radii_strict\n    else:\n        # If stricter LP fails, use the best found radii and apply a final scaling if needed.\n        radii = best['radii']\n        if not _verify(best['centers'], radii, tol_pair=1e-6):\n            d, _, _ = _pairwise_distances(best['centers'])\n            denom = radii[:, None] + radii[None, :]\n            with np.errstate(divide='ignore', invalid='ignore'):\n                ratio_pairs = np.where(denom > 1e-9, (d - 1e-6) / denom, np.inf)\n            iu = np.triu_indices(N, 1)\n            s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n            s_pairs = min(1.0, s_pairs if np.isfinite(s_pairs) else 1.0)\n            s_pairs = max(0.0, s_pairs)\n            \n            bx = np.minimum.reduce([best['centers'][:,0], best['centers'][:,1], 1-best['centers'][:,0], 1-best['centers'][:,1]])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                scale_b = np.min(np.where(radii > 1e-9, (bx - 1e-6) / radii, 1.0))\n            scale_b = min(1.0, scale_b if np.isfinite(scale_b) else 1.0)\n            scale_b = max(0.0, scale_b)\n            \n            radii = min(s_pairs, scale_b) * radii\n\n    centers = best['centers']\n    radii = np.clip(radii, 0.0, 0.5) # Final clip to ensure radii are non-negative and within max possible\n    sum_radii = float(np.sum(radii))\n    return centers.astype(float), radii.astype(float), sum_radii\n\ndef run_packing():\n    \"\"\"\n    Entry point for internal testing or direct execution.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n# trial_10_6 (score=2.6358676293444767)\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.optimize import linprog\n\n# Helper functions provided in the problem description\ndef _pairwise_distances(centers):\n    \"\"\"\n    Calculates pairwise Euclidean distances between centers.\n    Returns distance matrix, and matrices of dx and dy.\n    \"\"\"\n    diff = centers[:, None, :] - centers[None, :, :]\n    d = np.sqrt(np.sum(diff**2, axis=2))\n    return d, diff[..., 0], diff[..., 1]\n\ndef _objective_and_grad(z, N, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective function and its gradient for joint optimization of centers (x,y) and radii (r).\n    z = [x_0..x_N-1, y_0..y_N-1, r_0..r_N-1]\n    Objective: -sum(r) + P * (w_b * boundary_penalty + w_o * overlap_penalty)\n    Penalties are squared hinge functions.\n    \"\"\"\n    x = z[:N]\n    y = z[N:2*N]\n    r = z[2*N:]\n    tiny = 1e-12 # Small value to prevent division by zero\n\n    # Boundary penalties: hinges for r - x, r - y, r + x - 1, r + y - 1\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap penalties: hinges for r_i + r_j - d_ij\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1) # Upper triangle indices for unique pairs (i, j where i < j)\n    dab = d[iu] # Distances for unique pairs\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny) # Use tiny to prevent division by zero in gradients\n    hij = r[iu[0]] + r[iu[1]] - dab # Overlap amount for each pair\n    hpos = np.maximum(0.0, hij) # Positive part of overlap (hinge)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    # Total objective function value\n    f = -np.sum(r) + P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients for boundary penalties\n    dr_b = h1 + h2 + h3 + h4\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n\n    # Overlap gradients (accumulate with np.add.at for efficiency)\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    dr_o = np.zeros(N, dtype=float)\n\n    # Gradient contribution for centers (x, y)\n    coeff = hpos / d_safe # h / d\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx) # For circle i\n    np.add.at(dx_o, iu[1], +cx) # For circle j\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n    \n    # Gradient contribution for radii (r)\n    np.add.at(dr_o, iu[0], hpos)\n    np.add.at(dr_o, iu[1], hpos)\n\n    # Combine all gradients\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    dr_total = -1.0 + P * (w_b * dr_b + w_o * dr_o) # -1.0 from -sum(r)\n\n    grad = np.concatenate([dx_total, dy_total, dr_total])\n    return f, grad\n\ndef _objective_centers_only(z_xy, r_fixed, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective function and its gradient for optimizing centers (x,y) only, with fixed radii.\n    \"\"\"\n    N = r_fixed.shape[0]\n    x = z_xy[:N]\n    y = z_xy[N:2*N]\n    r = r_fixed\n    tiny = 1e-12\n\n    # Boundary hinges\n    s1 = r - x; s2 = r - y; s3 = r + x - 1.0; s4 = r + y - 1.0\n    h1 = np.maximum(0.0, s1); h2 = np.maximum(0.0, s2); h3 = np.maximum(0.0, s3); h4 = np.maximum(0.0, s4)\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap hinges\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]; dxab = dx_mat[iu]; dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    f = P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients wrt x,y only\n    dx_b = -h1 + h3; dy_b = -h2 + h4\n    dx_o = np.zeros(N, dtype=float); dy_o = np.zeros(N, dtype=float)\n    coeff = hpos / d_safe\n    cx = coeff * dxab; cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx); np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy); np.add.at(dy_o, iu[1], +cy)\n\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    g = np.concatenate([dx_total, dy_total])\n    return f, g\n\ndef _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n    \"\"\"\n    Maximizes sum(r) for given centers using linear programming, ensuring feasibility.\n    \"\"\"\n    N = centers.shape[0]\n    x, y = centers[:, 0], centers[:, 1]\n    A_rows, b_vals = [], []\n\n    # Boundary constraints: r_i <= c_k - eps_pair\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows.extend([e.copy(), e.copy(), e.copy(), e.copy()])\n        b_vals.extend([x[i] - eps_pair, y[i] - eps_pair, 1.0 - x[i] - eps_pair, 1.0 - y[i] - eps_pair])\n\n    # Pairwise overlap constraints: r_i + r_j <= dist(c_i,c_j) - eps_pair\n    d, _, _ = _pairwise_distances(centers)\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows.append(e); b_vals.append(r_max[i])\n\n    res = linprog(-np.ones(N), A_ub=np.array(A_rows), b_ub=np.array(b_vals), bounds=(0.0, 0.5), method='highs')\n    if res.success: return np.clip(res.x, 0.0, 0.5)\n\n    # Fallback: If LP with eps_pair is infeasible, try with eps_pair = 0 and scale down.\n    res2 = linprog(-np.ones(N), A_ub=np.array(A_rows), b_ub=np.array(b_vals) + eps_pair, bounds=(0.0, 0.5), method='highs')\n    if not res2.success: return np.zeros(N)\n    \n    r_base = np.clip(res2.x, 0.0, 0.5)\n    \n    with np.errstate(divide='ignore', invalid='ignore'):\n        denom_pairs = r_base[:, None] + r_base[None, :]\n        ratio_pairs = np.where(denom_pairs > 1e-9, (d - eps_pair) / denom_pairs, np.inf)\n        iu = np.triu_indices(N, 1)\n        s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n        \n        s_b_x_min = np.where(r_base > 1e-9, (x - eps_pair) / r_base, np.inf)\n        s_b_y_min = np.where(r_base > 1e-9, (y - eps_pair) / r_base, np.inf)\n        s_b_x_max = np.where(r_base > 1e-9, (1.0 - x - eps_pair) / r_base, np.inf)\n        s_b_y_max = np.where(r_base > 1e-9, (1.0 - y - eps_pair) / r_base, np.inf)\n        s_boundary = np.min([s_b_x_min, s_b_y_min, s_b_x_max, s_b_y_max])\n\n    s = min(s_pairs if np.isfinite(s_pairs) else 1.0, s_boundary if np.isfinite(s_boundary) else 1.0)\n    return np.clip(max(0.0, min(1.0, s)) * r_base, 0.0, 0.5)\n\ndef _verify(centers, radii, tol_pair=1e-6):\n    \"\"\"\n    Verifies if a given packing is strictly feasible.\n    \"\"\"\n    N = len(radii)\n    x, y = centers[:, 0], centers[:, 1]\n    if centers.shape != (N, 2) or np.any(radii < -1e-12): return False\n    if np.any(x - radii < tol_pair) or np.any(y - radii < tol_pair): return False\n    if np.any(x + radii > 1.0 - tol_pair) or np.any(y + radii > 1.0 - tol_pair): return False\n    d, _, _ = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    if np.any((radii[iu[0]] + radii[iu[1]]) - d[iu] + tol_pair > 1e-12): return False\n    return True\n\n# Custom helper functions for this solution\ndef _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n    \"\"\"Generates initial centers in a hexagonal-like grid pattern.\"\"\"\n    assert sum(rows) == 26\n    max_cols, nrows = max(rows), len(rows)\n    dx = (1.0 - 2*margin) / (max_cols - 1) if max_cols > 1 else 0.0\n    dy = (1.0 - 2*margin) / (nrows - 1) if nrows > 1 else 0.0\n    centers = []\n    rng = np.random.default_rng(seed)\n    for ri, cols in enumerate(rows):\n        y = margin + ri * dy if nrows > 1 else 0.5\n        row_width = (cols - 1) * dx\n        startx = 0.5 - row_width / 2.0 + (dx / 2.0 if ri % 2 == 1 else 0.0)\n        for k in range(cols):\n            centers.append([startx + k * dx, y])\n    centers = np.array(centers) + rng.normal(scale=jitter_scale, size=(sum(rows), 2))\n    return np.clip(centers, 1e-3, 1 - 1e-3)\n\ndef _multi_start_inits(N):\n    \"\"\"Generates a list of diverse initial center configurations.\"\"\"\n    patterns = [[6,5,6,5,4], [6,5,5,5,5], [5,6,5,5,5], [5,5,6,5,5], [6,6,5,5,4], [5,6,6,5,4]]\n    params = [(0.04, 0.03), (0.05, 0.03), (0.06, 0.02), (0.05, 0.04)]\n    inits = []\n    for i, pat in enumerate(patterns):\n        for j, (m, jit) in enumerate(params):\n            inits.append(_hex_initial_centers_from_rows(pat, margin=m, jitter_scale=jit, seed=i*10+j))\n    return inits\n\ndef _center_only_relax(centers, r_fixed, P=2000.0, w_b=1.0, w_o=1.0, iters=80):\n    \"\"\"Performs a short optimization run on centers only, with fixed radii.\"\"\"\n    N = centers.shape[0]\n    res = minimize(fun=lambda z: _objective_centers_only(z, r_fixed, P, w_b, w_o),\n                   x0=np.concatenate([centers[:, 0], centers[:, 1]]),\n                   method='L-BFGS-B', jac=True, bounds=[(0.0, 1.0)] * (2*N),\n                   options={'maxiter': iters, 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 20})\n    return np.stack([res.x[:N], res.x[N:2*N]], axis=1)\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square.\n    \"\"\"\n    N = 26\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n\n    P_schedule = [8.0, 80.0, 800.0, 3000.0, 10000.0, 20000.0]\n    maxiter_stage = [90, 100, 110, 120, 130, 140]\n    bounds = [(0.0, 1.0)] * (2*N) + [(0.0, 0.5)] * N\n\n    inits = _multi_start_inits(N)\n\n    for centers0 in inits:\n        x0, y0 = centers0[:, 0], centers0[:, 1]\n        base_bound = np.minimum.reduce([x0, y0, 1 - x0, 1 - y0])\n        r0 = 0.05 * base_bound\n        z = np.concatenate([x0, y0, r0])\n\n        for si, P in enumerate(P_schedule):\n            res = minimize(fun=lambda zz: _objective_and_grad(zz, N, P), x0=z, method='L-BFGS-B', jac=True,\n                           bounds=bounds, options={'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 30})\n            z = res.x\n            centers_tmp = np.stack([z[:N], z[N:2*N]], axis=1)\n            r_cur = np.clip(z[2*N:], 0.0, 0.5)\n            \n            cap_factor = 1.08 if si < len(P_schedule) - 1 else 1.15\n            r_cap = np.minimum(0.5, cap_factor * np.maximum(1e-9, r_cur))\n            r_lp = _lp_feasibilize(centers_tmp, r_max=r_cap, eps_pair=1e-6)\n            \n            centers_relaxed = _center_only_relax(centers_tmp, r_lp, P=max(1000.0, P), iters=70)\n            \n            r_lp2 = _lp_feasibilize(centers_relaxed, r_max=None, eps_pair=1e-6)\n            \n            z = np.concatenate([centers_relaxed[:, 0], centers_relaxed[:, 1], np.clip(r_lp2, 0.0, 0.5)])\n\n        centers_final = np.stack([z[:N], z[N:2*N]], axis=1)\n        r_final = _lp_feasibilize(centers_final, r_max=None, eps_pair=1e-6)\n\n        if _verify(centers_final, r_final, tol_pair=1e-6):\n            s = float(np.sum(r_final))\n            if s > best['sum']:\n                best.update({'centers': centers_final.copy(), 'radii': r_final.copy(), 'sum': s})\n\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        radii_fb = _lp_feasibilize(centers_fb, eps_pair=1e-6)\n        return centers_fb, np.clip(radii_fb, 0.0, 0.5), float(np.sum(radii_fb))\n\n    # Final hardening to guarantee strict feasibility\n    radii_strict = _lp_feasibilize(best['centers'], eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        radii = radii_strict\n    else:\n        radii = best['radii']\n\n    centers = best['centers']\n    radii = np.clip(radii, 0.0, 0.5)\n    sum_radii = float(np.sum(radii))\n    \n    return centers.astype(float), radii.astype(float), sum_radii\n\n# trial_15_7 (score=2.6358676293444767)\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.optimize import linprog\n\n# Helper functions for the packing algorithm\ndef _pairwise_distances(centers):\n    \"\"\"\n    Calculates pairwise Euclidean distances between centers.\n    Returns distance matrix, and matrices of dx and dy.\n    \"\"\"\n    diff = centers[:, None, :] - centers[None, :, :]\n    d = np.sqrt(np.sum(diff**2, axis=2))\n    return d, diff[..., 0], diff[..., 1]\n\ndef _objective_and_grad(z, N, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective function and its gradient for joint optimization of centers (x,y) and radii (r).\n    z = [x_0..x_N-1, y_0..y_N-1, r_0..r_N-1]\n    Objective: -sum(r) + P * (w_b * boundary_penalty + w_o * overlap_penalty)\n    Penalties are squared hinge functions.\n    \"\"\"\n    x = z[:N]\n    y = z[N:2*N]\n    r = z[2*N:]\n    tiny = 1e-12 # Small value to prevent division by zero\n\n    # Boundary penalties: hinges for r - x, r - y, r + x - 1, r + y - 1\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap penalties: hinges for r_i + r_j - d_ij\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1) # Upper triangle indices for unique pairs (i, j where i < j)\n    dab = d[iu] # Distances for unique pairs\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny) # Use tiny to prevent division by zero in gradients\n    hij = r[iu[0]] + r[iu[1]] - dab # Overlap amount for each pair\n    hpos = np.maximum(0.0, hij) # Positive part of overlap (hinge)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    # Total objective function value\n    f = -np.sum(r) + P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients for boundary penalties\n    dr_b = h1 + h2 + h3 + h4\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n\n    # Overlap gradients (accumulate with np.add.at for efficiency)\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    dr_o = np.zeros(N, dtype=float)\n\n    # Gradient contribution for centers (x, y)\n    coeff = hpos / d_safe # h / d\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx) # For circle i\n    np.add.at(dx_o, iu[1], +cx) # For circle j\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n    \n    # Gradient contribution for radii (r)\n    np.add.at(dr_o, iu[0], hpos)\n    np.add.at(dr_o, iu[1], hpos)\n\n    # Combine all gradients\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    dr_total = -1.0 + P * (w_b * dr_b + w_o * dr_o) # -1.0 from -sum(r)\n\n    grad = np.concatenate([dx_total, dy_total, dr_total])\n    return f, grad\n\ndef _objective_centers_only(z_xy, r_fixed, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective function and its gradient for optimizing centers (x,y) only, with fixed radii.\n    \"\"\"\n    N = r_fixed.shape[0]\n    x = z_xy[:N]\n    y = z_xy[N:2*N]\n    r = r_fixed\n    tiny = 1e-12\n\n    # Boundary hinges\n    s1 = r - x; s2 = r - y; s3 = r + x - 1.0; s4 = r + y - 1.0\n    h1 = np.maximum(0.0, s1); h2 = np.maximum(0.0, s2); h3 = np.maximum(0.0, s3); h4 = np.maximum(0.0, s4)\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap hinges\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]; dxab = dx_mat[iu]; dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    f = P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients wrt x,y only\n    dx_b = -h1 + h3; dy_b = -h2 + h4\n    dx_o = np.zeros(N, dtype=float); dy_o = np.zeros(N, dtype=float)\n    coeff = hpos / d_safe\n    cx = coeff * dxab; cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx); np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy); np.add.at(dy_o, iu[1], +cy)\n\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    g = np.concatenate([dx_total, dy_total])\n    return f, g\n\ndef _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n    \"\"\"\n    Maximizes sum(r) for given centers using linear programming, ensuring feasibility.\n    \"\"\"\n    N = centers.shape[0]\n    x, y = centers[:, 0], centers[:, 1]\n    \n    # Try with eps_pair first\n    A_rows, b_vals = [], []\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows.extend([e.copy(), e.copy(), e.copy(), e.copy()])\n        b_vals.extend([x[i] - eps_pair, y[i] - eps_pair, 1.0 - x[i] - eps_pair, 1.0 - y[i] - eps_pair])\n    d, _, _ = _pairwise_distances(centers)\n    for i in range(N):\n        for j in range(i + 1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows.append(e); b_vals.append(r_max[i])\n    \n    res = linprog(-np.ones(N), A_ub=np.array(A_rows), b_ub=np.array(b_vals), bounds=[(0,0.5)]*N, method='highs')\n    if res.success:\n        return np.clip(res.x, 0.0, 0.5)\n\n    # Fallback: solve with eps=0\n    A_rows2, b_vals2 = [], []\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows2.extend([e.copy(), e.copy(), e.copy(), e.copy()])\n        b_vals2.extend([x[i], y[i], 1.0 - x[i], 1.0 - y[i]])\n    for i in range(N):\n        for j in range(i + 1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows2.append(e); b_vals2.append(d[i, j])\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows2.append(e); b_vals2.append(r_max[i])\n\n    res2 = linprog(-np.ones(N), A_ub=np.array(A_rows2), b_ub=np.array(b_vals2), bounds=[(0,0.5)]*N, method='highs')\n    if not res2.success:\n        return np.zeros(N)\n    \n    r_base = np.clip(res2.x, 0.0, 0.5)\n    \n    # Scale r_base to satisfy eps_pair\n    with np.errstate(divide='ignore', invalid='ignore'):\n        denom_pairs = r_base[:, None] + r_base[None, :]\n        ratio_pairs = np.where(denom_pairs > 1e-9, (d - eps_pair) / denom_pairs, np.inf)\n        iu = np.triu_indices(N, 1)\n        s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n        \n        s_b_x_min = np.where(r_base > 1e-9, (x - eps_pair) / r_base, np.inf)\n        s_b_y_min = np.where(r_base > 1e-9, (y - eps_pair) / r_base, np.inf)\n        s_b_x_max = np.where(r_base > 1e-9, (1.0 - x - eps_pair) / r_base, np.inf)\n        s_b_y_max = np.where(r_base > 1e-9, (1.0 - y - eps_pair) / r_base, np.inf)\n        s_boundary = np.min([s_b_x_min, s_b_y_min, s_b_x_max, s_b_y_max])\n\n    s = min(s_pairs if np.isfinite(s_pairs) else 1.0, s_boundary if np.isfinite(s_boundary) else 1.0)\n    s = max(0.0, min(1.0, s))\n    return s * r_base\n\ndef _verify(centers, radii, tol_pair=1e-6):\n    \"\"\"\n    Verifies if a given packing is strictly feasible.\n    \"\"\"\n    N = len(radii)\n    x, y = centers[:, 0], centers[:, 1]\n    if centers.shape != (N, 2) or np.any(radii < -1e-12): return False\n    if np.any(x - radii < tol_pair) or np.any(y - radii < tol_pair): return False\n    if np.any(x + radii > 1.0 - tol_pair) or np.any(y + radii > 1.0 - tol_pair): return False\n    d, _, _ = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    if np.any((radii[iu[0]] + radii[iu[1]]) - d[iu] + tol_pair > 1e-12): return False\n    return True\n\ndef _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n    \"\"\"Generates initial centers in a hexagonal-like grid pattern.\"\"\"\n    assert sum(rows) == 26\n    max_cols, nrows = max(rows), len(rows)\n    dx = (1.0 - 2*margin) / (max_cols - 1) if max_cols > 1 else 0.0\n    dy = (1.0 - 2*margin) / (nrows - 1) if nrows > 1 else 0.0\n    centers = []\n    rng = np.random.default_rng(seed)\n    for ri, cols in enumerate(rows):\n        y = margin + ri * dy if nrows > 1 else 0.5\n        row_width = (cols - 1) * dx\n        startx = 0.5 - row_width / 2.0 + (dx / 2.0 if ri % 2 == 1 else 0.0)\n        for k in range(cols):\n            centers.append([startx + k * dx, y])\n    centers = np.array(centers) + rng.normal(scale=jitter_scale, size=(sum(rows), 2))\n    return np.clip(centers, 1e-3, 1 - 1e-3)\n\ndef _multi_start_inits(N):\n    \"\"\"Generates a list of diverse initial center configurations.\"\"\"\n    patterns = [[6,5,6,5,4], [6,5,5,5,5], [5,6,5,5,5], [5,5,6,5,5], [6,6,5,5,4], [5,6,6,5,4]]\n    params = [(0.04, 0.03), (0.05, 0.03), (0.06, 0.02), (0.05, 0.04)]\n    inits = []\n    for i, pat in enumerate(patterns):\n        for j, (m, jit) in enumerate(params):\n            inits.append(_hex_initial_centers_from_rows(pat, margin=m, jitter_scale=jit, seed=i*10+j))\n    return inits\n\ndef _center_only_relax(centers, r_fixed, P=2000.0, w_b=1.0, w_o=1.0, iters=80):\n    \"\"\"Performs a short optimization run on centers only, with fixed radii.\"\"\"\n    N = centers.shape[0]\n    res = minimize(fun=lambda z: _objective_centers_only(z, r_fixed, P, w_b, w_o),\n                   x0=np.concatenate([centers[:, 0], centers[:, 1]]),\n                   method='L-BFGS-B', jac=True, bounds=[(0.0, 1.0)] * (2*N),\n                   options={'maxiter': iters, 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 20})\n    return np.stack([res.x[:N], res.x[N:2*N]], axis=1)\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square.\n    \"\"\"\n    N = 26\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n\n    P_schedule = [8.0, 80.0, 800.0, 3000.0, 10000.0, 20000.0]\n    maxiter_stage = [90, 100, 110, 120, 130, 140]\n    bounds = [(0.0, 1.0)] * (2*N) + [(0.0, 0.5)] * N\n\n    inits = _multi_start_inits(N)\n\n    for centers0 in inits:\n        x0, y0 = centers0[:, 0], centers0[:, 1]\n        base_bound = np.minimum.reduce([x0, y0, 1 - x0, 1 - y0])\n        r0 = 0.05 * base_bound\n        z = np.concatenate([x0, y0, r0])\n\n        for si, P in enumerate(P_schedule):\n            res = minimize(fun=lambda zz: _objective_and_grad(zz, N, P), x0=z, method='L-BFGS-B', jac=True,\n                           bounds=bounds, options={'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 30})\n            z = res.x\n            centers_tmp = np.stack([z[:N], z[N:2*N]], axis=1)\n            r_cur = np.clip(z[2*N:], 0.0, 0.5)\n            \n            cap_factor = 1.08 if si < len(P_schedule) - 1 else 1.15\n            r_cap = np.minimum(0.5, cap_factor * np.maximum(1e-9, r_cur))\n            r_lp = _lp_feasibilize(centers_tmp, r_max=r_cap, eps_pair=1e-6)\n            \n            centers_relaxed = _center_only_relax(centers_tmp, r_lp, P=max(1000.0, P), iters=70)\n            \n            r_lp2 = _lp_feasibilize(centers_relaxed, r_max=None, eps_pair=1e-6)\n            \n            z = np.concatenate([centers_relaxed[:, 0], centers_relaxed[:, 1], np.clip(r_lp2, 0.0, 0.5)])\n\n        centers_final = np.stack([z[:N], z[N:2*N]], axis=1)\n        r_final = _lp_feasibilize(centers_final, r_max=None, eps_pair=1e-6)\n\n        if _verify(centers_final, r_final, tol_pair=1e-6):\n            s = float(np.sum(r_final))\n            if s > best['sum']:\n                best.update({'centers': centers_final.copy(), 'radii': r_final.copy(), 'sum': s})\n\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        radii_fb = _lp_feasibilize(centers_fb, eps_pair=1e-6)\n        return centers_fb, np.clip(radii_fb, 0.0, 0.5), float(np.sum(radii_fb))\n\n    # Final hardening to guarantee strict feasibility\n    radii_strict = _lp_feasibilize(best['centers'], eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        radii = radii_strict\n    else:\n        radii = best['radii']\n\n    centers = best['centers']\n    radii = np.clip(radii, 0.0, 0.5)\n    sum_radii = float(np.sum(radii))\n    \n    return centers.astype(float), radii.astype(float), sum_radii\n\n# trial_5_0 (score=2.6357967398504405)\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.optimize import linprog\n\ndef _pairwise_distances(centers):\n    diff = centers[:, None, :] - centers[None, :, :]\n    d = np.sqrt(np.sum(diff**2, axis=2))\n    return d, diff[..., 0], diff[..., 1]\n\ndef _objective_and_grad(z, N, P, w_b=1.0, w_o=1.0):\n    # z = [x(0..N-1), y(0..N-1), r(0..N-1)]\n    x = z[:N]\n    y = z[N:2*N]\n    r = z[2*N:]\n    tiny = 1e-12\n\n    # Boundary penalties: hinges\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap penalties: hinges for i<j\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    # Objective\n    f = -np.sum(r) + P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients for boundary penalties\n    dr_b = h1 + h2 + h3 + h4\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n\n    # Overlap gradients (accumulate with np.add.at)\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    dr_o = np.zeros(N, dtype=float)\n\n    # For centers:\n    # grad_x_a += -h * (dxab/d), grad_x_b += +h * (dxab/d)\n    # grad_y_a += -h * (dyab/d), grad_y_b += +h * (dyab/d)\n    coeff = hpos / d_safe\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx)\n    np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n    # For radii:\n    np.add.at(dr_o, iu[0], hpos)\n    np.add.at(dr_o, iu[1], hpos)\n\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    dr_total = -1.0 + P * (w_b * dr_b + w_o * dr_o)\n\n    grad = np.concatenate([dx_total, dy_total, dr_total])\n    return f, grad\n\ndef _objective_centers_only(z_xy, r_fixed, P, w_b=1.0, w_o=1.0):\n    # z_xy = [x(0..N-1), y(0..N-1)], radii fixed\n    N = r_fixed.shape[0]\n    x = z_xy[:N]\n    y = z_xy[N:2*N]\n    r = r_fixed\n    tiny = 1e-12\n\n    # Boundary hinges\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap hinges\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    f = P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients wrt x,y only\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    coeff = hpos / d_safe\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx)\n    np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    g = np.concatenate([dx_total, dy_total])\n    return f, g\n\ndef _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n    \"\"\"\n    Maximize sum(r) subject to:\n      r_i >= 0\n      r_i <= r_max[i] (if provided)\n      r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n      r_i + r_j <= dist(c_i,c_j) - eps_pair\n    \"\"\"\n    N = centers.shape[0]\n    x = centers[:, 0]\n    y = centers[:, 1]\n\n    # Build A_ub, b_ub\n    A_rows = []\n    b_vals = []\n\n    # Boundary constraints\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows.append(e.copy()); b_vals.append(x[i])\n        A_rows.append(e.copy()); b_vals.append(y[i])\n        A_rows.append(e.copy()); b_vals.append(1.0 - x[i])\n        A_rows.append(e.copy()); b_vals.append(1.0 - y[i])\n\n    # Pairwise constraints\n    d, _, _ = _pairwise_distances(centers)\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n\n    # Optional upper bounds r_i <= r_max[i]\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows.append(e); b_vals.append(r_max[i])\n\n    A_ub = np.array(A_rows)\n    b_ub = np.array(b_vals)\n\n    # Bounds on r: [0, 0.5]\n    bounds = [(0.0, 0.5) for _ in range(N)]\n    c = -np.ones(N)\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    if res.success:\n        return np.clip(res.x, 0.0, 0.5)\n\n    # Retry with eps_pair = 0 to get a feasible base, then scale to satisfy eps_pair\n    b_vals2 = []\n    A_rows2 = []\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows2.append(e.copy()); b_vals2.append(x[i])\n        A_rows2.append(e.copy()); b_vals2.append(y[i])\n        A_rows2.append(e.copy()); b_vals2.append(1.0 - x[i])\n        A_rows2.append(e.copy()); b_vals2.append(1.0 - y[i])\n\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows2.append(e); b_vals2.append(d[i, j])\n\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows2.append(e); b_vals2.append(r_max[i])\n\n    A_ub2 = np.array(A_rows2)\n    b_ub2 = np.array(b_vals2)\n\n    res2 = linprog(c, A_ub=A_ub2, b_ub=b_ub2, bounds=bounds, method='highs')\n    if not res2.success:\n        return np.zeros(N)\n\n    r_base = np.clip(res2.x, 0.0, 0.5)\n    d, _, _ = _pairwise_distances(centers)\n    denom = r_base[:, None] + r_base[None, :]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        ratio = np.where(denom > 0, (d - eps_pair) / denom, np.inf)\n    iu = np.triu_indices(N, 1)\n    if ratio[iu].size > 0:\n        s_pairs = np.min(ratio[iu])\n        if not np.isfinite(s_pairs):\n            s_pairs = 1.0\n        s = min(1.0, s_pairs)\n    else:\n        s = 1.0\n    s = max(0.0, s)\n    r = s * r_base\n    return np.clip(r, 0.0, 0.5)\n\ndef _verify(centers, radii, tol_pair=1e-6):\n    N = len(radii)\n    x = centers[:, 0]\n    y = centers[:, 1]\n    if centers.shape != (N, 2):\n        return False\n    if np.any(radii < -1e-12):\n        return False\n    if np.any(x - radii < -1e-9):\n        return False\n    if np.any(y - radii < -1e-9):\n        return False\n    if np.any(x + radii > 1.0 + 1e-9):\n        return False\n    if np.any(y + radii > 1.0 + 1e-9):\n        return False\n    d, _, _ = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    lhs = radii[:, None] + radii[None, :]\n    viol = lhs[iu] - d[iu] + tol_pair\n    if np.any(viol > 1e-12):\n        return False\n    return True\n\ndef _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n    # rows: list of counts per row, centered with hex offset when fewer than max\n    assert sum(rows) == 26\n    max_cols = max(rows)\n    nrows = len(rows)\n    dx = (1.0 - 2*margin) / (max_cols - 1) if max_cols > 1 else 0.0\n    dy = (1.0 - 2*margin) / (nrows - 1) if nrows > 1 else 0.0\n    centers = []\n    rng = np.random.default_rng(seed)\n    for ri, cols in enumerate(rows):\n        y = margin + ri * dy if nrows > 1 else 0.5\n        if cols == max_cols:\n            startx = margin\n        else:\n            startx = margin + 0.5 * dx\n        if cols == 1:\n            startx = 0.5\n        for k in range(cols):\n            x = startx + (k * dx if cols > 1 else 0.0)\n            centers.append([x, y])\n    centers = np.array(centers)\n    # Jitter and clip\n    jitter = rng.normal(scale=jitter_scale, size=centers.shape)\n    centers = centers + jitter\n    centers = np.clip(centers, 1e-3, 1 - 1e-3)\n    return centers\n\ndef _multi_start_inits(N):\n    # Various row patterns summing to 26\n    patterns = [\n        [6, 5, 6, 5, 4],\n        [6, 5, 5, 5, 5],\n        [5, 6, 5, 5, 5],\n        [5, 5, 6, 5, 5],\n        [6, 6, 5, 5, 4],\n        [5, 6, 6, 5, 4],\n        [6, 5, 6, 4, 5],\n    ]\n    params = [\n        (0.03, 0.02), (0.04, 0.03), (0.05, 0.03),\n        (0.06, 0.02), (0.07, 0.03), (0.05, 0.04),\n    ]\n    inits = []\n    seed = 0\n    for pat in patterns:\n        for (m, j) in params:\n            inits.append(_hex_initial_centers_from_rows(pat, margin=m, jitter_scale=j, seed=seed))\n            seed += 1\n            if len(inits) >= 16:  # Limit number of starts to keep runtime in check\n                return inits\n    return inits\n\ndef _center_only_relax(centers, r_fixed, P=2000.0, w_b=1.0, w_o=1.0, iters=80):\n    N = centers.shape[0]\n    z0 = np.concatenate([centers[:, 0], centers[:, 1]])\n    bounds_xy = [(0.0, 1.0)] * (2 * N)\n    res = minimize(\n        fun=lambda zz: _objective_centers_only(zz, r_fixed, P, w_b, w_o),\n        x0=z0,\n        method='L-BFGS-B',\n        jac=True,\n        bounds=bounds_xy,\n        options={'maxiter': iters, 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 20}\n    )\n    z = res.x\n    centers_new = np.stack([z[:N], z[N:2*N]], axis=1)\n    return centers_new\n\ndef construct_packing():\n    N = 26\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n\n    # Penalty schedule and bounds\n    P_schedule = [8.0, 80.0, 800.0, 3000.0, 10000.0]\n    maxiter_stage = [90, 100, 110, 120, 130]\n    bounds = [(0.0, 1.0)] * (2*N) + [(0.0, 0.5)] * N\n\n    # Weighting of penalties\n    w_b = 1.0\n    w_o = 1.0\n\n    # Initializations\n    inits = _multi_start_inits(N)\n    if not inits:\n        inits = [_hex_initial_centers_from_rows([6,5,6,5,4], margin=0.05, jitter_scale=0.03, seed=42)]\n\n    for init_idx, centers0 in enumerate(inits):\n        x0 = centers0[:, 0]\n        y0 = centers0[:, 1]\n        # Start with small radii within local boundary\n        base_bound = np.minimum.reduce([x0, y0, 1 - x0, 1 - y0])\n        r0 = 0.05 * base_bound\n        z = np.concatenate([x0, y0, r0])\n\n        # Annealing optimization with periodic LP tightening and center-only relaxation\n        for si, P in enumerate(P_schedule):\n            res = minimize(\n                fun=lambda zz: _objective_and_grad(zz, N, P, w_b, w_o),\n                x0=z,\n                method='L-BFGS-B',\n                jac=True,\n                bounds=bounds,\n                options={'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 30}\n            )\n            z = res.x\n            centers_tmp = np.stack([z[:N], z[N:2*N]], axis=1)\n            r_cur = np.clip(z[2*N:], 0.0, 0.5)\n            # Conservative LP cap slightly above current radii\n            cap_factor = 1.08 if si < len(P_schedule) - 1 else 1.15\n            r_cap = np.minimum(0.5, cap_factor * np.maximum(1e-9, r_cur))\n            r_lp = _lp_feasibilize(centers_tmp, r_max=r_cap, eps_pair=1e-6)\n            # Small center-only relaxation to open space, then re-LP\n            centers_relaxed = _center_only_relax(centers_tmp, r_lp, P=max(1000.0, P), w_b=w_b, w_o=w_o, iters=70)\n            r_lp2 = _lp_feasibilize(centers_relaxed, r_max=None, eps_pair=1e-6)\n            z = np.concatenate([centers_relaxed[:, 0], centers_relaxed[:, 1], np.clip(r_lp2, 0.0, 0.5)])\n\n        # Final LP without cap to fully utilize geometry\n        centers_cur = np.stack([z[:N], z[N:2*N]], axis=1)\n        r_final = _lp_feasibilize(centers_cur, r_max=None, eps_pair=1e-6)\n\n        # Verify and update best\n        if _verify(centers_cur, r_final, tol_pair=1e-6):\n            s = float(np.sum(r_final))\n            if s > best['sum']:\n                best['centers'] = centers_cur.copy()\n                best['radii'] = r_final.copy()\n                best['sum'] = s\n        else:\n            # Try slight shrink and re-LP to fix tiny violations\n            d, _, _ = _pairwise_distances(centers_cur)\n            denom = r_final[:, None] + r_final[None, :]\n            with np.errstate(divide='ignore', invalid='ignore'):\n                ratio = np.where(denom > 0, (d - 1.0e-6) / denom, np.inf)\n            iu = np.triu_indices(N, 1)\n            s_pairs = np.min(ratio[iu]) if ratio[iu].size > 0 else 1.0\n            if not np.isfinite(s_pairs):\n                s_pairs = 1.0\n            s_pairs = max(0.0, min(1.0, s_pairs))\n            r_try = s_pairs * r_final\n            # Boundary scaling\n            bx = np.minimum.reduce([centers_cur[:,0], centers_cur[:,1], 1-centers_cur[:,0], 1-centers_cur[:,1]])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                scale_b = np.min(np.where(r_try > 0, bx / r_try, 1.0))\n            scale_b = min(1.0, scale_b if np.isfinite(scale_b) else 1.0)\n            r_try = scale_b * r_try\n            if _verify(centers_cur, r_try, tol_pair=1e-6):\n                s = float(np.sum(r_try))\n                if s > best['sum']:\n                    best['centers'] = centers_cur.copy()\n                    best['radii'] = r_try.copy()\n                    best['sum'] = s\n\n    # Fallback if nothing verified\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        r_fb = _lp_feasibilize(centers_fb, r_max=None, eps_pair=1e-6)\n        if not _verify(centers_fb, r_fb, tol_pair=1e-6):\n            r_fb = 0.95 * r_fb\n        best['centers'] = centers_fb\n        best['radii'] = np.clip(r_fb, 0.0, 0.5)\n        best['sum'] = float(np.sum(best['radii']))\n\n    # Ensure strict feasibility and final verify\n    radii_strict = _lp_feasibilize(best['centers'], r_max=None, eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        radii = radii_strict\n    else:\n        radii = best['radii']\n\n    centers = best['centers']\n    # Final hardening: if any violation persists, scale radii conservatively\n    if not _verify(centers, radii, tol_pair=1e-6):\n        d, _, _ = _pairwise_distances(centers)\n        denom = radii[:, None] + radii[None, :]\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = np.where(denom > 0, (d - 1e-6) / denom, np.inf)\n        iu = np.triu_indices(N, 1)\n        s_pairs = np.min(ratio[iu]) if ratio[iu].size > 0 else 1.0\n        s_pairs = min(1.0, s_pairs if np.isfinite(s_pairs) else 1.0)\n        s_pairs = max(0.0, s_pairs)\n        radii = s_pairs * radii\n        bx = np.minimum.reduce([centers[:,0], centers[:,1], 1-centers[:,0], 1-centers[:,1]])\n        with np.errstate(divide='ignore', invalid='ignore'):\n            scale_b = np.min(np.where(radii > 0, bx / radii, 1.0))\n        scale_b = min(1.0, scale_b if np.isfinite(scale_b) else 1.0)\n        radii = scale_b * radii\n\n    radii = np.clip(radii, 0.0, 0.5)\n    sum_radii = float(np.sum(radii))\n    return centers.astype(float), radii.astype(float), sum_radii\n\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n# trial_13_6 (score=2.6357155005325295)\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_radii) with:\n        - centers: np.array shape (26, 2)\n        - radii:   np.array shape (26,)\n        - sum_radii: float, strictly feasible sum of radii\n    \"\"\"\n    # ---------------- Helper functions ----------------\n    def _pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        d = np.sqrt(np.sum(diff**2, axis=2))\n        return d, diff[..., 0], diff[..., 1]\n\n    def _density_weights(centers, k=5, eps=1e-12):\n        # Local density proxy: inverse of mean k-NN distance\n        d, _, _ = _pairwise_distances(centers)\n        N = centers.shape[0]\n        # Exclude self-distances by setting to inf then sort\n        d2 = d.copy()\n        np.fill_diagonal(d2, np.inf)\n        # k-NN mean distances\n        # For N <= k, fallback to finite minima\n        k_eff = min(k, max(1, N - 1))\n        # Partition to get k smallest\n        knn = np.partition(d2, kth=k_eff-1, axis=1)[:, :k_eff]\n        m = np.mean(knn, axis=1)\n        dens = 1.0 / (m + eps)\n        return dens\n\n    def _objective_and_grad(z, N, P, w_b=1.0, w_o=1.0, use_density=True):\n        # z = [x(0..N-1), y(0..N-1), r(0..N-1)]\n        x = z[:N]\n        y = z[N:2*N]\n        r = z[2*N:]\n        tiny = 1e-12\n\n        # Boundary penalties: hinges\n        s1 = r - x\n        s2 = r - y\n        s3 = r + x - 1.0\n        s4 = r + y - 1.0\n\n        h1 = np.maximum(0.0, s1)\n        h2 = np.maximum(0.0, s2)\n        h3 = np.maximum(0.0, s3)\n        h4 = np.maximum(0.0, s4)\n\n        pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n        # Overlap penalties: hinges for i<j\n        centers = np.stack([x, y], axis=1)\n        d, dx_mat, dy_mat = _pairwise_distances(centers)\n        iu = np.triu_indices(N, 1)\n        dab = d[iu]\n        dxab = dx_mat[iu]\n        dyab = dy_mat[iu]\n        d_safe = np.maximum(dab, tiny)\n        hij = r[iu[0]] + r[iu[1]] - dab\n        hpos = np.maximum(0.0, hij)\n\n        if use_density:\n            dens = _density_weights(centers, k=5, eps=tiny)\n            wij = 0.5 * (dens[iu[0]] + dens[iu[1]])\n        else:\n            wij = 1.0\n\n        pen_o = 0.5 * np.sum(wij * (hpos*hpos))\n\n        # Objective\n        f = -np.sum(r) + P * (w_b * pen_b + w_o * pen_o)\n\n        # Gradients for boundary penalties\n        dr_b = h1 + h2 + h3 + h4\n        dx_b = -h1 + h3\n        dy_b = -h2 + h4\n\n        # Overlap gradients (accumulate with np.add.at)\n        dx_o = np.zeros(N, dtype=float)\n        dy_o = np.zeros(N, dtype=float)\n        dr_o = np.zeros(N, dtype=float)\n\n        coeff = (wij * hpos) / d_safe\n        cx = coeff * dxab\n        cy = coeff * dyab\n        np.add.at(dx_o, iu[0], -cx)\n        np.add.at(dx_o, iu[1], +cx)\n        np.add.at(dy_o, iu[0], -cy)\n        np.add.at(dy_o, iu[1], +cy)\n        # For radii:\n        contrib_r = wij * hpos\n        np.add.at(dr_o, iu[0], contrib_r)\n        np.add.at(dr_o, iu[1], contrib_r)\n\n        dx_total = P * (w_b * dx_b + w_o * dx_o)\n        dy_total = P * (w_b * dy_b + w_o * dy_o)\n        dr_total = -1.0 + P * (w_b * dr_b + w_o * dr_o)\n\n        grad = np.concatenate([dx_total, dy_total, dr_total])\n        return f, grad\n\n    def _objective_centers_only(z_xy, r_fixed, P, w_b=1.0, w_o=1.0, use_density=True):\n        # z_xy = [x(0..N-1), y(0..N-1)], radii fixed\n        N = r_fixed.shape[0]\n        x = z_xy[:N]\n        y = z_xy[N:2*N]\n        r = r_fixed\n        tiny = 1e-12\n\n        # Boundary hinges\n        s1 = r - x\n        s2 = r - y\n        s3 = r + x - 1.0\n        s4 = r + y - 1.0\n        h1 = np.maximum(0.0, s1)\n        h2 = np.maximum(0.0, s2)\n        h3 = np.maximum(0.0, s3)\n        h4 = np.maximum(0.0, s4)\n        pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n        # Overlap hinges\n        centers = np.stack([x, y], axis=1)\n        d, dx_mat, dy_mat = _pairwise_distances(centers)\n        iu = np.triu_indices(N, 1)\n        dab = d[iu]\n        dxab = dx_mat[iu]\n        dyab = dy_mat[iu]\n        d_safe = np.maximum(dab, tiny)\n        hij = r[iu[0]] + r[iu[1]] - dab\n        hpos = np.maximum(0.0, hij)\n\n        if use_density:\n            dens = _density_weights(centers, k=5, eps=tiny)\n            wij = 0.5 * (dens[iu[0]] + dens[iu[1]])\n        else:\n            wij = 1.0\n\n        pen_o = 0.5 * np.sum(wij * (hpos*hpos))\n\n        f = P * (w_b * pen_b + w_o * pen_o)\n\n        # Gradients wrt x,y only\n        dx_b = -h1 + h3\n        dy_b = -h2 + h4\n\n        dx_o = np.zeros(N, dtype=float)\n        dy_o = np.zeros(N, dtype=float)\n        coeff = (wij * hpos) / d_safe\n        cx = coeff * dxab\n        cy = coeff * dyab\n        np.add.at(dx_o, iu[0], -cx)\n        np.add.at(dx_o, iu[1], +cx)\n        np.add.at(dy_o, iu[0], -cy)\n        np.add.at(dy_o, iu[1], +cy)\n\n        dx_total = P * (w_b * dx_b + w_o * dx_o)\n        dy_total = P * (w_b * dy_b + w_o * dy_o)\n        g = np.concatenate([dx_total, dy_total])\n        return f, g\n\n    def _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n        \"\"\"\n        Maximize sum(r) subject to:\n          r_i >= 0\n          r_i <= r_max[i] (if provided)\n          r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n          r_i + r_j <= dist(c_i,c_j) - eps_pair\n        \"\"\"\n        N = centers.shape[0]\n        x = centers[:, 0]\n        y = centers[:, 1]\n\n        # Build A_ub, b_ub\n        A_rows = []\n        b_vals = []\n\n        # Boundary constraints\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows.append(e.copy()); b_vals.append(x[i])\n            A_rows.append(e.copy()); b_vals.append(y[i])\n            A_rows.append(e.copy()); b_vals.append(1.0 - x[i])\n            A_rows.append(e.copy()); b_vals.append(1.0 - y[i])\n\n        # Pairwise constraints\n        d, _, _ = _pairwise_distances(centers)\n        for i in range(N):\n            for j in range(i+1, N):\n                e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n                A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n\n        # Optional upper bounds r_i <= r_max[i]\n        if r_max is not None:\n            for i in range(N):\n                e = np.zeros(N); e[i] = 1.0\n                A_rows.append(e); b_vals.append(r_max[i])\n\n        A_ub = np.array(A_rows)\n        b_ub = np.array(b_vals)\n\n        # Bounds on r: [0, 0.5]\n        bounds = [(0.0, 0.5) for _ in range(N)]\n        c = -np.ones(N)\n\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return np.clip(res.x, 0.0, 0.5)\n\n        # Retry with eps_pair = 0 to get a feasible base, then scale to satisfy eps_pair\n        b_vals2 = []\n        A_rows2 = []\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows2.append(e.copy()); b_vals2.append(x[i])\n            A_rows2.append(e.copy()); b_vals2.append(y[i])\n            A_rows2.append(e.copy()); b_vals2.append(1.0 - x[i])\n            A_rows2.append(e.copy()); b_vals2.append(1.0 - y[i])\n\n        for i in range(N):\n            for j in range(i+1, N):\n                e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n                A_rows2.append(e); b_vals2.append(d[i, j])\n\n        if r_max is not None:\n            for i in range(N):\n                e = np.zeros(N); e[i] = 1.0\n                A_rows2.append(e); b_vals2.append(r_max[i])\n\n        A_ub2 = np.array(A_rows2)\n        b_ub2 = np.array(b_vals2)\n\n        res2 = linprog(c, A_ub=A_ub2, b_ub=b_ub2, bounds=bounds, method='highs')\n        if not res2.success:\n            return np.zeros(N)\n\n        r_base = np.clip(res2.x, 0.0, 0.5)\n        d, _, _ = _pairwise_distances(centers)\n        denom = r_base[:, None] + r_base[None, :]\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = np.where(denom > 0, (d - eps_pair) / denom, np.inf)\n        iu = np.triu_indices(N, 1)\n        if ratio[iu].size > 0:\n            s_pairs = np.min(ratio[iu])\n            if not np.isfinite(s_pairs):\n                s_pairs = 1.0\n            s = min(1.0, s_pairs)\n        else:\n            s = 1.0\n        s = max(0.0, s)\n        r = s * r_base\n        return np.clip(r, 0.0, 0.5)\n\n    def _verify(centers, radii, tol_pair=1e-6):\n        N = len(radii)\n        x = centers[:, 0]\n        y = centers[:, 1]\n        if centers.shape != (N, 2):\n            return False\n        if np.any(radii < -1e-12):\n            return False\n        if np.any(x - radii < -1e-9):\n            return False\n        if np.any(y - radii < -1e-9):\n            return False\n        if np.any(x + radii > 1.0 + 1e-9):\n            return False\n        if np.any(y + radii > 1.0 + 1e-9):\n            return False\n        d, _, _ = _pairwise_distances(centers)\n        iu = np.triu_indices(N, 1)\n        lhs = radii[:, None] + radii[None, :]\n        viol = lhs[iu] - d[iu] + tol_pair\n        if np.any(viol > 1e-12):\n            return False\n        return True\n\n    def _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n        # rows: list of counts per row, centered with hex offset when fewer than max\n        assert sum(rows) == 26\n        max_cols = max(rows)\n        nrows = len(rows)\n        dx = (1.0 - 2*margin) / (max_cols - 1) if max_cols > 1 else 0.0\n        dy = (1.0 - 2*margin) / (nrows - 1) if nrows > 1 else 0.0\n        centers = []\n        rng = np.random.default_rng(seed)\n        for ri, cols in enumerate(rows):\n            y = margin + ri * dy if nrows > 1 else 0.5\n            if cols == max_cols:\n                startx = margin\n            else:\n                startx = margin + 0.5 * dx\n            if cols == 1:\n                startx = 0.5\n            for k in range(cols):\n                x = startx + (k * dx if cols > 1 else 0.0)\n                centers.append([x, y])\n        centers = np.array(centers, dtype=float)\n        # Jitter and clip\n        jitter = rng.normal(scale=jitter_scale, size=centers.shape)\n        centers = centers + jitter\n        centers = np.clip(centers, 1e-3, 1 - 1e-3)\n        return centers\n\n    def _multi_start_inits(N):\n        # Various row patterns summing to 26\n        patterns = [\n            [6, 5, 6, 5, 4],\n            [6, 5, 5, 5, 5],\n            [5, 6, 5, 5, 5],\n            [5, 5, 6, 5, 5],\n            [6, 6, 5, 5, 4],\n            [5, 6, 6, 5, 4],\n            [6, 5, 6, 4, 5],\n        ]\n        params = [\n            (0.03, 0.02), (0.04, 0.03), (0.05, 0.03),\n            (0.06, 0.02), (0.07, 0.03), (0.05, 0.04),\n        ]\n        inits = []\n        seed = 0\n        target_starts = 18\n        for pat in patterns:\n            for (m, j) in params:\n                inits.append(_hex_initial_centers_from_rows(pat, margin=m, jitter_scale=j, seed=seed))\n                seed += 1\n                if len(inits) >= target_starts:\n                    return inits\n        return inits\n\n    def _center_only_relax(centers, r_fixed, P=2000.0, w_b=1.0, w_o=1.0, iters=80):\n        N = centers.shape[0]\n        z0 = np.concatenate([centers[:, 0], centers[:, 1]])\n        bounds_xy = [(0.0, 1.0)] * (2 * N)\n        res = minimize(\n            fun=lambda zz: _objective_centers_only(zz, r_fixed, P, w_b, w_o, True),\n            x0=z0,\n            method='L-BFGS-B',\n            jac=True,\n            bounds=bounds_xy,\n            options={'maxiter': iters, 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 20}\n        )\n        z = res.x\n        centers_new = np.stack([z[:N], z[N:2*N]], axis=1)\n        return centers_new\n\n    # ---------------- Main optimization ----------------\n    N = 26\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n\n    # Penalty schedule and bounds\n    P_schedule = [8.0, 80.0, 800.0, 3000.0, 10000.0]\n    maxiter_stage = [90, 100, 110, 120, 130]\n    bounds = [(0.0, 1.0)] * (2*N) + [(0.0, 0.5)] * N\n\n    # Weighting of penalties\n    w_b = 1.0\n    w_o = 1.0\n\n    # Initializations\n    inits = _multi_start_inits(N)\n    if not inits:\n        inits = [_hex_initial_centers_from_rows([6,5,6,5,4], margin=0.05, jitter_scale=0.03, seed=42)]\n\n    for init_idx, centers0 in enumerate(inits):\n        x0 = centers0[:, 0]\n        y0 = centers0[:, 1]\n        # Start with small radii within local boundary\n        base_bound = np.minimum.reduce([x0, y0, 1 - x0, 1 - y0])\n        r0 = 0.05 * base_bound\n        z = np.concatenate([x0, y0, r0])\n\n        # Annealing optimization with periodic LP tightening and center-only relaxation\n        for si, P in enumerate(P_schedule):\n            res = minimize(\n                fun=lambda zz: _objective_and_grad(zz, N, P, w_b, w_o, True),\n                x0=z,\n                method='L-BFGS-B',\n                jac=True,\n                bounds=bounds,\n                options={'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 30}\n            )\n            z = res.x\n            centers_tmp = np.stack([z[:N], z[N:2*N]], axis=1)\n            r_cur = np.clip(z[2*N:], 0.0, 0.5)\n            # Conservative LP cap slightly above current radii\n            cap_factor = 1.08 if si < len(P_schedule) - 1 else 1.15\n            r_cap = np.minimum(0.5, cap_factor * np.maximum(1e-9, r_cur))\n            r_lp = _lp_feasibilize(centers_tmp, r_max=r_cap, eps_pair=1e-6)\n            # Small center-only relaxation to open space, then re-LP\n            centers_relaxed = _center_only_relax(centers_tmp, r_lp, P=max(1000.0, P), w_b=w_b, w_o=w_o, iters=70)\n            r_lp2 = _lp_feasibilize(centers_relaxed, r_max=None, eps_pair=1e-6)\n            z = np.concatenate([centers_relaxed[:, 0], centers_relaxed[:, 1], np.clip(r_lp2, 0.0, 0.5)])\n\n        # Final LP without cap to fully utilize geometry\n        centers_cur = np.stack([z[:N], z[N:2*N]], axis=1)\n        r_final = _lp_feasibilize(centers_cur, r_max=None, eps_pair=1e-6)\n\n        # Verify and update best\n        if _verify(centers_cur, r_final, tol_pair=1e-6):\n            s = float(np.sum(r_final))\n            if s > best['sum']:\n                best['centers'] = centers_cur.copy()\n                best['radii'] = r_final.copy()\n                best['sum'] = s\n        else:\n            # Try slight shrink and re-LP to fix tiny violations\n            d, _, _ = _pairwise_distances(centers_cur)\n            denom = r_final[:, None] + r_final[None, :]\n            with np.errstate(divide='ignore', invalid='ignore'):\n                ratio = np.where(denom > 0, (d - 1.0e-6) / denom, np.inf)\n            iu = np.triu_indices(N, 1)\n            s_pairs = np.min(ratio[iu]) if ratio[iu].size > 0 else 1.0\n            if not np.isfinite(s_pairs):\n                s_pairs = 1.0\n            s_pairs = max(0.0, min(1.0, s_pairs))\n            r_try = s_pairs * r_final\n            # Boundary scaling\n            bx = np.minimum.reduce([centers_cur[:,0], centers_cur[:,1], 1-centers_cur[:,0], 1-centers_cur[:,1]])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                scale_b = np.min(np.where(r_try > 0, bx / r_try, 1.0))\n            scale_b = min(1.0, scale_b if np.isfinite(scale_b) else 1.0)\n            r_try = scale_b * r_try\n            if _verify(centers_cur, r_try, tol_pair=1e-6):\n                s = float(np.sum(r_try))\n                if s > best['sum']:\n                    best['centers'] = centers_cur.copy()\n                    best['radii'] = r_try.copy()\n                    best['sum'] = s\n\n    # Fallback if nothing verified\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        r_fb = _lp_feasibilize(centers_fb, r_max=None, eps_pair=1e-6)\n        if not _verify(centers_fb, r_fb, tol_pair=1e-6):\n            r_fb = 0.95 * r_fb\n        best['centers'] = centers_fb\n        best['radii'] = np.clip(r_fb, 0.0, 0.5)\n        best['sum'] = float(np.sum(best['radii']))\n\n    # Ensure strict feasibility and final verify\n    radii_strict = _lp_feasibilize(best['centers'], r_max=None, eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        radii = radii_strict\n    else:\n        radii = best['radii']\n\n    centers = best['centers']\n    # Final hardening: if any violation persists, scale radii conservatively\n    if not _verify(centers, radii, tol_pair=1e-6):\n        d, _, _ = _pairwise_distances(centers)\n        denom = radii[:, None] + radii[None, :]\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio = np.where(denom > 0, (d - 1e-6) / denom, np.inf)\n        iu = np.triu_indices(N, 1)\n        s_pairs = np.min(ratio[iu]) if ratio[iu].size > 0 else 1.0\n        s_pairs = min(1.0, s_pairs if np.isfinite(s_pairs) else 1.0)\n        s_pairs = max(0.0, s_pairs)\n        radii = s_pairs * radii\n        bx = np.minimum.reduce([centers[:,0], centers[:,1], 1-centers[:,0], 1-centers[:,1]])\n        with np.errstate(divide='ignore', invalid='ignore'):\n            scale_b = np.min(np.where(radii > 0, bx / radii, 1.0))\n        scale_b = min(1.0, scale_b if np.isfinite(scale_b) else 1.0)\n        radii = scale_b * radii\n\n    radii = np.clip(radii, 0.0, 0.5)\n    sum_radii = float(np.sum(radii))\n    return centers.astype(float), radii.astype(float), sum_radii\n\n# trial_13_7 (score=2.6305903600884104)\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\n# Helper: pairwise distances and gradients components\ndef _pairwise_distances(centers):\n    \"\"\"\n    Returns:\n      d: (N,N) matrix of distances\n      dx: (N,N) matrix of x-differences\n      dy: (N,N) matrix of y-differences\n    \"\"\"\n    diff = centers[:, None, :] - centers[None, :, :]\n    d = np.sqrt(np.sum(diff**2, axis=2) + 0.0)\n    return d, diff[..., 0], diff[..., 1]\n\n# Global utilities used by the objective and gradient functions\ndef _objective_and_grad(z, N, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective: -sum(r) + P * (boundary_penalty + overlap_penalty)\n    z = [x_0..x_N-1, y_0..y_N-1, r_0..r_N-1]\n    Returns (f, grad)\n    \"\"\"\n    x = z[:N]\n    y = z[N:2*N]\n    r = z[2*N:]\n    tiny = 1e-12\n\n    # Boundary hinge penalties\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n    pen_b = 0.5 * (np.sum(h1*h1) + np.sum(h2*h2) + np.sum(h3*h3) + np.sum(h4*h4))\n\n    # Overlap penalties\n    centers = np.stack([x, y], axis=1)\n    d, dx, dy = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]\n    dxab = dx[iu]\n    dyab = dy[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    f = -np.sum(r) + P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients\n    dr_b = h1 + h2 + h3 + h4\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    dr_o = np.zeros(N, dtype=float)\n\n    # Gradients due to overlaps\n    coeff = hpos / d_safe\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx)\n    np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n    np.add.at(dr_o, iu[0], hpos)\n    np.add.at(dr_o, iu[1], hpos)\n\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    dr_total = -1.0 + P * (w_b * dr_b + w_o * dr_o)\n\n    grad = np.concatenate([dx_total, dy_total, dr_total])\n    return f, grad\n\ndef _objective_centers_only(z_xy, r_fixed, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective for optimizing centers only with fixed radii.\n    z_xy = [x_0..x_N-1, y_0..y_N-1]\n    Returns (f, g)\n    \"\"\"\n    N = r_fixed.shape[0]\n    x = z_xy[:N]\n    y = z_xy[N:2*N]\n    r = r_fixed\n    tiny = 1e-12\n\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n    pen_b = 0.5 * (np.sum(h1*h1) + np.sum(h2*h2) + np.sum(h3*h3) + np.sum(h4*h4))\n\n    centers = np.stack([x, y], axis=1)\n    d, dx, dy = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]\n    dxab = dx[iu]\n    dyab = dy[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    f = P * (w_b * pen_b + w_o * pen_o)\n\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    coeff = hpos / d_safe\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx)\n    np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    g = np.concatenate([dx_total, dy_total])\n    return f, g\n\ndef _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n    \"\"\"\n    Solve LP to maximize sum(r) with fixed centers.\n    Returns radii r (shape N,).\n    \"\"\"\n    N = centers.shape[0]\n    x, y = centers[:, 0], centers[:, 1]\n    A_rows, b_vals = [], []\n\n    # Boundary constraints: r_i <= boundary - eps\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows.extend([e.copy(), e.copy(), e.copy(), e.copy()])\n        b_vals.extend([x[i] - eps_pair, y[i] - eps_pair, 1.0 - x[i] - eps_pair, 1.0 - y[i] - eps_pair])\n\n    # Pairwise non-overlap: r_i + r_j <= d_ij - eps\n    d, _, _ = _pairwise_distances(centers)\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows.append(e); b_vals.append(r_max[i])\n\n    A_ub = np.array(A_rows)\n    b_ub = np.array(b_vals)\n\n    # Objective: maximize sum(r) -> minimize -sum(r)\n    res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=[(0.0, 0.5)]*N, method='highs')\n    if res.success:\n        return np.clip(res.x, 0.0, 0.5)\n\n    # Fallback: relax and retry\n    res2 = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub + eps_pair, bounds=[(0.0, 0.5)]*N, method='highs')\n    if not res2.success:\n        return np.zeros(N)\n    r_base = np.clip(res2.x, 0.0, 0.5)\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n        denom_pairs = r_base[:, None] + r_base[None, :]\n        ratio_pairs = np.where(denom_pairs > 1e-9, (d - eps_pair) / denom_pairs, np.inf)\n        iu = np.triu_indices(N, 1)\n        s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n\n        s_b_x_min = np.where(r_base > 1e-9, (x - eps_pair) / r_base, np.inf)\n        s_b_y_min = np.where(r_base > 1e-9, (y - eps_pair) / r_base, np.inf)\n        s_b_x_max = np.where(r_base > 1e-9, (1.0 - x - eps_pair) / r_base, np.inf)\n        s_b_y_max = np.where(r_base > 1e-9, (1.0 - y - eps_pair) / r_base, np.inf)\n        s_boundary = np.min([s_b_x_min, s_b_y_min, s_b_x_max, s_b_y_max])\n\n    s = min(s_pairs if np.isfinite(s_pairs) else 1.0, s_boundary if np.isfinite(s_boundary) else 1.0)\n    return np.clip(max(0.0, min(1.0, s)) * r_base, 0.0, 0.5)\n\ndef _verify(centers, radii, tol_pair=1e-6):\n    \"\"\"\n    Strict feasibility check:\n      - centers inside unit square with radii\n      - no overlaps (r_i + r_j <= d_ij - tol_pair)\n    \"\"\"\n    N = len(radii)\n    x, y = centers[:, 0], centers[:, 1]\n    if centers.shape != (N, 2) or np.any(radii < -1e-12): \n        return False\n    if np.any(x - radii < tol_pair) or np.any(y - radii < tol_pair): \n        return False\n    if np.any(x + radii > 1.0 - tol_pair) or np.any(y + radii > 1.0 - tol_pair): \n        return False\n    d, _, _ = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    if np.any((radii[iu[0]] + radii[iu[1]]) - d[iu] + tol_pair > 1e-12): \n        return False\n    return True\n\ndef _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n    \"\"\"Generate hex-like grid centers with given row counts.\"\"\"\n    assert sum(rows) == 26\n    max_cols, nrows = max(rows), len(rows)\n    dx = (1.0 - 2*margin) / (max_cols - 1) if max_cols > 1 else 0.0\n    dy = (1.0 - 2*margin) / (nrows - 1) if nrows > 1 else 0.0\n    centers = []\n    rng = np.random.default_rng(seed)\n    for ri, cols in enumerate(rows):\n        y = margin + ri * dy if nrows > 1 else 0.5\n        row_width = (cols - 1) * dx\n        startx = 0.5 - row_width / 2.0 + (dx / 2.0 if ri % 2 == 1 else 0.0)\n        for k in range(cols):\n            centers.append([startx + k * dx, y])\n    centers = np.array(centers) + rng.normal(scale=jitter_scale, size=(sum(rows), 2))\n    return np.clip(centers, 1e-3, 1 - 1e-3)\n\ndef _multi_start_inits(N):\n    \"\"\"Return a list of diverse initial center configurations for N circles.\"\"\"\n    patterns = [[6,5,6,5,4], [6,5,5,5,5], [5,6,5,5,5], [5,5,6,5,5], [6,6,5,5,4], [5,6,6,5,4]]\n    params = [(0.04, 0.03), (0.05, 0.03), (0.06, 0.02), (0.05, 0.04)]\n    inits = []\n    for i, pat in enumerate(patterns):\n        for j, (m, jit) in enumerate(params):\n            inits.append(_hex_initial_centers_from_rows(pat, margin=m, jitter_scale=jit, seed=i*10+j))\n    return inits\n\ndef _center_only_relax(centers, r_fixed, P=2000.0, w_b=1.0, w_o=1.0, iters=80):\n    \"\"\"Relax centers with fixed radii using L-BFGS-B.\"\"\"\n    N = centers.shape[0]\n    res = minimize(\n        fun=lambda z: _objective_centers_only(z, r_fixed, P, w_b, w_o),\n        jac=True,\n        x0=np.concatenate([centers[:, 0], centers[:, 1]]),\n        method='L-BFGS-B',\n        bounds=[(0.0, 1.0)] * (2*N),\n        options={'maxiter': iters, 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 20}\n    )\n    return np.stack([res.x[:N], res.x[N:2*N]], axis=1)\n\ndef construct_packing():\n    \"\"\"\n    Construct a packing of 26 circles inside the unit square maximizing sum of radii.\n    Returns:\n      centers: (26,2) ndarray\n      radii: (26,) ndarray\n      sum_radii: float\n    \"\"\"\n    N = 26\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n\n    # Stage configuration similar to reference approach\n    P_schedule = [8.0, 80.0, 800.0, 3000.0, 10000.0, 20000.0]\n    maxiter_stage = [90, 100, 110, 120, 130, 140]\n    bounds = [(0.0, 1.0)] * (2*N) + [(0.0, 0.5)] * N\n\n    inits = _multi_start_inits(N)\n\n    for centers0 in inits:\n        x0, y0 = centers0[:, 0], centers0[:, 1]\n        base_bound = np.minimum.reduce([x0, y0, 1 - x0, 1 - y0])\n        r0 = 0.05 * base_bound\n        z = np.concatenate([x0, y0, r0])\n\n        for si, P in enumerate(P_schedule):\n            res = minimize(\n                fun=lambda zz: _objective_and_grad(zz, N, P),\n                x0=z,\n                jac=True,\n                method='L-BFGS-B',\n                bounds=bounds,\n                options={'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 30}\n            )\n            z = res.x\n            centers_tmp = np.stack([z[:N], z[N:2*N]], axis=1)\n            r_cur = np.clip(z[2*N:], 0.0, 0.5)\n\n            cap_factor = 1.08 if si < len(P_schedule) - 1 else 1.15\n            r_cap = np.minimum(0.5, cap_factor * np.maximum(1e-9, r_cur))\n            r_lp = _lp_feasibilize(centers_tmp, r_max=r_cap, eps_pair=1e-6)\n\n            centers_relaxed = _center_only_relax(centers_tmp, r_lp, P=max(1000.0, P), iters=70)\n\n            r_lp2 = _lp_feasibilize(centers_relaxed, r_max=None, eps_pair=1e-6)\n\n            z = np.concatenate([centers_relaxed[:, 0], centers_relaxed[:, 1], np.clip(r_lp2, 0.0, 0.5)])\n\n        centers_final = np.stack([z[:N], z[N:2*N]], axis=1)\n        r_final = _lp_feasibilize(centers_final, r_max=None, eps_pair=1e-6)\n\n        if _verify(centers_final, r_final, tol_pair=1e-6):\n            s = float(np.sum(r_final))\n            if s > best['sum']:\n                best.update({'centers': centers_final.copy(), 'radii': r_final.copy(), 'sum': s})\n\n    # If nothing found, fall back to a deterministic hex-like layout\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        radii_fb = _lp_feasibilize(centers_fb, eps_pair=1e-6)\n        return centers_fb, np.clip(radii_fb, 0.0, 0.5), float(np.sum(radii_fb))\n\n    # Final hardening to guarantee strict feasibility\n    radii_strict = _lp_feasibilize(best['centers'], eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        radii = radii_strict\n    else:\n        radii = best['radii']\n\n    centers = best['centers']\n    radii = np.clip(radii, 0.0, 0.5)\n    sum_radii = float(np.sum(radii))\n\n    return centers.astype(float), radii.astype(float), sum_radii\n\n# trial_11_7 (score=2.6301918355665412)\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef _pairwise_distances(centers):\n    diff = centers[:, None, :] - centers[None, :, :]\n    d = np.sqrt(np.sum(diff**2, axis=2))\n    return d, diff[..., 0], diff[..., 1]\n\ndef _compute_dynamic_weights(centers, tiny=1e-12, gamma_density=0.8, gamma_edge=0.6):\n    \"\"\"\n    Compute per-circle weights w_i based on local density and edge proximity.\n    Returns w (N,) with mean ~1.\n    \"\"\"\n    N = centers.shape[0]\n    x = centers[:, 0]\n    y = centers[:, 1]\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    # For density: use mean distance to k nearest neighbors (k = min(6, N-1))\n    k = min(6, N-1)\n    if N <= 1:\n        density = np.ones(N)\n    else:\n        sorted_d = np.sort(d + np.eye(N) * 1e9, axis=1)  # ignore self\n        knn_mean = np.mean(sorted_d[:, :k], axis=1)\n        density_raw = 1.0 / (knn_mean + tiny)\n        # normalize to mean 1\n        density = density_raw / (np.mean(density_raw) + tiny)\n    # Edge proximity: smaller proximity => larger edge factor\n    proximity = np.minimum.reduce([x, y, 1.0 - x, 1.0 - y])\n    edge_factor = 1.0 - np.clip(4.0 * proximity, 0.0, 1.0)  # near center -> 0, near edge-> up to 1\n    w = 1.0 + gamma_density * (density - 1.0) + gamma_edge * edge_factor\n    # Clip to reasonable bounds\n    w = np.clip(w, 0.2, 5.0)\n    # Normalize to mean 1 to keep penalty scale stable\n    w = w / (np.mean(w) + tiny)\n    return w\n\ndef _objective_and_grad(z, N, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Joint objective and gradient for (x,y,r) using dynamic per-circle weights.\n    Returns (f, grad) where grad is the gradient vector.\n    \"\"\"\n    x = z[:N]\n    y = z[N:2*N]\n    r = z[2*N:]\n    tiny = 1e-12\n\n    centers = np.stack([x, y], axis=1)\n    # dynamic per-circle weights\n    w_vec = _compute_dynamic_weights(centers, tiny=tiny, gamma_density=0.8, gamma_edge=0.65)  # tuned\n    # Boundary penalties: hinges for r - x, r - y, r + x - 1, r + y - 1\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n    # per-circle boundary weight\n    w_b_vec = 1.0 + 0.4 * (1.0 - np.clip(4.0 * np.minimum.reduce([x, y, 1.0 - x, 1.0 - y]), 0.0, 1.0))\n    w_b_vec = w_b_vec * w_vec\n    pen_b_terms = 0.5 * (h1*h1 + h2*h2 + h3*h3 + h4*h4) * w_b_vec\n    pen_b = np.sum(pen_b_terms)\n\n    # Overlap penalties\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    # pairwise weight w_ij = w_i * w_j scaled by global w_o\n    w_i = w_vec[iu[0]]\n    w_j = w_vec[iu[1]]\n    w_pair = w_o * (w_i * w_j)\n    pen_o = 0.5 * np.sum(w_pair * (hpos * hpos))\n\n    f = -np.sum(r) + P * (w_b * pen_b + pen_o)\n\n    # Gradients\n    # Boundary gradients\n    dr_b = (h1 + h2 + h3 + h4) * w_b_vec\n    dx_b = (-h1 + h3) * w_b_vec\n    dy_b = (-h2 + h4) * w_b_vec\n\n    # Overlap gradients\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    dr_o = np.zeros(N, dtype=float)\n\n    coeff = hpos / d_safe  # h / d\n    # Multiply coeff by pairwise weight and by 1 (for squared hinge derivative)\n    coeff_w = coeff * w_pair\n    cx = coeff_w * dxab\n    cy = coeff_w * dyab\n    # center contributions\n    np.add.at(dx_o, iu[0], -cx)\n    np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n    # radii contributions: derivative of 0.5 * w_pair * h^2 wrt r_a is w_pair * hpos\n    np.add.at(dr_o, iu[0], w_pair * hpos)\n    np.add.at(dr_o, iu[1], w_pair * hpos)\n\n    dx_total = P * (w_b * dx_b + dx_o)\n    dy_total = P * (w_b * dy_b + dy_o)\n    dr_total = -1.0 + P * (w_b * dr_b + dr_o)\n\n    grad = np.concatenate([dx_total, dy_total, dr_total])\n    return float(f), grad\n\ndef _objective_centers_only(z_xy, r_fixed, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective and gradient for centers only with fixed radii.\n    Returns (f, grad_xy).\n    \"\"\"\n    N = r_fixed.shape[0]\n    x = z_xy[:N]\n    y = z_xy[N:2*N]\n    r = r_fixed\n    tiny = 1e-12\n\n    centers = np.stack([x, y], axis=1)\n    w_vec = _compute_dynamic_weights(centers, tiny=tiny, gamma_density=0.8, gamma_edge=0.65)\n    # Boundary\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n    w_b_vec = 1.0 + 0.4 * (1.0 - np.clip(4.0 * np.minimum.reduce([x, y, 1.0 - x, 1.0 - y]), 0.0, 1.0))\n    w_b_vec = w_b_vec * w_vec\n    pen_b_terms = 0.5 * (h1*h1 + h2*h2 + h3*h3 + h4*h4) * w_b_vec\n    pen_b = np.sum(pen_b_terms)\n\n    # Overlap\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    w_i = w_vec[iu[0]]\n    w_j = w_vec[iu[1]]\n    w_pair = w_o * (w_i * w_j)\n    pen_o = 0.5 * np.sum(w_pair * (hpos * hpos))\n\n    f = P * (w_b * pen_b + pen_o)\n\n    # Gradients wrt centers\n    dx_b = (-h1 + h3) * w_b_vec\n    dy_b = (-h2 + h4) * w_b_vec\n\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    coeff = hpos / d_safe\n    coeff_w = coeff * w_pair\n    cx = coeff_w * dxab\n    cy = coeff_w * dyab\n    np.add.at(dx_o, iu[0], -cx)\n    np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n\n    dx_total = P * (w_b * dx_b + dx_o)\n    dy_total = P * (w_b * dy_b + dy_o)\n    g = np.concatenate([dx_total, dy_total])\n    return float(f), g\n\ndef _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n    \"\"\"\n    Maximize sum(r) for fixed centers using linear programming.\n    \"\"\"\n    N = centers.shape[0]\n    x = centers[:, 0]\n    y = centers[:, 1]\n\n    A_rows = []\n    b_vals = []\n\n    # Boundary constraints: r_i <= x_i - eps_pair, etc.\n    for i in range(N):\n        e = np.zeros(N)\n        e[i] = 1.0\n        A_rows.append(e.copy()); b_vals.append(x[i] - eps_pair)\n        A_rows.append(e.copy()); b_vals.append(y[i] - eps_pair)\n        A_rows.append(e.copy()); b_vals.append(1.0 - x[i] - eps_pair)\n        A_rows.append(e.copy()); b_vals.append(1.0 - y[i] - eps_pair)\n\n    # Pairwise overlap constraints\n    d, _, _ = _pairwise_distances(centers)\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N)\n            e[i] = 1.0; e[j] = 1.0\n            A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n\n    # Optional per-variable caps\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows.append(e); b_vals.append(r_max[i])\n\n    if len(A_rows) == 0:\n        A_ub = None\n        b_ub = None\n    else:\n        A_ub = np.vstack(A_rows)\n        b_ub = np.array(b_vals)\n\n    bounds = [(0.0, 0.5)] * N\n    c = -np.ones(N)  # maximize sum(r) -> minimize -sum(r)\n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    except Exception:\n        res = None\n\n    if res is not None and res.success:\n        return np.clip(res.x, 0.0, 0.5)\n\n    # Fallback: try without eps_pair (less strict)\n    A_rows2 = []\n    b_vals2 = []\n    for i in range(N):\n        e = np.zeros(N)\n        e[i] = 1.0\n        A_rows2.append(e.copy()); b_vals2.append(x[i])\n        A_rows2.append(e.copy()); b_vals2.append(y[i])\n        A_rows2.append(e.copy()); b_vals2.append(1.0 - x[i])\n        A_rows2.append(e.copy()); b_vals2.append(1.0 - y[i])\n\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows2.append(e); b_vals2.append(d[i, j])\n\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows2.append(e); b_vals2.append(r_max[i])\n\n    if len(A_rows2) == 0:\n        A_ub2 = None\n        b_ub2 = None\n    else:\n        A_ub2 = np.vstack(A_rows2)\n        b_ub2 = np.array(b_vals2)\n\n    try:\n        res2 = linprog(c, A_ub=A_ub2, b_ub=b_ub2, bounds=bounds, method='highs')\n    except Exception:\n        res2 = None\n\n    if res2 is None or not res2.success:\n        return np.zeros(N)\n\n    r_base = np.clip(res2.x, 0.0, 0.5)\n    # scale down to satisfy eps_pair\n    d, _, _ = _pairwise_distances(centers)\n    denom_pairs = r_base[:, None] + r_base[None, :]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        ratio_pairs = np.where(denom_pairs > 1e-9, (d - eps_pair) / denom_pairs, np.inf)\n    iu = np.triu_indices(N, 1)\n    s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n    if not np.isfinite(s_pairs):\n        s_pairs = 1.0\n    s_pairs = max(0.0, min(1.0, s_pairs))\n    # boundary scaling\n    with np.errstate(divide='ignore', invalid='ignore'):\n        s_x_min = np.where(r_base > 1e-9, (x - eps_pair) / r_base, np.inf)\n        s_y_min = np.where(r_base > 1e-9, (y - eps_pair) / r_base, np.inf)\n        s_x_max = np.where(r_base > 1e-9, (1.0 - x - eps_pair) / r_base, np.inf)\n        s_y_max = np.where(r_base > 1e-9, (1.0 - y - eps_pair) / r_base, np.inf)\n    s_boundary = np.min([np.min(s_x_min), np.min(s_y_min), np.min(s_x_max), np.min(s_y_max)])\n    if not np.isfinite(s_boundary):\n        s_boundary = 1.0\n    s_boundary = max(0.0, min(1.0, s_boundary))\n    s = min(s_pairs, s_boundary)\n    r = s * r_base\n    return np.clip(r, 0.0, 0.5)\n\ndef _verify(centers, radii, tol_pair=1e-6):\n    N = len(radii)\n    if centers.shape != (N, 2):\n        return False\n    if np.any(radii < -1e-12):\n        return False\n    x = centers[:, 0]\n    y = centers[:, 1]\n    # boundary: x - r >= tol_pair, etc.\n    if np.any(x - radii < tol_pair):\n        return False\n    if np.any(y - radii < tol_pair):\n        return False\n    if np.any(x + radii > 1.0 - tol_pair):\n        return False\n    if np.any(y + radii > 1.0 - tol_pair):\n        return False\n    # pairwise\n    d, _, _ = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    lhs = radii[:, None] + radii[None, :]\n    viol = lhs[iu] - d[iu] + tol_pair\n    if np.any(viol > 1e-12):\n        return False\n    return True\n\ndef _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n    assert sum(rows) == 26\n    max_cols = max(rows)\n    nrows = len(rows)\n    dx_base = (1.0 - 2.0 * margin) / (max_cols - 1) if max_cols > 1 else 0.0\n    dy_base = (1.0 - 2.0 * margin) / (nrows - 1) if nrows > 1 else 0.0\n\n    centers = []\n    rng = np.random.default_rng(seed)\n    for ri, cols in enumerate(rows):\n        y = margin + ri * dy_base if nrows > 1 else 0.5\n        if cols > 1:\n            row_width = (cols - 1) * dx_base\n            startx = 0.5 - row_width / 2.0\n            if ri % 2 == 1:\n                startx += dx_base / 2.0\n        else:\n            startx = 0.5\n        for k in range(cols):\n            x = startx + (k * dx_base if cols > 1 else 0.0)\n            centers.append([x, y])\n    centers = np.array(centers)\n    jitter = rng.normal(scale=jitter_scale, size=centers.shape)\n    centers = centers + jitter\n    centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n    return centers\n\ndef _multi_start_inits(N, max_inits=32):\n    patterns = [\n        [6,5,6,5,4], [6,5,5,5,5], [5,6,5,5,5],\n        [5,5,6,5,5], [6,6,5,5,4], [5,6,6,5,4],\n        [6,5,6,4,5], [5,5,5,5,6], [4,5,6,5,6],\n        [5,4,5,6,6], [5,6,4,6,5]\n    ]\n    params = [\n        (0.03, 0.02), (0.04, 0.03), (0.05, 0.03),\n        (0.06, 0.02), (0.07, 0.03), (0.05, 0.04),\n        (0.04, 0.025), (0.055, 0.035), (0.065, 0.025)\n    ]\n    inits = []\n    seed = 1\n    for pat in patterns:\n        for (m, j) in params:\n            inits.append(_hex_initial_centers_from_rows(pat, margin=m, jitter_scale=j, seed=seed))\n            seed += 1\n            if len(inits) >= max_inits:\n                break\n        if len(inits) >= max_inits:\n            break\n    # Add some edge/corner heavy seeds: 8 near corners/edges + interior\n    if len(inits) < max_inits:\n        rng = np.random.default_rng(999)\n        # Construct 8 near corners/edges\n        edge_positions = [\n            [0.02, 0.02], [0.02, 0.5], [0.02, 0.98], [0.5, 0.02],\n            [0.5, 0.98], [0.98, 0.02], [0.98, 0.5], [0.98, 0.98]\n        ]\n        # remaining 18 as hex grid in interior\n        interior = _hex_initial_centers_from_rows([6,6,6], margin=0.2, jitter_scale=0.03, seed=1234)\n        # pick 18 from interior (it gives 18)\n        if interior.shape[0] >= 18:\n            interior = interior[:18]\n        else:\n            # replicate some if needed (unlikely)\n            extra = np.tile(interior, (int(np.ceil(18 / interior.shape[0])), 1))[:18]\n            interior = extra\n        centers = np.vstack([np.array(edge_positions), interior])\n        centers += rng.normal(scale=0.01, size=centers.shape)\n        centers = np.clip(centers, 1e-3, 1 - 1e-3)\n        inits.append(centers)\n    # Ensure all inits have N points\n    final_inits = []\n    for arr in inits[:max_inits]:\n        if arr.shape[0] != N:\n            continue\n        final_inits.append(arr)\n    # If none or less than desired, add deterministic fallback\n    while len(final_inits) < 4:\n        final_inits.append(_hex_initial_centers_from_rows([6,5,6,5,4], margin=0.05, jitter_scale=0.02, seed=42+len(final_inits)))\n    return final_inits\n\ndef _center_only_relax(centers, r_fixed, P=2000.0, w_b=1.0, w_o=1.0, iters=80):\n    N = centers.shape[0]\n    z0 = np.concatenate([centers[:, 0], centers[:, 1]])\n    bounds_xy = [(0.0, 1.0)] * (2 * N)\n    res = minimize(\n        fun=lambda zz: _objective_centers_only(zz, r_fixed, P, w_b, w_o),\n        x0=z0,\n        method='L-BFGS-B',\n        jac=True,\n        bounds=bounds_xy,\n        options={'maxiter': iters, 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 20}\n    )\n    z = res.x\n    centers_new = np.stack([z[:N], z[N:2*N]], axis=1)\n    centers_new = np.clip(centers_new, 1e-6, 1.0 - 1e-6)\n    return centers_new\n\ndef construct_packing():\n    N = 26\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n\n    P_schedule = [8.0, 80.0, 800.0, 3000.0]  # moderate schedule to limit runtime\n    maxiter_stage = [90, 100, 110, 120]\n    bounds = [(0.0, 1.0)] * (2 * N) + [(0.0, 0.5)] * N\n\n    inits = _multi_start_inits(N, max_inits=32)\n    if not inits:\n        inits = [_hex_initial_centers_from_rows([6,5,6,5,4], margin=0.05, jitter_scale=0.03, seed=42)]\n\n    for init_idx, centers0 in enumerate(inits):\n        x0 = centers0[:, 0].copy()\n        y0 = centers0[:, 1].copy()\n        base_bound = np.minimum.reduce([x0, y0, 1 - x0, 1 - y0])\n        # initialize radii as fraction of local boundary-clearance\n        r0 = 0.08 * base_bound\n        # small randomization for radii to diversify\n        rng = np.random.default_rng(1000 + init_idx)\n        r0 = r0 * (1.0 + 0.05 * rng.normal(size=r0.shape))\n        r0 = np.clip(r0, 1e-6, 0.5)\n        z = np.concatenate([x0, y0, r0])\n\n        # Annealing optimization loop\n        for si, P in enumerate(P_schedule):\n            # Joint optimization of centers & radii\n            try:\n                res = minimize(\n                    fun=lambda zz: _objective_and_grad(zz, N, P, 1.0, 1.0),\n                    x0=z,\n                    method='L-BFGS-B',\n                    jac=True,\n                    bounds=bounds,\n                    options={'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 25}\n                )\n                z = res.x\n            except Exception:\n                # If optimizer fails, keep previous z\n                pass\n\n            centers_tmp = np.stack([z[:N], z[N:2*N]], axis=1)\n            centers_tmp = np.clip(centers_tmp, 1e-6, 1.0 - 1e-6)\n            r_cur = np.clip(z[2*N:], 0.0, 0.5)\n\n            # LP Feasibilization with cap to avoid overgrowth\n            cap_factor = 1.07 if si < len(P_schedule) - 1 else 1.12\n            r_cap = np.minimum(0.5, cap_factor * np.maximum(1e-9, r_cur))\n            r_lp = _lp_feasibilize(centers_tmp, r_max=r_cap, eps_pair=1e-6)\n\n            # Center-only relaxation with fixed LP radii\n            centers_relaxed = _center_only_relax(centers_tmp, r_lp, P=max(1000.0, P), w_b=1.0, w_o=1.0, iters=70)\n\n            # Final LP for this stage without cap\n            r_lp2 = _lp_feasibilize(centers_relaxed, r_max=None, eps_pair=1e-6)\n\n            z = np.concatenate([centers_relaxed[:, 0], centers_relaxed[:, 1], np.clip(r_lp2, 0.0, 0.5)])\n\n        # Final LP after annealing\n        centers_final_opt = np.stack([z[:N], z[N:2*N]], axis=1)\n        centers_final_opt = np.clip(centers_final_opt, 1e-6, 1.0 - 1e-6)\n        r_final = _lp_feasibilize(centers_final_opt, r_max=None, eps_pair=1e-6)\n\n        if _verify(centers_final_opt, r_final, tol_pair=1e-6):\n            s = float(np.sum(r_final))\n            if s > best['sum']:\n                best['centers'] = centers_final_opt.copy()\n                best['radii'] = r_final.copy()\n                best['sum'] = s\n        else:\n            # Try scaling down radii to achieve strict feasibility\n            d, _, _ = _pairwise_distances(centers_final_opt)\n            denom = r_final[:, None] + r_final[None, :]\n            with np.errstate(divide='ignore', invalid='ignore'):\n                ratio_pairs = np.where(denom > 1e-9, (d - 1.0e-6) / denom, np.inf)\n            iu = np.triu_indices(N, 1)\n            s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n            if not np.isfinite(s_pairs):\n                s_pairs = 1.0\n            s_pairs = max(0.0, min(1.0, s_pairs))\n            bx = np.minimum.reduce([centers_final_opt[:,0], centers_final_opt[:,1], 1-centers_final_opt[:,0], 1-centers_final_opt[:,1]])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                scale_b = np.min(np.where(r_final > 1e-9, (bx - 1e-6) / r_final, 1.0))\n            scale_b = min(1.0, scale_b if np.isfinite(scale_b) else 1.0)\n            scale_b = max(0.0, scale_b)\n            r_try = min(s_pairs, scale_b) * r_final\n            r_try = np.clip(r_try, 0.0, 0.5)\n            if _verify(centers_final_opt, r_try, tol_pair=1e-6):\n                s = float(np.sum(r_try))\n                if s > best['sum']:\n                    best['centers'] = centers_final_opt.copy()\n                    best['radii'] = r_try.copy()\n                    best['sum'] = s\n\n    # Fallback if none found\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        r_fb = _lp_feasibilize(centers_fb, r_max=None, eps_pair=1e-6)\n        if not _verify(centers_fb, r_fb, tol_pair=1e-6):\n            r_fb = 0.95 * r_fb\n        best['centers'] = centers_fb\n        best['radii'] = np.clip(r_fb, 0.0, 0.5)\n        best['sum'] = float(np.sum(best['radii']))\n\n    # Final strict LP to harden solution\n    radii_strict = _lp_feasibilize(best['centers'], r_max=None, eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        radii = radii_strict\n    else:\n        radii = best['radii']\n        if not _verify(best['centers'], radii, tol_pair=1e-6):\n            d, _, _ = _pairwise_distances(best['centers'])\n            denom = radii[:, None] + radii[None, :]\n            with np.errstate(divide='ignore', invalid='ignore'):\n                ratio_pairs = np.where(denom > 1e-9, (d - 1e-6) / denom, np.inf)\n            iu = np.triu_indices(N, 1)\n            s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n            s_pairs = min(1.0, s_pairs if np.isfinite(s_pairs) else 1.0)\n            s_pairs = max(0.0, s_pairs)\n            bx = np.minimum.reduce([best['centers'][:,0], best['centers'][:,1], 1-best['centers'][:,0], 1-best['centers'][:,1]])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                scale_b = np.min(np.where(radii > 1e-9, (bx - 1e-6) / radii, 1.0))\n            scale_b = min(1.0, scale_b if np.isfinite(scale_b) else 1.0)\n            scale_b = max(0.0, scale_b)\n            radii = min(s_pairs, scale_b) * radii\n            radii = np.clip(radii, 0.0, 0.5)\n\n    centers = best['centers'].astype(float)\n    radii = np.clip(radii.astype(float), 0.0, 0.5)\n    sum_radii = float(np.sum(radii))\n    # Final verification; if it fails, shrink uniformly until it passes (very small loop)\n    if not _verify(centers, radii, tol_pair=1e-6):\n        factor = 0.999\n        for _ in range(2000):\n            radii = radii * factor\n            if _verify(centers, radii, tol_pair=1e-6):\n                break\n    return centers, radii, float(np.sum(radii))\n\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nYou must output a single Python code block and nothing else.\nImplement construct_packing() as the only required entry point (optional: run_packing()).\nReturn (centers, radii, sum_radii) where:\n- centers: np.ndarray of shape (26, 2), within [0,1]^2\n- radii:   np.ndarray of shape (26,), all >= 0\n- sum_radii: float sum of radii\nFeasibility constraints (strict):\n- Each circle inside the unit square\n- No overlaps: for all i<j, r_i + r_j <= ||c_i - c_j|| - 1e-6\nAllowed modules: numpy, scipy\nRuntime limit: aim < 270s\nNo prints or extra output.\n\nKey implementation details:\n- Use a final LP to maximize sum(r) given fixed centers with strict feasibility margin 1e-6:\n  maximize sum r_i\n  subject to  r_i >= 0\n              r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n              r_i + r_j <= dist_ij - 1e-6  for all i<j\n  Use scipy.optimize.linprog (method='highs'). Do NOT cap radii by current values in the final LP.\n- If you use penalties/gradients for centers/radii, vectorize them fully and apply epsilon only in denominators (no bias in the penalty itself).\n- Prefer multi-start seeding (triangular/hex and edge/corner-biased) and strict final LP feasibilization.\n- Deterministic seed (e.g., np.random.seed(42)).\n\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.special import expit, logit\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 non-overlapping circles into the unit square [0,1]^2.\n    Returns (centers, radii, sum_radii)\n      - centers: (26,2) ndarray with coordinates in [0,1]\n      - radii: (26,) ndarray, non-negative\n      - sum_radii: float sum of radii\n\n    Approach:\n      - Optimize centers only in unconstrained z-space via logistic mapping centers = sigmoid(z)\n      - Penalized objective (centers only) encourages pairwise separation and distance from boundaries\n        using smooth vectorized repulsive potentials. Analytic gradients computed and chain-ruled\n        through the sigmoid mapping.\n      - Multi-start optimization (several hex/row patterns) with an annealing schedule on penalty\n        strength. L-BFGS-B optimizes z for each stage.\n      - Final strict LP (no caps) maximizes sum(r) for the returned centers with eps_pair = 1e-6.\n      - If LP fails, fallback attempts use eps=0 then a conservative scaling to guarantee feasibility.\n    \"\"\"\n    np.random.seed(42)\n    N = 26\n\n    # ---------------- Utilities ----------------\n    def _pairwise_diffs_and_dist(centers):\n        # centers: (N,2)\n        diff = centers[:, None, :] - centers[None, :, :]  # (N,N,2)\n        d = np.sqrt(np.sum(diff * diff, axis=2))  # (N,N)\n        return diff, d\n\n    def _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n        assert sum(rows) == N\n        max_cols = max(rows)\n        nrows = len(rows)\n        dx_base = (1.0 - 2 * margin) / (max_cols - 1) if max_cols > 1 else 0.0\n        dy_base = (1.0 - 2 * margin) / (nrows - 1) if nrows > 1 else 0.0\n\n        centers = []\n        rng = np.random.default_rng(seed)\n        for ri, cols in enumerate(rows):\n            y = margin + ri * dy_base if nrows > 1 else 0.5\n            if cols > 1:\n                row_width = (cols - 1) * dx_base\n                startx = 0.5 - row_width / 2.0\n                if ri % 2 == 1:\n                    startx += dx_base / 2.0\n            else:\n                startx = 0.5\n            for k in range(cols):\n                x = startx + (k * dx_base if cols > 1 else 0.0)\n                centers.append([x, y])\n        centers = np.array(centers, dtype=float)\n        jitter = rng.normal(scale=jitter_scale, size=centers.shape)\n        centers = centers + jitter\n        centers = np.clip(centers, 1e-4, 1.0 - 1e-4)\n        return centers\n\n    def _multi_start_inits():\n        patterns = [\n            [6, 5, 6, 5, 4],\n            [6, 5, 5, 5, 5],\n            [5, 6, 5, 5, 5],\n            [6, 6, 6, 4, 4],\n            [7, 6, 6, 7],  # larger rows (will be jitter-clipped)\n            [5, 5, 5, 5, 6],\n            [6, 6, 5, 4, 5]\n        ]\n        params = [\n            (0.03, 0.02),\n            (0.05, 0.03),\n            (0.07, 0.03),\n            (0.045, 0.02)\n        ]\n        inits = []\n        seed = 0\n        for pat in patterns:\n            for (m, j) in params:\n                try:\n                    c = _hex_initial_centers_from_rows(pat, margin=m, jitter_scale=j, seed=seed)\n                    if c.shape[0] == N:\n                        inits.append(c)\n                except Exception:\n                    pass\n                seed += 1\n                if len(inits) >= 10:\n                    return inits\n        # If not enough, fill with repeated canonical pattern with varied jitter\n        while len(inits) < 8:\n            inits.append(_hex_initial_centers_from_rows([6,5,6,5,4], margin=0.05, jitter_scale=0.02, seed=100+len(inits)))\n        return inits\n\n    # ---------------- Penalized objective (centers only) ----------------\n    # We map z (unbounded) to centers via sigmoid: c = expit(z)\n    # Objective (to minimize): P * (w_o * pairwise_repulsion + w_b * boundary_repulsion)\n    # Pairwise repulsion: sum_{i<j} 1 / (d_ij + delta)^{p}\n    # Boundary repulsion: sum_i [ 1/(x_i+delta)^p + 1/(y_i+delta)^p + 1/(1-x_i+delta)^p + 1/(1-y_i+delta)^p ]\n    # Gradients are computed analytically and then chain-ruled by dc/dz = c*(1-c).\n\n    def _objective_and_grad_z(z, P=100.0, w_o=1.0, w_b=1.0, p=2, delta=0.02, delta_b=0.02):\n        # z: (2N,) vector representing unconstrained coordinates; returns (f, grad_z)\n        c = expit(z)  # (2N,) values in (0,1)\n        centers = c.reshape(2, N).T  # shape (N,2) (we expect z arranged [x0..xN-1, y0..yN-1])\n        # Note: ensure we accept either ordering; above we assume first N entries are x then N y.\n        # But in our usage we will arrange z as [x0..xN-1, y0..yN-1] as typical.\n\n        # Pairwise\n        diff, d = _pairwise_diffs_and_dist(centers)  # diff (N,N,2), d (N,N)\n        tiny = 1e-12\n        iu = np.triu_indices(N, 1)\n        dij = d[iu]  # (M,)\n        diffij = diff[iu]  # (M,2)\n        d_safe = np.maximum(dij, tiny)\n        denom = (dij + delta) ** p  # (M,)\n        # pairwise potential\n        pen_o = np.sum(1.0 / denom)\n\n        # gradient wrt centers due to pairwise term\n        # For each pair (i,j): derivative of (d+delta)^{-p} wrt center_i is:\n        # -p * (d+delta)^{-p-1} * (center_i - center_j) / d\n        coeff = -p * (d_safe + delta) ** (-p - 1)  # use d_safe in division\n        # careful: (d_safe + delta) == (dij + delta) but we avoid zero by using d_safe in division.\n        # contribution vector per pair for i is coeff * (center_i - center_j) / d_safe\n        with np.errstate(divide='ignore', invalid='ignore'):\n            invd = 1.0 / d_safe\n            vec = (coeff * invd)[:, None] * diffij  # (M,2), sign such that grad_i += vec, grad_j -= vec\n            # accumulate into gradient arrays\n        grad_centers_pair = np.zeros_like(centers)  # (N,2)\n        np.add.at(grad_centers_pair, iu[0], vec)\n        np.add.at(grad_centers_pair, iu[1], -vec)\n\n        # Boundary penalties\n        x = centers[:, 0]\n        y = centers[:, 1]\n        xb = x + delta_b\n        yb = y + delta_b\n        xb2 = (1.0 - x) + delta_b\n        yb2 = (1.0 - y) + delta_b\n        pen_b_terms = (xb ** (-p)) + (yb ** (-p)) + (xb2 ** (-p)) + (yb2 ** (-p))\n        pen_b = np.sum(pen_b_terms)\n\n        # Gradients wrt centers from boundary terms:\n        # d/dx of xb^{-p} = -p * xb^{-p-1} * d(xb)/dx = -p * xb^{-p-1}\n        grad_x_b = -p * xb ** (-p - 1) + p * xb2 ** (-p - 1)  # second term because derivative of (1-x) is -1, sign flips\n        grad_y_b = -p * yb ** (-p - 1) + p * yb2 ** (-p - 1)\n\n        grad_centers_boundary = np.zeros_like(centers)\n        grad_centers_boundary[:, 0] = grad_x_b\n        grad_centers_boundary[:, 1] = grad_y_b\n\n        # Total center gradient\n        grad_centers = w_o * grad_centers_pair + w_b * grad_centers_boundary\n\n        # Objective scalar\n        f = P * (w_o * pen_o + w_b * pen_b)\n\n        # Chain rule through sigmoid: c' = c*(1-c)\n        c_der = c * (1.0 - c)  # (2N,)\n        # grad_centers flattened in same ordering as z: first x coords then y coords\n        grad_centers_flat = np.concatenate([grad_centers[:, 0], grad_centers[:, 1]])  # (2N,)\n        # d f / d z = P * grad_centers_flat * dc/dz\n        grad_z = P * grad_centers_flat * c_der\n\n        # Return scalar and gradient\n        return float(f), grad_z\n\n    # ---------------- LP to maximize radii for fixed centers ----------------\n    def _lp_maximize_radii(centers, eps_pair=1e-6):\n        # centers: (N,2)\n        Nloc = centers.shape[0]\n        x = centers[:, 0]\n        y = centers[:, 1]\n\n        A_rows = []\n        b_vals = []\n\n        # boundary constraints: r_i <= x_i - eps, r_i <= y_i - eps, r_i <= 1-x_i - eps, r_i <= 1-y_i - eps\n        for i in range(Nloc):\n            e = np.zeros(Nloc)\n            e[i] = 1.0\n            A_rows.append(e.copy()); b_vals.append(x[i] - eps_pair)\n            A_rows.append(e.copy()); b_vals.append(y[i] - eps_pair)\n            A_rows.append(e.copy()); b_vals.append(1.0 - x[i] - eps_pair)\n            A_rows.append(e.copy()); b_vals.append(1.0 - y[i] - eps_pair)\n\n        # pairwise constraints: r_i + r_j <= dist - eps\n        _, d = _pairwise_diffs_and_dist(centers)\n        for i in range(Nloc):\n            for j in range(i + 1, Nloc):\n                e = np.zeros(Nloc)\n                e[i] = 1.0; e[j] = 1.0\n                A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n\n        # bounds for radii\n        bounds = [(0.0, 0.5) for _ in range(Nloc)]\n        c = -np.ones(Nloc)  # minimize -sum(r) -> maximize sum(r)\n\n        if len(A_rows) > 0:\n            A_ub = np.array(A_rows)\n            b_ub = np.array(b_vals)\n        else:\n            A_ub = None\n            b_ub = None\n\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return np.clip(res.x, 0.0, 0.5)\n\n        # Fallback: try with eps=0 to get base solution then scale down to satisfy eps_pair\n        # Build A_ub0\n        A_rows2 = []\n        b_vals2 = []\n        for i in range(Nloc):\n            e = np.zeros(Nloc); e[i] = 1.0\n            A_rows2.append(e.copy()); b_vals2.append(x[i])\n            A_rows2.append(e.copy()); b_vals2.append(y[i])\n            A_rows2.append(e.copy()); b_vals2.append(1.0 - x[i])\n            A_rows2.append(e.copy()); b_vals2.append(1.0 - y[i])\n\n        for i in range(Nloc):\n            for j in range(i + 1, Nloc):\n                e = np.zeros(Nloc); e[i] = 1.0; e[j] = 1.0\n                A_rows2.append(e); b_vals2.append(d[i, j])\n\n        A_ub2 = np.array(A_rows2)\n        b_ub2 = np.array(b_vals2)\n        res2 = linprog(c, A_ub=A_ub2, b_ub=b_ub2, bounds=bounds, method='highs')\n        if not res2.success:\n            # as last resort return zeros\n            return np.zeros(Nloc)\n\n        r_base = np.clip(res2.x, 0.0, 0.5)\n\n        # scale r_base to satisfy eps_pair\n        dmat = d\n        denom_pairs = r_base[:, None] + r_base[None, :]\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ratio_pairs = np.where(denom_pairs > 1e-12, (dmat - eps_pair) / denom_pairs, np.inf)\n        iu2 = np.triu_indices(Nloc, 1)\n        s_pairs = np.min(ratio_pairs[iu2]) if ratio_pairs[iu2].size > 0 else 1.0\n        if not np.isfinite(s_pairs):\n            s_pairs = 1.0\n        s_pairs = max(0.0, min(1.0, s_pairs))\n\n        # boundary scaling\n        with np.errstate(divide='ignore', invalid='ignore'):\n            s_x_min = np.where(r_base > 1e-12, (x - eps_pair) / r_base, np.inf)\n            s_y_min = np.where(r_base > 1e-12, (y - eps_pair) / r_base, np.inf)\n            s_x_max = np.where(r_base > 1e-12, (1.0 - x - eps_pair) / r_base, np.inf)\n            s_y_max = np.where(r_base > 1e-12, (1.0 - y - eps_pair) / r_base, np.inf)\n        s_boundary = np.min([np.min(s_x_min), np.min(s_y_min), np.min(s_x_max), np.min(s_y_max)])\n        if not np.isfinite(s_boundary):\n            s_boundary = 1.0\n        s_boundary = max(0.0, min(1.0, s_boundary))\n\n        s = min(s_pairs, s_boundary)\n        r = s * r_base\n        return np.clip(r, 0.0, 0.5)\n\n    # ---------------- Verification ----------------\n    def _verify(centers, radii, tol_pair=1e-6):\n        if centers.shape != (N, 2): return False\n        if radii.shape != (N,): return False\n        if np.any(radii < -1e-12): return False\n        x = centers[:, 0]; y = centers[:, 1]\n        # boundary\n        if np.any(x - radii < tol_pair): return False\n        if np.any(y - radii < tol_pair): return False\n        if np.any(x + radii > 1.0 - tol_pair): return False\n        if np.any(y + radii > 1.0 - tol_pair): return False\n        _, d = _pairwise_diffs_and_dist(centers)\n        iu = np.triu_indices(N, 1)\n        lhs = radii[:, None] + radii[None, :]\n        viol = lhs[iu] - d[iu] + tol_pair\n        if np.any(viol > 1e-12):\n            return False\n        return True\n\n    # ---------------- Multi-start optimization ----------------\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n    inits = _multi_start_inits()\n\n    # Annealing schedule for penalty P (increasing)\n    P_schedule = [5.0, 50.0, 300.0, 1500.0, 6000.0]\n    maxiter_stage = [60, 70, 80, 100, 120]\n\n    # We arrange z as [x0..xN-1, y0..yN-1]\n    for init_idx, centers0 in enumerate(inits[:10]):\n        # Convert centers to z initial via logit (clip to avoid infinities)\n        c0 = centers0.copy()\n        c0 = np.clip(c0, 1e-6, 1.0 - 1e-6)\n        z0 = np.concatenate([logit(c0[:, 0]), logit(c0[:, 1])])  # (2N,)\n        # add small gaussian noise in z-space to diversify starts\n        rng = np.random.default_rng(1000 + init_idx)\n        z = z0 + rng.normal(scale=0.5, size=z0.shape)\n\n        # Staged optimization\n        for si, P in enumerate(P_schedule):\n            opts = {'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8}\n            # minimize penalized objective wrt z\n            fun = lambda zz: _objective_and_grad_z(zz, P=P, w_o=1.0, w_b=1.0, p=2, delta=0.02, delta_b=0.02)\n            try:\n                res = minimize(fun=fun, x0=z, method='L-BFGS-B', jac=True, options=opts)\n                z = res.x\n            except Exception:\n                # keep previous z if optimizer fails\n                pass\n\n            # Quick local center-only polish with slightly higher penalty to encourage spacing\n            # (we simply perform a short L-BFGS-B inner run with increased P)\n            try:\n                res2 = minimize(fun=lambda zz: _objective_and_grad_z(zz, P=max(P * 5.0, 200.0), w_o=1.0, w_b=1.0, p=2, delta=0.02, delta_b=0.02),\n                                x0=z, method='L-BFGS-B', jac=True, options={'maxiter': 30, 'ftol': 1e-12})\n                z = res2.x\n            except Exception:\n                pass\n\n        # After annealing stages, map to centers and run final LP (strict) to get radii\n        centers_candidate = expit(z).reshape(2, N).T\n        centers_candidate = np.clip(centers_candidate, 1e-6, 1.0 - 1e-6)\n        r_lp = _lp_maximize_radii(centers_candidate, eps_pair=1e-6)\n\n        if _verify(centers_candidate, r_lp, tol_pair=1e-6):\n            s = float(np.sum(r_lp))\n            if s > best['sum']:\n                best['centers'] = centers_candidate.copy()\n                best['radii'] = r_lp.copy()\n                best['sum'] = s\n        else:\n            # try fallback: solve LP with eps=0 then scale down slightly to meet eps_pair\n            r0 = _lp_maximize_radii(centers_candidate, eps_pair=0.0)\n            if r0.sum() > 0:\n                # compute scaling needed\n                dmat = _pairwise_diffs_and_dist(centers_candidate)[1]\n                denom_pairs = r0[:, None] + r0[None, :]\n                with np.errstate(divide='ignore', invalid='ignore'):\n                    ratio_pairs = np.where(denom_pairs > 1e-12, (dmat - 1e-6) / denom_pairs, np.inf)\n                iu2 = np.triu_indices(N, 1)\n                s_pairs = np.min(ratio_pairs[iu2]) if ratio_pairs[iu2].size > 0 else 1.0\n                if not np.isfinite(s_pairs):\n                    s_pairs = 1.0\n                s_pairs = max(0.0, min(1.0, s_pairs))\n                # boundary scaling\n                bx = np.minimum.reduce([centers_candidate[:, 0], centers_candidate[:, 1], 1.0 - centers_candidate[:, 0], 1.0 - centers_candidate[:, 1]])\n                with np.errstate(divide='ignore', invalid='ignore'):\n                    scale_b = np.min(np.where(r0 > 1e-12, (bx - 1e-6) / r0, np.inf))\n                if not np.isfinite(scale_b):\n                    scale_b = 1.0\n                scale_b = max(0.0, min(1.0, scale_b))\n                s = min(s_pairs, scale_b)\n                r_try = np.clip(s * r0, 0.0, 0.5)\n                if _verify(centers_candidate, r_try, tol_pair=1e-6):\n                    ssum = float(np.sum(r_try))\n                    if ssum > best['sum']:\n                        best['centers'] = centers_candidate.copy()\n                        best['radii'] = r_try.copy()\n                        best['sum'] = ssum\n\n    # If no valid solution from multi-starts, fallback to a deterministic hex layout and LP\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6, 5, 6, 5, 4], margin=0.06, jitter_scale=0.02, seed=123)\n        centers_fb = np.clip(centers_fb, 1e-6, 1.0 - 1e-6)\n        r_fb = _lp_maximize_radii(centers_fb, eps_pair=1e-6)\n        if not _verify(centers_fb, r_fb, tol_pair=1e-6):\n            # try scaling down a bit\n            r_fb = 0.95 * r_fb\n        best['centers'] = centers_fb\n        best['radii'] = np.clip(r_fb, 0.0, 0.5)\n        best['sum'] = float(np.sum(best['radii']))\n\n    # Final strict LP hardening with slightly stricter epsilon\n    radii_strict = _lp_maximize_radii(best['centers'], eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        final_radii = radii_strict\n    else:\n        final_radii = best['radii']\n        # Last resort: if still infeasible, compute conservative uniform scaling\n        if not _verify(best['centers'], final_radii, tol_pair=1e-6):\n            dmat = _pairwise_diffs_and_dist(best['centers'])[1]\n            denom = final_radii[:, None] + final_radii[None, :]\n            with np.errstate(divide='ignore', invalid='ignore'):\n                ratio_pairs = np.where(denom > 1e-12, (dmat - 1e-6) / denom, np.inf)\n            iu = np.triu_indices(N, 1)\n            s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n            if not np.isfinite(s_pairs):\n                s_pairs = 1.0\n            s_pairs = max(0.0, min(1.0, s_pairs))\n            bx = np.minimum.reduce([best['centers'][:, 0], best['centers'][:, 1], 1.0 - best['centers'][:, 0], 1.0 - best['centers'][:, 1]])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                scale_b = np.min(np.where(final_radii > 1e-12, (bx - 1e-6) / final_radii, np.inf))\n            if not np.isfinite(scale_b):\n                scale_b = 1.0\n            scale_b = max(0.0, min(1.0, scale_b))\n            s_final = min(s_pairs, scale_b)\n            final_radii = np.clip(s_final * final_radii, 0.0, 0.5)\n\n    centers_out = best['centers'].astype(float)\n    radii_out = np.clip(final_radii.astype(float), 0.0, 0.5)\n    sum_radii = float(np.sum(radii_out))\n\n    # Final verification: if infeasible, shrink uniformly slightly until feasible (very small loop)\n    if not _verify(centers_out, radii_out, tol_pair=1e-6):\n        factor = 0.999\n        for _ in range(5000):\n            radii_out = radii_out * factor\n            if _verify(centers_out, radii_out, tol_pair=1e-6):\n                break\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\n\n# Optional helper to run directly\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T03:21:30.086309",
  "cost_data": null,
  "model_config": {
    "model": "openai/gpt-5-mini",
    "temperature": 0.35
  },
  "llm_call_duration_s": 102.97294010699261,
  "eval_duration_s": 0.5482485599350184
}