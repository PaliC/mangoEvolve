{
  "trial_id": "trial_3_3",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    n = 26\n    best_sum = 0.0\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple initialization strategies\n    init_strategies = [\n        lambda: triangular_lattice_init(n),\n        lambda: hex_pattern_init(n),\n        lambda: triangular_lattice_init(n, jitter=0.02),\n        lambda: hex_pattern_init(n, jitter=0.02)\n    ]\n    \n    for init_func in init_strategies:\n        centers = init_func()\n        \n        # Alternating optimization\n        for outer_iter in range(3):\n            # LP step: compute optimal radii given centers\n            radii, sum_radii = solve_lp_radii(centers)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            \n            # Local search step: improve centers\n            centers = improve_centers(centers, num_sweeps=30)\n    \n    # Final LP solve with best centers\n    if best_centers is not None:\n        final_radii, final_sum = solve_lp_radii(best_centers)\n        return best_centers, final_radii, final_sum\n    else:\n        # Fallback\n        centers = triangular_lattice_init(n)\n        radii, sum_radii = solve_lp_radii(centers)\n        return centers, radii, sum_radii\n\ndef triangular_lattice_init(n, jitter=0.0):\n    # Create triangular lattice points\n    points = []\n    rows = int(np.ceil(np.sqrt(n * 2 / np.sqrt(3))))\n    \n    for row in range(rows):\n        y = row * np.sqrt(3) / 2\n        if y > 1:\n            break\n        \n        cols = int(np.ceil(1.0 / (1.0 if row % 2 == 0 else 1.0)))\n        offset = 0.5 if row % 2 == 1 else 0.0\n        \n        for col in range(cols):\n            x = col + offset\n            if x > 1:\n                break\n            points.append([x, y])\n    \n    # Take first n points and scale to fit in [0,1]^2\n    points = np.array(points[:n])\n    if len(points) < n:\n        # Add random points if needed\n        extra = n - len(points)\n        extra_points = np.random.random((extra, 2))\n        points = np.vstack([points, extra_points])\n    \n    # Scale to fit in unit square with margin\n    margin = 0.1\n    points = points - points.min(axis=0)\n    scale = (1 - 2*margin) / points.max(axis=0).max()\n    points = points * scale + margin\n    \n    # Add jitter\n    if jitter > 0:\n        points += np.random.normal(0, jitter, points.shape)\n        points = np.clip(points, 0.05, 0.95)\n    \n    return points\n\ndef hex_pattern_init(n, jitter=0.0):\n    # Hexagonal close packing\n    points = []\n    spacing = 1.0 / np.ceil(np.sqrt(n))\n    \n    for i in range(int(1.0 / spacing) + 1):\n        for j in range(int(1.0 / spacing) + 1):\n            x = j * spacing\n            y = i * spacing * np.sqrt(3) / 2\n            if i % 2 == 1:\n                x += spacing / 2\n            \n            if x <= 1 and y <= 1:\n                points.append([x, y])\n    \n    points = np.array(points[:n])\n    if len(points) < n:\n        extra = n - len(points)\n        extra_points = np.random.random((extra, 2))\n        points = np.vstack([points, extra_points])\n    \n    # Add jitter\n    if jitter > 0:\n        points += np.random.normal(0, jitter, points.shape)\n        points = np.clip(points, 0.05, 0.95)\n    \n    return points\n\ndef solve_lp_radii(centers):\n    n = len(centers)\n    \n    # Compute pairwise distances\n    distances = compute_pairwise_distances(centers)\n    \n    # Compute boundary constraints (how close each center is to boundary)\n    x_coords = centers[:, 0]\n    y_coords = centers[:, 1]\n    \n    boundary_limits = np.minimum.reduce([\n        x_coords,           # distance to left boundary\n        y_coords,           # distance to bottom boundary  \n        1 - x_coords,       # distance to right boundary\n        1 - y_coords        # distance to top boundary\n    ])\n    \n    # Set up LP: minimize -sum(r_i)\n    c = -np.ones(n)  # coefficients for objective\n    \n    # Inequality constraints: A_ub @ x <= b_ub\n    A_ub = []\n    b_ub = []\n    \n    # Boundary constraints: r_i <= boundary_limits[i]\n    for i in range(n):\n        constraint = np.zeros(n)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(boundary_limits[i])\n    \n    # Non-overlap constraints: r_i + r_j <= dist_ij - eps\n    eps = 1e-6\n    for i in range(n):\n        for j in range(i + 1, n):\n            constraint = np.zeros(n)\n            constraint[i] = 1\n            constraint[j] = 1\n            A_ub.append(constraint)\n            b_ub.append(distances[i, j] - eps)\n    \n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n    \n    # Bounds: 0 <= r_i\n    bounds = [(0, None) for _ in range(n)]\n    \n    # Solve LP\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    \n    if result.success:\n        radii = result.x\n        sum_radii = np.sum(radii)\n        return radii, sum_radii\n    else:\n        # Fallback: set all radii to small value\n        radii = np.full(n, 0.01)\n        return radii, np.sum(radii)\n\ndef compute_pairwise_distances(centers):\n    n = len(centers)\n    distances = np.zeros((n, n))\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            distances[i, j] = dist\n            distances[j, i] = dist\n    \n    return distances\n\ndef improve_centers(centers, num_sweeps=30):\n    n = len(centers)\n    step_size = 0.05\n    decay = 0.95\n    \n    # 8 directions for local search\n    angles = np.linspace(0, 2*np.pi, 9)[:-1]  # 8 directions\n    directions = np.column_stack([np.cos(angles), np.sin(angles)])\n    \n    current_centers = centers.copy()\n    current_radii, current_sum = solve_lp_radii(current_centers)\n    \n    for sweep in range(num_sweeps):\n        improved = False\n        \n        for i in range(n):\n            best_move = None\n            best_sum = current_sum\n            \n            # Try moving in each direction\n            for direction in directions:\n                new_pos = current_centers[i] + step_size * direction\n                \n                # Project to stay in bounds\n                new_pos = np.clip(new_pos, 0.01, 0.99)\n                \n                # Test this move\n                test_centers = current_centers.copy()\n                test_centers[i] = new_pos\n                \n                test_radii, test_sum = solve_lp_radii(test_centers)\n                \n                if test_sum > best_sum:\n                    best_sum = test_sum\n                    best_move = new_pos\n            \n            # Apply best move if found\n            if best_move is not None:\n                current_centers[i] = best_move\n                current_sum = best_sum\n                improved = True\n        \n        # Decay step size\n        step_size *= decay\n        \n        if not improved and step_size < 1e-4:\n            break\n    \n    return current_centers",
  "metrics": {
    "valid": true,
    "score": 2.4407055600251426,
    "eval_time": 167.29523634910583,
    "error": null
  },
  "prompt": "\nImplement an alternating scheme:\n1) Given centers, compute radii via LP maximization of sum(r) under constraints.\n2) Improve centers by local coordinate descent:\n   - For each point, probe 8 directions on a small circle; accept move that increases LP objective the most;\n   - Decrease step size geometrically; 20-40 sweeps.\n   - Keep centers within [0,1]^2 (project if needed).\n3) Repeat (LP -> move) for a few outer iterations; return best feasible LP solution.\n\nUse deterministic initializations:\n- Triangular lattice matched to box; a refined hex pattern; plus slight uniform jitter.\n- Maintain a global best.\n\nFocus on efficiency: vectorize LP coefficient assembly and distance recomputation caching.\n\n\nRequirements:\n- Implement construct_packing() that returns (centers, radii, sum_radii).\n- centers: np.array shape (26, 2), radii: np.array shape (26,), sum_radii: float.\n- Use only numpy and scipy.\n- Exactly 26 circles; all inside [0,1]^2; no overlaps (tolerance 1e-6); radii >= 0.\n- Runtime <= 300s; no prints.\n- Use a linear program (scipy.optimize.linprog) for final feasibilization to strictly satisfy constraints:\n  maximize sum(r) subject to:\n    0 <= r_i <= r_cap_i\n    r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    r_i + r_j <= dist_ij - 1e-6 for all i<j\n  where r_cap_i are current candidate radii (upper bounds) and dist_ij are pairwise distances.\n  Implement as minimizing -sum(r).\n- Provide robust, vectorized computations; avoid numerical bias (apply eps only to denominators).\n- Return the strictly feasible LP output.\n\nImplement construct_packing() and helpers; no prints.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    n = 26\n    best_sum = 0.0\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple initialization strategies\n    init_strategies = [\n        lambda: triangular_lattice_init(n),\n        lambda: hex_pattern_init(n),\n        lambda: triangular_lattice_init(n, jitter=0.02),\n        lambda: hex_pattern_init(n, jitter=0.02)\n    ]\n    \n    for init_func in init_strategies:\n        centers = init_func()\n        \n        # Alternating optimization\n        for outer_iter in range(3):\n            # LP step: compute optimal radii given centers\n            radii, sum_radii = solve_lp_radii(centers)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            \n            # Local search step: improve centers\n            centers = improve_centers(centers, num_sweeps=30)\n    \n    # Final LP solve with best centers\n    if best_centers is not None:\n        final_radii, final_sum = solve_lp_radii(best_centers)\n        return best_centers, final_radii, final_sum\n    else:\n        # Fallback\n        centers = triangular_lattice_init(n)\n        radii, sum_radii = solve_lp_radii(centers)\n        return centers, radii, sum_radii\n\ndef triangular_lattice_init(n, jitter=0.0):\n    # Create triangular lattice points\n    points = []\n    rows = int(np.ceil(np.sqrt(n * 2 / np.sqrt(3))))\n    \n    for row in range(rows):\n        y = row * np.sqrt(3) / 2\n        if y > 1:\n            break\n        \n        cols = int(np.ceil(1.0 / (1.0 if row % 2 == 0 else 1.0)))\n        offset = 0.5 if row % 2 == 1 else 0.0\n        \n        for col in range(cols):\n            x = col + offset\n            if x > 1:\n                break\n            points.append([x, y])\n    \n    # Take first n points and scale to fit in [0,1]^2\n    points = np.array(points[:n])\n    if len(points) < n:\n        # Add random points if needed\n        extra = n - len(points)\n        extra_points = np.random.random((extra, 2))\n        points = np.vstack([points, extra_points])\n    \n    # Scale to fit in unit square with margin\n    margin = 0.1\n    points = points - points.min(axis=0)\n    scale = (1 - 2*margin) / points.max(axis=0).max()\n    points = points * scale + margin\n    \n    # Add jitter\n    if jitter > 0:\n        points += np.random.normal(0, jitter, points.shape)\n        points = np.clip(points, 0.05, 0.95)\n    \n    return points\n\ndef hex_pattern_init(n, jitter=0.0):\n    # Hexagonal close packing\n    points = []\n    spacing = 1.0 / np.ceil(np.sqrt(n))\n    \n    for i in range(int(1.0 / spacing) + 1):\n        for j in range(int(1.0 / spacing) + 1):\n            x = j * spacing\n            y = i * spacing * np.sqrt(3) / 2\n            if i % 2 == 1:\n                x += spacing / 2\n            \n            if x <= 1 and y <= 1:\n                points.append([x, y])\n    \n    points = np.array(points[:n])\n    if len(points) < n:\n        extra = n - len(points)\n        extra_points = np.random.random((extra, 2))\n        points = np.vstack([points, extra_points])\n    \n    # Add jitter\n    if jitter > 0:\n        points += np.random.normal(0, jitter, points.shape)\n        points = np.clip(points, 0.05, 0.95)\n    \n    return points\n\ndef solve_lp_radii(centers):\n    n = len(centers)\n    \n    # Compute pairwise distances\n    distances = compute_pairwise_distances(centers)\n    \n    # Compute boundary constraints (how close each center is to boundary)\n    x_coords = centers[:, 0]\n    y_coords = centers[:, 1]\n    \n    boundary_limits = np.minimum.reduce([\n        x_coords,           # distance to left boundary\n        y_coords,           # distance to bottom boundary  \n        1 - x_coords,       # distance to right boundary\n        1 - y_coords        # distance to top boundary\n    ])\n    \n    # Set up LP: minimize -sum(r_i)\n    c = -np.ones(n)  # coefficients for objective\n    \n    # Inequality constraints: A_ub @ x <= b_ub\n    A_ub = []\n    b_ub = []\n    \n    # Boundary constraints: r_i <= boundary_limits[i]\n    for i in range(n):\n        constraint = np.zeros(n)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(boundary_limits[i])\n    \n    # Non-overlap constraints: r_i + r_j <= dist_ij - eps\n    eps = 1e-6\n    for i in range(n):\n        for j in range(i + 1, n):\n            constraint = np.zeros(n)\n            constraint[i] = 1\n            constraint[j] = 1\n            A_ub.append(constraint)\n            b_ub.append(distances[i, j] - eps)\n    \n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n    \n    # Bounds: 0 <= r_i\n    bounds = [(0, None) for _ in range(n)]\n    \n    # Solve LP\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    \n    if result.success:\n        radii = result.x\n        sum_radii = np.sum(radii)\n        return radii, sum_radii\n    else:\n        # Fallback: set all radii to small value\n        radii = np.full(n, 0.01)\n        return radii, np.sum(radii)\n\ndef compute_pairwise_distances(centers):\n    n = len(centers)\n    distances = np.zeros((n, n))\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            distances[i, j] = dist\n            distances[j, i] = dist\n    \n    return distances\n\ndef improve_centers(centers, num_sweeps=30):\n    n = len(centers)\n    step_size = 0.05\n    decay = 0.95\n    \n    # 8 directions for local search\n    angles = np.linspace(0, 2*np.pi, 9)[:-1]  # 8 directions\n    directions = np.column_stack([np.cos(angles), np.sin(angles)])\n    \n    current_centers = centers.copy()\n    current_radii, current_sum = solve_lp_radii(current_centers)\n    \n    for sweep in range(num_sweeps):\n        improved = False\n        \n        for i in range(n):\n            best_move = None\n            best_sum = current_sum\n            \n            # Try moving in each direction\n            for direction in directions:\n                new_pos = current_centers[i] + step_size * direction\n                \n                # Project to stay in bounds\n                new_pos = np.clip(new_pos, 0.01, 0.99)\n                \n                # Test this move\n                test_centers = current_centers.copy()\n                test_centers[i] = new_pos\n                \n                test_radii, test_sum = solve_lp_radii(test_centers)\n                \n                if test_sum > best_sum:\n                    best_sum = test_sum\n                    best_move = new_pos\n            \n            # Apply best move if found\n            if best_move is not None:\n                current_centers[i] = best_move\n                current_sum = best_sum\n                improved = True\n        \n        # Decay step size\n        step_size *= decay\n        \n        if not improved and step_size < 1e-4:\n            break\n    \n    return current_centers\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T01:12:38.922273",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4",
    "temperature": 0.4
  },
  "llm_call_duration_s": 29.081426195101812,
  "eval_duration_s": 167.29524261900224
}