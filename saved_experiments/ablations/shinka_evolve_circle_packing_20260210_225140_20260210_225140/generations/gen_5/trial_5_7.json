{
  "trial_id": "trial_5_7",
  "generation": 5,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\n\n# Global constants\nN_CIRCLES = 26\nEPS = 1e-6 # Tolerance for non-overlap and strict containment\n\ndef solve_lp_radii(centers):\n    \"\"\"\n    Solves a Linear Program to find the maximum possible radii for a given\n    set of circle centers, ensuring non-overlap and containment within the unit square.\n    \"\"\"\n    num_circles = centers.shape[0]\n\n    # Objective: Maximize sum(r_i) => Minimize -sum(r_i)\n    c = -np.ones(num_circles)\n\n    # Constraints: r_i >= 0 (handled by bounds in linprog)\n\n    # 1. Boundary constraints: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    #    To ensure strict containment: r_i <= x_i - EPS, etc.\n    A_ub_box = np.vstack([\n        np.eye(num_circles),  # r_i <= x_i\n        np.eye(num_circles),  # r_i <= y_i\n        np.eye(num_circles),  # r_i <= 1-x_i\n        np.eye(num_circles)   # r_i <= 1-y_i\n    ])\n    b_ub_box = np.concatenate([\n        centers[:, 0] - EPS,\n        centers[:, 1] - EPS,\n        1 - centers[:, 0] - EPS,\n        1 - centers[:, 1] - EPS\n    ])\n\n    # 2. Pairwise non-overlap constraints: r_i + r_j <= dist_ij - EPS\n    num_pairs = num_circles * (num_circles - 1) // 2\n    A_ub_pair = np.zeros((num_pairs, num_circles))\n    b_ub_pair = np.zeros(num_pairs)\n\n    k = 0\n    for i in range(num_circles):\n        for j in range(i + 1, num_circles):\n            dist_ij = np.linalg.norm(centers[i] - centers[j])\n            A_ub_pair[k, i] = 1\n            A_ub_pair[k, j] = 1\n            b_ub_pair[k] = dist_ij - EPS\n            k += 1\n\n    # Combine all inequality constraints\n    A_ub = np.vstack([A_ub_box, A_ub_pair])\n    b_ub = np.concatenate([b_ub_box, b_ub_pair])\n\n    # Bounds for radii: r_i >= 0\n    bounds = [(0, None)] * num_circles\n\n    # Solve the linear program\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        radii = res.x\n        # Ensure radii are non-negative, sometimes linprog can return tiny negative values\n        radii[radii < 0] = 0\n        return radii\n    else:\n        # If LP fails, return zero radii. This makes the penalty function very high,\n        # encouraging the optimizer to find a feasible configuration.\n        return np.zeros(num_circles)\n\ndef objective_and_grad(x_flat, fixed_radii):\n    \"\"\"\n    Smooth penalty objective function and its gradient for L-BFGS-B.\n    Minimizes overlaps and boundary violations, assuming fixed radii.\n    \"\"\"\n    centers = x_flat.reshape(N_CIRCLES, 2)\n    total_penalty = 0.0\n    grad = np.zeros_like(centers)\n\n    # Vectorized boundary penalties and gradients\n    x_coords = centers[:, 0]\n    y_coords = centers[:, 1]\n    r = fixed_radii\n\n    # Left boundary: r_i - x_i > 0\n    violation_L = r - x_coords + EPS # Add EPS to penalize even slightly inside the tolerance\n    mask_L = violation_L > 0\n    total_penalty += np.sum(violation_L[mask_L]**2)\n    grad[mask_L, 0] -= 2 * violation_L[mask_L]\n\n    # Right boundary: r_i - (1 - x_i) > 0\n    violation_R = r - (1 - x_coords) + EPS\n    mask_R = violation_R > 0\n    total_penalty += np.sum(violation_R[mask_R]**2)\n    grad[mask_R, 0] += 2 * violation_R[mask_R]\n\n    # Bottom boundary: r_i - y_i > 0\n    violation_B = r - y_coords + EPS\n    mask_B = violation_B > 0\n    total_penalty += np.sum(violation_B[mask_B]**2)\n    grad[mask_B, 1] -= 2 * violation_B[mask_B]\n\n    # Top boundary: r_i - (1 - y_i) > 0\n    violation_T = r - (1 - y_coords) + EPS\n    mask_T = violation_T > 0\n    total_penalty += np.sum(violation_T[mask_T]**2)\n    grad[mask_T, 1] += 2 * violation_T[mask_T]\n\n    # Vectorized overlap penalties and gradients\n    # Use upper triangle to avoid double counting and self-loops\n    upper_tri_indices = np.triu_indices(N_CIRCLES, k=1)\n    \n    # Pre-calculate pairwise distances and overlaps for upper triangle\n    centers_i_pairs = centers[upper_tri_indices[0]]\n    centers_j_pairs = centers[upper_tri_indices[1]]\n    \n    dist_vecs_pairs = centers_i_pairs - centers_j_pairs\n    dist_ij_pairs = np.linalg.norm(dist_vecs_pairs, axis=1)\n    \n    sum_radii_pairs = fixed_radii[upper_tri_indices[0]] + fixed_radii[upper_tri_indices[1]]\n    \n    overlap_pairs = sum_radii_pairs - dist_ij_pairs + EPS\n    active_overlap_mask_pairs = overlap_pairs > 0\n    \n    # Penalty calculation\n    total_penalty += np.sum(overlap_pairs[active_overlap_mask_pairs]**2)\n    \n    # Gradient calculation for active overlaps\n    for idx in np.where(active_overlap_mask_pairs)[0]:\n        i = upper_tri_indices[0][idx]\n        j = upper_tri_indices[1][idx]\n        \n        overlap_val = overlap_pairs[idx]\n        dist_val = dist_ij_pairs[idx]\n        \n        if dist_val < 1e-10: # Handle very small distances to avoid division by zero\n            # If centers are almost on top of each other, push them apart strongly\n            # in an arbitrary direction to resolve the near-coincidence.\n            direction = np.array([1.0, 0.0]) # Arbitrary direction\n        else:\n            direction = dist_vecs_pairs[idx] / dist_val\n        \n        grad_val = 2 * overlap_val * direction\n        grad[i] += grad_val\n        grad[j] -= grad_val\n            \n    return total_penalty, grad.flatten()\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles into a unit square to maximize the sum of their radii.\n    \"\"\"\n    # 1. Initial Placement: 5x5 grid + 1 point, with jitter\n    # Distribute points in a grid, slightly offset from edges\n    grid_points = np.array([[x, y] for x in np.linspace(0.1, 0.9, 5) for y in np.linspace(0.1, 0.9, 5)])\n    \n    # Add the 26th point, e.g., at the center\n    initial_centers = np.vstack([grid_points, [0.5, 0.5]])\n    \n    # Add small random jitter\n    initial_centers += np.random.uniform(-0.01, 0.01, size=(N_CIRCLES, 2))\n    \n    # Clip centers to ensure they are within a reasonable range (e.g., [EPS, 1-EPS])\n    # to allow for initial radii.\n    initial_centers = np.clip(initial_centers, EPS, 1 - EPS)\n\n    centers = initial_centers.copy()\n\n    # 2. Greedy Adjustment of Centers (Gradient-like nudges)\n    # This step uses the smooth penalty objective to push centers apart and away from walls.\n    # Radii are re-calculated by LP at each iteration.\n    GREEDY_ITER = 50\n    step_size = 0.005 # Learning rate for greedy step\n\n    for _ in range(GREEDY_ITER):\n        current_radii = solve_lp_radii(centers)\n        \n        # Calculate penalty and gradient using the current radii as fixed_radii\n        penalty, grad = objective_and_grad(centers.flatten(), current_radii)\n        \n        # Apply gradient descent step\n        centers -= grad.reshape(N_CIRCLES, 2) * step_size\n        \n        # Clip centers to stay within bounds\n        centers = np.clip(centers, EPS, 1 - EPS)\n\n    # 3. L-BFGS-B Polish on Centers\n    # Use the radii from the last greedy step as fixed_radii for L-BFGS-B.\n    # This optimizes center positions to reduce overlaps and boundary violations for these radii.\n    radii_for_polish = solve_lp_radii(centers)\n    \n    # Bounds for L-BFGS-B: centers must stay within (EPS, 1-EPS)\n    bounds_lbfgsb = [(EPS, 1 - EPS)] * (N_CIRCLES * 2)\n    \n    LBFGSB_ITER = 200 # Max iterations for L-BFGS-B\n    \n    res_lbfgsb = minimize(\n        objective_and_grad,\n        centers.flatten(),\n        args=(radii_for_polish,),\n        method='L-BFGS-B',\n        jac=True,\n        bounds=bounds_lbfgsb,\n        options={'maxiter': LBFGSB_ITER, 'disp': False}\n    )\n    \n    centers_polished = res_lbfgsb.x.reshape(N_CIRCLES, 2)\n    \n    # 4. Final LP to get strictly feasible radii and maximize sum\n    final_radii = solve_lp_radii(centers_polished)\n    final_sum_radii = np.sum(final_radii)\n\n    return centers_polished, final_radii, final_sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.36366346224887,
    "eval_time": 0.45502638816833496,
    "error": null
  },
  "prompt": "\nYou are designing an algorithm to pack 26 non-overlapping circles into [0,1]x[0,1] maximizing sum of radii.\n\nRequirements:\n- Provide a single Python code block only, no prose.\n- Allowed modules: numpy, scipy\n- Implement function: construct_packing()\n- Optional: run_packing()\n- Return: (centers, radii, sum_radii)\n  - centers: np.array shape (26,2)\n  - radii:   np.array shape (26,)\n  - sum_radii: float\n- All circles must be strictly inside the unit square with non-overlap (tolerance 1e-6).\n- Exactly 26 circles; all radii >= 0.\n- Runtime <= 300s.\n\nCritical implementation notes:\n- Use analytic, fully vectorized gradients where applicable.\n- For distance-based penalties, apply epsilon only in divisions (avoid adding eps in the penalty itself).\n- Always finalize with a Linear Program to enforce feasibility and maximize sum of radii:\n  Maximize sum(r_i) subject to:\n    r_i >= 0\n    r_i <= min(current_r_i, x_i, y_i, 1-x_i, 1-y_i)\n    r_i + r_j <= dist_ij - 1e-6 for all i<j\n- If intermediate methods produce infeasible centers or radii, the LP must return a strictly feasible solution.\n\nScoring target:\n- Known best ~2.635. Aim to exceed 2.62+ reliably.\n\nImplement a constructive method:\n- Start from an edge-biased hex-like lattice of 26 centers with small jitter; prioritize placing more centers near edges/corners (where packing often benefits).\n- Greedy adjust centers by local swaps and small gradient-like nudges to reduce overlaps and improve minimal clearance.\n- After construction, compute radii using LP; then a brief L-BFGS-B polish on centers with a smooth penalty objective; finalize with LP again.\n\n\nImplement an LP feasibilizer function:\n- Input: centers (N,2), candidate radii (N,) or upper bounds (N,)\n- Build pairwise constraints r_i + r_j <= d_ij - 1e-6, where d_ij = ||c_i - c_j||_2\n- Bound by box: r_i <= x_i, y_i, 1-x_i, 1-y_i\n- Also enforce r_i <= r_ub_i (from candidate) if provided\n- Use scipy.optimize.linprog to maximize sum(r_i)\n- Return strictly feasible radii; on failure, back off margins slightly (e.g., add 1e-6 slack in constraints)\n\nEnsure strictly feasible output; keep runtime reasonable; vectorize pair computations.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\n# Global constants\nN_CIRCLES = 26\nEPS = 1e-6 # Tolerance for non-overlap and strict containment\n\ndef solve_lp_radii(centers):\n    \"\"\"\n    Solves a Linear Program to find the maximum possible radii for a given\n    set of circle centers, ensuring non-overlap and containment within the unit square.\n    \"\"\"\n    num_circles = centers.shape[0]\n\n    # Objective: Maximize sum(r_i) => Minimize -sum(r_i)\n    c = -np.ones(num_circles)\n\n    # Constraints: r_i >= 0 (handled by bounds in linprog)\n\n    # 1. Boundary constraints: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    #    To ensure strict containment: r_i <= x_i - EPS, etc.\n    A_ub_box = np.vstack([\n        np.eye(num_circles),  # r_i <= x_i\n        np.eye(num_circles),  # r_i <= y_i\n        np.eye(num_circles),  # r_i <= 1-x_i\n        np.eye(num_circles)   # r_i <= 1-y_i\n    ])\n    b_ub_box = np.concatenate([\n        centers[:, 0] - EPS,\n        centers[:, 1] - EPS,\n        1 - centers[:, 0] - EPS,\n        1 - centers[:, 1] - EPS\n    ])\n\n    # 2. Pairwise non-overlap constraints: r_i + r_j <= dist_ij - EPS\n    num_pairs = num_circles * (num_circles - 1) // 2\n    A_ub_pair = np.zeros((num_pairs, num_circles))\n    b_ub_pair = np.zeros(num_pairs)\n\n    k = 0\n    for i in range(num_circles):\n        for j in range(i + 1, num_circles):\n            dist_ij = np.linalg.norm(centers[i] - centers[j])\n            A_ub_pair[k, i] = 1\n            A_ub_pair[k, j] = 1\n            b_ub_pair[k] = dist_ij - EPS\n            k += 1\n\n    # Combine all inequality constraints\n    A_ub = np.vstack([A_ub_box, A_ub_pair])\n    b_ub = np.concatenate([b_ub_box, b_ub_pair])\n\n    # Bounds for radii: r_i >= 0\n    bounds = [(0, None)] * num_circles\n\n    # Solve the linear program\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        radii = res.x\n        # Ensure radii are non-negative, sometimes linprog can return tiny negative values\n        radii[radii < 0] = 0\n        return radii\n    else:\n        # If LP fails, return zero radii. This makes the penalty function very high,\n        # encouraging the optimizer to find a feasible configuration.\n        return np.zeros(num_circles)\n\ndef objective_and_grad(x_flat, fixed_radii):\n    \"\"\"\n    Smooth penalty objective function and its gradient for L-BFGS-B.\n    Minimizes overlaps and boundary violations, assuming fixed radii.\n    \"\"\"\n    centers = x_flat.reshape(N_CIRCLES, 2)\n    total_penalty = 0.0\n    grad = np.zeros_like(centers)\n\n    # Vectorized boundary penalties and gradients\n    x_coords = centers[:, 0]\n    y_coords = centers[:, 1]\n    r = fixed_radii\n\n    # Left boundary: r_i - x_i > 0\n    violation_L = r - x_coords + EPS # Add EPS to penalize even slightly inside the tolerance\n    mask_L = violation_L > 0\n    total_penalty += np.sum(violation_L[mask_L]**2)\n    grad[mask_L, 0] -= 2 * violation_L[mask_L]\n\n    # Right boundary: r_i - (1 - x_i) > 0\n    violation_R = r - (1 - x_coords) + EPS\n    mask_R = violation_R > 0\n    total_penalty += np.sum(violation_R[mask_R]**2)\n    grad[mask_R, 0] += 2 * violation_R[mask_R]\n\n    # Bottom boundary: r_i - y_i > 0\n    violation_B = r - y_coords + EPS\n    mask_B = violation_B > 0\n    total_penalty += np.sum(violation_B[mask_B]**2)\n    grad[mask_B, 1] -= 2 * violation_B[mask_B]\n\n    # Top boundary: r_i - (1 - y_i) > 0\n    violation_T = r - (1 - y_coords) + EPS\n    mask_T = violation_T > 0\n    total_penalty += np.sum(violation_T[mask_T]**2)\n    grad[mask_T, 1] += 2 * violation_T[mask_T]\n\n    # Vectorized overlap penalties and gradients\n    # Use upper triangle to avoid double counting and self-loops\n    upper_tri_indices = np.triu_indices(N_CIRCLES, k=1)\n    \n    # Pre-calculate pairwise distances and overlaps for upper triangle\n    centers_i_pairs = centers[upper_tri_indices[0]]\n    centers_j_pairs = centers[upper_tri_indices[1]]\n    \n    dist_vecs_pairs = centers_i_pairs - centers_j_pairs\n    dist_ij_pairs = np.linalg.norm(dist_vecs_pairs, axis=1)\n    \n    sum_radii_pairs = fixed_radii[upper_tri_indices[0]] + fixed_radii[upper_tri_indices[1]]\n    \n    overlap_pairs = sum_radii_pairs - dist_ij_pairs + EPS\n    active_overlap_mask_pairs = overlap_pairs > 0\n    \n    # Penalty calculation\n    total_penalty += np.sum(overlap_pairs[active_overlap_mask_pairs]**2)\n    \n    # Gradient calculation for active overlaps\n    for idx in np.where(active_overlap_mask_pairs)[0]:\n        i = upper_tri_indices[0][idx]\n        j = upper_tri_indices[1][idx]\n        \n        overlap_val = overlap_pairs[idx]\n        dist_val = dist_ij_pairs[idx]\n        \n        if dist_val < 1e-10: # Handle very small distances to avoid division by zero\n            # If centers are almost on top of each other, push them apart strongly\n            # in an arbitrary direction to resolve the near-coincidence.\n            direction = np.array([1.0, 0.0]) # Arbitrary direction\n        else:\n            direction = dist_vecs_pairs[idx] / dist_val\n        \n        grad_val = 2 * overlap_val * direction\n        grad[i] += grad_val\n        grad[j] -= grad_val\n            \n    return total_penalty, grad.flatten()\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles into a unit square to maximize the sum of their radii.\n    \"\"\"\n    # 1. Initial Placement: 5x5 grid + 1 point, with jitter\n    # Distribute points in a grid, slightly offset from edges\n    grid_points = np.array([[x, y] for x in np.linspace(0.1, 0.9, 5) for y in np.linspace(0.1, 0.9, 5)])\n    \n    # Add the 26th point, e.g., at the center\n    initial_centers = np.vstack([grid_points, [0.5, 0.5]])\n    \n    # Add small random jitter\n    initial_centers += np.random.uniform(-0.01, 0.01, size=(N_CIRCLES, 2))\n    \n    # Clip centers to ensure they are within a reasonable range (e.g., [EPS, 1-EPS])\n    # to allow for initial radii.\n    initial_centers = np.clip(initial_centers, EPS, 1 - EPS)\n\n    centers = initial_centers.copy()\n\n    # 2. Greedy Adjustment of Centers (Gradient-like nudges)\n    # This step uses the smooth penalty objective to push centers apart and away from walls.\n    # Radii are re-calculated by LP at each iteration.\n    GREEDY_ITER = 50\n    step_size = 0.005 # Learning rate for greedy step\n\n    for _ in range(GREEDY_ITER):\n        current_radii = solve_lp_radii(centers)\n        \n        # Calculate penalty and gradient using the current radii as fixed_radii\n        penalty, grad = objective_and_grad(centers.flatten(), current_radii)\n        \n        # Apply gradient descent step\n        centers -= grad.reshape(N_CIRCLES, 2) * step_size\n        \n        # Clip centers to stay within bounds\n        centers = np.clip(centers, EPS, 1 - EPS)\n\n    # 3. L-BFGS-B Polish on Centers\n    # Use the radii from the last greedy step as fixed_radii for L-BFGS-B.\n    # This optimizes center positions to reduce overlaps and boundary violations for these radii.\n    radii_for_polish = solve_lp_radii(centers)\n    \n    # Bounds for L-BFGS-B: centers must stay within (EPS, 1-EPS)\n    bounds_lbfgsb = [(EPS, 1 - EPS)] * (N_CIRCLES * 2)\n    \n    LBFGSB_ITER = 200 # Max iterations for L-BFGS-B\n    \n    res_lbfgsb = minimize(\n        objective_and_grad,\n        centers.flatten(),\n        args=(radii_for_polish,),\n        method='L-BFGS-B',\n        jac=True,\n        bounds=bounds_lbfgsb,\n        options={'maxiter': LBFGSB_ITER, 'disp': False}\n    )\n    \n    centers_polished = res_lbfgsb.x.reshape(N_CIRCLES, 2)\n    \n    # 4. Final LP to get strictly feasible radii and maximize sum\n    final_radii = solve_lp_radii(centers_polished)\n    final_sum_radii = np.sum(final_radii)\n\n    return centers_polished, final_radii, final_sum_radii\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T01:23:18.460589",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.5-flash",
    "temperature": 0.45,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 867,
        "candidates_token_count": 2605,
        "thoughts_token_count": 13387
      },
      "response_text_len": 7726
    }
  },
  "llm_call_duration_s": 66.28292066999711,
  "eval_duration_s": 0.4550320759881288
}