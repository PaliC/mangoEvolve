{
  "trial_id": "trial_2_3",
  "generation": 2,
  "parent_id": "trial_1_0",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nimport hashlib\n\ndef construct_packing():\n    def hash_centers(centers, precision=6):\n        rounded = np.round(centers, precision)\n        return hashlib.md5(rounded.tobytes()).hexdigest()\n    \n    def solve_lp(centers, cache={}):\n        key = hash_centers(centers)\n        if key in cache:\n            return cache[key]\n        \n        n = len(centers)\n        \n        # Compute pairwise distances\n        dists = np.sqrt(np.sum((centers[:, None, :] - centers[None, :, :]) ** 2, axis=2))\n        \n        # LP variables: r_0, r_1, ..., r_{n-1}\n        # Objective: minimize -sum(r_i)\n        c = -np.ones(n)\n        \n        # Constraints: A_ub @ r <= b_ub\n        A_ub = []\n        b_ub = []\n        \n        # Boundary constraints: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n        for i in range(n):\n            x_i, y_i = centers[i]\n            # r_i <= x_i\n            row = np.zeros(n)\n            row[i] = 1\n            A_ub.append(row)\n            b_ub.append(x_i)\n            # r_i <= y_i\n            A_ub.append(row.copy())\n            b_ub.append(y_i)\n            # r_i <= 1-x_i\n            A_ub.append(row.copy())\n            b_ub.append(1 - x_i)\n            # r_i <= 1-y_i\n            A_ub.append(row.copy())\n            b_ub.append(1 - y_i)\n        \n        # Non-overlap constraints: r_i + r_j <= dist_ij - 1e-6\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dists[i, j] - 1e-6)\n        \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        \n        # Bounds: r_i >= 0\n        bounds = [(0, None) for _ in range(n)]\n        \n        try:\n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if result.success:\n                radii = np.maximum(result.x, 0)  # Clip tiny negatives\n                sum_radii = np.sum(radii)\n                cache[key] = (radii, sum_radii, True)\n                return radii, sum_radii, True\n            else:\n                cache[key] = (np.zeros(n), 0.0, False)\n                return np.zeros(n), 0.0, False\n        except:\n            cache[key] = (np.zeros(n), 0.0, False)\n            return np.zeros(n), 0.0, False\n    \n    def initialize_centers():\n        # Triangular grid with jitter\n        n = 26\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        \n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (j + 0.5 * (i % 2)) / grid_size\n                y = i / grid_size\n                # Add jitter\n                x += np.random.uniform(-0.05, 0.05)\n                y += np.random.uniform(-0.05, 0.05)\n                # Clip to bounds\n                x = np.clip(x, 0.05, 0.95)\n                y = np.clip(y, 0.05, 0.95)\n                centers.append([x, y])\n        \n        return np.array(centers[:n])\n    \n    def optimize_centers():\n        centers = initialize_centers()\n        step_size = 0.05\n        max_iters = 1000\n        min_step = 1e-3\n        \n        # Initial evaluation\n        radii, sum_radii, success = solve_lp(centers)\n        if not success:\n            return centers, np.zeros(26), 0.0\n        \n        best_sum = sum_radii\n        \n        for iteration in range(max_iters):\n            improved = False\n            \n            for i in range(len(centers)):\n                current_center = centers[i].copy()\n                best_move = None\n                best_value = best_sum\n                \n                # Try 8 directions\n                directions = [\n                    [step_size, 0], [-step_size, 0],\n                    [0, step_size], [0, -step_size],\n                    [step_size, step_size], [step_size, -step_size],\n                    [-step_size, step_size], [-step_size, -step_size]\n                ]\n                \n                for dx, dy in directions:\n                    new_pos = current_center + [dx, dy]\n                    # Check bounds\n                    if 0 <= new_pos[0] <= 1 and 0 <= new_pos[1] <= 1:\n                        centers[i] = new_pos\n                        _, sum_val, success = solve_lp(centers)\n                        if success and sum_val > best_value:\n                            best_value = sum_val\n                            best_move = new_pos.copy()\n                \n                if best_move is not None:\n                    centers[i] = best_move\n                    best_sum = best_value\n                    improved = True\n                else:\n                    centers[i] = current_center\n            \n            if not improved:\n                step_size *= 0.5\n                if step_size < min_step:\n                    break\n        \n        return centers\n    \n    # Run optimization\n    np.random.seed(42)\n    centers = optimize_centers()\n    \n    # Final LP solve\n    radii, sum_radii, success = solve_lp(centers)\n    \n    if not success:\n        # Fallback: uniform shrinking\n        radii = np.full(26, 0.01)\n        sum_radii = 26 * 0.01\n    \n    # Ensure strict feasibility\n    radii = np.maximum(radii, 0)\n    \n    # Verify constraints\n    for i in range(26):\n        x, y = centers[i]\n        r = radii[i]\n        # Boundary constraints\n        radii[i] = min(radii[i], x, y, 1-x, 1-y)\n    \n    # Non-overlap constraints\n    for i in range(26):\n        for j in range(i + 1, 26):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            max_sum = dist - 1e-6\n            if radii[i] + radii[j] > max_sum:\n                # Shrink proportionally\n                factor = max_sum / (radii[i] + radii[j])\n                radii[i] *= factor\n                radii[j] *= factor\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.3206504496577685,
    "eval_time": 9.490234375,
    "error": null
  },
  "prompt": "Improve or create a high-quality solver for packing 26 circles to maximize sum of radii.\n\nYou must produce a single Python code block with NO prose.\nRequirements:\n- Define construct_packing() as the entry point; optional run_packing().\n- Return (centers, radii, sum_radii) where centers is np.array (26,2), radii is np.array (26,), sum_radii is float.\n- Use only numpy and scipy.\n- Exactly 26 circles; all inside [0,1]^2; no overlaps (tolerance 1e-6); radii >= 0.\n- Include a robust LP feasibilization step using scipy.optimize.linprog to maximize sum(r):\n  Variables r_i, objective maximize sum r_i (use minimize -sum r_i).\n  Constraints:\n    r_i >= 0\n    r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    r_i + r_j <= dist_ij - 1e-6 for all i<j\n  Also enforce r_i <= r_i_current to keep improvements conservative if needed.\n- Use vectorized computations. If using penalties/gradients: apply eps only in divisions, not in penalty values (avoid bias).\n- Ensure strict feasibility at the end (clip tiny negatives to 0; verify constraints; if LP infeasible due to numerical issues, shrink uniformly).\n- No prints or extraneous output.\n- Runtime <= 300s.\n\nImplement:\n- Maintain centers C and compute radii by solving the LP at every evaluation (maximize sum r).\n- Objective: maximize LP(C) = optimal sum of radii for given centers.\n- Use derivative-free alternating coordinate search over centers:\n  * Initialize centers on a triangular grid with jitter (26 points).\n  * Iteratively sweep through points; for each point, try moves in {\u00b1dx, 0}x{\u00b1dy, 0} (e.g., 8 directions),\n    evaluate LP(C) after tentative move; accept best improving move; enforce [0,1] bounds.\n  * Anneal step sizes: start at 0.05, halve when no improvement; stop when step < 1e-3 or max iters reached.\n- Cache LP results for repeated center configurations (hash approximate) to save time.\n- After convergence, run a final LP and return that strictly feasible solution.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport hashlib\n\ndef construct_packing():\n    def hash_centers(centers, precision=6):\n        rounded = np.round(centers, precision)\n        return hashlib.md5(rounded.tobytes()).hexdigest()\n    \n    def solve_lp(centers, cache={}):\n        key = hash_centers(centers)\n        if key in cache:\n            return cache[key]\n        \n        n = len(centers)\n        \n        # Compute pairwise distances\n        dists = np.sqrt(np.sum((centers[:, None, :] - centers[None, :, :]) ** 2, axis=2))\n        \n        # LP variables: r_0, r_1, ..., r_{n-1}\n        # Objective: minimize -sum(r_i)\n        c = -np.ones(n)\n        \n        # Constraints: A_ub @ r <= b_ub\n        A_ub = []\n        b_ub = []\n        \n        # Boundary constraints: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n        for i in range(n):\n            x_i, y_i = centers[i]\n            # r_i <= x_i\n            row = np.zeros(n)\n            row[i] = 1\n            A_ub.append(row)\n            b_ub.append(x_i)\n            # r_i <= y_i\n            A_ub.append(row.copy())\n            b_ub.append(y_i)\n            # r_i <= 1-x_i\n            A_ub.append(row.copy())\n            b_ub.append(1 - x_i)\n            # r_i <= 1-y_i\n            A_ub.append(row.copy())\n            b_ub.append(1 - y_i)\n        \n        # Non-overlap constraints: r_i + r_j <= dist_ij - 1e-6\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dists[i, j] - 1e-6)\n        \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        \n        # Bounds: r_i >= 0\n        bounds = [(0, None) for _ in range(n)]\n        \n        try:\n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if result.success:\n                radii = np.maximum(result.x, 0)  # Clip tiny negatives\n                sum_radii = np.sum(radii)\n                cache[key] = (radii, sum_radii, True)\n                return radii, sum_radii, True\n            else:\n                cache[key] = (np.zeros(n), 0.0, False)\n                return np.zeros(n), 0.0, False\n        except:\n            cache[key] = (np.zeros(n), 0.0, False)\n            return np.zeros(n), 0.0, False\n    \n    def initialize_centers():\n        # Triangular grid with jitter\n        n = 26\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        \n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n:\n                    break\n                x = (j + 0.5 * (i % 2)) / grid_size\n                y = i / grid_size\n                # Add jitter\n                x += np.random.uniform(-0.05, 0.05)\n                y += np.random.uniform(-0.05, 0.05)\n                # Clip to bounds\n                x = np.clip(x, 0.05, 0.95)\n                y = np.clip(y, 0.05, 0.95)\n                centers.append([x, y])\n        \n        return np.array(centers[:n])\n    \n    def optimize_centers():\n        centers = initialize_centers()\n        step_size = 0.05\n        max_iters = 1000\n        min_step = 1e-3\n        \n        # Initial evaluation\n        radii, sum_radii, success = solve_lp(centers)\n        if not success:\n            return centers, np.zeros(26), 0.0\n        \n        best_sum = sum_radii\n        \n        for iteration in range(max_iters):\n            improved = False\n            \n            for i in range(len(centers)):\n                current_center = centers[i].copy()\n                best_move = None\n                best_value = best_sum\n                \n                # Try 8 directions\n                directions = [\n                    [step_size, 0], [-step_size, 0],\n                    [0, step_size], [0, -step_size],\n                    [step_size, step_size], [step_size, -step_size],\n                    [-step_size, step_size], [-step_size, -step_size]\n                ]\n                \n                for dx, dy in directions:\n                    new_pos = current_center + [dx, dy]\n                    # Check bounds\n                    if 0 <= new_pos[0] <= 1 and 0 <= new_pos[1] <= 1:\n                        centers[i] = new_pos\n                        _, sum_val, success = solve_lp(centers)\n                        if success and sum_val > best_value:\n                            best_value = sum_val\n                            best_move = new_pos.copy()\n                \n                if best_move is not None:\n                    centers[i] = best_move\n                    best_sum = best_value\n                    improved = True\n                else:\n                    centers[i] = current_center\n            \n            if not improved:\n                step_size *= 0.5\n                if step_size < min_step:\n                    break\n        \n        return centers\n    \n    # Run optimization\n    np.random.seed(42)\n    centers = optimize_centers()\n    \n    # Final LP solve\n    radii, sum_radii, success = solve_lp(centers)\n    \n    if not success:\n        # Fallback: uniform shrinking\n        radii = np.full(26, 0.01)\n        sum_radii = 26 * 0.01\n    \n    # Ensure strict feasibility\n    radii = np.maximum(radii, 0)\n    \n    # Verify constraints\n    for i in range(26):\n        x, y = centers[i]\n        r = radii[i]\n        # Boundary constraints\n        radii[i] = min(radii[i], x, y, 1-x, 1-y)\n    \n    # Non-overlap constraints\n    for i in range(26):\n        for j in range(i + 1, 26):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            max_sum = dist - 1e-6\n            if radii[i] + radii[j] > max_sum:\n                # Shrink proportionally\n                factor = max_sum / (radii[i] + radii[j])\n                radii[i] *= factor\n                radii[j] *= factor\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T01:04:53.111374",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4",
    "temperature": 0.3
  },
  "llm_call_duration_s": 23.202539543039165,
  "eval_duration_s": 9.490247279056348
}