{
  "trial_id": "trial_2_5",
  "generation": 2,
  "parent_id": "trial_1_0",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.special import logsumexp\n\ndef construct_packing():\n    np.set_printoptions( suppress=True, precision=8 )\n\n    n = 26\n    eps = 1e-6\n\n    # 1) Initialize 26 centers on a hex-like grid inside [0,1]^2\n    centers = []\n    start_x, start_y = 0.08, 0.08\n    col_spacing = 0.15\n    row_spacing = 0.16\n    for i in range(5):  # up to 5 rows\n        y = start_y + i * row_spacing\n        x_offset = 0.0 if i % 2 == 0 else col_spacing / 2.0\n        for j in range(6):  # up to 6 cols\n            x = start_x + j * col_spacing + x_offset\n            if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:\n                centers.append([x, y])\n                if len(centers) == n:\n                    break\n        if len(centers) == n:\n            break\n    centers = np.array(centers, dtype=float)\n    # Fallback: if somehow short, pad with deterministic random-ish points\n    if centers.shape[0] < n:\n        rng = np.random.default_rng(12345)\n        while centers.shape[0] < n:\n            pt = rng.uniform(low=0.05, high=0.95, size=2)\n            centers = np.vstack([centers, pt])\n        centers = centers[:n]\n\n    # Helper: solve LP to compute radii given centers\n    def solve_lp_with_centers(centers_cur):\n        ncur = centers_cur.shape[0]\n        # bounds for each radius: r_i in [0, bound_i] where bound_i = min(distance to boundaries)\n        bounds = []\n        for i in range(ncur):\n            cx, cy = centers_cur[i]\n            bound_i = min(cx, cy, 1.0 - cx, 1.0 - cy)\n            bounds.append((0.0, bound_i))\n\n        # Build pairwise distance constraints: r_i + r_j <= dist_ij - eps\n        A_ub = []\n        b_ub = []\n        for i in range(ncur - 1):\n            xi, yi = centers_cur[i]\n            for j in range(i + 1, ncur):\n                xj, yj = centers_cur[j]\n                dist_ij = np.hypot(xi - xj, yi - yj)\n                A_ub.append(np.eye(1, ncur, i)[0] + np.eye(1, ncur, j)[0])  # not directly usable; rebuild row\n                row = np.zeros(ncur)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_ub.append(row)\n                b_ub.append(dist_ij - eps)\n\n        # Convert to arrays\n        if len(A_ub) > 0:\n            A_ub = np.array(A_ub, dtype=float)\n            b_ub = np.array(b_ub, dtype=float)\n        else:\n            A_ub = None\n            b_ub = None\n\n        c = -np.ones(ncur)\n\n        # Use highs solver for robustness\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs', options={'presolve': True, 'tol': 1e-9})\n        radii = None\n        if res.success:\n            radii = res.x\n            # Clip tiny numerical artifacts\n            radii = np.clip(radii, 0.0, None)\n            # Final sanity: ensure radii do not exceed their bounds\n            radii = np.minimum(radii, np.array([b for (a,b) in bounds]))\n        else:\n            radii = None\n        return radii\n\n    # 2) LP to compute initial radii\n    radii = solve_lp_with_centers(centers)\n    if radii is None:\n        # Fallback: make tiny radii\n        radii = np.zeros(n)\n    radii = np.asarray(radii, dtype=float)\n    if radii.shape[0] != n:\n        radii = np.resize(radii, (n,))\n\n    # Feasibility check\n    def check_feasible(rads, C):\n        nloc = rads.shape[0]\n        for i in range(nloc - 1):\n            for j in range(i + 1, nloc):\n                dij = np.hypot(C[i,0]-C[j,0], C[i,1]-C[j,1])\n                if rads[i] + rads[j] > dij - eps + 1e-12:\n                    return False\n        # bounds\n        for i in range(nloc):\n            cx, cy = C[i]\n            if rads[i] < -1e-9 or rads[i] > min(cx, cy, 1.0-cx, 1.0-cy) + 1e-9:\n                return False\n        return True\n\n    if not check_feasible(radii, centers):\n        # Try to shrink uniformly to feasibility\n        scale = 0.95\n        for _ in range(100):\n            radii *= scale\n            if check_feasible(radii, centers):\n                break\n\n    # 3) Center polishing: gradient ascent on surrogate objective\n    # surrogate: s_i = 0.5 * min_j dist(i,j) with softmin to smooth\n    tau = 0.02  # softmin temperature\n    Adam_m = np.zeros((n,2))\n    Adam_v = np.zeros((n,2))\n    beta1 = 0.9\n    beta2 = 0.999\n    lr = 0.6  # step size (start fairly large), will be tempered by Adam\n    max_steps = 200\n\n    centers = centers.copy()\n    for t in range(1, max_steps + 1):\n        # Distances\n        D = np.zeros((n, n))\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.hypot(centers[i,0]-centers[j,0], centers[i,1]-centers[j,1])\n                D[i, j] = d\n                D[j, i] = d\n        # argmin for each i\n        jstar = np.zeros(n, dtype=int)\n        for i in range(n):\n            # exclude self\n            drow = D[i].copy()\n            drow[i] = np.inf\n            jstar[i] = int(np.argmin(drow))\n\n        # Softmin for each i to compute s_i\n        s_vals = np.zeros(n)\n        for i in range(n):\n            vals = np.array([centers[i,0], centers[i,1], 1.0-centers[i,0], 1.0-centers[i,1], 0.5*D[i, jstar[i]]])\n            # soft min\n            neg_vals = -vals / tau\n            soft_min_i = -tau * logsumexp(neg_vals)\n            s_vals[i] = soft_min_i\n\n        # Gradient of sum s with respect to centers\n        grad = np.zeros((n,2))\n        for i in range(n):\n            j = jstar[i]\n            dij = D[i, j]\n            if dij <= 1e-12:\n                continue\n            cx_i, cy_i = centers[i]\n            cx_j, cy_j = centers[j]\n            # d s_i / d x_i and d s_i / d y_i\n            grad[i,0] += 0.5 * (cx_i - cx_j) / dij\n            grad[i,1] += 0.5 * (cy_i - cy_j) / dij\n            # d s_i / d x_j and d s_i / d y_j\n            grad[j,0] += 0.5 * (cx_j - cx_i) / dij\n            grad[j,1] += 0.5 * (cy_j - cy_i) / dij\n\n        # Adam update for gradient ascent\n        Adam_m = beta1 * Adam_m + (1 - beta1) * grad\n        Adam_v = beta2 * Adam_v + (1 - beta2) * (grad * grad)\n        m_hat = Adam_m / (1 - beta1**t)\n        v_hat = Adam_v / (1 - beta2**t)\n        delta = lr * m_hat / (np.sqrt(v_hat) + 1e-8)\n\n        centers = centers + delta\n        centers = np.clip(centers, 0.0, 1.0)  # projection to unit square\n\n    # 4) Re-run LP with updated centers to finalize radii\n    radii = solve_lp_with_centers(centers)\n    if radii is None:\n        radii = np.zeros(n)\n    radii = np.asarray(radii, dtype=float)\n    radii = np.clip(radii, 0.0, None)\n\n    # Final feasibility check; if any violation, gently shrink\n    if not check_feasible(radii, centers):\n        for _ in range(200):\n            radii *= 0.995\n            if check_feasible(radii, centers):\n                break\n        # If still infeasible, fallback to safe clipping to bounds\n        # Recompute bounds to clip\n        bounds = []\n        for i in range(n):\n            cx, cy = centers[i]\n            bound_i = min(cx, cy, 1.0 - cx, 1.0 - cy)\n            bounds.append(bound_i)\n        radii = np.minimum(radii, np.array(bounds))\n\n    sum_radii = float(np.sum(radii))\n    centers_out = centers.copy()\n    radii_out = radii.copy()\n\n    # Ensure shapes\n    centers_out = np.asarray(centers_out, dtype=float).reshape(n, 2)\n    radii_out = np.asarray(radii_out, dtype=float).reshape(n,)\n\n    return centers_out, radii_out, sum_radii\n\ndef run_packing():\n    return construct_packing()\n\n# If the module is run directly, perform a quick solve (optional)\nif __name__ == \"__main__\":\n    centers, radii, total = construct_packing()\n    # This block is intentionally left without prints as per requirements",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.3262965679168701,
    "error": "ValueError: Invalid input for linprog: b_ub must be a 1-D array; b_ub must not have more than one non-singleton dimension and the number of rows in A_ub must equal the number of values in b_ub"
  },
  "prompt": "Improve or create a high-quality solver for packing 26 circles to maximize sum of radii.\n\nYou must produce a single Python code block with NO prose.\nRequirements:\n- Define construct_packing() as the entry point; optional run_packing().\n- Return (centers, radii, sum_radii) where centers is np.array (26,2), radii is np.array (26,), sum_radii is float.\n- Use only numpy and scipy.\n- Exactly 26 circles; all inside [0,1]^2; no overlaps (tolerance 1e-6); radii >= 0.\n- Include a robust LP feasibilization step using scipy.optimize.linprog to maximize sum(r):\n  Variables r_i, objective maximize sum r_i (use minimize -sum r_i).\n  Constraints:\n    r_i >= 0\n    r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    r_i + r_j <= dist_ij - 1e-6 for all i<j\n  Also enforce r_i <= r_i_current to keep improvements conservative if needed.\n- Use vectorized computations. If using penalties/gradients: apply eps only in divisions, not in penalty values (avoid bias).\n- Ensure strict feasibility at the end (clip tiny negatives to 0; verify constraints; if LP infeasible due to numerical issues, shrink uniformly).\n- No prints or extraneous output.\n- Runtime <= 300s.\n\nImplement:\n- Construct 26 initial centers on an approximately hexagonal grid within [0,1]^2.\n- Solve LP to compute radii. Then perform a brief smooth-polish on centers:\n  * Use surrogate sum s(C) = sum_i min(x_i, y_i, 1-x_i, 1-y_i, 0.5*min_{j!=i} dist_ij)\n  * Approximate min via softmin with tau=0.02 (fixed small), compute gradient wrt centers, take ~200 Adam steps with projections to [0,1].\n- Re-run LP to finalize radii and return.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.special import logsumexp\n\ndef construct_packing():\n    np.set_printoptions( suppress=True, precision=8 )\n\n    n = 26\n    eps = 1e-6\n\n    # 1) Initialize 26 centers on a hex-like grid inside [0,1]^2\n    centers = []\n    start_x, start_y = 0.08, 0.08\n    col_spacing = 0.15\n    row_spacing = 0.16\n    for i in range(5):  # up to 5 rows\n        y = start_y + i * row_spacing\n        x_offset = 0.0 if i % 2 == 0 else col_spacing / 2.0\n        for j in range(6):  # up to 6 cols\n            x = start_x + j * col_spacing + x_offset\n            if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:\n                centers.append([x, y])\n                if len(centers) == n:\n                    break\n        if len(centers) == n:\n            break\n    centers = np.array(centers, dtype=float)\n    # Fallback: if somehow short, pad with deterministic random-ish points\n    if centers.shape[0] < n:\n        rng = np.random.default_rng(12345)\n        while centers.shape[0] < n:\n            pt = rng.uniform(low=0.05, high=0.95, size=2)\n            centers = np.vstack([centers, pt])\n        centers = centers[:n]\n\n    # Helper: solve LP to compute radii given centers\n    def solve_lp_with_centers(centers_cur):\n        ncur = centers_cur.shape[0]\n        # bounds for each radius: r_i in [0, bound_i] where bound_i = min(distance to boundaries)\n        bounds = []\n        for i in range(ncur):\n            cx, cy = centers_cur[i]\n            bound_i = min(cx, cy, 1.0 - cx, 1.0 - cy)\n            bounds.append((0.0, bound_i))\n\n        # Build pairwise distance constraints: r_i + r_j <= dist_ij - eps\n        A_ub = []\n        b_ub = []\n        for i in range(ncur - 1):\n            xi, yi = centers_cur[i]\n            for j in range(i + 1, ncur):\n                xj, yj = centers_cur[j]\n                dist_ij = np.hypot(xi - xj, yi - yj)\n                A_ub.append(np.eye(1, ncur, i)[0] + np.eye(1, ncur, j)[0])  # not directly usable; rebuild row\n                row = np.zeros(ncur)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_ub.append(row)\n                b_ub.append(dist_ij - eps)\n\n        # Convert to arrays\n        if len(A_ub) > 0:\n            A_ub = np.array(A_ub, dtype=float)\n            b_ub = np.array(b_ub, dtype=float)\n        else:\n            A_ub = None\n            b_ub = None\n\n        c = -np.ones(ncur)\n\n        # Use highs solver for robustness\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs', options={'presolve': True, 'tol': 1e-9})\n        radii = None\n        if res.success:\n            radii = res.x\n            # Clip tiny numerical artifacts\n            radii = np.clip(radii, 0.0, None)\n            # Final sanity: ensure radii do not exceed their bounds\n            radii = np.minimum(radii, np.array([b for (a,b) in bounds]))\n        else:\n            radii = None\n        return radii\n\n    # 2) LP to compute initial radii\n    radii = solve_lp_with_centers(centers)\n    if radii is None:\n        # Fallback: make tiny radii\n        radii = np.zeros(n)\n    radii = np.asarray(radii, dtype=float)\n    if radii.shape[0] != n:\n        radii = np.resize(radii, (n,))\n\n    # Feasibility check\n    def check_feasible(rads, C):\n        nloc = rads.shape[0]\n        for i in range(nloc - 1):\n            for j in range(i + 1, nloc):\n                dij = np.hypot(C[i,0]-C[j,0], C[i,1]-C[j,1])\n                if rads[i] + rads[j] > dij - eps + 1e-12:\n                    return False\n        # bounds\n        for i in range(nloc):\n            cx, cy = C[i]\n            if rads[i] < -1e-9 or rads[i] > min(cx, cy, 1.0-cx, 1.0-cy) + 1e-9:\n                return False\n        return True\n\n    if not check_feasible(radii, centers):\n        # Try to shrink uniformly to feasibility\n        scale = 0.95\n        for _ in range(100):\n            radii *= scale\n            if check_feasible(radii, centers):\n                break\n\n    # 3) Center polishing: gradient ascent on surrogate objective\n    # surrogate: s_i = 0.5 * min_j dist(i,j) with softmin to smooth\n    tau = 0.02  # softmin temperature\n    Adam_m = np.zeros((n,2))\n    Adam_v = np.zeros((n,2))\n    beta1 = 0.9\n    beta2 = 0.999\n    lr = 0.6  # step size (start fairly large), will be tempered by Adam\n    max_steps = 200\n\n    centers = centers.copy()\n    for t in range(1, max_steps + 1):\n        # Distances\n        D = np.zeros((n, n))\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.hypot(centers[i,0]-centers[j,0], centers[i,1]-centers[j,1])\n                D[i, j] = d\n                D[j, i] = d\n        # argmin for each i\n        jstar = np.zeros(n, dtype=int)\n        for i in range(n):\n            # exclude self\n            drow = D[i].copy()\n            drow[i] = np.inf\n            jstar[i] = int(np.argmin(drow))\n\n        # Softmin for each i to compute s_i\n        s_vals = np.zeros(n)\n        for i in range(n):\n            vals = np.array([centers[i,0], centers[i,1], 1.0-centers[i,0], 1.0-centers[i,1], 0.5*D[i, jstar[i]]])\n            # soft min\n            neg_vals = -vals / tau\n            soft_min_i = -tau * logsumexp(neg_vals)\n            s_vals[i] = soft_min_i\n\n        # Gradient of sum s with respect to centers\n        grad = np.zeros((n,2))\n        for i in range(n):\n            j = jstar[i]\n            dij = D[i, j]\n            if dij <= 1e-12:\n                continue\n            cx_i, cy_i = centers[i]\n            cx_j, cy_j = centers[j]\n            # d s_i / d x_i and d s_i / d y_i\n            grad[i,0] += 0.5 * (cx_i - cx_j) / dij\n            grad[i,1] += 0.5 * (cy_i - cy_j) / dij\n            # d s_i / d x_j and d s_i / d y_j\n            grad[j,0] += 0.5 * (cx_j - cx_i) / dij\n            grad[j,1] += 0.5 * (cy_j - cy_i) / dij\n\n        # Adam update for gradient ascent\n        Adam_m = beta1 * Adam_m + (1 - beta1) * grad\n        Adam_v = beta2 * Adam_v + (1 - beta2) * (grad * grad)\n        m_hat = Adam_m / (1 - beta1**t)\n        v_hat = Adam_v / (1 - beta2**t)\n        delta = lr * m_hat / (np.sqrt(v_hat) + 1e-8)\n\n        centers = centers + delta\n        centers = np.clip(centers, 0.0, 1.0)  # projection to unit square\n\n    # 4) Re-run LP with updated centers to finalize radii\n    radii = solve_lp_with_centers(centers)\n    if radii is None:\n        radii = np.zeros(n)\n    radii = np.asarray(radii, dtype=float)\n    radii = np.clip(radii, 0.0, None)\n\n    # Final feasibility check; if any violation, gently shrink\n    if not check_feasible(radii, centers):\n        for _ in range(200):\n            radii *= 0.995\n            if check_feasible(radii, centers):\n                break\n        # If still infeasible, fallback to safe clipping to bounds\n        # Recompute bounds to clip\n        bounds = []\n        for i in range(n):\n            cx, cy = centers[i]\n            bound_i = min(cx, cy, 1.0 - cx, 1.0 - cy)\n            bounds.append(bound_i)\n        radii = np.minimum(radii, np.array(bounds))\n\n    sum_radii = float(np.sum(radii))\n    centers_out = centers.copy()\n    radii_out = radii.copy()\n\n    # Ensure shapes\n    centers_out = np.asarray(centers_out, dtype=float).reshape(n, 2)\n    radii_out = np.asarray(radii_out, dtype=float).reshape(n,)\n\n    return centers_out, radii_out, sum_radii\n\ndef run_packing():\n    return construct_packing()\n\n# If the module is run directly, perform a quick solve (optional)\nif __name__ == \"__main__\":\n    centers, radii, total = construct_packing()\n    # This block is intentionally left without prints as per requirements\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T01:06:07.654044",
  "cost_data": null,
  "model_config": {
    "model": "openai/gpt-5-nano",
    "temperature": 0.25
  },
  "llm_call_duration_s": 106.91163028497249,
  "eval_duration_s": 0.32630440895445645
}