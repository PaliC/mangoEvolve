{
  "trial_id": "trial_18_6",
  "generation": 18,
  "parent_id": "trial_10_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 non-overlapping circles in the unit square by optimizing an unconstrained\n    78-dim parameterization (p in R^78) with sigmoid/softplus mappings, followed by\n    a final LP to extract a feasible radii set that maximizes the sum of radii.\n\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii:   np.array of shape (26,)\n        sum_radii: float, sum of radii\n    \"\"\"\n\n    rng = np.random.default_rng(0)\n\n    N = 26  # number of circles\n    mu = 1.0  # penalty weight for pair/boundary violations\n\n    # Initial lattice-like seed (26 centers): 3 rows (9,8,9)\n    row1_y = 0.15\n    row2_y = 0.50\n    row3_y = 0.85\n\n    x1 = np.linspace(0.10, 0.90, 9)  # 9 in row1\n    x2 = np.linspace(0.15, 0.85, 8)  # 8 in row2\n    x3 = np.linspace(0.10, 0.90, 9)  # 9 in row3\n\n    centers_seed = []\n    radii_seed = []\n\n    for x in x1:\n        centers_seed.append([x, row1_y]); radii_seed.append(0.07)\n    for x in x2:\n        centers_seed.append([x, row2_y]); radii_seed.append(0.07)\n    for x in x3:\n        centers_seed.append([x, row3_y]); radii_seed.append(0.07)\n\n    centers_seed = np.array(centers_seed)  # (26,2)\n    radii_seed = np.array(radii_seed)      # (26,)\n\n    # Build 10 perturbed seeds in p-space (inverse maps)\n    seeds_p = []\n    for s in range(10):\n        # slight jitter to centers\n        c = centers_seed + (rng.random((N, 2)) - 0.5) * 0.05\n        c = np.clip(c, 0.01, 0.99)\n\n        # radii jitter around seed\n        r = radii_seed * (0.9 + 0.4 * rng.random(N))\n        r = np.clip(r, 1e-6, 0.49)\n\n        # Inverse transforms to p-space\n        x_seed = c[:, 0]\n        y_seed = c[:, 1]\n        p_x = np.log(x_seed / (1.0 - x_seed))\n        p_y = np.log(y_seed / (1.0 - y_seed))\n        # softplus inverse: log(exp(r) - 1)\n        p_r = np.log(np.exp(r) - 1.0)\n        p = np.concatenate([p_x, p_y, p_r])\n        seeds_p.append((p, c, r))\n\n    # Sigmoid and softplus helpers\n    def sigmoid(z):\n        z = np.asarray(z)\n        return 1.0 / (1.0 + np.exp(-z))\n\n    def logit(x):\n        x = np.clip(np.asarray(x), 1e-9, 1 - 1e-9)\n        return np.log(x / (1.0 - x))\n\n    def softplus_inv(r):\n        # inverse of softplus\n        r = np.asarray(r)\n        return np.log(np.exp(r) - 1.0)\n\n    def unpack_p(p):\n        # p has length 78: [p_x (26), p_y (26), p_r (26)]\n        p = np.asarray(p)\n        p_x = p[:N]\n        p_y = p[N:2*N]\n        p_r = p[2*N:3*N]\n        x = sigmoid(p_x)\n        y = sigmoid(p_y)\n        r = softplus(p_r)  # softplus\n        return x, y, r\n\n    def loss_and_grad(p):\n        x, y, r = unpack_p(p)\n        # pairwise distances\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.hypot(dx, dy)  # (N,N)\n        s = r[:, None] + r[None, :]\n        # consider only i<j\n        pair_mask = np.triu(np.ones((N, N), dtype=bool), k=1)\n        dist_p = dist[pair_mask]\n        s_p = s[pair_mask]\n\n        viol = dist_p < s_p\n        delta = s_p - dist_p\n        P_batch = np.sum((delta[viol]) ** 2)\n\n        # Boundary penalties\n        # b1: r_i > x_i  -> (r_i - x_i)^2\n        b1 = np.maximum(0.0, r - x)\n        # b2: r_i > 1 - x_i -> (r_i - (1 - x_i))^2\n        b2 = np.maximum(0.0, r - (1.0 - x))\n        # b3: r_i > y_i -> (r_i - y_i)^2\n        b3 = np.maximum(0.0, r - y)\n        # b4: r_i > 1 - y_i -> (r_i - (1 - y_i))^2\n        b4 = np.maximum(0.0, r - (1.0 - y))\n\n        P_boundary = np.sum(b1**2 + b2**2 + b3**2 + b4**2)\n\n        L = -np.sum(r) + mu * (P_batch + P_boundary)\n\n        # Gradients (analytical)\n        dLdx = np.zeros(N)\n        dLdy = np.zeros(N)\n        dLdr = np.zeros(N)\n\n        # Pair contributions (i<j)\n        for i in range(N-1):\n            xi, yi, ri = x[i], y[i], r[i]\n            for j in range(i+1, N):\n                xj, yj, rj = x[j], y[j], r[j]\n                dij = dist[i, j]\n                sij = ri + rj\n                if dij > 0.0 and dij < sij - 1e-12:\n                    delta_ij = sij - dij  # >0\n                    # dx, dy\n                    dx_ij = xi - xj\n                    dy_ij = yi - yj\n                    inv_d = 1.0 / dij\n                    # dL/dx_i += -2*delta * (dx/d)\n                    dLdx[i] += -2.0 * delta_ij * (dx_ij * inv_d)\n                    dLdx[j] +=  2.0 * delta_ij * (dx_ij * inv_d)\n                    dLdy[i] += -2.0 * delta_ij * (dy_ij * inv_d)\n                    dLdy[j] +=  2.0 * delta_ij * (dy_ij * inv_d)\n                    # dL/dr_i += 2*delta\n                    dLdr[i] += mu * (2.0 * delta_ij)\n                    dLdr[j] += mu * (2.0 * delta_ij)\n\n        # Boundary derivatives\n        for i in range(N):\n            xi, yi, ri = x[i], y[i], r[i]\n            # b1\n            if ri > xi:\n                dLdx[i] += mu * (-2.0) * (ri - xi)\n                dLdr[i] += mu * (2.0) * (ri - xi)\n            # b2\n            t2 = ri - (1.0 - xi)\n            if t2 > 0.0:\n                dLdx[i] += mu * (2.0) * t2\n                dLdr[i] += mu * (2.0) * t2\n            # b3\n            if ri > yi:\n                dLdy[i] += mu * (-2.0) * (ri - yi)\n                dLdr[i] += mu * (2.0) * (ri - yi)\n            # b4\n            t4 = ri - (1.0 - yi)\n            if t4 > 0.0:\n                dLdy[i] += mu * (2.0) * t4\n                dLdr[i] += mu * (2.0) * t4\n\n        # Gradient wrt p via chain rule\n        p_x = p[:N]\n        p_y = p[N:2*N]\n        p_r = p[2*N:3*N]\n        x_s = sigmoid(p_x)\n        y_s = sigmoid(p_y)\n        r_s = sigmoid(p_r)  # dr/dp_r\n\n        grad_p_x = dLdx * x_s * (1.0 - x_s)\n        grad_p_y = dLdy * y_s * (1.0 - y_s)\n        grad_p_r = dLdr * r_s\n\n        grad = np.concatenate([grad_p_x, grad_p_y, grad_p_r])\n\n        return L, grad\n\n    # Build 10 starting points in p-space\n    starts = []\n    for (p_seed, c_seed, r_seed) in seeds_p:\n        starts.append(p_seed)\n\n    best_sum = -1.0\n    best_centers = None\n    best_p = None\n    best_r = None\n\n    # Run multi-start optimizations\n    for p0 in starts:\n        p0 = np.asarray(p0)\n\n        # Objective wrapper for minimize\n        def func(p):\n            val, _ = loss_and_grad(p)\n            return val\n\n        def jac(p):\n            _, g = loss_and_grad(p)\n            return g\n\n        res = minimize(fun=func,\n                       x0=p0,\n                       jac=jac,\n                       method='L-BFGS-B',\n                       options={'maxiter': 400, 'ftol': 1e-9, 'gtol': 1e-9, 'iprint': 0})\n\n        if not res.success:\n            continue\n\n        # Decode best p to centers/radii\n        x, y, r = unpack_p(res.x)\n        sum_r = float(np.sum(r))\n\n        if sum_r > best_sum:\n            best_sum = sum_r\n            best_centers = np.column_stack((x, y))\n            best_p = res.x\n            best_r = r\n\n    # If optimization didn't converge in any start, fall back to seed\n    if best_centers is None:\n        # Use the first seed as fallback\n        x0, y0, r0 = unpack_p(seeds_p[0][0])\n        best_centers = np.column_stack((x0, y0))\n        best_r = r0\n        best_p = seeds_p[0][0]\n        best_sum = float(np.sum(r0))\n\n    centers = best_centers  # (26,2)\n    radii = best_r\n\n    # Final LP to maximize sum of radii with fixed centers\n    # Build LP constraints: A_ub @ rad <= b_ub\n    A_rows = []\n    b_rows = []\n\n    # Pairwise non-overlap: r_i + r_j <= dist_ij\n    dx = centers[:, 0][:, None] - centers[:, 0][None, :]\n    dy = centers[:, 1][:, None] - centers[:, 1][None, :]\n    dist = np.hypot(dx, dy)\n    for i in range(N-1):\n        for j in range(i+1, N):\n            row = np.zeros(N)\n            row[i] = 1.0\n            row[j] = 1.0\n            A_rows.append(row)\n            b_rows.append(dist[i, j])\n\n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    for i in range(N):\n        row = np.zeros(N)\n        row[i] = 1.0\n        A_rows.append(row)\n        b_rows.append(centers[i, 0])  # r_i <= x_i\n\n        row = np.zeros(N)\n        row[i] = 1.0\n        A_rows.append(row)\n        b_rows.append(1.0 - centers[i, 0])  # r_i <= 1 - x_i\n\n        row = np.zeros(N)\n        row[i] = 1.0\n        A_rows.append(row)\n        b_rows.append(centers[i, 1])  # r_i <= y_i\n\n        row = np.zeros(N)\n        row[i] = 1.0\n        A_rows.append(row)\n        b_rows.append(1.0 - centers[i, 1])  # r_i <= 1 - y_i\n\n    A_ub = np.asarray(A_rows)\n    b_ub = np.asarray(b_rows)\n\n    c = -np.ones(N)  # maximize sum r_i\n\n    bounds = [(0.0, None) for _ in range(N)]\n    try:\n        res_lp = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res_lp.success:\n            radii_lp = res_lp.x\n            radii = radii_lp\n            sum_radii = float(np.sum(radii))\n        else:\n            sum_radii = float(np.sum(radii))\n    except Exception:\n        sum_radii = float(np.sum(radii))\n\n    return centers, radii, float(np.sum(radii))",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.3234367370605469,
    "error": "NameError: name 'softplus' is not defined"
  },
  "prompt": "\nOptimize in unconstrained space:\n- Param p in R^78; map:\n  * x = sigmoid(p_x), y = sigmoid(p_y)\n  * r_raw = softplus(p_r), then penalize boundary/overlap in objective to keep r reasonable\n- Objective: -sum(r) + mu*(pair + boundary), with analytic gradient via chain rule. Use eps only in divisions.\n- Local optimizer: L-BFGS-B on p (unconstrained bounds None).\n- 10 multi-starts by sampling initial p near a good lattice (encode initial c,r via inverse maps).\n- Final radii from LP (no cap), return feasible solution.\n\nUse vectorized ops; no prints.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 non-overlapping circles in the unit square by optimizing an unconstrained\n    78-dim parameterization (p in R^78) with sigmoid/softplus mappings, followed by\n    a final LP to extract a feasible radii set that maximizes the sum of radii.\n\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii:   np.array of shape (26,)\n        sum_radii: float, sum of radii\n    \"\"\"\n\n    rng = np.random.default_rng(0)\n\n    N = 26  # number of circles\n    mu = 1.0  # penalty weight for pair/boundary violations\n\n    # Initial lattice-like seed (26 centers): 3 rows (9,8,9)\n    row1_y = 0.15\n    row2_y = 0.50\n    row3_y = 0.85\n\n    x1 = np.linspace(0.10, 0.90, 9)  # 9 in row1\n    x2 = np.linspace(0.15, 0.85, 8)  # 8 in row2\n    x3 = np.linspace(0.10, 0.90, 9)  # 9 in row3\n\n    centers_seed = []\n    radii_seed = []\n\n    for x in x1:\n        centers_seed.append([x, row1_y]); radii_seed.append(0.07)\n    for x in x2:\n        centers_seed.append([x, row2_y]); radii_seed.append(0.07)\n    for x in x3:\n        centers_seed.append([x, row3_y]); radii_seed.append(0.07)\n\n    centers_seed = np.array(centers_seed)  # (26,2)\n    radii_seed = np.array(radii_seed)      # (26,)\n\n    # Build 10 perturbed seeds in p-space (inverse maps)\n    seeds_p = []\n    for s in range(10):\n        # slight jitter to centers\n        c = centers_seed + (rng.random((N, 2)) - 0.5) * 0.05\n        c = np.clip(c, 0.01, 0.99)\n\n        # radii jitter around seed\n        r = radii_seed * (0.9 + 0.4 * rng.random(N))\n        r = np.clip(r, 1e-6, 0.49)\n\n        # Inverse transforms to p-space\n        x_seed = c[:, 0]\n        y_seed = c[:, 1]\n        p_x = np.log(x_seed / (1.0 - x_seed))\n        p_y = np.log(y_seed / (1.0 - y_seed))\n        # softplus inverse: log(exp(r) - 1)\n        p_r = np.log(np.exp(r) - 1.0)\n        p = np.concatenate([p_x, p_y, p_r])\n        seeds_p.append((p, c, r))\n\n    # Sigmoid and softplus helpers\n    def sigmoid(z):\n        z = np.asarray(z)\n        return 1.0 / (1.0 + np.exp(-z))\n\n    def logit(x):\n        x = np.clip(np.asarray(x), 1e-9, 1 - 1e-9)\n        return np.log(x / (1.0 - x))\n\n    def softplus_inv(r):\n        # inverse of softplus\n        r = np.asarray(r)\n        return np.log(np.exp(r) - 1.0)\n\n    def unpack_p(p):\n        # p has length 78: [p_x (26), p_y (26), p_r (26)]\n        p = np.asarray(p)\n        p_x = p[:N]\n        p_y = p[N:2*N]\n        p_r = p[2*N:3*N]\n        x = sigmoid(p_x)\n        y = sigmoid(p_y)\n        r = softplus(p_r)  # softplus\n        return x, y, r\n\n    def loss_and_grad(p):\n        x, y, r = unpack_p(p)\n        # pairwise distances\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.hypot(dx, dy)  # (N,N)\n        s = r[:, None] + r[None, :]\n        # consider only i<j\n        pair_mask = np.triu(np.ones((N, N), dtype=bool), k=1)\n        dist_p = dist[pair_mask]\n        s_p = s[pair_mask]\n\n        viol = dist_p < s_p\n        delta = s_p - dist_p\n        P_batch = np.sum((delta[viol]) ** 2)\n\n        # Boundary penalties\n        # b1: r_i > x_i  -> (r_i - x_i)^2\n        b1 = np.maximum(0.0, r - x)\n        # b2: r_i > 1 - x_i -> (r_i - (1 - x_i))^2\n        b2 = np.maximum(0.0, r - (1.0 - x))\n        # b3: r_i > y_i -> (r_i - y_i)^2\n        b3 = np.maximum(0.0, r - y)\n        # b4: r_i > 1 - y_i -> (r_i - (1 - y_i))^2\n        b4 = np.maximum(0.0, r - (1.0 - y))\n\n        P_boundary = np.sum(b1**2 + b2**2 + b3**2 + b4**2)\n\n        L = -np.sum(r) + mu * (P_batch + P_boundary)\n\n        # Gradients (analytical)\n        dLdx = np.zeros(N)\n        dLdy = np.zeros(N)\n        dLdr = np.zeros(N)\n\n        # Pair contributions (i<j)\n        for i in range(N-1):\n            xi, yi, ri = x[i], y[i], r[i]\n            for j in range(i+1, N):\n                xj, yj, rj = x[j], y[j], r[j]\n                dij = dist[i, j]\n                sij = ri + rj\n                if dij > 0.0 and dij < sij - 1e-12:\n                    delta_ij = sij - dij  # >0\n                    # dx, dy\n                    dx_ij = xi - xj\n                    dy_ij = yi - yj\n                    inv_d = 1.0 / dij\n                    # dL/dx_i += -2*delta * (dx/d)\n                    dLdx[i] += -2.0 * delta_ij * (dx_ij * inv_d)\n                    dLdx[j] +=  2.0 * delta_ij * (dx_ij * inv_d)\n                    dLdy[i] += -2.0 * delta_ij * (dy_ij * inv_d)\n                    dLdy[j] +=  2.0 * delta_ij * (dy_ij * inv_d)\n                    # dL/dr_i += 2*delta\n                    dLdr[i] += mu * (2.0 * delta_ij)\n                    dLdr[j] += mu * (2.0 * delta_ij)\n\n        # Boundary derivatives\n        for i in range(N):\n            xi, yi, ri = x[i], y[i], r[i]\n            # b1\n            if ri > xi:\n                dLdx[i] += mu * (-2.0) * (ri - xi)\n                dLdr[i] += mu * (2.0) * (ri - xi)\n            # b2\n            t2 = ri - (1.0 - xi)\n            if t2 > 0.0:\n                dLdx[i] += mu * (2.0) * t2\n                dLdr[i] += mu * (2.0) * t2\n            # b3\n            if ri > yi:\n                dLdy[i] += mu * (-2.0) * (ri - yi)\n                dLdr[i] += mu * (2.0) * (ri - yi)\n            # b4\n            t4 = ri - (1.0 - yi)\n            if t4 > 0.0:\n                dLdy[i] += mu * (2.0) * t4\n                dLdr[i] += mu * (2.0) * t4\n\n        # Gradient wrt p via chain rule\n        p_x = p[:N]\n        p_y = p[N:2*N]\n        p_r = p[2*N:3*N]\n        x_s = sigmoid(p_x)\n        y_s = sigmoid(p_y)\n        r_s = sigmoid(p_r)  # dr/dp_r\n\n        grad_p_x = dLdx * x_s * (1.0 - x_s)\n        grad_p_y = dLdy * y_s * (1.0 - y_s)\n        grad_p_r = dLdr * r_s\n\n        grad = np.concatenate([grad_p_x, grad_p_y, grad_p_r])\n\n        return L, grad\n\n    # Build 10 starting points in p-space\n    starts = []\n    for (p_seed, c_seed, r_seed) in seeds_p:\n        starts.append(p_seed)\n\n    best_sum = -1.0\n    best_centers = None\n    best_p = None\n    best_r = None\n\n    # Run multi-start optimizations\n    for p0 in starts:\n        p0 = np.asarray(p0)\n\n        # Objective wrapper for minimize\n        def func(p):\n            val, _ = loss_and_grad(p)\n            return val\n\n        def jac(p):\n            _, g = loss_and_grad(p)\n            return g\n\n        res = minimize(fun=func,\n                       x0=p0,\n                       jac=jac,\n                       method='L-BFGS-B',\n                       options={'maxiter': 400, 'ftol': 1e-9, 'gtol': 1e-9, 'iprint': 0})\n\n        if not res.success:\n            continue\n\n        # Decode best p to centers/radii\n        x, y, r = unpack_p(res.x)\n        sum_r = float(np.sum(r))\n\n        if sum_r > best_sum:\n            best_sum = sum_r\n            best_centers = np.column_stack((x, y))\n            best_p = res.x\n            best_r = r\n\n    # If optimization didn't converge in any start, fall back to seed\n    if best_centers is None:\n        # Use the first seed as fallback\n        x0, y0, r0 = unpack_p(seeds_p[0][0])\n        best_centers = np.column_stack((x0, y0))\n        best_r = r0\n        best_p = seeds_p[0][0]\n        best_sum = float(np.sum(r0))\n\n    centers = best_centers  # (26,2)\n    radii = best_r\n\n    # Final LP to maximize sum of radii with fixed centers\n    # Build LP constraints: A_ub @ rad <= b_ub\n    A_rows = []\n    b_rows = []\n\n    # Pairwise non-overlap: r_i + r_j <= dist_ij\n    dx = centers[:, 0][:, None] - centers[:, 0][None, :]\n    dy = centers[:, 1][:, None] - centers[:, 1][None, :]\n    dist = np.hypot(dx, dy)\n    for i in range(N-1):\n        for j in range(i+1, N):\n            row = np.zeros(N)\n            row[i] = 1.0\n            row[j] = 1.0\n            A_rows.append(row)\n            b_rows.append(dist[i, j])\n\n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    for i in range(N):\n        row = np.zeros(N)\n        row[i] = 1.0\n        A_rows.append(row)\n        b_rows.append(centers[i, 0])  # r_i <= x_i\n\n        row = np.zeros(N)\n        row[i] = 1.0\n        A_rows.append(row)\n        b_rows.append(1.0 - centers[i, 0])  # r_i <= 1 - x_i\n\n        row = np.zeros(N)\n        row[i] = 1.0\n        A_rows.append(row)\n        b_rows.append(centers[i, 1])  # r_i <= y_i\n\n        row = np.zeros(N)\n        row[i] = 1.0\n        A_rows.append(row)\n        b_rows.append(1.0 - centers[i, 1])  # r_i <= 1 - y_i\n\n    A_ub = np.asarray(A_rows)\n    b_ub = np.asarray(b_rows)\n\n    c = -np.ones(N)  # maximize sum r_i\n\n    bounds = [(0.0, None) for _ in range(N)]\n    try:\n        res_lp = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res_lp.success:\n            radii_lp = res_lp.x\n            radii = radii_lp\n            sum_radii = float(np.sum(radii))\n        else:\n            sum_radii = float(np.sum(radii))\n    except Exception:\n        sum_radii = float(np.sum(radii))\n\n    return centers, radii, float(np.sum(radii))\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T03:36:01.464195",
  "cost_data": null,
  "model_config": {
    "model": "openai/gpt-5-nano",
    "temperature": 0.35
  },
  "llm_call_duration_s": 90.88518525206018,
  "eval_duration_s": 0.3234423539834097
}