{
  "trial_id": "trial_18_3",
  "generation": 18,
  "parent_id": "trial_10_6",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    def min_boundary_distance(centers):\n        \"\"\"Compute minimum distance to boundary for each center.\"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        return np.minimum.reduce([x, 1-x, y, 1-y])\n    \n    def pairwise_distances(centers):\n        \"\"\"Compute pairwise distances between centers.\"\"\"\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        return np.sqrt(np.sum(diff**2, axis=2))\n    \n    def project_centers_sweep(centers, radii, step_size, max_displacement):\n        \"\"\"Single sweep of center projection.\"\"\"\n        n = len(centers)\n        displacement = np.zeros_like(centers)\n        \n        # Boundary projection\n        min_bdry = min_boundary_distance(centers)\n        boundary_violations = radii > min_bdry\n        \n        if np.any(boundary_violations):\n            # Push centers inward\n            x, y = centers[:, 0], centers[:, 1]\n            \n            # Left boundary\n            mask = boundary_violations & (x < 0.5)\n            displacement[mask, 0] += np.maximum(0, radii[mask] - x[mask])\n            \n            # Right boundary\n            mask = boundary_violations & (x >= 0.5)\n            displacement[mask, 0] -= np.maximum(0, radii[mask] - (1 - x[mask]))\n            \n            # Bottom boundary\n            mask = boundary_violations & (y < 0.5)\n            displacement[mask, 1] += np.maximum(0, radii[mask] - y[mask])\n            \n            # Top boundary\n            mask = boundary_violations & (y >= 0.5)\n            displacement[mask, 1] -= np.maximum(0, radii[mask] - (1 - y[mask]))\n        \n        # Pairwise separation\n        distances = pairwise_distances(centers)\n        np.fill_diagonal(distances, np.inf)  # Avoid self-interaction\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                d_ij = distances[i, j]\n                margin = radii[i] + radii[j] - d_ij\n                \n                if margin > 0:\n                    if d_ij < 1e-12:\n                        # Random direction for coincident centers\n                        direction = np.random.randn(2)\n                        direction /= np.linalg.norm(direction)\n                    else:\n                        direction = (centers[i] - centers[j]) / d_ij\n                    \n                    move_dist = margin / 2\n                    displacement[i] += move_dist * direction\n                    displacement[j] -= move_dist * direction\n        \n        # Apply step size and displacement limit\n        displacement *= step_size\n        disp_norms = np.linalg.norm(displacement, axis=1)\n        scale_factors = np.minimum(1.0, max_displacement / np.maximum(disp_norms, 1e-12))\n        displacement *= scale_factors[:, np.newaxis]\n        \n        return centers + displacement\n    \n    def solve_radii_lp(centers):\n        \"\"\"Solve for optimal radii given fixed centers using LP.\"\"\"\n        n = len(centers)\n        \n        # Objective: maximize sum of radii (minimize negative sum)\n        c = -np.ones(n)\n        \n        # Inequality constraints: A_ub @ r <= b_ub\n        constraints = []\n        \n        # Boundary constraints: r_i <= min_boundary_distance_i\n        min_bdry = min_boundary_distance(centers)\n        A_boundary = np.eye(n)\n        constraints.append((A_boundary, min_bdry))\n        \n        # Pairwise constraints: r_i + r_j <= distance_ij\n        distances = pairwise_distances(centers)\n        for i in range(n):\n            for j in range(i+1, n):\n                A_pair = np.zeros(n)\n                A_pair[i] = 1\n                A_pair[j] = 1\n                constraints.append((A_pair.reshape(1, -1), np.array([distances[i, j]])))\n        \n        # Combine all constraints\n        A_ub = np.vstack([A for A, b in constraints])\n        b_ub = np.hstack([b for A, b in constraints])\n        \n        # Non-negativity bounds\n        bounds = [(0, None) for _ in range(n)]\n        \n        # Solve LP\n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if result.success:\n            return result.x\n        else:\n            # Fallback: use boundary-limited radii\n            return min_bdry * 0.9\n    \n    def generate_initial_centers(n, seed_type):\n        \"\"\"Generate initial center configurations.\"\"\"\n        np.random.seed(seed_type)\n        \n        if seed_type == 0:  # Triangular grid\n            rows = int(np.sqrt(n)) + 1\n            centers = []\n            for i in range(rows):\n                for j in range(rows):\n                    if len(centers) >= n:\n                        break\n                    x = (j + 0.5 * (i % 2)) / rows\n                    y = i * np.sqrt(3) / 2 / rows\n                    if 0 <= x <= 1 and 0 <= y <= 1:\n                        centers.append([x, y])\n                if len(centers) >= n:\n                    break\n            \n            while len(centers) < n:\n                centers.append([np.random.random(), np.random.random()])\n            \n            return np.array(centers[:n])\n        \n        elif seed_type == 1:  # Hexagonal-like\n            centers = []\n            side = int(np.ceil(np.sqrt(n)))\n            for i in range(side):\n                for j in range(side):\n                    if len(centers) >= n:\n                        break\n                    x = (j + 0.5 * (i % 2)) / side * 0.9 + 0.05\n                    y = i / side * 0.9 + 0.05\n                    centers.append([x, y])\n            \n            while len(centers) < n:\n                centers.append([np.random.random() * 0.9 + 0.05, np.random.random() * 0.9 + 0.05])\n            \n            return np.array(centers[:n])\n        \n        else:  # Edge-biased random\n            centers = []\n            # Place some near edges\n            for _ in range(n // 3):\n                if np.random.random() < 0.5:\n                    # Near vertical edges\n                    x = np.random.choice([0.05, 0.95])\n                    y = np.random.random()\n                else:\n                    # Near horizontal edges\n                    x = np.random.random()\n                    y = np.random.choice([0.05, 0.95])\n                centers.append([x, y])\n            \n            # Fill remaining with random\n            while len(centers) < n:\n                centers.append([np.random.random(), np.random.random()])\n            \n            return np.array(centers[:n])\n    \n    def optimize_packing(n=26):\n        \"\"\"Main optimization routine.\"\"\"\n        best_sum = 0\n        best_centers = None\n        best_radii = None\n        \n        # Try multiple seed configurations\n        for seed_type in range(3):\n            centers = generate_initial_centers(n, seed_type)\n            \n            # Projection parameters\n            max_sweeps = 200\n            k = 0.45  # Initial provisional radius factor\n            \n            for sweep in range(max_sweeps):\n                # Update provisional radii\n                min_bdry = min_boundary_distance(centers)\n                radii = k * min_bdry\n                \n                # Adaptive k adjustment\n                if sweep > 0 and sweep % 20 == 0:\n                    # Check if we can increase k\n                    distances = pairwise_distances(centers)\n                    np.fill_diagonal(distances, np.inf)\n                    min_pair_dist = np.min(distances)\n                    max_possible_r = min_pair_dist / 2\n                    avg_bdry = np.mean(min_bdry)\n                    \n                    if max_possible_r > k * avg_bdry:\n                        k = min(0.55, k * 1.05)\n                    else:\n                        k = max(0.4, k * 0.98)\n                \n                # Step size and displacement limit (diminishing)\n                step_size = 0.8 * (0.95 ** sweep)\n                max_displacement = 0.1 * (0.98 ** sweep)\n                \n                # Project centers\n                old_centers = centers.copy()\n                centers = project_centers_sweep(centers, radii, step_size, max_displacement)\n                \n                # Check convergence\n                movement = np.max(np.linalg.norm(centers - old_centers, axis=1))\n                if movement < 1e-6:\n                    break\n            \n            # Final LP solve\n            final_radii = solve_radii_lp(centers)\n            sum_radii = np.sum(final_radii)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = final_radii.copy()\n        \n        return best_centers, best_radii, best_sum\n    \n    centers, radii, sum_radii = optimize_packing()\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 1.7211878134167728,
    "eval_time": 0.3552107810974121,
    "error": null
  },
  "prompt": "\nImplement a Dykstra-like projection/repair algorithm on centers:\n- Start from multiple seeds (triangular/hex/edge-biased).\n- Iterate sweeps; in each sweep:\n  * For each boundary where r_i would exceed min_bdry_i, push c_i minimally inward.\n  * For each pair (i,j) with overlap margin m = r_i + r_j - d_ij > 0, move c_i and c_j apart along the line by +/- m/2 directions (handle d_ij=0 by random small direction).\n  * Use diminishing step sizes and limit total displacement per sweep.\n- Radii are adjusted only at the final stage via LP (no caps by candidate radii).\n- For the working radii during center projection, maintain provisional radii via a cheap heuristic: r_i = k * min_bdry_i with k in [0.4, 0.55], adjust k adaptively per sweep.\n- After convergence or max sweeps, run LP and return strictly feasible result.\n\nImplement fully vectorized helpers where possible; loops over pairs can be batched via masking to remain efficient. No prints.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    def min_boundary_distance(centers):\n        \"\"\"Compute minimum distance to boundary for each center.\"\"\"\n        x, y = centers[:, 0], centers[:, 1]\n        return np.minimum.reduce([x, 1-x, y, 1-y])\n    \n    def pairwise_distances(centers):\n        \"\"\"Compute pairwise distances between centers.\"\"\"\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        return np.sqrt(np.sum(diff**2, axis=2))\n    \n    def project_centers_sweep(centers, radii, step_size, max_displacement):\n        \"\"\"Single sweep of center projection.\"\"\"\n        n = len(centers)\n        displacement = np.zeros_like(centers)\n        \n        # Boundary projection\n        min_bdry = min_boundary_distance(centers)\n        boundary_violations = radii > min_bdry\n        \n        if np.any(boundary_violations):\n            # Push centers inward\n            x, y = centers[:, 0], centers[:, 1]\n            \n            # Left boundary\n            mask = boundary_violations & (x < 0.5)\n            displacement[mask, 0] += np.maximum(0, radii[mask] - x[mask])\n            \n            # Right boundary\n            mask = boundary_violations & (x >= 0.5)\n            displacement[mask, 0] -= np.maximum(0, radii[mask] - (1 - x[mask]))\n            \n            # Bottom boundary\n            mask = boundary_violations & (y < 0.5)\n            displacement[mask, 1] += np.maximum(0, radii[mask] - y[mask])\n            \n            # Top boundary\n            mask = boundary_violations & (y >= 0.5)\n            displacement[mask, 1] -= np.maximum(0, radii[mask] - (1 - y[mask]))\n        \n        # Pairwise separation\n        distances = pairwise_distances(centers)\n        np.fill_diagonal(distances, np.inf)  # Avoid self-interaction\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                d_ij = distances[i, j]\n                margin = radii[i] + radii[j] - d_ij\n                \n                if margin > 0:\n                    if d_ij < 1e-12:\n                        # Random direction for coincident centers\n                        direction = np.random.randn(2)\n                        direction /= np.linalg.norm(direction)\n                    else:\n                        direction = (centers[i] - centers[j]) / d_ij\n                    \n                    move_dist = margin / 2\n                    displacement[i] += move_dist * direction\n                    displacement[j] -= move_dist * direction\n        \n        # Apply step size and displacement limit\n        displacement *= step_size\n        disp_norms = np.linalg.norm(displacement, axis=1)\n        scale_factors = np.minimum(1.0, max_displacement / np.maximum(disp_norms, 1e-12))\n        displacement *= scale_factors[:, np.newaxis]\n        \n        return centers + displacement\n    \n    def solve_radii_lp(centers):\n        \"\"\"Solve for optimal radii given fixed centers using LP.\"\"\"\n        n = len(centers)\n        \n        # Objective: maximize sum of radii (minimize negative sum)\n        c = -np.ones(n)\n        \n        # Inequality constraints: A_ub @ r <= b_ub\n        constraints = []\n        \n        # Boundary constraints: r_i <= min_boundary_distance_i\n        min_bdry = min_boundary_distance(centers)\n        A_boundary = np.eye(n)\n        constraints.append((A_boundary, min_bdry))\n        \n        # Pairwise constraints: r_i + r_j <= distance_ij\n        distances = pairwise_distances(centers)\n        for i in range(n):\n            for j in range(i+1, n):\n                A_pair = np.zeros(n)\n                A_pair[i] = 1\n                A_pair[j] = 1\n                constraints.append((A_pair.reshape(1, -1), np.array([distances[i, j]])))\n        \n        # Combine all constraints\n        A_ub = np.vstack([A for A, b in constraints])\n        b_ub = np.hstack([b for A, b in constraints])\n        \n        # Non-negativity bounds\n        bounds = [(0, None) for _ in range(n)]\n        \n        # Solve LP\n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if result.success:\n            return result.x\n        else:\n            # Fallback: use boundary-limited radii\n            return min_bdry * 0.9\n    \n    def generate_initial_centers(n, seed_type):\n        \"\"\"Generate initial center configurations.\"\"\"\n        np.random.seed(seed_type)\n        \n        if seed_type == 0:  # Triangular grid\n            rows = int(np.sqrt(n)) + 1\n            centers = []\n            for i in range(rows):\n                for j in range(rows):\n                    if len(centers) >= n:\n                        break\n                    x = (j + 0.5 * (i % 2)) / rows\n                    y = i * np.sqrt(3) / 2 / rows\n                    if 0 <= x <= 1 and 0 <= y <= 1:\n                        centers.append([x, y])\n                if len(centers) >= n:\n                    break\n            \n            while len(centers) < n:\n                centers.append([np.random.random(), np.random.random()])\n            \n            return np.array(centers[:n])\n        \n        elif seed_type == 1:  # Hexagonal-like\n            centers = []\n            side = int(np.ceil(np.sqrt(n)))\n            for i in range(side):\n                for j in range(side):\n                    if len(centers) >= n:\n                        break\n                    x = (j + 0.5 * (i % 2)) / side * 0.9 + 0.05\n                    y = i / side * 0.9 + 0.05\n                    centers.append([x, y])\n            \n            while len(centers) < n:\n                centers.append([np.random.random() * 0.9 + 0.05, np.random.random() * 0.9 + 0.05])\n            \n            return np.array(centers[:n])\n        \n        else:  # Edge-biased random\n            centers = []\n            # Place some near edges\n            for _ in range(n // 3):\n                if np.random.random() < 0.5:\n                    # Near vertical edges\n                    x = np.random.choice([0.05, 0.95])\n                    y = np.random.random()\n                else:\n                    # Near horizontal edges\n                    x = np.random.random()\n                    y = np.random.choice([0.05, 0.95])\n                centers.append([x, y])\n            \n            # Fill remaining with random\n            while len(centers) < n:\n                centers.append([np.random.random(), np.random.random()])\n            \n            return np.array(centers[:n])\n    \n    def optimize_packing(n=26):\n        \"\"\"Main optimization routine.\"\"\"\n        best_sum = 0\n        best_centers = None\n        best_radii = None\n        \n        # Try multiple seed configurations\n        for seed_type in range(3):\n            centers = generate_initial_centers(n, seed_type)\n            \n            # Projection parameters\n            max_sweeps = 200\n            k = 0.45  # Initial provisional radius factor\n            \n            for sweep in range(max_sweeps):\n                # Update provisional radii\n                min_bdry = min_boundary_distance(centers)\n                radii = k * min_bdry\n                \n                # Adaptive k adjustment\n                if sweep > 0 and sweep % 20 == 0:\n                    # Check if we can increase k\n                    distances = pairwise_distances(centers)\n                    np.fill_diagonal(distances, np.inf)\n                    min_pair_dist = np.min(distances)\n                    max_possible_r = min_pair_dist / 2\n                    avg_bdry = np.mean(min_bdry)\n                    \n                    if max_possible_r > k * avg_bdry:\n                        k = min(0.55, k * 1.05)\n                    else:\n                        k = max(0.4, k * 0.98)\n                \n                # Step size and displacement limit (diminishing)\n                step_size = 0.8 * (0.95 ** sweep)\n                max_displacement = 0.1 * (0.98 ** sweep)\n                \n                # Project centers\n                old_centers = centers.copy()\n                centers = project_centers_sweep(centers, radii, step_size, max_displacement)\n                \n                # Check convergence\n                movement = np.max(np.linalg.norm(centers - old_centers, axis=1))\n                if movement < 1e-6:\n                    break\n            \n            # Final LP solve\n            final_radii = solve_radii_lp(centers)\n            sum_radii = np.sum(final_radii)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = final_radii.copy()\n        \n        return best_centers, best_radii, best_sum\n    \n    centers, radii, sum_radii = optimize_packing()\n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T03:35:03.502714",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4",
    "temperature": 0.35
  },
  "llm_call_duration_s": 32.892916430020705,
  "eval_duration_s": 0.3552172229392454
}