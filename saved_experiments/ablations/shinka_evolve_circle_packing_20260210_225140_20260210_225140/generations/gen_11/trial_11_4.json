{
  "trial_id": "trial_11_4",
  "generation": 11,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    def solve_radii_lp(centers, max_radii=None):\n        n = len(centers)\n        \n        # Objective: maximize sum of radii (minimize negative sum)\n        c = -np.ones(n)\n        \n        # Inequality constraints: A_ub @ r <= b_ub\n        A_ub = []\n        b_ub = []\n        \n        # Pairwise separation constraints: r_i + r_j <= dist_ij - 1e-6\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                constraint[j] = 1\n                A_ub.append(constraint)\n                b_ub.append(dist - 1e-6)\n        \n        # Boundary constraints: r_i <= min(x_i, y_i, 1-x_i, 1-y_i)\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1-x, 1-y)\n            constraint = np.zeros(n)\n            constraint[i] = 1\n            A_ub.append(constraint)\n            b_ub.append(max_r)\n        \n        # Optional max radii constraints\n        if max_radii is not None:\n            for i in range(n):\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                A_ub.append(constraint)\n                b_ub.append(max_radii[i])\n        \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        \n        # Bounds: r_i >= 0\n        bounds = [(0, None) for _ in range(n)]\n        \n        try:\n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if result.success:\n                return result.x, -result.fun\n            else:\n                return np.zeros(n), 0.0\n        except:\n            return np.zeros(n), 0.0\n    \n    def project_centers_dykstra(centers, radii, n_sweeps=200):\n        n = len(centers)\n        centers = centers.copy()\n        \n        for sweep in range(n_sweeps):\n            step_factor = max(0.1, 1.0 - sweep / n_sweeps)\n            \n            # Project pairwise separation constraints\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist < 1e-12:\n                        # Handle coincident points\n                        centers[j] += np.random.normal(0, 0.01, 2)\n                        diff = centers[i] - centers[j]\n                        dist = np.linalg.norm(diff)\n                    \n                    required_dist = radii[i] + radii[j] + 1e-6\n                    if dist < required_dist:\n                        # Move centers apart\n                        direction = diff / (dist + 1e-12)\n                        gap = required_dist - dist\n                        move_i = gap * 0.5 * step_factor\n                        move_j = -gap * 0.5 * step_factor\n                        centers[i] += direction * move_i\n                        centers[j] += direction * move_j\n            \n            # Project boundary constraints\n            for i in range(n):\n                r = radii[i]\n                centers[i, 0] = np.clip(centers[i, 0], r, 1 - r)\n                centers[i, 1] = np.clip(centers[i, 1], r, 1 - r)\n            \n            # Update radii every 10 sweeps\n            if sweep % 10 == 0:\n                new_radii, _ = solve_radii_lp(centers, max_radii=radii * 1.1)\n                radii = new_radii\n        \n        return centers, radii\n    \n    def generate_initial_centers(n):\n        candidates = []\n        \n        # Triangular grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(candidates) >= n:\n                    break\n                x = (j + 0.5 * (i % 2)) / grid_size\n                y = i * np.sqrt(3) / 2 / grid_size\n                if 0 <= x <= 1 and 0 <= y <= 1:\n                    candidates.append([x, y])\n        \n        # Add random points if needed\n        while len(candidates) < n:\n            candidates.append(np.random.uniform(0, 1, 2))\n        \n        return np.array(candidates[:n])\n    \n    def optimize_packing():\n        best_sum = 0\n        best_centers = None\n        best_radii = None\n        \n        # Multiple random starts\n        for seed in range(8):\n            np.random.seed(42 + seed)\n            \n            # Generate initial centers\n            centers = generate_initial_centers(26)\n            \n            # Add some noise\n            centers += np.random.normal(0, 0.05, centers.shape)\n            centers = np.clip(centers, 0.1, 0.9)\n            \n            # Initial radii estimate\n            radii = np.full(26, 0.02)\n            \n            # Dykstra projection\n            centers, radii = project_centers_dykstra(centers, radii, n_sweeps=150)\n            \n            # Final LP optimization\n            final_radii, sum_radii = solve_radii_lp(centers)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = final_radii.copy()\n        \n        return best_centers, best_radii, best_sum\n    \n    # Run optimization\n    centers, radii, sum_radii = optimize_packing()\n    \n    # Ensure all constraints are satisfied\n    for i in range(26):\n        x, y = centers[i]\n        r = radii[i]\n        # Boundary constraints\n        assert r <= x + 1e-10, f\"Circle {i} violates left boundary\"\n        assert r <= y + 1e-10, f\"Circle {i} violates bottom boundary\"\n        assert r <= 1 - x + 1e-10, f\"Circle {i} violates right boundary\"\n        assert r <= 1 - y + 1e-10, f\"Circle {i} violates top boundary\"\n    \n    # Pairwise separation\n    for i in range(26):\n        for j in range(i + 1, 26):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            required = radii[i] + radii[j] + 1e-6\n            assert dist >= required - 1e-10, f\"Circles {i} and {j} overlap\"\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.3771244759148162,
    "eval_time": 1.4732956886291504,
    "error": null
  },
  "prompt": "\nYou must output a single Python code block with no prose.\nImplement:\n- construct_packing() -> (centers, radii, sum_radii)\n- Optional: run_packing()\nReturn types:\n- centers: np.ndarray shape (26,2)\n- radii: np.ndarray shape (26,)\n- sum_radii: float\n\nConstraints:\n- Exactly 26 circles\n- All circles inside [0,1]^2\n- No overlaps: for all i<j, ||c_i - c_j|| >= r_i + r_j + 1e-6 (use 1e-6 margin)\n- Radii non-negative\n\nAllowed modules: numpy, scipy\nNo prints. Keep runtime <= 300s. Use reproducible seeds where randomness is used.\n\nCore methodology requirements:\n- Use a linear program (SciPy linprog with method=\"highs\") to feasibilize radii given centers:\n  Maximize sum r_i subject to:\n    r_i >= 0\n    r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    r_i + r_j <= dist_ij - 1e-6 for all pairs i<j\n  Optionally cap r_i <= r_i_current to be non-expansive during inner loops, but final LP should be uncapped (except bounds above).\n- Always finish with an LP that ensures strict feasibility and maximizes sum of radii for the final centers.\n- If you optimize a penalized continuous objective, provide fully vectorized gradients.\n  Stabilization: apply small epsilon only in divisions (denominator), do NOT add eps to the penalty value itself to avoid bias (per calibration).\n- Prefer annealed penalties and multiple restarts; select the best solution by LP sum of radii.\n\nFinal output must be strictly feasible. No extraneous output.\n\n\nImplement a Dykstra-like projection on centers plus LP for radii:\n- Start from diverse seeds (tri grid, edge/corner-biased), keep 8\u201312 candidates.\n- Iteratively project centers to satisfy pairwise separation constraints with current radii estimates:\n  For any overlapping pair (i,j) with d < r_i + r_j + 1e-6, shift c_i and c_j along their line to enforce equality (split the displacement).\n- Interleave with boundary projection to [r_i, 1-r_i]^2 boxes.\n- After each sweep, recompute radii via LP; optionally inflate small radii by local slack before next sweep.\n- Do 100\u2013300 sweeps with diminishing step relaxations; cache neighbor lists to speed checks.\n- Finish with LP for strict feasibility and choose the best candidate by sum radii.\n\nOptionally add a short analytic-gradient polish on centers in the last 10 sweeps.\nKeep everything vectorized where feasible; no prints; one code block only.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    def solve_radii_lp(centers, max_radii=None):\n        n = len(centers)\n        \n        # Objective: maximize sum of radii (minimize negative sum)\n        c = -np.ones(n)\n        \n        # Inequality constraints: A_ub @ r <= b_ub\n        A_ub = []\n        b_ub = []\n        \n        # Pairwise separation constraints: r_i + r_j <= dist_ij - 1e-6\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                constraint[j] = 1\n                A_ub.append(constraint)\n                b_ub.append(dist - 1e-6)\n        \n        # Boundary constraints: r_i <= min(x_i, y_i, 1-x_i, 1-y_i)\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1-x, 1-y)\n            constraint = np.zeros(n)\n            constraint[i] = 1\n            A_ub.append(constraint)\n            b_ub.append(max_r)\n        \n        # Optional max radii constraints\n        if max_radii is not None:\n            for i in range(n):\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                A_ub.append(constraint)\n                b_ub.append(max_radii[i])\n        \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        \n        # Bounds: r_i >= 0\n        bounds = [(0, None) for _ in range(n)]\n        \n        try:\n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if result.success:\n                return result.x, -result.fun\n            else:\n                return np.zeros(n), 0.0\n        except:\n            return np.zeros(n), 0.0\n    \n    def project_centers_dykstra(centers, radii, n_sweeps=200):\n        n = len(centers)\n        centers = centers.copy()\n        \n        for sweep in range(n_sweeps):\n            step_factor = max(0.1, 1.0 - sweep / n_sweeps)\n            \n            # Project pairwise separation constraints\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist < 1e-12:\n                        # Handle coincident points\n                        centers[j] += np.random.normal(0, 0.01, 2)\n                        diff = centers[i] - centers[j]\n                        dist = np.linalg.norm(diff)\n                    \n                    required_dist = radii[i] + radii[j] + 1e-6\n                    if dist < required_dist:\n                        # Move centers apart\n                        direction = diff / (dist + 1e-12)\n                        gap = required_dist - dist\n                        move_i = gap * 0.5 * step_factor\n                        move_j = -gap * 0.5 * step_factor\n                        centers[i] += direction * move_i\n                        centers[j] += direction * move_j\n            \n            # Project boundary constraints\n            for i in range(n):\n                r = radii[i]\n                centers[i, 0] = np.clip(centers[i, 0], r, 1 - r)\n                centers[i, 1] = np.clip(centers[i, 1], r, 1 - r)\n            \n            # Update radii every 10 sweeps\n            if sweep % 10 == 0:\n                new_radii, _ = solve_radii_lp(centers, max_radii=radii * 1.1)\n                radii = new_radii\n        \n        return centers, radii\n    \n    def generate_initial_centers(n):\n        candidates = []\n        \n        # Triangular grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(candidates) >= n:\n                    break\n                x = (j + 0.5 * (i % 2)) / grid_size\n                y = i * np.sqrt(3) / 2 / grid_size\n                if 0 <= x <= 1 and 0 <= y <= 1:\n                    candidates.append([x, y])\n        \n        # Add random points if needed\n        while len(candidates) < n:\n            candidates.append(np.random.uniform(0, 1, 2))\n        \n        return np.array(candidates[:n])\n    \n    def optimize_packing():\n        best_sum = 0\n        best_centers = None\n        best_radii = None\n        \n        # Multiple random starts\n        for seed in range(8):\n            np.random.seed(42 + seed)\n            \n            # Generate initial centers\n            centers = generate_initial_centers(26)\n            \n            # Add some noise\n            centers += np.random.normal(0, 0.05, centers.shape)\n            centers = np.clip(centers, 0.1, 0.9)\n            \n            # Initial radii estimate\n            radii = np.full(26, 0.02)\n            \n            # Dykstra projection\n            centers, radii = project_centers_dykstra(centers, radii, n_sweeps=150)\n            \n            # Final LP optimization\n            final_radii, sum_radii = solve_radii_lp(centers)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = final_radii.copy()\n        \n        return best_centers, best_radii, best_sum\n    \n    # Run optimization\n    centers, radii, sum_radii = optimize_packing()\n    \n    # Ensure all constraints are satisfied\n    for i in range(26):\n        x, y = centers[i]\n        r = radii[i]\n        # Boundary constraints\n        assert r <= x + 1e-10, f\"Circle {i} violates left boundary\"\n        assert r <= y + 1e-10, f\"Circle {i} violates bottom boundary\"\n        assert r <= 1 - x + 1e-10, f\"Circle {i} violates right boundary\"\n        assert r <= 1 - y + 1e-10, f\"Circle {i} violates top boundary\"\n    \n    # Pairwise separation\n    for i in range(26):\n        for j in range(i + 1, 26):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            required = radii[i] + radii[j] + 1e-6\n            assert dist >= required - 1e-10, f\"Circles {i} and {j} overlap\"\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T02:40:06.680141",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4",
    "temperature": 0.3
  },
  "llm_call_duration_s": 24.217412144993432,
  "eval_duration_s": 1.473300761077553
}