{
  "trial_id": "trial_9_7",
  "generation": 9,
  "parent_id": "trial_7_7",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef lp_max_radii(centers, r_cap=None, margin=1e-6):\n    n = centers.shape[0]\n    # Objective: maximize sum r -> minimize -sum r\n    c = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    # Boundary constraints\n    x = centers[:,0]; y = centers[:,1]\n    bounds_caps = np.stack([x, y, 1-x, 1-y], axis=1)  # shape (n,4)\n    for i in range(n):\n        for k in range(4):\n            row = np.zeros(n); row[i] = 1.0\n            A_ub.append(row); b_ub.append(bounds_caps[i,k])\n    # Pairwise constraints\n    for i in range(n):\n        ci = centers[i]\n        for j in range(i+1, n):\n            d = np.linalg.norm(ci - centers[j])\n            row = np.zeros(n); row[i] = 1.0; row[j] = 1.0\n            A_ub.append(row); b_ub.append(max(0.0, d - margin))\n    A_ub = np.array(A_ub); b_ub = np.array(b_ub)\n    # Bounds: 0 <= r_i <= r_cap_i (if provided), else None upper bound (linprog will be limited by A_ub)\n    if r_cap is not None:\n        bounds = [(0.0, max(0.0, float(r_cap[i]))) for i in range(n)]\n    else:\n        bounds = [(0.0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n    if res.success:\n        r = np.maximum(0.0, res.x)\n        return r\n    # Fallback: minimal feasible radii (zero)\n    return np.zeros(n)\n\ndef strictly_feasible(centers, radii, tol=1e-6):\n    n = len(radii)\n    x = centers[:,0]; y = centers[:,1]\n    if np.any(radii < -1e-9): return False\n    if np.any(x - radii < -tol): return False\n    if np.any(y - radii < -tol): return False\n    if np.any(x + radii > 1 + tol): return False\n    if np.any(y + radii > 1 + tol): return False\n    for i in range(n):\n        for j in range(i+1, n):\n            if np.hypot(*(centers[i]-centers[j])) < radii[i] + radii[j] - tol:\n                return False\n    return True\n\ndef seed_centers(n=26, rng=None):\n    if rng is None:\n        rng = np.random.default_rng(42)\n    # Mix hex-like grid and edge-biased jitter\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n/rows))\n    pts = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(pts) >= n: break\n            off = 0.5*(i % 2)\n            x = (j + off + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            pts.append([x, y])\n    C = np.array(pts[:n], dtype=float)\n    # Edge/corner bias\n    bias = rng.uniform(-0.03, 0.03, size=C.shape)\n    C = np.clip(C + bias, 0.05, 0.95)\n    return C\n\ndef construct_packing():\n    n = 26\n    rng = np.random.default_rng(42)\n    \n    # Initialize centers\n    centers = seed_centers(n, rng)\n    \n    # Optimization parameters\n    max_iter = 200\n    step_size = 0.01\n    step_decay = 0.98\n    tol_active = 1e-4\n    eps = 1e-8\n    \n    for iteration in range(max_iter):\n        # Solve LP for radii\n        radii = lp_max_radii(centers, margin=1e-6)\n        \n        # Compute pairwise distances\n        diff = centers[:, None, :] - centers[None, :, :]  # (n, n, 2)\n        dists = np.sqrt(np.sum(diff**2, axis=2))  # (n, n)\n        np.fill_diagonal(dists, np.inf)  # Avoid self-pairs\n        \n        # Find active pairwise constraints\n        active_pairs = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if radii[i] + radii[j] >= dists[i, j] - tol_active:\n                    active_pairs.append((i, j))\n        \n        # Find boundary-active constraints\n        x, y = centers[:, 0], centers[:, 1]\n        boundary_active = []\n        for i in range(n):\n            if radii[i] >= x[i] - tol_active:\n                boundary_active.append((i, 'left'))\n            if radii[i] >= y[i] - tol_active:\n                boundary_active.append((i, 'bottom'))\n            if radii[i] >= 1 - x[i] - tol_active:\n                boundary_active.append((i, 'right'))\n            if radii[i] >= 1 - y[i] - tol_active:\n                boundary_active.append((i, 'top'))\n        \n        # Compute gradient\n        grad = np.zeros((n, 2))\n        \n        # Pairwise gradient contributions\n        for i, j in active_pairs:\n            d = dists[i, j]\n            if d > eps:\n                direction = (centers[i] - centers[j]) / d\n                grad[i] += direction\n                grad[j] -= direction\n        \n        # Boundary gradient contributions\n        for i, side in boundary_active:\n            if side == 'left':\n                grad[i, 0] += 1.0\n            elif side == 'right':\n                grad[i, 0] -= 1.0\n            elif side == 'bottom':\n                grad[i, 1] += 1.0\n            elif side == 'top':\n                grad[i, 1] -= 1.0\n        \n        # Take gradient step\n        centers_new = centers + step_size * grad\n        \n        # Project to feasible region\n        centers_new = np.clip(centers_new, 0.05, 0.95)\n        \n        # Update centers\n        centers = centers_new\n        \n        # Decay step size\n        step_size *= step_decay\n        \n        # Early stopping if step size is too small\n        if step_size < 1e-6:\n            break\n    \n    # Final LP solve\n    radii = lp_max_radii(centers, margin=1e-6)\n    sum_radii = np.sum(radii)\n    \n    # Verify feasibility\n    if not strictly_feasible(centers, radii, tol=1e-6):\n        # Fallback to zero radii if infeasible\n        radii = np.zeros(n)\n        sum_radii = 0.0\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.534810930116512,
    "eval_time": 0.8278729915618896,
    "error": null
  },
  "prompt": "\n# Reference best trial: trial_7_7 score=2.6358676293444767\nDesign:\n- Loop:\n  a) Solve LP to get radii r.\n  b) Identify active pairwise constraints where r_i + r_j >= d_ij - tol_a.\n  c) Compute subgradient of sum(r) w.r.t centers by moving centers to increase d_ij on active pairs (symmetrically); also include boundary-active edges (push inward).\n  d) Take a projected step; re-solve LP; reduce step.\n- After iterations, return LP radii.\n\n\nRequirements:\n- Provide a single Python code block, no prose.\n- Allowed modules: numpy, scipy.\n- Entry point: construct_packing() -> (centers, radii, sum_radii).\n- centers: np.ndarray shape (26,2), radii: np.ndarray shape (26,), sum_radii: float.\n- Strict feasibility: circles inside [0,1]^2, pairwise non-overlap with tolerance 1e-6.\n- Use an LP to finalize radii given centers to ensure strict feasibility:\n  Maximize sum r_i subject to:\n    r_i >= 0\n    r_i <= x_i, r_i <= y_i, r_i <= 1 - x_i, r_i <= 1 - y_i\n    r_i + r_j <= dist_ij - 1e-6 for all i<j, where dist_ij = ||c_i - c_j||_2\n- Return the LP-improved radii. If optimization fails, gracefully return a feasible solution.\n- No prints. Keep runtime under 300s.\n- Vectorized math. In penalties/gradients, apply epsilon only in denominators (not in penalties) to avoid bias.\n\n\nImplement vectorized active-set extraction and stable step control; eps only in denominators.\n\nInclude:\n\ndef lp_max_radii(centers, r_cap=None, margin=1e-6):\n    import numpy as np\n    from scipy.optimize import linprog\n    n = centers.shape[0]\n    # Objective: maximize sum r -> minimize -sum r\n    c = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    # Boundary constraints\n    x = centers[:,0]; y = centers[:,1]\n    bounds_caps = np.stack([x, y, 1-x, 1-y], axis=1)  # shape (n,4)\n    for i in range(n):\n        for k in range(4):\n            row = np.zeros(n); row[i] = 1.0\n            A_ub.append(row); b_ub.append(bounds_caps[i,k])\n    # Pairwise constraints\n    for i in range(n):\n        ci = centers[i]\n        for j in range(i+1, n):\n            d = np.linalg.norm(ci - centers[j])\n            row = np.zeros(n); row[i] = 1.0; row[j] = 1.0\n            A_ub.append(row); b_ub.append(max(0.0, d - margin))\n    A_ub = np.array(A_ub); b_ub = np.array(b_ub)\n    # Bounds: 0 <= r_i <= r_cap_i (if provided), else None upper bound (linprog will be limited by A_ub)\n    if r_cap is not None:\n        bounds = [(0.0, max(0.0, float(r_cap[i]))) for i in range(n)]\n    else:\n        bounds = [(0.0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n    if res.success:\n        r = np.maximum(0.0, res.x)\n        return r\n    # Fallback: minimal feasible radii (zero)\n    return np.zeros(n)\n\n\ndef strictly_feasible(centers, radii, tol=1e-6):\n    import numpy as np\n    n = len(radii)\n    x = centers[:,0]; y = centers[:,1]\n    if np.any(radii < -1e-9): return False\n    if np.any(x - radii < -tol): return False\n    if np.any(y - radii < -tol): return False\n    if np.any(x + radii > 1 + tol): return False\n    if np.any(y + radii > 1 + tol): return False\n    for i in range(n):\n        for j in range(i+1, n):\n            if np.hypot(*(centers[i]-centers[j])) < radii[i] + radii[j] - tol:\n                return False\n    return True\n\n\ndef seed_centers(n=26, rng=None):\n    import numpy as np\n    if rng is None:\n        rng = np.random.default_rng(42)\n    # Mix hex-like grid and edge-biased jitter\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n/rows))\n    pts = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(pts) >= n: break\n            off = 0.5*(i % 2)\n            x = (j + off + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            pts.append([x, y])\n    C = np.array(pts[:n], dtype=float)\n    # Edge/corner bias\n    bias = rng.uniform(-0.03, 0.03, size=C.shape)\n    C = np.clip(C + bias, 0.05, 0.95)\n    return C\n\n\nProvide ONLY code with construct_packing().\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef lp_max_radii(centers, r_cap=None, margin=1e-6):\n    n = centers.shape[0]\n    # Objective: maximize sum r -> minimize -sum r\n    c = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    # Boundary constraints\n    x = centers[:,0]; y = centers[:,1]\n    bounds_caps = np.stack([x, y, 1-x, 1-y], axis=1)  # shape (n,4)\n    for i in range(n):\n        for k in range(4):\n            row = np.zeros(n); row[i] = 1.0\n            A_ub.append(row); b_ub.append(bounds_caps[i,k])\n    # Pairwise constraints\n    for i in range(n):\n        ci = centers[i]\n        for j in range(i+1, n):\n            d = np.linalg.norm(ci - centers[j])\n            row = np.zeros(n); row[i] = 1.0; row[j] = 1.0\n            A_ub.append(row); b_ub.append(max(0.0, d - margin))\n    A_ub = np.array(A_ub); b_ub = np.array(b_ub)\n    # Bounds: 0 <= r_i <= r_cap_i (if provided), else None upper bound (linprog will be limited by A_ub)\n    if r_cap is not None:\n        bounds = [(0.0, max(0.0, float(r_cap[i]))) for i in range(n)]\n    else:\n        bounds = [(0.0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n    if res.success:\n        r = np.maximum(0.0, res.x)\n        return r\n    # Fallback: minimal feasible radii (zero)\n    return np.zeros(n)\n\ndef strictly_feasible(centers, radii, tol=1e-6):\n    n = len(radii)\n    x = centers[:,0]; y = centers[:,1]\n    if np.any(radii < -1e-9): return False\n    if np.any(x - radii < -tol): return False\n    if np.any(y - radii < -tol): return False\n    if np.any(x + radii > 1 + tol): return False\n    if np.any(y + radii > 1 + tol): return False\n    for i in range(n):\n        for j in range(i+1, n):\n            if np.hypot(*(centers[i]-centers[j])) < radii[i] + radii[j] - tol:\n                return False\n    return True\n\ndef seed_centers(n=26, rng=None):\n    if rng is None:\n        rng = np.random.default_rng(42)\n    # Mix hex-like grid and edge-biased jitter\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n/rows))\n    pts = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(pts) >= n: break\n            off = 0.5*(i % 2)\n            x = (j + off + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            pts.append([x, y])\n    C = np.array(pts[:n], dtype=float)\n    # Edge/corner bias\n    bias = rng.uniform(-0.03, 0.03, size=C.shape)\n    C = np.clip(C + bias, 0.05, 0.95)\n    return C\n\ndef construct_packing():\n    n = 26\n    rng = np.random.default_rng(42)\n    \n    # Initialize centers\n    centers = seed_centers(n, rng)\n    \n    # Optimization parameters\n    max_iter = 200\n    step_size = 0.01\n    step_decay = 0.98\n    tol_active = 1e-4\n    eps = 1e-8\n    \n    for iteration in range(max_iter):\n        # Solve LP for radii\n        radii = lp_max_radii(centers, margin=1e-6)\n        \n        # Compute pairwise distances\n        diff = centers[:, None, :] - centers[None, :, :]  # (n, n, 2)\n        dists = np.sqrt(np.sum(diff**2, axis=2))  # (n, n)\n        np.fill_diagonal(dists, np.inf)  # Avoid self-pairs\n        \n        # Find active pairwise constraints\n        active_pairs = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if radii[i] + radii[j] >= dists[i, j] - tol_active:\n                    active_pairs.append((i, j))\n        \n        # Find boundary-active constraints\n        x, y = centers[:, 0], centers[:, 1]\n        boundary_active = []\n        for i in range(n):\n            if radii[i] >= x[i] - tol_active:\n                boundary_active.append((i, 'left'))\n            if radii[i] >= y[i] - tol_active:\n                boundary_active.append((i, 'bottom'))\n            if radii[i] >= 1 - x[i] - tol_active:\n                boundary_active.append((i, 'right'))\n            if radii[i] >= 1 - y[i] - tol_active:\n                boundary_active.append((i, 'top'))\n        \n        # Compute gradient\n        grad = np.zeros((n, 2))\n        \n        # Pairwise gradient contributions\n        for i, j in active_pairs:\n            d = dists[i, j]\n            if d > eps:\n                direction = (centers[i] - centers[j]) / d\n                grad[i] += direction\n                grad[j] -= direction\n        \n        # Boundary gradient contributions\n        for i, side in boundary_active:\n            if side == 'left':\n                grad[i, 0] += 1.0\n            elif side == 'right':\n                grad[i, 0] -= 1.0\n            elif side == 'bottom':\n                grad[i, 1] += 1.0\n            elif side == 'top':\n                grad[i, 1] -= 1.0\n        \n        # Take gradient step\n        centers_new = centers + step_size * grad\n        \n        # Project to feasible region\n        centers_new = np.clip(centers_new, 0.05, 0.95)\n        \n        # Update centers\n        centers = centers_new\n        \n        # Decay step size\n        step_size *= step_decay\n        \n        # Early stopping if step size is too small\n        if step_size < 1e-6:\n            break\n    \n    # Final LP solve\n    radii = lp_max_radii(centers, margin=1e-6)\n    sum_radii = np.sum(radii)\n    \n    # Verify feasibility\n    if not strictly_feasible(centers, radii, tol=1e-6):\n        # Fallback to zero radii if infeasible\n        radii = np.zeros(n)\n        sum_radii = 0.0\n    \n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T02:16:24.170289",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4",
    "temperature": 0.15
  },
  "llm_call_duration_s": 20.220677241915837,
  "eval_duration_s": 0.8278788529569283
}