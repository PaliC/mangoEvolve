{
  "trial_id": "trial_9_6",
  "generation": 9,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef lp_max_radii(centers, r_cap=None, margin=1e-6):\n    import numpy as np\n    from scipy.optimize import linprog\n    n = centers.shape[0]\n    # Objective: maximize sum r_i -> minimize -sum r_i\n    c = -np.ones(n)\n\n    A_ub = []\n    b_ub = []\n\n    # Boundary constraints: r_i <= x_i, r_i <= y_i, r_i <= 1 - x_i, r_i <= 1 - y_i\n    x = centers[:, 0]\n    y = centers[:, 1]\n    for i in range(n):\n        row = np.zeros(n)\n        row[i] = 1.0\n        A_ub.append(row)\n        b_ub.append(x[i])\n        row = np.zeros(n)\n        row[i] = 1.0\n        A_ub.append(row)\n        b_ub.append(y[i])\n        row = np.zeros(n)\n        row[i] = 1.0\n        A_ub.append(row)\n        b_ub.append(1.0 - x[i])\n        row = np.zeros(n)\n        row[i] = 1.0\n        A_ub.append(row)\n        b_ub.append(1.0 - y[i])\n\n    # Pairwise constraints: r_i + r_j <= dist_ij - margin\n    for i in range(n):\n        ci = centers[i]\n        for j in range(i + 1, n):\n            cj = centers[j]\n            d = np.linalg.norm(ci - cj)\n            row = np.zeros(n)\n            row[i] = 1.0\n            row[j] = 1.0\n            A_ub.append(row)\n            b_ub.append(max(0.0, d - margin))\n\n    A_ub = np.array(A_ub, dtype=float)\n    b_ub = np.array(b_ub, dtype=float)\n\n    # Bounds on radii\n    if r_cap is not None:\n        bounds = [(0.0, max(0.0, float(r_cap[i]))) for i in range(n)]\n    else:\n        bounds = [(0.0, None)] * n\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n    if res.success:\n        r = np.maximum(0.0, res.x)\n        return r\n    # Fallback feasible radii (all zeros)\n    return np.zeros(n)\n\ndef strictly_feasible(centers, radii, tol=1e-6):\n    n = len(radii)\n    x = centers[:, 0]\n    y = centers[:, 1]\n    if np.any(radii < -1e-9):\n        return False\n    if np.any(x - radii < -tol):\n        return False\n    if np.any(y - radii < -tol):\n        return False\n    if np.any(x + radii > 1 + tol):\n        return False\n    if np.any(y + radii > 1 + tol):\n        return False\n    for i in range(n):\n        for j in range(i + 1, n):\n            if np.hypot(centers[i, 0] - centers[j, 0], centers[i, 1] - centers[j, 1]) < radii[i] + radii[j] - tol:\n                return False\n    return True\n\ndef seed_centers(n=26, rng=None):\n    if rng is None:\n        rng = np.random.default_rng(42)\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n / rows))\n    pts = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(pts) >= n:\n                break\n            off = 0.5 * (i % 2)\n            x = (j + off + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            pts.append([x, y])\n    C = np.array(pts[:n], dtype=float)\n    bias = rng.uniform(-0.03, 0.03, size=C.shape)\n    C = np.clip(C + bias, 0.05, 0.95)\n    return C\n\ndef relocate_centers(centers, iterations=3, span=0.25, steps=5):\n    centers = centers.copy()\n    n = centers.shape[0]\n    for it in range(iterations):\n        for i in range(n):\n            cx, cy = centers[i]\n            best = np.array([cx, cy])\n            best_score = -1.0\n            dx_vals = np.linspace(-span, span, steps)\n            dy_vals = np.linspace(-span, span, steps)\n            for dx in dx_vals:\n                for dy in dy_vals:\n                    nx = cx + dx\n                    ny = cy + dy\n                    nx = min(1.0, max(0.0, nx))\n                    ny = min(1.0, max(0.0, ny))\n                    dist_bound = min(nx, ny, 1.0 - nx, 1.0 - ny)\n                    if i > 0:\n                        dists = np.sqrt((centers[:i, 0] - nx) ** 2 + (centers[:i, 1] - ny) ** 2)\n                        min_dist_others = dists.min() if dists.size > 0 else np.inf\n                    else:\n                        min_dist_others = np.inf\n                    score = min(dist_bound, min_dist_others)\n                    if score > best_score:\n                        best_score = score\n                        best = np.array([nx, ny])\n            centers[i] = best\n    return centers\n\ndef construct_packing():\n    n = 26\n\n    # Seed centers\n    centers = seed_centers(n)\n\n    # Optional: coarse local relocation to improve placement\n    centers = relocate_centers(centers, iterations=2, span=0.25, steps=7)\n\n    # Solve LP to maximize radii given centers\n    radii = lp_max_radii(centers, r_cap=None, margin=1e-6)\n\n    # Ensure feasibility; if LP failed to produce valid radii, fall back to zeros (shouldn't happen)\n    if not strictly_feasible(centers, radii, tol=1e-6):\n        # Fallback: small equal radii while keeping inside boundaries\n        # Compute a conservative uniform radius\n        max_r = min(centers[:,0].min(), centers[:,1].min(), 1-centers[:,0].max(), 1-centers[:,1].max()) * 0.25\n        radii = np.full(n, max(0.0, max_r))\n        # If still not feasible, zero radii\n        if not strictly_feasible(centers, radii, tol=1e-6):\n            radii = np.zeros(n)\n\n    sum_radii = float(np.sum(radii))\n    centers = np.asarray(centers, dtype=float)\n    radii = np.asarray(radii, dtype=float)\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 1.850248956629081,
    "eval_time": 0.3530263900756836,
    "error": null
  },
  "prompt": "\n# Reference best trial: trial_7_7 score=2.6358676293444767\nDesign:\n- Construct centers iteratively: start from empty set; place each new center at the point maximizing minimal distance to (i) boundaries and (ii) existing centers (use a coarse grid refined near gaps). For each placement, assign radius as that minimal distance. Repeat to get 26.\n- Then apply a few iterations of local centroid-like relocation: move each center toward the weighted centroid of its clearance region (approximate via sampling), keeping it within [0,1].\n- Final LP to maximize radii and return.\n\n\nRequirements:\n- Provide a single Python code block, no prose.\n- Allowed modules: numpy, scipy.\n- Entry point: construct_packing() -> (centers, radii, sum_radii).\n- centers: np.ndarray shape (26,2), radii: np.ndarray shape (26,), sum_radii: float.\n- Strict feasibility: circles inside [0,1]^2, pairwise non-overlap with tolerance 1e-6.\n- Use an LP to finalize radii given centers to ensure strict feasibility:\n  Maximize sum r_i subject to:\n    r_i >= 0\n    r_i <= x_i, r_i <= y_i, r_i <= 1 - x_i, r_i <= 1 - y_i\n    r_i + r_j <= dist_ij - 1e-6 for all i<j, where dist_ij = ||c_i - c_j||_2\n- Return the LP-improved radii. If optimization fails, gracefully return a feasible solution.\n- No prints. Keep runtime under 300s.\n- Vectorized math. In penalties/gradients, apply epsilon only in denominators (not in penalties) to avoid bias.\n\n\nKeep runtime by using moderate grid sizes and samples; ensure strict feasibility by LP at the end.\n\nInclude:\n\ndef lp_max_radii(centers, r_cap=None, margin=1e-6):\n    import numpy as np\n    from scipy.optimize import linprog\n    n = centers.shape[0]\n    # Objective: maximize sum r -> minimize -sum r\n    c = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    # Boundary constraints\n    x = centers[:,0]; y = centers[:,1]\n    bounds_caps = np.stack([x, y, 1-x, 1-y], axis=1)  # shape (n,4)\n    for i in range(n):\n        for k in range(4):\n            row = np.zeros(n); row[i] = 1.0\n            A_ub.append(row); b_ub.append(bounds_caps[i,k])\n    # Pairwise constraints\n    for i in range(n):\n        ci = centers[i]\n        for j in range(i+1, n):\n            d = np.linalg.norm(ci - centers[j])\n            row = np.zeros(n); row[i] = 1.0; row[j] = 1.0\n            A_ub.append(row); b_ub.append(max(0.0, d - margin))\n    A_ub = np.array(A_ub); b_ub = np.array(b_ub)\n    # Bounds: 0 <= r_i <= r_cap_i (if provided), else None upper bound (linprog will be limited by A_ub)\n    if r_cap is not None:\n        bounds = [(0.0, max(0.0, float(r_cap[i]))) for i in range(n)]\n    else:\n        bounds = [(0.0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n    if res.success:\n        r = np.maximum(0.0, res.x)\n        return r\n    # Fallback: minimal feasible radii (zero)\n    return np.zeros(n)\n\n\ndef strictly_feasible(centers, radii, tol=1e-6):\n    import numpy as np\n    n = len(radii)\n    x = centers[:,0]; y = centers[:,1]\n    if np.any(radii < -1e-9): return False\n    if np.any(x - radii < -tol): return False\n    if np.any(y - radii < -tol): return False\n    if np.any(x + radii > 1 + tol): return False\n    if np.any(y + radii > 1 + tol): return False\n    for i in range(n):\n        for j in range(i+1, n):\n            if np.hypot(*(centers[i]-centers[j])) < radii[i] + radii[j] - tol:\n                return False\n    return True\n\n\ndef seed_centers(n=26, rng=None):\n    import numpy as np\n    if rng is None:\n        rng = np.random.default_rng(42)\n    # Mix hex-like grid and edge-biased jitter\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n/rows))\n    pts = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(pts) >= n: break\n            off = 0.5*(i % 2)\n            x = (j + off + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            pts.append([x, y])\n    C = np.array(pts[:n], dtype=float)\n    # Edge/corner bias\n    bias = rng.uniform(-0.03, 0.03, size=C.shape)\n    C = np.clip(C + bias, 0.05, 0.95)\n    return C\n\n\nProvide ONLY code with construct_packing().\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef lp_max_radii(centers, r_cap=None, margin=1e-6):\n    import numpy as np\n    from scipy.optimize import linprog\n    n = centers.shape[0]\n    # Objective: maximize sum r_i -> minimize -sum r_i\n    c = -np.ones(n)\n\n    A_ub = []\n    b_ub = []\n\n    # Boundary constraints: r_i <= x_i, r_i <= y_i, r_i <= 1 - x_i, r_i <= 1 - y_i\n    x = centers[:, 0]\n    y = centers[:, 1]\n    for i in range(n):\n        row = np.zeros(n)\n        row[i] = 1.0\n        A_ub.append(row)\n        b_ub.append(x[i])\n        row = np.zeros(n)\n        row[i] = 1.0\n        A_ub.append(row)\n        b_ub.append(y[i])\n        row = np.zeros(n)\n        row[i] = 1.0\n        A_ub.append(row)\n        b_ub.append(1.0 - x[i])\n        row = np.zeros(n)\n        row[i] = 1.0\n        A_ub.append(row)\n        b_ub.append(1.0 - y[i])\n\n    # Pairwise constraints: r_i + r_j <= dist_ij - margin\n    for i in range(n):\n        ci = centers[i]\n        for j in range(i + 1, n):\n            cj = centers[j]\n            d = np.linalg.norm(ci - cj)\n            row = np.zeros(n)\n            row[i] = 1.0\n            row[j] = 1.0\n            A_ub.append(row)\n            b_ub.append(max(0.0, d - margin))\n\n    A_ub = np.array(A_ub, dtype=float)\n    b_ub = np.array(b_ub, dtype=float)\n\n    # Bounds on radii\n    if r_cap is not None:\n        bounds = [(0.0, max(0.0, float(r_cap[i]))) for i in range(n)]\n    else:\n        bounds = [(0.0, None)] * n\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n    if res.success:\n        r = np.maximum(0.0, res.x)\n        return r\n    # Fallback feasible radii (all zeros)\n    return np.zeros(n)\n\ndef strictly_feasible(centers, radii, tol=1e-6):\n    n = len(radii)\n    x = centers[:, 0]\n    y = centers[:, 1]\n    if np.any(radii < -1e-9):\n        return False\n    if np.any(x - radii < -tol):\n        return False\n    if np.any(y - radii < -tol):\n        return False\n    if np.any(x + radii > 1 + tol):\n        return False\n    if np.any(y + radii > 1 + tol):\n        return False\n    for i in range(n):\n        for j in range(i + 1, n):\n            if np.hypot(centers[i, 0] - centers[j, 0], centers[i, 1] - centers[j, 1]) < radii[i] + radii[j] - tol:\n                return False\n    return True\n\ndef seed_centers(n=26, rng=None):\n    if rng is None:\n        rng = np.random.default_rng(42)\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n / rows))\n    pts = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(pts) >= n:\n                break\n            off = 0.5 * (i % 2)\n            x = (j + off + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            pts.append([x, y])\n    C = np.array(pts[:n], dtype=float)\n    bias = rng.uniform(-0.03, 0.03, size=C.shape)\n    C = np.clip(C + bias, 0.05, 0.95)\n    return C\n\ndef relocate_centers(centers, iterations=3, span=0.25, steps=5):\n    centers = centers.copy()\n    n = centers.shape[0]\n    for it in range(iterations):\n        for i in range(n):\n            cx, cy = centers[i]\n            best = np.array([cx, cy])\n            best_score = -1.0\n            dx_vals = np.linspace(-span, span, steps)\n            dy_vals = np.linspace(-span, span, steps)\n            for dx in dx_vals:\n                for dy in dy_vals:\n                    nx = cx + dx\n                    ny = cy + dy\n                    nx = min(1.0, max(0.0, nx))\n                    ny = min(1.0, max(0.0, ny))\n                    dist_bound = min(nx, ny, 1.0 - nx, 1.0 - ny)\n                    if i > 0:\n                        dists = np.sqrt((centers[:i, 0] - nx) ** 2 + (centers[:i, 1] - ny) ** 2)\n                        min_dist_others = dists.min() if dists.size > 0 else np.inf\n                    else:\n                        min_dist_others = np.inf\n                    score = min(dist_bound, min_dist_others)\n                    if score > best_score:\n                        best_score = score\n                        best = np.array([nx, ny])\n            centers[i] = best\n    return centers\n\ndef construct_packing():\n    n = 26\n\n    # Seed centers\n    centers = seed_centers(n)\n\n    # Optional: coarse local relocation to improve placement\n    centers = relocate_centers(centers, iterations=2, span=0.25, steps=7)\n\n    # Solve LP to maximize radii given centers\n    radii = lp_max_radii(centers, r_cap=None, margin=1e-6)\n\n    # Ensure feasibility; if LP failed to produce valid radii, fall back to zeros (shouldn't happen)\n    if not strictly_feasible(centers, radii, tol=1e-6):\n        # Fallback: small equal radii while keeping inside boundaries\n        # Compute a conservative uniform radius\n        max_r = min(centers[:,0].min(), centers[:,1].min(), 1-centers[:,0].max(), 1-centers[:,1].max()) * 0.25\n        radii = np.full(n, max(0.0, max_r))\n        # If still not feasible, zero radii\n        if not strictly_feasible(centers, radii, tol=1e-6):\n            radii = np.zeros(n)\n\n    sum_radii = float(np.sum(radii))\n    centers = np.asarray(centers, dtype=float)\n    radii = np.asarray(radii, dtype=float)\n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T02:16:52.750427",
  "cost_data": null,
  "model_config": {
    "model": "openai/gpt-5-nano",
    "temperature": 0.2
  },
  "llm_call_duration_s": 49.27616888098419,
  "eval_duration_s": 0.3530323030427098
}