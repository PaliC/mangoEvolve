{
  "trial_id": "trial_9_1",
  "generation": 9,
  "parent_id": "trial_7_7",
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef lp_max_radii(centers, r_cap=None, margin=1e-6):\n    import numpy as np\n    from scipy.optimize import linprog\n    n = centers.shape[0]\n    c = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    x = centers[:,0]; y = centers[:,1]\n    bounds_caps = np.stack([x, y, 1-x, 1-y], axis=1)\n    for i in range(n):\n        for k in range(4):\n            row = np.zeros(n); row[i] = 1.0\n            A_ub.append(row); b_ub.append(bounds_caps[i,k])\n    for i in range(n):\n        ci = centers[i]\n        for j in range(i+1, n):\n            d = np.linalg.norm(ci - centers[j])\n            row = np.zeros(n); row[i] = 1.0; row[j] = 1.0\n            A_ub.append(row); b_ub.append(max(0.0, d - margin))\n    A_ub = np.array(A_ub); b_ub = np.array(b_ub)\n    if r_cap is not None:\n        bounds = [(0.0, max(0.0, float(r_cap[i]))) for i in range(n)]\n    else:\n        bounds = [(0.0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n    if res.success:\n        return np.maximum(0.0, res.x)\n    return np.zeros(n)\n\ndef strictly_feasible(centers, radii, tol=1e-6):\n    import numpy as np\n    n = len(radii)\n    x = centers[:,0]; y = centers[:,1]\n    if np.any(radii < -1e-9): return False\n    if np.any(x - radii < -tol): return False\n    if np.any(y - radii < -tol): return False\n    if np.any(x + radii > 1 + tol): return False\n    if np.any(y + radii > 1 + tol): return False\n    for i in range(n):\n        for j in range(i+1, n):\n            if np.hypot(*(centers[i]-centers[j])) < radii[i] + radii[j] - tol:\n                return False\n    return True\n\ndef seed_centers(n=26, rng=None):\n    import numpy as np\n    if rng is None:\n        rng = np.random.default_rng(42)\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n/rows))\n    pts = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(pts) >= n: break\n            off = 0.5*(i % 2)\n            x = (j + off + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            pts.append([x, y])\n    C = np.array(pts[:n], dtype=float)\n    bias = rng.uniform(-0.03, 0.03, size=C.shape)\n    C = np.clip(C + bias, 0.05, 0.95)\n    return C\n\ndef construct_packing():\n    import numpy as np\n    rng = np.random.default_rng(12345)\n    n = 26\n    best_sum = 0.0\n    best_C = None\n    best_R = None\n    # global random search\n    for _ in range(50):\n        C = seed_centers(n, rng)\n        R = lp_max_radii(C, margin=1e-6)\n        if strictly_feasible(C, R):\n            s = R.sum()\n            if s > best_sum:\n                best_sum = s\n                best_C = C.copy()\n                best_R = R.copy()\n    # ensure some starting solution\n    if best_C is None:\n        best_C = seed_centers(n, rng)\n        best_R = lp_max_radii(best_C, margin=1e-6)\n        best_sum = best_R.sum()\n    # local refinement\n    for _ in range(200):\n        C2 = best_C + rng.normal(scale=0.01, size=best_C.shape)\n        C2 = np.clip(C2, 0.0, 1.0)\n        R2 = lp_max_radii(C2, margin=1e-6)\n        if strictly_feasible(C2, R2):\n            s2 = R2.sum()\n            if s2 > best_sum:\n                best_sum = s2\n                best_C = C2.copy()\n                best_R = R2.copy()\n    return best_C, best_R, float(best_sum)",
  "metrics": {
    "valid": true,
    "score": 2.1000472245807233,
    "eval_time": 1.0722367763519287,
    "error": null
  },
  "prompt": "\n# Reference best trial: trial_7_7 score=2.6358676293444767\nDesign: Basin-hopping over centers with small random displacements; local solver L-BFGS-B on a smooth penalized objective with analytic gradients; recompute LP radii at each local step; retain best feasible.\n\n\nRequirements:\n- Provide a single Python code block, no prose.\n- Allowed modules: numpy, scipy.\n- Entry point: construct_packing() -> (centers, radii, sum_radii).\n- centers: np.ndarray shape (26,2), radii: np.ndarray shape (26,), sum_radii: float.\n- Strict feasibility: circles inside [0,1]^2, pairwise non-overlap with tolerance 1e-6.\n- Use an LP to finalize radii given centers to ensure strict feasibility:\n  Maximize sum r_i subject to:\n    r_i >= 0\n    r_i <= x_i, r_i <= y_i, r_i <= 1 - x_i, r_i <= 1 - y_i\n    r_i + r_j <= dist_ij - 1e-6 for all i<j, where dist_ij = ||c_i - c_j||_2\n- Return the LP-improved radii. If optimization fails, gracefully return a feasible solution.\n- No prints. Keep runtime under 300s.\n- Vectorized math. In penalties/gradients, apply epsilon only in denominators (not in penalties) to avoid bias.\n\n\nKey details:\n- Overlap penalty uses pairwise hinge on (r_i + r_j - d_ij); distances stabilized as sqrt(d^2 + eps^2) in denominator only.\n- r proxies updated from LP after each local polish.\n- Boundary penalty: hinge on distances to edges to keep centers away from immediate violation.\n- Limit hops to meet runtime.\n\nInclude:\n\ndef lp_max_radii(centers, r_cap=None, margin=1e-6):\n    import numpy as np\n    from scipy.optimize import linprog\n    n = centers.shape[0]\n    # Objective: maximize sum r -> minimize -sum r\n    c = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    # Boundary constraints\n    x = centers[:,0]; y = centers[:,1]\n    bounds_caps = np.stack([x, y, 1-x, 1-y], axis=1)  # shape (n,4)\n    for i in range(n):\n        for k in range(4):\n            row = np.zeros(n); row[i] = 1.0\n            A_ub.append(row); b_ub.append(bounds_caps[i,k])\n    # Pairwise constraints\n    for i in range(n):\n        ci = centers[i]\n        for j in range(i+1, n):\n            d = np.linalg.norm(ci - centers[j])\n            row = np.zeros(n); row[i] = 1.0; row[j] = 1.0\n            A_ub.append(row); b_ub.append(max(0.0, d - margin))\n    A_ub = np.array(A_ub); b_ub = np.array(b_ub)\n    # Bounds: 0 <= r_i <= r_cap_i (if provided), else None upper bound (linprog will be limited by A_ub)\n    if r_cap is not None:\n        bounds = [(0.0, max(0.0, float(r_cap[i]))) for i in range(n)]\n    else:\n        bounds = [(0.0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n    if res.success:\n        r = np.maximum(0.0, res.x)\n        return r\n    # Fallback: minimal feasible radii (zero)\n    return np.zeros(n)\n\n\ndef strictly_feasible(centers, radii, tol=1e-6):\n    import numpy as np\n    n = len(radii)\n    x = centers[:,0]; y = centers[:,1]\n    if np.any(radii < -1e-9): return False\n    if np.any(x - radii < -tol): return False\n    if np.any(y - radii < -tol): return False\n    if np.any(x + radii > 1 + tol): return False\n    if np.any(y + radii > 1 + tol): return False\n    for i in range(n):\n        for j in range(i+1, n):\n            if np.hypot(*(centers[i]-centers[j])) < radii[i] + radii[j] - tol:\n                return False\n    return True\n\n\ndef seed_centers(n=26, rng=None):\n    import numpy as np\n    if rng is None:\n        rng = np.random.default_rng(42)\n    # Mix hex-like grid and edge-biased jitter\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n/rows))\n    pts = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(pts) >= n: break\n            off = 0.5*(i % 2)\n            x = (j + off + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            pts.append([x, y])\n    C = np.array(pts[:n], dtype=float)\n    # Edge/corner bias\n    bias = rng.uniform(-0.03, 0.03, size=C.shape)\n    C = np.clip(C + bias, 0.05, 0.95)\n    return C\n\n\nProvide ONLY code with construct_packing().\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef lp_max_radii(centers, r_cap=None, margin=1e-6):\n    import numpy as np\n    from scipy.optimize import linprog\n    n = centers.shape[0]\n    c = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    x = centers[:,0]; y = centers[:,1]\n    bounds_caps = np.stack([x, y, 1-x, 1-y], axis=1)\n    for i in range(n):\n        for k in range(4):\n            row = np.zeros(n); row[i] = 1.0\n            A_ub.append(row); b_ub.append(bounds_caps[i,k])\n    for i in range(n):\n        ci = centers[i]\n        for j in range(i+1, n):\n            d = np.linalg.norm(ci - centers[j])\n            row = np.zeros(n); row[i] = 1.0; row[j] = 1.0\n            A_ub.append(row); b_ub.append(max(0.0, d - margin))\n    A_ub = np.array(A_ub); b_ub = np.array(b_ub)\n    if r_cap is not None:\n        bounds = [(0.0, max(0.0, float(r_cap[i]))) for i in range(n)]\n    else:\n        bounds = [(0.0, None)] * n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n    if res.success:\n        return np.maximum(0.0, res.x)\n    return np.zeros(n)\n\ndef strictly_feasible(centers, radii, tol=1e-6):\n    import numpy as np\n    n = len(radii)\n    x = centers[:,0]; y = centers[:,1]\n    if np.any(radii < -1e-9): return False\n    if np.any(x - radii < -tol): return False\n    if np.any(y - radii < -tol): return False\n    if np.any(x + radii > 1 + tol): return False\n    if np.any(y + radii > 1 + tol): return False\n    for i in range(n):\n        for j in range(i+1, n):\n            if np.hypot(*(centers[i]-centers[j])) < radii[i] + radii[j] - tol:\n                return False\n    return True\n\ndef seed_centers(n=26, rng=None):\n    import numpy as np\n    if rng is None:\n        rng = np.random.default_rng(42)\n    rows = int(np.ceil(np.sqrt(n)))\n    cols = int(np.ceil(n/rows))\n    pts = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(pts) >= n: break\n            off = 0.5*(i % 2)\n            x = (j + off + 0.5) / (cols + 0.5)\n            y = (i + 0.5) / (rows + 0.5)\n            pts.append([x, y])\n    C = np.array(pts[:n], dtype=float)\n    bias = rng.uniform(-0.03, 0.03, size=C.shape)\n    C = np.clip(C + bias, 0.05, 0.95)\n    return C\n\ndef construct_packing():\n    import numpy as np\n    rng = np.random.default_rng(12345)\n    n = 26\n    best_sum = 0.0\n    best_C = None\n    best_R = None\n    # global random search\n    for _ in range(50):\n        C = seed_centers(n, rng)\n        R = lp_max_radii(C, margin=1e-6)\n        if strictly_feasible(C, R):\n            s = R.sum()\n            if s > best_sum:\n                best_sum = s\n                best_C = C.copy()\n                best_R = R.copy()\n    # ensure some starting solution\n    if best_C is None:\n        best_C = seed_centers(n, rng)\n        best_R = lp_max_radii(best_C, margin=1e-6)\n        best_sum = best_R.sum()\n    # local refinement\n    for _ in range(200):\n        C2 = best_C + rng.normal(scale=0.01, size=best_C.shape)\n        C2 = np.clip(C2, 0.0, 1.0)\n        R2 = lp_max_radii(C2, margin=1e-6)\n        if strictly_feasible(C2, R2):\n            s2 = R2.sum()\n            if s2 > best_sum:\n                best_sum = s2\n                best_C = C2.copy()\n                best_R = R2.copy()\n    return best_C, best_R, float(best_sum)\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T02:16:33.025113",
  "cost_data": null,
  "model_config": {
    "model": "openai/o4-mini",
    "temperature": 0.15
  },
  "llm_call_duration_s": 28.83300181897357,
  "eval_duration_s": 1.0722424800042063
}