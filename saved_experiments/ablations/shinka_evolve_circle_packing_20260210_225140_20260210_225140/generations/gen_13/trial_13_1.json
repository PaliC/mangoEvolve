{
  "trial_id": "trial_13_1",
  "generation": 13,
  "parent_id": "trial_10_6",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 non-overlapping circles in [0,1]^2 to maximize sum of radii.\n    Returns centers (26x2 array), radii (26,), sum_radii.\n    \"\"\"\n    # Helper: pairwise distances\n    def _pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        d = np.sqrt(np.sum(diff**2, axis=2))\n        return d, diff[...,0], diff[...,1]\n\n    # LP-based radius maximizer for fixed centers\n    def _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n        N = centers.shape[0]\n        x, y = centers[:,0], centers[:,1]\n        A, b = [], []\n        # boundary: r_i <= x_i - eps, y_i - eps, 1-x_i - eps, 1-y_i - eps\n        for i in range(N):\n            e = np.zeros(N); e[i]=1\n            A += [ e.copy(), e.copy(), e.copy(), e.copy() ]\n            b += [ x[i]-eps_pair, y[i]-eps_pair, 1-x[i]-eps_pair, 1-y[i]-eps_pair ]\n        # pairwise: r_i + r_j <= d_ij - eps\n        d, _, _ = _pairwise_distances(centers)\n        for i in range(N):\n            for j in range(i+1,N):\n                e = np.zeros(N); e[i]=1; e[j]=1\n                A.append(e); b.append(d[i,j]-eps_pair)\n        # optional upper bounds\n        if r_max is not None:\n            for i in range(N):\n                e = np.zeros(N); e[i]=1\n                A.append(e); b.append(r_max[i])\n        res = linprog(-np.ones(N), A_ub=np.array(A), b_ub=np.array(b),\n                      bounds=(0.0,0.5), method='highs')\n        if res.success:\n            return np.clip(res.x,0,0.5)\n        # fallback: relax eps_pair\n        return np.zeros(N)\n\n    # verify strict feasibility\n    def _verify(centers, radii, tol=1e-6):\n        N = len(radii)\n        x,y = centers[:,0], centers[:,1]\n        if np.any(radii<0): return False\n        if np.any(x - radii < tol) or np.any(y - radii < tol): return False\n        if np.any(x + radii > 1-tol) or np.any(y + radii > 1-tol): return False\n        d,_,_ = _pairwise_distances(centers)\n        iu = np.triu_indices(N,1)\n        if np.any(radii[iu[0]]+radii[iu[1]] - d[iu] + tol > 0): return False\n        return True\n\n    # hex-grid initial centers\n    def _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n        assert sum(rows)==26\n        maxc, nr = max(rows), len(rows)\n        dx = (1-2*margin)/(maxc-1) if maxc>1 else 0\n        dy = (1-2*margin)/(nr-1) if nr>1 else 0\n        centers=[]; rng=np.random.default_rng(seed)\n        for ri,cols in enumerate(rows):\n            y0 = margin + ri*dy if nr>1 else 0.5\n            roww = (cols-1)*dx\n            startx = 0.5 - roww/2 + (dx/2 if ri%2 else 0)\n            for k in range(cols):\n                centers.append([startx+k*dx, y0])\n        c = np.array(centers) + rng.normal(scale=jitter_scale, size=(26,2))\n        return np.clip(c,1e-3,1-1e-3)\n\n    # many initial patterns\n    def _multi_start_inits():\n        patterns = [[6,5,6,5,4],[6,5,5,5,5],[5,6,5,5,5],[5,5,6,5,5],\n                    [6,6,5,5,4],[5,6,6,5,4]]\n        params = [(0.04,0.03),(0.05,0.03),(0.06,0.02),(0.05,0.04)]\n        inits=[]\n        for i,pat in enumerate(patterns):\n            for j,(m,jit) in enumerate(params):\n                inits.append(_hex_initial_centers_from_rows(pat, m, jit, seed=i*10+j))\n        return inits\n\n    N=26\n    # precompute constraint indices\n    iu0, iu1 = np.triu_indices(N,1)\n    M = 4*N + len(iu0)\n    nvar = 2*N + N  # x,y,r\n    eps = 1e-6\n\n    # objective: maximize sum(r) -> minimize f = -sum(r)\n    def obj_fun(z):\n        return -np.sum(z[2*N:])\n    def obj_jac(z):\n        return np.concatenate([np.zeros(2*N), -np.ones(N)])\n\n    # nonlinear constraints fun and jacobian\n    def cons_fun(z):\n        x = z[:N]; y = z[N:2*N]; r = z[2*N:]\n        vals = np.empty(M)\n        # boundary\n        idx = 0\n        for i in range(N):\n            vals[idx]   = x[i] - r[i] - eps;   idx+=1\n            vals[idx]   = y[i] - r[i] - eps;   idx+=1\n            vals[idx]   = (1-x[i]) - r[i] - eps; idx+=1\n            vals[idx]   = (1-y[i]) - r[i] - eps; idx+=1\n        # pairwise\n        # compute distances\n        d, dxm, dym = _pairwise_distances(np.column_stack([x,y]))\n        for k,(i,j) in enumerate(zip(iu0,iu1)):\n            vals[idx] = d[i,j] - r[i] - r[j] - eps\n            idx+=1\n        return vals\n\n    def cons_jac(z):\n        x = z[:N]; y = z[N:2*N]; r = z[2*N:]\n        J = np.zeros((M, nvar))\n        # boundary\n        idx = 0\n        for i in range(N):\n            # x_i - r_i - eps >=0\n            J[idx, i] = 1; J[idx, 2*N+i] = -1; idx+=1\n            # y_i - r_i\n            J[idx, N+i] = 1; J[idx, 2*N+i] = -1; idx+=1\n            # (1-x_i)-r_i\n            J[idx, i] = -1; J[idx, 2*N+i] = -1; idx+=1\n            # (1-y_i)-r_i\n            J[idx, N+i] = -1; J[idx, 2*N+i] = -1; idx+=1\n        # pairwise\n        centers = np.column_stack([x,y])\n        d, dxm, dym = _pairwise_distances(centers)\n        for k,(i,j) in enumerate(zip(iu0,iu1)):\n            dij = max(d[i,j], 1e-12)\n            # d_ij - r_i - r_j - eps\n            J[idx, i]     =  dxm[i,j]/dij\n            J[idx, j]     = -dxm[i,j]/dij\n            J[idx, N+i]   =  dym[i,j]/dij\n            J[idx, N+j]   = -dym[i,j]/dij\n            J[idx, 2*N+i] = -1\n            J[idx, 2*N+j] = -1\n            idx+=1\n        return J\n\n    # set up nonlinear constraint\n    nl_con = NonlinearConstraint(cons_fun, 0.0, np.inf, jac=cons_jac)\n\n    # bounds: x,y in [0,1], r in [0,0.5]\n    bounds = [(0.0,1.0)]*(2*N) + [(0.0,0.5)]*N\n\n    best = {'sum': -np.inf, 'centers': None, 'radii': None}\n\n    inits = _multi_start_inits()[:8]  # moderate multi-start\n    for centers0 in inits:\n        # initial radii small\n        x0, y0 = centers0[:,0], centers0[:,1]\n        base = np.minimum.reduce([x0, y0, 1-x0, 1-y0])\n        r0 = 0.05 * base\n        z0 = np.concatenate([x0, y0, r0])\n        try:\n            res = minimize(obj_fun, z0, method='trust-constr', jac=obj_jac,\n                           constraints=[nl_con], bounds=bounds,\n                           options={'verbose':0, 'maxiter':300, 'xtol':1e-9})\n            if not res.success:\n                continue\n            z = res.x\n            centers = np.column_stack([z[:N], z[N:2*N]])\n            # LP finalize radii\n            radii = _lp_feasibilize(centers, r_max=None, eps_pair=1e-6)\n            if not _verify(centers, radii, tol=1e-6):\n                continue\n            s = float(np.sum(radii))\n            if s > best['sum']:\n                best.update({'sum':s, 'centers':centers.copy(), 'radii':radii.copy()})\n        except Exception:\n            continue\n\n    # fallback if none worked\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        radii_fb  = _lp_feasibilize(centers_fb, eps_pair=1e-6)\n        return centers_fb, radii_fb, float(np.sum(radii_fb))\n\n    # final strict LP\n    radii_strict = _lp_feasibilize(best['centers'], eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol=1e-6):\n        radii = radii_strict\n    else:\n        radii = best['radii']\n    centers = best['centers']\n    sum_r = float(np.sum(radii))\n    return centers.astype(float), radii.astype(float), sum_r",
  "metrics": {
    "valid": true,
    "score": 2.614892312863695,
    "eval_time": 14.938035011291504,
    "error": null
  },
  "prompt": "\nYou are an expert numerical optimizer. Produce ONLY a single Python code block with the function:\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_radii) with:\n        - centers: np.array shape (26, 2)\n        - radii:   np.array shape (26,)\n        - sum_radii: float, strictly feasible sum of radii\n    \"\"\"\n    ...\n\nRules:\n- Exactly 26 circles\n- Circles inside [0,1]^2\n- No overlaps: r_i + r_j <= dist(c_i,c_j) - 1e-6 (strict feasibility)\n- All radii non-negative\n- Use numpy, scipy only\n- No printing, no plots, no I/O\n- Runtime <= 300s\n- Return strictly feasible packing\n- Use a final LP feasibilization step to maximize sum(r) given fixed centers:\n  Maximize sum(r_i) subject to:\n    r_i >= 0\n    r_i <= x_i, y_i, 1-x_i, 1-y_i\n    r_i + r_j <= ||c_i - c_j||_2 - 1e-6 for all i<j\n- Vectorized math; stabilize divisions using eps ONLY in denominators (do not bias penalties).\n- Prefer L-BFGS-B or trust-constr/SLSQP with analytic gradients/Jacobians where applicable.\n- Seed with deterministic edge/corner-biased and hex-like layouts plus small jitter.\n- Multi-start (moderate count) and finalize with LP ensures strict feasibility.\n\nTitle: trust-constr with explicit constraints/Jacobians + LP finalize\n\n# Reference for constraints (good Jacobians):\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.optimize import linprog\n\n# Helper functions provided in the problem description\ndef _pairwise_distances(centers):\n    \"\"\"\n    Calculates pairwise Euclidean distances between centers.\n    Returns distance matrix, and matrices of dx and dy.\n    \"\"\"\n    diff = centers[:, None, :] - centers[None, :, :]\n    d = np.sqrt(np.sum(diff**2, axis=2))\n    return d, diff[..., 0], diff[..., 1]\n\ndef _objective_and_grad(z, N, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective function and its gradient for joint optimization of centers (x,y) and radii (r).\n    z = [x_0..x_N-1, y_0..y_N-1, r_0..r_N-1]\n    Objective: -sum(r) + P * (w_b * boundary_penalty + w_o * overlap_penalty)\n    Penalties are squared hinge functions.\n    \"\"\"\n    x = z[:N]\n    y = z[N:2*N]\n    r = z[2*N:]\n    tiny = 1e-12 # Small value to prevent division by zero\n\n    # Boundary penalties: hinges for r - x, r - y, r + x - 1, r + y - 1\n    s1 = r - x\n    s2 = r - y\n    s3 = r + x - 1.0\n    s4 = r + y - 1.0\n\n    h1 = np.maximum(0.0, s1)\n    h2 = np.maximum(0.0, s2)\n    h3 = np.maximum(0.0, s3)\n    h4 = np.maximum(0.0, s4)\n\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap penalties: hinges for r_i + r_j - d_ij\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1) # Upper triangle indices for unique pairs (i, j where i < j)\n    dab = d[iu] # Distances for unique pairs\n    dxab = dx_mat[iu]\n    dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny) # Use tiny to prevent division by zero in gradients\n    hij = r[iu[0]] + r[iu[1]] - dab # Overlap amount for each pair\n    hpos = np.maximum(0.0, hij) # Positive part of overlap (hinge)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    # Total objective function value\n    f = -np.sum(r) + P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients for boundary penalties\n    dr_b = h1 + h2 + h3 + h4\n    dx_b = -h1 + h3\n    dy_b = -h2 + h4\n\n    # Overlap gradients (accumulate with np.add.at for efficiency)\n    dx_o = np.zeros(N, dtype=float)\n    dy_o = np.zeros(N, dtype=float)\n    dr_o = np.zeros(N, dtype=float)\n\n    # Gradient contribution for centers (x, y)\n    coeff = hpos / d_safe # h / d\n    cx = coeff * dxab\n    cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx) # For circle i\n    np.add.at(dx_o, iu[1], +cx) # For circle j\n    np.add.at(dy_o, iu[0], -cy)\n    np.add.at(dy_o, iu[1], +cy)\n    \n    # Gradient contribution for radii (r)\n    np.add.at(dr_o, iu[0], hpos)\n    np.add.at(dr_o, iu[1], hpos)\n\n    # Combine all gradients\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    dr_total = -1.0 + P * (w_b * dr_b + w_o * dr_o) # -1.0 from -sum(r)\n\n    grad = np.concatenate([dx_total, dy_total, dr_total])\n    return f, grad\n\ndef _objective_centers_only(z_xy, r_fixed, P, w_b=1.0, w_o=1.0):\n    \"\"\"\n    Objective function and its gradient for optimizing centers (x,y) only, with fixed radii.\n    \"\"\"\n    N = r_fixed.shape[0]\n    x = z_xy[:N]\n    y = z_xy[N:2*N]\n    r = r_fixed\n    tiny = 1e-12\n\n    # Boundary hinges\n    s1 = r - x; s2 = r - y; s3 = r + x - 1.0; s4 = r + y - 1.0\n    h1 = np.maximum(0.0, s1); h2 = np.maximum(0.0, s2); h3 = np.maximum(0.0, s3); h4 = np.maximum(0.0, s4)\n    pen_b = 0.5 * np.sum(h1*h1 + h2*h2 + h3*h3 + h4*h4)\n\n    # Overlap hinges\n    centers = np.stack([x, y], axis=1)\n    d, dx_mat, dy_mat = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    dab = d[iu]; dxab = dx_mat[iu]; dyab = dy_mat[iu]\n    d_safe = np.maximum(dab, tiny)\n    hij = r[iu[0]] + r[iu[1]] - dab\n    hpos = np.maximum(0.0, hij)\n    pen_o = 0.5 * np.sum(hpos*hpos)\n\n    f = P * (w_b * pen_b + w_o * pen_o)\n\n    # Gradients wrt x,y only\n    dx_b = -h1 + h3; dy_b = -h2 + h4\n    dx_o = np.zeros(N, dtype=float); dy_o = np.zeros(N, dtype=float)\n    coeff = hpos / d_safe\n    cx = coeff * dxab; cy = coeff * dyab\n    np.add.at(dx_o, iu[0], -cx); np.add.at(dx_o, iu[1], +cx)\n    np.add.at(dy_o, iu[0], -cy); np.add.at(dy_o, iu[1], +cy)\n\n    dx_total = P * (w_b * dx_b + w_o * dx_o)\n    dy_total = P * (w_b * dy_b + w_o * dy_o)\n    g = np.concatenate([dx_total, dy_total])\n    return f, g\n\ndef _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n    \"\"\"\n    Maximizes sum(r) for given centers using linear programming, ensuring feasibility.\n    \"\"\"\n    N = centers.shape[0]\n    x, y = centers[:, 0], centers[:, 1]\n    A_rows, b_vals = [], []\n\n    # Boundary constraints: r_i <= c_k - eps_pair\n    for i in range(N):\n        e = np.zeros(N); e[i] = 1.0\n        A_rows.extend([e.copy(), e.copy(), e.copy(), e.copy()])\n        b_vals.extend([x[i] - eps_pair, y[i] - eps_pair, 1.0 - x[i] - eps_pair, 1.0 - y[i] - eps_pair])\n\n    # Pairwise overlap constraints: r_i + r_j <= dist(c_i,c_j) - eps_pair\n    d, _, _ = _pairwise_distances(centers)\n    for i in range(N):\n        for j in range(i+1, N):\n            e = np.zeros(N); e[i] = 1.0; e[j] = 1.0\n            A_rows.append(e); b_vals.append(d[i, j] - eps_pair)\n\n    if r_max is not None:\n        for i in range(N):\n            e = np.zeros(N); e[i] = 1.0\n            A_rows.append(e); b_vals.append(r_max[i])\n\n    res = linprog(-np.ones(N), A_ub=np.array(A_rows), b_ub=np.array(b_vals), bounds=(0.0, 0.5), method='highs')\n    if res.success: return np.clip(res.x, 0.0, 0.5)\n\n    # Fallback: If LP with eps_pair is infeasible, try with eps_pair = 0 and scale down.\n    res2 = linprog(-np.ones(N), A_ub=np.array(A_rows), b_ub=np.array(b_vals) + eps_pair, bounds=(0.0, 0.5), method='highs')\n    if not res2.success: return np.zeros(N)\n    \n    r_base = np.clip(res2.x, 0.0, 0.5)\n    \n    with np.errstate(divide='ignore', invalid='ignore'):\n        denom_pairs = r_base[:, None] + r_base[None, :]\n        ratio_pairs = np.where(denom_pairs > 1e-9, (d - eps_pair) / denom_pairs, np.inf)\n        iu = np.triu_indices(N, 1)\n        s_pairs = np.min(ratio_pairs[iu]) if ratio_pairs[iu].size > 0 else 1.0\n        \n        s_b_x_min = np.where(r_base > 1e-9, (x - eps_pair) / r_base, np.inf)\n        s_b_y_min = np.where(r_base > 1e-9, (y - eps_pair) / r_base, np.inf)\n        s_b_x_max = np.where(r_base > 1e-9, (1.0 - x - eps_pair) / r_base, np.inf)\n        s_b_y_max = np.where(r_base > 1e-9, (1.0 - y - eps_pair) / r_base, np.inf)\n        s_boundary = np.min([s_b_x_min, s_b_y_min, s_b_x_max, s_b_y_max])\n\n    s = min(s_pairs if np.isfinite(s_pairs) else 1.0, s_boundary if np.isfinite(s_boundary) else 1.0)\n    return np.clip(max(0.0, min(1.0, s)) * r_base, 0.0, 0.5)\n\ndef _verify(centers, radii, tol_pair=1e-6):\n    \"\"\"\n    Verifies if a given packing is strictly feasible.\n    \"\"\"\n    N = len(radii)\n    x, y = centers[:, 0], centers[:, 1]\n    if centers.shape != (N, 2) or np.any(radii < -1e-12): return False\n    if np.any(x - radii < tol_pair) or np.any(y - radii < tol_pair): return False\n    if np.any(x + radii > 1.0 - tol_pair) or np.any(y + radii > 1.0 - tol_pair): return False\n    d, _, _ = _pairwise_distances(centers)\n    iu = np.triu_indices(N, 1)\n    if np.any((radii[iu[0]] + radii[iu[1]]) - d[iu] + tol_pair > 1e-12): return False\n    return True\n\n# Custom helper functions for this solution\ndef _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n    \"\"\"Generates initial centers in a hexagonal-like grid pattern.\"\"\"\n    assert sum(rows) == 26\n    max_cols, nrows = max(rows), len(rows)\n    dx = (1.0 - 2*margin) / (max_cols - 1) if max_cols > 1 else 0.0\n    dy = (1.0 - 2*margin) / (nrows - 1) if nrows > 1 else 0.0\n    centers = []\n    rng = np.random.default_rng(seed)\n    for ri, cols in enumerate(rows):\n        y = margin + ri * dy if nrows > 1 else 0.5\n        row_width = (cols - 1) * dx\n        startx = 0.5 - row_width / 2.0 + (dx / 2.0 if ri % 2 == 1 else 0.0)\n        for k in range(cols):\n            centers.append([startx + k * dx, y])\n    centers = np.array(centers) + rng.normal(scale=jitter_scale, size=(sum(rows), 2))\n    return np.clip(centers, 1e-3, 1 - 1e-3)\n\ndef _multi_start_inits(N):\n    \"\"\"Generates a list of diverse initial center configurations.\"\"\"\n    patterns = [[6,5,6,5,4], [6,5,5,5,5], [5,6,5,5,5], [5,5,6,5,5], [6,6,5,5,4], [5,6,6,5,4]]\n    params = [(0.04, 0.03), (0.05, 0.03), (0.06, 0.02), (0.05, 0.04)]\n    inits = []\n    for i, pat in enumerate(patterns):\n        for j, (m, jit) in enumerate(params):\n            inits.append(_hex_initial_centers_from_rows(pat, margin=m, jitter_scale=jit, seed=i*10+j))\n    return inits\n\ndef _center_only_relax(centers, r_fixed, P=2000.0, w_b=1.0, w_o=1.0, iters=80):\n    \"\"\"Performs a short optimization run on centers only, with fixed radii.\"\"\"\n    N = centers.shape[0]\n    res = minimize(fun=lambda z: _objective_centers_only(z, r_fixed, P, w_b, w_o),\n                   x0=np.concatenate([centers[:, 0], centers[:, 1]]),\n                   method='L-BFGS-B', jac=True, bounds=[(0.0, 1.0)] * (2*N),\n                   options={'maxiter': iters, 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 20})\n    return np.stack([res.x[:N], res.x[N:2*N]], axis=1)\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square.\n    \"\"\"\n    N = 26\n    best = {'centers': None, 'radii': None, 'sum': -np.inf}\n\n    P_schedule = [8.0, 80.0, 800.0, 3000.0, 10000.0, 20000.0]\n    maxiter_stage = [90, 100, 110, 120, 130, 140]\n    bounds = [(0.0, 1.0)] * (2*N) + [(0.0, 0.5)] * N\n\n    inits = _multi_start_inits(N)\n\n    for centers0 in inits:\n        x0, y0 = centers0[:, 0], centers0[:, 1]\n        base_bound = np.minimum.reduce([x0, y0, 1 - x0, 1 - y0])\n        r0 = 0.05 * base_bound\n        z = np.concatenate([x0, y0, r0])\n\n        for si, P in enumerate(P_schedule):\n            res = minimize(fun=lambda zz: _objective_and_grad(zz, N, P), x0=z, method='L-BFGS-B', jac=True,\n                           bounds=bounds, options={'maxiter': maxiter_stage[si], 'ftol': 1e-12, 'gtol': 1e-8, 'maxcor': 30})\n            z = res.x\n            centers_tmp = np.stack([z[:N], z[N:2*N]], axis=1)\n            r_cur = np.clip(z[2*N:], 0.0, 0.5)\n            \n            cap_factor = 1.08 if si < len(P_schedule) - 1 else 1.15\n            r_cap = np.minimum(0.5, cap_factor * np.maximum(1e-9, r_cur))\n            r_lp = _lp_feasibilize(centers_tmp, r_max=r_cap, eps_pair=1e-6)\n            \n            centers_relaxed = _center_only_relax(centers_tmp, r_lp, P=max(1000.0, P), iters=70)\n            \n            r_lp2 = _lp_feasibilize(centers_relaxed, r_max=None, eps_pair=1e-6)\n            \n            z = np.concatenate([centers_relaxed[:, 0], centers_relaxed[:, 1], np.clip(r_lp2, 0.0, 0.5)])\n\n        centers_final = np.stack([z[:N], z[N:2*N]], axis=1)\n        r_final = _lp_feasibilize(centers_final, r_max=None, eps_pair=1e-6)\n\n        if _verify(centers_final, r_final, tol_pair=1e-6):\n            s = float(np.sum(r_final))\n            if s > best['sum']:\n                best.update({'centers': centers_final.copy(), 'radii': r_final.copy(), 'sum': s})\n\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        radii_fb = _lp_feasibilize(centers_fb, eps_pair=1e-6)\n        return centers_fb, np.clip(radii_fb, 0.0, 0.5), float(np.sum(radii_fb))\n\n    # Final hardening to guarantee strict feasibility\n    radii_strict = _lp_feasibilize(best['centers'], eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol_pair=1e-6):\n        radii = radii_strict\n    else:\n        radii = best['radii']\n\n    centers = best['centers']\n    radii = np.clip(radii, 0.0, 0.5)\n    sum_radii = float(np.sum(radii))\n    \n    return centers.astype(float), radii.astype(float), sum_radii\n\n# Implement as follows:\n\nImplementation guidance:\n- Penalized objective for centers (and optionally radii) with:\n  * Overlap penalty: sum(max(0, r_i+r_j - d_ij)^2), where d_ij = ||c_i-c_j||, eps only in denom.\n  * Boundary penalty: sum(max(0, r_i - b_i)^2) where b_i = min(x_i, y_i, 1-x_i, 1-y_i).\n- Prefer center-only optimization; always finalize radii via LP.\n- Adaptive/density weights: weight pairs by local density (e.g., based on k-NN distances).\n- Anneal penalties over stages; warm-start best centers between stages.\n- Use neighbor masks to reduce O(n^2) cost where safe (still maintain correctness).\n- Ensure strict feasibility via LP with -1e-6 margins on pair constraints.\n\n\n- Variables: x in R^{26*2} for centers; radii handled by LP, so primary optimization is on centers.\n- Still, formulate nonlinear constraints on centers via surrogate slack: ensure a high-penalty barrier for overlaps/boundaries within trust-constr.\n- Provide analytic Jacobians for pairwise distances and boundaries.\n- Multi-start 10 seeds; pick best by LP sum.\n- Final LP ensures strict feasibility and maximizes sum of radii.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Packs 26 non-overlapping circles in [0,1]^2 to maximize sum of radii.\n    Returns centers (26x2 array), radii (26,), sum_radii.\n    \"\"\"\n    # Helper: pairwise distances\n    def _pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        d = np.sqrt(np.sum(diff**2, axis=2))\n        return d, diff[...,0], diff[...,1]\n\n    # LP-based radius maximizer for fixed centers\n    def _lp_feasibilize(centers, r_max=None, eps_pair=1e-6):\n        N = centers.shape[0]\n        x, y = centers[:,0], centers[:,1]\n        A, b = [], []\n        # boundary: r_i <= x_i - eps, y_i - eps, 1-x_i - eps, 1-y_i - eps\n        for i in range(N):\n            e = np.zeros(N); e[i]=1\n            A += [ e.copy(), e.copy(), e.copy(), e.copy() ]\n            b += [ x[i]-eps_pair, y[i]-eps_pair, 1-x[i]-eps_pair, 1-y[i]-eps_pair ]\n        # pairwise: r_i + r_j <= d_ij - eps\n        d, _, _ = _pairwise_distances(centers)\n        for i in range(N):\n            for j in range(i+1,N):\n                e = np.zeros(N); e[i]=1; e[j]=1\n                A.append(e); b.append(d[i,j]-eps_pair)\n        # optional upper bounds\n        if r_max is not None:\n            for i in range(N):\n                e = np.zeros(N); e[i]=1\n                A.append(e); b.append(r_max[i])\n        res = linprog(-np.ones(N), A_ub=np.array(A), b_ub=np.array(b),\n                      bounds=(0.0,0.5), method='highs')\n        if res.success:\n            return np.clip(res.x,0,0.5)\n        # fallback: relax eps_pair\n        return np.zeros(N)\n\n    # verify strict feasibility\n    def _verify(centers, radii, tol=1e-6):\n        N = len(radii)\n        x,y = centers[:,0], centers[:,1]\n        if np.any(radii<0): return False\n        if np.any(x - radii < tol) or np.any(y - radii < tol): return False\n        if np.any(x + radii > 1-tol) or np.any(y + radii > 1-tol): return False\n        d,_,_ = _pairwise_distances(centers)\n        iu = np.triu_indices(N,1)\n        if np.any(radii[iu[0]]+radii[iu[1]] - d[iu] + tol > 0): return False\n        return True\n\n    # hex-grid initial centers\n    def _hex_initial_centers_from_rows(rows, margin=0.05, jitter_scale=0.03, seed=0):\n        assert sum(rows)==26\n        maxc, nr = max(rows), len(rows)\n        dx = (1-2*margin)/(maxc-1) if maxc>1 else 0\n        dy = (1-2*margin)/(nr-1) if nr>1 else 0\n        centers=[]; rng=np.random.default_rng(seed)\n        for ri,cols in enumerate(rows):\n            y0 = margin + ri*dy if nr>1 else 0.5\n            roww = (cols-1)*dx\n            startx = 0.5 - roww/2 + (dx/2 if ri%2 else 0)\n            for k in range(cols):\n                centers.append([startx+k*dx, y0])\n        c = np.array(centers) + rng.normal(scale=jitter_scale, size=(26,2))\n        return np.clip(c,1e-3,1-1e-3)\n\n    # many initial patterns\n    def _multi_start_inits():\n        patterns = [[6,5,6,5,4],[6,5,5,5,5],[5,6,5,5,5],[5,5,6,5,5],\n                    [6,6,5,5,4],[5,6,6,5,4]]\n        params = [(0.04,0.03),(0.05,0.03),(0.06,0.02),(0.05,0.04)]\n        inits=[]\n        for i,pat in enumerate(patterns):\n            for j,(m,jit) in enumerate(params):\n                inits.append(_hex_initial_centers_from_rows(pat, m, jit, seed=i*10+j))\n        return inits\n\n    N=26\n    # precompute constraint indices\n    iu0, iu1 = np.triu_indices(N,1)\n    M = 4*N + len(iu0)\n    nvar = 2*N + N  # x,y,r\n    eps = 1e-6\n\n    # objective: maximize sum(r) -> minimize f = -sum(r)\n    def obj_fun(z):\n        return -np.sum(z[2*N:])\n    def obj_jac(z):\n        return np.concatenate([np.zeros(2*N), -np.ones(N)])\n\n    # nonlinear constraints fun and jacobian\n    def cons_fun(z):\n        x = z[:N]; y = z[N:2*N]; r = z[2*N:]\n        vals = np.empty(M)\n        # boundary\n        idx = 0\n        for i in range(N):\n            vals[idx]   = x[i] - r[i] - eps;   idx+=1\n            vals[idx]   = y[i] - r[i] - eps;   idx+=1\n            vals[idx]   = (1-x[i]) - r[i] - eps; idx+=1\n            vals[idx]   = (1-y[i]) - r[i] - eps; idx+=1\n        # pairwise\n        # compute distances\n        d, dxm, dym = _pairwise_distances(np.column_stack([x,y]))\n        for k,(i,j) in enumerate(zip(iu0,iu1)):\n            vals[idx] = d[i,j] - r[i] - r[j] - eps\n            idx+=1\n        return vals\n\n    def cons_jac(z):\n        x = z[:N]; y = z[N:2*N]; r = z[2*N:]\n        J = np.zeros((M, nvar))\n        # boundary\n        idx = 0\n        for i in range(N):\n            # x_i - r_i - eps >=0\n            J[idx, i] = 1; J[idx, 2*N+i] = -1; idx+=1\n            # y_i - r_i\n            J[idx, N+i] = 1; J[idx, 2*N+i] = -1; idx+=1\n            # (1-x_i)-r_i\n            J[idx, i] = -1; J[idx, 2*N+i] = -1; idx+=1\n            # (1-y_i)-r_i\n            J[idx, N+i] = -1; J[idx, 2*N+i] = -1; idx+=1\n        # pairwise\n        centers = np.column_stack([x,y])\n        d, dxm, dym = _pairwise_distances(centers)\n        for k,(i,j) in enumerate(zip(iu0,iu1)):\n            dij = max(d[i,j], 1e-12)\n            # d_ij - r_i - r_j - eps\n            J[idx, i]     =  dxm[i,j]/dij\n            J[idx, j]     = -dxm[i,j]/dij\n            J[idx, N+i]   =  dym[i,j]/dij\n            J[idx, N+j]   = -dym[i,j]/dij\n            J[idx, 2*N+i] = -1\n            J[idx, 2*N+j] = -1\n            idx+=1\n        return J\n\n    # set up nonlinear constraint\n    nl_con = NonlinearConstraint(cons_fun, 0.0, np.inf, jac=cons_jac)\n\n    # bounds: x,y in [0,1], r in [0,0.5]\n    bounds = [(0.0,1.0)]*(2*N) + [(0.0,0.5)]*N\n\n    best = {'sum': -np.inf, 'centers': None, 'radii': None}\n\n    inits = _multi_start_inits()[:8]  # moderate multi-start\n    for centers0 in inits:\n        # initial radii small\n        x0, y0 = centers0[:,0], centers0[:,1]\n        base = np.minimum.reduce([x0, y0, 1-x0, 1-y0])\n        r0 = 0.05 * base\n        z0 = np.concatenate([x0, y0, r0])\n        try:\n            res = minimize(obj_fun, z0, method='trust-constr', jac=obj_jac,\n                           constraints=[nl_con], bounds=bounds,\n                           options={'verbose':0, 'maxiter':300, 'xtol':1e-9})\n            if not res.success:\n                continue\n            z = res.x\n            centers = np.column_stack([z[:N], z[N:2*N]])\n            # LP finalize radii\n            radii = _lp_feasibilize(centers, r_max=None, eps_pair=1e-6)\n            if not _verify(centers, radii, tol=1e-6):\n                continue\n            s = float(np.sum(radii))\n            if s > best['sum']:\n                best.update({'sum':s, 'centers':centers.copy(), 'radii':radii.copy()})\n        except Exception:\n            continue\n\n    # fallback if none worked\n    if best['centers'] is None:\n        centers_fb = _hex_initial_centers_from_rows([6,5,6,5,4], margin=0.06, jitter_scale=0.02, seed=123)\n        radii_fb  = _lp_feasibilize(centers_fb, eps_pair=1e-6)\n        return centers_fb, radii_fb, float(np.sum(radii_fb))\n\n    # final strict LP\n    radii_strict = _lp_feasibilize(best['centers'], eps_pair=1.1e-6)\n    if _verify(best['centers'], radii_strict, tol=1e-6):\n        radii = radii_strict\n    else:\n        radii = best['radii']\n    centers = best['centers']\n    sum_r = float(np.sum(radii))\n    return centers.astype(float), radii.astype(float), sum_r\n```\n",
  "reasoning": "",
  "timestamp": "2026-02-11T02:54:37.487683",
  "cost_data": null,
  "model_config": {
    "model": "openai/o4-mini",
    "temperature": 0.3
  },
  "llm_call_duration_s": 39.97503118007444,
  "eval_duration_s": 14.93804119003471
}