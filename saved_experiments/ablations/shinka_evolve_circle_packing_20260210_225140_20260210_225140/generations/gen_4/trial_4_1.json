{
  "trial_id": "trial_4_1",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef construct_packing():\n    N = 26\n    eps = 1e-6\n    eps2 = 1e-6\n    kb = 0.1\n    alpha = 0.01\n    max_iters = 500\n    checkpoint = 100\n    lr0 = 0.2\n    beta1, beta2 = 0.9, 0.999\n\n    def solve_radii(C):\n        # maximize sum r_i s.t. r_i <= x_i, y_i, 1-x_i, 1-y_i and r_i+r_j <= dist(C_i,C_j)\n        c = -np.ones(N)\n        A = []\n        b = []\n        # boundary\n        for i in range(N):\n            xi, yi = C[i]\n            row = np.zeros(N)\n            row[i] = 1\n            A.append(row.copy()); b.append(xi)\n            A.append(row.copy()); b.append(yi)\n            A.append(row.copy()); b.append(1 - xi)\n            A.append(row.copy()); b.append(1 - yi)\n        # pairwise\n        diffs = C[:, None, :] - C[None, :, :]\n        dists = np.linalg.norm(diffs, axis=2)\n        for i in range(N):\n            for j in range(i+1, N):\n                row = np.zeros(N)\n                row[i] = 1; row[j] = 1\n                A.append(row); b.append(dists[i, j])\n        A_ub = np.vstack(A)\n        b_ub = np.array(b)\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub,\n                      bounds=[(0, None)]*N,\n                      method='highs')\n        if res.success:\n            r = res.x\n            return r, r.sum()\n        else:\n            return np.zeros(N), 0.0\n\n    def energy_and_grad(C_flat):\n        C_mat = C_flat.reshape(N, 2)\n        # boundary energy\n        Eb = -kb * (np.sum(np.log(C_mat + eps)) + np.sum(np.log(1 - C_mat + eps)))\n        # repulsion energy\n        diffs = C_mat[:, None, :] - C_mat[None, :, :]\n        d = np.linalg.norm(diffs, axis=2) + eps2\n        iu = np.triu_indices(N, k=1)\n        Erep = -alpha * np.sum(np.log(d[iu] + eps2))\n        E = Eb + Erep\n        # gradients\n        gx = -kb / (C_mat[:,0] + eps) + kb / (1 - C_mat[:,0] + eps)\n        gy = -kb / (C_mat[:,1] + eps) + kb / (1 - C_mat[:,1] + eps)\n        grad = np.stack([gx, gy], axis=1)\n        inv_d2 = 1.0 / (d * d)\n        rep = -alpha * (diffs * inv_d2[:,:,None]).sum(axis=1)\n        grad += rep\n        return E, grad.ravel()\n\n    def optimize_seed(C0):\n        best_C = C0.copy()\n        best_r, best_s = solve_radii(best_C)\n        C = C0.copy()\n        m = np.zeros_like(C)\n        v = np.zeros_like(C)\n        for t in range(1, max_iters + 1):\n            # compute gradients\n            gx = -kb / (C[:,0] + eps) + kb / (1 - C[:,0] + eps)\n            gy = -kb / (C[:,1] + eps) + kb / (1 - C[:,1] + eps)\n            grad = np.stack([gx, gy], axis=1)\n            diffs = C[:, None, :] - C[None, :, :]\n            d = np.linalg.norm(diffs, axis=2) + eps2\n            inv_d2 = 1.0 / (d * d)\n            rep = -alpha * (diffs * inv_d2[:,:,None]).sum(axis=1)\n            grad += rep\n            # Adam update\n            m = beta1 * m + (1 - beta1) * grad\n            v = beta2 * v + (1 - beta2) * (grad * grad)\n            m_hat = m / (1 - beta1**t)\n            v_hat = v / (1 - beta2**t)\n            lr = lr0 * (1 - t / max_iters)\n            C -= lr * m_hat / (np.sqrt(v_hat) + eps)\n            np.clip(C, 0, 1, out=C)\n            if t % checkpoint == 0:\n                r, s = solve_radii(C)\n                if s > best_s + 1e-12:\n                    best_s = s\n                    best_r = r.copy()\n                    best_C = C.copy()\n        # L-BFGS-B polish\n        res = minimize(energy_and_grad, best_C.ravel(),\n                       method='L-BFGS-B',\n                       jac=True,\n                       bounds=[(0,1)]*(2*N),\n                       options={'maxiter':200})\n        Cp = res.x.reshape(N,2)\n        r, s = solve_radii(Cp)\n        if s > best_s:\n            best_s = s; best_r = r; best_C = Cp\n        return best_C, best_r, best_s\n\n    # seeds\n    seeds = []\n    # 1: hex grid\n    rows = [6,5,5,5,5]\n    ys = np.linspace(0.1, 0.9, len(rows))\n    pts = []\n    for ry, cnt in zip(ys, rows):\n        xs = np.linspace(0.1, 0.9, cnt)\n        for x in xs:\n            pts.append([x, ry])\n    seeds.append(np.array(pts)[:N])\n    # 2: shifted hex\n    pts = []\n    for i, (ry, cnt) in enumerate(zip(ys, rows)):\n        xs = np.linspace(0.1, 0.9, cnt)\n        if i % 2 == 1:\n            xs = 0.1 + (xs - 0.1 + (0.9-0.1)/(2*cnt))%(0.9-0.1)\n        for x in xs:\n            pts.append([x, ry])\n    seeds.append(np.array(pts)[:N])\n    # 3: edge heavy\n    pts = []\n    ys = np.linspace(0.2, 0.8, 6)\n    for y in ys:\n        pts.append([0.1, y])\n        pts.append([0.9, y])\n    xs = np.linspace(0.2, 0.8, 6)\n    for x in xs:\n        pts.append([x, 0.1])\n        pts.append([x, 0.9])\n    pts.append([0.5,0.5])\n    pts.append([0.3,0.7])\n    seeds.append(np.array(pts)[:N])\n    # 4: random uniform\n    seeds.append(np.random.rand(N,2))\n\n    # run all seeds\n    best_overall = (None, None, 0.0)\n    for C0 in seeds:\n        C, r, s = optimize_seed(C0)\n        if s > best_overall[2]:\n            best_overall = (C.copy(), r.copy(), s)\n    centers, radii, sum_radii = best_overall\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": true,
    "score": 2.4799999999999995,
    "eval_time": 0.5257461071014404,
    "error": null
  },
  "prompt": "\nSingle Python code block only. Implement construct_packing() to return a strictly feasible packing of 26 circles in [0,1]^2 maximizing sum of radii.\nMethod:\n- Maintain centers; compute radii via LP feasibilization (maximize sum r with boundary and pairwise constraints).\n- Optimize centers with a smooth force-directed energy:\n  E(C) = sum_i phi_b(x_i) + phi_b(y_i) + phi_b(1-x_i) + phi_b(1-y_i) + alpha * sum_{i<j} psi(||C_i - C_j||)\n  where phi_b(t) = -k_b * log(t + eps) encourages room near boundaries (discourages getting too close too fast), and psi(d) = -log(d + eps) is repulsive.\n- Use gradient descent with Adam-like momentum for a few hundred steps, decreasing step size; then a short L-BFGS-B polish on the same energy with bounds [0,1].\n- At checkpoints and end, run LP to extract radii; track best feasible.\n- Use 4 seeds: (i) hex grid, (ii) hex shifted, (iii) edge-heavy init (more points near edges), (iv) random quasi-uniform via Poisson disk approximation.\n\nDetails:\n- Vectorized gradients; only add eps in denominators (no bias).\n- After each optimization trajectory, run LP; pick best.\n- Return centers (26,2), radii (26,), sum_radii float.\nNo prints. Use only numpy and scipy.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef construct_packing():\n    N = 26\n    eps = 1e-6\n    eps2 = 1e-6\n    kb = 0.1\n    alpha = 0.01\n    max_iters = 500\n    checkpoint = 100\n    lr0 = 0.2\n    beta1, beta2 = 0.9, 0.999\n\n    def solve_radii(C):\n        # maximize sum r_i s.t. r_i <= x_i, y_i, 1-x_i, 1-y_i and r_i+r_j <= dist(C_i,C_j)\n        c = -np.ones(N)\n        A = []\n        b = []\n        # boundary\n        for i in range(N):\n            xi, yi = C[i]\n            row = np.zeros(N)\n            row[i] = 1\n            A.append(row.copy()); b.append(xi)\n            A.append(row.copy()); b.append(yi)\n            A.append(row.copy()); b.append(1 - xi)\n            A.append(row.copy()); b.append(1 - yi)\n        # pairwise\n        diffs = C[:, None, :] - C[None, :, :]\n        dists = np.linalg.norm(diffs, axis=2)\n        for i in range(N):\n            for j in range(i+1, N):\n                row = np.zeros(N)\n                row[i] = 1; row[j] = 1\n                A.append(row); b.append(dists[i, j])\n        A_ub = np.vstack(A)\n        b_ub = np.array(b)\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub,\n                      bounds=[(0, None)]*N,\n                      method='highs')\n        if res.success:\n            r = res.x\n            return r, r.sum()\n        else:\n            return np.zeros(N), 0.0\n\n    def energy_and_grad(C_flat):\n        C_mat = C_flat.reshape(N, 2)\n        # boundary energy\n        Eb = -kb * (np.sum(np.log(C_mat + eps)) + np.sum(np.log(1 - C_mat + eps)))\n        # repulsion energy\n        diffs = C_mat[:, None, :] - C_mat[None, :, :]\n        d = np.linalg.norm(diffs, axis=2) + eps2\n        iu = np.triu_indices(N, k=1)\n        Erep = -alpha * np.sum(np.log(d[iu] + eps2))\n        E = Eb + Erep\n        # gradients\n        gx = -kb / (C_mat[:,0] + eps) + kb / (1 - C_mat[:,0] + eps)\n        gy = -kb / (C_mat[:,1] + eps) + kb / (1 - C_mat[:,1] + eps)\n        grad = np.stack([gx, gy], axis=1)\n        inv_d2 = 1.0 / (d * d)\n        rep = -alpha * (diffs * inv_d2[:,:,None]).sum(axis=1)\n        grad += rep\n        return E, grad.ravel()\n\n    def optimize_seed(C0):\n        best_C = C0.copy()\n        best_r, best_s = solve_radii(best_C)\n        C = C0.copy()\n        m = np.zeros_like(C)\n        v = np.zeros_like(C)\n        for t in range(1, max_iters + 1):\n            # compute gradients\n            gx = -kb / (C[:,0] + eps) + kb / (1 - C[:,0] + eps)\n            gy = -kb / (C[:,1] + eps) + kb / (1 - C[:,1] + eps)\n            grad = np.stack([gx, gy], axis=1)\n            diffs = C[:, None, :] - C[None, :, :]\n            d = np.linalg.norm(diffs, axis=2) + eps2\n            inv_d2 = 1.0 / (d * d)\n            rep = -alpha * (diffs * inv_d2[:,:,None]).sum(axis=1)\n            grad += rep\n            # Adam update\n            m = beta1 * m + (1 - beta1) * grad\n            v = beta2 * v + (1 - beta2) * (grad * grad)\n            m_hat = m / (1 - beta1**t)\n            v_hat = v / (1 - beta2**t)\n            lr = lr0 * (1 - t / max_iters)\n            C -= lr * m_hat / (np.sqrt(v_hat) + eps)\n            np.clip(C, 0, 1, out=C)\n            if t % checkpoint == 0:\n                r, s = solve_radii(C)\n                if s > best_s + 1e-12:\n                    best_s = s\n                    best_r = r.copy()\n                    best_C = C.copy()\n        # L-BFGS-B polish\n        res = minimize(energy_and_grad, best_C.ravel(),\n                       method='L-BFGS-B',\n                       jac=True,\n                       bounds=[(0,1)]*(2*N),\n                       options={'maxiter':200})\n        Cp = res.x.reshape(N,2)\n        r, s = solve_radii(Cp)\n        if s > best_s:\n            best_s = s; best_r = r; best_C = Cp\n        return best_C, best_r, best_s\n\n    # seeds\n    seeds = []\n    # 1: hex grid\n    rows = [6,5,5,5,5]\n    ys = np.linspace(0.1, 0.9, len(rows))\n    pts = []\n    for ry, cnt in zip(ys, rows):\n        xs = np.linspace(0.1, 0.9, cnt)\n        for x in xs:\n            pts.append([x, ry])\n    seeds.append(np.array(pts)[:N])\n    # 2: shifted hex\n    pts = []\n    for i, (ry, cnt) in enumerate(zip(ys, rows)):\n        xs = np.linspace(0.1, 0.9, cnt)\n        if i % 2 == 1:\n            xs = 0.1 + (xs - 0.1 + (0.9-0.1)/(2*cnt))%(0.9-0.1)\n        for x in xs:\n            pts.append([x, ry])\n    seeds.append(np.array(pts)[:N])\n    # 3: edge heavy\n    pts = []\n    ys = np.linspace(0.2, 0.8, 6)\n    for y in ys:\n        pts.append([0.1, y])\n        pts.append([0.9, y])\n    xs = np.linspace(0.2, 0.8, 6)\n    for x in xs:\n        pts.append([x, 0.1])\n        pts.append([x, 0.9])\n    pts.append([0.5,0.5])\n    pts.append([0.3,0.7])\n    seeds.append(np.array(pts)[:N])\n    # 4: random uniform\n    seeds.append(np.random.rand(N,2))\n\n    # run all seeds\n    best_overall = (None, None, 0.0)\n    for C0 in seeds:\n        C, r, s = optimize_seed(C0)\n        if s > best_overall[2]:\n            best_overall = (C.copy(), r.copy(), s)\n    centers, radii, sum_radii = best_overall\n    return centers, radii, sum_radii\n```\n",
  "reasoning": "",
  "timestamp": "2026-02-11T01:15:22.788282",
  "cost_data": null,
  "model_config": {
    "model": "openai/o4-mini",
    "temperature": 0.4
  },
  "llm_call_duration_s": 42.125137561000884,
  "eval_duration_s": 0.525752320070751
}