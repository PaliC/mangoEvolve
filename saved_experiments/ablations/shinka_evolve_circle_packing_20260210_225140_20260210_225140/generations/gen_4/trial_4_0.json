{
  "trial_id": "trial_4_0",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.special import logsumexp\n\ndef construct_packing():\n    n = 26\n    tau_schedule = [0.03, 0.01, 0.005]\n    eps_lp = 1e-6\n\n    def softmin_value_and_weights(vals, tau):\n        # f = -tau * logsumexp(-vals/tau); df/dv = softmax(-v/tau)\n        z = -vals / tau\n        a = -tau * logsumexp(z)\n        w = np.exp(z - np.max(z))\n        w = w / np.sum(w)\n        return a, w\n\n    def obj_grad(C_flat, tau):\n        C = C_flat.reshape(-1, 2)\n        nloc = C.shape[0]\n        # Pairwise differences and distances\n        D = C[:, None, :] - C[None, :, :]\n        dist = np.sqrt(np.sum(D**2, axis=2))  # shape (n,n)\n        # Avoid zero division in gradients; we'll use safe distances\n        dist_safe = np.maximum(dist, 1e-12)\n\n        obj = 0.0\n        grad = np.zeros_like(C)\n\n        for i in range(nloc):\n            xi, yi = C[i]\n            b = np.array([xi, yi, 1.0 - xi, 1.0 - yi])  # boundary terms\n            # indices of others\n            js = np.arange(nloc) != i\n            js_idx = np.nonzero(js)[0]\n            dij = dist[i, js]\n            vals = np.concatenate([b, 0.5 * dij])\n            a_i, w = softmin_value_and_weights(vals, tau)\n            obj += a_i\n            # boundary grads\n            # d/dx: +1 for xi, -1 for (1-xi)\n            grad[i, 0] += w[0] - w[2]\n            grad[i, 1] += w[1] - w[3]\n            # pairwise grads\n            if js_idx.size > 0:\n                vecs = C[i] - C[js_idx]  # (m,2)\n                d_safe = dist_safe[i, js][:, None]  # (m,1)\n                w_pairs = w[4:][:, None]  # (m,1)\n                gpair = 0.5 * w_pairs * (vecs / d_safe)  # (m,2)\n                grad[i] += np.sum(gpair, axis=0)\n                grad[js_idx] -= gpair\n\n        f = -obj\n        g = -grad.ravel()\n        return f, g\n\n    def ensure_min_separation(C, min_sep=2e-4, max_iter=50):\n        # Push apart any pairs closer than min_sep by moving along their connecting line\n        C = C.copy()\n        nloc = C.shape[0]\n        for _ in range(max_iter):\n            D = C[:, None, :] - C[None, :, :]\n            dist = np.sqrt(np.sum(D**2, axis=2)) + np.eye(nloc)  # add eye to avoid zero on diag\n            close = np.argwhere((dist < min_sep) & (np.triu(np.ones_like(dist, dtype=bool), 1)))\n            if close.size == 0:\n                break\n            for i, j in close:\n                v = C[i] - C[j]\n                d = np.linalg.norm(v)\n                if d < 1e-12:\n                    # random small direction\n                    v = np.random.randn(2)\n                    v /= (np.linalg.norm(v) + 1e-12)\n                    d = 0.0\n                else:\n                    v = v / d\n                delta = 0.5 * (min_sep - d) * v\n                C[i] += delta\n                C[j] -= delta\n            # Keep inside [0,1]\n            C = np.clip(C, 0.0, 1.0)\n        return C\n\n    def solve_lp_radii(C):\n        # Ensure minimal center separation to avoid infeasible LP\n        C = ensure_min_separation(C, min_sep=2e-4, max_iter=50)\n        nloc = C.shape[0]\n        # Bounds to box\n        b_i = np.minimum(np.minimum(C[:, 0], C[:, 1]), np.minimum(1.0 - C[:, 0], 1.0 - C[:, 1]))\n        # Pairwise distances\n        D = C[:, None, :] - C[None, :, :]\n        dist = np.sqrt(np.sum(D**2, axis=2))\n        # If any distance < eps_lp, try to fix further and recompute\n        if np.any((dist + np.eye(nloc)) < eps_lp):\n            C = ensure_min_separation(C, min_sep=4e-4, max_iter=100)\n            D = C[:, None, :] - C[None, :, :]\n            dist = np.sqrt(np.sum(D**2, axis=2))\n        # Build LP: maximize sum r_i\n        # Variables: r in R^n, bounds r_i >= 0\n        # Constraints:\n        # 1) r_i <= b_i\n        # 2) r_i + r_j <= d_ij - eps_lp\n        # Build A_ub and b_ub\n        # r_i <= b_i\n        A_rows = []\n        b_rows = []\n        for i in range(nloc):\n            row = np.zeros(nloc)\n            row[i] = 1.0\n            A_rows.append(row)\n            b_rows.append(b_i[i])\n        # Pairwise constraints\n        for i in range(nloc):\n            for j in range(i + 1, nloc):\n                row = np.zeros(nloc)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_rows.append(row)\n                b_rows.append(max(0.0, dist[i, j] - eps_lp))  # if negative, infeasible; keep 0 to help solver diagnose\n        A_ub = np.vstack(A_rows)\n        b_ub = np.array(b_rows)\n        c = -np.ones(nloc)\n        bounds = [(0.0, None)] * nloc\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n        if res.status != 0:\n            # Try to repair by increasing separation and retry\n            C2 = ensure_min_separation(C, min_sep=6e-4, max_iter=150)\n            if not np.allclose(C2, C):\n                return solve_lp_radii(C2)\n            # If still failing, return zeros to ensure feasibility\n            return C, np.zeros(nloc), 0.0\n        r = res.x\n        # Post-check feasibility (numerical)\n        if np.any(r < -1e-8):\n            r = np.maximum(r, 0.0)\n        sum_r = float(np.sum(r))\n        return C, r, sum_r\n\n    def triangular_seed(n_points, angle_deg=0.0, jitter=0.002, rng=None):\n        if rng is None:\n            rng = np.random.default_rng()\n        # Approximate nearest-neighbor spacing for triangular lattice in unit square\n        a = np.sqrt(2.0 / (np.sqrt(3.0) * n_points))\n        dx = a\n        dy = a * np.sqrt(3.0) / 2.0\n        # Generate grid covering a bit larger than [0,1] to allow rotation\n        ys = np.arange(-2, int(np.ceil((1.0 + 2 * dy) / dy)) + 3) * dy\n        pts = []\n        for k, y in enumerate(ys):\n            x_offset = 0.5 * dx if (k % 2) else 0.0\n            xs = np.arange(-2, int(np.ceil((1.0 + 2 * dx) / dx)) + 3) * dx + x_offset\n            for x in xs:\n                pts.append([x, y])\n        P = np.array(pts, dtype=float)\n        # Center roughly at 0.5,0.5\n        # Shift so that the median falls near 0.5\n        P -= np.min(P, axis=0)\n        P /= np.max(P, axis=0)\n        P = 0.1 + 0.8 * P  # keep within [0.1,0.9] before rotation to avoid loss after rotation\n        # Rotate around center (0.5,0.5)\n        theta = np.deg2rad(angle_deg)\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n        P = (P - 0.5) @ R.T + 0.5\n        # Keep those within [0,1]\n        mask = np.all((P >= 0.0) & (P <= 1.0), axis=1)\n        P_in = P[mask]\n        # If too many, take nearest to center\n        if P_in.shape[0] < n_points:\n            # If too few, expand original cloud slightly by adding more jittered points\n            extra = n_points - P_in.shape[0]\n            add = rng.uniform(0.05, 0.95, size=(extra + 50, 2))\n            P_in = np.vstack([P_in, add])\n        # Rank by proximity to center\n        d2 = np.sum((P_in - 0.5) ** 2, axis=1)\n        idx = np.argsort(d2)[:n_points]\n        C0 = P_in[idx]\n        # Small jitter\n        C0 += rng.normal(scale=jitter, size=C0.shape)\n        C0 = np.clip(C0, 0.0, 1.0)\n        # Ensure minimal separation to avoid exact overlaps\n        C0 = ensure_min_separation(C0, min_sep=1e-3, max_iter=60)\n        return C0\n\n    def optimize_from_seed(C0, rng):\n        best_centers = None\n        best_radii = None\n        best_sum = -np.inf\n        Ccur = C0.copy()\n        x0 = Ccur.ravel()\n        bounds = [(0.0, 1.0)] * (2 * n)\n        for tau in tau_schedule:\n            res = minimize(lambda x: obj_grad(x, tau), x0, method='L-BFGS-B', jac=True, bounds=bounds,\n                           options=dict(maxiter=300, ftol=1e-9))\n            x0 = res.x\n            Ccur = x0.reshape(n, 2)\n            # slight cleanup\n            Ccur = np.clip(Ccur, 0.0, 1.0)\n            # avoid extreme near-collisions\n            Ccur = ensure_min_separation(Ccur, min_sep=2e-4, max_iter=60)\n            # LP feasibilization\n            Cfeas, r, s = solve_lp_radii(Ccur)\n            if s > best_sum + 1e-9:\n                best_sum = s\n                best_centers = Cfeas.copy()\n                best_radii = r.copy()\n        return best_centers, best_radii, best_sum\n\n    rng = np.random.default_rng(12345)\n    seeds = []\n    # Base hex-like\n    seeds.append(triangular_seed(n, angle_deg=0.0, jitter=0.003, rng=rng))\n    # Slight rotation\n    seeds.append(triangular_seed(n, angle_deg=18.0, jitter=0.003, rng=rng))\n    # Opposite rotation\n    seeds.append(triangular_seed(n, angle_deg=-12.0, jitter=0.003, rng=rng))\n\n    global_best_sum = -np.inf\n    global_best_centers = None\n    global_best_radii = None\n\n    for C0 in seeds:\n        Cb, rb, sb = optimize_from_seed(C0, rng)\n        if sb > global_best_sum + 1e-9:\n            global_best_sum = sb\n            global_best_centers = Cb\n            global_best_radii = rb\n\n    # Final guard: ensure strict feasibility with 1e-6 tolerance\n    if global_best_centers is None:\n        # Fallback trivial non-overlapping tiny circles\n        centers = np.linspace(0.1, 0.9, n)\n        centers = np.stack([centers, np.mod(np.arange(n) * 0.381966, 1.0)], axis=1)\n        centers = np.clip(centers, 0.0, 1.0)\n        centers, radii, sum_r = solve_lp_radii(centers)\n        return centers, radii, float(sum_r)\n\n    C_final = ensure_min_separation(global_best_centers, min_sep=2e-4, max_iter=80)\n    C_final, r_final, s_final = solve_lp_radii(C_final)\n\n    return C_final.astype(float), r_final.astype(float), float(np.sum(r_final))",
  "metrics": {
    "valid": true,
    "score": 2.534055444532196,
    "eval_time": 1.7173185348510742,
    "error": null
  },
  "prompt": "\nYou are to produce a single Python code block only, containing a function construct_packing() and optional helpers, using only numpy and scipy.\nGoal: Pack 26 non-overlapping circles in [0,1]^2 maximizing sum of radii. Return strictly feasible solution via LP feasibilization.\n\nApproach:\n- Decision vars: centers C in [0,1]^2. Radii are computed by an LP given centers.\n- Objective surrogate for optimizing centers: maximize a smooth lower bound S(C) of attainable sum of radii using soft-min of constraints:\n  For each i, define available radius a_i(C) = softmin([x_i, y_i, 1-x_i, 1-y_i, 0.5*min_j!=i dist(C_i,C_j)]), where softmin uses log-sum-exp with temperature tau.\n  Use tau decreasing schedule (annealing): start tau=0.03, reduce to 0.01, 0.005 across runs.\n- Optimize centers via L-BFGS-B (bounds [0,1]) on -sum a_i(C) with analytic gradient:\n  - Boundary terms: grad of x_i -> 1 for x_i, etc.\n  - Pairwise term: d_ij = ||C_i - C_j||; grad of 0.5*d_ij w.r.t C_i is 0.5*(C_i - C_j)/max(d_ij, eps)\n  - softmin gradient via softmax over the candidate constraints\n- After each stage, run LP to compute exact radii and get sum_r. Keep best feasible seen.\n- Initialize centers from a near-hexagonal grid (rotated and jittered) trimmed to 26 points near a triangular lattice density.\n\nLP:\nMaximize sum r_i\ns.t. 0 <= r_i\n     r_i <= b_i := min(x_i, y_i, 1-x_i, 1-y_i)\n     r_i + r_j <= ||C_i - C_j|| - 1e-6 for all i<j\nSolve with scipy.optimize.linprog (highs), robust to infeasibility.\n\nImplementation details:\n- Vectorize distances; use eps only in division to avoid penalty bias.\n- Multiple restarts: 3 seeds (base hex, shifted, edge-focused); keep best.\n- Return shapes: centers (26,2), radii (26,), sum_radii float.\n\nNo prints. Single code block only.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.special import logsumexp\n\ndef construct_packing():\n    n = 26\n    tau_schedule = [0.03, 0.01, 0.005]\n    eps_lp = 1e-6\n\n    def softmin_value_and_weights(vals, tau):\n        # f = -tau * logsumexp(-vals/tau); df/dv = softmax(-v/tau)\n        z = -vals / tau\n        a = -tau * logsumexp(z)\n        w = np.exp(z - np.max(z))\n        w = w / np.sum(w)\n        return a, w\n\n    def obj_grad(C_flat, tau):\n        C = C_flat.reshape(-1, 2)\n        nloc = C.shape[0]\n        # Pairwise differences and distances\n        D = C[:, None, :] - C[None, :, :]\n        dist = np.sqrt(np.sum(D**2, axis=2))  # shape (n,n)\n        # Avoid zero division in gradients; we'll use safe distances\n        dist_safe = np.maximum(dist, 1e-12)\n\n        obj = 0.0\n        grad = np.zeros_like(C)\n\n        for i in range(nloc):\n            xi, yi = C[i]\n            b = np.array([xi, yi, 1.0 - xi, 1.0 - yi])  # boundary terms\n            # indices of others\n            js = np.arange(nloc) != i\n            js_idx = np.nonzero(js)[0]\n            dij = dist[i, js]\n            vals = np.concatenate([b, 0.5 * dij])\n            a_i, w = softmin_value_and_weights(vals, tau)\n            obj += a_i\n            # boundary grads\n            # d/dx: +1 for xi, -1 for (1-xi)\n            grad[i, 0] += w[0] - w[2]\n            grad[i, 1] += w[1] - w[3]\n            # pairwise grads\n            if js_idx.size > 0:\n                vecs = C[i] - C[js_idx]  # (m,2)\n                d_safe = dist_safe[i, js][:, None]  # (m,1)\n                w_pairs = w[4:][:, None]  # (m,1)\n                gpair = 0.5 * w_pairs * (vecs / d_safe)  # (m,2)\n                grad[i] += np.sum(gpair, axis=0)\n                grad[js_idx] -= gpair\n\n        f = -obj\n        g = -grad.ravel()\n        return f, g\n\n    def ensure_min_separation(C, min_sep=2e-4, max_iter=50):\n        # Push apart any pairs closer than min_sep by moving along their connecting line\n        C = C.copy()\n        nloc = C.shape[0]\n        for _ in range(max_iter):\n            D = C[:, None, :] - C[None, :, :]\n            dist = np.sqrt(np.sum(D**2, axis=2)) + np.eye(nloc)  # add eye to avoid zero on diag\n            close = np.argwhere((dist < min_sep) & (np.triu(np.ones_like(dist, dtype=bool), 1)))\n            if close.size == 0:\n                break\n            for i, j in close:\n                v = C[i] - C[j]\n                d = np.linalg.norm(v)\n                if d < 1e-12:\n                    # random small direction\n                    v = np.random.randn(2)\n                    v /= (np.linalg.norm(v) + 1e-12)\n                    d = 0.0\n                else:\n                    v = v / d\n                delta = 0.5 * (min_sep - d) * v\n                C[i] += delta\n                C[j] -= delta\n            # Keep inside [0,1]\n            C = np.clip(C, 0.0, 1.0)\n        return C\n\n    def solve_lp_radii(C):\n        # Ensure minimal center separation to avoid infeasible LP\n        C = ensure_min_separation(C, min_sep=2e-4, max_iter=50)\n        nloc = C.shape[0]\n        # Bounds to box\n        b_i = np.minimum(np.minimum(C[:, 0], C[:, 1]), np.minimum(1.0 - C[:, 0], 1.0 - C[:, 1]))\n        # Pairwise distances\n        D = C[:, None, :] - C[None, :, :]\n        dist = np.sqrt(np.sum(D**2, axis=2))\n        # If any distance < eps_lp, try to fix further and recompute\n        if np.any((dist + np.eye(nloc)) < eps_lp):\n            C = ensure_min_separation(C, min_sep=4e-4, max_iter=100)\n            D = C[:, None, :] - C[None, :, :]\n            dist = np.sqrt(np.sum(D**2, axis=2))\n        # Build LP: maximize sum r_i\n        # Variables: r in R^n, bounds r_i >= 0\n        # Constraints:\n        # 1) r_i <= b_i\n        # 2) r_i + r_j <= d_ij - eps_lp\n        # Build A_ub and b_ub\n        # r_i <= b_i\n        A_rows = []\n        b_rows = []\n        for i in range(nloc):\n            row = np.zeros(nloc)\n            row[i] = 1.0\n            A_rows.append(row)\n            b_rows.append(b_i[i])\n        # Pairwise constraints\n        for i in range(nloc):\n            for j in range(i + 1, nloc):\n                row = np.zeros(nloc)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_rows.append(row)\n                b_rows.append(max(0.0, dist[i, j] - eps_lp))  # if negative, infeasible; keep 0 to help solver diagnose\n        A_ub = np.vstack(A_rows)\n        b_ub = np.array(b_rows)\n        c = -np.ones(nloc)\n        bounds = [(0.0, None)] * nloc\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n        if res.status != 0:\n            # Try to repair by increasing separation and retry\n            C2 = ensure_min_separation(C, min_sep=6e-4, max_iter=150)\n            if not np.allclose(C2, C):\n                return solve_lp_radii(C2)\n            # If still failing, return zeros to ensure feasibility\n            return C, np.zeros(nloc), 0.0\n        r = res.x\n        # Post-check feasibility (numerical)\n        if np.any(r < -1e-8):\n            r = np.maximum(r, 0.0)\n        sum_r = float(np.sum(r))\n        return C, r, sum_r\n\n    def triangular_seed(n_points, angle_deg=0.0, jitter=0.002, rng=None):\n        if rng is None:\n            rng = np.random.default_rng()\n        # Approximate nearest-neighbor spacing for triangular lattice in unit square\n        a = np.sqrt(2.0 / (np.sqrt(3.0) * n_points))\n        dx = a\n        dy = a * np.sqrt(3.0) / 2.0\n        # Generate grid covering a bit larger than [0,1] to allow rotation\n        ys = np.arange(-2, int(np.ceil((1.0 + 2 * dy) / dy)) + 3) * dy\n        pts = []\n        for k, y in enumerate(ys):\n            x_offset = 0.5 * dx if (k % 2) else 0.0\n            xs = np.arange(-2, int(np.ceil((1.0 + 2 * dx) / dx)) + 3) * dx + x_offset\n            for x in xs:\n                pts.append([x, y])\n        P = np.array(pts, dtype=float)\n        # Center roughly at 0.5,0.5\n        # Shift so that the median falls near 0.5\n        P -= np.min(P, axis=0)\n        P /= np.max(P, axis=0)\n        P = 0.1 + 0.8 * P  # keep within [0.1,0.9] before rotation to avoid loss after rotation\n        # Rotate around center (0.5,0.5)\n        theta = np.deg2rad(angle_deg)\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n        P = (P - 0.5) @ R.T + 0.5\n        # Keep those within [0,1]\n        mask = np.all((P >= 0.0) & (P <= 1.0), axis=1)\n        P_in = P[mask]\n        # If too many, take nearest to center\n        if P_in.shape[0] < n_points:\n            # If too few, expand original cloud slightly by adding more jittered points\n            extra = n_points - P_in.shape[0]\n            add = rng.uniform(0.05, 0.95, size=(extra + 50, 2))\n            P_in = np.vstack([P_in, add])\n        # Rank by proximity to center\n        d2 = np.sum((P_in - 0.5) ** 2, axis=1)\n        idx = np.argsort(d2)[:n_points]\n        C0 = P_in[idx]\n        # Small jitter\n        C0 += rng.normal(scale=jitter, size=C0.shape)\n        C0 = np.clip(C0, 0.0, 1.0)\n        # Ensure minimal separation to avoid exact overlaps\n        C0 = ensure_min_separation(C0, min_sep=1e-3, max_iter=60)\n        return C0\n\n    def optimize_from_seed(C0, rng):\n        best_centers = None\n        best_radii = None\n        best_sum = -np.inf\n        Ccur = C0.copy()\n        x0 = Ccur.ravel()\n        bounds = [(0.0, 1.0)] * (2 * n)\n        for tau in tau_schedule:\n            res = minimize(lambda x: obj_grad(x, tau), x0, method='L-BFGS-B', jac=True, bounds=bounds,\n                           options=dict(maxiter=300, ftol=1e-9))\n            x0 = res.x\n            Ccur = x0.reshape(n, 2)\n            # slight cleanup\n            Ccur = np.clip(Ccur, 0.0, 1.0)\n            # avoid extreme near-collisions\n            Ccur = ensure_min_separation(Ccur, min_sep=2e-4, max_iter=60)\n            # LP feasibilization\n            Cfeas, r, s = solve_lp_radii(Ccur)\n            if s > best_sum + 1e-9:\n                best_sum = s\n                best_centers = Cfeas.copy()\n                best_radii = r.copy()\n        return best_centers, best_radii, best_sum\n\n    rng = np.random.default_rng(12345)\n    seeds = []\n    # Base hex-like\n    seeds.append(triangular_seed(n, angle_deg=0.0, jitter=0.003, rng=rng))\n    # Slight rotation\n    seeds.append(triangular_seed(n, angle_deg=18.0, jitter=0.003, rng=rng))\n    # Opposite rotation\n    seeds.append(triangular_seed(n, angle_deg=-12.0, jitter=0.003, rng=rng))\n\n    global_best_sum = -np.inf\n    global_best_centers = None\n    global_best_radii = None\n\n    for C0 in seeds:\n        Cb, rb, sb = optimize_from_seed(C0, rng)\n        if sb > global_best_sum + 1e-9:\n            global_best_sum = sb\n            global_best_centers = Cb\n            global_best_radii = rb\n\n    # Final guard: ensure strict feasibility with 1e-6 tolerance\n    if global_best_centers is None:\n        # Fallback trivial non-overlapping tiny circles\n        centers = np.linspace(0.1, 0.9, n)\n        centers = np.stack([centers, np.mod(np.arange(n) * 0.381966, 1.0)], axis=1)\n        centers = np.clip(centers, 0.0, 1.0)\n        centers, radii, sum_r = solve_lp_radii(centers)\n        return centers, radii, float(sum_r)\n\n    C_final = ensure_min_separation(global_best_centers, min_sep=2e-4, max_iter=80)\n    C_final, r_final, s_final = solve_lp_radii(C_final)\n\n    return C_final.astype(float), r_final.astype(float), float(np.sum(r_final))\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T01:17:27.911821",
  "cost_data": null,
  "model_config": {
    "model": "openai/gpt-5",
    "temperature": 0.4
  },
  "llm_call_duration_s": 166.05529695097357,
  "eval_duration_s": 1.7173245860030875
}