{
  "trial_id": "trial_4_5",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a packing of 26 circles in the unit square by trying several deterministic layouts,\n    solving a linear program to maximize the sum of radii given fixed centers, and performing\n    a few rounds of center nudging with re-optimization.\n\n    Returns:\n        centers: (26, 2) np.ndarray of center coordinates\n        radii: (26,) np.ndarray of radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    eps = 1e-6\n    n = 26\n\n    # Helper: Solve LP for radii given centers\n    def solve_radii(centers):\n        centers = np.asarray(centers, dtype=float)\n        n = centers.shape[0]\n\n        # Distance to boundary for each circle\n        d_to_boundary = np.minimum.reduce([centers[:, 0], 1.0 - centers[:, 0],\n                                           centers[:, 1], 1.0 - centers[:, 1]])\n\n        # Build LP:\n        # Variables: r_0 ... r_{n-1}\n        # Maximize sum r_i  => minimize -sum r_i\n        # Constraints:\n        #   r_i <= d_to_boundary[i]\n        #   r_i + r_j <= dist(i,j) - eps  for all i<j\n        A = []\n        b = []\n\n        # Boundary constraints\n        for i in range(n):\n            row = np.zeros(n)\n            row[i] = 1.0\n            A.append(row)\n            b.append(d_to_boundary[i])\n\n        # Pair constraints\n        dist = np.linalg.norm(centers[:, None, :] - centers[None, :, :], axis=2)\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i] = 1.0\n                row[j] = 1.0\n                A.append(row)\n                b.append(dist[i, j] - eps)\n\n        A = np.asarray(A, dtype=float)\n        b = np.asarray(b, dtype=float)\n\n        c = -np.ones(n, dtype=float)\n        bounds = [(0.0, None) for _ in range(n)]\n\n        # Use HiGHS for performance and robustness\n        res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs', options={'presolve': True, 'tol': 1e-12})\n        if res.success:\n            radii = res.x\n            sum_radii = float(radii.sum())\n            return radii, sum_radii\n        else:\n            # Fallback: zero radii (shouldn't happen in normal runs)\n            radii = np.zeros(n, dtype=float)\n            return radii, 0.0\n\n    # Helper: initial hex lattice layout generator\n    def hex_points_for_d(d, limit=40):\n        pts = []\n        for yi in range(-limit, limit + 1):\n            y = yi * (np.sqrt(3.0) / 2.0) * d\n            for xi in range(-limit, limit + 1):\n                x = xi * d + (0.5 * d if (yi % 2) else 0.0)\n                if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:\n                    pts.append([x, y])\n        return np.array(pts, dtype=float)\n\n    def layout_hex():\n        # Start with a reasonably dense hex lattice\n        d = 0.14\n        pts = hex_points_for_d(d, limit=40)\n        if pts.shape[0] < n:\n            d = 0.10\n            pts = hex_points_for_d(d, limit=60)\n        if pts.shape[0] < n:\n            d = 0.08\n            pts = hex_points_for_d(d, limit=80)\n        return pts[:n]\n\n    def layout_edge_biased(base_points):\n        # Slight radial push outward toward edges\n        c = np.array([0.5, 0.5])\n        p = base_points.copy()\n        dirs = p - c\n        norms = np.linalg.norm(dirs, axis=1, keepdims=True)\n        norms = np.where(norms < 1e-12, 1.0, norms)\n        push = 0.20 * (dirs / norms)\n        p = p + push\n        p = np.clip(p, 0.0, 1.0)\n        return p\n\n    def layout_corner_emphasis(base_points):\n        # Move points toward their nearest corner by a half-step\n        p = base_points.copy()\n        for idx in range(p.shape[0]):\n            x, y = p[idx]\n            corner = np.array([0.0, 0.0])\n            if x >= 0.5:\n                corner[0] = 1.0\n            if y >= 0.5:\n                corner[1] = 1.0\n            p[idx] = 0.5 * (p[idx] + corner)\n        p = np.clip(p, 0.0, 1.0)\n        return p\n\n    # Build layouts (deterministic)\n    base_hex = layout_hex()\n    layouts = [\n        base_hex,\n        layout_edge_biased(base_hex),\n        layout_corner_emphasis(base_hex)\n    ]\n\n    # Nudging and re-optimization\n    best_centers = None\n    best_radii = None\n    best_sum = -1.0\n\n    def nudge_centers(centers, radii):\n        centers = np.asarray(centers, dtype=float)\n        radii = np.asarray(radii, dtype=float)\n        m = centers.shape[0]\n        x = centers.copy()\n        r = radii.copy()\n\n        # Distances between centers\n        dx = x[:, 0][:, None] - x[None, :, 0]\n        dy = x[:, 1][:, None] - x[None, :, 1]\n        dist = np.sqrt(dx * dx + dy * dy)\n        np.fill_diagonal(dist, np.inf)\n\n        # Boundary distances\n        d_bound = np.minimum.reduce([x[:, 0], 1.0 - x[:, 0], x[:, 1], 1.0 - x[:, 1]])\n        # Slack for pair constraints\n        s_pair = dist - (r[:, None] + r[None, :]) - eps\n\n        # For each i, compute minimum slack\n        min_slack_i = np.minimum(d_bound - r, np.min(s_pair, axis=1))\n\n        delta = np.zeros((m, 2), dtype=float)\n\n        for i in range(m):\n            # Boundary contribution if boundary is tight\n            if (d_bound[i] - r[i]) <= min_slack_i[i] + 1e-6:\n                # Push away from nearest edge\n                side = int(np.argmin([x[i, 0], 1.0 - x[i, 0], x[i, 1], 1.0 - x[i, 1]]))\n                g = np.zeros(2, dtype=float)\n                if side == 0:\n                    g = np.array([1.0, 0.0])\n                elif side == 1:\n                    g = np.array([-1.0, 0.0])\n                elif side == 2:\n                    g = np.array([0.0, 1.0])\n                else:\n                    g = np.array([0.0, -1.0])\n                delta[i] += g\n\n            # Pair constraints that are among the tightest\n            tight_js = np.where((dist[i, :] < np.inf) & (s_pair[i, :] <= min_slack_i[i] + 1e-6))[0]\n            for j in tight_js:\n                if j == i:\n                    continue\n                dij = dist[i, j]\n                if dij < 1e-12:\n                    continue\n                grad = (x[i] - x[j]) / dij\n                w = np.exp(-max(0.0, (min_slack_i[i] - s_pair[i, j])) / 0.05)\n                delta[i] += w * grad\n\n        # Apply a modest step\n        step = 0.15\n        x = x + step * delta\n        x = np.clip(x, 0.0, 1.0)\n        return x\n\n    for base in layouts:\n        centers = base.copy()\n        # Normalize to exact 26 points\n        if centers.shape[0] != n:\n            # If somehow not 26, pad or trim deterministically\n            if centers.shape[0] > n:\n                centers = centers[:n]\n            else:\n                # Pad with slight jitter in a deterministic way\n                need = n - centers.shape[0]\n                pad = np.tile(np.array([[0.25, 0.25]]), (need, 1))\n                centers = np.vstack([centers, pad])\n\n        # Run a few rounds: LP, then nudges + LP\n        for _ in range(3):  # 3 rounds: initial LP, then 2 nudged refinements\n            radii, sum_radii = solve_radii(centers)\n            if best_centers is None or sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            # Nudging step (except after last LP in this loop)\n            centers = nudge_centers(centers, radii)\n\n    # Fallback if something failed\n    if best_centers is None:\n        best_centers = layout_hex()[:n]\n        best_radii, best_sum = solve_radii(best_centers)\n\n    # Ensure shapes and non-negativity\n    centers_out = np.asarray(best_centers, dtype=float)\n    radii_out = np.asarray(best_radii, dtype=float)\n    sum_radii_out = float(best_sum)\n\n    # Final guard: clip radii to be non-negative and within feasible bounds\n    radii_out = np.clip(radii_out, 0.0, None)\n    return centers_out, radii_out, sum_radii_out",
  "metrics": {
    "valid": true,
    "score": 1.139992,
    "eval_time": 0.4233419895172119,
    "error": null
  },
  "prompt": "\nProvide a single Python code block implementing construct_packing() using numpy and scipy only.\nConstructive approach:\n- Generate multiple deterministic center layouts for 26 points:\n  (i) hexagonal lattice clipped to unit square, scale and shift variants,\n  (ii) edge-biased hex (slightly pull points toward edges),\n  (iii) corner-emphasis variant.\n- For each layout, run LP to compute radii (maximize sum r, constraints r>=0, r<=boundary, r_i + r_j <= d_ij - 1e-6).\n- Apply a few rounds of small reposition nudges: move any center with r_i much smaller than neighbors toward local softmax-weighted direction of increasing min-constraint; after each nudge, re-LP.\n- Keep best feasible solution.\n\nEnsure:\n- Fully vectorized distance computations.\n- Epsilon only in denominators where needed.\n- Strict feasibility tolerance 1e-6.\n\nReturn centers (26,2), radii (26,), sum_radii float. No prints.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a packing of 26 circles in the unit square by trying several deterministic layouts,\n    solving a linear program to maximize the sum of radii given fixed centers, and performing\n    a few rounds of center nudging with re-optimization.\n\n    Returns:\n        centers: (26, 2) np.ndarray of center coordinates\n        radii: (26,) np.ndarray of radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    eps = 1e-6\n    n = 26\n\n    # Helper: Solve LP for radii given centers\n    def solve_radii(centers):\n        centers = np.asarray(centers, dtype=float)\n        n = centers.shape[0]\n\n        # Distance to boundary for each circle\n        d_to_boundary = np.minimum.reduce([centers[:, 0], 1.0 - centers[:, 0],\n                                           centers[:, 1], 1.0 - centers[:, 1]])\n\n        # Build LP:\n        # Variables: r_0 ... r_{n-1}\n        # Maximize sum r_i  => minimize -sum r_i\n        # Constraints:\n        #   r_i <= d_to_boundary[i]\n        #   r_i + r_j <= dist(i,j) - eps  for all i<j\n        A = []\n        b = []\n\n        # Boundary constraints\n        for i in range(n):\n            row = np.zeros(n)\n            row[i] = 1.0\n            A.append(row)\n            b.append(d_to_boundary[i])\n\n        # Pair constraints\n        dist = np.linalg.norm(centers[:, None, :] - centers[None, :, :], axis=2)\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i] = 1.0\n                row[j] = 1.0\n                A.append(row)\n                b.append(dist[i, j] - eps)\n\n        A = np.asarray(A, dtype=float)\n        b = np.asarray(b, dtype=float)\n\n        c = -np.ones(n, dtype=float)\n        bounds = [(0.0, None) for _ in range(n)]\n\n        # Use HiGHS for performance and robustness\n        res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs', options={'presolve': True, 'tol': 1e-12})\n        if res.success:\n            radii = res.x\n            sum_radii = float(radii.sum())\n            return radii, sum_radii\n        else:\n            # Fallback: zero radii (shouldn't happen in normal runs)\n            radii = np.zeros(n, dtype=float)\n            return radii, 0.0\n\n    # Helper: initial hex lattice layout generator\n    def hex_points_for_d(d, limit=40):\n        pts = []\n        for yi in range(-limit, limit + 1):\n            y = yi * (np.sqrt(3.0) / 2.0) * d\n            for xi in range(-limit, limit + 1):\n                x = xi * d + (0.5 * d if (yi % 2) else 0.0)\n                if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:\n                    pts.append([x, y])\n        return np.array(pts, dtype=float)\n\n    def layout_hex():\n        # Start with a reasonably dense hex lattice\n        d = 0.14\n        pts = hex_points_for_d(d, limit=40)\n        if pts.shape[0] < n:\n            d = 0.10\n            pts = hex_points_for_d(d, limit=60)\n        if pts.shape[0] < n:\n            d = 0.08\n            pts = hex_points_for_d(d, limit=80)\n        return pts[:n]\n\n    def layout_edge_biased(base_points):\n        # Slight radial push outward toward edges\n        c = np.array([0.5, 0.5])\n        p = base_points.copy()\n        dirs = p - c\n        norms = np.linalg.norm(dirs, axis=1, keepdims=True)\n        norms = np.where(norms < 1e-12, 1.0, norms)\n        push = 0.20 * (dirs / norms)\n        p = p + push\n        p = np.clip(p, 0.0, 1.0)\n        return p\n\n    def layout_corner_emphasis(base_points):\n        # Move points toward their nearest corner by a half-step\n        p = base_points.copy()\n        for idx in range(p.shape[0]):\n            x, y = p[idx]\n            corner = np.array([0.0, 0.0])\n            if x >= 0.5:\n                corner[0] = 1.0\n            if y >= 0.5:\n                corner[1] = 1.0\n            p[idx] = 0.5 * (p[idx] + corner)\n        p = np.clip(p, 0.0, 1.0)\n        return p\n\n    # Build layouts (deterministic)\n    base_hex = layout_hex()\n    layouts = [\n        base_hex,\n        layout_edge_biased(base_hex),\n        layout_corner_emphasis(base_hex)\n    ]\n\n    # Nudging and re-optimization\n    best_centers = None\n    best_radii = None\n    best_sum = -1.0\n\n    def nudge_centers(centers, radii):\n        centers = np.asarray(centers, dtype=float)\n        radii = np.asarray(radii, dtype=float)\n        m = centers.shape[0]\n        x = centers.copy()\n        r = radii.copy()\n\n        # Distances between centers\n        dx = x[:, 0][:, None] - x[None, :, 0]\n        dy = x[:, 1][:, None] - x[None, :, 1]\n        dist = np.sqrt(dx * dx + dy * dy)\n        np.fill_diagonal(dist, np.inf)\n\n        # Boundary distances\n        d_bound = np.minimum.reduce([x[:, 0], 1.0 - x[:, 0], x[:, 1], 1.0 - x[:, 1]])\n        # Slack for pair constraints\n        s_pair = dist - (r[:, None] + r[None, :]) - eps\n\n        # For each i, compute minimum slack\n        min_slack_i = np.minimum(d_bound - r, np.min(s_pair, axis=1))\n\n        delta = np.zeros((m, 2), dtype=float)\n\n        for i in range(m):\n            # Boundary contribution if boundary is tight\n            if (d_bound[i] - r[i]) <= min_slack_i[i] + 1e-6:\n                # Push away from nearest edge\n                side = int(np.argmin([x[i, 0], 1.0 - x[i, 0], x[i, 1], 1.0 - x[i, 1]]))\n                g = np.zeros(2, dtype=float)\n                if side == 0:\n                    g = np.array([1.0, 0.0])\n                elif side == 1:\n                    g = np.array([-1.0, 0.0])\n                elif side == 2:\n                    g = np.array([0.0, 1.0])\n                else:\n                    g = np.array([0.0, -1.0])\n                delta[i] += g\n\n            # Pair constraints that are among the tightest\n            tight_js = np.where((dist[i, :] < np.inf) & (s_pair[i, :] <= min_slack_i[i] + 1e-6))[0]\n            for j in tight_js:\n                if j == i:\n                    continue\n                dij = dist[i, j]\n                if dij < 1e-12:\n                    continue\n                grad = (x[i] - x[j]) / dij\n                w = np.exp(-max(0.0, (min_slack_i[i] - s_pair[i, j])) / 0.05)\n                delta[i] += w * grad\n\n        # Apply a modest step\n        step = 0.15\n        x = x + step * delta\n        x = np.clip(x, 0.0, 1.0)\n        return x\n\n    for base in layouts:\n        centers = base.copy()\n        # Normalize to exact 26 points\n        if centers.shape[0] != n:\n            # If somehow not 26, pad or trim deterministically\n            if centers.shape[0] > n:\n                centers = centers[:n]\n            else:\n                # Pad with slight jitter in a deterministic way\n                need = n - centers.shape[0]\n                pad = np.tile(np.array([[0.25, 0.25]]), (need, 1))\n                centers = np.vstack([centers, pad])\n\n        # Run a few rounds: LP, then nudges + LP\n        for _ in range(3):  # 3 rounds: initial LP, then 2 nudged refinements\n            radii, sum_radii = solve_radii(centers)\n            if best_centers is None or sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            # Nudging step (except after last LP in this loop)\n            centers = nudge_centers(centers, radii)\n\n    # Fallback if something failed\n    if best_centers is None:\n        best_centers = layout_hex()[:n]\n        best_radii, best_sum = solve_radii(best_centers)\n\n    # Ensure shapes and non-negativity\n    centers_out = np.asarray(best_centers, dtype=float)\n    radii_out = np.asarray(best_radii, dtype=float)\n    sum_radii_out = float(best_sum)\n\n    # Final guard: clip radii to be non-negative and within feasible bounds\n    radii_out = np.clip(radii_out, 0.0, None)\n    return centers_out, radii_out, sum_radii_out\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T01:16:27.464839",
  "cost_data": null,
  "model_config": {
    "model": "openai/gpt-5-nano",
    "temperature": 0.35
  },
  "llm_call_duration_s": 106.90340986591764,
  "eval_duration_s": 0.4233479400863871
}