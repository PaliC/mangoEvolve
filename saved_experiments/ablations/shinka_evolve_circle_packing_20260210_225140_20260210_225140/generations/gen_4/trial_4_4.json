{
  "trial_id": "trial_4_4",
  "generation": 4,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct packing of 26 non-overlapping circles in unit square.\n    Returns: (centers, radii, sum_radii)\n    centers: np.array shape (26,2)\n    radii: np.array shape (26,)\n    sum_radii: float\n    \"\"\"\n    np.random.seed(0)\n    n = 26\n    eps = 1e-8\n    tol = 1e-6\n\n    # Helper: check feasibility\n    def is_feasible(centers, radii, tol=1e-6):\n        if np.any(radii < -1e-12):\n            return False\n        if np.any(centers < -1e-12) or np.any(centers > 1 + 1e-12):\n            return False\n        # boundary\n        x = centers[:,0]; y = centers[:,1]\n        dists = np.vstack([x, y, 1 - x, 1 - y]).min(axis=0)\n        if np.any(radii - dists > tol):\n            return False\n        # pairwise\n        dx = x[:,None] - x[None,:]\n        dy = y[:,None] - y[None,:]\n        dmat = np.sqrt(dx*dx + dy*dy)\n        iu = np.triu_indices(n, 1)\n        if np.any(radii[iu[0]] + radii[iu[1]] - dmat[iu] > tol):\n            return False\n        return True\n\n    # Objective and gradient factory\n    def make_obj(mu_b, mu_p):\n        def obj_and_grad(z):\n            # z: flattened [x0..x25, y0..y25, r0..r25]\n            x = z[0:n]\n            y = z[n:2*n]\n            r = z[2*n:3*n]\n            # Compute objective J = -sum r + mu_b * boundary_pen + mu_p * pairwise_pen\n            J = -r.sum()\n            # boundary\n            dx_left = x\n            dx_right = 1.0 - x\n            dy_bottom = y\n            dy_top = 1.0 - y\n            # z = r - dist\n            z_left = r - dx_left\n            z_right = r - dx_right\n            z_bottom = r - dy_bottom\n            z_top = r - dy_top\n            # relu\n            rl = np.maximum(z_left, 0.0)\n            rr = np.maximum(z_right, 0.0)\n            rb = np.maximum(z_bottom, 0.0)\n            rt = np.maximum(z_top, 0.0)\n            boundary_pen = (rl*rl + rr*rr + rb*rb + rt*rt).sum()\n            J += mu_b * boundary_pen\n            # pairwise\n            dx = x[:,None] - x[None,:]\n            dy = y[:,None] - y[None,:]\n            dmat = np.sqrt(dx*dx + dy*dy + eps)\n            # mask upper triangle excluding diagonal, but we'll compute full matrix and zero diag\n            zpair = (r[:,None] + r[None,:] - dmat)\n            # zero diagonal\n            np.fill_diagonal(zpair, 0.0)\n            rp = np.maximum(zpair, 0.0)\n            pair_pen = (rp*rp).sum() * 0.5  # since each pair counted twice in full matrix\n            # but easier: sum over i<j = 0.5 * sum over all i!=j\n            J += mu_p * pair_pen\n\n            # Gradients\n            gx = np.zeros_like(x)\n            gy = np.zeros_like(y)\n            gr = np.zeros_like(r)\n\n            # gradient from -sum r\n            gr += -1.0\n\n            # boundary grads\n            # derivative of relu(z)^2 is 2*relu(z)*dz\n            # for left: dz/dr = 1, dz/dx = -1\n            mask = rl > 0\n            if np.any(mask):\n                v = 2.0 * rl[mask] * mu_b\n                gr[mask] += v\n                gx[mask] += -v\n            # right: dz/dr =1, dz/dx = +1\n            mask = rr > 0\n            if np.any(mask):\n                v = 2.0 * rr[mask] * mu_b\n                gr[mask] += v\n                gx[mask] += v\n            # bottom: dz/dr =1, dz/dy = -1\n            mask = rb > 0\n            if np.any(mask):\n                v = 2.0 * rb[mask] * mu_b\n                gr[mask] += v\n                gy[mask] += -v\n            # top: dz/dr =1, dz/dy = +1\n            mask = rt > 0\n            if np.any(mask):\n                v = 2.0 * rt[mask] * mu_b\n                gr[mask] += v\n                gy[mask] += v\n\n            # pairwise grads\n            # For full matrix, each pair counted twice; we handle full then multiply by mu_p/1 because pair_pen included 0.5 factor\n            # rp is full matrix nonnegative with zeros on diagonal\n            if np.any(rp > 0):\n                Z = rp  # shape n x n\n                # dr contribution: for each i sum_j 2*mu_p*0.5*Z_ij * (dz/dr_i) where dz/dr_i = 1\n                # But since we used pair_pen = 0.5*sum(Z^2), derivative factor is mu_p * (Z) (not doubled)\n                # Let's compute consistent: derivative of mu_p * 0.5 * sum(Z^2) wrt r_i:\n                # d/d r_i = mu_p * sum_j Z_ij * dZ_ij/dr_i * 0.5*2? Simpler compute directly elementwise:\n                # For i != j, contribution to objective is mu_p * 0.5 * Z_ij^2. d/d r_i of Z_ij = 1, so d = mu_p * 0.5 * 2 * Z_ij * 1 = mu_p * Z_ij.\n                # But note Z_ij and Z_ji both present; for dr_i sum over j mu_p * Z_ij. So dr += mu_p * Z.sum(axis=1)\n                dr_pair = mu_p * Z.sum(axis=1)\n                gr += dr_pair\n\n                # For x,y grads: derivative of Z_ij wrt x_i is - (x_i - x_j)/d_ij\n                # contribution to grad from pair penalty: for each (i,j) mu_p * Z_ij * dZ_ij/dx_i\n                # Thus gx_i += mu_p * sum_j Z_ij * ( - (x_i - x_j)/d_ij )\n                invd = 1.0 / dmat\n                # avoid diagonal\n                invd[np.diag_indices(n)] = 0.0\n                factor = - mu_p * Z * invd  # shape n x n\n                gx += factor.sum(axis=1) * 1.0\n                gy += (- mu_p * Z * (dy * invd)).sum(axis=1) * 1.0  # note dy*(1/d) = (y_i - y_j)/d; derivative sign negative already included\n\n            # assemble gradient vector\n            grad = np.empty(3*n)\n            grad[0:n] = gx\n            grad[n:2*n] = gy\n            grad[2*n:3*n] = gr\n            return J, grad\n        return obj_and_grad\n\n    # Generate initial center configurations (3 variants)\n    inits = []\n    # Variant 1: hex-staggered rows with counts summing to 26: [6,5,5,5,5]\n    row_counts = [6,5,5,5,5]\n    total = sum(row_counts)\n    assert total == n\n    ys = np.linspace(0.1, 0.9, len(row_counts))\n    centers1 = []\n    for ir, cnt in enumerate(row_counts):\n        xstart = 0.1 if (ir % 2 == 0) else 0.1 + 0.05\n        xs = np.linspace(0.1, 0.9, cnt)\n        for xval in xs:\n            centers1.append((xval + (0.02 if (ir % 2 == 1) else 0.0), ys[ir]))\n    centers1 = np.array(centers1)[:n]\n    inits.append(centers1)\n\n    # Variant 2: square-ish grid 5x6 then remove extras\n    xs = np.linspace(0.08, 0.92, 6)\n    ys = np.linspace(0.08, 0.92, 5)\n    centers2 = []\n    for j in range(len(ys)):\n        for i_ in range(len(xs)):\n            centers2.append((xs[i_] + (0.01 if j % 2 else -0.01), ys[j]))\n    centers2 = np.array(centers2)[:n]\n    inits.append(centers2)\n\n    # Variant 3: jittered hex variant\n    centers3 = centers1 + 0.02 * (np.random.RandomState(1).randn(*centers1.shape))\n    centers3 = np.clip(centers3, 0.05, 0.95)\n    inits.append(centers3)\n\n    best_solution = None\n    best_sum = -1.0\n\n    # Annealing schedule for mu_b, mu_p\n    schedule = [(1e-3, 1e-3), (1e-2, 1e-2), (1e-1, 1e-1), (1.0, 1.0), (10.0, 10.0), (100.0, 100.0)]\n\n    for centers_init in inits:\n        # initial radii: from boundary distances * 0.9\n        x0 = centers_init[:,0].copy()\n        y0 = centers_init[:,1].copy()\n        dists_bound = np.minimum.reduce([x0, y0, 1-x0, 1-y0])\n        r0 = 0.9 * dists_bound\n        # Package variable vector\n        z0 = np.concatenate([x0, y0, r0])\n\n        bounds = []\n        # bounds for x\n        for _ in range(n):\n            bounds.append((0.0, 1.0))\n        for _ in range(n):\n            bounds.append((0.0, 1.0))\n        # bounds for r: 0 <= r <= 1.0 (unsafe large cap but ok)\n        for _ in range(n):\n            bounds.append((0.0, 1.0))\n\n        z_curr = z0.copy()\n        for (mu_b, mu_p) in schedule:\n            objg = make_obj(mu_b, mu_p)\n\n            def fun(z):\n                f, _ = objg(z)\n                return f\n\n            def jac(z):\n                _, g = objg(z)\n                return g\n\n            # run L-BFGS-B\n            res = minimize(fun, z_curr, method='L-BFGS-B', jac=jac, bounds=bounds,\n                           options={'maxiter': 200, 'ftol': 1e-9})\n            if res.success:\n                z_curr = res.x\n            else:\n                # accept current\n                z_curr = res.x if res.x is not None else z_curr\n\n        # Extract centers and radii\n        x_opt = z_curr[0:n].copy()\n        y_opt = z_curr[n:2*n].copy()\n        r_opt = z_curr[2*n:3*n].copy()\n        centers_opt = np.vstack([x_opt, y_opt]).T\n\n        # LP feasibilization: maximize sum r subject to 0<=r<=current_r and boundary/pairwise constraints\n        # linear program: minimize c^T r where c = -1 to maximize sum r\n        c = -np.ones(n)\n        # bounds for LP variables: (0, current_r)\n        lp_bounds = [(0.0, max(ri, 1e-12)) for ri in r_opt]\n\n        # A_ub and b_ub\n        A_ub = []\n        b_ub = []\n        # boundary constraints: r_i <= min_dist_bound_i\n        min_dists = np.minimum.reduce([x_opt, y_opt, 1-x_opt, 1-y_opt])\n        for i in range(n):\n            row = np.zeros(n)\n            row[i] = 1.0\n            A_ub.append(row)\n            b_ub.append(max(min_dists[i], 0.0))\n        # pairwise constraints r_i + r_j <= d_ij\n        dx = x_opt[:,None] - x_opt[None,:]\n        dy = y_opt[:,None] - y_opt[None,:]\n        dmat = np.sqrt(dx*dx + dy*dy)\n        iu = np.triu_indices(n, 1)\n        for (i, j) in zip(iu[0], iu[1]):\n            row = np.zeros(n)\n            row[i] = 1.0\n            row[j] = 1.0\n            A_ub.append(row)\n            b_ub.append(max(dmat[i, j], 0.0))\n\n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n\n        # solve LP\n        try:\n            lp_res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs', options={'tol':1e-9})\n        except Exception:\n            lp_res = None\n\n        if lp_res is not None and lp_res.success:\n            r_feas = np.maximum(lp_res.x, 0.0)\n        else:\n            # fallback: clip to min boundary distances and shrink globally to remove pairwise overlaps\n            r_feas = np.minimum(r_opt, min_dists)\n            # enforce pairwise by global scaling\n            dx = x_opt[:,None] - x_opt[None,:]\n            dy = y_opt[:,None] - y_opt[None,:]\n            dmat = np.sqrt(dx*dx + dy*dy)\n            iu = np.triu_indices(n, 1)\n            viol = r_feas[iu[0]] + r_feas[iu[1]] - dmat[iu]\n            if np.any(viol > tol):\n                ratios = np.ones_like(viol)\n                positive = (r_feas[iu[0]] + r_feas[iu[1]]) > 0\n                ratios[positive] = dmat[iu][positive] / (r_feas[iu[0]][positive] + r_feas[iu[1]][positive] + 1e-12)\n                scale = np.minimum(1.0, ratios.min()) * 0.999\n                r_feas = r_feas * scale\n            r_feas = np.maximum(r_feas, 0.0)\n\n        # final check and small global shrink if needed\n        centers_final = centers_opt.copy()\n        radii_final = r_feas.copy()\n\n        # enforce constraints if minor violations\n        # ensure inside boundaries\n        min_dists = np.minimum.reduce([centers_final[:,0], centers_final[:,1],\n                                       1-centers_final[:,0], 1-centers_final[:,1]])\n        if np.any(radii_final - min_dists > tol):\n            scales = min_dists / (radii_final + 1e-12)\n            scales[radii_final <= 0] = 1.0\n            global_scale = np.min(np.minimum(scales, 1.0))\n            radii_final *= global_scale * 0.999\n\n        # ensure pairwise\n        dx = centers_final[:,0][:,None] - centers_final[:,0][None,:]\n        dy = centers_final[:,1][:,None] - centers_final[:,1][None,:]\n        dmat = np.sqrt(dx*dx + dy*dy)\n        iu = np.triu_indices(n, 1)\n        viol_vals = radii_final[iu[0]] + radii_final[iu[1]] - dmat[iu]\n        if np.any(viol_vals > tol):\n            # global shrink\n            denom = (radii_final[iu[0]] + radii_final[iu[1]]) + 1e-12\n            ratios = dmat[iu] / denom\n            ratios = np.where(denom > 0, ratios, 1.0)\n            global_scale = np.min(np.minimum(ratios, 1.0))\n            radii_final *= global_scale * 0.999\n\n        # final feasibility clip\n        radii_final = np.maximum(radii_final, 0.0)\n\n        if not is_feasible(centers_final, radii_final, tol=1e-5):\n            # as a last resort, reduce radii a bit\n            radii_final *= 0.9\n\n        sum_r = radii_final.sum()\n        if sum_r > best_sum and is_feasible(centers_final, radii_final, tol=1e-6):\n            best_sum = float(sum_r)\n            best_solution = (centers_final.copy(), radii_final.copy(), float(sum_r))\n\n    # If no feasible found (unlikely), return simple trivial packing: 26 tiny circles\n    if best_solution is None:\n        centers = np.zeros((n,2))\n        radii = np.zeros(n)\n        # place them evenly with tiny radii\n        xs = np.linspace(0.02, 0.98, 6)\n        ys = np.linspace(0.02, 0.98, 5)\n        idx=0\n        for j in range(len(ys)):\n            for i_ in range(len(xs)):\n                if idx>=n: break\n                centers[idx,0] = xs[i_]\n                centers[idx,1] = ys[j]\n                radii[idx] = 0.005\n                idx+=1\n        best_solution = (centers, radii, float(radii.sum()))\n\n    return best_solution\n\n# If run as script, you could call construct_packing()",
  "metrics": {
    "valid": true,
    "score": 0.3403659167072929,
    "eval_time": 0.9508099555969238,
    "error": null
  },
  "prompt": "\nSingle Python code block only. Implement construct_packing() using numpy and scipy.\nDecision variables: x in R^{26x2}, r in R^{26}, bounded 0<=x<=1, r>=0.\nObjective: maximize sum r subject to constraints; we use a smooth penalty J(x,r) minimized by L-BFGS-B:\nJ = -sum r + mu_b * sum_i sum_{k in {x,y}} relu(r_i - b_{ik})^2 + mu_p * sum_{i<j} relu(r_i + r_j - d_ij)^2\nwhere b_{ix}=x_i, b_{iy}=y_i, b_{i(1-x)}=1-x_i, b_{i(1-y)}=1-y_i, and include all four boundaries in the boundary penalty. Use annealing schedule for mu_b, mu_p: start small, increase.\nGradients:\n- d(-sum r)/dr = -1\n- For relu(z)^2: grad = 2*relu(z)*dz with hinge mask; dz for boundary is +/-1 on x,y; for pairwise is 1 wrt r_i/r_j and - (C_i-C_j)/d_ij wrt centers.\nStabilize divisions by d_ij+eps only in denominators.\nProcedure:\n- Initialize centers from structured grids (2-3 variants) and r from min boundary distances * 0.9.\n- Run L-BFGS-B with bounds: 0<=x<=1, 0<=y<=1, r>=0.\n- After annealing stages, run LP feasibilization: maximize sum r subject to 0<=r<=current r and boundary/pairwise constraints. This guarantees strict feasibility and non-overlap.\n- Return best feasible (centers, radii, sum_radii).\nNo prints.\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct packing of 26 non-overlapping circles in unit square.\n    Returns: (centers, radii, sum_radii)\n    centers: np.array shape (26,2)\n    radii: np.array shape (26,)\n    sum_radii: float\n    \"\"\"\n    np.random.seed(0)\n    n = 26\n    eps = 1e-8\n    tol = 1e-6\n\n    # Helper: check feasibility\n    def is_feasible(centers, radii, tol=1e-6):\n        if np.any(radii < -1e-12):\n            return False\n        if np.any(centers < -1e-12) or np.any(centers > 1 + 1e-12):\n            return False\n        # boundary\n        x = centers[:,0]; y = centers[:,1]\n        dists = np.vstack([x, y, 1 - x, 1 - y]).min(axis=0)\n        if np.any(radii - dists > tol):\n            return False\n        # pairwise\n        dx = x[:,None] - x[None,:]\n        dy = y[:,None] - y[None,:]\n        dmat = np.sqrt(dx*dx + dy*dy)\n        iu = np.triu_indices(n, 1)\n        if np.any(radii[iu[0]] + radii[iu[1]] - dmat[iu] > tol):\n            return False\n        return True\n\n    # Objective and gradient factory\n    def make_obj(mu_b, mu_p):\n        def obj_and_grad(z):\n            # z: flattened [x0..x25, y0..y25, r0..r25]\n            x = z[0:n]\n            y = z[n:2*n]\n            r = z[2*n:3*n]\n            # Compute objective J = -sum r + mu_b * boundary_pen + mu_p * pairwise_pen\n            J = -r.sum()\n            # boundary\n            dx_left = x\n            dx_right = 1.0 - x\n            dy_bottom = y\n            dy_top = 1.0 - y\n            # z = r - dist\n            z_left = r - dx_left\n            z_right = r - dx_right\n            z_bottom = r - dy_bottom\n            z_top = r - dy_top\n            # relu\n            rl = np.maximum(z_left, 0.0)\n            rr = np.maximum(z_right, 0.0)\n            rb = np.maximum(z_bottom, 0.0)\n            rt = np.maximum(z_top, 0.0)\n            boundary_pen = (rl*rl + rr*rr + rb*rb + rt*rt).sum()\n            J += mu_b * boundary_pen\n            # pairwise\n            dx = x[:,None] - x[None,:]\n            dy = y[:,None] - y[None,:]\n            dmat = np.sqrt(dx*dx + dy*dy + eps)\n            # mask upper triangle excluding diagonal, but we'll compute full matrix and zero diag\n            zpair = (r[:,None] + r[None,:] - dmat)\n            # zero diagonal\n            np.fill_diagonal(zpair, 0.0)\n            rp = np.maximum(zpair, 0.0)\n            pair_pen = (rp*rp).sum() * 0.5  # since each pair counted twice in full matrix\n            # but easier: sum over i<j = 0.5 * sum over all i!=j\n            J += mu_p * pair_pen\n\n            # Gradients\n            gx = np.zeros_like(x)\n            gy = np.zeros_like(y)\n            gr = np.zeros_like(r)\n\n            # gradient from -sum r\n            gr += -1.0\n\n            # boundary grads\n            # derivative of relu(z)^2 is 2*relu(z)*dz\n            # for left: dz/dr = 1, dz/dx = -1\n            mask = rl > 0\n            if np.any(mask):\n                v = 2.0 * rl[mask] * mu_b\n                gr[mask] += v\n                gx[mask] += -v\n            # right: dz/dr =1, dz/dx = +1\n            mask = rr > 0\n            if np.any(mask):\n                v = 2.0 * rr[mask] * mu_b\n                gr[mask] += v\n                gx[mask] += v\n            # bottom: dz/dr =1, dz/dy = -1\n            mask = rb > 0\n            if np.any(mask):\n                v = 2.0 * rb[mask] * mu_b\n                gr[mask] += v\n                gy[mask] += -v\n            # top: dz/dr =1, dz/dy = +1\n            mask = rt > 0\n            if np.any(mask):\n                v = 2.0 * rt[mask] * mu_b\n                gr[mask] += v\n                gy[mask] += v\n\n            # pairwise grads\n            # For full matrix, each pair counted twice; we handle full then multiply by mu_p/1 because pair_pen included 0.5 factor\n            # rp is full matrix nonnegative with zeros on diagonal\n            if np.any(rp > 0):\n                Z = rp  # shape n x n\n                # dr contribution: for each i sum_j 2*mu_p*0.5*Z_ij * (dz/dr_i) where dz/dr_i = 1\n                # But since we used pair_pen = 0.5*sum(Z^2), derivative factor is mu_p * (Z) (not doubled)\n                # Let's compute consistent: derivative of mu_p * 0.5 * sum(Z^2) wrt r_i:\n                # d/d r_i = mu_p * sum_j Z_ij * dZ_ij/dr_i * 0.5*2? Simpler compute directly elementwise:\n                # For i != j, contribution to objective is mu_p * 0.5 * Z_ij^2. d/d r_i of Z_ij = 1, so d = mu_p * 0.5 * 2 * Z_ij * 1 = mu_p * Z_ij.\n                # But note Z_ij and Z_ji both present; for dr_i sum over j mu_p * Z_ij. So dr += mu_p * Z.sum(axis=1)\n                dr_pair = mu_p * Z.sum(axis=1)\n                gr += dr_pair\n\n                # For x,y grads: derivative of Z_ij wrt x_i is - (x_i - x_j)/d_ij\n                # contribution to grad from pair penalty: for each (i,j) mu_p * Z_ij * dZ_ij/dx_i\n                # Thus gx_i += mu_p * sum_j Z_ij * ( - (x_i - x_j)/d_ij )\n                invd = 1.0 / dmat\n                # avoid diagonal\n                invd[np.diag_indices(n)] = 0.0\n                factor = - mu_p * Z * invd  # shape n x n\n                gx += factor.sum(axis=1) * 1.0\n                gy += (- mu_p * Z * (dy * invd)).sum(axis=1) * 1.0  # note dy*(1/d) = (y_i - y_j)/d; derivative sign negative already included\n\n            # assemble gradient vector\n            grad = np.empty(3*n)\n            grad[0:n] = gx\n            grad[n:2*n] = gy\n            grad[2*n:3*n] = gr\n            return J, grad\n        return obj_and_grad\n\n    # Generate initial center configurations (3 variants)\n    inits = []\n    # Variant 1: hex-staggered rows with counts summing to 26: [6,5,5,5,5]\n    row_counts = [6,5,5,5,5]\n    total = sum(row_counts)\n    assert total == n\n    ys = np.linspace(0.1, 0.9, len(row_counts))\n    centers1 = []\n    for ir, cnt in enumerate(row_counts):\n        xstart = 0.1 if (ir % 2 == 0) else 0.1 + 0.05\n        xs = np.linspace(0.1, 0.9, cnt)\n        for xval in xs:\n            centers1.append((xval + (0.02 if (ir % 2 == 1) else 0.0), ys[ir]))\n    centers1 = np.array(centers1)[:n]\n    inits.append(centers1)\n\n    # Variant 2: square-ish grid 5x6 then remove extras\n    xs = np.linspace(0.08, 0.92, 6)\n    ys = np.linspace(0.08, 0.92, 5)\n    centers2 = []\n    for j in range(len(ys)):\n        for i_ in range(len(xs)):\n            centers2.append((xs[i_] + (0.01 if j % 2 else -0.01), ys[j]))\n    centers2 = np.array(centers2)[:n]\n    inits.append(centers2)\n\n    # Variant 3: jittered hex variant\n    centers3 = centers1 + 0.02 * (np.random.RandomState(1).randn(*centers1.shape))\n    centers3 = np.clip(centers3, 0.05, 0.95)\n    inits.append(centers3)\n\n    best_solution = None\n    best_sum = -1.0\n\n    # Annealing schedule for mu_b, mu_p\n    schedule = [(1e-3, 1e-3), (1e-2, 1e-2), (1e-1, 1e-1), (1.0, 1.0), (10.0, 10.0), (100.0, 100.0)]\n\n    for centers_init in inits:\n        # initial radii: from boundary distances * 0.9\n        x0 = centers_init[:,0].copy()\n        y0 = centers_init[:,1].copy()\n        dists_bound = np.minimum.reduce([x0, y0, 1-x0, 1-y0])\n        r0 = 0.9 * dists_bound\n        # Package variable vector\n        z0 = np.concatenate([x0, y0, r0])\n\n        bounds = []\n        # bounds for x\n        for _ in range(n):\n            bounds.append((0.0, 1.0))\n        for _ in range(n):\n            bounds.append((0.0, 1.0))\n        # bounds for r: 0 <= r <= 1.0 (unsafe large cap but ok)\n        for _ in range(n):\n            bounds.append((0.0, 1.0))\n\n        z_curr = z0.copy()\n        for (mu_b, mu_p) in schedule:\n            objg = make_obj(mu_b, mu_p)\n\n            def fun(z):\n                f, _ = objg(z)\n                return f\n\n            def jac(z):\n                _, g = objg(z)\n                return g\n\n            # run L-BFGS-B\n            res = minimize(fun, z_curr, method='L-BFGS-B', jac=jac, bounds=bounds,\n                           options={'maxiter': 200, 'ftol': 1e-9})\n            if res.success:\n                z_curr = res.x\n            else:\n                # accept current\n                z_curr = res.x if res.x is not None else z_curr\n\n        # Extract centers and radii\n        x_opt = z_curr[0:n].copy()\n        y_opt = z_curr[n:2*n].copy()\n        r_opt = z_curr[2*n:3*n].copy()\n        centers_opt = np.vstack([x_opt, y_opt]).T\n\n        # LP feasibilization: maximize sum r subject to 0<=r<=current_r and boundary/pairwise constraints\n        # linear program: minimize c^T r where c = -1 to maximize sum r\n        c = -np.ones(n)\n        # bounds for LP variables: (0, current_r)\n        lp_bounds = [(0.0, max(ri, 1e-12)) for ri in r_opt]\n\n        # A_ub and b_ub\n        A_ub = []\n        b_ub = []\n        # boundary constraints: r_i <= min_dist_bound_i\n        min_dists = np.minimum.reduce([x_opt, y_opt, 1-x_opt, 1-y_opt])\n        for i in range(n):\n            row = np.zeros(n)\n            row[i] = 1.0\n            A_ub.append(row)\n            b_ub.append(max(min_dists[i], 0.0))\n        # pairwise constraints r_i + r_j <= d_ij\n        dx = x_opt[:,None] - x_opt[None,:]\n        dy = y_opt[:,None] - y_opt[None,:]\n        dmat = np.sqrt(dx*dx + dy*dy)\n        iu = np.triu_indices(n, 1)\n        for (i, j) in zip(iu[0], iu[1]):\n            row = np.zeros(n)\n            row[i] = 1.0\n            row[j] = 1.0\n            A_ub.append(row)\n            b_ub.append(max(dmat[i, j], 0.0))\n\n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n\n        # solve LP\n        try:\n            lp_res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=lp_bounds, method='highs', options={'tol':1e-9})\n        except Exception:\n            lp_res = None\n\n        if lp_res is not None and lp_res.success:\n            r_feas = np.maximum(lp_res.x, 0.0)\n        else:\n            # fallback: clip to min boundary distances and shrink globally to remove pairwise overlaps\n            r_feas = np.minimum(r_opt, min_dists)\n            # enforce pairwise by global scaling\n            dx = x_opt[:,None] - x_opt[None,:]\n            dy = y_opt[:,None] - y_opt[None,:]\n            dmat = np.sqrt(dx*dx + dy*dy)\n            iu = np.triu_indices(n, 1)\n            viol = r_feas[iu[0]] + r_feas[iu[1]] - dmat[iu]\n            if np.any(viol > tol):\n                ratios = np.ones_like(viol)\n                positive = (r_feas[iu[0]] + r_feas[iu[1]]) > 0\n                ratios[positive] = dmat[iu][positive] / (r_feas[iu[0]][positive] + r_feas[iu[1]][positive] + 1e-12)\n                scale = np.minimum(1.0, ratios.min()) * 0.999\n                r_feas = r_feas * scale\n            r_feas = np.maximum(r_feas, 0.0)\n\n        # final check and small global shrink if needed\n        centers_final = centers_opt.copy()\n        radii_final = r_feas.copy()\n\n        # enforce constraints if minor violations\n        # ensure inside boundaries\n        min_dists = np.minimum.reduce([centers_final[:,0], centers_final[:,1],\n                                       1-centers_final[:,0], 1-centers_final[:,1]])\n        if np.any(radii_final - min_dists > tol):\n            scales = min_dists / (radii_final + 1e-12)\n            scales[radii_final <= 0] = 1.0\n            global_scale = np.min(np.minimum(scales, 1.0))\n            radii_final *= global_scale * 0.999\n\n        # ensure pairwise\n        dx = centers_final[:,0][:,None] - centers_final[:,0][None,:]\n        dy = centers_final[:,1][:,None] - centers_final[:,1][None,:]\n        dmat = np.sqrt(dx*dx + dy*dy)\n        iu = np.triu_indices(n, 1)\n        viol_vals = radii_final[iu[0]] + radii_final[iu[1]] - dmat[iu]\n        if np.any(viol_vals > tol):\n            # global shrink\n            denom = (radii_final[iu[0]] + radii_final[iu[1]]) + 1e-12\n            ratios = dmat[iu] / denom\n            ratios = np.where(denom > 0, ratios, 1.0)\n            global_scale = np.min(np.minimum(ratios, 1.0))\n            radii_final *= global_scale * 0.999\n\n        # final feasibility clip\n        radii_final = np.maximum(radii_final, 0.0)\n\n        if not is_feasible(centers_final, radii_final, tol=1e-5):\n            # as a last resort, reduce radii a bit\n            radii_final *= 0.9\n\n        sum_r = radii_final.sum()\n        if sum_r > best_sum and is_feasible(centers_final, radii_final, tol=1e-6):\n            best_sum = float(sum_r)\n            best_solution = (centers_final.copy(), radii_final.copy(), float(sum_r))\n\n    # If no feasible found (unlikely), return simple trivial packing: 26 tiny circles\n    if best_solution is None:\n        centers = np.zeros((n,2))\n        radii = np.zeros(n)\n        # place them evenly with tiny radii\n        xs = np.linspace(0.02, 0.98, 6)\n        ys = np.linspace(0.02, 0.98, 5)\n        idx=0\n        for j in range(len(ys)):\n            for i_ in range(len(xs)):\n                if idx>=n: break\n                centers[idx,0] = xs[i_]\n                centers[idx,1] = ys[j]\n                radii[idx] = 0.005\n                idx+=1\n        best_solution = (centers, radii, float(radii.sum()))\n\n    return best_solution\n\n# If run as script, you could call construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T01:16:27.358621",
  "cost_data": null,
  "model_config": {
    "model": "openai/gpt-5-mini",
    "temperature": 0.35
  },
  "llm_call_duration_s": 106.27169816300739,
  "eval_duration_s": 0.9508156729862094
}