{
  "trial_id": "trial_17_7",
  "generation": 17,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\nfrom scipy.spatial.distance import pdist, squareform\n\n# Global constants\nN_CIRCLES = 26\nEPS = 1e-9  # For numerical stability in divisions/sqrt\nLP_MARGIN = 1e-6 # Strict margin for LP constraints\nVERIFY_SLACK = 1e-12 # Additional slack for verification in feasibility check\nMAX_SHRINK_ATTEMPTS = 5 # Max attempts to shrink radii for strict feasibility\nSHRINK_FACTOR = 1 - 2e-7 # Factor to shrink radii if verification fails\n\n# Set a deterministic seed for reproducibility\nnp.random.seed(42)\n\ndef calculate_distances(centers):\n    \"\"\"\n    Calculates pairwise Euclidean distances and squared distances between centers.\n    \n    Args:\n        centers (np.ndarray): An (N, 2) array of circle center coordinates.\n        \n    Returns:\n        tuple: A tuple containing:\n            - dist_matrix (np.ndarray): An (N, N) matrix of pairwise distances.\n            - dist_sq_matrix (np.ndarray): An (N, N) matrix of pairwise squared distances.\n    \"\"\"\n    if centers.shape[0] < 2:\n        return np.array([[0.0]]), np.array([[0.0]])\n    dist_sq_matrix = squareform(pdist(centers, 'sqeuclidean'))\n    dist_matrix = np.sqrt(dist_sq_matrix)\n    return dist_matrix, dist_sq_matrix\n\ndef solve_lp(centers, current_radii_caps=None):\n    \"\"\"\n    Solves a Linear Program to find maximum radii for given centers.\n    Maximizes sum(r_i) subject to non-overlap and boundary constraints.\n    \n    Args:\n        centers (np.ndarray): An (N, 2) array of circle center coordinates.\n        current_radii_caps (np.ndarray, optional): An (N,) array of upper bounds\n            for each radius. If None, no upper bound is applied other than geometric.\n            \n    Returns:\n        tuple: A tuple containing:\n            - radii (np.ndarray): An (N,) array of optimized radii.\n            - sum_radii (float): The sum of the optimized radii.\n    \"\"\"\n    n = centers.shape[0]\n    c = -np.ones(n)  # Objective: maximize sum(r_i) -> minimize -sum(r_i)\n\n    A_ub = []\n    b_ub = []\n\n    # Wall constraints: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    for i in range(n):\n        row_i = np.zeros(n)\n        row_i[i] = 1.0\n        \n        A_ub.append(row_i)\n        b_ub.append(centers[i, 0]) # r_i <= x_i\n        \n        A_ub.append(row_i)\n        b_ub.append(centers[i, 1]) # r_i <= y_i\n        \n        A_ub.append(row_i)\n        b_ub.append(1.0 - centers[i, 0]) # r_i <= 1-x_i\n        \n        A_ub.append(row_i)\n        b_ub.append(1.0 - centers[i, 1]) # r_i <= 1-y_i\n\n    # Pairwise overlap constraints: r_i + r_j <= ||c_i - c_j|| - LP_MARGIN\n    dist_matrix, _ = calculate_distances(centers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            row_ij = np.zeros(n)\n            row_ij[i] = 1.0\n            row_ij[j] = 1.0\n            A_ub.append(row_ij)\n            b_ub.append(dist_matrix[i, j] - LP_MARGIN)\n\n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n\n    # Bounds for radii: r_i >= 0. If current_radii_caps are provided, r_i <= cap.\n    if current_radii_caps is not None:\n        bounds = [(0, cap) for cap in current_radii_caps]\n    else:\n        bounds = [(0, None)] * n\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        return res.x, -res.fun\n    else:\n        # If LP fails due to infeasibility, try relaxing the margin to 0 for a retry.\n        # This can help find a solution if the margin was too aggressive.\n        if res.status == 2 and LP_MARGIN > 0: # Infeasible\n            A_ub_retry = []\n            b_ub_retry = []\n            # Re-add wall constraints (unchanged)\n            for i in range(n):\n                row_i = np.zeros(n)\n                row_i[i] = 1.0\n                A_ub_retry.append(row_i)\n                b_ub_retry.append(centers[i, 0])\n                A_ub_retry.append(row_i)\n                b_ub_retry.append(centers[i, 1])\n                A_ub_retry.append(row_i)\n                b_ub_retry.append(1.0 - centers[i, 0])\n                A_ub_retry.append(row_i)\n                b_ub_retry.append(1.0 - centers[i, 1])\n            # Re-add pairwise constraints with 0 margin\n            for i in range(n):\n                for j in range(i + 1, n):\n                    row_ij = np.zeros(n)\n                    row_ij[i] = 1.0\n                    row_ij[j] = 1.0\n                    A_ub_retry.append(row_ij)\n                    b_ub_retry.append(dist_matrix[i, j]) # No margin\n            \n            res_retry = linprog(c, A_ub=np.array(A_ub_retry), b_ub=np.array(b_ub_retry), bounds=bounds, method='highs')\n            if res_retry.success:\n                return res_retry.x, -res_retry.fun\n        \n        return np.zeros(n), 0.0\n\ndef verify_solution(centers, radii):\n    \"\"\"\n    Verifies if a solution (centers, radii) is strictly feasible.\n    Shrinks radii slightly if numerical violations are found and retries.\n    \n    Args:\n        centers (np.ndarray): An (N, 2) array of circle center coordinates.\n        radii (np.ndarray): An (N,) array of circle radii.\n        \n    Returns:\n        tuple: A tuple containing:\n            - is_feasible (bool): True if the solution is strictly feasible, False otherwise.\n            - verified_radii (np.ndarray): The radii array, potentially shrunk to ensure feasibility.\n    \"\"\"\n    current_radii = np.copy(radii)\n    \n    for attempt in range(MAX_SHRINK_ATTEMPTS):\n        is_feasible = True\n        \n        # 1. Radii must be non-negative\n        if np.any(current_radii < 0):\n            is_feasible = False\n        \n        # 2. Centers must be within [0,1]\n        if np.any(centers < 0 - EPS) or np.any(centers > 1 + EPS):\n            is_feasible = False\n\n        # 3. Circles must be entirely within unit square\n        if np.any(centers[:, 0] - current_radii < 0 - LP_MARGIN - VERIFY_SLACK) or \\\n           np.any(centers[:, 0] + current_radii > 1 + LP_MARGIN + VERIFY_SLACK) or \\\n           np.any(centers[:, 1] - current_radii < 0 - LP_MARGIN - VERIFY_SLACK) or \\\n           np.any(centers[:, 1] + current_radii > 1 + LP_MARGIN + VERIFY_SLACK):\n            is_feasible = False\n\n        # 4. No overlap between circles\n        dist_matrix, _ = calculate_distances(centers)\n        for i in range(N_CIRCLES):\n            for j in range(i + 1, N_CIRCLES):\n                if current_radii[i] + current_radii[j] > dist_matrix[i, j] - LP_MARGIN - VERIFY_SLACK:\n                    is_feasible = False\n                    break\n            if not is_feasible:\n                break\n        \n        if is_feasible:\n            return True, current_radii\n        else:\n            current_radii *= SHRINK_FACTOR # Shrink radii and retry\n    \n    return False, current_radii # Failed to achieve feasibility after max attempts\n\ndef generate_seeds():\n    \"\"\"\n    Generates a diverse set of initial center configurations (seeds).\n    \n    Returns:\n        list: A list of np.ndarray, where each array is an (N_CIRCLES, 2)\n              center configuration.\n    \"\"\"\n    seeds = []\n\n    # Helper to ensure N_CIRCLES points from a larger grid\n    def get_n_points_from_grid(grid_points, jitter_amount):\n        if len(grid_points) > N_CIRCLES:\n            centers = grid_points[np.random.choice(len(grid_points), N_CIRCLES, replace=False)]\n        elif len(grid_points) < N_CIRCLES:\n            extra_points = N_CIRCLES - len(grid_points)\n            centers = np.vstack([grid_points, np.random.uniform(0, 1, size=(extra_points, 2))])\n        else:\n            centers = grid_points\n        \n        centers += np.random.uniform(-jitter_amount, jitter_amount, size=centers.shape)\n        return np.clip(centers, 0, 1)\n\n    # 1. Uniform grid with jitter (5 seeds)\n    for _ in range(5):\n        grid_size = int(np.sqrt(N_CIRCLES)) + 1 \n        x_coords = np.linspace(0.05, 0.95, grid_size)\n        y_coords = np.linspace(0.05, 0.95, grid_size)\n        \n        grid_points = []\n        for x in x_coords:\n            for y in y_coords:\n                grid_points.append([x, y])\n        \n        seeds.append(get_n_points_from_grid(np.array(grid_points), np.random.uniform(0.01, 0.05)))\n\n    # 2. Hexagonal grid with jitter (5 seeds)\n    for _ in range(5):\n        grid_points = []\n        rows = int(np.sqrt(N_CIRCLES * 4 / (3 * np.sqrt(3)))) + 1\n        cols = int(N_CIRCLES / rows) + 2\n        \n        x_step = 1.0 / (cols - 1)\n        y_step = np.sqrt(3) / 2 * x_step\n\n        for r in range(rows):\n            for c in range(cols):\n                x = c * x_step\n                y = r * y_step\n                if r % 2 == 1:\n                    x += x_step / 2\n                grid_points.append([x, y])\n        \n        grid_points = np.array(grid_points)\n        # Scale to [0,1]\n        grid_points[:,0] = (grid_points[:,0] - grid_points[:,0].min()) / (grid_points[:,0].max() - grid_points[:,0].min() + EPS)\n        grid_points[:,1] = (grid_points[:,1] - grid_points[:,1].min()) / (grid_points[:,1].max() - grid_points[:,1].min() + EPS)\n        \n        seeds.append(get_n_points_from_grid(grid_points, np.random.uniform(0.01, 0.05)))\n\n    # 3. Edge-biased (5 seeds)\n    for _ in range(5):\n        centers = np.random.beta(0.5, 0.5, size=(N_CIRCLES, 2)) # Biased towards 0 and 1\n        jitter = np.random.uniform(0.01, 0.03)\n        centers += np.random.uniform(-jitter, jitter, size=centers.shape)\n        seeds.append(np.clip(centers, 0, 1))\n\n    # 4. Corner-biased (5 seeds)\n    for _ in range(5):\n        centers = np.random.rand(N_CIRCLES, 2)**np.random.uniform(2, 5) # Biased towards (0,0)\n        # Randomly flip to other corners\n        centers[np.random.rand(N_CIRCLES) > 0.5, 0] = 1 - centers[np.random.rand(N_CIRCLES) > 0.5, 0]\n        centers[np.random.rand(N_CIRCLES) > 0.5, 1] = 1 - centers[np.random.rand(N_CIRCLES) > 0.5, 1]\n        jitter = np.random.uniform(0.01, 0.03)\n        centers += np.random.uniform(-jitter, jitter, size=centers.shape)\n        seeds.append(np.clip(centers, 0, 1))\n        \n    # 5. Random uniform (5 seeds)\n    for _ in range(5):\n        centers = np.random.uniform(0, 1, size=(N_CIRCLES, 2))\n        seeds.append(centers)\n\n    return seeds\n\ndef shake_centers(initial_centers):\n    \"\"\"\n    Iteratively nudges centers away from near neighbors and walls.\n    Uses a heuristic for provisional radii to estimate overlap pressure.\n    \n    Args:\n        initial_centers (np.ndarray): An (N, 2) array of initial center coordinates.\n        \n    Returns:\n        np.ndarray: An (N, 2) array of shaken center coordinates.\n    \"\"\"\n    centers = initial_centers.copy()\n    max_iter = 300\n    initial_step_size = 0.01\n    wall_repulsion_strength = 10.0\n    overlap_repulsion_strength = 0.5\n\n    for iter_idx in range(max_iter):\n        step_size = initial_step_size * (1 - iter_idx / max_iter)\n        \n        dist_matrix, _ = calculate_distances(centers)\n        \n        # Provisional radii heuristic: min of wall distance and half nearest neighbor distance\n        r_provisional = np.zeros(N_CIRCLES)\n        for i in range(N_CIRCLES):\n            wall_dists = np.array([centers[i,0], centers[i,1], 1-centers[i,0], 1-centers[i,1]])\n            r_provisional[i] = np.min(wall_dists)\n            \n            dists_to_others = dist_matrix[i, np.arange(N_CIRCLES) != i]\n            if len(dists_to_others) > 0:\n                r_provisional[i] = np.min([r_provisional[i], np.min(dists_to_others) / 2.0])\n        \n        forces = np.zeros_like(centers)\n\n        for i in range(N_CIRCLES):\n            # Wall repulsion\n            forces[i,0] += np.maximum(0, r_provisional[i] - centers[i,0]) * wall_repulsion_strength\n            forces[i,0] -= np.maximum(0, r_provisional[i] - (1 - centers[i,0])) * wall_repulsion_strength\n            forces[i,1] += np.maximum(0, r_provisional[i] - centers[i,1]) * wall_repulsion_strength\n            forces[i,1] -= np.maximum(0, r_provisional[i] - (1 - centers[i,1])) * wall_repulsion_strength\n\n            # Overlap repulsion\n            for j in range(i + 1, N_CIRCLES):\n                d_ij = dist_matrix[i, j]\n                overlap = r_provisional[i] + r_provisional[j] - d_ij\n                \n                if overlap > 0:\n                    direction = (centers[i] - centers[j]) / (d_ij + EPS)\n                    force_magnitude = overlap * overlap_repulsion_strength\n                    forces[i] += direction * force_magnitude\n                    forces[j] -= direction * force_magnitude\n        \n        centers += forces * step_size\n        centers = np.clip(centers, 0, 1) # Keep centers within bounds\n    \n    return centers\n\ndef polish_centers_radii(initial_centers, initial_radii):\n    \"\"\"\n    Optimizes centers and radii simultaneously using L-BFGS-B with a penalty function.\n    \n    Args:\n        initial_centers (np.ndarray): An (N, 2) array of initial center coordinates.\n        initial_radii (np.ndarray): An (N,) array of initial radii.\n        \n    Returns:\n        tuple: A tuple containing:\n            - polished_centers (np.ndarray): An (N, 2) array of optimized center coordinates.\n            - polished_radii (np.ndarray): An (N,) array of optimized radii.\n    \"\"\"\n    n = N_CIRCLES\n    \n    # Initial guess: flatten centers and radii\n    x0 = np.concatenate((initial_centers.flatten(), initial_radii))\n\n    # Bounds for L-BFGS-B\n    center_bounds = [(0, 1)] * (2 * n)\n    radius_bounds = [(0, None)] * n # Radii must be non-negative, upper bound handled by penalty\n    bounds = center_bounds + radius_bounds\n\n    def objective(x, rho):\n        \"\"\"Objective function for L-BFGS-B: -sum(radii) + rho * (boundary_penalty + overlap_penalty)\"\"\"\n        centers_flat = x[:2*n]\n        radii = x[2*n:]\n        centers = centers_flat.reshape(n, 2)\n\n        cost = -np.sum(radii) # Maximize sum of radii -> minimize negative sum\n\n        # Boundary penalty: penalize if r_i makes circle go out of bounds\n        boundary_penalty = 0.0\n        for i in range(n):\n            boundary_penalty += np.sum(np.maximum(0, radii[i] - centers[i])**2) # r_i > x_i or r_i > y_i\n            boundary_penalty += np.sum(np.maximum(0, radii[i] - (1 - centers[i]))**2) # r_i > 1-x_i or r_i > 1-y_i\n        \n        # Overlap penalty: penalize if r_i + r_j > d_ij\n        overlap_penalty = 0.0\n        dist_sq_matrix = calculate_distances(centers)[1]\n        for i in range(n):\n            for j in range(i + 1, n):\n                d_ij_sq = dist_sq_matrix[i, j]\n                d_ij_safe = np.sqrt(d_ij_sq + EPS) # Stabilize distance for gradient\n                overlap = radii[i] + radii[j] - d_ij_safe\n                overlap_penalty += np.maximum(0, overlap)**2\n        \n        return cost + rho * (boundary_penalty + overlap_penalty)\n\n    def gradient(x, rho):\n        \"\"\"Gradient function for L-BFGS-B.\"\"\"\n        centers_flat = x[:2*n]\n        radii = x[2*n:]\n        centers = centers_flat.reshape(n, 2)\n\n        grad_centers = np.zeros_like(centers)\n        grad_radii = np.zeros_like(radii)\n\n        grad_radii -= 1.0 # Gradient from -sum(radii)\n\n        # Boundary penalty gradients\n        for i in range(n):\n            for dim in range(2):\n                # Gradient for (r_i - c_i[dim])^2\n                val = radii[i] - centers[i, dim]\n                if val > 0:\n                    grad_radii[i] += rho * 2 * val\n                    grad_centers[i, dim] -= rho * 2 * val\n                \n                # Gradient for (r_i - (1 - c_i[dim]))^2\n                val = radii[i] - (1 - centers[i, dim])\n                if val > 0:\n                    grad_radii[i] += rho * 2 * val\n                    grad_centers[i, dim] += rho * 2 * val\n        \n        # Overlap penalty gradients\n        dist_sq_matrix = calculate_distances(centers)[1]\n        for i in range(n):\n            for j in range(i + 1, n):\n                d_ij_sq = dist_sq_matrix[i, j]\n                d_ij_safe = np.sqrt(d_ij_sq + EPS)\n                overlap = radii[i] + radii[j] - d_ij_safe\n                \n                if overlap > 0:\n                    grad_val = rho * 2 * overlap\n                    grad_radii[i] += grad_val\n                    grad_radii[j] += grad_val\n\n                    # Chain rule for d_overlap / d_d_ij_safe = -1\n                    # Chain rule for d_d_ij_safe / d_d_ij_sq = 0.5 / d_ij_safe\n                    grad_d_ij_sq = (-grad_val) * 0.5 / d_ij_safe\n                    \n                    # Chain rule for d_d_ij_sq / d_c_k = 2 * (c_k - c_l)\n                    diff_c = centers[i] - centers[j]\n                    grad_centers[i] += grad_d_ij_sq * 2 * diff_c\n                    grad_centers[j] -= grad_d_ij_sq * 2 * diff_c\n        \n        return np.concatenate((grad_centers.flatten(), grad_radii))\n\n    # Annealing rho to gradually increase penalty for violations\n    rhos = [1.0, 10.0, 100.0, 200.0]\n    current_x = x0\n\n    for rho_val in rhos:\n        res = minimize(objective, current_x, args=(rho_val,), method='L-BFGS-B', jac=gradient, bounds=bounds, options={'maxiter': 100, 'ftol': 1e-7, 'gtol': 1e-5})\n        current_x = res.x\n        # If optimization fails for a given rho, continue with the last valid x\n        if not res.success:\n            break\n\n    polished_centers = current_x[:2*n].reshape(n, 2)\n    polished_radii = current_x[2*n:]\n    \n    # Ensure radii are non-negative after polish\n    polished_radii = np.maximum(0, polished_radii)\n\n    return polished_centers, polished_radii\n\ndef construct_packing():\n    \"\"\"\n    Main function to construct the circle packing.\n    \n    Returns:\n        tuple: A tuple containing:\n            - centers (np.ndarray): An (N_CIRCLES, 2) array of optimized center coordinates.\n            - radii (np.ndarray): An (N_CIRCLES,) array of optimized radii.\n            - sum_radii (float): The sum of the optimized radii.\n    \"\"\"\n    best_sum_radii = 0.0\n    best_centers = np.zeros((N_CIRCLES, 2), dtype=np.float64)\n    best_radii = np.zeros(N_CIRCLES, dtype=np.float64)\n\n    all_seeds = generate_seeds()\n    \n    candidate_solutions = [] # Stores (sum_radii, centers, radii) after shaking and initial LP\n\n    # Phase 1: Generate diverse seeds, shake them, and run initial LP\n    for seed_centers in all_seeds:\n        shaken_centers = shake_centers(seed_centers)\n        \n        radii_lp, current_sum_radii = solve_lp(shaken_centers)\n        \n        if current_sum_radii > 0 and np.all(radii_lp >= 0):\n            candidate_solutions.append((current_sum_radii, shaken_centers, radii_lp))\n    \n    # Sort candidates by sum_radii (descending)\n    candidate_solutions.sort(key=lambda x: x[0], reverse=True)\n\n    # Phase 2: Polish top candidates with L-BFGS-B and re-evaluate with LP\n    num_to_polish = min(len(candidate_solutions), 3) # Polish top 3 candidates\n\n    for i in range(num_to_polish):\n        _, initial_centers, initial_radii = candidate_solutions[i]\n        \n        polished_centers, polished_radii_from_polish = polish_centers_radii(initial_centers, initial_radii)\n        \n        # After polishing, run a final LP to ensure strict feasibility and get optimal radii\n        final_radii, final_sum_radii = solve_lp(polished_centers)\n        \n        # Verify strict feasibility and update best solution\n        is_feasible, verified_radii = verify_solution(polished_centers, final_radii)\n        \n        if is_feasible:\n            if final_sum_radii > best_sum_radii:\n                best_sum_radii = final_sum_radii\n                best_centers = polished_centers\n                best_radii = verified_radii\n        else:\n            # If LP solution is not strictly feasible after verification, use the verified (shrunk) radii\n            # and check if its sum is better.\n            shrunk_sum_radii = np.sum(verified_radii)\n            if shrunk_sum_radii > best_sum_radii:\n                best_sum_radii = shrunk_sum_radii\n                best_centers = polished_centers\n                best_radii = verified_radii\n\n    # Ensure numpy arrays with correct shapes and dtype=float64\n    best_centers = best_centers.astype(np.float64)\n    best_radii = best_radii.astype(np.float64)\n\n    return best_centers, best_radii, best_sum_radii",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.3270072937011719,
    "error": "ValueError: shape mismatch: value array of shape (9,) could not be broadcast to indexing result of shape (13,)"
  },
  "prompt": "\nImplement a constructive multi-restart heuristic:\n- Generate 20-40 diverse center seeds: hex-like grids with slight jitter, edge-heavy and corner-biased patterns.\n- For each seed, run a fast local shaking: iteratively nudge centers away from near neighbors (kNN) proportional to overlap pressure\n  computed from a provisional LP radii; 200-400 iterations with decaying step.\n- After shaking, run LP for final radii; track best sum. Finish with a brief L-BFGS-B center polish on the top 2 seeds, then final LP.\n- Eps only in divisions; strict LP margin 1e-6; deterministic seed.\n\n\nRequirements:\n- Output a single Python code block, no prose.\n- Allowed modules: numpy, scipy only.\n- Provide a function construct_packing() returning (centers, radii, sum_radii).\n- Shapes: centers (26,2), radii (26,).\n- All circles strictly inside [0,1]^2 and pairwise non-overlapping, tolerance 1e-6.\n- Maximize sum(radii); use a final LP feasibilization to ensure strict feasibility:\n  Max sum r s.t. 0 <= r_i, r_i <= min(current_r_i, x_i, y_i, 1-x_i, 1-y_i),\n  and r_i + r_j <= dist_ij - 1e-6 for all i<j. Use scipy.optimize.linprog (HiGHS).\n- Gradient stabilization: apply eps only in divisions (do not bias penalties).\n- Keep runtime <= 300s. No printing. Deterministic seed ok.\n- Return the best strictly feasible solution found.\n\n\nLP details:\n- Objective: maximize sum r -> minimize c^T r with c = -1.\n- Bounds: (0, None) or (0, current_r_i) but ensure boundary caps r_i <= x_i, y_i, 1-x_i, 1-y_i via A_ub.\n- Pairwise constraints: r_i + r_j <= ||c_i - c_j|| - 1e-6 for all pairs.\n- Use method='highs'; check success; if infeasible due to tight margins, reduce radii bound slightly and retry.\n\n\nFeasibility check:\n- After LP, verify: all 0<=r_i, r_i <= margins; for all i<j: r_i+r_j <= dist_ij - 1e-6 - 1e-12 slack; centers in [0,1].\n- If any violation (numerical), shrink radii slightly (factor 1 - 2e-7) and recheck.\n\n\nPenalty model for centers+radii (when used):\n- Smooth hinge for boundary: phi(t)=relu(-t) with squared penalty; gradients w.r.t x,y,r vectorized.\n- Overlap penalty: for each pair i<j, s_ij = (r_i + r_j) - d_ij; penalize relu(s_ij)^2.\n- Distances stabilized using d_ij_safe = sqrt(d2 + eps2) with eps only in denominator when normalizing.\n- Use annealed weights: rho in [1.0, 200.0] staged, and optionally density-weighted scaling per-circle via k-NN.\n\n\nSeeding:\n- Provide multiple starts: triangular/hex-like rows near edges and interior, plus jitter.\n- Include an edge-biased seed and a corner-biased seed.\n- Keep radii initial guesses moderate; LP will adjust.\n\n\nFinalize:\n- Always run LP on the best candidate centers with generous current_r caps (or infinity); let LP bound by geometry.\n- Return centers, radii, sum(radii). Ensure numpy arrays with correct shapes and dtype=float64.\n\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nfrom scipy.spatial.distance import pdist, squareform\n\n# Global constants\nN_CIRCLES = 26\nEPS = 1e-9  # For numerical stability in divisions/sqrt\nLP_MARGIN = 1e-6 # Strict margin for LP constraints\nVERIFY_SLACK = 1e-12 # Additional slack for verification in feasibility check\nMAX_SHRINK_ATTEMPTS = 5 # Max attempts to shrink radii for strict feasibility\nSHRINK_FACTOR = 1 - 2e-7 # Factor to shrink radii if verification fails\n\n# Set a deterministic seed for reproducibility\nnp.random.seed(42)\n\ndef calculate_distances(centers):\n    \"\"\"\n    Calculates pairwise Euclidean distances and squared distances between centers.\n    \n    Args:\n        centers (np.ndarray): An (N, 2) array of circle center coordinates.\n        \n    Returns:\n        tuple: A tuple containing:\n            - dist_matrix (np.ndarray): An (N, N) matrix of pairwise distances.\n            - dist_sq_matrix (np.ndarray): An (N, N) matrix of pairwise squared distances.\n    \"\"\"\n    if centers.shape[0] < 2:\n        return np.array([[0.0]]), np.array([[0.0]])\n    dist_sq_matrix = squareform(pdist(centers, 'sqeuclidean'))\n    dist_matrix = np.sqrt(dist_sq_matrix)\n    return dist_matrix, dist_sq_matrix\n\ndef solve_lp(centers, current_radii_caps=None):\n    \"\"\"\n    Solves a Linear Program to find maximum radii for given centers.\n    Maximizes sum(r_i) subject to non-overlap and boundary constraints.\n    \n    Args:\n        centers (np.ndarray): An (N, 2) array of circle center coordinates.\n        current_radii_caps (np.ndarray, optional): An (N,) array of upper bounds\n            for each radius. If None, no upper bound is applied other than geometric.\n            \n    Returns:\n        tuple: A tuple containing:\n            - radii (np.ndarray): An (N,) array of optimized radii.\n            - sum_radii (float): The sum of the optimized radii.\n    \"\"\"\n    n = centers.shape[0]\n    c = -np.ones(n)  # Objective: maximize sum(r_i) -> minimize -sum(r_i)\n\n    A_ub = []\n    b_ub = []\n\n    # Wall constraints: r_i <= x_i, r_i <= y_i, r_i <= 1-x_i, r_i <= 1-y_i\n    for i in range(n):\n        row_i = np.zeros(n)\n        row_i[i] = 1.0\n        \n        A_ub.append(row_i)\n        b_ub.append(centers[i, 0]) # r_i <= x_i\n        \n        A_ub.append(row_i)\n        b_ub.append(centers[i, 1]) # r_i <= y_i\n        \n        A_ub.append(row_i)\n        b_ub.append(1.0 - centers[i, 0]) # r_i <= 1-x_i\n        \n        A_ub.append(row_i)\n        b_ub.append(1.0 - centers[i, 1]) # r_i <= 1-y_i\n\n    # Pairwise overlap constraints: r_i + r_j <= ||c_i - c_j|| - LP_MARGIN\n    dist_matrix, _ = calculate_distances(centers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            row_ij = np.zeros(n)\n            row_ij[i] = 1.0\n            row_ij[j] = 1.0\n            A_ub.append(row_ij)\n            b_ub.append(dist_matrix[i, j] - LP_MARGIN)\n\n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n\n    # Bounds for radii: r_i >= 0. If current_radii_caps are provided, r_i <= cap.\n    if current_radii_caps is not None:\n        bounds = [(0, cap) for cap in current_radii_caps]\n    else:\n        bounds = [(0, None)] * n\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        return res.x, -res.fun\n    else:\n        # If LP fails due to infeasibility, try relaxing the margin to 0 for a retry.\n        # This can help find a solution if the margin was too aggressive.\n        if res.status == 2 and LP_MARGIN > 0: # Infeasible\n            A_ub_retry = []\n            b_ub_retry = []\n            # Re-add wall constraints (unchanged)\n            for i in range(n):\n                row_i = np.zeros(n)\n                row_i[i] = 1.0\n                A_ub_retry.append(row_i)\n                b_ub_retry.append(centers[i, 0])\n                A_ub_retry.append(row_i)\n                b_ub_retry.append(centers[i, 1])\n                A_ub_retry.append(row_i)\n                b_ub_retry.append(1.0 - centers[i, 0])\n                A_ub_retry.append(row_i)\n                b_ub_retry.append(1.0 - centers[i, 1])\n            # Re-add pairwise constraints with 0 margin\n            for i in range(n):\n                for j in range(i + 1, n):\n                    row_ij = np.zeros(n)\n                    row_ij[i] = 1.0\n                    row_ij[j] = 1.0\n                    A_ub_retry.append(row_ij)\n                    b_ub_retry.append(dist_matrix[i, j]) # No margin\n            \n            res_retry = linprog(c, A_ub=np.array(A_ub_retry), b_ub=np.array(b_ub_retry), bounds=bounds, method='highs')\n            if res_retry.success:\n                return res_retry.x, -res_retry.fun\n        \n        return np.zeros(n), 0.0\n\ndef verify_solution(centers, radii):\n    \"\"\"\n    Verifies if a solution (centers, radii) is strictly feasible.\n    Shrinks radii slightly if numerical violations are found and retries.\n    \n    Args:\n        centers (np.ndarray): An (N, 2) array of circle center coordinates.\n        radii (np.ndarray): An (N,) array of circle radii.\n        \n    Returns:\n        tuple: A tuple containing:\n            - is_feasible (bool): True if the solution is strictly feasible, False otherwise.\n            - verified_radii (np.ndarray): The radii array, potentially shrunk to ensure feasibility.\n    \"\"\"\n    current_radii = np.copy(radii)\n    \n    for attempt in range(MAX_SHRINK_ATTEMPTS):\n        is_feasible = True\n        \n        # 1. Radii must be non-negative\n        if np.any(current_radii < 0):\n            is_feasible = False\n        \n        # 2. Centers must be within [0,1]\n        if np.any(centers < 0 - EPS) or np.any(centers > 1 + EPS):\n            is_feasible = False\n\n        # 3. Circles must be entirely within unit square\n        if np.any(centers[:, 0] - current_radii < 0 - LP_MARGIN - VERIFY_SLACK) or \\\n           np.any(centers[:, 0] + current_radii > 1 + LP_MARGIN + VERIFY_SLACK) or \\\n           np.any(centers[:, 1] - current_radii < 0 - LP_MARGIN - VERIFY_SLACK) or \\\n           np.any(centers[:, 1] + current_radii > 1 + LP_MARGIN + VERIFY_SLACK):\n            is_feasible = False\n\n        # 4. No overlap between circles\n        dist_matrix, _ = calculate_distances(centers)\n        for i in range(N_CIRCLES):\n            for j in range(i + 1, N_CIRCLES):\n                if current_radii[i] + current_radii[j] > dist_matrix[i, j] - LP_MARGIN - VERIFY_SLACK:\n                    is_feasible = False\n                    break\n            if not is_feasible:\n                break\n        \n        if is_feasible:\n            return True, current_radii\n        else:\n            current_radii *= SHRINK_FACTOR # Shrink radii and retry\n    \n    return False, current_radii # Failed to achieve feasibility after max attempts\n\ndef generate_seeds():\n    \"\"\"\n    Generates a diverse set of initial center configurations (seeds).\n    \n    Returns:\n        list: A list of np.ndarray, where each array is an (N_CIRCLES, 2)\n              center configuration.\n    \"\"\"\n    seeds = []\n\n    # Helper to ensure N_CIRCLES points from a larger grid\n    def get_n_points_from_grid(grid_points, jitter_amount):\n        if len(grid_points) > N_CIRCLES:\n            centers = grid_points[np.random.choice(len(grid_points), N_CIRCLES, replace=False)]\n        elif len(grid_points) < N_CIRCLES:\n            extra_points = N_CIRCLES - len(grid_points)\n            centers = np.vstack([grid_points, np.random.uniform(0, 1, size=(extra_points, 2))])\n        else:\n            centers = grid_points\n        \n        centers += np.random.uniform(-jitter_amount, jitter_amount, size=centers.shape)\n        return np.clip(centers, 0, 1)\n\n    # 1. Uniform grid with jitter (5 seeds)\n    for _ in range(5):\n        grid_size = int(np.sqrt(N_CIRCLES)) + 1 \n        x_coords = np.linspace(0.05, 0.95, grid_size)\n        y_coords = np.linspace(0.05, 0.95, grid_size)\n        \n        grid_points = []\n        for x in x_coords:\n            for y in y_coords:\n                grid_points.append([x, y])\n        \n        seeds.append(get_n_points_from_grid(np.array(grid_points), np.random.uniform(0.01, 0.05)))\n\n    # 2. Hexagonal grid with jitter (5 seeds)\n    for _ in range(5):\n        grid_points = []\n        rows = int(np.sqrt(N_CIRCLES * 4 / (3 * np.sqrt(3)))) + 1\n        cols = int(N_CIRCLES / rows) + 2\n        \n        x_step = 1.0 / (cols - 1)\n        y_step = np.sqrt(3) / 2 * x_step\n\n        for r in range(rows):\n            for c in range(cols):\n                x = c * x_step\n                y = r * y_step\n                if r % 2 == 1:\n                    x += x_step / 2\n                grid_points.append([x, y])\n        \n        grid_points = np.array(grid_points)\n        # Scale to [0,1]\n        grid_points[:,0] = (grid_points[:,0] - grid_points[:,0].min()) / (grid_points[:,0].max() - grid_points[:,0].min() + EPS)\n        grid_points[:,1] = (grid_points[:,1] - grid_points[:,1].min()) / (grid_points[:,1].max() - grid_points[:,1].min() + EPS)\n        \n        seeds.append(get_n_points_from_grid(grid_points, np.random.uniform(0.01, 0.05)))\n\n    # 3. Edge-biased (5 seeds)\n    for _ in range(5):\n        centers = np.random.beta(0.5, 0.5, size=(N_CIRCLES, 2)) # Biased towards 0 and 1\n        jitter = np.random.uniform(0.01, 0.03)\n        centers += np.random.uniform(-jitter, jitter, size=centers.shape)\n        seeds.append(np.clip(centers, 0, 1))\n\n    # 4. Corner-biased (5 seeds)\n    for _ in range(5):\n        centers = np.random.rand(N_CIRCLES, 2)**np.random.uniform(2, 5) # Biased towards (0,0)\n        # Randomly flip to other corners\n        centers[np.random.rand(N_CIRCLES) > 0.5, 0] = 1 - centers[np.random.rand(N_CIRCLES) > 0.5, 0]\n        centers[np.random.rand(N_CIRCLES) > 0.5, 1] = 1 - centers[np.random.rand(N_CIRCLES) > 0.5, 1]\n        jitter = np.random.uniform(0.01, 0.03)\n        centers += np.random.uniform(-jitter, jitter, size=centers.shape)\n        seeds.append(np.clip(centers, 0, 1))\n        \n    # 5. Random uniform (5 seeds)\n    for _ in range(5):\n        centers = np.random.uniform(0, 1, size=(N_CIRCLES, 2))\n        seeds.append(centers)\n\n    return seeds\n\ndef shake_centers(initial_centers):\n    \"\"\"\n    Iteratively nudges centers away from near neighbors and walls.\n    Uses a heuristic for provisional radii to estimate overlap pressure.\n    \n    Args:\n        initial_centers (np.ndarray): An (N, 2) array of initial center coordinates.\n        \n    Returns:\n        np.ndarray: An (N, 2) array of shaken center coordinates.\n    \"\"\"\n    centers = initial_centers.copy()\n    max_iter = 300\n    initial_step_size = 0.01\n    wall_repulsion_strength = 10.0\n    overlap_repulsion_strength = 0.5\n\n    for iter_idx in range(max_iter):\n        step_size = initial_step_size * (1 - iter_idx / max_iter)\n        \n        dist_matrix, _ = calculate_distances(centers)\n        \n        # Provisional radii heuristic: min of wall distance and half nearest neighbor distance\n        r_provisional = np.zeros(N_CIRCLES)\n        for i in range(N_CIRCLES):\n            wall_dists = np.array([centers[i,0], centers[i,1], 1-centers[i,0], 1-centers[i,1]])\n            r_provisional[i] = np.min(wall_dists)\n            \n            dists_to_others = dist_matrix[i, np.arange(N_CIRCLES) != i]\n            if len(dists_to_others) > 0:\n                r_provisional[i] = np.min([r_provisional[i], np.min(dists_to_others) / 2.0])\n        \n        forces = np.zeros_like(centers)\n\n        for i in range(N_CIRCLES):\n            # Wall repulsion\n            forces[i,0] += np.maximum(0, r_provisional[i] - centers[i,0]) * wall_repulsion_strength\n            forces[i,0] -= np.maximum(0, r_provisional[i] - (1 - centers[i,0])) * wall_repulsion_strength\n            forces[i,1] += np.maximum(0, r_provisional[i] - centers[i,1]) * wall_repulsion_strength\n            forces[i,1] -= np.maximum(0, r_provisional[i] - (1 - centers[i,1])) * wall_repulsion_strength\n\n            # Overlap repulsion\n            for j in range(i + 1, N_CIRCLES):\n                d_ij = dist_matrix[i, j]\n                overlap = r_provisional[i] + r_provisional[j] - d_ij\n                \n                if overlap > 0:\n                    direction = (centers[i] - centers[j]) / (d_ij + EPS)\n                    force_magnitude = overlap * overlap_repulsion_strength\n                    forces[i] += direction * force_magnitude\n                    forces[j] -= direction * force_magnitude\n        \n        centers += forces * step_size\n        centers = np.clip(centers, 0, 1) # Keep centers within bounds\n    \n    return centers\n\ndef polish_centers_radii(initial_centers, initial_radii):\n    \"\"\"\n    Optimizes centers and radii simultaneously using L-BFGS-B with a penalty function.\n    \n    Args:\n        initial_centers (np.ndarray): An (N, 2) array of initial center coordinates.\n        initial_radii (np.ndarray): An (N,) array of initial radii.\n        \n    Returns:\n        tuple: A tuple containing:\n            - polished_centers (np.ndarray): An (N, 2) array of optimized center coordinates.\n            - polished_radii (np.ndarray): An (N,) array of optimized radii.\n    \"\"\"\n    n = N_CIRCLES\n    \n    # Initial guess: flatten centers and radii\n    x0 = np.concatenate((initial_centers.flatten(), initial_radii))\n\n    # Bounds for L-BFGS-B\n    center_bounds = [(0, 1)] * (2 * n)\n    radius_bounds = [(0, None)] * n # Radii must be non-negative, upper bound handled by penalty\n    bounds = center_bounds + radius_bounds\n\n    def objective(x, rho):\n        \"\"\"Objective function for L-BFGS-B: -sum(radii) + rho * (boundary_penalty + overlap_penalty)\"\"\"\n        centers_flat = x[:2*n]\n        radii = x[2*n:]\n        centers = centers_flat.reshape(n, 2)\n\n        cost = -np.sum(radii) # Maximize sum of radii -> minimize negative sum\n\n        # Boundary penalty: penalize if r_i makes circle go out of bounds\n        boundary_penalty = 0.0\n        for i in range(n):\n            boundary_penalty += np.sum(np.maximum(0, radii[i] - centers[i])**2) # r_i > x_i or r_i > y_i\n            boundary_penalty += np.sum(np.maximum(0, radii[i] - (1 - centers[i]))**2) # r_i > 1-x_i or r_i > 1-y_i\n        \n        # Overlap penalty: penalize if r_i + r_j > d_ij\n        overlap_penalty = 0.0\n        dist_sq_matrix = calculate_distances(centers)[1]\n        for i in range(n):\n            for j in range(i + 1, n):\n                d_ij_sq = dist_sq_matrix[i, j]\n                d_ij_safe = np.sqrt(d_ij_sq + EPS) # Stabilize distance for gradient\n                overlap = radii[i] + radii[j] - d_ij_safe\n                overlap_penalty += np.maximum(0, overlap)**2\n        \n        return cost + rho * (boundary_penalty + overlap_penalty)\n\n    def gradient(x, rho):\n        \"\"\"Gradient function for L-BFGS-B.\"\"\"\n        centers_flat = x[:2*n]\n        radii = x[2*n:]\n        centers = centers_flat.reshape(n, 2)\n\n        grad_centers = np.zeros_like(centers)\n        grad_radii = np.zeros_like(radii)\n\n        grad_radii -= 1.0 # Gradient from -sum(radii)\n\n        # Boundary penalty gradients\n        for i in range(n):\n            for dim in range(2):\n                # Gradient for (r_i - c_i[dim])^2\n                val = radii[i] - centers[i, dim]\n                if val > 0:\n                    grad_radii[i] += rho * 2 * val\n                    grad_centers[i, dim] -= rho * 2 * val\n                \n                # Gradient for (r_i - (1 - c_i[dim]))^2\n                val = radii[i] - (1 - centers[i, dim])\n                if val > 0:\n                    grad_radii[i] += rho * 2 * val\n                    grad_centers[i, dim] += rho * 2 * val\n        \n        # Overlap penalty gradients\n        dist_sq_matrix = calculate_distances(centers)[1]\n        for i in range(n):\n            for j in range(i + 1, n):\n                d_ij_sq = dist_sq_matrix[i, j]\n                d_ij_safe = np.sqrt(d_ij_sq + EPS)\n                overlap = radii[i] + radii[j] - d_ij_safe\n                \n                if overlap > 0:\n                    grad_val = rho * 2 * overlap\n                    grad_radii[i] += grad_val\n                    grad_radii[j] += grad_val\n\n                    # Chain rule for d_overlap / d_d_ij_safe = -1\n                    # Chain rule for d_d_ij_safe / d_d_ij_sq = 0.5 / d_ij_safe\n                    grad_d_ij_sq = (-grad_val) * 0.5 / d_ij_safe\n                    \n                    # Chain rule for d_d_ij_sq / d_c_k = 2 * (c_k - c_l)\n                    diff_c = centers[i] - centers[j]\n                    grad_centers[i] += grad_d_ij_sq * 2 * diff_c\n                    grad_centers[j] -= grad_d_ij_sq * 2 * diff_c\n        \n        return np.concatenate((grad_centers.flatten(), grad_radii))\n\n    # Annealing rho to gradually increase penalty for violations\n    rhos = [1.0, 10.0, 100.0, 200.0]\n    current_x = x0\n\n    for rho_val in rhos:\n        res = minimize(objective, current_x, args=(rho_val,), method='L-BFGS-B', jac=gradient, bounds=bounds, options={'maxiter': 100, 'ftol': 1e-7, 'gtol': 1e-5})\n        current_x = res.x\n        # If optimization fails for a given rho, continue with the last valid x\n        if not res.success:\n            break\n\n    polished_centers = current_x[:2*n].reshape(n, 2)\n    polished_radii = current_x[2*n:]\n    \n    # Ensure radii are non-negative after polish\n    polished_radii = np.maximum(0, polished_radii)\n\n    return polished_centers, polished_radii\n\ndef construct_packing():\n    \"\"\"\n    Main function to construct the circle packing.\n    \n    Returns:\n        tuple: A tuple containing:\n            - centers (np.ndarray): An (N_CIRCLES, 2) array of optimized center coordinates.\n            - radii (np.ndarray): An (N_CIRCLES,) array of optimized radii.\n            - sum_radii (float): The sum of the optimized radii.\n    \"\"\"\n    best_sum_radii = 0.0\n    best_centers = np.zeros((N_CIRCLES, 2), dtype=np.float64)\n    best_radii = np.zeros(N_CIRCLES, dtype=np.float64)\n\n    all_seeds = generate_seeds()\n    \n    candidate_solutions = [] # Stores (sum_radii, centers, radii) after shaking and initial LP\n\n    # Phase 1: Generate diverse seeds, shake them, and run initial LP\n    for seed_centers in all_seeds:\n        shaken_centers = shake_centers(seed_centers)\n        \n        radii_lp, current_sum_radii = solve_lp(shaken_centers)\n        \n        if current_sum_radii > 0 and np.all(radii_lp >= 0):\n            candidate_solutions.append((current_sum_radii, shaken_centers, radii_lp))\n    \n    # Sort candidates by sum_radii (descending)\n    candidate_solutions.sort(key=lambda x: x[0], reverse=True)\n\n    # Phase 2: Polish top candidates with L-BFGS-B and re-evaluate with LP\n    num_to_polish = min(len(candidate_solutions), 3) # Polish top 3 candidates\n\n    for i in range(num_to_polish):\n        _, initial_centers, initial_radii = candidate_solutions[i]\n        \n        polished_centers, polished_radii_from_polish = polish_centers_radii(initial_centers, initial_radii)\n        \n        # After polishing, run a final LP to ensure strict feasibility and get optimal radii\n        final_radii, final_sum_radii = solve_lp(polished_centers)\n        \n        # Verify strict feasibility and update best solution\n        is_feasible, verified_radii = verify_solution(polished_centers, final_radii)\n        \n        if is_feasible:\n            if final_sum_radii > best_sum_radii:\n                best_sum_radii = final_sum_radii\n                best_centers = polished_centers\n                best_radii = verified_radii\n        else:\n            # If LP solution is not strictly feasible after verification, use the verified (shrunk) radii\n            # and check if its sum is better.\n            shrunk_sum_radii = np.sum(verified_radii)\n            if shrunk_sum_radii > best_sum_radii:\n                best_sum_radii = shrunk_sum_radii\n                best_centers = polished_centers\n                best_radii = verified_radii\n\n    # Ensure numpy arrays with correct shapes and dtype=float64\n    best_centers = best_centers.astype(np.float64)\n    best_radii = best_radii.astype(np.float64)\n\n    return best_centers, best_radii, best_sum_radii\n\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T03:28:42.941470",
  "cost_data": null,
  "model_config": {
    "model": "gemini-2.5-flash",
    "temperature": 0.35,
    "provider_debug": {
      "finish_reason": "STOP",
      "usage_metadata": {
        "prompt_token_count": 1104,
        "candidates_token_count": 6425,
        "thoughts_token_count": 13584
      },
      "response_text_len": 20070
    }
  },
  "llm_call_duration_s": 79.20535304001532,
  "eval_duration_s": 0.3270124359987676
}