{
  "trial_id": "trial_17_4",
  "generation": 17,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    def solve_lp_radii(centers, current_radii=None, margin_factor=1e-6):\n        n = len(centers)\n        \n        # Compute pairwise distances\n        dists = np.zeros((n, n))\n        for i in range(n):\n            for j in range(i+1, n):\n                dists[i,j] = dists[j,i] = np.linalg.norm(centers[i] - centers[j])\n        \n        # Objective: minimize -sum(r_i)\n        c = -np.ones(n)\n        \n        # Inequality constraints: r_i + r_j <= d_ij - margin_factor\n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                constraint[j] = 1\n                A_ub.append(constraint)\n                b_ub.append(dists[i,j] - margin_factor)\n        \n        # Boundary constraints: r_i <= min(x_i, y_i, 1-x_i, 1-y_i)\n        for i in range(n):\n            x, y = centers[i]\n            margin = min(x, y, 1-x, 1-y)\n            constraint = np.zeros(n)\n            constraint[i] = 1\n            A_ub.append(constraint)\n            b_ub.append(margin)\n        \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        \n        # Bounds: r_i >= 0\n        bounds = [(0, None) for _ in range(n)]\n        if current_radii is not None:\n            for i in range(n):\n                bounds[i] = (0, current_radii[i])\n        \n        try:\n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if result.success:\n                return result.x, -result.fun\n            else:\n                # Fallback: use smaller radii\n                fallback_radii = np.minimum(0.01, b_ub[-n:] * 0.5)\n                return fallback_radii, np.sum(fallback_radii)\n        except:\n            fallback_radii = np.full(n, 0.01)\n            return fallback_radii, np.sum(fallback_radii)\n    \n    def project_centers_boundary(centers, slack=1e-3):\n        centers_proj = np.copy(centers)\n        centers_proj[:, 0] = np.clip(centers_proj[:, 0], slack, 1-slack)\n        centers_proj[:, 1] = np.clip(centers_proj[:, 1], slack, 1-slack)\n        return centers_proj\n    \n    def push_overlapping_pairs(centers, radii, step_size=0.01):\n        n = len(centers)\n        centers_new = np.copy(centers)\n        eps = 1e-12\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                d_vec = centers[j] - centers[i]\n                d = np.linalg.norm(d_vec)\n                if d < eps:\n                    # Add small random perturbation\n                    d_vec = np.random.randn(2) * 1e-6\n                    d = np.linalg.norm(d_vec)\n                \n                required_dist = radii[i] + radii[j] + 1e-6\n                if d < required_dist:\n                    overlap = required_dist - d\n                    direction = d_vec / (d + eps)\n                    push = overlap * step_size * 0.5\n                    centers_new[i] -= push * direction\n                    centers_new[j] += push * direction\n        \n        return centers_new\n    \n    def dykstra_projection(centers_init, max_iters=300):\n        centers = np.copy(centers_init)\n        best_sum = 0\n        best_centers = np.copy(centers)\n        best_radii = np.zeros(26)\n        \n        for iteration in range(max_iters):\n            # Step size decay\n            step_size = 0.1 * (0.95 ** (iteration // 10))\n            \n            # Solve LP for radii\n            radii, sum_radii = solve_lp_radii(centers)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = np.copy(centers)\n                best_radii = np.copy(radii)\n            \n            # Push overlapping pairs apart\n            centers = push_overlapping_pairs(centers, radii, step_size)\n            \n            # Project to boundary\n            centers = project_centers_boundary(centers, slack=1e-3)\n        \n        return best_centers, best_radii, best_sum\n    \n    def penalty_objective(x, rho=100.0):\n        n = 26\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        penalty = 0.0\n        eps = 1e-12\n        \n        # Boundary penalties\n        for i in range(n):\n            cx, cy, r = centers[i, 0], centers[i, 1], radii[i]\n            penalty += rho * max(0, r - cx)**2\n            penalty += rho * max(0, r - cy)**2\n            penalty += rho * max(0, r - (1-cx))**2\n            penalty += rho * max(0, r - (1-cy))**2\n            penalty += rho * max(0, -r)**2\n        \n        # Overlap penalties\n        for i in range(n):\n            for j in range(i+1, n):\n                d_vec = centers[j] - centers[i]\n                d = np.sqrt(np.sum(d_vec**2) + eps**2)\n                overlap = radii[i] + radii[j] - d + 1e-6\n                if overlap > 0:\n                    penalty += rho * overlap**2\n        \n        return -np.sum(radii) + penalty\n    \n    def lbfgs_polish(centers_init, radii_init):\n        n = 26\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        bounds = []\n        # Center bounds\n        for i in range(2*n):\n            bounds.append((1e-3, 1-1e-3))\n        # Radii bounds\n        for i in range(n):\n            bounds.append((0, 0.1))\n        \n        try:\n            result = minimize(penalty_objective, x0, method='L-BFGS-B', \n                            bounds=bounds, options={'maxiter': 100})\n            if result.success:\n                centers = result.x[:2*n].reshape(n, 2)\n                radii = result.x[2*n:]\n                return centers, radii\n        except:\n            pass\n        \n        return centers_init, radii_init\n    \n    def create_seed_patterns():\n        seeds = []\n        \n        # Hex-like grid\n        centers = []\n        for row in range(6):\n            y = 0.1 + 0.8 * row / 5\n            n_cols = 5 if row % 2 == 0 else 4\n            for col in range(n_cols):\n                if row % 2 == 0:\n                    x = 0.1 + 0.8 * col / 4\n                else:\n                    x = 0.2 + 0.6 * col / 3\n                if len(centers) < 26:\n                    centers.append([x, y])\n        \n        while len(centers) < 26:\n            centers.append([0.5, 0.5])\n        \n        seeds.append(np.array(centers[:26]))\n        \n        # Edge-biased\n        centers = []\n        # Edges\n        for i in range(8):\n            centers.append([0.05, 0.1 + 0.8 * i / 7])\n        for i in range(8):\n            centers.append([0.95, 0.1 + 0.8 * i / 7])\n        for i in range(5):\n            centers.append([0.2 + 0.6 * i / 4, 0.05])\n        for i in range(5):\n            centers.append([0.2 + 0.6 * i / 4, 0.95])\n        \n        seeds.append(np.array(centers[:26]))\n        \n        # Corner-biased\n        centers = []\n        corners = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n        for corner in corners:\n            for i in range(6):\n                angle = 2 * np.pi * i / 6\n                r = 0.1 + 0.05 * (i % 3)\n                x = corner[0] + r * np.cos(angle)\n                y = corner[1] + r * np.sin(angle)\n                x = np.clip(x, 0.05, 0.95)\n                y = np.clip(y, 0.05, 0.95)\n                if len(centers) < 26:\n                    centers.append([x, y])\n        \n        while len(centers) < 26:\n            centers.append([0.5, 0.5])\n        \n        seeds.append(np.array(centers[:26]))\n        \n        return seeds\n    \n    def check_feasibility(centers, radii, tolerance=1e-6):\n        n = len(centers)\n        \n        # Check bounds\n        for i in range(n):\n            if radii[i] < 0:\n                return False\n            x, y = centers[i]\n            if not (0 <= x <= 1 and 0 <= y <= 1):\n                return False\n            if radii[i] > min(x, y, 1-x, 1-y):\n                return False\n        \n        # Check overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > d + tolerance + 1e-12:\n                    return False\n        \n        return True\n    \n    # Main algorithm\n    seed_patterns = create_seed_patterns()\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    for seed_centers in seed_patterns:\n        # Dykstra projection\n        centers, radii, sum_radii = dykstra_projection(seed_centers)\n        \n        # L-BFGS polish\n        centers, radii = lbfgs_polish(centers, radii)\n        \n        # Final LP\n        radii_final, sum_final = solve_lp_radii(centers)\n        \n        # Feasibility check and adjustment\n        if not check_feasibility(centers, radii_final):\n            radii_final *= (1 - 2e-7)\n        \n        if np.sum(radii_final) > best_sum and check_feasibility(centers, radii_final):\n            best_sum = np.sum(radii_final)\n            best_centers = np.copy(centers)\n            best_radii = np.copy(radii_final)\n    \n    if best_centers is None:\n        # Fallback\n        best_centers = np.random.uniform(0.1, 0.9, (26, 2))\n        best_radii = np.full(26, 0.01)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers.astype(np.float64), best_radii.astype(np.float64), float(best_sum)",
  "metrics": {
    "valid": true,
    "score": 2.475462849052453,
    "eval_time": 36.97544836997986,
    "error": null
  },
  "prompt": "\nImplement a Dykstra-like projection algorithm on centers:\n- Loop: (a) Solve LP for radii with current centers; (b) Identify active overlaps (r_i+r_j close to d_ij) and push pairs apart minimally along connecting line;\n  (c) Enforce boundary feasibility by projecting to [0,1]^2 with small slack; (d) Repeat with diminishing step sizes.\n- After 200-400 projection sweeps, run a brief penalized L-BFGS-B polish on centers with kNN penalties; finish with final LP.\n- Deterministic seeds (hex/edge/corner). Eps only in divisions.\n\n\nRequirements:\n- Output a single Python code block, no prose.\n- Allowed modules: numpy, scipy only.\n- Provide a function construct_packing() returning (centers, radii, sum_radii).\n- Shapes: centers (26,2), radii (26,).\n- All circles strictly inside [0,1]^2 and pairwise non-overlapping, tolerance 1e-6.\n- Maximize sum(radii); use a final LP feasibilization to ensure strict feasibility:\n  Max sum r s.t. 0 <= r_i, r_i <= min(current_r_i, x_i, y_i, 1-x_i, 1-y_i),\n  and r_i + r_j <= dist_ij - 1e-6 for all i<j. Use scipy.optimize.linprog (HiGHS).\n- Gradient stabilization: apply eps only in divisions (do not bias penalties).\n- Keep runtime <= 300s. No printing. Deterministic seed ok.\n- Return the best strictly feasible solution found.\n\n\nLP details:\n- Objective: maximize sum r -> minimize c^T r with c = -1.\n- Bounds: (0, None) or (0, current_r_i) but ensure boundary caps r_i <= x_i, y_i, 1-x_i, 1-y_i via A_ub.\n- Pairwise constraints: r_i + r_j <= ||c_i - c_j|| - 1e-6 for all pairs.\n- Use method='highs'; check success; if infeasible due to tight margins, reduce radii bound slightly and retry.\n\n\nFeasibility check:\n- After LP, verify: all 0<=r_i, r_i <= margins; for all i<j: r_i+r_j <= dist_ij - 1e-6 - 1e-12 slack; centers in [0,1].\n- If any violation (numerical), shrink radii slightly (factor 1 - 2e-7) and recheck.\n\n\nPenalty model for centers+radii (when used):\n- Smooth hinge for boundary: phi(t)=relu(-t) with squared penalty; gradients w.r.t x,y,r vectorized.\n- Overlap penalty: for each pair i<j, s_ij = (r_i + r_j) - d_ij; penalize relu(s_ij)^2.\n- Distances stabilized using d_ij_safe = sqrt(d2 + eps2) with eps only in denominator when normalizing.\n- Use annealed weights: rho in [1.0, 200.0] staged, and optionally density-weighted scaling per-circle via k-NN.\n\n\nSeeding:\n- Provide multiple starts: triangular/hex-like rows near edges and interior, plus jitter.\n- Include an edge-biased seed and a corner-biased seed.\n- Keep radii initial guesses moderate; LP will adjust.\n\n\nFinalize:\n- Always run LP on the best candidate centers with generous current_r caps (or infinity); let LP bound by geometry.\n- Return centers, radii, sum(radii). Ensure numpy arrays with correct shapes and dtype=float64.\n\n",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef construct_packing():\n    np.random.seed(42)\n    \n    def solve_lp_radii(centers, current_radii=None, margin_factor=1e-6):\n        n = len(centers)\n        \n        # Compute pairwise distances\n        dists = np.zeros((n, n))\n        for i in range(n):\n            for j in range(i+1, n):\n                dists[i,j] = dists[j,i] = np.linalg.norm(centers[i] - centers[j])\n        \n        # Objective: minimize -sum(r_i)\n        c = -np.ones(n)\n        \n        # Inequality constraints: r_i + r_j <= d_ij - margin_factor\n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i+1, n):\n                constraint = np.zeros(n)\n                constraint[i] = 1\n                constraint[j] = 1\n                A_ub.append(constraint)\n                b_ub.append(dists[i,j] - margin_factor)\n        \n        # Boundary constraints: r_i <= min(x_i, y_i, 1-x_i, 1-y_i)\n        for i in range(n):\n            x, y = centers[i]\n            margin = min(x, y, 1-x, 1-y)\n            constraint = np.zeros(n)\n            constraint[i] = 1\n            A_ub.append(constraint)\n            b_ub.append(margin)\n        \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        \n        # Bounds: r_i >= 0\n        bounds = [(0, None) for _ in range(n)]\n        if current_radii is not None:\n            for i in range(n):\n                bounds[i] = (0, current_radii[i])\n        \n        try:\n            result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if result.success:\n                return result.x, -result.fun\n            else:\n                # Fallback: use smaller radii\n                fallback_radii = np.minimum(0.01, b_ub[-n:] * 0.5)\n                return fallback_radii, np.sum(fallback_radii)\n        except:\n            fallback_radii = np.full(n, 0.01)\n            return fallback_radii, np.sum(fallback_radii)\n    \n    def project_centers_boundary(centers, slack=1e-3):\n        centers_proj = np.copy(centers)\n        centers_proj[:, 0] = np.clip(centers_proj[:, 0], slack, 1-slack)\n        centers_proj[:, 1] = np.clip(centers_proj[:, 1], slack, 1-slack)\n        return centers_proj\n    \n    def push_overlapping_pairs(centers, radii, step_size=0.01):\n        n = len(centers)\n        centers_new = np.copy(centers)\n        eps = 1e-12\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                d_vec = centers[j] - centers[i]\n                d = np.linalg.norm(d_vec)\n                if d < eps:\n                    # Add small random perturbation\n                    d_vec = np.random.randn(2) * 1e-6\n                    d = np.linalg.norm(d_vec)\n                \n                required_dist = radii[i] + radii[j] + 1e-6\n                if d < required_dist:\n                    overlap = required_dist - d\n                    direction = d_vec / (d + eps)\n                    push = overlap * step_size * 0.5\n                    centers_new[i] -= push * direction\n                    centers_new[j] += push * direction\n        \n        return centers_new\n    \n    def dykstra_projection(centers_init, max_iters=300):\n        centers = np.copy(centers_init)\n        best_sum = 0\n        best_centers = np.copy(centers)\n        best_radii = np.zeros(26)\n        \n        for iteration in range(max_iters):\n            # Step size decay\n            step_size = 0.1 * (0.95 ** (iteration // 10))\n            \n            # Solve LP for radii\n            radii, sum_radii = solve_lp_radii(centers)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = np.copy(centers)\n                best_radii = np.copy(radii)\n            \n            # Push overlapping pairs apart\n            centers = push_overlapping_pairs(centers, radii, step_size)\n            \n            # Project to boundary\n            centers = project_centers_boundary(centers, slack=1e-3)\n        \n        return best_centers, best_radii, best_sum\n    \n    def penalty_objective(x, rho=100.0):\n        n = 26\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        penalty = 0.0\n        eps = 1e-12\n        \n        # Boundary penalties\n        for i in range(n):\n            cx, cy, r = centers[i, 0], centers[i, 1], radii[i]\n            penalty += rho * max(0, r - cx)**2\n            penalty += rho * max(0, r - cy)**2\n            penalty += rho * max(0, r - (1-cx))**2\n            penalty += rho * max(0, r - (1-cy))**2\n            penalty += rho * max(0, -r)**2\n        \n        # Overlap penalties\n        for i in range(n):\n            for j in range(i+1, n):\n                d_vec = centers[j] - centers[i]\n                d = np.sqrt(np.sum(d_vec**2) + eps**2)\n                overlap = radii[i] + radii[j] - d + 1e-6\n                if overlap > 0:\n                    penalty += rho * overlap**2\n        \n        return -np.sum(radii) + penalty\n    \n    def lbfgs_polish(centers_init, radii_init):\n        n = 26\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        bounds = []\n        # Center bounds\n        for i in range(2*n):\n            bounds.append((1e-3, 1-1e-3))\n        # Radii bounds\n        for i in range(n):\n            bounds.append((0, 0.1))\n        \n        try:\n            result = minimize(penalty_objective, x0, method='L-BFGS-B', \n                            bounds=bounds, options={'maxiter': 100})\n            if result.success:\n                centers = result.x[:2*n].reshape(n, 2)\n                radii = result.x[2*n:]\n                return centers, radii\n        except:\n            pass\n        \n        return centers_init, radii_init\n    \n    def create_seed_patterns():\n        seeds = []\n        \n        # Hex-like grid\n        centers = []\n        for row in range(6):\n            y = 0.1 + 0.8 * row / 5\n            n_cols = 5 if row % 2 == 0 else 4\n            for col in range(n_cols):\n                if row % 2 == 0:\n                    x = 0.1 + 0.8 * col / 4\n                else:\n                    x = 0.2 + 0.6 * col / 3\n                if len(centers) < 26:\n                    centers.append([x, y])\n        \n        while len(centers) < 26:\n            centers.append([0.5, 0.5])\n        \n        seeds.append(np.array(centers[:26]))\n        \n        # Edge-biased\n        centers = []\n        # Edges\n        for i in range(8):\n            centers.append([0.05, 0.1 + 0.8 * i / 7])\n        for i in range(8):\n            centers.append([0.95, 0.1 + 0.8 * i / 7])\n        for i in range(5):\n            centers.append([0.2 + 0.6 * i / 4, 0.05])\n        for i in range(5):\n            centers.append([0.2 + 0.6 * i / 4, 0.95])\n        \n        seeds.append(np.array(centers[:26]))\n        \n        # Corner-biased\n        centers = []\n        corners = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n        for corner in corners:\n            for i in range(6):\n                angle = 2 * np.pi * i / 6\n                r = 0.1 + 0.05 * (i % 3)\n                x = corner[0] + r * np.cos(angle)\n                y = corner[1] + r * np.sin(angle)\n                x = np.clip(x, 0.05, 0.95)\n                y = np.clip(y, 0.05, 0.95)\n                if len(centers) < 26:\n                    centers.append([x, y])\n        \n        while len(centers) < 26:\n            centers.append([0.5, 0.5])\n        \n        seeds.append(np.array(centers[:26]))\n        \n        return seeds\n    \n    def check_feasibility(centers, radii, tolerance=1e-6):\n        n = len(centers)\n        \n        # Check bounds\n        for i in range(n):\n            if radii[i] < 0:\n                return False\n            x, y = centers[i]\n            if not (0 <= x <= 1 and 0 <= y <= 1):\n                return False\n            if radii[i] > min(x, y, 1-x, 1-y):\n                return False\n        \n        # Check overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > d + tolerance + 1e-12:\n                    return False\n        \n        return True\n    \n    # Main algorithm\n    seed_patterns = create_seed_patterns()\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    for seed_centers in seed_patterns:\n        # Dykstra projection\n        centers, radii, sum_radii = dykstra_projection(seed_centers)\n        \n        # L-BFGS polish\n        centers, radii = lbfgs_polish(centers, radii)\n        \n        # Final LP\n        radii_final, sum_final = solve_lp_radii(centers)\n        \n        # Feasibility check and adjustment\n        if not check_feasibility(centers, radii_final):\n            radii_final *= (1 - 2e-7)\n        \n        if np.sum(radii_final) > best_sum and check_feasibility(centers, radii_final):\n            best_sum = np.sum(radii_final)\n            best_centers = np.copy(centers)\n            best_radii = np.copy(radii_final)\n    \n    if best_centers is None:\n        # Fallback\n        best_centers = np.random.uniform(0.1, 0.9, (26, 2))\n        best_radii = np.full(26, 0.01)\n        best_sum = np.sum(best_radii)\n    \n    return best_centers.astype(np.float64), best_radii.astype(np.float64), float(best_sum)\n```",
  "reasoning": "",
  "timestamp": "2026-02-11T03:28:38.825184",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4",
    "temperature": 0.35
  },
  "llm_call_duration_s": 38.44319125905167,
  "eval_duration_s": 36.975454260013066
}