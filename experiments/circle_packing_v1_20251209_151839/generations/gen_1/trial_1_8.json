{
  "trial_id": "trial_1_8",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    gradient-based optimization with momentum.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum valid radii for given centers.\"\"\"\n        radii = np.ones(n) * 0.5\n        \n        # Constraint from boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = max(0, max_r)\n        \n        # Constraint from other circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_sum = dist\n                # Binary search for optimal radii split\n                if radii[i] + radii[j] > max_sum:\n                    # Proportional reduction\n                    factor = max_sum / (radii[i] + radii[j])\n                    radii[i] *= factor\n                    radii[j] *= factor\n        \n        return radii\n    \n    def objective(centers):\n        \"\"\"Objective to maximize (negative for minimization).\"\"\"\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    def gradient_fd(centers, epsilon=1e-6):\n        \"\"\"Compute gradient using finite differences.\"\"\"\n        grad = np.zeros_like(centers)\n        f0 = objective(centers)\n        \n        for i in range(n):\n            for j in range(2):\n                centers_plus = centers.copy()\n                centers_plus[i, j] += epsilon\n                f_plus = objective(centers_plus)\n                grad[i, j] = (f_plus - f0) / epsilon\n        \n        return grad\n    \n    def optimize_with_momentum(init_centers, iterations=5000, lr=0.01, momentum=0.9):\n        \"\"\"Optimize using momentum-based gradient descent.\"\"\"\n        centers = init_centers.copy()\n        velocity = np.zeros_like(centers)\n        best_centers = centers.copy()\n        best_score = objective(centers)\n        \n        # Adaptive learning rate parameters\n        lr_current = lr\n        lr_decay = 0.995\n        lr_min = 1e-5\n        \n        patience = 0\n        max_patience = 200\n        \n        for iter in range(iterations):\n            # Compute gradient\n            grad = gradient_fd(centers)\n            \n            # Update velocity with momentum\n            velocity = momentum * velocity - lr_current * grad\n            \n            # Update centers\n            new_centers = centers + velocity\n            \n            # Project to valid range [0.05, 0.95] to keep away from boundaries\n            new_centers = np.clip(new_centers, 0.05, 0.95)\n            \n            # Evaluate\n            score = objective(new_centers)\n            \n            # Update if better\n            if score < best_score:\n                best_score = score\n                best_centers = new_centers.copy()\n                patience = 0\n            else:\n                patience += 1\n            \n            centers = new_centers\n            \n            # Decay learning rate\n            lr_current = max(lr_min, lr_current * lr_decay)\n            \n            # Restart from best with perturbation if stuck\n            if patience >= max_patience:\n                centers = best_centers + np.random.randn(n, 2) * 0.02\n                centers = np.clip(centers, 0.05, 0.95)\n                velocity = np.zeros_like(centers)\n                patience = 0\n                lr_current = lr * 0.5\n            \n            # Progress tracking\n            if iter % 500 == 0:\n                radii = compute_max_radii(best_centers)\n                print(f\"Iter {iter}: sum_radii = {np.sum(radii):.6f}\")\n        \n        return best_centers, best_score\n    \n    # Initialize with hexagonal packing\n    def hexagonal_init():\n        \"\"\"Initialize with approximate hexagonal packing.\"\"\"\n        centers = []\n        rows = 5\n        cols = 6\n        \n        dx = 1.0 / (cols + 1)\n        dy = 1.0 / (rows + 1)\n        \n        for row in range(rows):\n            offset = (dx / 2) if row % 2 == 1 else 0\n            for col in range(cols):\n                x = (col + 1) * dx + offset\n                y = (row + 1) * dy\n                if len(centers) < n:\n                    centers.append([x, y])\n        \n        # Add extra circle if needed\n        while len(centers) < n:\n            centers.append([0.5, 0.5])\n        \n        return np.array(centers[:n])\n    \n    # Try multiple initializations\n    best_overall_centers = None\n    best_overall_score = float('inf')\n    \n    # Hexagonal initialization\n    print(\"Starting hexagonal initialization...\")\n    init_centers = hexagonal_init()\n    centers, score = optimize_with_momentum(init_centers, iterations=3000, lr=0.015)\n    if score < best_overall_score:\n        best_overall_score = score\n        best_overall_centers = centers.copy()\n    \n    # Grid initialization with jitter\n    print(\"\\nStarting grid initialization...\")\n    grid_size = int(np.ceil(np.sqrt(n)))\n    init_centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5 + np.random.randn() * 0.1) / grid_size\n        y = (row + 0.5 + np.random.randn() * 0.1) / grid_size\n        init_centers.append([x, y])\n    init_centers = np.array(init_centers)\n    init_centers = np.clip(init_centers, 0.05, 0.95)\n    \n    centers, score = optimize_with_momentum(init_centers, iterations=3000, lr=0.015)\n    if score < best_overall_score:\n        best_overall_score = score\n        best_overall_centers = centers.copy()\n    \n    # Random restart from best\n    print(\"\\nRandom restart from best...\")\n    for restart in range(3):\n        init_centers = best_overall_centers + np.random.randn(n, 2) * 0.05\n        init_centers = np.clip(init_centers, 0.05, 0.95)\n        centers, score = optimize_with_momentum(init_centers, iterations=2000, lr=0.01)\n        if score < best_overall_score:\n            best_overall_score = score\n            best_overall_centers = centers.copy()\n    \n    # Final refinement with scipy\n    print(\"\\nFinal refinement with scipy.optimize...\")\n    \n    def objective_scipy(x):\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_bounds(x):\n        \"\"\"Keep centers away from boundaries.\"\"\"\n        centers = x.reshape(n, 2)\n        margin = 0.02\n        penalties = []\n        for i in range(n):\n            penalties.append(centers[i, 0] - margin)\n            penalties.append(centers[i, 1] - margin)\n            penalties.append(0.98 - centers[i, 0])\n            penalties.append(0.98 - centers[i, 1])\n        return np.array(penalties)\n    \n    x0 = best_overall_centers.flatten()\n    bounds = [(0.02, 0.98)] * (n * 2)\n    \n    result = minimize(\n        objective_scipy,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    final_centers = result.x.reshape(n, 2)\n    final_radii = compute_max_radii(final_centers)\n    final_sum = np.sum(final_radii)\n    \n    print(f\"\\nFinal sum of radii: {final_sum:.6f}\")\n    \n    return final_centers, final_radii, final_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0070080757141,
    "error": "Timeout after 300s"
  },
  "prompt": "Create a gradient-based optimization with momentum:\n\n1. Start with grid or hexagonal initialization\n2. Compute gradient of sum_radii with respect to positions using finite differences\n3. Use momentum-based updates (like SGD with momentum)\n4. Add adaptive learning rate\n5. Periodically restart from best position with perturbation\n6. Run for 5000+ iterations with multiple restarts\n7. Final refinement with scipy.optimize\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    gradient-based optimization with momentum.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum valid radii for given centers.\"\"\"\n        radii = np.ones(n) * 0.5\n        \n        # Constraint from boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = max(0, max_r)\n        \n        # Constraint from other circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_sum = dist\n                # Binary search for optimal radii split\n                if radii[i] + radii[j] > max_sum:\n                    # Proportional reduction\n                    factor = max_sum / (radii[i] + radii[j])\n                    radii[i] *= factor\n                    radii[j] *= factor\n        \n        return radii\n    \n    def objective(centers):\n        \"\"\"Objective to maximize (negative for minimization).\"\"\"\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    def gradient_fd(centers, epsilon=1e-6):\n        \"\"\"Compute gradient using finite differences.\"\"\"\n        grad = np.zeros_like(centers)\n        f0 = objective(centers)\n        \n        for i in range(n):\n            for j in range(2):\n                centers_plus = centers.copy()\n                centers_plus[i, j] += epsilon\n                f_plus = objective(centers_plus)\n                grad[i, j] = (f_plus - f0) / epsilon\n        \n        return grad\n    \n    def optimize_with_momentum(init_centers, iterations=5000, lr=0.01, momentum=0.9):\n        \"\"\"Optimize using momentum-based gradient descent.\"\"\"\n        centers = init_centers.copy()\n        velocity = np.zeros_like(centers)\n        best_centers = centers.copy()\n        best_score = objective(centers)\n        \n        # Adaptive learning rate parameters\n        lr_current = lr\n        lr_decay = 0.995\n        lr_min = 1e-5\n        \n        patience = 0\n        max_patience = 200\n        \n        for iter in range(iterations):\n            # Compute gradient\n            grad = gradient_fd(centers)\n            \n            # Update velocity with momentum\n            velocity = momentum * velocity - lr_current * grad\n            \n            # Update centers\n            new_centers = centers + velocity\n            \n            # Project to valid range [0.05, 0.95] to keep away from boundaries\n            new_centers = np.clip(new_centers, 0.05, 0.95)\n            \n            # Evaluate\n            score = objective(new_centers)\n            \n            # Update if better\n            if score < best_score:\n                best_score = score\n                best_centers = new_centers.copy()\n                patience = 0\n            else:\n                patience += 1\n            \n            centers = new_centers\n            \n            # Decay learning rate\n            lr_current = max(lr_min, lr_current * lr_decay)\n            \n            # Restart from best with perturbation if stuck\n            if patience >= max_patience:\n                centers = best_centers + np.random.randn(n, 2) * 0.02\n                centers = np.clip(centers, 0.05, 0.95)\n                velocity = np.zeros_like(centers)\n                patience = 0\n                lr_current = lr * 0.5\n            \n            # Progress tracking\n            if iter % 500 == 0:\n                radii = compute_max_radii(best_centers)\n                print(f\"Iter {iter}: sum_radii = {np.sum(radii):.6f}\")\n        \n        return best_centers, best_score\n    \n    # Initialize with hexagonal packing\n    def hexagonal_init():\n        \"\"\"Initialize with approximate hexagonal packing.\"\"\"\n        centers = []\n        rows = 5\n        cols = 6\n        \n        dx = 1.0 / (cols + 1)\n        dy = 1.0 / (rows + 1)\n        \n        for row in range(rows):\n            offset = (dx / 2) if row % 2 == 1 else 0\n            for col in range(cols):\n                x = (col + 1) * dx + offset\n                y = (row + 1) * dy\n                if len(centers) < n:\n                    centers.append([x, y])\n        \n        # Add extra circle if needed\n        while len(centers) < n:\n            centers.append([0.5, 0.5])\n        \n        return np.array(centers[:n])\n    \n    # Try multiple initializations\n    best_overall_centers = None\n    best_overall_score = float('inf')\n    \n    # Hexagonal initialization\n    print(\"Starting hexagonal initialization...\")\n    init_centers = hexagonal_init()\n    centers, score = optimize_with_momentum(init_centers, iterations=3000, lr=0.015)\n    if score < best_overall_score:\n        best_overall_score = score\n        best_overall_centers = centers.copy()\n    \n    # Grid initialization with jitter\n    print(\"\\nStarting grid initialization...\")\n    grid_size = int(np.ceil(np.sqrt(n)))\n    init_centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5 + np.random.randn() * 0.1) / grid_size\n        y = (row + 0.5 + np.random.randn() * 0.1) / grid_size\n        init_centers.append([x, y])\n    init_centers = np.array(init_centers)\n    init_centers = np.clip(init_centers, 0.05, 0.95)\n    \n    centers, score = optimize_with_momentum(init_centers, iterations=3000, lr=0.015)\n    if score < best_overall_score:\n        best_overall_score = score\n        best_overall_centers = centers.copy()\n    \n    # Random restart from best\n    print(\"\\nRandom restart from best...\")\n    for restart in range(3):\n        init_centers = best_overall_centers + np.random.randn(n, 2) * 0.05\n        init_centers = np.clip(init_centers, 0.05, 0.95)\n        centers, score = optimize_with_momentum(init_centers, iterations=2000, lr=0.01)\n        if score < best_overall_score:\n            best_overall_score = score\n            best_overall_centers = centers.copy()\n    \n    # Final refinement with scipy\n    print(\"\\nFinal refinement with scipy.optimize...\")\n    \n    def objective_scipy(x):\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_bounds(x):\n        \"\"\"Keep centers away from boundaries.\"\"\"\n        centers = x.reshape(n, 2)\n        margin = 0.02\n        penalties = []\n        for i in range(n):\n            penalties.append(centers[i, 0] - margin)\n            penalties.append(centers[i, 1] - margin)\n            penalties.append(0.98 - centers[i, 0])\n            penalties.append(0.98 - centers[i, 1])\n        return np.array(penalties)\n    \n    x0 = best_overall_centers.flatten()\n    bounds = [(0.02, 0.98)] * (n * 2)\n    \n    result = minimize(\n        objective_scipy,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    final_centers = result.x.reshape(n, 2)\n    final_radii = compute_max_radii(final_centers)\n    final_sum = np.sum(final_radii)\n    \n    print(f\"\\nFinal sum of radii: {final_sum:.6f}\")\n    \n    return final_centers, final_radii, final_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:31:47.735874",
  "cost_data": null
}