{
  "trial_id": "trial_1_13",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses coordinate descent with multiple restarts and global refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    # Try multiple initialization strategies\n    for trial in range(15):\n        if trial < 5:\n            # Hexagonal-like grid\n            centers = initialize_hexagonal(n, trial)\n        elif trial < 10:\n            # Regular grid with perturbation\n            centers = initialize_grid(n, trial)\n        else:\n            # Random initialization\n            np.random.seed(trial)\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n        \n        # Coordinate descent optimization\n        centers, radii = coordinate_descent(centers, n, max_iterations=50)\n        \n        # Global refinement\n        centers, radii = global_refinement(centers, radii, n)\n        \n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef initialize_hexagonal(n, seed):\n    \"\"\"Initialize circles in a hexagonal-like pattern.\"\"\"\n    np.random.seed(seed)\n    centers = []\n    \n    # Create hexagonal grid\n    rows = int(np.sqrt(n * 2 / np.sqrt(3))) + 1\n    cols = int(np.sqrt(n * np.sqrt(3) / 2)) + 1\n    \n    dx = 1.0 / (cols + 1)\n    dy = 1.0 / (rows + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = dx * (j + 1)\n            y = dy * (i + 1)\n            \n            # Offset every other row\n            if i % 2 == 1:\n                x += dx / 2\n            \n            # Add small random perturbation\n            x += np.random.uniform(-0.02, 0.02)\n            y += np.random.uniform(-0.02, 0.02)\n            \n            x = np.clip(x, 0.1, 0.9)\n            y = np.clip(y, 0.1, 0.9)\n            \n            centers.append([x, y])\n        \n        if len(centers) >= n:\n            break\n    \n    # Fill remaining with random\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    return np.array(centers[:n])\n\n\ndef initialize_grid(n, seed):\n    \"\"\"Initialize circles in a regular grid with perturbation.\"\"\"\n    np.random.seed(seed)\n    cols = int(np.ceil(np.sqrt(n)))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    dx = 1.0 / (cols + 1)\n    dy = 1.0 / (rows + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = dx * (j + 1) + np.random.uniform(-0.03, 0.03)\n            y = dy * (i + 1) + np.random.uniform(-0.03, 0.03)\n            \n            x = np.clip(x, 0.1, 0.9)\n            y = np.clip(y, 0.1, 0.9)\n            \n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\n\ndef compute_max_radius(center, other_centers, other_radii):\n    \"\"\"Compute maximum radius for a circle at given center.\"\"\"\n    x, y = center\n    \n    # Distance to boundaries\n    max_r = min(x, y, 1 - x, 1 - y)\n    \n    # Distance to other circles\n    if len(other_centers) > 0:\n        distances = np.sqrt(np.sum((other_centers - center)**2, axis=1))\n        max_r_others = distances - other_radii\n        if len(max_r_others) > 0:\n            max_r = min(max_r, np.min(max_r_others))\n    \n    return max(0, max_r)\n\n\ndef optimize_single_circle(idx, centers, radii, n):\n    \"\"\"Optimize position of a single circle to maximize its radius.\"\"\"\n    # Keep other circles fixed\n    other_idx = [i for i in range(n) if i != idx]\n    other_centers = centers[other_idx]\n    other_radii = radii[other_idx]\n    \n    def objective(pos):\n        # Negative because we minimize\n        r = compute_max_radius(pos, other_centers, other_radii)\n        return -r\n    \n    # Try multiple starting points\n    best_pos = centers[idx].copy()\n    best_r = radii[idx]\n    \n    # Current position\n    result = minimize(objective, centers[idx], method='L-BFGS-B',\n                     bounds=[(0, 1), (0, 1)], options={'maxiter': 50})\n    if result.success:\n        r = compute_max_radius(result.x, other_centers, other_radii)\n        if r > best_r:\n            best_r = r\n            best_pos = result.x\n    \n    # Try a few random positions\n    for _ in range(3):\n        start = np.random.uniform(0.1, 0.9, 2)\n        result = minimize(objective, start, method='L-BFGS-B',\n                         bounds=[(0, 1), (0, 1)], options={'maxiter': 30})\n        if result.success:\n            r = compute_max_radius(result.x, other_centers, other_radii)\n            if r > best_r:\n                best_r = r\n                best_pos = result.x\n    \n    return best_pos, best_r\n\n\ndef coordinate_descent(centers, n, max_iterations=50):\n    \"\"\"Perform coordinate descent optimization.\"\"\"\n    centers = centers.copy()\n    radii = np.zeros(n)\n    \n    # Initial radius computation\n    for i in range(n):\n        other_idx = [j for j in range(n) if j != i]\n        radii[i] = compute_max_radius(centers[i], centers[other_idx], radii[other_idx])\n    \n    no_improvement_count = 0\n    \n    for iteration in range(max_iterations):\n        old_sum = np.sum(radii)\n        \n        # Random order for this iteration\n        order = np.random.permutation(n)\n        \n        for idx in order:\n            # Optimize this circle\n            new_pos, new_r = optimize_single_circle(idx, centers, radii, n)\n            \n            if new_r > radii[idx] * 1.001:  # At least 0.1% improvement\n                centers[idx] = new_pos\n                radii[idx] = new_r\n                \n                # Update radii of other circles\n                for i in range(n):\n                    if i != idx:\n                        other_idx = [j for j in range(n) if j != i]\n                        radii[i] = compute_max_radius(centers[i], centers[other_idx], radii[other_idx])\n        \n        new_sum = np.sum(radii)\n        improvement = new_sum - old_sum\n        \n        if improvement < 1e-5:\n            no_improvement_count += 1\n            if no_improvement_count >= 5:\n                # Random restart for a few circles\n                if iteration < max_iterations - 5:\n                    num_restart = min(5, n // 4)\n                    restart_idx = np.random.choice(n, num_restart, replace=False)\n                    for idx in restart_idx:\n                        centers[idx] = np.random.uniform(0.1, 0.9, 2)\n                        radii[idx] = compute_max_radius(centers[idx], \n                                                       centers[[i for i in range(n) if i != idx]], \n                                                       radii[[i for i in range(n) if i != idx]])\n                    no_improvement_count = 0\n                else:\n                    break\n        else:\n            no_improvement_count = 0\n    \n    return centers, radii\n\n\ndef global_refinement(centers, radii, n):\n    \"\"\"Global refinement using scipy.optimize.\"\"\"\n    # Flatten centers for optimization\n    x0 = centers.flatten()\n    \n    def objective(x):\n        c = x.reshape(n, 2)\n        r = np.zeros(n)\n        \n        # Compute radii\n        for i in range(n):\n            other_idx = [j for j in range(n) if j != i]\n            r[i] = compute_max_radius(c[i], c[other_idx], r[other_idx])\n        \n        return -np.sum(r)  # Negative for minimization\n    \n    def constraint_bounds(x):\n        \"\"\"All centers must be within bounds considering their radii.\"\"\"\n        c = x.reshape(n, 2)\n        r = np.zeros(n)\n        \n        for i in range(n):\n            other_idx = [j for j in range(n) if j != i]\n            r[i] = compute_max_radius(c[i], c[other_idx], r[other_idx])\n        \n        violations = []\n        for i in range(n):\n            violations.append(c[i, 0] - r[i])  # x - r >= 0\n            violations.append(c[i, 1] - r[i])  # y - r >= 0\n            violations.append(1 - c[i, 0] - r[i])  # 1 - x - r >= 0\n            violations.append(1 - c[i, 1] - r[i])  # 1 - y - r >= 0\n        \n        return np.array(violations)\n    \n    bounds = [(0, 1) for _ in range(2 * n)]\n    \n    try:\n        result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                         options={'maxiter': 200, 'ftol': 1e-8})\n        \n        if result.success or result.fun < objective(x0):\n            centers = result.x.reshape(n, 2)\n            \n            # Recompute radii\n            radii = np.zeros(n)\n            for i in range(n):\n                other_idx = [j for j in range(n) if j != i]\n                radii[i] = compute_max_radius(centers[i], centers[other_idx], radii[other_idx])\n    except:\n        pass\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.449898321212379,
    "target_ratio": 0.9297526835720604,
    "combined_score": 0.9297526835720604,
    "eval_time": 209.45442581176758,
    "error": null
  },
  "prompt": "Create a coordinate descent optimization:\n\n1. Initialize with good pattern (hexagonal or grid)\n2. Iteratively optimize each circle's position while keeping others fixed\n3. For each circle, find position that maximizes its radius\n4. Sweep through all circles multiple times\n5. Add random restarts when improvement stalls\n6. After convergence, run global scipy.optimize refinement\n7. Repeat entire process 10+ times with different initializations\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses coordinate descent with multiple restarts and global refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = 0\n    \n    # Try multiple initialization strategies\n    for trial in range(15):\n        if trial < 5:\n            # Hexagonal-like grid\n            centers = initialize_hexagonal(n, trial)\n        elif trial < 10:\n            # Regular grid with perturbation\n            centers = initialize_grid(n, trial)\n        else:\n            # Random initialization\n            np.random.seed(trial)\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n        \n        # Coordinate descent optimization\n        centers, radii = coordinate_descent(centers, n, max_iterations=50)\n        \n        # Global refinement\n        centers, radii = global_refinement(centers, radii, n)\n        \n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef initialize_hexagonal(n, seed):\n    \"\"\"Initialize circles in a hexagonal-like pattern.\"\"\"\n    np.random.seed(seed)\n    centers = []\n    \n    # Create hexagonal grid\n    rows = int(np.sqrt(n * 2 / np.sqrt(3))) + 1\n    cols = int(np.sqrt(n * np.sqrt(3) / 2)) + 1\n    \n    dx = 1.0 / (cols + 1)\n    dy = 1.0 / (rows + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = dx * (j + 1)\n            y = dy * (i + 1)\n            \n            # Offset every other row\n            if i % 2 == 1:\n                x += dx / 2\n            \n            # Add small random perturbation\n            x += np.random.uniform(-0.02, 0.02)\n            y += np.random.uniform(-0.02, 0.02)\n            \n            x = np.clip(x, 0.1, 0.9)\n            y = np.clip(y, 0.1, 0.9)\n            \n            centers.append([x, y])\n        \n        if len(centers) >= n:\n            break\n    \n    # Fill remaining with random\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    return np.array(centers[:n])\n\n\ndef initialize_grid(n, seed):\n    \"\"\"Initialize circles in a regular grid with perturbation.\"\"\"\n    np.random.seed(seed)\n    cols = int(np.ceil(np.sqrt(n)))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    dx = 1.0 / (cols + 1)\n    dy = 1.0 / (rows + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = dx * (j + 1) + np.random.uniform(-0.03, 0.03)\n            y = dy * (i + 1) + np.random.uniform(-0.03, 0.03)\n            \n            x = np.clip(x, 0.1, 0.9)\n            y = np.clip(y, 0.1, 0.9)\n            \n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\n\ndef compute_max_radius(center, other_centers, other_radii):\n    \"\"\"Compute maximum radius for a circle at given center.\"\"\"\n    x, y = center\n    \n    # Distance to boundaries\n    max_r = min(x, y, 1 - x, 1 - y)\n    \n    # Distance to other circles\n    if len(other_centers) > 0:\n        distances = np.sqrt(np.sum((other_centers - center)**2, axis=1))\n        max_r_others = distances - other_radii\n        if len(max_r_others) > 0:\n            max_r = min(max_r, np.min(max_r_others))\n    \n    return max(0, max_r)\n\n\ndef optimize_single_circle(idx, centers, radii, n):\n    \"\"\"Optimize position of a single circle to maximize its radius.\"\"\"\n    # Keep other circles fixed\n    other_idx = [i for i in range(n) if i != idx]\n    other_centers = centers[other_idx]\n    other_radii = radii[other_idx]\n    \n    def objective(pos):\n        # Negative because we minimize\n        r = compute_max_radius(pos, other_centers, other_radii)\n        return -r\n    \n    # Try multiple starting points\n    best_pos = centers[idx].copy()\n    best_r = radii[idx]\n    \n    # Current position\n    result = minimize(objective, centers[idx], method='L-BFGS-B',\n                     bounds=[(0, 1), (0, 1)], options={'maxiter': 50})\n    if result.success:\n        r = compute_max_radius(result.x, other_centers, other_radii)\n        if r > best_r:\n            best_r = r\n            best_pos = result.x\n    \n    # Try a few random positions\n    for _ in range(3):\n        start = np.random.uniform(0.1, 0.9, 2)\n        result = minimize(objective, start, method='L-BFGS-B',\n                         bounds=[(0, 1), (0, 1)], options={'maxiter': 30})\n        if result.success:\n            r = compute_max_radius(result.x, other_centers, other_radii)\n            if r > best_r:\n                best_r = r\n                best_pos = result.x\n    \n    return best_pos, best_r\n\n\ndef coordinate_descent(centers, n, max_iterations=50):\n    \"\"\"Perform coordinate descent optimization.\"\"\"\n    centers = centers.copy()\n    radii = np.zeros(n)\n    \n    # Initial radius computation\n    for i in range(n):\n        other_idx = [j for j in range(n) if j != i]\n        radii[i] = compute_max_radius(centers[i], centers[other_idx], radii[other_idx])\n    \n    no_improvement_count = 0\n    \n    for iteration in range(max_iterations):\n        old_sum = np.sum(radii)\n        \n        # Random order for this iteration\n        order = np.random.permutation(n)\n        \n        for idx in order:\n            # Optimize this circle\n            new_pos, new_r = optimize_single_circle(idx, centers, radii, n)\n            \n            if new_r > radii[idx] * 1.001:  # At least 0.1% improvement\n                centers[idx] = new_pos\n                radii[idx] = new_r\n                \n                # Update radii of other circles\n                for i in range(n):\n                    if i != idx:\n                        other_idx = [j for j in range(n) if j != i]\n                        radii[i] = compute_max_radius(centers[i], centers[other_idx], radii[other_idx])\n        \n        new_sum = np.sum(radii)\n        improvement = new_sum - old_sum\n        \n        if improvement < 1e-5:\n            no_improvement_count += 1\n            if no_improvement_count >= 5:\n                # Random restart for a few circles\n                if iteration < max_iterations - 5:\n                    num_restart = min(5, n // 4)\n                    restart_idx = np.random.choice(n, num_restart, replace=False)\n                    for idx in restart_idx:\n                        centers[idx] = np.random.uniform(0.1, 0.9, 2)\n                        radii[idx] = compute_max_radius(centers[idx], \n                                                       centers[[i for i in range(n) if i != idx]], \n                                                       radii[[i for i in range(n) if i != idx]])\n                    no_improvement_count = 0\n                else:\n                    break\n        else:\n            no_improvement_count = 0\n    \n    return centers, radii\n\n\ndef global_refinement(centers, radii, n):\n    \"\"\"Global refinement using scipy.optimize.\"\"\"\n    # Flatten centers for optimization\n    x0 = centers.flatten()\n    \n    def objective(x):\n        c = x.reshape(n, 2)\n        r = np.zeros(n)\n        \n        # Compute radii\n        for i in range(n):\n            other_idx = [j for j in range(n) if j != i]\n            r[i] = compute_max_radius(c[i], c[other_idx], r[other_idx])\n        \n        return -np.sum(r)  # Negative for minimization\n    \n    def constraint_bounds(x):\n        \"\"\"All centers must be within bounds considering their radii.\"\"\"\n        c = x.reshape(n, 2)\n        r = np.zeros(n)\n        \n        for i in range(n):\n            other_idx = [j for j in range(n) if j != i]\n            r[i] = compute_max_radius(c[i], c[other_idx], r[other_idx])\n        \n        violations = []\n        for i in range(n):\n            violations.append(c[i, 0] - r[i])  # x - r >= 0\n            violations.append(c[i, 1] - r[i])  # y - r >= 0\n            violations.append(1 - c[i, 0] - r[i])  # 1 - x - r >= 0\n            violations.append(1 - c[i, 1] - r[i])  # 1 - y - r >= 0\n        \n        return np.array(violations)\n    \n    bounds = [(0, 1) for _ in range(2 * n)]\n    \n    try:\n        result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds,\n                         options={'maxiter': 200, 'ftol': 1e-8})\n        \n        if result.success or result.fun < objective(x0):\n            centers = result.x.reshape(n, 2)\n            \n            # Recompute radii\n            radii = np.zeros(n)\n            for i in range(n):\n                other_idx = [j for j in range(n) if j != i]\n                radii[i] = compute_max_radius(centers[i], centers[other_idx], radii[other_idx])\n    except:\n        pass\n    \n    return centers, radii\n\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:30:23.589014",
  "cost_data": null
}