{
  "trial_id": "trial_1_3",
  "generation": 1,
  "parent_id": "trial_0_2",
  "code": "",
  "metrics": {},
  "prompt": "Improve the basic scipy optimization with better initialization and constraint handling.\n\nBase code from trial_0_2:\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Decision variables: [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n    # Total: 3*n variables\n    \n    def objective(vars):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n        radii = vars[2::3]  # Every third element starting from index 2\n        return -np.sum(radii)\n    \n    def create_constraints():\n        \"\"\"Create constraint functions for optimization\"\"\"\n        constraints = []\n        \n        # Boundary constraints: each circle must be inside [0,1] x [0,1]\n        for i in range(n):\n            x_idx = 3*i\n            y_idx = 3*i + 1\n            r_idx = 3*i + 2\n            \n            # x - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, xi=x_idx, ri=r_idx: vars[xi] - vars[ri]\n            })\n            # x + r <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, xi=x_idx, ri=r_idx: 1 - vars[xi] - vars[ri]\n            })\n            # y - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, yi=y_idx, ri=r_idx: vars[yi] - vars[ri]\n            })\n            # y + r <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, yi=y_idx, ri=r_idx: 1 - vars[yi] - vars[ri]\n            })\n        \n        # Non-overlap constraints: distance between centers > sum of radii\n        for i in range(n):\n            for j in range(i+1, n):\n                xi_idx = 3*i\n                yi_idx = 3*i + 1\n                ri_idx = 3*i + 2\n                xj_idx = 3*j\n                yj_idx = 3*j + 1\n                rj_idx = 3*j + 2\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda vars, xi=xi_idx, yi=yi_idx, ri=ri_idx, \n                                  xj=xj_idx, yj=yj_idx, rj=rj_idx:\n                        np.sqrt((vars[xi] - vars[xj])**2 + (vars[yi] - vars[yj])**2) \n                        - vars[ri] - vars[rj]\n                })\n        \n        return constraints\n    \n    # Initialize with a grid-based layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_radius = 0.5 / grid_size\n    \n    x0 = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        r = initial_radius * 0.8  # Slightly smaller to ensure feasibility\n        x0.extend([x, y, r])\n    \n    x0 = np.array(x0)\n    \n    # Bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x\n        bounds.append((0, 1))  # y\n        bounds.append((0, 0.5))  # r\n    \n    # Create constraints\n    constraints = create_constraints()\n    \n    # Optimize with multiple random restarts to find better solutions\n    best_result = None\n    best_sum = -np.inf\n    \n    # Try multiple initial configurations\n    for attempt in range(3):\n        if attempt == 0:\n            # Use grid initialization\n            x_init = x0.copy()\n        else:\n            # Random initialization with small radii\n            x_init = []\n            for i in range(n):\n                x = np.random.uniform(0.1, 0.9)\n                y = np.random.uniform(0.1, 0.9)\n                r = np.random.uniform(0.01, 0.05)\n                x_init.extend([x, y, r])\n            x_init = np.array(x_init)\n        \n        try:\n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.success or result.fun < best_sum:\n                current_sum = -result.fun\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result\n        except:\n            continue\n    \n    # If optimization failed, use grid layout with maximum feasible radii\n    if best_result is None:\n        centers = []\n        radii = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            r = 0.4 / grid_size\n            centers.append([x, y])\n            radii.append(r)\n        centers = np.array(centers)\n        radii = np.array(radii)\n        sum_radii = np.sum(radii)\n    else:\n        # Extract solution\n        solution = best_result.x\n        centers = []\n        radii = []\n        for i in range(n):\n            x = solution[3*i]\n            y = solution[3*i + 1]\n            r = solution[3*i + 2]\n            centers.append([x, y])\n            radii.append(r)\n        \n        centers = np.array(centers)\n        radii = np.array(radii)\n        sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nImprovements:\n1. Add 5-10 different initialization strategies (hexagonal, boundary-focused, spiral, etc.)\n2. Use trust-constr method in addition to SLSQP\n3. Add gradient information for faster convergence\n4. Implement adaptive constraint tightness\n5. Post-process to expand radii incrementally\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(vars):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n        radii = vars[2::3]\n        return -np.sum(radii)\n    \n    def objective_grad(vars):\n        \"\"\"Gradient of objective function\"\"\"\n        grad = np.zeros_like(vars)\n        grad[2::3] = -1  # Derivative w.r.t. radii\n        return grad\n    \n    def get_centers_radii(vars):\n        \"\"\"Extract centers and radii from decision variables\"\"\"\n        centers = vars.reshape(n, 3)[:, :2]\n        radii = vars.reshape(n, 3)[:, 2]\n        return centers, radii\n    \n    def create_nonlinear_constraints():\n        \"\"\"Create nonlinear constraints for trust-constr\"\"\"\n        # Non-overlap constraints\n        def overlap_constraint(vars):\n            centers, radii = get_centers_radii(vars)\n            distances = pdist(centers)\n            radii_sums = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    radii_sums.append(radii[i] + radii[j])\n            radii_sums = np.array(radii_sums)\n            return distances - radii_sums\n        \n        return NonlinearConstraint(overlap_constraint, 0, np.inf)\n    \n    def create_constraints_slsqp():\n        \"\"\"Create constraint functions for SLSQP\"\"\"\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            x_idx = 3*i\n            y_idx = 3*i + 1\n            r_idx = 3*i + 2\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, xi=x_idx, ri=r_idx: vars[xi] - vars[ri]\n            })\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, xi=x_idx, ri=r_idx: 1 - vars[xi] - vars[ri]\n            })\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, yi=y_idx, ri=r_idx: vars[yi] - vars[ri]\n            })\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, yi=y_idx, ri=r_idx: 1 - vars[yi] - vars[ri]\n            })\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                xi_idx = 3*i\n                yi_idx = 3*i + 1\n                ri_idx = 3*i + 2\n                xj_idx = 3*j\n                yj_idx = 3*j + 1\n                rj_idx = 3*j + 2\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda vars, xi=xi_idx, yi=yi_idx, ri=ri_idx, \n                                  xj=xj_idx, yj=yj_idx, rj=rj_idx:\n                        np.sqrt((vars[xi] - vars[xj])**2 + (vars[yi] - vars[yj])**2) \n                        - vars[ri] - vars[rj]\n                })\n        \n        return constraints\n    \n    def init_grid(n, grid_size=None):\n        \"\"\"Grid-based initialization\"\"\"\n        if grid_size is None:\n            grid_size = int(np.ceil(np.sqrt(n)))\n        initial_radius = 0.45 / grid_size\n        \n        x0 = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            r = initial_radius\n            x0.extend([x, y, r])\n        return np.array(x0)\n    \n    def init_hexagonal(n):\n        \"\"\"Hexagonal packing initialization\"\"\"\n        x0 = []\n        hex_spacing = 0.18\n        row = 0\n        col = 0\n        for i in range(n):\n            if row % 2 == 0:\n                x = 0.1 + col * hex_spacing\n            else:\n                x = 0.1 + col * hex_spacing + hex_spacing / 2\n            y = 0.1 + row * hex_spacing * 0.866\n            \n            # Wrap around if out of bounds\n            if x > 0.9 or y > 0.9:\n                col = 0\n                row += 1\n                if row % 2 == 0:\n                    x = 0.1 + col * hex_spacing\n                else:\n                    x = 0.1 + col * hex_spacing + hex_spacing / 2\n                y = 0.1 + row * hex_spacing * 0.866\n            \n            r = 0.08\n            x0.extend([x, y, r])\n            col += 1\n            \n            if col * hex_spacing > 0.8:\n                col = 0\n                row += 1\n        \n        return np.array(x0)\n    \n    def init_boundary_focused(n):\n        \"\"\"Place circles along boundary first\"\"\"\n        x0 = []\n        boundary_circles = min(n, 16)\n        interior_circles = n - boundary_circles\n        \n        # Boundary circles\n        for i in range(boundary_circles):\n            angle = 2 * np.pi * i / boundary_circles\n            # Place on boundary with some margin\n            margin = 0.08\n            if i % 4 == 0:  # bottom\n                x = 0.5 + 0.4 * np.cos(angle)\n                y = margin\n            elif i % 4 == 1:  # right\n                x = 1 - margin\n                y = 0.5 + 0.4 * np.sin(angle)\n            elif i % 4 == 2:  # top\n                x = 0.5 + 0.4 * np.cos(angle)\n                y = 1 - margin\n            else:  # left\n                x = margin\n                y = 0.5 + 0.4 * np.sin(angle)\n            \n            x = np.clip(x, 0.08, 0.92)\n            y = np.clip(y, 0.08, 0.92)\n            r = 0.07\n            x0.extend([x, y, r])\n        \n        # Interior circles in grid\n        if interior_circles > 0:\n            grid_size = int(np.ceil(np.sqrt(interior_circles)))\n            for i in range(interior_circles):\n                row = i // grid_size\n                col = i % grid_size\n                x = 0.3 + (col + 0.5) * 0.4 / grid_size\n                y = 0.3 + (row + 0.5) * 0.4 / grid_size\n                r = 0.06\n                x0.extend([x, y, r])\n        \n        return np.array(x0)\n    \n    def init_spiral(n):\n        \"\"\"Spiral initialization\"\"\"\n        x0 = []\n        angle = 0\n        radius = 0.05\n        for i in range(n):\n            x = 0.5 + radius * np.cos(angle)\n            y = 0.5 + radius * np.sin(angle)\n            x = np.clip(x, 0.08, 0.92)\n            y = np.clip(y, 0.08, 0.92)\n            r = 0.06\n            x0.extend([x, y, r])\n            \n            angle += 0.8\n            radius += 0.015\n            if radius > 0.4:\n                radius = 0.05\n        \n        return np.array(x0)\n    \n    def init_random_clustered(n):\n        \"\"\"Random initialization with clustering\"\"\"\n        x0 = []\n        num_clusters = 4\n        for i in range(n):\n            cluster = i % num_clusters\n            if cluster == 0:\n                cx, cy = 0.25, 0.25\n            elif cluster == 1:\n                cx, cy = 0.75, 0.25\n            elif cluster == 2:\n                cx, cy = 0.25, 0.75\n            else:\n                cx, cy = 0.75, 0.75\n            \n            x = cx + np.random.uniform(-0.15, 0.15)\n            y = cy + np.random.uniform(-0.15, 0.15)\n            x = np.clip(x, 0.08, 0.92)\n            y = np.clip(y, 0.08, 0.92)\n            r = np.random.uniform(0.04, 0.08)\n            x0.extend([x, y, r])\n        \n        return np.array(x0)\n    \n    def init_concentric(n):\n        \"\"\"Concentric circles initialization\"\"\"\n        x0 = []\n        circles_per_ring = [8, 12, 6]\n        ring_radii = [0.15, 0.3, 0.45]\n        idx = 0\n        \n        for ring_idx, (num_in_ring, ring_r) in enumerate(zip(circles_per_ring, ring_radii)):\n            for i in range(num_in_ring):\n                if idx >= n:\n                    break\n                angle = 2 * np.pi * i / num_in_ring\n                x = 0.5 + ring_r * np.cos(angle)\n                y = 0.5 + ring_r * np.sin(angle)\n                x = np.clip(x, 0.08, 0.92)\n                y = np.clip(y, 0.08, 0.92)\n                r = 0.06\n                x0.extend([x, y, r])\n                idx += 1\n        \n        # Fill remaining with center\n        while idx < n:\n            x = 0.5 + np.random.uniform(-0.1, 0.1)\n            y = 0.5 + np.random.uniform(-0.1, 0.1)\n            r = 0.05\n            x0.extend([x, y, r])\n            idx += 1\n        \n        return np.array(x0)\n    \n    def post_process_expand(centers, radii):\n        \"\"\"Incrementally expand radii while maintaining feasibility\"\"\"\n        max_iterations = 100\n        expansion_rate = 0.001\n        \n        for _ in range(max_iterations):\n            improved = False\n            for i in range(n):\n                # Try expanding this circle\n                new_radii = radii.copy()\n                new_radii[i] += expansion_rate\n                \n                # Check boundary constraints\n                if (centers[i, 0] - new_radii[i] < 0 or \n                    centers[i, 0] + new_radii[i] > 1 or\n                    centers[i, 1] - new_radii[i] < 0 or \n                    centers[i, 1] + new_radii[i] > 1):\n                    continue\n                \n                # Check overlap constraints\n                feasible = True\n                for j in range(n):\n                    if i != j:\n                        dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                     (centers[i, 1] - centers[j, 1])**2)\n                        if dist < new_radii[i] + new_radii[j]:\n                            feasible = False\n                            break\n                \n                if feasible:\n                    radii[i] = new_radii[i]\n                    improved = True\n            \n            if not improved:\n                break\n        \n        return radii\n    \n    # Bounds\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x\n        bounds.append((0, 1))  # y\n        bounds.append((0, 0.5))  # r\n    \n    # Try multiple initialization strategies\n    init_strategies = [\n        ('grid', init_grid(n)),\n        ('grid_tight', init_grid(n, grid_size=6)),\n        ('hexagonal', init_hexagonal(n)),\n        ('boundary', init_boundary_focused(n)),\n        ('spiral', init_spiral(n)),\n        ('clustered', init_random_clustered(n)),\n        ('concentric', init_concentric(n)),\n    ]\n    \n    # Add random initializations\n    for i in range(3):\n        x_init = []\n        for j in range(n):\n            x = np.random.uniform(0.1, 0.9)\n            y = np.random.uniform(0.1, 0.9)\n            r = np.random.uniform(0.03, 0.08)\n            x_init.extend([x, y, r])\n        init_strategies.append((f'random_{i}', np.array(x_init)))\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Try each initialization with both SLSQP and trust-constr\n    for strategy_name, x_init in init_strategies:\n        # Try SLSQP\n        try:\n            constraints_slsqp = create_constraints_slsqp()\n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                jac=objective_grad,\n                bounds=bounds,\n                constraints=constraints_slsqp,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.success or -result.fun > best_sum:\n                current_sum = -result.fun\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result\n        except:\n            pass\n        \n        # Try trust-constr for some strategies\n        if strategy_name in ['hexagonal', 'boundary', 'grid']:\n            try:\n                # Create bounds for trust-constr\n                lb = np.array([0, 0, 0] * n)\n                ub = np.array([1, 1, 0.5] * n)\n                bounds_tc = [(lb[i], ub[i]) for i in range(len(lb))]\n                \n                nlc = create_nonlinear_constraints()\n                \n                result = minimize(\n                    objective,\n                    x_init,\n                    method='trust-constr',\n                    jac=objective_grad,\n                    bounds=bounds_tc,\n                    constraints=nlc,\n                    options={'maxiter': 500, 'verbose': 0}\n                )\n                \n                if result.success or -result.fun > best_sum:\n                    current_sum = -result.fun\n                    if current_sum > best_sum:\n                        best_sum = current_sum\n                        best_result = result\n            except:\n                pass\n    \n    # Extract best solution\n    if best_result is None:\n        # Fallback to grid\n        x_init = init_grid(n)\n        centers = x_init.reshape(n, 3)[:, :2]\n        radii = x_init.reshape(n, 3)[:, 2]\n    else:\n        solution = best_result.x\n        centers",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(vars):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n        radii = vars[2::3]\n        return -np.sum(radii)\n    \n    def objective_grad(vars):\n        \"\"\"Gradient of objective function\"\"\"\n        grad = np.zeros_like(vars)\n        grad[2::3] = -1  # Derivative w.r.t. radii\n        return grad\n    \n    def get_centers_radii(vars):\n        \"\"\"Extract centers and radii from decision variables\"\"\"\n        centers = vars.reshape(n, 3)[:, :2]\n        radii = vars.reshape(n, 3)[:, 2]\n        return centers, radii\n    \n    def create_nonlinear_constraints():\n        \"\"\"Create nonlinear constraints for trust-constr\"\"\"\n        # Non-overlap constraints\n        def overlap_constraint(vars):\n            centers, radii = get_centers_radii(vars)\n            distances = pdist(centers)\n            radii_sums = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    radii_sums.append(radii[i] + radii[j])\n            radii_sums = np.array(radii_sums)\n            return distances - radii_sums\n        \n        return NonlinearConstraint(overlap_constraint, 0, np.inf)\n    \n    def create_constraints_slsqp():\n        \"\"\"Create constraint functions for SLSQP\"\"\"\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            x_idx = 3*i\n            y_idx = 3*i + 1\n            r_idx = 3*i + 2\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, xi=x_idx, ri=r_idx: vars[xi] - vars[ri]\n            })\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, xi=x_idx, ri=r_idx: 1 - vars[xi] - vars[ri]\n            })\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, yi=y_idx, ri=r_idx: vars[yi] - vars[ri]\n            })\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, yi=y_idx, ri=r_idx: 1 - vars[yi] - vars[ri]\n            })\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                xi_idx = 3*i\n                yi_idx = 3*i + 1\n                ri_idx = 3*i + 2\n                xj_idx = 3*j\n                yj_idx = 3*j + 1\n                rj_idx = 3*j + 2\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda vars, xi=xi_idx, yi=yi_idx, ri=ri_idx, \n                                  xj=xj_idx, yj=yj_idx, rj=rj_idx:\n                        np.sqrt((vars[xi] - vars[xj])**2 + (vars[yi] - vars[yj])**2) \n                        - vars[ri] - vars[rj]\n                })\n        \n        return constraints\n    \n    def init_grid(n, grid_size=None):\n        \"\"\"Grid-based initialization\"\"\"\n        if grid_size is None:\n            grid_size = int(np.ceil(np.sqrt(n)))\n        initial_radius = 0.45 / grid_size\n        \n        x0 = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            r = initial_radius\n            x0.extend([x, y, r])\n        return np.array(x0)\n    \n    def init_hexagonal(n):\n        \"\"\"Hexagonal packing initialization\"\"\"\n        x0 = []\n        hex_spacing = 0.18\n        row = 0\n        col = 0\n        for i in range(n):\n            if row % 2 == 0:\n                x = 0.1 + col * hex_spacing\n            else:\n                x = 0.1 + col * hex_spacing + hex_spacing / 2\n            y = 0.1 + row * hex_spacing * 0.866\n            \n            # Wrap around if out of bounds\n            if x > 0.9 or y > 0.9:\n                col = 0\n                row += 1\n                if row % 2 == 0:\n                    x = 0.1 + col * hex_spacing\n                else:\n                    x = 0.1 + col * hex_spacing + hex_spacing / 2\n                y = 0.1 + row * hex_spacing * 0.866\n            \n            r = 0.08\n            x0.extend([x, y, r])\n            col += 1\n            \n            if col * hex_spacing > 0.8:\n                col = 0\n                row += 1\n        \n        return np.array(x0)\n    \n    def init_boundary_focused(n):\n        \"\"\"Place circles along boundary first\"\"\"\n        x0 = []\n        boundary_circles = min(n, 16)\n        interior_circles = n - boundary_circles\n        \n        # Boundary circles\n        for i in range(boundary_circles):\n            angle = 2 * np.pi * i / boundary_circles\n            # Place on boundary with some margin\n            margin = 0.08\n            if i % 4 == 0:  # bottom\n                x = 0.5 + 0.4 * np.cos(angle)\n                y = margin\n            elif i % 4 == 1:  # right\n                x = 1 - margin\n                y = 0.5 + 0.4 * np.sin(angle)\n            elif i % 4 == 2:  # top\n                x = 0.5 + 0.4 * np.cos(angle)\n                y = 1 - margin\n            else:  # left\n                x = margin\n                y = 0.5 + 0.4 * np.sin(angle)\n            \n            x = np.clip(x, 0.08, 0.92)\n            y = np.clip(y, 0.08, 0.92)\n            r = 0.07\n            x0.extend([x, y, r])\n        \n        # Interior circles in grid\n        if interior_circles > 0:\n            grid_size = int(np.ceil(np.sqrt(interior_circles)))\n            for i in range(interior_circles):\n                row = i // grid_size\n                col = i % grid_size\n                x = 0.3 + (col + 0.5) * 0.4 / grid_size\n                y = 0.3 + (row + 0.5) * 0.4 / grid_size\n                r = 0.06\n                x0.extend([x, y, r])\n        \n        return np.array(x0)\n    \n    def init_spiral(n):\n        \"\"\"Spiral initialization\"\"\"\n        x0 = []\n        angle = 0\n        radius = 0.05\n        for i in range(n):\n            x = 0.5 + radius * np.cos(angle)\n            y = 0.5 + radius * np.sin(angle)\n            x = np.clip(x, 0.08, 0.92)\n            y = np.clip(y, 0.08, 0.92)\n            r = 0.06\n            x0.extend([x, y, r])\n            \n            angle += 0.8\n            radius += 0.015\n            if radius > 0.4:\n                radius = 0.05\n        \n        return np.array(x0)\n    \n    def init_random_clustered(n):\n        \"\"\"Random initialization with clustering\"\"\"\n        x0 = []\n        num_clusters = 4\n        for i in range(n):\n            cluster = i % num_clusters\n            if cluster == 0:\n                cx, cy = 0.25, 0.25\n            elif cluster == 1:\n                cx, cy = 0.75, 0.25\n            elif cluster == 2:\n                cx, cy = 0.25, 0.75\n            else:\n                cx, cy = 0.75, 0.75\n            \n            x = cx + np.random.uniform(-0.15, 0.15)\n            y = cy + np.random.uniform(-0.15, 0.15)\n            x = np.clip(x, 0.08, 0.92)\n            y = np.clip(y, 0.08, 0.92)\n            r = np.random.uniform(0.04, 0.08)\n            x0.extend([x, y, r])\n        \n        return np.array(x0)\n    \n    def init_concentric(n):\n        \"\"\"Concentric circles initialization\"\"\"\n        x0 = []\n        circles_per_ring = [8, 12, 6]\n        ring_radii = [0.15, 0.3, 0.45]\n        idx = 0\n        \n        for ring_idx, (num_in_ring, ring_r) in enumerate(zip(circles_per_ring, ring_radii)):\n            for i in range(num_in_ring):\n                if idx >= n:\n                    break\n                angle = 2 * np.pi * i / num_in_ring\n                x = 0.5 + ring_r * np.cos(angle)\n                y = 0.5 + ring_r * np.sin(angle)\n                x = np.clip(x, 0.08, 0.92)\n                y = np.clip(y, 0.08, 0.92)\n                r = 0.06\n                x0.extend([x, y, r])\n                idx += 1\n        \n        # Fill remaining with center\n        while idx < n:\n            x = 0.5 + np.random.uniform(-0.1, 0.1)\n            y = 0.5 + np.random.uniform(-0.1, 0.1)\n            r = 0.05\n            x0.extend([x, y, r])\n            idx += 1\n        \n        return np.array(x0)\n    \n    def post_process_expand(centers, radii):\n        \"\"\"Incrementally expand radii while maintaining feasibility\"\"\"\n        max_iterations = 100\n        expansion_rate = 0.001\n        \n        for _ in range(max_iterations):\n            improved = False\n            for i in range(n):\n                # Try expanding this circle\n                new_radii = radii.copy()\n                new_radii[i] += expansion_rate\n                \n                # Check boundary constraints\n                if (centers[i, 0] - new_radii[i] < 0 or \n                    centers[i, 0] + new_radii[i] > 1 or\n                    centers[i, 1] - new_radii[i] < 0 or \n                    centers[i, 1] + new_radii[i] > 1):\n                    continue\n                \n                # Check overlap constraints\n                feasible = True\n                for j in range(n):\n                    if i != j:\n                        dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                     (centers[i, 1] - centers[j, 1])**2)\n                        if dist < new_radii[i] + new_radii[j]:\n                            feasible = False\n                            break\n                \n                if feasible:\n                    radii[i] = new_radii[i]\n                    improved = True\n            \n            if not improved:\n                break\n        \n        return radii\n    \n    # Bounds\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x\n        bounds.append((0, 1))  # y\n        bounds.append((0, 0.5))  # r\n    \n    # Try multiple initialization strategies\n    init_strategies = [\n        ('grid', init_grid(n)),\n        ('grid_tight', init_grid(n, grid_size=6)),\n        ('hexagonal', init_hexagonal(n)),\n        ('boundary', init_boundary_focused(n)),\n        ('spiral', init_spiral(n)),\n        ('clustered', init_random_clustered(n)),\n        ('concentric', init_concentric(n)),\n    ]\n    \n    # Add random initializations\n    for i in range(3):\n        x_init = []\n        for j in range(n):\n            x = np.random.uniform(0.1, 0.9)\n            y = np.random.uniform(0.1, 0.9)\n            r = np.random.uniform(0.03, 0.08)\n            x_init.extend([x, y, r])\n        init_strategies.append((f'random_{i}', np.array(x_init)))\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Try each initialization with both SLSQP and trust-constr\n    for strategy_name, x_init in init_strategies:\n        # Try SLSQP\n        try:\n            constraints_slsqp = create_constraints_slsqp()\n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                jac=objective_grad,\n                bounds=bounds,\n                constraints=constraints_slsqp,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.success or -result.fun > best_sum:\n                current_sum = -result.fun\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result\n        except:\n            pass\n        \n        # Try trust-constr for some strategies\n        if strategy_name in ['hexagonal', 'boundary', 'grid']:\n            try:\n                # Create bounds for trust-constr\n                lb = np.array([0, 0, 0] * n)\n                ub = np.array([1, 1, 0.5] * n)\n                bounds_tc = [(lb[i], ub[i]) for i in range(len(lb))]\n                \n                nlc = create_nonlinear_constraints()\n                \n                result = minimize(\n                    objective,\n                    x_init,\n                    method='trust-constr',\n                    jac=objective_grad,\n                    bounds=bounds_tc,\n                    constraints=nlc,\n                    options={'maxiter': 500, 'verbose': 0}\n                )\n                \n                if result.success or -result.fun > best_sum:\n                    current_sum = -result.fun\n                    if current_sum > best_sum:\n                        best_sum = current_sum\n                        best_result = result\n            except:\n                pass\n    \n    # Extract best solution\n    if best_result is None:\n        # Fallback to grid\n        x_init = init_grid(n)\n        centers = x_init.reshape(n, 3)[:, :2]\n        radii = x_init.reshape(n, 3)[:, 2]\n    else:\n        solution = best_result.x\n        centers",
  "timestamp": "2025-12-09T15:27:05.350969",
  "cost_data": null
}