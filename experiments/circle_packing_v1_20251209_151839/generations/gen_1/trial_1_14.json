{
  "trial_id": "trial_1_14",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    all_results = []\n    \n    # Generate diverse initial patterns\n    patterns = []\n    \n    # 1. Hexagonal grids with different orientations and scales\n    for rows in [4, 5, 6]:\n        for offset_scale in [0.8, 0.9, 1.0]:\n            patterns.append(generate_hexagonal_grid(n, rows, offset_scale))\n    \n    # 2. Regular grids\n    for rows in [4, 5, 6]:\n        cols = (n + rows - 1) // rows\n        patterns.append(generate_regular_grid(n, rows, cols))\n    \n    # 3. Spiral patterns\n    for turns in [2, 3, 4]:\n        for start_radius in [0.1, 0.15, 0.2]:\n            patterns.append(generate_spiral(n, turns, start_radius))\n    \n    # 4. Boundary-focused arrangements\n    for boundary_ratio in [0.3, 0.4, 0.5]:\n        patterns.append(generate_boundary_focused(n, boundary_ratio))\n    \n    # 5. Concentric circles\n    for num_rings in [2, 3, 4]:\n        patterns.append(generate_concentric(n, num_rings))\n    \n    # 6. Random with clustering\n    for seed in range(10):\n        patterns.append(generate_clustered_random(n, seed))\n    \n    # 7. Triangular lattice variations\n    for angle in [0, 15, 30]:\n        patterns.append(generate_triangular_lattice(n, angle))\n    \n    # 8. Mixed strategies\n    patterns.append(generate_mixed_boundary_interior(n))\n    patterns.append(generate_optimized_grid_perturbed(n))\n    \n    print(f\"Generated {len(patterns)} initial patterns\")\n    \n    # First pass: optimize all patterns with moderate iterations\n    for i, initial_centers in enumerate(patterns):\n        if i % 10 == 0:\n            print(f\"Optimizing pattern {i+1}/{len(patterns)}\")\n        \n        result = optimize_packing(initial_centers, max_iter=200)\n        all_results.append(result)\n        \n        if result['sum_radii'] > best_sum:\n            best_sum = result['sum_radii']\n            best_centers = result['centers']\n            best_radii = result['radii']\n    \n    # Sort results and get top 10\n    all_results.sort(key=lambda x: x['sum_radii'], reverse=True)\n    print(f\"\\nTop 10 results from first pass: {[r['sum_radii'] for r in all_results[:10]]}\")\n    \n    # Second pass: extended optimization on top 10\n    print(\"\\nRunning extended optimization on top 10 patterns...\")\n    for i, result in enumerate(all_results[:10]):\n        print(f\"Extended optimization {i+1}/10\")\n        extended_result = optimize_packing(result['centers'], max_iter=500)\n        \n        if extended_result['sum_radii'] > best_sum:\n            best_sum = extended_result['sum_radii']\n            best_centers = extended_result['centers']\n            best_radii = extended_result['radii']\n    \n    print(f\"\\nFinal best sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef optimize_packing(initial_centers, max_iter=200):\n    \"\"\"Optimize a packing configuration.\"\"\"\n    n = len(initial_centers)\n    \n    # Flatten centers for optimization\n    x0 = initial_centers.flatten()\n    \n    # Bounds: all coordinates in [0, 1]\n    bounds = [(0, 1)] * (2 * n)\n    \n    def objective(x):\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)  # Negative because we minimize\n    \n    def constraint_non_overlap(x):\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        distances = squareform(pdist(centers))\n        np.fill_diagonal(distances, np.inf)\n        min_distances = distances - (radii[:, None] + radii[None, :])\n        return np.min(min_distances)\n    \n    constraints = [{'type': 'ineq', 'fun': constraint_non_overlap}]\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': max_iter, 'ftol': 1e-9}\n    )\n    \n    centers = result.x.reshape(n, 2)\n    radii = compute_radii(centers)\n    \n    return {\n        'centers': centers,\n        'radii': radii,\n        'sum_radii': np.sum(radii)\n    }\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum valid radius for each circle.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(\n            centers[i, 0],  # left\n            1 - centers[i, 0],  # right\n            centers[i, 1],  # bottom\n            1 - centers[i, 1]  # top\n        )\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, (dist - radii[j]) / 1.0)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\n# Pattern generation functions\n\ndef generate_hexagonal_grid(n, rows, offset_scale=1.0):\n    \"\"\"Generate hexagonal grid pattern.\"\"\"\n    cols = (n + rows - 1) // rows\n    centers = []\n    \n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = (j + 0.5 + (i % 2) * 0.5 * offset_scale) * dx\n            y = (i + 0.5) * dy\n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef generate_regular_grid(n, rows, cols):\n    \"\"\"Generate regular grid pattern.\"\"\"\n    centers = []\n    dx = 1.0 / (cols + 1)\n    dy = 1.0 / (rows + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = (j + 1) * dx\n            y = (i + 1) * dy\n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef generate_spiral(n, turns, start_radius):\n    \"\"\"Generate spiral pattern.\"\"\"\n    centers = []\n    theta = np.linspace(0, turns * 2 * np.pi, n)\n    r = np.linspace(start_radius, 0.4, n)\n    \n    for i in range(n):\n        x = 0.5 + r[i] * np.cos(theta[i])\n        y = 0.5 + r[i] * np.sin(theta[i])\n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef generate_boundary_focused(n, boundary_ratio):\n    \"\"\"Generate boundary-focused pattern.\"\"\"\n    n_boundary = int(n * boundary_ratio)\n    n_interior = n - n_boundary\n    \n    centers = []\n    \n    # Boundary circles\n    perimeter_positions = np.linspace(0, 4, n_boundary, endpoint=False)\n    margin = 0.05\n    \n    for pos in perimeter_positions:\n        if pos < 1:  # Bottom edge\n            centers.append([pos, margin])\n        elif pos < 2:  # Right edge\n            centers.append([1 - margin, pos - 1])\n        elif pos < 3:  # Top edge\n            centers.append([3 - pos, 1 - margin])\n        else:  # Left edge\n            centers.append([margin, 4 - pos])\n    \n    # Interior circles in grid\n    if n_interior > 0:\n        interior_rows = int(np.sqrt(n_interior))\n        interior_cols = (n_interior + interior_rows - 1) // interior_rows\n        \n        for i in range(interior_rows):\n            for j in range(interior_cols):\n                if len(centers) >= n:\n                    break\n                x = 0.2 + 0.6 * j / max(1, interior_cols - 1) if interior_cols > 1 else 0.5\n                y = 0.2 + 0.6 * i / max(1, interior_rows - 1) if interior_rows > 1 else 0.5\n                centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef generate_concentric(n, num_rings):\n    \"\"\"Generate concentric circles pattern.\"\"\"\n    centers = []\n    circles_per_ring = n // num_rings\n    remainder = n % num_rings\n    \n    for ring in range(num_rings):\n        n_ring = circles_per_ring + (1 if ring < remainder else 0)\n        radius = 0.15 + 0.3 * ring / max(1, num_rings - 1)\n        \n        for i in range(n_ring):\n            theta = 2 * np.pi * i / n_ring\n            x = 0.5 + radius * np.cos(theta)\n            y = 0.5 + radius * np.sin(theta)\n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef generate_clustered_random(n, seed):\n    \"\"\"Generate random pattern with clustering.\"\"\"\n    np.random.seed(seed)\n    num_clusters = 4\n    centers = []\n    \n    cluster_centers = np.random.uniform(0.2, 0.8, (num_clusters, 2))\n    circles_per_cluster = n // num_clusters\n    remainder = n % num_clusters\n    \n    for i, cluster_center in enumerate(cluster_centers):\n        n_cluster = circles_per_cluster + (1 if i < remainder else 0)\n        for _ in range(n_cluster):\n            offset = np.random.normal(0, 0.1, 2)\n            center = np.clip(cluster_center + offset, 0.05, 0.95)\n            centers.append(center)\n    \n    return np.array(centers[:n])\n\ndef generate_triangular_lattice(n, angle_deg):\n    \"\"\"Generate triangular lattice with rotation.\"\"\"\n    angle = np.radians(angle_deg)\n    rows = int(np.sqrt(n)) + 1\n    centers = []\n    \n    dx = 1.0 / (rows + 1)\n    dy = dx * np.sqrt(3) / 2\n    \n    for i in range(rows):\n        for j in range(rows):\n            if len(centers) >= n:\n                break\n            x = (j + (i % 2) * 0.5) * dx + 0.1\n            y = i * dy + 0.1\n            \n            # Rotate around center\n            x_rot = 0.5 + (x - 0.5) * np.cos(angle) - (y - 0.5) * np.sin(angle)\n            y_rot = 0.5 + (x - 0.5) * np.sin(angle) + (y - 0.5) * np.cos(angle)\n            \n            if 0 < x_rot < 1 and 0 < y_rot < 1:\n                centers.append([x_rot, y_rot])\n    \n    return np.array(centers[:n])\n\ndef generate_mixed_boundary_interior(n):\n    \"\"\"Generate mixed boundary and interior pattern.\"\"\"\n    centers = []\n    \n    # 12 on boundary\n    for i in range(12):\n        t = i / 12 * 4\n        if t < 1:\n            centers.append([t, 0.05])\n        elif t < 2:\n            centers.append([0.95, t - 1])\n        elif t < 3:\n            centers.append([3 - t, 0.95])\n        else:\n            centers.append([0.05, 4 - t])\n    \n    # Interior in 4x4 grid\n    for i in range(4):\n        for j in range(4):\n            if len(centers) >= n:\n                break\n            x = 0.2 + 0.6 * j / 3\n            y = 0.2 + 0.6 * i / 3\n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef generate_optimized_grid_perturbed(n):\n    \"\"\"Generate optimized grid with perturbations.\"\"\"\n    rows = 5\n    cols = 6\n    centers = []\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = (j + 0.5 + (i % 2) * 0.25) / cols\n            y = (i + 0.5) / rows\n            # Add small random perturbation\n            x += np.random.uniform(-0.02, 0.02)\n            y += np.random.uniform(-0.02, 0.02)\n            centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n    \n    return np.array(centers[:n])\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0091140270233,
    "error": "Timeout after 300s"
  },
  "prompt": "Create a pattern-based initialization with exhaustive optimization:\n\n1. Generate 50+ different initial patterns:\n   - Various hexagonal configurations\n   - Different grid arrangements (5x6, 4x7, etc.)\n   - Spiral patterns with different parameters\n   - Boundary-focused arrangements\n   - Random with clustering\n2. For each pattern, run scipy.optimize.minimize with SLSQP\n3. Keep track of best configuration\n4. For top 10 patterns, run extended optimization with more iterations\n5. Return the best overall result\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    all_results = []\n    \n    # Generate diverse initial patterns\n    patterns = []\n    \n    # 1. Hexagonal grids with different orientations and scales\n    for rows in [4, 5, 6]:\n        for offset_scale in [0.8, 0.9, 1.0]:\n            patterns.append(generate_hexagonal_grid(n, rows, offset_scale))\n    \n    # 2. Regular grids\n    for rows in [4, 5, 6]:\n        cols = (n + rows - 1) // rows\n        patterns.append(generate_regular_grid(n, rows, cols))\n    \n    # 3. Spiral patterns\n    for turns in [2, 3, 4]:\n        for start_radius in [0.1, 0.15, 0.2]:\n            patterns.append(generate_spiral(n, turns, start_radius))\n    \n    # 4. Boundary-focused arrangements\n    for boundary_ratio in [0.3, 0.4, 0.5]:\n        patterns.append(generate_boundary_focused(n, boundary_ratio))\n    \n    # 5. Concentric circles\n    for num_rings in [2, 3, 4]:\n        patterns.append(generate_concentric(n, num_rings))\n    \n    # 6. Random with clustering\n    for seed in range(10):\n        patterns.append(generate_clustered_random(n, seed))\n    \n    # 7. Triangular lattice variations\n    for angle in [0, 15, 30]:\n        patterns.append(generate_triangular_lattice(n, angle))\n    \n    # 8. Mixed strategies\n    patterns.append(generate_mixed_boundary_interior(n))\n    patterns.append(generate_optimized_grid_perturbed(n))\n    \n    print(f\"Generated {len(patterns)} initial patterns\")\n    \n    # First pass: optimize all patterns with moderate iterations\n    for i, initial_centers in enumerate(patterns):\n        if i % 10 == 0:\n            print(f\"Optimizing pattern {i+1}/{len(patterns)}\")\n        \n        result = optimize_packing(initial_centers, max_iter=200)\n        all_results.append(result)\n        \n        if result['sum_radii'] > best_sum:\n            best_sum = result['sum_radii']\n            best_centers = result['centers']\n            best_radii = result['radii']\n    \n    # Sort results and get top 10\n    all_results.sort(key=lambda x: x['sum_radii'], reverse=True)\n    print(f\"\\nTop 10 results from first pass: {[r['sum_radii'] for r in all_results[:10]]}\")\n    \n    # Second pass: extended optimization on top 10\n    print(\"\\nRunning extended optimization on top 10 patterns...\")\n    for i, result in enumerate(all_results[:10]):\n        print(f\"Extended optimization {i+1}/10\")\n        extended_result = optimize_packing(result['centers'], max_iter=500)\n        \n        if extended_result['sum_radii'] > best_sum:\n            best_sum = extended_result['sum_radii']\n            best_centers = extended_result['centers']\n            best_radii = extended_result['radii']\n    \n    print(f\"\\nFinal best sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef optimize_packing(initial_centers, max_iter=200):\n    \"\"\"Optimize a packing configuration.\"\"\"\n    n = len(initial_centers)\n    \n    # Flatten centers for optimization\n    x0 = initial_centers.flatten()\n    \n    # Bounds: all coordinates in [0, 1]\n    bounds = [(0, 1)] * (2 * n)\n    \n    def objective(x):\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)  # Negative because we minimize\n    \n    def constraint_non_overlap(x):\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        distances = squareform(pdist(centers))\n        np.fill_diagonal(distances, np.inf)\n        min_distances = distances - (radii[:, None] + radii[None, :])\n        return np.min(min_distances)\n    \n    constraints = [{'type': 'ineq', 'fun': constraint_non_overlap}]\n    \n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': max_iter, 'ftol': 1e-9}\n    )\n    \n    centers = result.x.reshape(n, 2)\n    radii = compute_radii(centers)\n    \n    return {\n        'centers': centers,\n        'radii': radii,\n        'sum_radii': np.sum(radii)\n    }\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum valid radius for each circle.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(\n            centers[i, 0],  # left\n            1 - centers[i, 0],  # right\n            centers[i, 1],  # bottom\n            1 - centers[i, 1]  # top\n        )\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, (dist - radii[j]) / 1.0)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\n# Pattern generation functions\n\ndef generate_hexagonal_grid(n, rows, offset_scale=1.0):\n    \"\"\"Generate hexagonal grid pattern.\"\"\"\n    cols = (n + rows - 1) // rows\n    centers = []\n    \n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = (j + 0.5 + (i % 2) * 0.5 * offset_scale) * dx\n            y = (i + 0.5) * dy\n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef generate_regular_grid(n, rows, cols):\n    \"\"\"Generate regular grid pattern.\"\"\"\n    centers = []\n    dx = 1.0 / (cols + 1)\n    dy = 1.0 / (rows + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = (j + 1) * dx\n            y = (i + 1) * dy\n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef generate_spiral(n, turns, start_radius):\n    \"\"\"Generate spiral pattern.\"\"\"\n    centers = []\n    theta = np.linspace(0, turns * 2 * np.pi, n)\n    r = np.linspace(start_radius, 0.4, n)\n    \n    for i in range(n):\n        x = 0.5 + r[i] * np.cos(theta[i])\n        y = 0.5 + r[i] * np.sin(theta[i])\n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef generate_boundary_focused(n, boundary_ratio):\n    \"\"\"Generate boundary-focused pattern.\"\"\"\n    n_boundary = int(n * boundary_ratio)\n    n_interior = n - n_boundary\n    \n    centers = []\n    \n    # Boundary circles\n    perimeter_positions = np.linspace(0, 4, n_boundary, endpoint=False)\n    margin = 0.05\n    \n    for pos in perimeter_positions:\n        if pos < 1:  # Bottom edge\n            centers.append([pos, margin])\n        elif pos < 2:  # Right edge\n            centers.append([1 - margin, pos - 1])\n        elif pos < 3:  # Top edge\n            centers.append([3 - pos, 1 - margin])\n        else:  # Left edge\n            centers.append([margin, 4 - pos])\n    \n    # Interior circles in grid\n    if n_interior > 0:\n        interior_rows = int(np.sqrt(n_interior))\n        interior_cols = (n_interior + interior_rows - 1) // interior_rows\n        \n        for i in range(interior_rows):\n            for j in range(interior_cols):\n                if len(centers) >= n:\n                    break\n                x = 0.2 + 0.6 * j / max(1, interior_cols - 1) if interior_cols > 1 else 0.5\n                y = 0.2 + 0.6 * i / max(1, interior_rows - 1) if interior_rows > 1 else 0.5\n                centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef generate_concentric(n, num_rings):\n    \"\"\"Generate concentric circles pattern.\"\"\"\n    centers = []\n    circles_per_ring = n // num_rings\n    remainder = n % num_rings\n    \n    for ring in range(num_rings):\n        n_ring = circles_per_ring + (1 if ring < remainder else 0)\n        radius = 0.15 + 0.3 * ring / max(1, num_rings - 1)\n        \n        for i in range(n_ring):\n            theta = 2 * np.pi * i / n_ring\n            x = 0.5 + radius * np.cos(theta)\n            y = 0.5 + radius * np.sin(theta)\n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef generate_clustered_random(n, seed):\n    \"\"\"Generate random pattern with clustering.\"\"\"\n    np.random.seed(seed)\n    num_clusters = 4\n    centers = []\n    \n    cluster_centers = np.random.uniform(0.2, 0.8, (num_clusters, 2))\n    circles_per_cluster = n // num_clusters\n    remainder = n % num_clusters\n    \n    for i, cluster_center in enumerate(cluster_centers):\n        n_cluster = circles_per_cluster + (1 if i < remainder else 0)\n        for _ in range(n_cluster):\n            offset = np.random.normal(0, 0.1, 2)\n            center = np.clip(cluster_center + offset, 0.05, 0.95)\n            centers.append(center)\n    \n    return np.array(centers[:n])\n\ndef generate_triangular_lattice(n, angle_deg):\n    \"\"\"Generate triangular lattice with rotation.\"\"\"\n    angle = np.radians(angle_deg)\n    rows = int(np.sqrt(n)) + 1\n    centers = []\n    \n    dx = 1.0 / (rows + 1)\n    dy = dx * np.sqrt(3) / 2\n    \n    for i in range(rows):\n        for j in range(rows):\n            if len(centers) >= n:\n                break\n            x = (j + (i % 2) * 0.5) * dx + 0.1\n            y = i * dy + 0.1\n            \n            # Rotate around center\n            x_rot = 0.5 + (x - 0.5) * np.cos(angle) - (y - 0.5) * np.sin(angle)\n            y_rot = 0.5 + (x - 0.5) * np.sin(angle) + (y - 0.5) * np.cos(angle)\n            \n            if 0 < x_rot < 1 and 0 < y_rot < 1:\n                centers.append([x_rot, y_rot])\n    \n    return np.array(centers[:n])\n\ndef generate_mixed_boundary_interior(n):\n    \"\"\"Generate mixed boundary and interior pattern.\"\"\"\n    centers = []\n    \n    # 12 on boundary\n    for i in range(12):\n        t = i / 12 * 4\n        if t < 1:\n            centers.append([t, 0.05])\n        elif t < 2:\n            centers.append([0.95, t - 1])\n        elif t < 3:\n            centers.append([3 - t, 0.95])\n        else:\n            centers.append([0.05, 4 - t])\n    \n    # Interior in 4x4 grid\n    for i in range(4):\n        for j in range(4):\n            if len(centers) >= n:\n                break\n            x = 0.2 + 0.6 * j / 3\n            y = 0.2 + 0.6 * i / 3\n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef generate_optimized_grid_perturbed(n):\n    \"\"\"Generate optimized grid with perturbations.\"\"\"\n    rows = 5\n    cols = 6\n    centers = []\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = (j + 0.5 + (i % 2) * 0.25) / cols\n            y = (i + 0.5) / rows\n            # Add small random perturbation\n            x += np.random.uniform(-0.02, 0.02)\n            y += np.random.uniform(-0.02, 0.02)\n            centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n    \n    return np.array(centers[:n])\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:32:02.127850",
  "cost_data": null
}