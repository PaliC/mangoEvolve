{
  "trial_id": "trial_1_10",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping, minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using basin-hopping.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def positions_to_radii(positions):\n        \"\"\"Compute maximum radii given positions.\"\"\"\n        positions = positions.reshape(n, 2)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            min_dist_boundary = min(\n                positions[i, 0],  # left\n                1 - positions[i, 0],  # right\n                positions[i, 1],  # bottom\n                1 - positions[i, 1]  # top\n            )\n            \n            # Distance to other circles\n            min_dist_circles = np.inf\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    if radii[j] > 0:\n                        min_dist_circles = min(min_dist_circles, dist - radii[j])\n                    else:\n                        min_dist_circles = min(min_dist_circles, dist)\n            \n            radii[i] = max(0, min(min_dist_boundary, min_dist_circles))\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: negative sum of radii (we minimize).\"\"\"\n        radii = positions_to_radii(x)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"Constraint: all circles within boundaries.\"\"\"\n        positions = x.reshape(n, 2)\n        radii = positions_to_radii(x)\n        \n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                positions[i, 0] - radii[i],  # left boundary\n                1 - positions[i, 0] - radii[i],  # right boundary\n                positions[i, 1] - radii[i],  # bottom boundary\n                1 - positions[i, 1] - radii[i]  # top boundary\n            ])\n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        \"\"\"Constraint: no overlaps between circles.\"\"\"\n        positions = x.reshape(n, 2)\n        radii = positions_to_radii(x)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(positions[i] - positions[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    # Bounds: all positions in [0, 1]\n    bounds = [(0, 1)] * (2 * n)\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Try multiple starting configurations\n    np.random.seed(42)\n    starting_configs = [\n        # Grid-based starts\n        np.array([[i % 6 / 6 + 0.08, i // 6 / 5 + 0.1] for i in range(26)]).flatten(),\n        np.array([[i % 5 / 5 + 0.1, i // 5 / 6 + 0.08] for i in range(26)]).flatten(),\n        # Random starts\n        np.random.uniform(0.1, 0.9, 2 * n),\n        np.random.uniform(0.15, 0.85, 2 * n),\n        # Hexagonal-inspired\n        np.array([[0.1 + 0.15 * (i % 6) + 0.075 * ((i // 6) % 2), \n                   0.1 + 0.13 * (i // 6)] for i in range(26)]).flatten(),\n    ]\n    \n    class CustomBounds:\n        \"\"\"Custom bounds for basin-hopping.\"\"\"\n        def __init__(self, xmin, xmax):\n            self.xmin = np.array(xmin)\n            self.xmax = np.array(xmax)\n        \n        def __call__(self, **kwargs):\n            x = kwargs[\"x_new\"]\n            tmax = bool(np.all(x <= self.xmax))\n            tmin = bool(np.all(x >= self.xmin))\n            return tmax and tmin\n    \n    bounded_step = CustomBounds([0] * (2 * n), [1] * (2 * n))\n    \n    for config_idx, x0 in enumerate(starting_configs):\n        print(f\"Trying configuration {config_idx + 1}/{len(starting_configs)}\")\n        \n        # Temperature schedule: start higher, decrease over time\n        temperature = 0.1 if config_idx < 2 else 0.05\n        \n        minimizer_kwargs = {\n            \"method\": \"SLSQP\",\n            \"bounds\": bounds,\n            \"constraints\": constraints,\n            \"options\": {\"maxiter\": 100, \"ftol\": 1e-6}\n        }\n        \n        try:\n            result = basinhopping(\n                objective,\n                x0,\n                minimizer_kwargs=minimizer_kwargs,\n                niter=250,  # More iterations for better exploration\n                T=temperature,\n                stepsize=0.05,\n                accept_test=bounded_step,\n                seed=42 + config_idx,\n                disp=False\n            )\n            \n            if result.fun < 0:  # Valid solution found\n                sum_radii = -result.fun\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_result = result\n                    print(f\"  New best: {sum_radii:.6f}\")\n        except Exception as e:\n            print(f\"  Configuration failed: {e}\")\n            continue\n    \n    if best_result is None:\n        # Fallback: simple grid\n        print(\"Using fallback grid configuration\")\n        centers = np.array([[i % 6 / 6 + 0.08, i // 6 / 5 + 0.1] for i in range(26)])\n        radii = positions_to_radii(centers.flatten())\n        sum_radii = np.sum(radii)\n    else:\n        centers = best_result.x.reshape(n, 2)\n        radii = positions_to_radii(best_result.x)\n        sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal sum of radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0078709125519,
    "error": "Timeout after 300s"
  },
  "prompt": "Create a basin-hopping optimization approach:\n\nUse scipy.optimize.basinhopping which is designed to find global optima:\n1. Define objective: negative sum of radii (computed from positions)\n2. Define constraints: boundaries and no overlaps\n3. Use basinhopping with SLSQP as local minimizer\n4. Try 200+ iterations with temperature scheduling\n5. Use multiple starting configurations\n6. This should escape local optima better than pure gradient descent\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using basin-hopping.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def positions_to_radii(positions):\n        \"\"\"Compute maximum radii given positions.\"\"\"\n        positions = positions.reshape(n, 2)\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            # Distance to boundaries\n            min_dist_boundary = min(\n                positions[i, 0],  # left\n                1 - positions[i, 0],  # right\n                positions[i, 1],  # bottom\n                1 - positions[i, 1]  # top\n            )\n            \n            # Distance to other circles\n            min_dist_circles = np.inf\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    if radii[j] > 0:\n                        min_dist_circles = min(min_dist_circles, dist - radii[j])\n                    else:\n                        min_dist_circles = min(min_dist_circles, dist)\n            \n            radii[i] = max(0, min(min_dist_boundary, min_dist_circles))\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Objective: negative sum of radii (we minimize).\"\"\"\n        radii = positions_to_radii(x)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"Constraint: all circles within boundaries.\"\"\"\n        positions = x.reshape(n, 2)\n        radii = positions_to_radii(x)\n        \n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                positions[i, 0] - radii[i],  # left boundary\n                1 - positions[i, 0] - radii[i],  # right boundary\n                positions[i, 1] - radii[i],  # bottom boundary\n                1 - positions[i, 1] - radii[i]  # top boundary\n            ])\n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        \"\"\"Constraint: no overlaps between circles.\"\"\"\n        positions = x.reshape(n, 2)\n        radii = positions_to_radii(x)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(positions[i] - positions[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    # Bounds: all positions in [0, 1]\n    bounds = [(0, 1)] * (2 * n)\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    best_result = None\n    best_sum = -np.inf\n    \n    # Try multiple starting configurations\n    np.random.seed(42)\n    starting_configs = [\n        # Grid-based starts\n        np.array([[i % 6 / 6 + 0.08, i // 6 / 5 + 0.1] for i in range(26)]).flatten(),\n        np.array([[i % 5 / 5 + 0.1, i // 5 / 6 + 0.08] for i in range(26)]).flatten(),\n        # Random starts\n        np.random.uniform(0.1, 0.9, 2 * n),\n        np.random.uniform(0.15, 0.85, 2 * n),\n        # Hexagonal-inspired\n        np.array([[0.1 + 0.15 * (i % 6) + 0.075 * ((i // 6) % 2), \n                   0.1 + 0.13 * (i // 6)] for i in range(26)]).flatten(),\n    ]\n    \n    class CustomBounds:\n        \"\"\"Custom bounds for basin-hopping.\"\"\"\n        def __init__(self, xmin, xmax):\n            self.xmin = np.array(xmin)\n            self.xmax = np.array(xmax)\n        \n        def __call__(self, **kwargs):\n            x = kwargs[\"x_new\"]\n            tmax = bool(np.all(x <= self.xmax))\n            tmin = bool(np.all(x >= self.xmin))\n            return tmax and tmin\n    \n    bounded_step = CustomBounds([0] * (2 * n), [1] * (2 * n))\n    \n    for config_idx, x0 in enumerate(starting_configs):\n        print(f\"Trying configuration {config_idx + 1}/{len(starting_configs)}\")\n        \n        # Temperature schedule: start higher, decrease over time\n        temperature = 0.1 if config_idx < 2 else 0.05\n        \n        minimizer_kwargs = {\n            \"method\": \"SLSQP\",\n            \"bounds\": bounds,\n            \"constraints\": constraints,\n            \"options\": {\"maxiter\": 100, \"ftol\": 1e-6}\n        }\n        \n        try:\n            result = basinhopping(\n                objective,\n                x0,\n                minimizer_kwargs=minimizer_kwargs,\n                niter=250,  # More iterations for better exploration\n                T=temperature,\n                stepsize=0.05,\n                accept_test=bounded_step,\n                seed=42 + config_idx,\n                disp=False\n            )\n            \n            if result.fun < 0:  # Valid solution found\n                sum_radii = -result.fun\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_result = result\n                    print(f\"  New best: {sum_radii:.6f}\")\n        except Exception as e:\n            print(f\"  Configuration failed: {e}\")\n            continue\n    \n    if best_result is None:\n        # Fallback: simple grid\n        print(\"Using fallback grid configuration\")\n        centers = np.array([[i % 6 / 6 + 0.08, i // 6 / 5 + 0.1] for i in range(26)])\n        radii = positions_to_radii(centers.flatten())\n        sum_radii = np.sum(radii)\n    else:\n        centers = best_result.x.reshape(n, 2)\n        radii = positions_to_radii(best_result.x)\n        sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal sum of radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:31:43.350780",
  "cost_data": null
}