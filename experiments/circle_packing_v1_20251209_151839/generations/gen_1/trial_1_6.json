{
  "trial_id": "trial_1_6",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses explicit radius maximization with multiple initialization strategies.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Try multiple initialization strategies\n    init_strategies = []\n    \n    # Strategy 1: Grid-based initializations with various configurations\n    for grid_size in [(5, 6), (6, 5), (4, 7), (7, 4)]:\n        rows, cols = grid_size\n        if rows * cols >= n:\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = (j + 0.5) / cols\n                    y = (i + 0.5) / rows\n                    centers.append([x, y])\n                if len(centers) >= n:\n                    break\n            centers = np.array(centers[:n])\n            # Estimate initial radius\n            spacing = min(1.0/cols, 1.0/rows)\n            r_init = spacing * 0.4\n            radii = np.full(n, r_init)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 2: Hexagonal packing approximations\n    for offset in [0.0, 0.25, 0.5]:\n        centers = []\n        r_est = 0.08\n        rows = int(1.0 / (r_est * 1.8)) + 1\n        for row in range(rows):\n            y = (row + 0.5) * (r_est * 1.8)\n            if y > 1.0:\n                break\n            cols_in_row = int(1.0 / (r_est * 2)) + 1\n            x_offset = (r_est if row % 2 == 1 else 0) + offset * r_est\n            for col in range(cols_in_row):\n                x = col * (r_est * 2) + r_est + x_offset\n                if x <= 1.0 and len(centers) < n:\n                    centers.append([x, y])\n        \n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, r_est)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 3: Random initializations with different radius estimates\n    for _ in range(10):\n        centers = np.random.uniform(0.15, 0.85, (n, 2))\n        r_init = np.random.uniform(0.06, 0.12)\n        radii = np.full(n, r_init) * np.random.uniform(0.8, 1.2, n)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 4: Clustered initialization\n    for n_clusters in [2, 3, 4]:\n        centers = []\n        cluster_centers = np.random.uniform(0.2, 0.8, (n_clusters, 2))\n        circles_per_cluster = n // n_clusters\n        for i, cc in enumerate(cluster_centers):\n            n_in_cluster = circles_per_cluster if i < n_clusters - 1 else n - len(centers)\n            cluster_points = cc + np.random.uniform(-0.15, 0.15, (n_in_cluster, 2))\n            cluster_points = np.clip(cluster_points, 0.1, 0.9)\n            centers.extend(cluster_points)\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 5: Optimized grid with perturbations\n    for grid_config in [(5, 6), (6, 5)]:\n        rows, cols = grid_config\n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (j + 0.5) / cols + np.random.uniform(-0.05, 0.05)\n                y = (i + 0.5) / rows + np.random.uniform(-0.05, 0.05)\n                x = np.clip(x, 0.1, 0.9)\n                y = np.clip(y, 0.1, 0.9)\n                centers.append([x, y])\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.09) * np.random.uniform(0.9, 1.1, n)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii with small penalty for variance.\"\"\"\n        radii = x[2*n:]\n        sum_r = np.sum(radii)\n        variance_penalty = 0.05 * np.var(radii)  # Small penalty to encourage uniform sizes\n        return -(sum_r - variance_penalty)  # Negative because we minimize\n    \n    def boundary_constraints(x):\n        \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers[i, 0] - radii[i],  # left boundary\n                1.0 - centers[i, 0] - radii[i],  # right boundary\n                centers[i, 1] - radii[i],  # bottom boundary\n                1.0 - centers[i, 1] - radii[i]  # top boundary\n            ])\n        return np.array(constraints)\n    \n    def overlap_constraints(x):\n        \"\"\"No two circles should overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    # Bounds: centers in [0,1], radii in [0, 0.5]\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n    \n    # Constraints\n    boundary_cons = NonlinearConstraint(boundary_constraints, 0, np.inf)\n    overlap_cons = NonlinearConstraint(overlap_constraints, 0, np.inf)\n    \n    print(f\"Trying {len(init_strategies)} different initializations...\")\n    \n    for idx, x0 in enumerate(init_strategies):\n        try:\n            # Try SLSQP first (faster)\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[boundary_cons, overlap_cons],\n                options={'maxiter': 500, 'ftol': 1e-8}\n            )\n            \n            if result.success or result.fun < 0:\n                centers_opt = result.x[:2*n].reshape(n, 2)\n                radii_opt = result.x[2*n:]\n                sum_radii = np.sum(radii_opt)\n                \n                # Verify constraints\n                if (np.all(boundary_constraints(result.x) >= -1e-6) and \n                    np.all(overlap_constraints(result.x) >= -1e-6) and\n                    sum_radii > best_sum):\n                    best_sum = sum_radii\n                    best_solution = result.x.copy()\n                    print(f\"  Init {idx+1}: sum_radii = {sum_radii:.6f}\")\n            \n            # If SLSQP didn't work well, try trust-constr for some cases\n            if idx % 5 == 0:\n                result2 = minimize(\n                    objective,\n                    x0,\n                    method='trust-constr',\n                    bounds=bounds,\n                    constraints=[boundary_cons, overlap_cons],\n                    options={'maxiter': 300, 'verbose': 0}\n                )\n                \n                if result2.success or result2.fun < 0:\n                    centers_opt2 = result2.x[:2*n].reshape(n, 2)\n                    radii_opt2 = result2.x[2*n:]\n                    sum_radii2 = np.sum(radii_opt2)\n                    \n                    if (np.all(boundary_constraints(result2.x) >= -1e-6) and \n                        np.all(overlap_constraints(result2.x) >= -1e-6) and\n                        sum_radii2 > best_sum):\n                        best_sum = sum_radii2\n                        best_solution = result2.x.copy()\n                        print(f\"  Init {idx+1} (trust-constr): sum_radii = {sum_radii2:.6f}\")\n        \n        except Exception as e:\n            continue\n    \n    if best_solution is not None:\n        centers = best_solution[:2*n].reshape(n, 2)\n        radii = best_solution[2*n:]\n        sum_radii = np.sum(radii)\n        print(f\"\\nBest solution found: sum_radii = {sum_radii:.6f}\")\n        return centers, radii, sum_radii\n    else:\n        # Fallback: return a simple grid\n        print(\"No valid solution found, using fallback grid\")\n        centers = []\n        for i in range(5):\n            for j in range(6):\n                if len(centers) >= n:\n                    break\n                centers.append([(j + 0.5) / 6, (i + 0.5) / 5])\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.621268983146597,
    "target_ratio": 0.9947889879114221,
    "combined_score": 0.9947889879114221,
    "eval_time": 56.70817732810974,
    "error": null
  },
  "prompt": "Create an optimization approach with explicit radius maximization.\n\nInstead of computing radii from positions, optimize both simultaneously with bias toward larger radii.\n\nStrategy:\n1. Variables: 26 centers (x,y) + 26 radii = 78 variables\n2. Objective: maximize sum(radii) - 0.1*sum(radii_variance) to encourage uniform sizes\n3. Constraints: boundaries, no overlaps\n4. Use multiple initialization patterns\n5. Try both SLSQP and trust-constr methods\n6. Run 30+ starts with different initializations\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses explicit radius maximization with multiple initialization strategies.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Try multiple initialization strategies\n    init_strategies = []\n    \n    # Strategy 1: Grid-based initializations with various configurations\n    for grid_size in [(5, 6), (6, 5), (4, 7), (7, 4)]:\n        rows, cols = grid_size\n        if rows * cols >= n:\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = (j + 0.5) / cols\n                    y = (i + 0.5) / rows\n                    centers.append([x, y])\n                if len(centers) >= n:\n                    break\n            centers = np.array(centers[:n])\n            # Estimate initial radius\n            spacing = min(1.0/cols, 1.0/rows)\n            r_init = spacing * 0.4\n            radii = np.full(n, r_init)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 2: Hexagonal packing approximations\n    for offset in [0.0, 0.25, 0.5]:\n        centers = []\n        r_est = 0.08\n        rows = int(1.0 / (r_est * 1.8)) + 1\n        for row in range(rows):\n            y = (row + 0.5) * (r_est * 1.8)\n            if y > 1.0:\n                break\n            cols_in_row = int(1.0 / (r_est * 2)) + 1\n            x_offset = (r_est if row % 2 == 1 else 0) + offset * r_est\n            for col in range(cols_in_row):\n                x = col * (r_est * 2) + r_est + x_offset\n                if x <= 1.0 and len(centers) < n:\n                    centers.append([x, y])\n        \n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, r_est)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 3: Random initializations with different radius estimates\n    for _ in range(10):\n        centers = np.random.uniform(0.15, 0.85, (n, 2))\n        r_init = np.random.uniform(0.06, 0.12)\n        radii = np.full(n, r_init) * np.random.uniform(0.8, 1.2, n)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 4: Clustered initialization\n    for n_clusters in [2, 3, 4]:\n        centers = []\n        cluster_centers = np.random.uniform(0.2, 0.8, (n_clusters, 2))\n        circles_per_cluster = n // n_clusters\n        for i, cc in enumerate(cluster_centers):\n            n_in_cluster = circles_per_cluster if i < n_clusters - 1 else n - len(centers)\n            cluster_points = cc + np.random.uniform(-0.15, 0.15, (n_in_cluster, 2))\n            cluster_points = np.clip(cluster_points, 0.1, 0.9)\n            centers.extend(cluster_points)\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 5: Optimized grid with perturbations\n    for grid_config in [(5, 6), (6, 5)]:\n        rows, cols = grid_config\n        centers = []\n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (j + 0.5) / cols + np.random.uniform(-0.05, 0.05)\n                y = (i + 0.5) / rows + np.random.uniform(-0.05, 0.05)\n                x = np.clip(x, 0.1, 0.9)\n                y = np.clip(y, 0.1, 0.9)\n                centers.append([x, y])\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.09) * np.random.uniform(0.9, 1.1, n)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii with small penalty for variance.\"\"\"\n        radii = x[2*n:]\n        sum_r = np.sum(radii)\n        variance_penalty = 0.05 * np.var(radii)  # Small penalty to encourage uniform sizes\n        return -(sum_r - variance_penalty)  # Negative because we minimize\n    \n    def boundary_constraints(x):\n        \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers[i, 0] - radii[i],  # left boundary\n                1.0 - centers[i, 0] - radii[i],  # right boundary\n                centers[i, 1] - radii[i],  # bottom boundary\n                1.0 - centers[i, 1] - radii[i]  # top boundary\n            ])\n        return np.array(constraints)\n    \n    def overlap_constraints(x):\n        \"\"\"No two circles should overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    # Bounds: centers in [0,1], radii in [0, 0.5]\n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n    \n    # Constraints\n    boundary_cons = NonlinearConstraint(boundary_constraints, 0, np.inf)\n    overlap_cons = NonlinearConstraint(overlap_constraints, 0, np.inf)\n    \n    print(f\"Trying {len(init_strategies)} different initializations...\")\n    \n    for idx, x0 in enumerate(init_strategies):\n        try:\n            # Try SLSQP first (faster)\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[boundary_cons, overlap_cons],\n                options={'maxiter': 500, 'ftol': 1e-8}\n            )\n            \n            if result.success or result.fun < 0:\n                centers_opt = result.x[:2*n].reshape(n, 2)\n                radii_opt = result.x[2*n:]\n                sum_radii = np.sum(radii_opt)\n                \n                # Verify constraints\n                if (np.all(boundary_constraints(result.x) >= -1e-6) and \n                    np.all(overlap_constraints(result.x) >= -1e-6) and\n                    sum_radii > best_sum):\n                    best_sum = sum_radii\n                    best_solution = result.x.copy()\n                    print(f\"  Init {idx+1}: sum_radii = {sum_radii:.6f}\")\n            \n            # If SLSQP didn't work well, try trust-constr for some cases\n            if idx % 5 == 0:\n                result2 = minimize(\n                    objective,\n                    x0,\n                    method='trust-constr',\n                    bounds=bounds,\n                    constraints=[boundary_cons, overlap_cons],\n                    options={'maxiter': 300, 'verbose': 0}\n                )\n                \n                if result2.success or result2.fun < 0:\n                    centers_opt2 = result2.x[:2*n].reshape(n, 2)\n                    radii_opt2 = result2.x[2*n:]\n                    sum_radii2 = np.sum(radii_opt2)\n                    \n                    if (np.all(boundary_constraints(result2.x) >= -1e-6) and \n                        np.all(overlap_constraints(result2.x) >= -1e-6) and\n                        sum_radii2 > best_sum):\n                        best_sum = sum_radii2\n                        best_solution = result2.x.copy()\n                        print(f\"  Init {idx+1} (trust-constr): sum_radii = {sum_radii2:.6f}\")\n        \n        except Exception as e:\n            continue\n    \n    if best_solution is not None:\n        centers = best_solution[:2*n].reshape(n, 2)\n        radii = best_solution[2*n:]\n        sum_radii = np.sum(radii)\n        print(f\"\\nBest solution found: sum_radii = {sum_radii:.6f}\")\n        return centers, radii, sum_radii\n    else:\n        # Fallback: return a simple grid\n        print(\"No valid solution found, using fallback grid\")\n        centers = []\n        for i in range(5):\n            for j in range(6):\n                if len(centers) >= n:\n                    break\n                centers.append([(j + 0.5) / 6, (i + 0.5) / 5])\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:27:50.946573",
  "cost_data": null
}