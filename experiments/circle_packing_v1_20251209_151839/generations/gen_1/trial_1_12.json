{
  "trial_id": "trial_1_12",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\nimport random\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using simulated annealing.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Try multiple independent runs\n    for run in range(5):\n        if run == 0:\n            # Start with hexagonal pattern\n            centers = initialize_hexagonal(n)\n        elif run == 1:\n            # Start with grid pattern\n            centers = initialize_grid(n)\n        else:\n            # Random initialization\n            centers = np.random.rand(n, 2) * 0.8 + 0.1\n        \n        # Simulated annealing\n        centers, radii, sum_radii = simulated_annealing(centers, n)\n        \n        # Local refinement\n        centers, radii, sum_radii = refine_solution(centers, radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_solution = (centers.copy(), radii.copy(), sum_radii)\n    \n    return best_solution\n\ndef initialize_hexagonal(n):\n    \"\"\"Initialize circles in hexagonal pattern.\"\"\"\n    centers = []\n    rows = 5\n    cols = 6\n    \n    hex_height = 0.866  # sqrt(3)/2\n    x_spacing = 1.0 / (cols + 0.5)\n    y_spacing = 1.0 / (rows + 0.5)\n    \n    for row in range(rows):\n        offset = 0.5 * x_spacing if row % 2 == 1 else 0\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = (col + 1) * x_spacing + offset\n            y = (row + 1) * y_spacing\n            centers.append([x, y])\n        if len(centers) >= n:\n            break\n    \n    # Add remaining circles if needed\n    while len(centers) < n:\n        centers.append([np.random.rand() * 0.8 + 0.1, np.random.rand() * 0.8 + 0.1])\n    \n    return np.array(centers[:n])\n\ndef initialize_grid(n):\n    \"\"\"Initialize circles in grid pattern.\"\"\"\n    cols = int(np.ceil(np.sqrt(n)))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    x_spacing = 1.0 / (cols + 1)\n    y_spacing = 1.0 / (rows + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = (j + 1) * x_spacing\n            y = (i + 1) * y_spacing\n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum radii for each circle given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        min_dist = min(centers[i, 0], 1 - centers[i, 0], \n                      centers[i, 1], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = min(min_dist, dist / 2)\n        \n        radii[i] = max(0, min_dist)\n    \n    return radii\n\ndef is_valid(centers, radii):\n    \"\"\"Check if configuration is valid.\"\"\"\n    n = len(centers)\n    \n    # Check boundaries\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n            centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n            return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\ndef simulated_annealing(centers, n, iterations=15000):\n    \"\"\"Perform simulated annealing optimization.\"\"\"\n    current_centers = centers.copy()\n    current_radii = compute_radii(current_centers)\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_sum = current_sum\n    \n    # Temperature schedule\n    T_initial = 0.1\n    T_final = 0.001\n    \n    for iteration in range(iterations):\n        # Adaptive temperature\n        T = T_initial * (T_final / T_initial) ** (iteration / iterations)\n        \n        # Choose move type\n        move_type = random.choices(\n            ['swap', 'optimize_one', 'shift_group', 'perturb'],\n            weights=[0.2, 0.3, 0.2, 0.3]\n        )[0]\n        \n        new_centers = current_centers.copy()\n        \n        if move_type == 'swap':\n            # Swap two circles\n            i, j = random.sample(range(n), 2)\n            new_centers[i], new_centers[j] = new_centers[j].copy(), new_centers[i].copy()\n            \n        elif move_type == 'optimize_one':\n            # Move one circle to maximize its radius\n            i = random.randint(0, n - 1)\n            new_centers[i] = optimize_single_circle(new_centers, i)\n            \n        elif move_type == 'shift_group':\n            # Shift a group of circles\n            group_size = random.randint(2, min(5, n))\n            indices = random.sample(range(n), group_size)\n            shift = (np.random.rand(2) - 0.5) * 0.1\n            for i in indices:\n                new_centers[i] += shift\n                new_centers[i] = np.clip(new_centers[i], 0.05, 0.95)\n                \n        else:  # perturb\n            # Small random perturbation\n            i = random.randint(0, n - 1)\n            perturbation = (np.random.rand(2) - 0.5) * 0.05\n            new_centers[i] += perturbation\n            new_centers[i] = np.clip(new_centers[i], 0.05, 0.95)\n        \n        # Compute new radii\n        new_radii = compute_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        # Metropolis criterion\n        delta = new_sum - current_sum\n        if delta > 0 or random.random() < np.exp(delta / T):\n            current_centers = new_centers\n            current_radii = new_radii\n            current_sum = new_sum\n            \n            if current_sum > best_sum and is_valid(current_centers, current_radii):\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_sum = current_sum\n    \n    return best_centers, best_radii, best_sum\n\ndef optimize_single_circle(centers, idx):\n    \"\"\"Optimize position of a single circle.\"\"\"\n    n = len(centers)\n    other_centers = np.delete(centers, idx, axis=0)\n    \n    # Try to find position that maximizes radius\n    best_pos = centers[idx].copy()\n    best_radius = 0\n    \n    for _ in range(10):\n        # Random position\n        pos = np.random.rand(2) * 0.9 + 0.05\n        \n        # Compute radius at this position\n        min_dist = min(pos[0], 1 - pos[0], pos[1], 1 - pos[1])\n        for other in other_centers:\n            dist = np.linalg.norm(pos - other)\n            min_dist = min(min_dist, dist / 2)\n        \n        if min_dist > best_radius:\n            best_radius = min_dist\n            best_pos = pos\n    \n    return best_pos\n\ndef refine_solution(centers, radii):\n    \"\"\"Refine solution using scipy optimization.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        centers_flat = x.reshape(n, 2)\n        radii = compute_radii(centers_flat)\n        return -np.sum(radii)  # Negative because we minimize\n    \n    def constraint_boundary(x):\n        centers_flat = x.reshape(n, 2)\n        radii = compute_radii(centers_flat)\n        violations = []\n        for i in range(n):\n            violations.append(centers_flat[i, 0] - radii[i])\n            violations.append(1 - centers_flat[i, 0] - radii[i])\n            violations.append(centers_flat[i, 1] - radii[i])\n            violations.append(1 - centers_flat[i, 1] - radii[i])\n        return np.array(violations)\n    \n    # Bounds\n    bounds = [(0.01, 0.99) for _ in range(2 * n)]\n    \n    # Optimize\n    result = minimize(\n        objective,\n        centers.flatten(),\n        method='SLSQP',\n        bounds=bounds,\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    if result.success:\n        centers = result.x.reshape(n, 2)\n        radii = compute_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        if is_valid(centers, radii):\n            return centers, radii, sum_radii\n    \n    # Return original if optimization failed\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5185498452444097,
    "target_ratio": 0.955806392882129,
    "combined_score": 0.955806392882129,
    "eval_time": 193.58633589744568,
    "error": null
  },
  "prompt": "Create a simulated annealing approach with smart moves:\n\n1. Start with grid or hexagonal pattern\n2. At each step, try one of several move types:\n   - Swap two circle positions\n   - Move a circle to maximize its radius\n   - Shift a group of circles together\n   - Rotate a subset around a point\n3. Accept moves based on Metropolis criterion\n4. Use adaptive temperature schedule\n5. Run for 10000+ iterations\n6. Final refinement with scipy.optimize\n7. Try 5+ independent runs\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\nimport random\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using simulated annealing.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Try multiple independent runs\n    for run in range(5):\n        if run == 0:\n            # Start with hexagonal pattern\n            centers = initialize_hexagonal(n)\n        elif run == 1:\n            # Start with grid pattern\n            centers = initialize_grid(n)\n        else:\n            # Random initialization\n            centers = np.random.rand(n, 2) * 0.8 + 0.1\n        \n        # Simulated annealing\n        centers, radii, sum_radii = simulated_annealing(centers, n)\n        \n        # Local refinement\n        centers, radii, sum_radii = refine_solution(centers, radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_solution = (centers.copy(), radii.copy(), sum_radii)\n    \n    return best_solution\n\ndef initialize_hexagonal(n):\n    \"\"\"Initialize circles in hexagonal pattern.\"\"\"\n    centers = []\n    rows = 5\n    cols = 6\n    \n    hex_height = 0.866  # sqrt(3)/2\n    x_spacing = 1.0 / (cols + 0.5)\n    y_spacing = 1.0 / (rows + 0.5)\n    \n    for row in range(rows):\n        offset = 0.5 * x_spacing if row % 2 == 1 else 0\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = (col + 1) * x_spacing + offset\n            y = (row + 1) * y_spacing\n            centers.append([x, y])\n        if len(centers) >= n:\n            break\n    \n    # Add remaining circles if needed\n    while len(centers) < n:\n        centers.append([np.random.rand() * 0.8 + 0.1, np.random.rand() * 0.8 + 0.1])\n    \n    return np.array(centers[:n])\n\ndef initialize_grid(n):\n    \"\"\"Initialize circles in grid pattern.\"\"\"\n    cols = int(np.ceil(np.sqrt(n)))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    x_spacing = 1.0 / (cols + 1)\n    y_spacing = 1.0 / (rows + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = (j + 1) * x_spacing\n            y = (i + 1) * y_spacing\n            centers.append([x, y])\n    \n    return np.array(centers[:n])\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum radii for each circle given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        min_dist = min(centers[i, 0], 1 - centers[i, 0], \n                      centers[i, 1], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = min(min_dist, dist / 2)\n        \n        radii[i] = max(0, min_dist)\n    \n    return radii\n\ndef is_valid(centers, radii):\n    \"\"\"Check if configuration is valid.\"\"\"\n    n = len(centers)\n    \n    # Check boundaries\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n            centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n            return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-10:\n                return False\n    \n    return True\n\ndef simulated_annealing(centers, n, iterations=15000):\n    \"\"\"Perform simulated annealing optimization.\"\"\"\n    current_centers = centers.copy()\n    current_radii = compute_radii(current_centers)\n    current_sum = np.sum(current_radii)\n    \n    best_centers = current_centers.copy()\n    best_radii = current_radii.copy()\n    best_sum = current_sum\n    \n    # Temperature schedule\n    T_initial = 0.1\n    T_final = 0.001\n    \n    for iteration in range(iterations):\n        # Adaptive temperature\n        T = T_initial * (T_final / T_initial) ** (iteration / iterations)\n        \n        # Choose move type\n        move_type = random.choices(\n            ['swap', 'optimize_one', 'shift_group', 'perturb'],\n            weights=[0.2, 0.3, 0.2, 0.3]\n        )[0]\n        \n        new_centers = current_centers.copy()\n        \n        if move_type == 'swap':\n            # Swap two circles\n            i, j = random.sample(range(n), 2)\n            new_centers[i], new_centers[j] = new_centers[j].copy(), new_centers[i].copy()\n            \n        elif move_type == 'optimize_one':\n            # Move one circle to maximize its radius\n            i = random.randint(0, n - 1)\n            new_centers[i] = optimize_single_circle(new_centers, i)\n            \n        elif move_type == 'shift_group':\n            # Shift a group of circles\n            group_size = random.randint(2, min(5, n))\n            indices = random.sample(range(n), group_size)\n            shift = (np.random.rand(2) - 0.5) * 0.1\n            for i in indices:\n                new_centers[i] += shift\n                new_centers[i] = np.clip(new_centers[i], 0.05, 0.95)\n                \n        else:  # perturb\n            # Small random perturbation\n            i = random.randint(0, n - 1)\n            perturbation = (np.random.rand(2) - 0.5) * 0.05\n            new_centers[i] += perturbation\n            new_centers[i] = np.clip(new_centers[i], 0.05, 0.95)\n        \n        # Compute new radii\n        new_radii = compute_radii(new_centers)\n        new_sum = np.sum(new_radii)\n        \n        # Metropolis criterion\n        delta = new_sum - current_sum\n        if delta > 0 or random.random() < np.exp(delta / T):\n            current_centers = new_centers\n            current_radii = new_radii\n            current_sum = new_sum\n            \n            if current_sum > best_sum and is_valid(current_centers, current_radii):\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_sum = current_sum\n    \n    return best_centers, best_radii, best_sum\n\ndef optimize_single_circle(centers, idx):\n    \"\"\"Optimize position of a single circle.\"\"\"\n    n = len(centers)\n    other_centers = np.delete(centers, idx, axis=0)\n    \n    # Try to find position that maximizes radius\n    best_pos = centers[idx].copy()\n    best_radius = 0\n    \n    for _ in range(10):\n        # Random position\n        pos = np.random.rand(2) * 0.9 + 0.05\n        \n        # Compute radius at this position\n        min_dist = min(pos[0], 1 - pos[0], pos[1], 1 - pos[1])\n        for other in other_centers:\n            dist = np.linalg.norm(pos - other)\n            min_dist = min(min_dist, dist / 2)\n        \n        if min_dist > best_radius:\n            best_radius = min_dist\n            best_pos = pos\n    \n    return best_pos\n\ndef refine_solution(centers, radii):\n    \"\"\"Refine solution using scipy optimization.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        centers_flat = x.reshape(n, 2)\n        radii = compute_radii(centers_flat)\n        return -np.sum(radii)  # Negative because we minimize\n    \n    def constraint_boundary(x):\n        centers_flat = x.reshape(n, 2)\n        radii = compute_radii(centers_flat)\n        violations = []\n        for i in range(n):\n            violations.append(centers_flat[i, 0] - radii[i])\n            violations.append(1 - centers_flat[i, 0] - radii[i])\n            violations.append(centers_flat[i, 1] - radii[i])\n            violations.append(1 - centers_flat[i, 1] - radii[i])\n        return np.array(violations)\n    \n    # Bounds\n    bounds = [(0.01, 0.99) for _ in range(2 * n)]\n    \n    # Optimize\n    result = minimize(\n        objective,\n        centers.flatten(),\n        method='SLSQP',\n        bounds=bounds,\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    \n    if result.success:\n        centers = result.x.reshape(n, 2)\n        radii = compute_radii(centers)\n        sum_radii = np.sum(radii)\n        \n        if is_valid(centers, radii):\n            return centers, radii, sum_radii\n    \n    # Return original if optimization failed\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:30:05.510328",
  "cost_data": null
}