{
  "trial_id": "trial_1_7",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom itertools import permutations\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hierarchical approach.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    \n    def pack_in_quadrant(n_circles, quad_bounds, initial_guess=None):\n        \"\"\"Pack circles in a quadrant with bounds [x_min, x_max, y_min, y_max].\"\"\"\n        x_min, x_max, y_min, y_max = quad_bounds\n        width = x_max - x_min\n        height = y_max - y_min\n        \n        if initial_guess is None:\n            # Initialize with grid pattern\n            grid_size = int(np.ceil(np.sqrt(n_circles)))\n            centers = []\n            for i in range(n_circles):\n                row = i // grid_size\n                col = i % grid_size\n                x = x_min + width * (col + 0.5) / grid_size\n                y = y_min + height * (row + 0.5) / grid_size\n                centers.append([x, y])\n            centers = np.array(centers)\n            \n            # Initial radius estimate\n            min_dist = min(width, height) / grid_size\n            radii = np.full(n_circles, min_dist * 0.4)\n            x0 = np.concatenate([centers.flatten(), radii])\n        else:\n            x0 = initial_guess\n        \n        def objective(x):\n            radii = x[2*n_circles:]\n            return -np.sum(radii)\n        \n        def constraints_func(x):\n            centers = x[:2*n_circles].reshape(n_circles, 2)\n            radii = x[2*n_circles:]\n            \n            constraints = []\n            \n            # Circles must be inside quadrant\n            for i in range(n_circles):\n                constraints.append(centers[i, 0] - radii[i] - x_min)  # left\n                constraints.append(x_max - centers[i, 0] - radii[i])  # right\n                constraints.append(centers[i, 1] - radii[i] - y_min)  # bottom\n                constraints.append(y_max - centers[i, 1] - radii[i])  # top\n            \n            # Non-overlapping\n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                 (centers[i, 1] - centers[j, 1])**2)\n                    constraints.append(dist - radii[i] - radii[j])\n            \n            # Radii non-negative\n            for i in range(n_circles):\n                constraints.append(radii[i])\n            \n            return np.array(constraints)\n        \n        # Use SLSQP\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints_func},\n            options={'maxiter': 500, 'ftol': 1e-8}\n        )\n        \n        if result.success or result.fun < 0:\n            centers = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii = result.x[2*n_circles:]\n            return centers, radii, -result.fun\n        else:\n            centers = x0[:2*n_circles].reshape(n_circles, 2)\n            radii = x0[2*n_circles:]\n            return centers, radii, np.sum(radii)\n    \n    def optimize_full_packing(centers, radii):\n        \"\"\"Optimize the full packing configuration.\"\"\"\n        n_circles = len(radii)\n        x0 = np.concatenate([centers.flatten(), radii])\n        \n        def objective(x):\n            radii = x[2*n_circles:]\n            return -np.sum(radii)\n        \n        def constraints_func(x):\n            centers = x[:2*n_circles].reshape(n_circles, 2)\n            radii = x[2*n_circles:]\n            \n            constraints = []\n            \n            # Circles must be inside unit square\n            for i in range(n_circles):\n                constraints.append(centers[i, 0] - radii[i])\n                constraints.append(1.0 - centers[i, 0] - radii[i])\n                constraints.append(centers[i, 1] - radii[i])\n                constraints.append(1.0 - centers[i, 1] - radii[i])\n            \n            # Non-overlapping\n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                 (centers[i, 1] - centers[j, 1])**2)\n                    constraints.append(dist - radii[i] - radii[j])\n            \n            # Radii non-negative\n            for i in range(n_circles):\n                constraints.append(radii[i])\n            \n            return np.array(constraints)\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints_func},\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if result.success or result.fun < 0:\n            centers = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii = result.x[2*n_circles:]\n            return centers, radii, -result.fun\n        else:\n            return centers, radii, np.sum(radii)\n    \n    # Try different allocation strategies\n    allocations = [\n        [6, 6, 7, 7],\n        [6, 7, 6, 7],\n        [7, 6, 6, 7],\n        [5, 7, 7, 7],\n        [7, 5, 7, 7],\n        [7, 7, 5, 7],\n        [7, 7, 7, 5],\n        [6, 6, 6, 8],\n        [8, 6, 6, 6],\n    ]\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    for allocation in allocations:\n        # Define quadrants: [bottom-left, bottom-right, top-left, top-right]\n        quadrants = [\n            [0.0, 0.5, 0.0, 0.5],  # bottom-left\n            [0.5, 1.0, 0.0, 0.5],  # bottom-right\n            [0.0, 0.5, 0.5, 1.0],  # top-left\n            [0.5, 1.0, 0.5, 1.0],  # top-right\n        ]\n        \n        all_centers = []\n        all_radii = []\n        \n        # Pack each quadrant\n        for i, n_circles in enumerate(allocation):\n            centers, radii, _ = pack_in_quadrant(n_circles, quadrants[i])\n            all_centers.append(centers)\n            all_radii.append(radii)\n        \n        # Combine all circles\n        combined_centers = np.vstack(all_centers)\n        combined_radii = np.concatenate(all_radii)\n        \n        # Optimize full configuration\n        final_centers, final_radii, final_sum = optimize_full_packing(\n            combined_centers, combined_radii\n        )\n        \n        if final_sum > best_sum:\n            best_sum = final_sum\n            best_centers = final_centers\n            best_radii = final_radii\n    \n    # Try one more global optimization with best result\n    if best_centers is not None:\n        final_centers, final_radii, final_sum = optimize_full_packing(\n            best_centers, best_radii\n        )\n        if final_sum > best_sum:\n            best_sum = final_sum\n            best_centers = final_centers\n            best_radii = final_radii\n    \n    # Also try a hexagonal packing as alternative\n    def hexagonal_packing():\n        n = 26\n        # Hexagonal grid pattern\n        centers = []\n        rows = 5\n        cols = 6\n        \n        for row in range(rows):\n            n_in_row = cols if row % 2 == 0 else cols - 1\n            for col in range(n_in_row):\n                if len(centers) >= n:\n                    break\n                x = 0.1 + 0.8 * col / (cols - 1) if row % 2 == 0 else 0.1 + 0.8 * (col + 0.5) / (cols - 1)\n                y = 0.1 + 0.8 * row / (rows - 1)\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        \n        hex_centers, hex_radii, hex_sum = optimize_full_packing(centers, radii)\n        return hex_centers, hex_radii, hex_sum\n    \n    hex_centers, hex_radii, hex_sum = hexagonal_packing()\n    if hex_sum > best_sum:\n        best_sum = hex_sum\n        best_centers = hex_centers\n        best_radii = hex_radii\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.601977375113307,
    "target_ratio": 0.9874676945401545,
    "combined_score": 0.9874676945401545,
    "eval_time": 3.181523084640503,
    "error": null
  },
  "prompt": "Create a hierarchical packing approach:\n\n1. Divide the square into 4 quadrants\n2. Pack 6-7 circles optimally in each quadrant independently\n3. Then optimize the entire configuration together\n4. Try different quadrant allocations (6-6-7-7, 5-7-7-7, etc.)\n5. Use scipy.optimize with SLSQP for each phase\n6. Keep the best result across all allocation strategies\n\nThis divide-and-conquer may find better local optima.\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom itertools import permutations\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hierarchical approach.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    \n    def pack_in_quadrant(n_circles, quad_bounds, initial_guess=None):\n        \"\"\"Pack circles in a quadrant with bounds [x_min, x_max, y_min, y_max].\"\"\"\n        x_min, x_max, y_min, y_max = quad_bounds\n        width = x_max - x_min\n        height = y_max - y_min\n        \n        if initial_guess is None:\n            # Initialize with grid pattern\n            grid_size = int(np.ceil(np.sqrt(n_circles)))\n            centers = []\n            for i in range(n_circles):\n                row = i // grid_size\n                col = i % grid_size\n                x = x_min + width * (col + 0.5) / grid_size\n                y = y_min + height * (row + 0.5) / grid_size\n                centers.append([x, y])\n            centers = np.array(centers)\n            \n            # Initial radius estimate\n            min_dist = min(width, height) / grid_size\n            radii = np.full(n_circles, min_dist * 0.4)\n            x0 = np.concatenate([centers.flatten(), radii])\n        else:\n            x0 = initial_guess\n        \n        def objective(x):\n            radii = x[2*n_circles:]\n            return -np.sum(radii)\n        \n        def constraints_func(x):\n            centers = x[:2*n_circles].reshape(n_circles, 2)\n            radii = x[2*n_circles:]\n            \n            constraints = []\n            \n            # Circles must be inside quadrant\n            for i in range(n_circles):\n                constraints.append(centers[i, 0] - radii[i] - x_min)  # left\n                constraints.append(x_max - centers[i, 0] - radii[i])  # right\n                constraints.append(centers[i, 1] - radii[i] - y_min)  # bottom\n                constraints.append(y_max - centers[i, 1] - radii[i])  # top\n            \n            # Non-overlapping\n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                 (centers[i, 1] - centers[j, 1])**2)\n                    constraints.append(dist - radii[i] - radii[j])\n            \n            # Radii non-negative\n            for i in range(n_circles):\n                constraints.append(radii[i])\n            \n            return np.array(constraints)\n        \n        # Use SLSQP\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints_func},\n            options={'maxiter': 500, 'ftol': 1e-8}\n        )\n        \n        if result.success or result.fun < 0:\n            centers = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii = result.x[2*n_circles:]\n            return centers, radii, -result.fun\n        else:\n            centers = x0[:2*n_circles].reshape(n_circles, 2)\n            radii = x0[2*n_circles:]\n            return centers, radii, np.sum(radii)\n    \n    def optimize_full_packing(centers, radii):\n        \"\"\"Optimize the full packing configuration.\"\"\"\n        n_circles = len(radii)\n        x0 = np.concatenate([centers.flatten(), radii])\n        \n        def objective(x):\n            radii = x[2*n_circles:]\n            return -np.sum(radii)\n        \n        def constraints_func(x):\n            centers = x[:2*n_circles].reshape(n_circles, 2)\n            radii = x[2*n_circles:]\n            \n            constraints = []\n            \n            # Circles must be inside unit square\n            for i in range(n_circles):\n                constraints.append(centers[i, 0] - radii[i])\n                constraints.append(1.0 - centers[i, 0] - radii[i])\n                constraints.append(centers[i, 1] - radii[i])\n                constraints.append(1.0 - centers[i, 1] - radii[i])\n            \n            # Non-overlapping\n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                 (centers[i, 1] - centers[j, 1])**2)\n                    constraints.append(dist - radii[i] - radii[j])\n            \n            # Radii non-negative\n            for i in range(n_circles):\n                constraints.append(radii[i])\n            \n            return np.array(constraints)\n        \n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints_func},\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if result.success or result.fun < 0:\n            centers = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii = result.x[2*n_circles:]\n            return centers, radii, -result.fun\n        else:\n            return centers, radii, np.sum(radii)\n    \n    # Try different allocation strategies\n    allocations = [\n        [6, 6, 7, 7],\n        [6, 7, 6, 7],\n        [7, 6, 6, 7],\n        [5, 7, 7, 7],\n        [7, 5, 7, 7],\n        [7, 7, 5, 7],\n        [7, 7, 7, 5],\n        [6, 6, 6, 8],\n        [8, 6, 6, 6],\n    ]\n    \n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    for allocation in allocations:\n        # Define quadrants: [bottom-left, bottom-right, top-left, top-right]\n        quadrants = [\n            [0.0, 0.5, 0.0, 0.5],  # bottom-left\n            [0.5, 1.0, 0.0, 0.5],  # bottom-right\n            [0.0, 0.5, 0.5, 1.0],  # top-left\n            [0.5, 1.0, 0.5, 1.0],  # top-right\n        ]\n        \n        all_centers = []\n        all_radii = []\n        \n        # Pack each quadrant\n        for i, n_circles in enumerate(allocation):\n            centers, radii, _ = pack_in_quadrant(n_circles, quadrants[i])\n            all_centers.append(centers)\n            all_radii.append(radii)\n        \n        # Combine all circles\n        combined_centers = np.vstack(all_centers)\n        combined_radii = np.concatenate(all_radii)\n        \n        # Optimize full configuration\n        final_centers, final_radii, final_sum = optimize_full_packing(\n            combined_centers, combined_radii\n        )\n        \n        if final_sum > best_sum:\n            best_sum = final_sum\n            best_centers = final_centers\n            best_radii = final_radii\n    \n    # Try one more global optimization with best result\n    if best_centers is not None:\n        final_centers, final_radii, final_sum = optimize_full_packing(\n            best_centers, best_radii\n        )\n        if final_sum > best_sum:\n            best_sum = final_sum\n            best_centers = final_centers\n            best_radii = final_radii\n    \n    # Also try a hexagonal packing as alternative\n    def hexagonal_packing():\n        n = 26\n        # Hexagonal grid pattern\n        centers = []\n        rows = 5\n        cols = 6\n        \n        for row in range(rows):\n            n_in_row = cols if row % 2 == 0 else cols - 1\n            for col in range(n_in_row):\n                if len(centers) >= n:\n                    break\n                x = 0.1 + 0.8 * col / (cols - 1) if row % 2 == 0 else 0.1 + 0.8 * (col + 0.5) / (cols - 1)\n                y = 0.1 + 0.8 * row / (rows - 1)\n                centers.append([x, y])\n            if len(centers) >= n:\n                break\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        \n        hex_centers, hex_radii, hex_sum = optimize_full_packing(centers, radii)\n        return hex_centers, hex_radii, hex_sum\n    \n    hex_centers, hex_radii, hex_sum = hexagonal_packing()\n    if hex_sum > best_sum:\n        best_sum = hex_sum\n        best_centers = hex_centers\n        best_radii = hex_radii\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:26:52.343878",
  "cost_data": null
}