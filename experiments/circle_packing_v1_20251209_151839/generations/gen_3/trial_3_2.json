{
  "trial_id": "trial_3_2",
  "generation": 3,
  "parent_id": "trial_2_0",
  "code": "",
  "metrics": {},
  "prompt": "Improve trial_2_0's multi-start approach with better initialization and refinement.\n\nBase code:\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_result = None\n    best_sum_radii = -np.inf\n    \n    # Try multiple starting configurations with different strategies\n    n_starts = 80\n    \n    for start_idx in range(n_starts):\n        np.random.seed(start_idx)\n        \n        # Choose initialization strategy based on start_idx\n        strategy = start_idx % 5\n        \n        if strategy == 0:\n            # Grid with noise\n            centers_init = init_grid_noise(n, start_idx)\n        elif strategy == 1:\n            # Hexagonal pattern\n            centers_init = init_hexagonal(n, start_idx)\n        elif strategy == 2:\n            # Boundary-focused\n            centers_init = init_boundary_focused(n, start_idx)\n        elif strategy == 3:\n            # Random uniform\n            centers_init = init_random_uniform(n)\n        else:\n            # Hexagonal with rotation\n            centers_init = init_hexagonal_rotated(n, start_idx)\n        \n        # Run optimization with reduced iterations\n        result = optimize_packing(centers_init, n, maxiter=300)\n        \n        if result is not None:\n            centers, radii, sum_radii = result\n            if sum_radii > best_sum_radii:\n                best_sum_radii = sum_radii\n                best_result = (centers.copy(), radii.copy(), sum_radii)\n    \n    # Final refinement with more iterations on best solution\n    if best_result is not None:\n        centers_best, radii_best, sum_radii_best = best_result\n        refined_result = optimize_packing(centers_best, n, maxiter=500)\n        if refined_result is not None:\n            centers, radii, sum_radii = refined_result\n            if sum_radii > sum_radii_best:\n                best_result = (centers, radii, sum_radii)\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_fallback_packing(n)\n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n    \n    return best_result\n\ndef init_grid_noise(n, seed):\n    \"\"\"Grid initialization with noise.\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    \n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.randn() * 0.05\n        y = (row + 0.5) / grid_size + np.random.randn() * 0.05\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_hexagonal(n, seed):\n    \"\"\"Hexagonal packing initialization.\"\"\"\n    centers = []\n    row = 0\n    col = 0\n    spacing = 0.18  # Approximate spacing\n    \n    while len(centers) < n:\n        y = row * spacing * np.sqrt(3) / 2 + 0.1\n        x_offset = (spacing / 2) if row % 2 == 1 else 0\n        x = col * spacing + x_offset + 0.1\n        \n        if x <= 0.9 and y <= 0.9:\n            centers.append([x, y])\n        \n        col += 1\n        if x > 0.9:\n            col = 0\n            row += 1\n            if y > 0.9:\n                break\n    \n    # If we don't have enough, add random points\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    centers = np.array(centers[:n])\n    # Add small noise\n    centers += np.random.randn(n, 2) * 0.02\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_hexagonal_rotated(n, seed):\n    \"\"\"Hexagonal packing with rotation.\"\"\"\n    centers = init_hexagonal(n, seed)\n    \n    # Rotate around center\n    angle = (seed % 12) * np.pi / 12\n    center = np.array([0.5, 0.5])\n    \n    # Translate to origin, rotate, translate back\n    centers_centered = centers - center\n    cos_a, sin_a = np.cos(angle), np.sin(angle)\n    rotation_matrix = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n    centers_rotated = centers_centered @ rotation_matrix.T\n    centers = centers_rotated + center\n    \n    return np.clip(centers, 0.05, 0.95)\n\ndef init_boundary_focused(n, seed):\n    \"\"\"Initialize with more circles near boundaries.\"\"\"\n    centers = []\n    \n    # Place circles along boundaries\n    n_boundary = n // 2\n    for i in range(n_boundary):\n        t = i / n_boundary\n        side = i % 4\n        \n        if side == 0:  # Bottom\n            centers.append([t, 0.1 + np.random.rand() * 0.1])\n        elif side == 1:  # Right\n            centers.append([0.9 - np.random.rand() * 0.1, t])\n        elif side == 2:  # Top\n            centers.append([1 - t, 0.9 - np.random.rand() * 0.1])\n        else:  # Left\n            centers.append([0.1 + np.random.rand() * 0.1, 1 - t])\n    \n    # Fill interior\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n    \n    centers = np.array(centers[:n])\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_random_uniform(n):\n    \"\"\"Random uniform initialization.\"\"\"\n    centers = np.random.uniform(0.1, 0.9, size=(n, 2))\n    return centers\n\ndef optimize_packing(centers_init, n, maxiter=300):\n    \"\"\"Optimize a single packing configuration.\"\"\"\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum valid radius for each circle.\"\"\"\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            cx, cy = centers[i]\n            \n            # Distance to boundaries\n            r_max = min(cx, 1 - cx, cy, 1 - cy)\n            \n            # Distance to other circles (vectorized)\n            if i > 0:\n                dists = np.linalg.norm(centers[:i] - centers[i], axis=1)\n                r_max = min(r_max, np.min(dists - radii[:i]) if len(dists) > 0 else r_max)\n            \n            radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (to minimize).\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure circles stay within boundaries.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        # Vectorized boundary constraints\n        constraints = np.concatenate([\n            centers[:, 0] - radii,      # left\n            1 - centers[:, 0] - radii,  # right\n            centers[:, 1] - radii,      # bottom\n            1 - centers[:, 1] - radii   # top\n        ])\n        \n        return constraints\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no circles overlap.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Bounds: centers must be in [0, 1]\n    bounds = [(0.01, 0.99) for _ in range(2 * n)]\n    \n    # Optimize\n    x0 = centers_init.flatten()\n    \n    try:\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        if res.success or res.fun < 0:\n            centers = res.x.reshape(n, 2)\n            radii = compute_radii(centers)\n            \n            # Verify solution\n            if verify_packing(centers, radii):\n                sum_radii = np.sum(radii)\n                return centers, radii, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef verify_packing(centers, radii):\n    \"\"\"Verify that a packing is valid.\"\"\"\n    n = len(centers)\n    \n    # Check boundaries\n    for i in range(n):\n        cx, cy = centers[i]\n        r = radii[i]\n        if cx - r < -1e-6 or cx + r > 1 + 1e-6:\n            return False\n        if cy - r < -1e-6 or cy + r > 1 + 1e-6:\n            return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\ndef create_fallback_packing(n):\n    \"\"\"Create a simple valid packing as fallback.\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n)))\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.1  # Leave some margin\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) * spacing\n        y = (row + 0.5) * spacing\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n, radius)\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nEnhancements:\n1. Increase starts to 100 (from 80)\n2. Add more initialization strategies:\n   - Hexagonal with 6 different orientations (0\u00b0, 15\u00b0, 30\u00b0, 45\u00b0, 60\u00b0, 75\u00b0)\n   - Grid with varying aspect ratios (4x7, 5x6, 6x5, 7x4, 3x9, 9x3)\n   - Boundary-focused with different margin sizes\n3. After finding best, run 3 refinement passes with maxiter=400 each\n4. Between refinement passes, add small random perturbations (\u00b10.002)\n5. Final radius expansion phase\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_result = None\n    best_sum_radii = -np.inf\n    \n    # Try multiple starting configurations with different strategies\n    n_starts = 100\n    \n    for start_idx in range(n_starts):\n        np.random.seed(start_idx)\n        \n        # Choose initialization strategy based on start_idx\n        strategy = start_idx % 10\n        \n        if strategy == 0:\n            # Grid with noise\n            centers_init = init_grid_noise(n, start_idx)\n        elif strategy == 1:\n            # Hexagonal pattern with rotation\n            angle_idx = (start_idx // 10) % 6\n            centers_init = init_hexagonal_rotated(n, angle_idx)\n        elif strategy == 2:\n            # Boundary-focused with varying margins\n            margin = 0.08 + (start_idx % 5) * 0.02\n            centers_init = init_boundary_focused(n, start_idx, margin)\n        elif strategy == 3:\n            # Random uniform\n            centers_init = init_random_uniform(n)\n        elif strategy == 4:\n            # Grid with aspect ratio 4x7\n            centers_init = init_grid_aspect(n, 4, 7, start_idx)\n        elif strategy == 5:\n            # Grid with aspect ratio 5x6\n            centers_init = init_grid_aspect(n, 5, 6, start_idx)\n        elif strategy == 6:\n            # Grid with aspect ratio 6x5\n            centers_init = init_grid_aspect(n, 6, 5, start_idx)\n        elif strategy == 7:\n            # Grid with aspect ratio 7x4\n            centers_init = init_grid_aspect(n, 7, 4, start_idx)\n        elif strategy == 8:\n            # Grid with aspect ratio 3x9\n            centers_init = init_grid_aspect(n, 3, 9, start_idx)\n        else:\n            # Grid with aspect ratio 9x3\n            centers_init = init_grid_aspect(n, 9, 3, start_idx)\n        \n        # Run optimization with reduced iterations\n        result = optimize_packing(centers_init, n, maxiter=300)\n        \n        if result is not None:\n            centers, radii, sum_radii = result\n            if sum_radii > best_sum_radii:\n                best_sum_radii = sum_radii\n                best_result = (centers.copy(), radii.copy(), sum_radii)\n    \n    # Multi-pass refinement with perturbations\n    if best_result is not None:\n        centers_best, radii_best, sum_radii_best = best_result\n        \n        for refinement_pass in range(3):\n            # Add small random perturbations\n            if refinement_pass > 0:\n                centers_best += np.random.randn(n, 2) * 0.002\n                centers_best = np.clip(centers_best, 0.01, 0.99)\n            \n            refined_result = optimize_packing(centers_best, n, maxiter=400)\n            \n            if refined_result is not None:\n                centers, radii, sum_radii = refined_result\n                if sum_radii > sum_radii_best:\n                    sum_radii_best = sum_radii\n                    centers_best = centers.copy()\n                    radii_best = radii.copy()\n                    best_result = (centers_best, radii_best, sum_radii_best)\n        \n        # Final radius expansion phase\n        centers_final, radii_final, sum_radii_final = best_result\n        expanded_result = expand_radii(centers_final, n)\n        \n        if expanded_result is not None:\n            centers_exp, radii_exp, sum_radii_exp = expanded_result\n            if sum_radii_exp > sum_radii_final:\n                best_result = (centers_exp, radii_exp, sum_radii_exp)\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_fallback_packing(n)\n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n    \n    return best_result\n\ndef init_grid_noise(n, seed):\n    \"\"\"Grid initialization with noise.\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    \n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.randn() * 0.05\n        y = (row + 0.5) / grid_size + np.random.randn() * 0.05\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_hexagonal_rotated(n, angle_idx):\n    \"\"\"Hexagonal packing with specific rotation angle.\"\"\"\n    centers = []\n    row = 0\n    col = 0\n    spacing = 0.18  # Approximate spacing\n    \n    while len(centers) < n:\n        y = row * spacing * np.sqrt(3) / 2 + 0.1\n        x_offset = (spacing / 2) if row % 2 == 1 else 0\n        x = col * spacing + x_offset + 0.1\n        \n        if x <= 0.9 and y <= 0.9:\n            centers.append([x, y])\n        \n        col += 1\n        if x > 0.9:\n            col = 0\n            row += 1\n            if y > 0.9:\n                break\n    \n    # If we don't have enough, add random points\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    centers = np.array(centers[:n])\n    \n    # Rotate around center with specific angle\n    angle = angle_idx * np.pi / 12  # 0\u00b0, 15\u00b0, 30\u00b0, 45\u00b0, 60\u00b0, 75\u00b0\n    center = np.array([0.5, 0.5])\n    \n    # Translate to origin, rotate, translate back\n    centers_centered = centers - center\n    cos_a, sin_a = np.cos(angle), np.sin(angle)\n    rotation_matrix = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n    centers_rotated = centers_centered @ rotation_matrix.T\n    centers = centers_rotated + center\n    \n    # Add small noise\n    centers += np.random.randn(n, 2) * 0.02\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_boundary_focused(n, seed, margin=0.1):\n    \"\"\"Initialize with more circles near boundaries.\"\"\"\n    centers = []\n    \n    # Place circles along boundaries\n    n_boundary = n // 2\n    for i in range(n_boundary):\n        t = i / n_boundary\n        side = i % 4\n        \n        if side == 0:  # Bottom\n            centers.append([t, margin + np.random.rand() * margin])\n        elif side == 1:  # Right\n            centers.append([1 - margin - np.random.rand() * margin, t])\n        elif side == 2:  # Top\n            centers.append([1 - t, 1 - margin - np.random.rand() * margin])\n        else:  # Left\n            centers.append([margin + np.random.rand() * margin, 1 - t])\n    \n    # Fill interior\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n    \n    centers = np.array(centers[:n])\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_grid_aspect(n, rows, cols, seed):\n    \"\"\"Grid initialization with specific aspect ratio.\"\"\"\n    centers = []\n    \n    x_spacing = 1.0 / cols\n    y_spacing = 1.0 / rows\n    \n    for i in range(n):\n        row = i // cols\n        col = i % cols\n        x = (col + 0.5) * x_spacing + np.random.randn() * 0.02\n        y = (row + 0.5) * y_spacing + np.random.randn() * 0.02\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_random_uniform(n):\n    \"\"\"Random uniform initialization.\"\"\"\n    centers = np.random.uniform(0.1, 0.9, size=(n, 2))\n    return centers\n\ndef optimize_packing(centers_init, n, maxiter=300):\n    \"\"\"Optimize a single packing configuration.\"\"\"\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum valid radius for each circle.\"\"\"\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            cx, cy = centers[i]\n            \n            # Distance to boundaries\n            r_max = min(cx, 1 - cx, cy, 1 - cy)\n            \n            # Distance to other circles (vectorized)\n            if i > 0:\n                dists = np.linalg.norm(centers[:i] - centers[i], axis=1)\n                r_max = min(r_max, np.min(dists - radii[:i]) if len(dists) > 0 else r_max)\n            \n            radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (to minimize).\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure circles stay within boundaries.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        # Vectorized boundary constraints\n        constraints = np.concatenate([\n            centers[:, 0] - radii,      # left\n            1 - centers[:, 0] - radii,  # right\n            centers[:, 1] - radii,      # bottom\n            1 - centers[:, 1] - radii   # top\n        ])\n        \n        return constraints\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no circles overlap.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Bounds: centers must be in [0, 1]\n    bounds = [(0.01, 0.99) for _ in range(2 * n)]\n    \n    # Optimize\n    x0 = centers_init.flatten()\n    \n    try:\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        if res.success or res.fun < 0:\n            centers = res.x.reshape(n, 2)\n            radii = compute_radii(centers)\n            \n            # Verify solution\n            if verify_packing(centers, radii):\n                sum_radii = np.sum(radii)\n                return centers, radii, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef expand_radii(centers, n):\n    \"\"\"Try to expand radii by small adjustments to centers.\"\"\"\n    \n    def compute_radii_safe(centers):\n        \"\"\"Compute maximum valid radius for each circle with safety margin.\"\"\"\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            cx, cy = centers[i]\n            \n            # Distance to boundaries\n            r_max = min(cx, 1 - cx, cy, 1 - cy)\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, (dist - radii[j]) / 2 if j < i else dist / 2)\n            \n            radii[i] = max(0, r_max * 0.999)  # Small safety margin\n        \n        return radii\n    \n    # Try small local adjustments\n    best_centers = centers.copy()\n    best_radii = compute_radii_safe(centers)\n    best_sum = np.sum(best_radii)\n    \n    for iteration in range(50):\n        # Try moving each circle slightly\n        for i in range(n):\n            for dx in [-0.001, 0.001]:\n                for dy in [-0.001, 0.001]:\n                    test_centers = best_centers.copy()\n                    test_centers[i] += [dx, dy]\n                    \n                    # Check if still valid\n                    if (test_centers[i, 0] >= 0.01 and test_centers[i, 0] <= 0.99 and\n                        test_centers[i, 1] >= 0.01 and test_centers[i, 1] <= 0.99):\n                        \n                        test_radii = compute_radii_safe(test_centers)\n                        \n                        if verify_packing(test_centers, test_radii):\n                            test_sum = np.sum(test_radii)\n                            if test_sum > best_sum:\n                                best_sum = test_sum\n                                best_centers = test_centers.copy()\n                                best_radii = test_radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef verify_packing(centers, radii):\n    \"\"\"Verify that a packing is valid.\"\"\"\n    n = len(centers)\n    \n    # Check boundaries\n    for i in range(n):\n        cx, cy = centers[i]\n        r = radii[i]\n        if cx - r < -1e-6 or cx + r > 1 + 1e-6:\n            return False\n        if cy - r < -1e-6 or cy + r > 1 + 1e-6:\n            return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\ndef create_fallback_packing(n):\n    \"\"\"Create a simple valid packing as fallback.\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n)))\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.1  # Leave some margin\n    \n    centers = []\n    for i",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_result = None\n    best_sum_radii = -np.inf\n    \n    # Try multiple starting configurations with different strategies\n    n_starts = 100\n    \n    for start_idx in range(n_starts):\n        np.random.seed(start_idx)\n        \n        # Choose initialization strategy based on start_idx\n        strategy = start_idx % 10\n        \n        if strategy == 0:\n            # Grid with noise\n            centers_init = init_grid_noise(n, start_idx)\n        elif strategy == 1:\n            # Hexagonal pattern with rotation\n            angle_idx = (start_idx // 10) % 6\n            centers_init = init_hexagonal_rotated(n, angle_idx)\n        elif strategy == 2:\n            # Boundary-focused with varying margins\n            margin = 0.08 + (start_idx % 5) * 0.02\n            centers_init = init_boundary_focused(n, start_idx, margin)\n        elif strategy == 3:\n            # Random uniform\n            centers_init = init_random_uniform(n)\n        elif strategy == 4:\n            # Grid with aspect ratio 4x7\n            centers_init = init_grid_aspect(n, 4, 7, start_idx)\n        elif strategy == 5:\n            # Grid with aspect ratio 5x6\n            centers_init = init_grid_aspect(n, 5, 6, start_idx)\n        elif strategy == 6:\n            # Grid with aspect ratio 6x5\n            centers_init = init_grid_aspect(n, 6, 5, start_idx)\n        elif strategy == 7:\n            # Grid with aspect ratio 7x4\n            centers_init = init_grid_aspect(n, 7, 4, start_idx)\n        elif strategy == 8:\n            # Grid with aspect ratio 3x9\n            centers_init = init_grid_aspect(n, 3, 9, start_idx)\n        else:\n            # Grid with aspect ratio 9x3\n            centers_init = init_grid_aspect(n, 9, 3, start_idx)\n        \n        # Run optimization with reduced iterations\n        result = optimize_packing(centers_init, n, maxiter=300)\n        \n        if result is not None:\n            centers, radii, sum_radii = result\n            if sum_radii > best_sum_radii:\n                best_sum_radii = sum_radii\n                best_result = (centers.copy(), radii.copy(), sum_radii)\n    \n    # Multi-pass refinement with perturbations\n    if best_result is not None:\n        centers_best, radii_best, sum_radii_best = best_result\n        \n        for refinement_pass in range(3):\n            # Add small random perturbations\n            if refinement_pass > 0:\n                centers_best += np.random.randn(n, 2) * 0.002\n                centers_best = np.clip(centers_best, 0.01, 0.99)\n            \n            refined_result = optimize_packing(centers_best, n, maxiter=400)\n            \n            if refined_result is not None:\n                centers, radii, sum_radii = refined_result\n                if sum_radii > sum_radii_best:\n                    sum_radii_best = sum_radii\n                    centers_best = centers.copy()\n                    radii_best = radii.copy()\n                    best_result = (centers_best, radii_best, sum_radii_best)\n        \n        # Final radius expansion phase\n        centers_final, radii_final, sum_radii_final = best_result\n        expanded_result = expand_radii(centers_final, n)\n        \n        if expanded_result is not None:\n            centers_exp, radii_exp, sum_radii_exp = expanded_result\n            if sum_radii_exp > sum_radii_final:\n                best_result = (centers_exp, radii_exp, sum_radii_exp)\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_fallback_packing(n)\n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n    \n    return best_result\n\ndef init_grid_noise(n, seed):\n    \"\"\"Grid initialization with noise.\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    \n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.randn() * 0.05\n        y = (row + 0.5) / grid_size + np.random.randn() * 0.05\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_hexagonal_rotated(n, angle_idx):\n    \"\"\"Hexagonal packing with specific rotation angle.\"\"\"\n    centers = []\n    row = 0\n    col = 0\n    spacing = 0.18  # Approximate spacing\n    \n    while len(centers) < n:\n        y = row * spacing * np.sqrt(3) / 2 + 0.1\n        x_offset = (spacing / 2) if row % 2 == 1 else 0\n        x = col * spacing + x_offset + 0.1\n        \n        if x <= 0.9 and y <= 0.9:\n            centers.append([x, y])\n        \n        col += 1\n        if x > 0.9:\n            col = 0\n            row += 1\n            if y > 0.9:\n                break\n    \n    # If we don't have enough, add random points\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    centers = np.array(centers[:n])\n    \n    # Rotate around center with specific angle\n    angle = angle_idx * np.pi / 12  # 0\u00b0, 15\u00b0, 30\u00b0, 45\u00b0, 60\u00b0, 75\u00b0\n    center = np.array([0.5, 0.5])\n    \n    # Translate to origin, rotate, translate back\n    centers_centered = centers - center\n    cos_a, sin_a = np.cos(angle), np.sin(angle)\n    rotation_matrix = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n    centers_rotated = centers_centered @ rotation_matrix.T\n    centers = centers_rotated + center\n    \n    # Add small noise\n    centers += np.random.randn(n, 2) * 0.02\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_boundary_focused(n, seed, margin=0.1):\n    \"\"\"Initialize with more circles near boundaries.\"\"\"\n    centers = []\n    \n    # Place circles along boundaries\n    n_boundary = n // 2\n    for i in range(n_boundary):\n        t = i / n_boundary\n        side = i % 4\n        \n        if side == 0:  # Bottom\n            centers.append([t, margin + np.random.rand() * margin])\n        elif side == 1:  # Right\n            centers.append([1 - margin - np.random.rand() * margin, t])\n        elif side == 2:  # Top\n            centers.append([1 - t, 1 - margin - np.random.rand() * margin])\n        else:  # Left\n            centers.append([margin + np.random.rand() * margin, 1 - t])\n    \n    # Fill interior\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n    \n    centers = np.array(centers[:n])\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_grid_aspect(n, rows, cols, seed):\n    \"\"\"Grid initialization with specific aspect ratio.\"\"\"\n    centers = []\n    \n    x_spacing = 1.0 / cols\n    y_spacing = 1.0 / rows\n    \n    for i in range(n):\n        row = i // cols\n        col = i % cols\n        x = (col + 0.5) * x_spacing + np.random.randn() * 0.02\n        y = (row + 0.5) * y_spacing + np.random.randn() * 0.02\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    return np.clip(centers, 0.05, 0.95)\n\ndef init_random_uniform(n):\n    \"\"\"Random uniform initialization.\"\"\"\n    centers = np.random.uniform(0.1, 0.9, size=(n, 2))\n    return centers\n\ndef optimize_packing(centers_init, n, maxiter=300):\n    \"\"\"Optimize a single packing configuration.\"\"\"\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum valid radius for each circle.\"\"\"\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            cx, cy = centers[i]\n            \n            # Distance to boundaries\n            r_max = min(cx, 1 - cx, cy, 1 - cy)\n            \n            # Distance to other circles (vectorized)\n            if i > 0:\n                dists = np.linalg.norm(centers[:i] - centers[i], axis=1)\n                r_max = min(r_max, np.min(dists - radii[:i]) if len(dists) > 0 else r_max)\n            \n            radii[i] = max(0, r_max)\n        \n        return radii\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (to minimize).\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure circles stay within boundaries.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        # Vectorized boundary constraints\n        constraints = np.concatenate([\n            centers[:, 0] - radii,      # left\n            1 - centers[:, 0] - radii,  # right\n            centers[:, 1] - radii,      # bottom\n            1 - centers[:, 1] - radii   # top\n        ])\n        \n        return constraints\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no circles overlap.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Bounds: centers must be in [0, 1]\n    bounds = [(0.01, 0.99) for _ in range(2 * n)]\n    \n    # Optimize\n    x0 = centers_init.flatten()\n    \n    try:\n        res = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        if res.success or res.fun < 0:\n            centers = res.x.reshape(n, 2)\n            radii = compute_radii(centers)\n            \n            # Verify solution\n            if verify_packing(centers, radii):\n                sum_radii = np.sum(radii)\n                return centers, radii, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef expand_radii(centers, n):\n    \"\"\"Try to expand radii by small adjustments to centers.\"\"\"\n    \n    def compute_radii_safe(centers):\n        \"\"\"Compute maximum valid radius for each circle with safety margin.\"\"\"\n        radii = np.zeros(n)\n        \n        for i in range(n):\n            cx, cy = centers[i]\n            \n            # Distance to boundaries\n            r_max = min(cx, 1 - cx, cy, 1 - cy)\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, (dist - radii[j]) / 2 if j < i else dist / 2)\n            \n            radii[i] = max(0, r_max * 0.999)  # Small safety margin\n        \n        return radii\n    \n    # Try small local adjustments\n    best_centers = centers.copy()\n    best_radii = compute_radii_safe(centers)\n    best_sum = np.sum(best_radii)\n    \n    for iteration in range(50):\n        # Try moving each circle slightly\n        for i in range(n):\n            for dx in [-0.001, 0.001]:\n                for dy in [-0.001, 0.001]:\n                    test_centers = best_centers.copy()\n                    test_centers[i] += [dx, dy]\n                    \n                    # Check if still valid\n                    if (test_centers[i, 0] >= 0.01 and test_centers[i, 0] <= 0.99 and\n                        test_centers[i, 1] >= 0.01 and test_centers[i, 1] <= 0.99):\n                        \n                        test_radii = compute_radii_safe(test_centers)\n                        \n                        if verify_packing(test_centers, test_radii):\n                            test_sum = np.sum(test_radii)\n                            if test_sum > best_sum:\n                                best_sum = test_sum\n                                best_centers = test_centers.copy()\n                                best_radii = test_radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef verify_packing(centers, radii):\n    \"\"\"Verify that a packing is valid.\"\"\"\n    n = len(centers)\n    \n    # Check boundaries\n    for i in range(n):\n        cx, cy = centers[i]\n        r = radii[i]\n        if cx - r < -1e-6 or cx + r > 1 + 1e-6:\n            return False\n        if cy - r < -1e-6 or cy + r > 1 + 1e-6:\n            return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\ndef create_fallback_packing(n):\n    \"\"\"Create a simple valid packing as fallback.\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n)))\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.1  # Leave some margin\n    \n    centers = []\n    for i",
  "timestamp": "2025-12-09T15:42:15.679734",
  "cost_data": null
}