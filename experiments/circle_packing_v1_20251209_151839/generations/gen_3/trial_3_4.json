{
  "trial_id": "trial_3_4",
  "generation": 3,
  "parent_id": "trial_2_2",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses explicit radius maximization with focused initialization strategies\n    followed by intensive micro-optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Focused initialization strategies (20 total)\n    init_strategies = []\n    \n    # Strategy 1: Optimal grid configurations (4 variations)\n    for grid_size in [(5, 6), (6, 5)]:\n        rows, cols = grid_size\n        for perturbation in [0.0, 0.08]:\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = (j + 0.5) / cols\n                    y = (i + 0.5) / rows\n                    if perturbation > 0:\n                        x += np.random.uniform(-perturbation, perturbation)\n                        y += np.random.uniform(-perturbation, perturbation)\n                        x = np.clip(x, 0.05, 0.95)\n                        y = np.clip(y, 0.05, 0.95)\n                    centers.append([x, y])\n                if len(centers) >= n:\n                    break\n            centers = np.array(centers[:n])\n            spacing = min(1.0/cols, 1.0/rows)\n            r_init = spacing * 0.42\n            radii = np.full(n, r_init)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 2: Hexagonal packing variations (6 variations)\n    for row_spacing in [0.09, 0.095, 0.10]:\n        for offset_factor in [0.0, 0.5]:\n            centers = []\n            r_est = row_spacing / 2\n            rows_count = int(1.0 / row_spacing) + 1\n            for row in range(rows_count):\n                y = (row + 0.5) * row_spacing\n                if y > 1.0:\n                    break\n                cols_in_row = int(1.0 / (r_est * 2)) + 2\n                x_offset = (r_est if row % 2 == 1 else 0) + offset_factor * r_est\n                for col in range(cols_in_row):\n                    x = col * (r_est * 2) + r_est + x_offset\n                    if 0 < x < 1.0 and len(centers) < n:\n                        centers.append([x, y])\n            \n            # Fill remaining with strategic placement\n            while len(centers) < n:\n                centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n            \n            centers = np.array(centers[:n])\n            radii = np.full(n, r_est * 0.95)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 3: Boundary-focused placement (4 variations)\n    for boundary_weight in [0.3, 0.5]:\n        for n_boundary in [12, 16]:\n            centers = []\n            # Place circles along boundary\n            for i in range(n_boundary):\n                t = i / n_boundary\n                if t < 0.25:\n                    x, y = t * 4, 0.05\n                elif t < 0.5:\n                    x, y = 1.0 - 0.05, (t - 0.25) * 4\n                elif t < 0.75:\n                    x, y = 1.0 - (t - 0.5) * 4, 1.0 - 0.05\n                else:\n                    x, y = 0.05, 1.0 - (t - 0.75) * 4\n                centers.append([x, y])\n            \n            # Fill interior\n            n_interior = n - n_boundary\n            interior_grid = int(np.ceil(np.sqrt(n_interior)))\n            for i in range(interior_grid):\n                for j in range(interior_grid):\n                    if len(centers) >= n:\n                        break\n                    x = 0.2 + (j + 0.5) * 0.6 / interior_grid\n                    y = 0.2 + (i + 0.5) * 0.6 / interior_grid\n                    centers.append([x, y])\n            \n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.085)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 4: Random with good radius estimates (6 variations)\n    for _ in range(6):\n        centers = np.random.uniform(0.12, 0.88, (n, 2))\n        r_init = np.random.uniform(0.075, 0.095)\n        radii = np.full(n, r_init) * np.random.uniform(0.85, 1.15, n)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii with minimal penalty for variance.\"\"\"\n        radii = x[2*n:]\n        sum_r = np.sum(radii)\n        variance_penalty = 0.02 * np.var(radii)\n        return -(sum_r - variance_penalty)\n    \n    def boundary_constraints(x):\n        \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers[i, 0] - radii[i],\n                1.0 - centers[i, 0] - radii[i],\n                centers[i, 1] - radii[i],\n                1.0 - centers[i, 1] - radii[i]\n            ])\n        return np.array(constraints)\n    \n    def overlap_constraints(x):\n        \"\"\"No two circles should overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def is_valid(x, tol=1e-6):\n        \"\"\"Check if configuration is valid.\"\"\"\n        return (np.all(boundary_constraints(x) >= -tol) and \n                np.all(overlap_constraints(x) >= -tol))\n    \n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n    boundary_cons = NonlinearConstraint(boundary_constraints, 0, np.inf)\n    overlap_cons = NonlinearConstraint(overlap_constraints, 0, np.inf)\n    \n    print(f\"Phase 1: Trying {len(init_strategies)} focused initializations...\")\n    \n    for idx, x0 in enumerate(init_strategies):\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[boundary_cons, overlap_cons],\n                options={'maxiter': 300, 'ftol': 1e-8}\n            )\n            \n            if result.success or result.fun < 0:\n                centers_opt = result.x[:2*n].reshape(n, 2)\n                radii_opt = result.x[2*n:]\n                sum_radii = np.sum(radii_opt)\n                \n                if is_valid(result.x) and sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_solution = result.x.copy()\n                    print(f\"  Init {idx+1}: sum_radii = {sum_radii:.6f}\")\n        \n        except Exception as e:\n            continue\n    \n    if best_solution is None:\n        print(\"No valid solution found in Phase 1, using fallback grid\")\n        centers = []\n        for i in range(5):\n            for j in range(6):\n                if len(centers) >= n:\n                    break\n                centers.append([(j + 0.5) / 6, (i + 0.5) / 5])\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n    \n    # Phase 2: Post-optimization radius expansion\n    print(\"\\nPhase 2: Applying post-optimization radius expansion...\")\n    x_current = best_solution.copy()\n    \n    for expansion_iter in range(5):\n        expansion_factor = 1.01\n        x_test = x_current.copy()\n        x_test[2*n:] *= expansion_factor\n        \n        if is_valid(x_test):\n            x_current = x_test\n            best_sum = np.sum(x_current[2*n:])\n            print(f\"  Expansion {expansion_iter+1}: sum_radii = {best_sum:.6f}\")\n        else:\n            # Try individual radius expansion\n            improved = False\n            for i in range(n):\n                x_test = x_current.copy()\n                x_test[2*n + i] *= 1.02\n                if is_valid(x_test):\n                    x_current = x_test\n                    improved = True\n            \n            new_sum = np.sum(x_current[2*n:])\n            if new_sum > best_sum:\n                best_sum = new_sum\n                print(f\"  Individual expansion: sum_radii = {best_sum:.6f}\")\n            if not improved:\n                break\n    \n    best_solution = x_current\n    \n    # Phase 3: Micro-optimization loop\n    print(\"\\nPhase 3: Micro-optimization (100 iterations)...\")\n    x_current = best_solution.copy()\n    best_sum = np.sum(x_current[2*n:])\n    \n    micro_step = 0.0005  # Position perturbation\n    radius_factor = 1.0005  # Radius expansion factor\n    \n    for micro_iter in range(100):\n        improved = False\n        \n        # Try moving each circle slightly\n        for i in range(n):\n            for dx, dy in [(micro_step, 0), (-micro_step, 0), (0, micro_step), (0, -micro_step)]:\n                x_test = x_current.copy()\n                x_test[2*i] += dx\n                x_test[2*i + 1] += dy\n                \n                if is_valid(x_test):\n                    # Try to expand all radii after the move\n                    x_test_expand = x_test.copy()\n                    x_test_expand[2*n:] *= 1.002\n                    if is_valid(x_test_expand):\n                        x_test = x_test_expand\n                    \n                    new_sum = np.sum(x_test[2*n:])\n                    if new_sum > best_sum:\n                        x_current = x_test\n                        best_sum = new_sum\n                        improved = True\n        \n        # Try expanding each radius individually\n        for i in range(n):\n            x_test = x_current.copy()\n            x_test[2*n + i] *= radius_factor\n            \n            if is_valid(x_test):\n                new_sum = np.sum(x_test[2*n:])\n                if new_sum > best_sum:\n                    x_current = x_test\n                    best_sum = new_sum\n                    improved = True\n        \n        if improved and (micro_iter + 1) % 10 == 0:\n            print(f\"  Iteration {micro_iter+1}: sum_radii = {best_sum:.6f}\")\n        \n        if not improved and micro_iter > 20:\n            # No improvement for a while, break early\n            break\n    \n    best_solution = x_current\n    print(f\"  Final after micro-optimization: sum_radii = {best_sum:.6f}\")\n    \n    # Phase 4: Final SLSQP polish with very tight tolerances\n    print(\"\\nPhase 4: Final SLSQP polish...\")\n    try:\n        result = minimize(\n            objective,\n            best_solution,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=[boundary_cons, overlap_cons],\n            options={'maxiter': 500, 'ftol': 1e-12}\n        )\n        \n        if is_valid(result.x):\n            new_sum = np.sum(result.x[2*n:])\n            if new_sum > best_sum:\n                best_solution = result.x.copy()\n                best_sum = new_sum\n                print(f\"  Polish improved: sum_radii = {best_sum:.6f}\")\n    except Exception as e:\n        print(f\"  Polish failed: {e}\")\n    \n    # Phase 5: One more radius expansion pass\n    print(\"\\nPhase 5: Final radius expansion...\")\n    x_current = best_solution.copy()\n    \n    for _ in range(10):\n        improved = False\n        \n        # Try uniform expansion\n        x_test = x_current.copy()\n        x_test[2*n:] *= 1.001\n        if is_valid(x_test):\n            x_current = x_test\n            best_sum = np.sum(x_current[2*n:])\n            improved = True\n        \n        # Try individual expansion\n        for i in range(n):\n            x_test = x_current.copy()\n            x_test[2*n + i] *= 1.005\n            if is_valid(x_test):\n                x_current = x_test\n                improved = True\n        \n        new_sum = np.sum(x_current[2*n:])\n        if new_sum > best_sum:\n            best_sum = new_sum\n        \n        if not improved:\n            break\n    \n    best_solution = x_current\n    centers = best_solution[:2*n].reshape(n, 2)\n    radii = best_solution[2*n:]\n    sum_radii = np.sum(radii)\n    \n    print(f\"\\n{'='*60}\")\n    print(f\"FINAL SOLUTION: sum_radii = {sum_radii:.6f}\")\n    print(f\"{'='*60}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.621268983234182,
    "target_ratio": 0.9947889879446611,
    "combined_score": 0.9947889879446611,
    "eval_time": 93.31185412406921,
    "error": null
  },
  "prompt": "Create a fine-tuning approach specifically for high-performing solutions.\n\nStart with trial_2_2's approach:\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses explicit radius maximization with focused initialization strategies.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Focused initialization strategies (20 total)\n    init_strategies = []\n    \n    # Strategy 1: Optimal grid configurations (4 variations)\n    for grid_size in [(5, 6), (6, 5)]:\n        rows, cols = grid_size\n        for perturbation in [0.0, 0.08]:\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = (j + 0.5) / cols\n                    y = (i + 0.5) / rows\n                    if perturbation > 0:\n                        x += np.random.uniform(-perturbation, perturbation)\n                        y += np.random.uniform(-perturbation, perturbation)\n                        x = np.clip(x, 0.05, 0.95)\n                        y = np.clip(y, 0.05, 0.95)\n                    centers.append([x, y])\n                if len(centers) >= n:\n                    break\n            centers = np.array(centers[:n])\n            spacing = min(1.0/cols, 1.0/rows)\n            r_init = spacing * 0.42\n            radii = np.full(n, r_init)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 2: Hexagonal packing variations (6 variations)\n    for row_spacing in [0.09, 0.095, 0.10]:\n        for offset_factor in [0.0, 0.5]:\n            centers = []\n            r_est = row_spacing / 2\n            rows_count = int(1.0 / row_spacing) + 1\n            for row in range(rows_count):\n                y = (row + 0.5) * row_spacing\n                if y > 1.0:\n                    break\n                cols_in_row = int(1.0 / (r_est * 2)) + 2\n                x_offset = (r_est if row % 2 == 1 else 0) + offset_factor * r_est\n                for col in range(cols_in_row):\n                    x = col * (r_est * 2) + r_est + x_offset\n                    if 0 < x < 1.0 and len(centers) < n:\n                        centers.append([x, y])\n            \n            # Fill remaining with strategic placement\n            while len(centers) < n:\n                centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n            \n            centers = np.array(centers[:n])\n            radii = np.full(n, r_est * 0.95)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 3: Boundary-focused placement (4 variations)\n    for boundary_weight in [0.3, 0.5]:\n        for n_boundary in [12, 16]:\n            centers = []\n            # Place circles along boundary\n            for i in range(n_boundary):\n                t = i / n_boundary\n                if t < 0.25:\n                    x, y = t * 4, 0.05\n                elif t < 0.5:\n                    x, y = 1.0 - 0.05, (t - 0.25) * 4\n                elif t < 0.75:\n                    x, y = 1.0 - (t - 0.5) * 4, 1.0 - 0.05\n                else:\n                    x, y = 0.05, 1.0 - (t - 0.75) * 4\n                centers.append([x, y])\n            \n            # Fill interior\n            n_interior = n - n_boundary\n            interior_grid = int(np.ceil(np.sqrt(n_interior)))\n            for i in range(interior_grid):\n                for j in range(interior_grid):\n                    if len(centers) >= n:\n                        break\n                    x = 0.2 + (j + 0.5) * 0.6 / interior_grid\n                    y = 0.2 + (i + 0.5) * 0.6 / interior_grid\n                    centers.append([x, y])\n            \n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.085)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 4: Random with good radius estimates (6 variations)\n    for _ in range(6):\n        centers = np.random.uniform(0.12, 0.88, (n, 2))\n        r_init = np.random.uniform(0.075, 0.095)\n        radii = np.full(n, r_init) * np.random.uniform(0.85, 1.15, n)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii with minimal penalty for variance.\"\"\"\n        radii = x[2*n:]\n        sum_r = np.sum(radii)\n        variance_penalty = 0.02 * np.var(radii)\n        return -(sum_r - variance_penalty)\n    \n    def boundary_constraints(x):\n        \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers[i, 0] - radii[i],\n                1.0 - centers[i, 0] - radii[i],\n                centers[i, 1] - radii[i],\n                1.0 - centers[i, 1] - radii[i]\n            ])\n        return np.array(constraints)\n    \n    def overlap_constraints(x):\n        \"\"\"No two circles should overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n    boundary_cons = NonlinearConstraint(boundary_constraints, 0, np.inf)\n    overlap_cons = NonlinearConstraint(overlap_constraints, 0, np.inf)\n    \n    print(f\"Trying {len(init_strategies)} focused initializations...\")\n    \n    for idx, x0 in enumerate(init_strategies):\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[boundary_cons, overlap_cons],\n                options={'maxiter': 300, 'ftol': 1e-8}\n            )\n            \n            if result.success or result.fun < 0:\n                centers_opt = result.x[:2*n].reshape(n, 2)\n                radii_opt = result.x[2*n:]\n                sum_radii = np.sum(radii_opt)\n                \n                if (np.all(boundary_constraints(result.x) >= -1e-6) and \n                    np.all(overlap_constraints(result.x) >= -1e-6) and\n                    sum_radii > best_sum):\n                    best_sum = sum_radii\n                    best_solution = result.x.copy()\n                    print(f\"  Init {idx+1}: sum_radii = {sum_radii:.6f}\")\n        \n        except Exception as e:\n            continue\n    \n    # Post-optimization: try to expand radii uniformly\n    if best_solution is not None:\n        print(\"\\nApplying post-optimization radius expansion...\")\n        x_current = best_solution.copy()\n        \n        for expansion_iter in range(5):\n            # Try to increase all radii by a small uniform amount\n            expansion_factor = 1.01\n            x_test = x_current.copy()\n            x_test[2*n:] *= expansion_factor\n            \n            if (np.all(boundary_constraints(x_test) >= -1e-6) and \n                np.all(overlap_constraints(x_test) >= -1e-6)):\n                x_current = x_test\n                best_sum = np.sum(x_current[2*n:])\n                print(f\"  Expansion {expansion_iter+1}: sum_radii = {best_sum:.6f}\")\n            else:\n                # Try individual radius expansion\n                radii_current = x_current[2*n:].copy()\n                for i in range(n):\n                    x_test = x_current.copy()\n                    x_test[2*n + i] *= 1.02\n                    if (np.all(boundary_constraints(x_test) >= -1e-6) and \n                        np.all(overlap_constraints(x_test) >= -1e-6)):\n                        x_current = x_test\n                \n                new_sum = np.sum(x_current[2*n:])\n                if new_sum > best_sum:\n                    best_sum = new_sum\n                    print(f\"  Individual expansion: sum_radii = {best_sum:.6f}\")\n                else:\n                    break\n        \n        best_solution = x_current\n        centers = best_solution[:2*n].reshape(n, 2)\n        radii = best_solution[2*n:]\n        sum_radii = np.sum(radii)\n        print(f\"\\nFinal solution: sum_radii = {sum_radii:.6f}\")\n        return centers, radii, sum_radii\n    else:\n        print(\"No valid solution found, using fallback grid\")\n        centers = []\n        for i in range(5):\n            for j in range(6):\n                if len(centers) >= n:\n                    break\n                centers.append([(j + 0.5) / 6, (i + 0.5) / 5])\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nAdd micro-optimization phases:\n1. Run the base optimization (20 focused patterns)\n2. Take the best result\n3. Micro-optimization loop (100 iterations):\n   - For each circle, try moving by \u00b10.0005 in x and y\n   - For each circle, try expanding radius by 0.05%\n   - Accept any improvement\n   - Recompute all radii after each change\n4. Run final SLSQP polish with very tight tolerances (ftol=1e-12)\n5. One more radius expansion pass\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses explicit radius maximization with focused initialization strategies\n    followed by intensive micro-optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Focused initialization strategies (20 total)\n    init_strategies = []\n    \n    # Strategy 1: Optimal grid configurations (4 variations)\n    for grid_size in [(5, 6), (6, 5)]:\n        rows, cols = grid_size\n        for perturbation in [0.0, 0.08]:\n            centers = []\n            for i in range(rows):\n                for j in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = (j + 0.5) / cols\n                    y = (i + 0.5) / rows\n                    if perturbation > 0:\n                        x += np.random.uniform(-perturbation, perturbation)\n                        y += np.random.uniform(-perturbation, perturbation)\n                        x = np.clip(x, 0.05, 0.95)\n                        y = np.clip(y, 0.05, 0.95)\n                    centers.append([x, y])\n                if len(centers) >= n:\n                    break\n            centers = np.array(centers[:n])\n            spacing = min(1.0/cols, 1.0/rows)\n            r_init = spacing * 0.42\n            radii = np.full(n, r_init)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 2: Hexagonal packing variations (6 variations)\n    for row_spacing in [0.09, 0.095, 0.10]:\n        for offset_factor in [0.0, 0.5]:\n            centers = []\n            r_est = row_spacing / 2\n            rows_count = int(1.0 / row_spacing) + 1\n            for row in range(rows_count):\n                y = (row + 0.5) * row_spacing\n                if y > 1.0:\n                    break\n                cols_in_row = int(1.0 / (r_est * 2)) + 2\n                x_offset = (r_est if row % 2 == 1 else 0) + offset_factor * r_est\n                for col in range(cols_in_row):\n                    x = col * (r_est * 2) + r_est + x_offset\n                    if 0 < x < 1.0 and len(centers) < n:\n                        centers.append([x, y])\n            \n            # Fill remaining with strategic placement\n            while len(centers) < n:\n                centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n            \n            centers = np.array(centers[:n])\n            radii = np.full(n, r_est * 0.95)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 3: Boundary-focused placement (4 variations)\n    for boundary_weight in [0.3, 0.5]:\n        for n_boundary in [12, 16]:\n            centers = []\n            # Place circles along boundary\n            for i in range(n_boundary):\n                t = i / n_boundary\n                if t < 0.25:\n                    x, y = t * 4, 0.05\n                elif t < 0.5:\n                    x, y = 1.0 - 0.05, (t - 0.25) * 4\n                elif t < 0.75:\n                    x, y = 1.0 - (t - 0.5) * 4, 1.0 - 0.05\n                else:\n                    x, y = 0.05, 1.0 - (t - 0.75) * 4\n                centers.append([x, y])\n            \n            # Fill interior\n            n_interior = n - n_boundary\n            interior_grid = int(np.ceil(np.sqrt(n_interior)))\n            for i in range(interior_grid):\n                for j in range(interior_grid):\n                    if len(centers) >= n:\n                        break\n                    x = 0.2 + (j + 0.5) * 0.6 / interior_grid\n                    y = 0.2 + (i + 0.5) * 0.6 / interior_grid\n                    centers.append([x, y])\n            \n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.085)\n            init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    # Strategy 4: Random with good radius estimates (6 variations)\n    for _ in range(6):\n        centers = np.random.uniform(0.12, 0.88, (n, 2))\n        r_init = np.random.uniform(0.075, 0.095)\n        radii = np.full(n, r_init) * np.random.uniform(0.85, 1.15, n)\n        init_strategies.append(np.concatenate([centers.flatten(), radii]))\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii with minimal penalty for variance.\"\"\"\n        radii = x[2*n:]\n        sum_r = np.sum(radii)\n        variance_penalty = 0.02 * np.var(radii)\n        return -(sum_r - variance_penalty)\n    \n    def boundary_constraints(x):\n        \"\"\"All circles must be inside [0,1]x[0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers[i, 0] - radii[i],\n                1.0 - centers[i, 0] - radii[i],\n                centers[i, 1] - radii[i],\n                1.0 - centers[i, 1] - radii[i]\n            ])\n        return np.array(constraints)\n    \n    def overlap_constraints(x):\n        \"\"\"No two circles should overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def is_valid(x, tol=1e-6):\n        \"\"\"Check if configuration is valid.\"\"\"\n        return (np.all(boundary_constraints(x) >= -tol) and \n                np.all(overlap_constraints(x) >= -tol))\n    \n    bounds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n    boundary_cons = NonlinearConstraint(boundary_constraints, 0, np.inf)\n    overlap_cons = NonlinearConstraint(overlap_constraints, 0, np.inf)\n    \n    print(f\"Phase 1: Trying {len(init_strategies)} focused initializations...\")\n    \n    for idx, x0 in enumerate(init_strategies):\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[boundary_cons, overlap_cons],\n                options={'maxiter': 300, 'ftol': 1e-8}\n            )\n            \n            if result.success or result.fun < 0:\n                centers_opt = result.x[:2*n].reshape(n, 2)\n                radii_opt = result.x[2*n:]\n                sum_radii = np.sum(radii_opt)\n                \n                if is_valid(result.x) and sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_solution = result.x.copy()\n                    print(f\"  Init {idx+1}: sum_radii = {sum_radii:.6f}\")\n        \n        except Exception as e:\n            continue\n    \n    if best_solution is None:\n        print(\"No valid solution found in Phase 1, using fallback grid\")\n        centers = []\n        for i in range(5):\n            for j in range(6):\n                if len(centers) >= n:\n                    break\n                centers.append([(j + 0.5) / 6, (i + 0.5) / 5])\n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        sum_radii = np.sum(radii)\n        return centers, radii, sum_radii\n    \n    # Phase 2: Post-optimization radius expansion\n    print(\"\\nPhase 2: Applying post-optimization radius expansion...\")\n    x_current = best_solution.copy()\n    \n    for expansion_iter in range(5):\n        expansion_factor = 1.01\n        x_test = x_current.copy()\n        x_test[2*n:] *= expansion_factor\n        \n        if is_valid(x_test):\n            x_current = x_test\n            best_sum = np.sum(x_current[2*n:])\n            print(f\"  Expansion {expansion_iter+1}: sum_radii = {best_sum:.6f}\")\n        else:\n            # Try individual radius expansion\n            improved = False\n            for i in range(n):\n                x_test = x_current.copy()\n                x_test[2*n + i] *= 1.02\n                if is_valid(x_test):\n                    x_current = x_test\n                    improved = True\n            \n            new_sum = np.sum(x_current[2*n:])\n            if new_sum > best_sum:\n                best_sum = new_sum\n                print(f\"  Individual expansion: sum_radii = {best_sum:.6f}\")\n            if not improved:\n                break\n    \n    best_solution = x_current\n    \n    # Phase 3: Micro-optimization loop\n    print(\"\\nPhase 3: Micro-optimization (100 iterations)...\")\n    x_current = best_solution.copy()\n    best_sum = np.sum(x_current[2*n:])\n    \n    micro_step = 0.0005  # Position perturbation\n    radius_factor = 1.0005  # Radius expansion factor\n    \n    for micro_iter in range(100):\n        improved = False\n        \n        # Try moving each circle slightly\n        for i in range(n):\n            for dx, dy in [(micro_step, 0), (-micro_step, 0), (0, micro_step), (0, -micro_step)]:\n                x_test = x_current.copy()\n                x_test[2*i] += dx\n                x_test[2*i + 1] += dy\n                \n                if is_valid(x_test):\n                    # Try to expand all radii after the move\n                    x_test_expand = x_test.copy()\n                    x_test_expand[2*n:] *= 1.002\n                    if is_valid(x_test_expand):\n                        x_test = x_test_expand\n                    \n                    new_sum = np.sum(x_test[2*n:])\n                    if new_sum > best_sum:\n                        x_current = x_test\n                        best_sum = new_sum\n                        improved = True\n        \n        # Try expanding each radius individually\n        for i in range(n):\n            x_test = x_current.copy()\n            x_test[2*n + i] *= radius_factor\n            \n            if is_valid(x_test):\n                new_sum = np.sum(x_test[2*n:])\n                if new_sum > best_sum:\n                    x_current = x_test\n                    best_sum = new_sum\n                    improved = True\n        \n        if improved and (micro_iter + 1) % 10 == 0:\n            print(f\"  Iteration {micro_iter+1}: sum_radii = {best_sum:.6f}\")\n        \n        if not improved and micro_iter > 20:\n            # No improvement for a while, break early\n            break\n    \n    best_solution = x_current\n    print(f\"  Final after micro-optimization: sum_radii = {best_sum:.6f}\")\n    \n    # Phase 4: Final SLSQP polish with very tight tolerances\n    print(\"\\nPhase 4: Final SLSQP polish...\")\n    try:\n        result = minimize(\n            objective,\n            best_solution,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=[boundary_cons, overlap_cons],\n            options={'maxiter': 500, 'ftol': 1e-12}\n        )\n        \n        if is_valid(result.x):\n            new_sum = np.sum(result.x[2*n:])\n            if new_sum > best_sum:\n                best_solution = result.x.copy()\n                best_sum = new_sum\n                print(f\"  Polish improved: sum_radii = {best_sum:.6f}\")\n    except Exception as e:\n        print(f\"  Polish failed: {e}\")\n    \n    # Phase 5: One more radius expansion pass\n    print(\"\\nPhase 5: Final radius expansion...\")\n    x_current = best_solution.copy()\n    \n    for _ in range(10):\n        improved = False\n        \n        # Try uniform expansion\n        x_test = x_current.copy()\n        x_test[2*n:] *= 1.001\n        if is_valid(x_test):\n            x_current = x_test\n            best_sum = np.sum(x_current[2*n:])\n            improved = True\n        \n        # Try individual expansion\n        for i in range(n):\n            x_test = x_current.copy()\n            x_test[2*n + i] *= 1.005\n            if is_valid(x_test):\n                x_current = x_test\n                improved = True\n        \n        new_sum = np.sum(x_current[2*n:])\n        if new_sum > best_sum:\n            best_sum = new_sum\n        \n        if not improved:\n            break\n    \n    best_solution = x_current\n    centers = best_solution[:2*n].reshape(n, 2)\n    radii = best_solution[2*n:]\n    sum_radii = np.sum(radii)\n    \n    print(f\"\\n{'='*60}\")\n    print(f\"FINAL SOLUTION: sum_radii = {sum_radii:.6f}\")\n    print(f\"{'='*60}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:43:47.372666",
  "cost_data": null
}