{
  "trial_id": "trial_3_7",
  "generation": 3,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    gradient-enhanced optimization with analytical gradients.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def objective_grad(x):\n        \"\"\"Analytical gradient of objective.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0  # Gradient w.r.t. radii is -1\n        return grad\n    \n    def constraint_boundary(x):\n        \"\"\"All circles must be inside [0,1] x [0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = np.zeros(4*n)\n        # x - r >= 0\n        constraints[0*n:1*n] = centers[:, 0] - radii\n        # x + r <= 1\n        constraints[1*n:2*n] = 1.0 - centers[:, 0] - radii\n        # y - r >= 0\n        constraints[2*n:3*n] = centers[:, 1] - radii\n        # y + r <= 1\n        constraints[3*n:4*n] = 1.0 - centers[:, 1] - radii\n        \n        return constraints\n    \n    def constraint_boundary_jac(x):\n        \"\"\"Analytical Jacobian of boundary constraints.\"\"\"\n        jac = np.zeros((4*n, 3*n))\n        \n        for i in range(n):\n            # x - r >= 0: dx/dx = 1, dr/dr = -1\n            jac[i, 2*i] = 1.0\n            jac[i, 2*n + i] = -1.0\n            \n            # 1 - x - r >= 0: dx/dx = -1, dr/dr = -1\n            jac[n + i, 2*i] = -1.0\n            jac[n + i, 2*n + i] = -1.0\n            \n            # y - r >= 0: dy/dy = 1, dr/dr = -1\n            jac[2*n + i, 2*i + 1] = 1.0\n            jac[2*n + i, 2*n + i] = -1.0\n            \n            # 1 - y - r >= 0: dy/dy = -1, dr/dr = -1\n            jac[3*n + i, 2*i + 1] = -1.0\n            jac[3*n + i, 2*n + i] = -1.0\n        \n        return jac\n    \n    def constraint_overlap(x):\n        \"\"\"No two circles should overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                # dist - r_i - r_j >= 0\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    def constraint_overlap_jac(x):\n        \"\"\"Analytical Jacobian of overlap constraints.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        num_pairs = n * (n - 1) // 2\n        jac = np.zeros((num_pairs, 3*n))\n        \n        idx = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist > 1e-10:\n                    # Gradient w.r.t. center i\n                    jac[idx, 2*i:2*i+2] = diff / dist\n                    # Gradient w.r.t. center j\n                    jac[idx, 2*j:2*j+2] = -diff / dist\n                \n                # Gradient w.r.t. radii\n                jac[idx, 2*n + i] = -1.0\n                jac[idx, 2*n + j] = -1.0\n                \n                idx += 1\n        \n        return jac\n    \n    def generate_initial_guess(seed):\n        \"\"\"Generate diverse initial configurations.\"\"\"\n        np.random.seed(seed)\n        \n        if seed < 10:\n            # Grid-based initializations\n            grid_size = int(np.ceil(np.sqrt(n)))\n            centers = []\n            for i in range(n):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5 + 0.2 * (np.random.rand() - 0.5)) / grid_size\n                y = (row + 0.5 + 0.2 * (np.random.rand() - 0.5)) / grid_size\n                centers.append([x, y])\n            centers = np.array(centers)\n            radii = np.full(n, 0.8 / grid_size)\n        \n        elif seed < 20:\n            # Hexagonal packing variations\n            centers = []\n            rows = 6\n            for row in range(rows):\n                cols = 5 if row % 2 == 0 else 4\n                for col in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = (col + 0.5 * (row % 2)) / 5 + 0.1\n                    y = row / (rows - 1) * 0.8 + 0.1\n                    centers.append([x, y])\n                if len(centers) >= n:\n                    break\n            \n            while len(centers) < n:\n                centers.append([np.random.rand(), np.random.rand()])\n            \n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.06 + 0.01 * np.random.rand())\n        \n        elif seed < 35:\n            # Circular arrangements with random perturbations\n            angles = np.linspace(0, 2*np.pi, n, endpoint=False)\n            radius_factor = 0.35 + 0.05 * np.random.rand()\n            centers = np.column_stack([\n                0.5 + radius_factor * np.cos(angles) + 0.05 * (np.random.rand(n) - 0.5),\n                0.5 + radius_factor * np.sin(angles) + 0.05 * (np.random.rand(n) - 0.5)\n            ])\n            radii = np.full(n, 0.05 + 0.02 * np.random.rand())\n        \n        else:\n            # Completely random with varying densities\n            centers = np.random.rand(n, 2)\n            radii = 0.03 + 0.03 * np.random.rand(n)\n        \n        # Clip to valid range\n        centers = np.clip(centers, 0.1, 0.9)\n        radii = np.clip(radii, 0.01, 0.15)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    # Run optimization with multiple initializations\n    best_result = None\n    best_value = float('inf')\n    all_results = []\n    \n    print(\"Running 50 diverse initializations with analytical gradients...\")\n    \n    for seed in range(50):\n        x0 = generate_initial_guess(seed)\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                jac=objective_grad,\n                constraints=[\n                    {'type': 'ineq', 'fun': constraint_boundary, 'jac': constraint_boundary_jac},\n                    {'type': 'ineq', 'fun': constraint_overlap, 'jac': constraint_overlap_jac}\n                ],\n                options={'maxiter': 300, 'ftol': 1e-9}\n            )\n            \n            if result.success or result.fun < best_value:\n                all_results.append((result.fun, result.x.copy()))\n                if result.fun < best_value:\n                    best_value = result.fun\n                    best_result = result\n                    print(f\"  Seed {seed}: sum_radii = {-result.fun:.6f}\")\n        \n        except Exception as e:\n            continue\n    \n    # Extended optimization on top 5 solutions\n    print(\"\\nRunning extended optimization on top 5 solutions...\")\n    all_results.sort(key=lambda x: x[0])\n    \n    for i, (_, x0) in enumerate(all_results[:5]):\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                jac=objective_grad,\n                constraints=[\n                    {'type': 'ineq', 'fun': constraint_boundary, 'jac': constraint_boundary_jac},\n                    {'type': 'ineq', 'fun': constraint_overlap, 'jac': constraint_overlap_jac}\n                ],\n                options={'maxiter': 1000, 'ftol': 1e-12}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n                print(f\"  Extended {i+1}: sum_radii = {-result.fun:.6f}\")\n        \n        except Exception as e:\n            continue\n    \n    # Post-optimization refinement\n    print(\"\\nPost-optimization refinement...\")\n    if best_result is not None:\n        x0 = best_result.x.copy()\n        \n        # Try small perturbations\n        for attempt in range(10):\n            x_perturbed = x0.copy()\n            # Small random perturbations\n            x_perturbed += np.random.randn(len(x0)) * 0.001\n            \n            try:\n                result = minimize(\n                    objective,\n                    x_perturbed,\n                    method='SLSQP',\n                    jac=objective_grad,\n                    constraints=[\n                        {'type': 'ineq', 'fun': constraint_boundary, 'jac': constraint_boundary_jac},\n                        {'type': 'ineq', 'fun': constraint_overlap, 'jac': constraint_overlap_jac}\n                    ],\n                    options={'maxiter': 500, 'ftol': 1e-12}\n                )\n                \n                if result.fun < best_value:\n                    best_value = result.fun\n                    best_result = result\n                    print(f\"  Refinement {attempt+1}: sum_radii = {-result.fun:.6f}\")\n            \n            except Exception as e:\n                continue\n    \n    if best_result is None:\n        # Fallback to simple grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            centers.append([(col + 0.5) / grid_size, (row + 0.5) / grid_size])\n        centers = np.array(centers)\n        radii = np.full(n, 0.4 / grid_size)\n        sum_radii = np.sum(radii)\n    else:\n        centers = best_result.x[:2*n].reshape(n, 2)\n        radii = best_result.x[2*n:]\n        sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal sum of radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.6138590513254654,
    "target_ratio": 0.9919768695732317,
    "combined_score": 0.9919768695732317,
    "eval_time": 76.74438333511353,
    "error": null
  },
  "prompt": "Create a gradient-enhanced optimization with analytical gradients.\n\nStrategy:\n1. Define objective with analytical gradient (trivial: gradient of -sum(r) is -1 for each radius)\n2. Define constraints with analytical Jacobians for faster convergence\n3. Use 50 diverse initializations\n4. Optimize with SLSQP using jac parameter for both objective and constraints\n5. This should converge faster and more accurately\n6. Take top 5 and run extended optimization (maxiter=1000)\n7. Add post-optimization refinement\n\nThe analytical gradients should make optimization more efficient and accurate.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    gradient-enhanced optimization with analytical gradients.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def objective_grad(x):\n        \"\"\"Analytical gradient of objective.\"\"\"\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0  # Gradient w.r.t. radii is -1\n        return grad\n    \n    def constraint_boundary(x):\n        \"\"\"All circles must be inside [0,1] x [0,1].\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = np.zeros(4*n)\n        # x - r >= 0\n        constraints[0*n:1*n] = centers[:, 0] - radii\n        # x + r <= 1\n        constraints[1*n:2*n] = 1.0 - centers[:, 0] - radii\n        # y - r >= 0\n        constraints[2*n:3*n] = centers[:, 1] - radii\n        # y + r <= 1\n        constraints[3*n:4*n] = 1.0 - centers[:, 1] - radii\n        \n        return constraints\n    \n    def constraint_boundary_jac(x):\n        \"\"\"Analytical Jacobian of boundary constraints.\"\"\"\n        jac = np.zeros((4*n, 3*n))\n        \n        for i in range(n):\n            # x - r >= 0: dx/dx = 1, dr/dr = -1\n            jac[i, 2*i] = 1.0\n            jac[i, 2*n + i] = -1.0\n            \n            # 1 - x - r >= 0: dx/dx = -1, dr/dr = -1\n            jac[n + i, 2*i] = -1.0\n            jac[n + i, 2*n + i] = -1.0\n            \n            # y - r >= 0: dy/dy = 1, dr/dr = -1\n            jac[2*n + i, 2*i + 1] = 1.0\n            jac[2*n + i, 2*n + i] = -1.0\n            \n            # 1 - y - r >= 0: dy/dy = -1, dr/dr = -1\n            jac[3*n + i, 2*i + 1] = -1.0\n            jac[3*n + i, 2*n + i] = -1.0\n        \n        return jac\n    \n    def constraint_overlap(x):\n        \"\"\"No two circles should overlap.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                # dist - r_i - r_j >= 0\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    def constraint_overlap_jac(x):\n        \"\"\"Analytical Jacobian of overlap constraints.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        num_pairs = n * (n - 1) // 2\n        jac = np.zeros((num_pairs, 3*n))\n        \n        idx = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist > 1e-10:\n                    # Gradient w.r.t. center i\n                    jac[idx, 2*i:2*i+2] = diff / dist\n                    # Gradient w.r.t. center j\n                    jac[idx, 2*j:2*j+2] = -diff / dist\n                \n                # Gradient w.r.t. radii\n                jac[idx, 2*n + i] = -1.0\n                jac[idx, 2*n + j] = -1.0\n                \n                idx += 1\n        \n        return jac\n    \n    def generate_initial_guess(seed):\n        \"\"\"Generate diverse initial configurations.\"\"\"\n        np.random.seed(seed)\n        \n        if seed < 10:\n            # Grid-based initializations\n            grid_size = int(np.ceil(np.sqrt(n)))\n            centers = []\n            for i in range(n):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5 + 0.2 * (np.random.rand() - 0.5)) / grid_size\n                y = (row + 0.5 + 0.2 * (np.random.rand() - 0.5)) / grid_size\n                centers.append([x, y])\n            centers = np.array(centers)\n            radii = np.full(n, 0.8 / grid_size)\n        \n        elif seed < 20:\n            # Hexagonal packing variations\n            centers = []\n            rows = 6\n            for row in range(rows):\n                cols = 5 if row % 2 == 0 else 4\n                for col in range(cols):\n                    if len(centers) >= n:\n                        break\n                    x = (col + 0.5 * (row % 2)) / 5 + 0.1\n                    y = row / (rows - 1) * 0.8 + 0.1\n                    centers.append([x, y])\n                if len(centers) >= n:\n                    break\n            \n            while len(centers) < n:\n                centers.append([np.random.rand(), np.random.rand()])\n            \n            centers = np.array(centers[:n])\n            radii = np.full(n, 0.06 + 0.01 * np.random.rand())\n        \n        elif seed < 35:\n            # Circular arrangements with random perturbations\n            angles = np.linspace(0, 2*np.pi, n, endpoint=False)\n            radius_factor = 0.35 + 0.05 * np.random.rand()\n            centers = np.column_stack([\n                0.5 + radius_factor * np.cos(angles) + 0.05 * (np.random.rand(n) - 0.5),\n                0.5 + radius_factor * np.sin(angles) + 0.05 * (np.random.rand(n) - 0.5)\n            ])\n            radii = np.full(n, 0.05 + 0.02 * np.random.rand())\n        \n        else:\n            # Completely random with varying densities\n            centers = np.random.rand(n, 2)\n            radii = 0.03 + 0.03 * np.random.rand(n)\n        \n        # Clip to valid range\n        centers = np.clip(centers, 0.1, 0.9)\n        radii = np.clip(radii, 0.01, 0.15)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    # Run optimization with multiple initializations\n    best_result = None\n    best_value = float('inf')\n    all_results = []\n    \n    print(\"Running 50 diverse initializations with analytical gradients...\")\n    \n    for seed in range(50):\n        x0 = generate_initial_guess(seed)\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                jac=objective_grad,\n                constraints=[\n                    {'type': 'ineq', 'fun': constraint_boundary, 'jac': constraint_boundary_jac},\n                    {'type': 'ineq', 'fun': constraint_overlap, 'jac': constraint_overlap_jac}\n                ],\n                options={'maxiter': 300, 'ftol': 1e-9}\n            )\n            \n            if result.success or result.fun < best_value:\n                all_results.append((result.fun, result.x.copy()))\n                if result.fun < best_value:\n                    best_value = result.fun\n                    best_result = result\n                    print(f\"  Seed {seed}: sum_radii = {-result.fun:.6f}\")\n        \n        except Exception as e:\n            continue\n    \n    # Extended optimization on top 5 solutions\n    print(\"\\nRunning extended optimization on top 5 solutions...\")\n    all_results.sort(key=lambda x: x[0])\n    \n    for i, (_, x0) in enumerate(all_results[:5]):\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                jac=objective_grad,\n                constraints=[\n                    {'type': 'ineq', 'fun': constraint_boundary, 'jac': constraint_boundary_jac},\n                    {'type': 'ineq', 'fun': constraint_overlap, 'jac': constraint_overlap_jac}\n                ],\n                options={'maxiter': 1000, 'ftol': 1e-12}\n            )\n            \n            if result.fun < best_value:\n                best_value = result.fun\n                best_result = result\n                print(f\"  Extended {i+1}: sum_radii = {-result.fun:.6f}\")\n        \n        except Exception as e:\n            continue\n    \n    # Post-optimization refinement\n    print(\"\\nPost-optimization refinement...\")\n    if best_result is not None:\n        x0 = best_result.x.copy()\n        \n        # Try small perturbations\n        for attempt in range(10):\n            x_perturbed = x0.copy()\n            # Small random perturbations\n            x_perturbed += np.random.randn(len(x0)) * 0.001\n            \n            try:\n                result = minimize(\n                    objective,\n                    x_perturbed,\n                    method='SLSQP',\n                    jac=objective_grad,\n                    constraints=[\n                        {'type': 'ineq', 'fun': constraint_boundary, 'jac': constraint_boundary_jac},\n                        {'type': 'ineq', 'fun': constraint_overlap, 'jac': constraint_overlap_jac}\n                    ],\n                    options={'maxiter': 500, 'ftol': 1e-12}\n                )\n                \n                if result.fun < best_value:\n                    best_value = result.fun\n                    best_result = result\n                    print(f\"  Refinement {attempt+1}: sum_radii = {-result.fun:.6f}\")\n            \n            except Exception as e:\n                continue\n    \n    if best_result is None:\n        # Fallback to simple grid\n        grid_size = int(np.ceil(np.sqrt(n)))\n        centers = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            centers.append([(col + 0.5) / grid_size, (row + 0.5) / grid_size])\n        centers = np.array(centers)\n        radii = np.full(n, 0.4 / grid_size)\n        sum_radii = np.sum(radii)\n    else:\n        centers = best_result.x[:2*n].reshape(n, 2)\n        radii = best_result.x[2*n:]\n        sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal sum of radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:43:31.418330",
  "cost_data": null
}