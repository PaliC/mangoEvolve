{
  "trial_id": "trial_3_14",
  "generation": 3,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Create an ensemble approach combining multiple optimization methods.\n\nStrategy:\n1. Generate 30 good initializations (hexagonal, grid, boundary)\n2. For each initialization, try 3 different optimization methods:\n   - SLSQP with standard settings\n   - SLSQP with tight tolerances\n   - Trust-constr method\n3. This gives 90 optimization runs\n4. Take top 5 results regardless of method used\n5. Run extended optimization on each (maxiter=800)\n6. Best solution: aggressive local search\n7. Final radius expansion\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Generate diverse initializations\n    initializations = []\n    \n    # 1. Hexagonal grids with different orientations and scales\n    for offset_x in [0, 0.05, 0.1]:\n        for offset_y in [0, 0.05, 0.1]:\n            for scale in [0.85, 0.9, 0.95]:\n                centers = generate_hexagonal_grid(n, offset_x, offset_y, scale)\n                if centers is not None:\n                    initializations.append(centers)\n    \n    # 2. Regular grids with variations\n    for rows in range(4, 7):\n        cols = (n + rows - 1) // rows\n        for jitter in [0, 0.02, 0.04]:\n            centers = generate_grid(n, rows, cols, jitter)\n            if centers is not None:\n                initializations.append(centers)\n    \n    # 3. Boundary-focused layouts\n    for boundary_ratio in [0.4, 0.5, 0.6]:\n        centers = generate_boundary_layout(n, boundary_ratio)\n        if centers is not None:\n            initializations.append(centers)\n    \n    # 4. Random perturbations of good layouts\n    if len(initializations) > 0:\n        for _ in range(5):\n            base = initializations[np.random.randint(len(initializations))].copy()\n            base += np.random.normal(0, 0.02, base.shape)\n            base = np.clip(base, 0.1, 0.9)\n            initializations.append(base)\n    \n    # Limit to 30 best diverse initializations\n    initializations = select_diverse_initializations(initializations[:30], n)\n    \n    print(f\"Generated {len(initializations)} initializations\")\n    \n    # Optimization methods to try\n    methods = [\n        {'method': 'SLSQP', 'ftol': 1e-8, 'maxiter': 500},\n        {'method': 'SLSQP', 'ftol': 1e-10, 'maxiter': 500},\n        {'method': 'trust-constr', 'gtol': 1e-8, 'maxiter': 500}\n    ]\n    \n    candidates = []\n    \n    # Run all combinations\n    for init_idx, init_centers in enumerate(initializations):\n        for method_idx, method_params in enumerate(methods):\n            try:\n                centers, radii, sum_radii = optimize_packing(init_centers, **method_params)\n                \n                if is_valid_packing(centers, radii):\n                    candidates.append((sum_radii, centers, radii))\n                    print(f\"Init {init_idx+1}/{len(initializations)}, Method {method_idx+1}: sum_radii = {sum_radii:.6f}\")\n                    \n                    if sum_radii > best_sum:\n                        best_sum = sum_radii\n                        best_centers = centers.copy()\n                        best_radii = radii.copy()\n            except:\n                continue\n    \n    # Sort candidates and take top 5\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    top_candidates = candidates[:5]\n    \n    print(f\"\\nTop 5 candidates: {[c[0] for c in top_candidates]}\")\n    \n    # Extended optimization on top candidates\n    for idx, (_, centers, radii) in enumerate(top_candidates):\n        try:\n            centers, radii, sum_radii = optimize_packing(\n                centers, method='SLSQP', ftol=1e-12, maxiter=800\n            )\n            \n            if is_valid_packing(centers, radii) and sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                print(f\"Extended opt {idx+1}: sum_radii = {sum_radii:.6f}\")\n        except:\n            continue\n    \n    # Aggressive local search on best solution\n    if best_centers is not None:\n        print(\"\\nRunning aggressive local search...\")\n        for iteration in range(10):\n            improved = False\n            \n            # Try moving each circle\n            for i in range(n):\n                original_center = best_centers[i].copy()\n                \n                # Try small moves in different directions\n                for dx, dy in [(0.01, 0), (-0.01, 0), (0, 0.01), (0, -0.01),\n                               (0.007, 0.007), (-0.007, 0.007), (0.007, -0.007), (-0.007, -0.007)]:\n                    test_centers = best_centers.copy()\n                    test_centers[i] += [dx, dy]\n                    \n                    test_radii = compute_max_radii(test_centers)\n                    \n                    if is_valid_packing(test_centers, test_radii):\n                        test_sum = np.sum(test_radii)\n                        if test_sum > best_sum + 1e-9:\n                            best_centers = test_centers\n                            best_radii = test_radii\n                            best_sum = test_sum\n                            improved = True\n                            print(f\"  Local search improved to {best_sum:.6f}\")\n                            break\n                \n                if not improved:\n                    best_centers[i] = original_center\n            \n            if not improved:\n                break\n    \n    # Final radius expansion\n    if best_centers is not None:\n        best_radii = expand_radii(best_centers, best_radii)\n        best_sum = np.sum(best_radii)\n    \n    print(f\"\\nFinal sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef generate_hexagonal_grid(n, offset_x=0, offset_y=0, scale=0.9):\n    \"\"\"Generate hexagonal grid layout.\"\"\"\n    centers = []\n    rows = int(np.ceil(np.sqrt(n / 0.866)))\n    \n    y_spacing = scale / (rows + 1)\n    x_spacing = y_spacing * 0.866\n    \n    for row in range(rows):\n        y = (row + 1) * y_spacing + offset_y\n        if y > 1.0:\n            break\n        \n        x_offset = (row % 2) * x_spacing / 2\n        cols = int(1.0 / x_spacing) + 1\n        \n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = col * x_spacing + x_offset + offset_x\n            \n            if 0 < x < 1 and 0 < y < 1:\n                centers.append([x, y])\n        \n        if len(centers) >= n:\n            break\n    \n    if len(centers) < n:\n        # Fill remaining with random positions\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    return np.array(centers[:n])\n\ndef generate_grid(n, rows, cols, jitter=0):\n    \"\"\"Generate regular grid with optional jitter.\"\"\"\n    centers = []\n    \n    x_spacing = 1.0 / (cols + 1)\n    y_spacing = 1.0 / (rows + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            \n            x = (j + 1) * x_spacing\n            y = (i + 1) * y_spacing\n            \n            if jitter > 0:\n                x += np.random.uniform(-jitter, jitter)\n                y += np.random.uniform(-jitter, jitter)\n            \n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n    \n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    return np.array(centers[:n])\n\ndef generate_boundary_layout(n, boundary_ratio=0.5):\n    \"\"\"Generate layout with circles along boundary and interior.\"\"\"\n    centers = []\n    n_boundary = int(n * boundary_ratio)\n    n_interior = n - n_boundary\n    \n    # Place circles along boundary\n    perimeter_positions = np.linspace(0, 4, n_boundary, endpoint=False)\n    \n    for pos in perimeter_positions:\n        if pos < 1:  # Bottom edge\n            centers.append([pos, 0.05])\n        elif pos < 2:  # Right edge\n            centers.append([0.95, pos - 1])\n        elif pos < 3:  # Top edge\n            centers.append([3 - pos, 0.95])\n        else:  # Left edge\n            centers.append([0.05, 4 - pos])\n    \n    # Place interior circles\n    interior_rows = int(np.sqrt(n_interior))\n    interior_cols = (n_interior + interior_rows - 1) // interior_rows\n    \n    for i in range(interior_rows):\n        for j in range(interior_cols):\n            if len(centers) >= n:\n                break\n            x = 0.2 + (j / (interior_cols + 1)) * 0.6\n            y = 0.2 + (i / (interior_rows + 1)) * 0.6\n            centers.append([x, y])\n    \n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    return np.array(centers[:n])\n\ndef select_diverse_initializations(initializations, n, max_count=30):\n    \"\"\"Select diverse initializations based on pairwise distances.\"\"\"\n    if len(initializations) <= max_count:\n        return initializations\n    \n    # Start with first initialization\n    selected = [initializations[0]]\n    remaining = list(range(1, len(initializations)))\n    \n    while len(selected) < max_count and remaining:\n        # Find initialization most different from selected ones\n        max_min_dist = -1\n        best_idx = None\n        \n        for idx in remaining:\n            min_dist = float('inf')\n            for sel_init in selected:\n                dist = np.linalg.norm(initializations[idx] - sel_init)\n                min_dist = min(min_dist, dist)\n            \n            if min_dist > max_min_dist:\n                max_min_dist = min_dist\n                best_idx = idx\n        \n        if best_idx is not None:\n            selected.append(initializations[best_idx])\n            remaining.remove(best_idx)\n        else:\n            break\n    \n    return selected\n\ndef optimize_packing(initial_centers, method='SLSQP', ftol=1e-8, gtol=1e-8, maxiter=500):\n    \"\"\"Optimize circle packing.\"\"\"\n    n = len(initial_centers)\n    x0 = initial_centers.flatten()\n    \n    def objective(x):\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        dists = pdist(centers)\n        radii_sums = np.array([radii[i] + radii[j] \n                               for i in range(n) for j in range(i+1, n)])\n        return dists - radii_sums\n    \n    def constraint_inside_square(x):\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers[i, 0] - radii[i],\n                1 - centers[i, 0] - radii[i],\n                centers[i, 1] - radii[i],\n                1 - centers[i, 1] - radii[i]\n            ])\n        return np.array(constraints)\n    \n    bounds = [(0, 1)] * (2 * n)\n    \n    if method == 'trust-constr':\n        constraints = [\n            NonlinearConstraint(constraint_no_overlap, 0, np.inf),\n            NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        ]\n        result = minimize(objective, x0, method='trust-constr',\n                         constraints=constraints, bounds=bounds,\n                         options={'maxiter': maxiter, 'gtol': gtol})\n    else:\n        constraints = [\n            {'type': 'ineq', 'fun': constraint_no_overlap},\n            {'type': 'ineq', 'fun': constraint_inside_square}\n        ]\n        result = minimize(objective, x0, method='SLSQP',\n                         bounds=bounds, constraints=constraints,\n                         options={'maxiter': maxiter, 'ftol': ftol})\n    \n    centers = result.x.reshape(n, 2)\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum valid radius for each circle.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], 1 - centers[i, 0],\n                   centers[i, 1], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef is_valid_packing(centers, radii, tol=1e-6):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check boundaries\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < -tol or\n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or\n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    return True\n\ndef expand_radii(centers, radii, epsilon=1e-9):\n    \"\"\"Expand radii slightly while maintaining validity",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom scipy.spatial.distance import pdist, squareform\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Generate diverse initializations\n    initializations = []\n    \n    # 1. Hexagonal grids with different orientations and scales\n    for offset_x in [0, 0.05, 0.1]:\n        for offset_y in [0, 0.05, 0.1]:\n            for scale in [0.85, 0.9, 0.95]:\n                centers = generate_hexagonal_grid(n, offset_x, offset_y, scale)\n                if centers is not None:\n                    initializations.append(centers)\n    \n    # 2. Regular grids with variations\n    for rows in range(4, 7):\n        cols = (n + rows - 1) // rows\n        for jitter in [0, 0.02, 0.04]:\n            centers = generate_grid(n, rows, cols, jitter)\n            if centers is not None:\n                initializations.append(centers)\n    \n    # 3. Boundary-focused layouts\n    for boundary_ratio in [0.4, 0.5, 0.6]:\n        centers = generate_boundary_layout(n, boundary_ratio)\n        if centers is not None:\n            initializations.append(centers)\n    \n    # 4. Random perturbations of good layouts\n    if len(initializations) > 0:\n        for _ in range(5):\n            base = initializations[np.random.randint(len(initializations))].copy()\n            base += np.random.normal(0, 0.02, base.shape)\n            base = np.clip(base, 0.1, 0.9)\n            initializations.append(base)\n    \n    # Limit to 30 best diverse initializations\n    initializations = select_diverse_initializations(initializations[:30], n)\n    \n    print(f\"Generated {len(initializations)} initializations\")\n    \n    # Optimization methods to try\n    methods = [\n        {'method': 'SLSQP', 'ftol': 1e-8, 'maxiter': 500},\n        {'method': 'SLSQP', 'ftol': 1e-10, 'maxiter': 500},\n        {'method': 'trust-constr', 'gtol': 1e-8, 'maxiter': 500}\n    ]\n    \n    candidates = []\n    \n    # Run all combinations\n    for init_idx, init_centers in enumerate(initializations):\n        for method_idx, method_params in enumerate(methods):\n            try:\n                centers, radii, sum_radii = optimize_packing(init_centers, **method_params)\n                \n                if is_valid_packing(centers, radii):\n                    candidates.append((sum_radii, centers, radii))\n                    print(f\"Init {init_idx+1}/{len(initializations)}, Method {method_idx+1}: sum_radii = {sum_radii:.6f}\")\n                    \n                    if sum_radii > best_sum:\n                        best_sum = sum_radii\n                        best_centers = centers.copy()\n                        best_radii = radii.copy()\n            except:\n                continue\n    \n    # Sort candidates and take top 5\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    top_candidates = candidates[:5]\n    \n    print(f\"\\nTop 5 candidates: {[c[0] for c in top_candidates]}\")\n    \n    # Extended optimization on top candidates\n    for idx, (_, centers, radii) in enumerate(top_candidates):\n        try:\n            centers, radii, sum_radii = optimize_packing(\n                centers, method='SLSQP', ftol=1e-12, maxiter=800\n            )\n            \n            if is_valid_packing(centers, radii) and sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                print(f\"Extended opt {idx+1}: sum_radii = {sum_radii:.6f}\")\n        except:\n            continue\n    \n    # Aggressive local search on best solution\n    if best_centers is not None:\n        print(\"\\nRunning aggressive local search...\")\n        for iteration in range(10):\n            improved = False\n            \n            # Try moving each circle\n            for i in range(n):\n                original_center = best_centers[i].copy()\n                \n                # Try small moves in different directions\n                for dx, dy in [(0.01, 0), (-0.01, 0), (0, 0.01), (0, -0.01),\n                               (0.007, 0.007), (-0.007, 0.007), (0.007, -0.007), (-0.007, -0.007)]:\n                    test_centers = best_centers.copy()\n                    test_centers[i] += [dx, dy]\n                    \n                    test_radii = compute_max_radii(test_centers)\n                    \n                    if is_valid_packing(test_centers, test_radii):\n                        test_sum = np.sum(test_radii)\n                        if test_sum > best_sum + 1e-9:\n                            best_centers = test_centers\n                            best_radii = test_radii\n                            best_sum = test_sum\n                            improved = True\n                            print(f\"  Local search improved to {best_sum:.6f}\")\n                            break\n                \n                if not improved:\n                    best_centers[i] = original_center\n            \n            if not improved:\n                break\n    \n    # Final radius expansion\n    if best_centers is not None:\n        best_radii = expand_radii(best_centers, best_radii)\n        best_sum = np.sum(best_radii)\n    \n    print(f\"\\nFinal sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef generate_hexagonal_grid(n, offset_x=0, offset_y=0, scale=0.9):\n    \"\"\"Generate hexagonal grid layout.\"\"\"\n    centers = []\n    rows = int(np.ceil(np.sqrt(n / 0.866)))\n    \n    y_spacing = scale / (rows + 1)\n    x_spacing = y_spacing * 0.866\n    \n    for row in range(rows):\n        y = (row + 1) * y_spacing + offset_y\n        if y > 1.0:\n            break\n        \n        x_offset = (row % 2) * x_spacing / 2\n        cols = int(1.0 / x_spacing) + 1\n        \n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = col * x_spacing + x_offset + offset_x\n            \n            if 0 < x < 1 and 0 < y < 1:\n                centers.append([x, y])\n        \n        if len(centers) >= n:\n            break\n    \n    if len(centers) < n:\n        # Fill remaining with random positions\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    return np.array(centers[:n])\n\ndef generate_grid(n, rows, cols, jitter=0):\n    \"\"\"Generate regular grid with optional jitter.\"\"\"\n    centers = []\n    \n    x_spacing = 1.0 / (cols + 1)\n    y_spacing = 1.0 / (rows + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            \n            x = (j + 1) * x_spacing\n            y = (i + 1) * y_spacing\n            \n            if jitter > 0:\n                x += np.random.uniform(-jitter, jitter)\n                y += np.random.uniform(-jitter, jitter)\n            \n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n    \n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    return np.array(centers[:n])\n\ndef generate_boundary_layout(n, boundary_ratio=0.5):\n    \"\"\"Generate layout with circles along boundary and interior.\"\"\"\n    centers = []\n    n_boundary = int(n * boundary_ratio)\n    n_interior = n - n_boundary\n    \n    # Place circles along boundary\n    perimeter_positions = np.linspace(0, 4, n_boundary, endpoint=False)\n    \n    for pos in perimeter_positions:\n        if pos < 1:  # Bottom edge\n            centers.append([pos, 0.05])\n        elif pos < 2:  # Right edge\n            centers.append([0.95, pos - 1])\n        elif pos < 3:  # Top edge\n            centers.append([3 - pos, 0.95])\n        else:  # Left edge\n            centers.append([0.05, 4 - pos])\n    \n    # Place interior circles\n    interior_rows = int(np.sqrt(n_interior))\n    interior_cols = (n_interior + interior_rows - 1) // interior_rows\n    \n    for i in range(interior_rows):\n        for j in range(interior_cols):\n            if len(centers) >= n:\n                break\n            x = 0.2 + (j / (interior_cols + 1)) * 0.6\n            y = 0.2 + (i / (interior_rows + 1)) * 0.6\n            centers.append([x, y])\n    \n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n    \n    return np.array(centers[:n])\n\ndef select_diverse_initializations(initializations, n, max_count=30):\n    \"\"\"Select diverse initializations based on pairwise distances.\"\"\"\n    if len(initializations) <= max_count:\n        return initializations\n    \n    # Start with first initialization\n    selected = [initializations[0]]\n    remaining = list(range(1, len(initializations)))\n    \n    while len(selected) < max_count and remaining:\n        # Find initialization most different from selected ones\n        max_min_dist = -1\n        best_idx = None\n        \n        for idx in remaining:\n            min_dist = float('inf')\n            for sel_init in selected:\n                dist = np.linalg.norm(initializations[idx] - sel_init)\n                min_dist = min(min_dist, dist)\n            \n            if min_dist > max_min_dist:\n                max_min_dist = min_dist\n                best_idx = idx\n        \n        if best_idx is not None:\n            selected.append(initializations[best_idx])\n            remaining.remove(best_idx)\n        else:\n            break\n    \n    return selected\n\ndef optimize_packing(initial_centers, method='SLSQP', ftol=1e-8, gtol=1e-8, maxiter=500):\n    \"\"\"Optimize circle packing.\"\"\"\n    n = len(initial_centers)\n    x0 = initial_centers.flatten()\n    \n    def objective(x):\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        dists = pdist(centers)\n        radii_sums = np.array([radii[i] + radii[j] \n                               for i in range(n) for j in range(i+1, n)])\n        return dists - radii_sums\n    \n    def constraint_inside_square(x):\n        centers = x.reshape(n, 2)\n        radii = compute_max_radii(centers)\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers[i, 0] - radii[i],\n                1 - centers[i, 0] - radii[i],\n                centers[i, 1] - radii[i],\n                1 - centers[i, 1] - radii[i]\n            ])\n        return np.array(constraints)\n    \n    bounds = [(0, 1)] * (2 * n)\n    \n    if method == 'trust-constr':\n        constraints = [\n            NonlinearConstraint(constraint_no_overlap, 0, np.inf),\n            NonlinearConstraint(constraint_inside_square, 0, np.inf)\n        ]\n        result = minimize(objective, x0, method='trust-constr',\n                         constraints=constraints, bounds=bounds,\n                         options={'maxiter': maxiter, 'gtol': gtol})\n    else:\n        constraints = [\n            {'type': 'ineq', 'fun': constraint_no_overlap},\n            {'type': 'ineq', 'fun': constraint_inside_square}\n        ]\n        result = minimize(objective, x0, method='SLSQP',\n                         bounds=bounds, constraints=constraints,\n                         options={'maxiter': maxiter, 'ftol': ftol})\n    \n    centers = result.x.reshape(n, 2)\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum valid radius for each circle.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        r_max = min(centers[i, 0], 1 - centers[i, 0],\n                   centers[i, 1], 1 - centers[i, 1])\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef is_valid_packing(centers, radii, tol=1e-6):\n    \"\"\"Check if packing satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check boundaries\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < -tol or\n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or\n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    return True\n\ndef expand_radii(centers, radii, epsilon=1e-9):\n    \"\"\"Expand radii slightly while maintaining validity",
  "timestamp": "2025-12-09T15:44:13.542335",
  "cost_data": null
}