{
  "trial_id": "trial_3_8",
  "generation": 3,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Create a constraint-aware initialization approach.\n\nStrategy:\n1. Generate 60 initializations that explicitly respect constraints:\n   - For hexagonal patterns, compute exact radii that fit without overlap\n   - For grid patterns, use maximum feasible radius for spacing\n   - For boundary patterns, maximize radii for circles on edges\n2. These \"constraint-aware\" initializations should be closer to optimal\n3. Quick optimization (maxiter=200) on all 60\n4. Extended optimization (maxiter=800) on top 5\n5. Aggressive local search on best\n6. Final radius expansion\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses constraint-aware initialization with multiple patterns.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Generate 60 constraint-aware initializations\n    initializations = []\n    \n    # 1. Hexagonal patterns (20 variations)\n    for seed in range(20):\n        centers, radii = generate_hexagonal_packing(n, seed)\n        initializations.append((centers, radii))\n    \n    # 2. Grid patterns (15 variations)\n    for seed in range(15):\n        centers, radii = generate_grid_packing(n, seed)\n        initializations.append((centers, radii))\n    \n    # 3. Boundary-focused patterns (15 variations)\n    for seed in range(15):\n        centers, radii = generate_boundary_packing(n, seed)\n        initializations.append((centers, radii))\n    \n    # 4. Mixed patterns (10 variations)\n    for seed in range(10):\n        centers, radii = generate_mixed_packing(n, seed)\n        initializations.append((centers, radii))\n    \n    # Quick optimization on all 60 initializations\n    print(\"Phase 1: Quick optimization on 60 initializations...\")\n    candidates = []\n    for idx, (centers, radii) in enumerate(initializations):\n        result = optimize_packing(centers, radii, maxiter=200)\n        candidates.append((result['sum_radii'], result['centers'], result['radii']))\n        if result['sum_radii'] > best_sum:\n            best_sum = result['sum_radii']\n            best_solution = result\n        if (idx + 1) % 10 == 0:\n            print(f\"  Processed {idx + 1}/60, best so far: {best_sum:.6f}\")\n    \n    # Sort and get top 5\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    print(f\"\\nPhase 2: Extended optimization on top 5...\")\n    print(f\"  Top 5 sums: {[c[0] for c in candidates[:5]]}\")\n    \n    # Extended optimization on top 5\n    for idx, (_, centers, radii) in enumerate(candidates[:5]):\n        result = optimize_packing(centers, radii, maxiter=800)\n        if result['sum_radii'] > best_sum:\n            best_sum = result['sum_radii']\n            best_solution = result\n        print(f\"  Candidate {idx + 1}/5: {result['sum_radii']:.6f}\")\n    \n    # Aggressive local search on best\n    print(f\"\\nPhase 3: Aggressive local search...\")\n    result = aggressive_local_search(best_solution['centers'], best_solution['radii'])\n    if result['sum_radii'] > best_sum:\n        best_sum = result['sum_radii']\n        best_solution = result\n    print(f\"  After local search: {best_sum:.6f}\")\n    \n    # Final radius expansion\n    print(f\"\\nPhase 4: Final radius expansion...\")\n    centers, radii = expand_radii(best_solution['centers'], best_solution['radii'])\n    sum_radii = np.sum(radii)\n    print(f\"  Final sum: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef generate_hexagonal_packing(n, seed):\n    \"\"\"Generate hexagonal pattern with constraint-aware radii.\"\"\"\n    np.random.seed(seed)\n    \n    # Determine grid size for hexagonal packing\n    rows = int(np.sqrt(n * 2 / np.sqrt(3))) + 1\n    cols = int(np.sqrt(n * np.sqrt(3) / 2)) + 1\n    \n    # Compute spacing to fit in unit square\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    # Maximum radius that prevents overlap in hexagonal grid\n    hex_spacing = min(dx, dy * 2 / np.sqrt(3))\n    max_radius = hex_spacing / 2.1  # Conservative estimate\n    \n    centers = []\n    for row in range(rows):\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = (col + 0.5 + (0.5 if row % 2 else 0)) * dx\n            y = (row + 0.5) * dy\n            # Add small random perturbation\n            x += np.random.uniform(-0.01, 0.01)\n            y += np.random.uniform(-0.01, 0.01)\n            centers.append([x, y])\n        if len(centers) >= n:\n            break\n    \n    centers = np.array(centers[:n])\n    \n    # Ensure centers are within bounds with margin for radius\n    centers = np.clip(centers, max_radius + 0.01, 1 - max_radius - 0.01)\n    \n    # Initialize radii based on nearest neighbor distance\n    radii = np.full(n, max_radius * 0.9)\n    \n    return centers, radii\n\ndef generate_grid_packing(n, seed):\n    \"\"\"Generate grid pattern with maximum feasible radii.\"\"\"\n    np.random.seed(seed)\n    \n    # Find grid dimensions\n    cols = int(np.ceil(np.sqrt(n)))\n    rows = int(np.ceil(n / cols))\n    \n    dx = 1.0 / (cols + 1)\n    dy = 1.0 / (rows + 1)\n    \n    # Maximum radius for grid spacing\n    max_radius = min(dx, dy) / 2.2\n    \n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = (j + 1) * dx + np.random.uniform(-0.01, 0.01)\n            y = (i + 1) * dy + np.random.uniform(-0.01, 0.01)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n])\n    centers = np.clip(centers, max_radius + 0.01, 1 - max_radius - 0.01)\n    \n    radii = np.full(n, max_radius * 0.9)\n    \n    return centers, radii\n\ndef generate_boundary_packing(n, seed):\n    \"\"\"Generate pattern with circles on boundaries.\"\"\"\n    np.random.seed(seed)\n    \n    # Place circles on perimeter\n    n_boundary = min(n // 2, 16)\n    n_interior = n - n_boundary\n    \n    centers = []\n    \n    # Boundary circles\n    for i in range(n_boundary):\n        t = i / n_boundary\n        side = int(t * 4)\n        s = (t * 4) % 1\n        \n        if side == 0:  # Bottom\n            x, y = s, 0.05\n        elif side == 1:  # Right\n            x, y = 0.95, s\n        elif side == 2:  # Top\n            x, y = 1 - s, 0.95\n        else:  # Left\n            x, y = 0.05, 1 - s\n        \n        centers.append([x, y])\n    \n    # Interior circles\n    for i in range(n_interior):\n        x = np.random.uniform(0.2, 0.8)\n        y = np.random.uniform(0.2, 0.8)\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Compute safe radii\n    radii = []\n    for i, (x, y) in enumerate(centers):\n        # Distance to boundaries\n        margin_to_boundary = min(x, y, 1 - x, 1 - y)\n        \n        # Distance to other circles (approximate)\n        if len(radii) > 0:\n            dists = np.sqrt((centers[:i, 0] - x)**2 + (centers[:i, 1] - y)**2)\n            min_dist = np.min(dists) if len(dists) > 0 else 1.0\n            max_r = min(margin_to_boundary * 0.9, min_dist / 2.5)\n        else:\n            max_r = margin_to_boundary * 0.9\n        \n        radii.append(max(max_r, 0.01))\n    \n    return centers, np.array(radii)\n\ndef generate_mixed_packing(n, seed):\n    \"\"\"Generate mixed pattern combining strategies.\"\"\"\n    np.random.seed(seed)\n    \n    # Combine different strategies\n    n1 = n // 3\n    n2 = n // 3\n    n3 = n - n1 - n2\n    \n    centers1, radii1 = generate_hexagonal_packing(n1, seed)\n    centers2, radii2 = generate_grid_packing(n2, seed + 100)\n    centers3, radii3 = generate_boundary_packing(n3, seed + 200)\n    \n    # Scale and position different groups\n    centers1 = centers1 * 0.5 + 0.25\n    centers2 = centers2 * 0.4 + 0.1\n    centers3 = centers3 * 0.6 + 0.2\n    \n    centers = np.vstack([centers1, centers2, centers3])\n    radii = np.concatenate([radii1, radii2, radii3]) * 0.7\n    \n    # Ensure within bounds\n    for i in range(len(centers)):\n        r = radii[i]\n        centers[i] = np.clip(centers[i], r + 0.01, 1 - r - 0.01)\n    \n    return centers, radii\n\ndef optimize_packing(centers, radii, maxiter=500):\n    \"\"\"Optimize packing using scipy minimize.\"\"\"\n    n = len(centers)\n    \n    # Pack variables: [centers_flat, radii]\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        r = x[2*n:]\n        return -np.sum(r)  # Negative because we minimize\n    \n    def constraint_violations(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        violations = []\n        \n        # Boundary constraints\n        for i in range(n):\n            violations.append(c[i, 0] - r[i])  # x >= r\n            violations.append(c[i, 1] - r[i])  # y >= r\n            violations.append(1 - c[i, 0] - r[i])  # x <= 1 - r\n            violations.append(1 - c[i, 1] - r[i])  # y <= 1 - r\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((c[i, 0] - c[j, 0])**2 + (c[i, 1] - c[j, 1])**2)\n                violations.append(dist - r[i] - r[j])\n        \n        return np.array(violations)\n    \n    constraints = {'type': 'ineq', 'fun': constraint_violations}\n    bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n    \n    result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                     constraints=constraints, options={'maxiter': maxiter, 'ftol': 1e-9})\n    \n    opt_centers = result.x[:2*n].reshape(n, 2)\n    opt_radii = result.x[2*n:]\n    \n    return {\n        'centers': opt_centers,\n        'radii': opt_radii,\n        'sum_radii': np.sum(opt_radii)\n    }\n\ndef aggressive_local_search(centers, radii, iterations=5):\n    \"\"\"Perform aggressive local search with perturbations.\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for it in range(iterations):\n        # Try perturbing each circle\n        for i in range(n):\n            # Save original\n            orig_center = centers[i].copy()\n            orig_radius = radii[i]\n            \n            # Try multiple perturbations\n            for _ in range(10):\n                # Perturb center\n                centers[i] = orig_center + np.random.uniform(-0.02, 0.02, 2)\n                centers[i] = np.clip(centers[i], radii[i] + 0.01, 1 - radii[i] - 0.01)\n                \n                # Try to expand radius\n                max_r = radii[i]\n                for r_test in np.linspace(radii[i], radii[i] * 1.2, 5):\n                    if is_valid_configuration(centers, np.concatenate([radii[:i], [r_test], radii[i+1:]])):\n                        max_r = r_test\n                \n                radii[i] = max_r\n                \n                # Check if improved\n                current_sum = np.sum(radii)\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            \n            # Restore if no improvement\n            centers[i] = best_centers[i]\n            radii[i] = best_radii[i]\n        \n        # Full optimization every iteration\n        result = optimize_packing(best_centers, best_radii, maxiter=300)\n        if result['sum_radii'] > best_sum:\n            best_sum = result['sum_radii']\n            best_centers = result['centers']\n            best_radii = result['radii']\n    \n    return {\n        'centers': best_centers,\n        'radii': best_radii,\n        'sum_radii': best_sum\n    }\n\ndef is_valid_configuration(centers, radii):\n    \"\"\"Check if configuration satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n            centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\ndef expand_radii(centers, radii, iterations=3):\n    \"\"\"Expand radii as much as possible while maintaining constraints.\"\"\"\n    n = len(centers)\n    \n    for _ in range(iterations):\n        for i in range(n):\n            # Find maximum radius for circle i\n            max_r = radii[i]\n            \n            # Check boundary constraints\n            max_r = min",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses constraint-aware initialization with multiple patterns.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Generate 60 constraint-aware initializations\n    initializations = []\n    \n    # 1. Hexagonal patterns (20 variations)\n    for seed in range(20):\n        centers, radii = generate_hexagonal_packing(n, seed)\n        initializations.append((centers, radii))\n    \n    # 2. Grid patterns (15 variations)\n    for seed in range(15):\n        centers, radii = generate_grid_packing(n, seed)\n        initializations.append((centers, radii))\n    \n    # 3. Boundary-focused patterns (15 variations)\n    for seed in range(15):\n        centers, radii = generate_boundary_packing(n, seed)\n        initializations.append((centers, radii))\n    \n    # 4. Mixed patterns (10 variations)\n    for seed in range(10):\n        centers, radii = generate_mixed_packing(n, seed)\n        initializations.append((centers, radii))\n    \n    # Quick optimization on all 60 initializations\n    print(\"Phase 1: Quick optimization on 60 initializations...\")\n    candidates = []\n    for idx, (centers, radii) in enumerate(initializations):\n        result = optimize_packing(centers, radii, maxiter=200)\n        candidates.append((result['sum_radii'], result['centers'], result['radii']))\n        if result['sum_radii'] > best_sum:\n            best_sum = result['sum_radii']\n            best_solution = result\n        if (idx + 1) % 10 == 0:\n            print(f\"  Processed {idx + 1}/60, best so far: {best_sum:.6f}\")\n    \n    # Sort and get top 5\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    print(f\"\\nPhase 2: Extended optimization on top 5...\")\n    print(f\"  Top 5 sums: {[c[0] for c in candidates[:5]]}\")\n    \n    # Extended optimization on top 5\n    for idx, (_, centers, radii) in enumerate(candidates[:5]):\n        result = optimize_packing(centers, radii, maxiter=800)\n        if result['sum_radii'] > best_sum:\n            best_sum = result['sum_radii']\n            best_solution = result\n        print(f\"  Candidate {idx + 1}/5: {result['sum_radii']:.6f}\")\n    \n    # Aggressive local search on best\n    print(f\"\\nPhase 3: Aggressive local search...\")\n    result = aggressive_local_search(best_solution['centers'], best_solution['radii'])\n    if result['sum_radii'] > best_sum:\n        best_sum = result['sum_radii']\n        best_solution = result\n    print(f\"  After local search: {best_sum:.6f}\")\n    \n    # Final radius expansion\n    print(f\"\\nPhase 4: Final radius expansion...\")\n    centers, radii = expand_radii(best_solution['centers'], best_solution['radii'])\n    sum_radii = np.sum(radii)\n    print(f\"  Final sum: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef generate_hexagonal_packing(n, seed):\n    \"\"\"Generate hexagonal pattern with constraint-aware radii.\"\"\"\n    np.random.seed(seed)\n    \n    # Determine grid size for hexagonal packing\n    rows = int(np.sqrt(n * 2 / np.sqrt(3))) + 1\n    cols = int(np.sqrt(n * np.sqrt(3) / 2)) + 1\n    \n    # Compute spacing to fit in unit square\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    # Maximum radius that prevents overlap in hexagonal grid\n    hex_spacing = min(dx, dy * 2 / np.sqrt(3))\n    max_radius = hex_spacing / 2.1  # Conservative estimate\n    \n    centers = []\n    for row in range(rows):\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = (col + 0.5 + (0.5 if row % 2 else 0)) * dx\n            y = (row + 0.5) * dy\n            # Add small random perturbation\n            x += np.random.uniform(-0.01, 0.01)\n            y += np.random.uniform(-0.01, 0.01)\n            centers.append([x, y])\n        if len(centers) >= n:\n            break\n    \n    centers = np.array(centers[:n])\n    \n    # Ensure centers are within bounds with margin for radius\n    centers = np.clip(centers, max_radius + 0.01, 1 - max_radius - 0.01)\n    \n    # Initialize radii based on nearest neighbor distance\n    radii = np.full(n, max_radius * 0.9)\n    \n    return centers, radii\n\ndef generate_grid_packing(n, seed):\n    \"\"\"Generate grid pattern with maximum feasible radii.\"\"\"\n    np.random.seed(seed)\n    \n    # Find grid dimensions\n    cols = int(np.ceil(np.sqrt(n)))\n    rows = int(np.ceil(n / cols))\n    \n    dx = 1.0 / (cols + 1)\n    dy = 1.0 / (rows + 1)\n    \n    # Maximum radius for grid spacing\n    max_radius = min(dx, dy) / 2.2\n    \n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = (j + 1) * dx + np.random.uniform(-0.01, 0.01)\n            y = (i + 1) * dy + np.random.uniform(-0.01, 0.01)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n])\n    centers = np.clip(centers, max_radius + 0.01, 1 - max_radius - 0.01)\n    \n    radii = np.full(n, max_radius * 0.9)\n    \n    return centers, radii\n\ndef generate_boundary_packing(n, seed):\n    \"\"\"Generate pattern with circles on boundaries.\"\"\"\n    np.random.seed(seed)\n    \n    # Place circles on perimeter\n    n_boundary = min(n // 2, 16)\n    n_interior = n - n_boundary\n    \n    centers = []\n    \n    # Boundary circles\n    for i in range(n_boundary):\n        t = i / n_boundary\n        side = int(t * 4)\n        s = (t * 4) % 1\n        \n        if side == 0:  # Bottom\n            x, y = s, 0.05\n        elif side == 1:  # Right\n            x, y = 0.95, s\n        elif side == 2:  # Top\n            x, y = 1 - s, 0.95\n        else:  # Left\n            x, y = 0.05, 1 - s\n        \n        centers.append([x, y])\n    \n    # Interior circles\n    for i in range(n_interior):\n        x = np.random.uniform(0.2, 0.8)\n        y = np.random.uniform(0.2, 0.8)\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Compute safe radii\n    radii = []\n    for i, (x, y) in enumerate(centers):\n        # Distance to boundaries\n        margin_to_boundary = min(x, y, 1 - x, 1 - y)\n        \n        # Distance to other circles (approximate)\n        if len(radii) > 0:\n            dists = np.sqrt((centers[:i, 0] - x)**2 + (centers[:i, 1] - y)**2)\n            min_dist = np.min(dists) if len(dists) > 0 else 1.0\n            max_r = min(margin_to_boundary * 0.9, min_dist / 2.5)\n        else:\n            max_r = margin_to_boundary * 0.9\n        \n        radii.append(max(max_r, 0.01))\n    \n    return centers, np.array(radii)\n\ndef generate_mixed_packing(n, seed):\n    \"\"\"Generate mixed pattern combining strategies.\"\"\"\n    np.random.seed(seed)\n    \n    # Combine different strategies\n    n1 = n // 3\n    n2 = n // 3\n    n3 = n - n1 - n2\n    \n    centers1, radii1 = generate_hexagonal_packing(n1, seed)\n    centers2, radii2 = generate_grid_packing(n2, seed + 100)\n    centers3, radii3 = generate_boundary_packing(n3, seed + 200)\n    \n    # Scale and position different groups\n    centers1 = centers1 * 0.5 + 0.25\n    centers2 = centers2 * 0.4 + 0.1\n    centers3 = centers3 * 0.6 + 0.2\n    \n    centers = np.vstack([centers1, centers2, centers3])\n    radii = np.concatenate([radii1, radii2, radii3]) * 0.7\n    \n    # Ensure within bounds\n    for i in range(len(centers)):\n        r = radii[i]\n        centers[i] = np.clip(centers[i], r + 0.01, 1 - r - 0.01)\n    \n    return centers, radii\n\ndef optimize_packing(centers, radii, maxiter=500):\n    \"\"\"Optimize packing using scipy minimize.\"\"\"\n    n = len(centers)\n    \n    # Pack variables: [centers_flat, radii]\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        r = x[2*n:]\n        return -np.sum(r)  # Negative because we minimize\n    \n    def constraint_violations(x):\n        c = x[:2*n].reshape(n, 2)\n        r = x[2*n:]\n        \n        violations = []\n        \n        # Boundary constraints\n        for i in range(n):\n            violations.append(c[i, 0] - r[i])  # x >= r\n            violations.append(c[i, 1] - r[i])  # y >= r\n            violations.append(1 - c[i, 0] - r[i])  # x <= 1 - r\n            violations.append(1 - c[i, 1] - r[i])  # y <= 1 - r\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((c[i, 0] - c[j, 0])**2 + (c[i, 1] - c[j, 1])**2)\n                violations.append(dist - r[i] - r[j])\n        \n        return np.array(violations)\n    \n    constraints = {'type': 'ineq', 'fun': constraint_violations}\n    bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n    \n    result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                     constraints=constraints, options={'maxiter': maxiter, 'ftol': 1e-9})\n    \n    opt_centers = result.x[:2*n].reshape(n, 2)\n    opt_radii = result.x[2*n:]\n    \n    return {\n        'centers': opt_centers,\n        'radii': opt_radii,\n        'sum_radii': np.sum(opt_radii)\n    }\n\ndef aggressive_local_search(centers, radii, iterations=5):\n    \"\"\"Perform aggressive local search with perturbations.\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for it in range(iterations):\n        # Try perturbing each circle\n        for i in range(n):\n            # Save original\n            orig_center = centers[i].copy()\n            orig_radius = radii[i]\n            \n            # Try multiple perturbations\n            for _ in range(10):\n                # Perturb center\n                centers[i] = orig_center + np.random.uniform(-0.02, 0.02, 2)\n                centers[i] = np.clip(centers[i], radii[i] + 0.01, 1 - radii[i] - 0.01)\n                \n                # Try to expand radius\n                max_r = radii[i]\n                for r_test in np.linspace(radii[i], radii[i] * 1.2, 5):\n                    if is_valid_configuration(centers, np.concatenate([radii[:i], [r_test], radii[i+1:]])):\n                        max_r = r_test\n                \n                radii[i] = max_r\n                \n                # Check if improved\n                current_sum = np.sum(radii)\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n            \n            # Restore if no improvement\n            centers[i] = best_centers[i]\n            radii[i] = best_radii[i]\n        \n        # Full optimization every iteration\n        result = optimize_packing(best_centers, best_radii, maxiter=300)\n        if result['sum_radii'] > best_sum:\n            best_sum = result['sum_radii']\n            best_centers = result['centers']\n            best_radii = result['radii']\n    \n    return {\n        'centers': best_centers,\n        'radii': best_radii,\n        'sum_radii': best_sum\n    }\n\ndef is_valid_configuration(centers, radii):\n    \"\"\"Check if configuration satisfies all constraints.\"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n            centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\ndef expand_radii(centers, radii, iterations=3):\n    \"\"\"Expand radii as much as possible while maintaining constraints.\"\"\"\n    n = len(centers)\n    \n    for _ in range(iterations):\n        for i in range(n):\n            # Find maximum radius for circle i\n            max_r = radii[i]\n            \n            # Check boundary constraints\n            max_r = min",
  "timestamp": "2025-12-09T15:44:17.770408",
  "cost_data": null
}