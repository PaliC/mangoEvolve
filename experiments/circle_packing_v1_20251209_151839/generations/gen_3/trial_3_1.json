{
  "trial_id": "trial_3_1",
  "generation": 3,
  "parent_id": "trial_2_5",
  "code": "",
  "metrics": {},
  "prompt": "Create an ultra-refined version of trial_2_5 with post-optimization enhancement.\n\nBase code:\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses adaptive multi-start optimization strategy.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def generate_initial_configurations():\n        \"\"\"Generate 30 diverse initial configurations.\"\"\"\n        configs = []\n        \n        # 1. Grid-based layouts (6 variations)\n        for grid_type in range(6):\n            if grid_type == 0:\n                # 5x6 grid\n                rows, cols = 5, 6\n            elif grid_type == 1:\n                # 6x5 grid\n                rows, cols = 6, 5\n            elif grid_type == 2:\n                # 4x7 grid\n                rows, cols = 4, 7\n            elif grid_type == 3:\n                # 7x4 grid\n                rows, cols = 7, 4\n            elif grid_type == 4:\n                # 3x9 grid\n                rows, cols = 3, 9\n            else:\n                # 9x3 grid\n                rows, cols = 9, 3\n            \n            centers = []\n            for i in range(n):\n                row = i // cols\n                col = i % cols\n                x = (col + 0.5) / cols\n                y = (row + 0.5) / rows\n                centers.append([x, y])\n            configs.append(np.array(centers[:n]))\n        \n        # 2. Hexagonal packing variations (4 variations)\n        for hex_type in range(4):\n            centers = []\n            if hex_type < 2:\n                rows_hex = 5\n                cols_hex = 6\n            else:\n                rows_hex = 6\n                cols_hex = 5\n            \n            offset = 0.5 if hex_type % 2 == 0 else 0.3\n            \n            for i in range(n):\n                row = i // cols_hex\n                col = i % cols_hex\n                x = (col + (0.5 * offset if row % 2 == 1 else 0)) / cols_hex\n                y = (row + 0.5) / rows_hex\n                centers.append([x, y])\n            configs.append(np.array(centers[:n]))\n        \n        # 3. Boundary-focused layouts (4 variations)\n        for boundary_type in range(4):\n            centers = []\n            # Place circles along boundary\n            n_boundary = 16 + boundary_type\n            n_interior = n - n_boundary\n            \n            # Boundary circles\n            for i in range(n_boundary):\n                t = i / n_boundary\n                if t < 0.25:\n                    x, y = 4 * t, 0.1\n                elif t < 0.5:\n                    x, y = 0.9, 4 * (t - 0.25)\n                elif t < 0.75:\n                    x, y = 0.9 - 4 * (t - 0.5), 0.9\n                else:\n                    x, y = 0.1, 0.9 - 4 * (t - 0.75)\n                centers.append([x, y])\n            \n            # Interior circles\n            for i in range(n_interior):\n                x = 0.3 + 0.4 * (i % 4) / 3\n                y = 0.3 + 0.4 * (i // 4) / 3\n                centers.append([x, y])\n            \n            configs.append(np.array(centers[:n]))\n        \n        # 4. Random configurations with different densities (8 variations)\n        for rand_type in range(8):\n            np.random.seed(rand_type * 100)\n            if rand_type < 4:\n                # More spread out\n                margin = 0.15\n                centers = margin + (1 - 2*margin) * np.random.rand(n, 2)\n            else:\n                # More concentrated\n                margin = 0.1\n                centers = margin + (1 - 2*margin) * np.random.rand(n, 2)\n            configs.append(centers)\n        \n        # 5. Clustered layouts (4 variations)\n        for cluster_type in range(4):\n            centers = []\n            n_clusters = 3 + cluster_type % 2\n            per_cluster = n // n_clusters\n            \n            cluster_centers = [(0.25, 0.25), (0.75, 0.25), (0.5, 0.75), (0.25, 0.75), (0.75, 0.75)]\n            \n            for c in range(n_clusters):\n                cx, cy = cluster_centers[c]\n                for i in range(per_cluster):\n                    angle = 2 * np.pi * i / per_cluster\n                    r = 0.15 + 0.05 * (cluster_type % 2)\n                    x = cx + r * np.cos(angle)\n                    y = cy + r * np.sin(angle)\n                    x = np.clip(x, 0.1, 0.9)\n                    y = np.clip(y, 0.1, 0.9)\n                    centers.append([x, y])\n            \n            # Add remaining circles\n            while len(centers) < n:\n                centers.append([0.5, 0.5])\n            \n            configs.append(np.array(centers[:n]))\n        \n        # 6. Diagonal patterns (4 variations)\n        for diag_type in range(4):\n            centers = []\n            if diag_type < 2:\n                # Main diagonal\n                for i in range(n):\n                    t = i / (n - 1)\n                    x = 0.1 + 0.8 * t\n                    y = 0.1 + 0.8 * t + 0.1 * (diag_type % 2) * np.sin(4 * np.pi * t)\n                    centers.append([x, y])\n            else:\n                # Anti-diagonal\n                for i in range(n):\n                    t = i / (n - 1)\n                    x = 0.1 + 0.8 * t\n                    y = 0.9 - 0.8 * t + 0.1 * (diag_type % 2) * np.sin(4 * np.pi * t)\n                    centers.append([x, y])\n            configs.append(np.array(centers[:n]))\n        \n        return configs\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        \"\"\"Compute all constraints.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    def optimize_packing(initial_centers, max_iter=100):\n        \"\"\"Optimize a packing starting from initial centers.\"\"\"\n        # Initialize radii based on nearest neighbor distances\n        dists = squareform(pdist(initial_centers))\n        np.fill_diagonal(dists, np.inf)\n        min_dists = np.min(dists, axis=1)\n        \n        # Also consider boundary distances\n        boundary_dists = np.minimum.reduce([\n            initial_centers[:, 0],\n            1 - initial_centers[:, 0],\n            initial_centers[:, 1],\n            1 - initial_centers[:, 1]\n        ])\n        \n        initial_radii = np.minimum(min_dists / 2.5, boundary_dists) * 0.9\n        initial_radii = np.maximum(initial_radii, 0.01)\n        \n        x0 = pack_to_vector(initial_centers, initial_radii)\n        \n        # Bounds\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        \n        # Constraints\n        constraints = {'type': 'ineq', 'fun': constraints_func}\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': max_iter, 'ftol': 1e-8}\n            )\n            \n            if result.success or constraints_func(result.x).min() >= -1e-6:\n                centers, radii = vector_to_pack(result.x)\n                return centers, radii, np.sum(radii)\n            else:\n                return initial_centers, initial_radii, np.sum(initial_radii)\n        except:\n            return initial_centers, initial_radii, np.sum(initial_radii)\n    \n    # Adaptive multi-start strategy\n    print(\"Generating initial configurations...\")\n    initial_configs = generate_initial_configurations()\n    \n    # Stage 1: Quick optimization on all 30 configurations\n    print(\"Stage 1: Quick optimization (maxiter=100) on 30 configurations...\")\n    stage1_results = []\n    for i, config in enumerate(initial_configs):\n        centers, radii, sum_radii = optimize_packing(config, max_iter=100)\n        stage1_results.append((centers, radii, sum_radii))\n        print(f\"  Config {i+1}/30: sum_radii = {sum_radii:.6f}\")\n    \n    # Select top 10\n    stage1_results.sort(key=lambda x: x[2], reverse=True)\n    top10 = stage1_results[:10]\n    print(f\"\\nTop 10 after stage 1: {[f'{r[2]:.6f}' for r in top10[:3]]}\")\n    \n    # Stage 2: Medium optimization on top 10\n    print(\"\\nStage 2: Medium optimization (maxiter=300) on top 10...\")\n    stage2_results = []\n    for i, (centers, radii, _) in enumerate(top10):\n        centers, radii, sum_radii = optimize_packing(centers, max_iter=300)\n        stage2_results.append((centers, radii, sum_radii))\n        print(f\"  Config {i+1}/10: sum_radii = {sum_radii:.6f}\")\n    \n    # Select top 3\n    stage2_results.sort(key=lambda x: x[2], reverse=True)\n    top3 = stage2_results[:3]\n    print(f\"\\nTop 3 after stage 2: {[f'{r[2]:.6f}' for r in top3]}\")\n    \n    # Stage 3: Deep optimization on top 3\n    print(\"\\nStage 3: Deep optimization (maxiter=800) on top 3...\")\n    stage3_results = []\n    for i, (centers, radii, _) in enumerate(top3):\n        centers, radii, sum_radii = optimize_packing(centers, max_iter=800)\n        stage3_results.append((centers, radii, sum_radii))\n        print(f\"  Config {i+1}/3: sum_radii = {sum_radii:.6f}\")\n    \n    # Select best\n    stage3_results.sort(key=lambda x: x[2], reverse=True)\n    best_centers, best_radii, best_sum = stage3_results[0]\n    \n    # Stage 4: Final local search\n    print(\"\\nStage 4: Final local search...\")\n    final_centers, final_radii, final_sum = optimize_packing(best_centers, max_iter=1000)\n    \n    print(f\"\\nFinal sum of radii: {final_sum:.6f}\")\n    \n    return final_centers, final_radii, final_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n\nFocus on post-optimization:\n1. Keep the 3-phase adaptive approach (it works well)\n2. After phase 3, add intensive local search:\n   - For each circle, try 8 directions (N, NE, E, SE, S, SW, W, NW)\n   - Step sizes: 0.001, 0.0005, 0.0001\n   - Accept moves that increase sum_radii\n3. Add radius expansion phase:\n   - Try expanding all radii uniformly by 0.05%\n   - Try expanding each radius individually by 0.1%\n   - Iterate until no improvement\n4. Final polish: Run one more optimization with maxiter=500\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses adaptive multi-start optimization with post-optimization enhancement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def generate_initial_configurations():\n        \"\"\"Generate 30 diverse initial configurations.\"\"\"\n        configs = []\n        \n        # 1. Grid-based layouts (6 variations)\n        for grid_type in range(6):\n            if grid_type == 0:\n                rows, cols = 5, 6\n            elif grid_type == 1:\n                rows, cols = 6, 5\n            elif grid_type == 2:\n                rows, cols = 4, 7\n            elif grid_type == 3:\n                rows, cols = 7, 4\n            elif grid_type == 4:\n                rows, cols = 3, 9\n            else:\n                rows, cols = 9, 3\n            \n            centers = []\n            for i in range(n):\n                row = i // cols\n                col = i % cols\n                x = (col + 0.5) / cols\n                y = (row + 0.5) / rows\n                centers.append([x, y])\n            configs.append(np.array(centers[:n]))\n        \n        # 2. Hexagonal packing variations (4 variations)\n        for hex_type in range(4):\n            centers = []\n            if hex_type < 2:\n                rows_hex = 5\n                cols_hex = 6\n            else:\n                rows_hex = 6\n                cols_hex = 5\n            \n            offset = 0.5 if hex_type % 2 == 0 else 0.3\n            \n            for i in range(n):\n                row = i // cols_hex\n                col = i % cols_hex\n                x = (col + (0.5 * offset if row % 2 == 1 else 0)) / cols_hex\n                y = (row + 0.5) / rows_hex\n                centers.append([x, y])\n            configs.append(np.array(centers[:n]))\n        \n        # 3. Boundary-focused layouts (4 variations)\n        for boundary_type in range(4):\n            centers = []\n            n_boundary = 16 + boundary_type\n            n_interior = n - n_boundary\n            \n            for i in range(n_boundary):\n                t = i / n_boundary\n                if t < 0.25:\n                    x, y = 4 * t, 0.1\n                elif t < 0.5:\n                    x, y = 0.9, 4 * (t - 0.25)\n                elif t < 0.75:\n                    x, y = 0.9 - 4 * (t - 0.5), 0.9\n                else:\n                    x, y = 0.1, 0.9 - 4 * (t - 0.75)\n                centers.append([x, y])\n            \n            for i in range(n_interior):\n                x = 0.3 + 0.4 * (i % 4) / 3\n                y = 0.3 + 0.4 * (i // 4) / 3\n                centers.append([x, y])\n            \n            configs.append(np.array(centers[:n]))\n        \n        # 4. Random configurations (8 variations)\n        for rand_type in range(8):\n            np.random.seed(rand_type * 100)\n            if rand_type < 4:\n                margin = 0.15\n                centers = margin + (1 - 2*margin) * np.random.rand(n, 2)\n            else:\n                margin = 0.1\n                centers = margin + (1 - 2*margin) * np.random.rand(n, 2)\n            configs.append(centers)\n        \n        # 5. Clustered layouts (4 variations)\n        for cluster_type in range(4):\n            centers = []\n            n_clusters = 3 + cluster_type % 2\n            per_cluster = n // n_clusters\n            \n            cluster_centers = [(0.25, 0.25), (0.75, 0.25), (0.5, 0.75), (0.25, 0.75), (0.75, 0.75)]\n            \n            for c in range(n_clusters):\n                cx, cy = cluster_centers[c]\n                for i in range(per_cluster):\n                    angle = 2 * np.pi * i / per_cluster\n                    r = 0.15 + 0.05 * (cluster_type % 2)\n                    x = cx + r * np.cos(angle)\n                    y = cy + r * np.sin(angle)\n                    x = np.clip(x, 0.1, 0.9)\n                    y = np.clip(y, 0.1, 0.9)\n                    centers.append([x, y])\n            \n            while len(centers) < n:\n                centers.append([0.5, 0.5])\n            \n            configs.append(np.array(centers[:n]))\n        \n        # 6. Diagonal patterns (4 variations)\n        for diag_type in range(4):\n            centers = []\n            if diag_type < 2:\n                for i in range(n):\n                    t = i / (n - 1)\n                    x = 0.1 + 0.8 * t\n                    y = 0.1 + 0.8 * t + 0.1 * (diag_type % 2) * np.sin(4 * np.pi * t)\n                    centers.append([x, y])\n            else:\n                for i in range(n):\n                    t = i / (n - 1)\n                    x = 0.1 + 0.8 * t\n                    y = 0.9 - 0.8 * t + 0.1 * (diag_type % 2) * np.sin(4 * np.pi * t)\n                    centers.append([x, y])\n            configs.append(np.array(centers[:n]))\n        \n        return configs\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        \"\"\"Compute all constraints.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        \n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid.\"\"\"\n        if np.any(radii < 0):\n            return False\n        \n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def optimize_packing(initial_centers, max_iter=100):\n        \"\"\"Optimize a packing starting from initial centers.\"\"\"\n        dists = squareform(pdist(initial_centers))\n        np.fill_diagonal(dists, np.inf)\n        min_dists = np.min(dists, axis=1)\n        \n        boundary_dists = np.minimum.reduce([\n            initial_centers[:, 0],\n            1 - initial_centers[:, 0],\n            initial_centers[:, 1],\n            1 - initial_centers[:, 1]\n        ])\n        \n        initial_radii = np.minimum(min_dists / 2.5, boundary_dists) * 0.9\n        initial_radii = np.maximum(initial_radii, 0.01)\n        \n        x0 = pack_to_vector(initial_centers, initial_radii)\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        constraints = {'type': 'ineq', 'fun': constraints_func}\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': max_iter, 'ftol': 1e-8}\n            )\n            \n            if result.success or constraints_func(result.x).min() >= -1e-6:\n                centers, radii = vector_to_pack(result.x)\n                return centers, radii, np.sum(radii)\n            else:\n                return initial_centers, initial_radii, np.sum(initial_radii)\n        except:\n            return initial_centers, initial_radii, np.sum(initial_radii)\n    \n    def local_search_directional(centers, radii, step_sizes=[0.001, 0.0005, 0.0001]):\n        \"\"\"Intensive local search by moving circles in 8 directions.\"\"\"\n        directions = [\n            (0, 1),    # N\n            (1, 1),    # NE\n            (1, 0),    # E\n            (1, -1),   # SE\n            (0, -1),   # S\n            (-1, -1),  # SW\n            (-1, 0),   # W\n            (-1, 1)    # NW\n        ]\n        \n        improved = True\n        iterations = 0\n        max_iterations = 50\n        \n        while improved and iterations < max_iterations:\n            improved = False\n            iterations += 1\n            \n            for i in range(n):\n                for step_size in step_sizes:\n                    for dx, dy in directions:\n                        new_centers = centers.copy()\n                        new_centers[i, 0] += dx * step_size\n                        new_centers[i, 1] += dy * step_size\n                        \n                        if is_valid(new_centers, radii):\n                            centers = new_centers\n                            improved = True\n                            break\n                    if improved:\n                        break\n                if improved:\n                    break\n        \n        return centers, radii\n    \n    def expand_radii(centers, radii):\n        \"\"\"Try to expand radii uniformly and individually.\"\"\"\n        max_iterations = 20\n        \n        for iteration in range(max_iterations):\n            improved = False\n            \n            # Try uniform expansion\n            expansion_factors = [1.0005, 1.0002, 1.0001]\n            for factor in expansion_factors:\n                new_radii = radii * factor\n                if is_valid(centers, new_radii):\n                    radii = new_radii\n                    improved = True\n                    break\n            \n            # Try individual expansion\n            for i in range(n):\n                expansion_amounts = [0.001, 0.0005, 0.0001]\n                for amount in expansion_amounts:\n                    new_radii = radii.copy()\n                    new_radii[i] += amount\n                    if is_valid(centers, new_radii):\n                        radii = new_radii\n                        improved = True\n                        break\n            \n            if not improved:\n                break\n        \n        return radii\n    \n    # Stage 1: Quick optimization\n    print(\"Generating initial configurations...\")\n    initial_configs = generate_initial_configurations()\n    \n    print(\"Stage 1: Quick optimization (maxiter=100) on 30 configurations...\")\n    stage1_results = []\n    for i, config in enumerate(initial_configs):\n        centers, radii, sum_radii = optimize_packing(config, max_iter=100)\n        stage1_results.append((centers, radii, sum_radii))\n        print(f\"  Config {i+1}/30: sum_radii = {sum_radii:.6f}\")\n    \n    stage1_results.sort(key=lambda x: x[2], reverse=True)\n    top10 = stage1_results[:10]\n    print(f\"\\nTop 10 after stage 1: {[f'{r[2]:.6f}' for r in top10[:3]]}\")\n    \n    # Stage 2: Medium optimization\n    print(\"\\nStage 2: Medium optimization (maxiter=300) on top 10...\")\n    stage2_results = []\n    for i, (centers, radii, _) in enumerate(top10):\n        centers, radii, sum_radii = optimize_packing(centers, max_iter=300)\n        stage2_results.append((centers, radii, sum_radii))\n        print(f\"  Config {i+1}/10: sum_radii = {sum_radii:.6f}\")\n    \n    stage2_results.sort(key=lambda x: x[2], reverse=True)\n    top3 = stage2_results[:3]\n    print(f\"\\nTop 3 after stage 2: {[f'{r[2]:.6f}' for r in top3]}\")\n    \n    # Stage 3: Deep optimization\n    print(\"\\nStage 3: Deep optimization (maxiter=800) on top 3...\")\n    stage3_results = []\n    for i, (centers, radii, _) in enumerate(top3):\n        centers, radii, sum_radii = optimize_packing(centers, max_iter=800)\n        stage3_results.append((centers, radii, sum_radii))\n        print(f\"  Config {i+1}/3: sum_radii = {sum_radii:.6f}\")\n    \n    stage3_results.sort(key=lambda x: x[2], reverse=True)\n    best_centers, best_radii, best_sum = stage3_results[0]\n    print(f\"\\nBest after stage 3: {best_sum:.6f}\")\n    \n    # Post-optimization enhancement\n    print(\"\\nPost-optimization phase:\")\n    \n    # 1. Intensive local search\n    print(\"  1. Directional local search...\")\n    best_centers, best_radii = local_search_directional(best_centers, best_radii)\n    best_sum = np.sum(best_radii)\n    print(f\"     After local search: {best_sum:.6f}\")\n    \n    # 2.",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses adaptive multi-start optimization with post-optimization enhancement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def generate_initial_configurations():\n        \"\"\"Generate 30 diverse initial configurations.\"\"\"\n        configs = []\n        \n        # 1. Grid-based layouts (6 variations)\n        for grid_type in range(6):\n            if grid_type == 0:\n                rows, cols = 5, 6\n            elif grid_type == 1:\n                rows, cols = 6, 5\n            elif grid_type == 2:\n                rows, cols = 4, 7\n            elif grid_type == 3:\n                rows, cols = 7, 4\n            elif grid_type == 4:\n                rows, cols = 3, 9\n            else:\n                rows, cols = 9, 3\n            \n            centers = []\n            for i in range(n):\n                row = i // cols\n                col = i % cols\n                x = (col + 0.5) / cols\n                y = (row + 0.5) / rows\n                centers.append([x, y])\n            configs.append(np.array(centers[:n]))\n        \n        # 2. Hexagonal packing variations (4 variations)\n        for hex_type in range(4):\n            centers = []\n            if hex_type < 2:\n                rows_hex = 5\n                cols_hex = 6\n            else:\n                rows_hex = 6\n                cols_hex = 5\n            \n            offset = 0.5 if hex_type % 2 == 0 else 0.3\n            \n            for i in range(n):\n                row = i // cols_hex\n                col = i % cols_hex\n                x = (col + (0.5 * offset if row % 2 == 1 else 0)) / cols_hex\n                y = (row + 0.5) / rows_hex\n                centers.append([x, y])\n            configs.append(np.array(centers[:n]))\n        \n        # 3. Boundary-focused layouts (4 variations)\n        for boundary_type in range(4):\n            centers = []\n            n_boundary = 16 + boundary_type\n            n_interior = n - n_boundary\n            \n            for i in range(n_boundary):\n                t = i / n_boundary\n                if t < 0.25:\n                    x, y = 4 * t, 0.1\n                elif t < 0.5:\n                    x, y = 0.9, 4 * (t - 0.25)\n                elif t < 0.75:\n                    x, y = 0.9 - 4 * (t - 0.5), 0.9\n                else:\n                    x, y = 0.1, 0.9 - 4 * (t - 0.75)\n                centers.append([x, y])\n            \n            for i in range(n_interior):\n                x = 0.3 + 0.4 * (i % 4) / 3\n                y = 0.3 + 0.4 * (i // 4) / 3\n                centers.append([x, y])\n            \n            configs.append(np.array(centers[:n]))\n        \n        # 4. Random configurations (8 variations)\n        for rand_type in range(8):\n            np.random.seed(rand_type * 100)\n            if rand_type < 4:\n                margin = 0.15\n                centers = margin + (1 - 2*margin) * np.random.rand(n, 2)\n            else:\n                margin = 0.1\n                centers = margin + (1 - 2*margin) * np.random.rand(n, 2)\n            configs.append(centers)\n        \n        # 5. Clustered layouts (4 variations)\n        for cluster_type in range(4):\n            centers = []\n            n_clusters = 3 + cluster_type % 2\n            per_cluster = n // n_clusters\n            \n            cluster_centers = [(0.25, 0.25), (0.75, 0.25), (0.5, 0.75), (0.25, 0.75), (0.75, 0.75)]\n            \n            for c in range(n_clusters):\n                cx, cy = cluster_centers[c]\n                for i in range(per_cluster):\n                    angle = 2 * np.pi * i / per_cluster\n                    r = 0.15 + 0.05 * (cluster_type % 2)\n                    x = cx + r * np.cos(angle)\n                    y = cy + r * np.sin(angle)\n                    x = np.clip(x, 0.1, 0.9)\n                    y = np.clip(y, 0.1, 0.9)\n                    centers.append([x, y])\n            \n            while len(centers) < n:\n                centers.append([0.5, 0.5])\n            \n            configs.append(np.array(centers[:n]))\n        \n        # 6. Diagonal patterns (4 variations)\n        for diag_type in range(4):\n            centers = []\n            if diag_type < 2:\n                for i in range(n):\n                    t = i / (n - 1)\n                    x = 0.1 + 0.8 * t\n                    y = 0.1 + 0.8 * t + 0.1 * (diag_type % 2) * np.sin(4 * np.pi * t)\n                    centers.append([x, y])\n            else:\n                for i in range(n):\n                    t = i / (n - 1)\n                    x = 0.1 + 0.8 * t\n                    y = 0.9 - 0.8 * t + 0.1 * (diag_type % 2) * np.sin(4 * np.pi * t)\n                    centers.append([x, y])\n            configs.append(np.array(centers[:n]))\n        \n        return configs\n    \n    def pack_to_vector(centers, radii):\n        \"\"\"Convert centers and radii to optimization vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def vector_to_pack(x):\n        \"\"\"Convert optimization vector to centers and radii.\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        return centers, radii\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        _, radii = vector_to_pack(x)\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        \"\"\"Compute all constraints.\"\"\"\n        centers, radii = vector_to_pack(x)\n        constraints = []\n        \n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid.\"\"\"\n        if np.any(radii < 0):\n            return False\n        \n        for i in range(n):\n            if (centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6 or\n                centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6):\n                return False\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        \n        return True\n    \n    def optimize_packing(initial_centers, max_iter=100):\n        \"\"\"Optimize a packing starting from initial centers.\"\"\"\n        dists = squareform(pdist(initial_centers))\n        np.fill_diagonal(dists, np.inf)\n        min_dists = np.min(dists, axis=1)\n        \n        boundary_dists = np.minimum.reduce([\n            initial_centers[:, 0],\n            1 - initial_centers[:, 0],\n            initial_centers[:, 1],\n            1 - initial_centers[:, 1]\n        ])\n        \n        initial_radii = np.minimum(min_dists / 2.5, boundary_dists) * 0.9\n        initial_radii = np.maximum(initial_radii, 0.01)\n        \n        x0 = pack_to_vector(initial_centers, initial_radii)\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        constraints = {'type': 'ineq', 'fun': constraints_func}\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': max_iter, 'ftol': 1e-8}\n            )\n            \n            if result.success or constraints_func(result.x).min() >= -1e-6:\n                centers, radii = vector_to_pack(result.x)\n                return centers, radii, np.sum(radii)\n            else:\n                return initial_centers, initial_radii, np.sum(initial_radii)\n        except:\n            return initial_centers, initial_radii, np.sum(initial_radii)\n    \n    def local_search_directional(centers, radii, step_sizes=[0.001, 0.0005, 0.0001]):\n        \"\"\"Intensive local search by moving circles in 8 directions.\"\"\"\n        directions = [\n            (0, 1),    # N\n            (1, 1),    # NE\n            (1, 0),    # E\n            (1, -1),   # SE\n            (0, -1),   # S\n            (-1, -1),  # SW\n            (-1, 0),   # W\n            (-1, 1)    # NW\n        ]\n        \n        improved = True\n        iterations = 0\n        max_iterations = 50\n        \n        while improved and iterations < max_iterations:\n            improved = False\n            iterations += 1\n            \n            for i in range(n):\n                for step_size in step_sizes:\n                    for dx, dy in directions:\n                        new_centers = centers.copy()\n                        new_centers[i, 0] += dx * step_size\n                        new_centers[i, 1] += dy * step_size\n                        \n                        if is_valid(new_centers, radii):\n                            centers = new_centers\n                            improved = True\n                            break\n                    if improved:\n                        break\n                if improved:\n                    break\n        \n        return centers, radii\n    \n    def expand_radii(centers, radii):\n        \"\"\"Try to expand radii uniformly and individually.\"\"\"\n        max_iterations = 20\n        \n        for iteration in range(max_iterations):\n            improved = False\n            \n            # Try uniform expansion\n            expansion_factors = [1.0005, 1.0002, 1.0001]\n            for factor in expansion_factors:\n                new_radii = radii * factor\n                if is_valid(centers, new_radii):\n                    radii = new_radii\n                    improved = True\n                    break\n            \n            # Try individual expansion\n            for i in range(n):\n                expansion_amounts = [0.001, 0.0005, 0.0001]\n                for amount in expansion_amounts:\n                    new_radii = radii.copy()\n                    new_radii[i] += amount\n                    if is_valid(centers, new_radii):\n                        radii = new_radii\n                        improved = True\n                        break\n            \n            if not improved:\n                break\n        \n        return radii\n    \n    # Stage 1: Quick optimization\n    print(\"Generating initial configurations...\")\n    initial_configs = generate_initial_configurations()\n    \n    print(\"Stage 1: Quick optimization (maxiter=100) on 30 configurations...\")\n    stage1_results = []\n    for i, config in enumerate(initial_configs):\n        centers, radii, sum_radii = optimize_packing(config, max_iter=100)\n        stage1_results.append((centers, radii, sum_radii))\n        print(f\"  Config {i+1}/30: sum_radii = {sum_radii:.6f}\")\n    \n    stage1_results.sort(key=lambda x: x[2], reverse=True)\n    top10 = stage1_results[:10]\n    print(f\"\\nTop 10 after stage 1: {[f'{r[2]:.6f}' for r in top10[:3]]}\")\n    \n    # Stage 2: Medium optimization\n    print(\"\\nStage 2: Medium optimization (maxiter=300) on top 10...\")\n    stage2_results = []\n    for i, (centers, radii, _) in enumerate(top10):\n        centers, radii, sum_radii = optimize_packing(centers, max_iter=300)\n        stage2_results.append((centers, radii, sum_radii))\n        print(f\"  Config {i+1}/10: sum_radii = {sum_radii:.6f}\")\n    \n    stage2_results.sort(key=lambda x: x[2], reverse=True)\n    top3 = stage2_results[:3]\n    print(f\"\\nTop 3 after stage 2: {[f'{r[2]:.6f}' for r in top3]}\")\n    \n    # Stage 3: Deep optimization\n    print(\"\\nStage 3: Deep optimization (maxiter=800) on top 3...\")\n    stage3_results = []\n    for i, (centers, radii, _) in enumerate(top3):\n        centers, radii, sum_radii = optimize_packing(centers, max_iter=800)\n        stage3_results.append((centers, radii, sum_radii))\n        print(f\"  Config {i+1}/3: sum_radii = {sum_radii:.6f}\")\n    \n    stage3_results.sort(key=lambda x: x[2], reverse=True)\n    best_centers, best_radii, best_sum = stage3_results[0]\n    print(f\"\\nBest after stage 3: {best_sum:.6f}\")\n    \n    # Post-optimization enhancement\n    print(\"\\nPost-optimization phase:\")\n    \n    # 1. Intensive local search\n    print(\"  1. Directional local search...\")\n    best_centers, best_radii = local_search_directional(best_centers, best_radii)\n    best_sum = np.sum(best_radii)\n    print(f\"     After local search: {best_sum:.6f}\")\n    \n    # 2.",
  "timestamp": "2025-12-09T15:42:15.169396",
  "cost_data": null
}