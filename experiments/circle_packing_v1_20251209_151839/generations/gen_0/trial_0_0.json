{
  "trial_id": "trial_0_0",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hexagonal lattice.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Hexagonal lattice arrangement\n    # We'll try to fit circles in a hexagonal pattern\n    # For 26 circles, we can try different row configurations\n    \n    # Try 5-5-5-5-6 pattern (5 rows with varying circles)\n    # Hexagonal packing has rows offset by 0.5 horizontally\n    \n    def create_hex_grid(rows_config, base_radius):\n        \"\"\"Create hexagonal grid with given row configuration.\"\"\"\n        centers = []\n        dy = base_radius * np.sqrt(3)  # vertical spacing in hex lattice\n        \n        y_pos = base_radius\n        for row_idx, n_circles in enumerate(rows_config):\n            # Horizontal spacing\n            if n_circles == 1:\n                dx = 0\n                x_start = 0.5\n            else:\n                dx = 2 * base_radius\n                # Center the row\n                row_width = (n_circles - 1) * dx\n                x_start = (1.0 - row_width) / 2\n            \n            # Offset every other row for hexagonal packing\n            x_offset = base_radius if row_idx % 2 == 1 else 0\n            \n            for i in range(n_circles):\n                x = x_start + i * dx + x_offset\n                centers.append([x, y_pos])\n            \n            y_pos += dy\n        \n        return np.array(centers)\n    \n    def compute_max_radius(centers):\n        \"\"\"Compute maximum radius that satisfies all constraints.\"\"\"\n        n = len(centers)\n        \n        # Maximum radius from boundary constraints\n        max_r_boundary = float('inf')\n        for i in range(n):\n            x, y = centers[i]\n            max_r_boundary = min(max_r_boundary, x, 1.0 - x, y, 1.0 - y)\n        \n        # Maximum radius from non-overlap constraints\n        max_r_overlap = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r_overlap = min(max_r_overlap, dist / 2.0)\n        \n        return min(max_r_boundary, max_r_overlap)\n    \n    # Try different hexagonal configurations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    configurations = [\n        [4, 5, 4, 5, 4, 4],  # 6 rows\n        [5, 5, 5, 5, 6],      # 5 rows\n        [4, 5, 5, 5, 4, 3],   # 6 rows\n        [3, 4, 5, 5, 5, 4],   # 6 rows\n        [5, 4, 5, 4, 4, 4],   # 6 rows\n    ]\n    \n    for config in configurations:\n        if sum(config) != 26:\n            continue\n            \n        # Try different base radii\n        for base_r in np.linspace(0.06, 0.12, 20):\n            centers = create_hex_grid(config, base_r)\n            \n            if len(centers) != 26:\n                continue\n            \n            # Compute actual maximum radius\n            max_r = compute_max_radius(centers)\n            \n            if max_r > 0:\n                radii = np.full(26, max_r)\n                sum_radii = np.sum(radii)\n                \n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n    \n    # Optimize positions with gradient descent\n    if best_centers is not None:\n        def objective(params):\n            centers = params.reshape(26, 2)\n            max_r = compute_max_radius(centers)\n            return -max_r * 26  # Maximize sum of radii\n        \n        def constraint_boundary(params):\n            centers = params.reshape(26, 2)\n            max_r = compute_max_radius(centers)\n            violations = []\n            for i in range(26):\n                x, y = centers[i]\n                violations.extend([\n                    x - max_r,\n                    1.0 - x - max_r,\n                    y - max_r,\n                    1.0 - y - max_r\n                ])\n            return np.array(violations)\n        \n        def constraint_overlap(params):\n            centers = params.reshape(26, 2)\n            max_r = compute_max_radius(centers)\n            violations = []\n            for i in range(26):\n                for j in range(i + 1, 26):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    violations.append(dist - 2 * max_r)\n            return np.array(violations)\n        \n        # Light optimization\n        try:\n            result = minimize(\n                objective,\n                best_centers.flatten(),\n                method='SLSQP',\n                constraints=[\n                    {'type': 'ineq', 'fun': constraint_boundary},\n                    {'type': 'ineq', 'fun': constraint_overlap}\n                ],\n                options={'maxiter': 100}\n            )\n            \n            if result.success:\n                opt_centers = result.x.reshape(26, 2)\n                opt_max_r = compute_max_radius(opt_centers)\n                if opt_max_r > 0:\n                    best_centers = opt_centers\n                    best_radii = np.full(26, opt_max_r)\n                    best_sum = np.sum(best_radii)\n        except:\n            pass\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.261746195129077,
    "target_ratio": 0.8583477021362721,
    "combined_score": 0.8583477021362721,
    "eval_time": 0.6009643077850342,
    "error": null
  },
  "prompt": "Write a hexagonal lattice circle packing algorithm for 26 circles in a unit square [0,1]x[0,1].\n\nUse a hexagonal close-packing pattern, which is optimal for infinite plane packing. Arrange circles in a hexagonal grid and adjust radii to maximize the sum while staying within bounds.\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- centers: np.array shape (26, 2) with (x,y) coordinates\n- radii: np.array shape (26,) with radius values\n- All circles must be entirely in [0,1]x[0,1]\n- No overlaps allowed\n- Maximize sum of radii\n\nUse numpy for calculations. Do not print or plot anything.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hexagonal lattice.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Hexagonal lattice arrangement\n    # We'll try to fit circles in a hexagonal pattern\n    # For 26 circles, we can try different row configurations\n    \n    # Try 5-5-5-5-6 pattern (5 rows with varying circles)\n    # Hexagonal packing has rows offset by 0.5 horizontally\n    \n    def create_hex_grid(rows_config, base_radius):\n        \"\"\"Create hexagonal grid with given row configuration.\"\"\"\n        centers = []\n        dy = base_radius * np.sqrt(3)  # vertical spacing in hex lattice\n        \n        y_pos = base_radius\n        for row_idx, n_circles in enumerate(rows_config):\n            # Horizontal spacing\n            if n_circles == 1:\n                dx = 0\n                x_start = 0.5\n            else:\n                dx = 2 * base_radius\n                # Center the row\n                row_width = (n_circles - 1) * dx\n                x_start = (1.0 - row_width) / 2\n            \n            # Offset every other row for hexagonal packing\n            x_offset = base_radius if row_idx % 2 == 1 else 0\n            \n            for i in range(n_circles):\n                x = x_start + i * dx + x_offset\n                centers.append([x, y_pos])\n            \n            y_pos += dy\n        \n        return np.array(centers)\n    \n    def compute_max_radius(centers):\n        \"\"\"Compute maximum radius that satisfies all constraints.\"\"\"\n        n = len(centers)\n        \n        # Maximum radius from boundary constraints\n        max_r_boundary = float('inf')\n        for i in range(n):\n            x, y = centers[i]\n            max_r_boundary = min(max_r_boundary, x, 1.0 - x, y, 1.0 - y)\n        \n        # Maximum radius from non-overlap constraints\n        max_r_overlap = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r_overlap = min(max_r_overlap, dist / 2.0)\n        \n        return min(max_r_boundary, max_r_overlap)\n    \n    # Try different hexagonal configurations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    configurations = [\n        [4, 5, 4, 5, 4, 4],  # 6 rows\n        [5, 5, 5, 5, 6],      # 5 rows\n        [4, 5, 5, 5, 4, 3],   # 6 rows\n        [3, 4, 5, 5, 5, 4],   # 6 rows\n        [5, 4, 5, 4, 4, 4],   # 6 rows\n    ]\n    \n    for config in configurations:\n        if sum(config) != 26:\n            continue\n            \n        # Try different base radii\n        for base_r in np.linspace(0.06, 0.12, 20):\n            centers = create_hex_grid(config, base_r)\n            \n            if len(centers) != 26:\n                continue\n            \n            # Compute actual maximum radius\n            max_r = compute_max_radius(centers)\n            \n            if max_r > 0:\n                radii = np.full(26, max_r)\n                sum_radii = np.sum(radii)\n                \n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n    \n    # Optimize positions with gradient descent\n    if best_centers is not None:\n        def objective(params):\n            centers = params.reshape(26, 2)\n            max_r = compute_max_radius(centers)\n            return -max_r * 26  # Maximize sum of radii\n        \n        def constraint_boundary(params):\n            centers = params.reshape(26, 2)\n            max_r = compute_max_radius(centers)\n            violations = []\n            for i in range(26):\n                x, y = centers[i]\n                violations.extend([\n                    x - max_r,\n                    1.0 - x - max_r,\n                    y - max_r,\n                    1.0 - y - max_r\n                ])\n            return np.array(violations)\n        \n        def constraint_overlap(params):\n            centers = params.reshape(26, 2)\n            max_r = compute_max_radius(centers)\n            violations = []\n            for i in range(26):\n                for j in range(i + 1, 26):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    violations.append(dist - 2 * max_r)\n            return np.array(violations)\n        \n        # Light optimization\n        try:\n            result = minimize(\n                objective,\n                best_centers.flatten(),\n                method='SLSQP',\n                constraints=[\n                    {'type': 'ineq', 'fun': constraint_boundary},\n                    {'type': 'ineq', 'fun': constraint_overlap}\n                ],\n                options={'maxiter': 100}\n            )\n            \n            if result.success:\n                opt_centers = result.x.reshape(26, 2)\n                opt_max_r = compute_max_radius(opt_centers)\n                if opt_max_r > 0:\n                    best_centers = opt_centers\n                    best_radii = np.full(26, opt_max_r)\n                    best_sum = np.sum(best_radii)\n        except:\n            pass\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:19:50.121047",
  "cost_data": null
}