{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    n = 26\n    \n    # Initialize with random positions\n    centers = np.random.uniform(0.1, 0.9, size=(n, 2))\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum valid radius for each circle.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if radii[j] > 0:\n                        max_r = min(max_r, dist - radii[j])\n                    else:\n                        max_r = min(max_r, dist / 2)\n            \n            radii[i] = max(0, max_r)\n        return radii\n    \n    def objective(positions):\n        \"\"\"Objective to minimize (negative sum of radii).\"\"\"\n        centers_temp = positions.reshape(n, 2)\n        radii_temp = compute_max_radii(centers_temp)\n        return -np.sum(radii_temp)\n    \n    def constraint_in_square(positions):\n        \"\"\"Ensure all centers can have positive radius within square.\"\"\"\n        centers_temp = positions.reshape(n, 2)\n        radii_temp = compute_max_radii(centers_temp)\n        # Each center must be at least min_radius from boundary\n        min_radius = 0.01\n        constraints = []\n        for i in range(n):\n            constraints.append(centers_temp[i, 0] - min_radius)\n            constraints.append(1 - min_radius - centers_temp[i, 0])\n            constraints.append(centers_temp[i, 1] - min_radius)\n            constraints.append(1 - min_radius - centers_temp[i, 1])\n        return np.array(constraints)\n    \n    # Multi-start local optimization\n    best_centers = centers.copy()\n    best_sum = -np.inf\n    \n    for attempt in range(5):\n        if attempt > 0:\n            # Random restart with some structure\n            grid_size = int(np.ceil(np.sqrt(n)))\n            centers = np.zeros((n, 2))\n            idx = 0\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if idx >= n:\n                        break\n                    centers[idx] = [\n                        (i + 0.5 + np.random.uniform(-0.3, 0.3)) / grid_size,\n                        (j + 0.5 + np.random.uniform(-0.3, 0.3)) / grid_size\n                    ]\n                    idx += 1\n        \n        # Local optimization iterations\n        for iteration in range(10):\n            radii = compute_max_radii(centers)\n            \n            # Optimize each circle position individually\n            for i in range(n):\n                def obj_single(pos):\n                    centers_temp = centers.copy()\n                    centers_temp[i] = pos\n                    radii_temp = compute_max_radii(centers_temp)\n                    return -radii_temp[i]\n                \n                bounds = [(radii[i], 1 - radii[i]), (radii[i], 1 - radii[i])]\n                \n                result = minimize(\n                    obj_single,\n                    centers[i],\n                    method='L-BFGS-B',\n                    bounds=bounds,\n                    options={'maxiter': 20}\n                )\n                \n                if result.success:\n                    centers[i] = result.x\n            \n            # Compute final radii for this iteration\n            radii = compute_max_radii(centers)\n            current_sum = np.sum(radii)\n            \n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = centers.copy()\n    \n    # Final computation with best centers\n    centers = best_centers\n    radii = compute_max_radii(centers)\n    \n    # Refinement: iteratively increase radii\n    for _ in range(50):\n        improved = False\n        for i in range(n):\n            # Try to increase radius slightly\n            test_radius = radii[i] * 1.01\n            \n            # Check if valid\n            valid = True\n            # Check boundaries\n            if (centers[i, 0] - test_radius < 0 or centers[i, 0] + test_radius > 1 or\n                centers[i, 1] - test_radius < 0 or centers[i, 1] + test_radius > 1):\n                valid = False\n            \n            # Check other circles\n            if valid:\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < test_radius + radii[j]:\n                            valid = False\n                            break\n            \n            if valid:\n                radii[i] = test_radius\n                improved = True\n        \n        if not improved:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.452921944757838,
    "target_ratio": 0.9309001687885534,
    "combined_score": 0.9309001687885534,
    "eval_time": 240.2975471019745,
    "error": null
  },
  "prompt": "Write a random placement with local optimization for 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Randomly place 26 circle centers in the square\n2. Compute maximum valid radius for each circle given its neighbors\n3. Apply local optimization: slightly move circles to increase radii\n4. Repeat optimization steps multiple times\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use numpy.random with fixed seed for reproducibility\n- No printing/plotting",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    n = 26\n    \n    # Initialize with random positions\n    centers = np.random.uniform(0.1, 0.9, size=(n, 2))\n    \n    def compute_max_radii(centers):\n        \"\"\"Compute maximum valid radius for each circle.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if radii[j] > 0:\n                        max_r = min(max_r, dist - radii[j])\n                    else:\n                        max_r = min(max_r, dist / 2)\n            \n            radii[i] = max(0, max_r)\n        return radii\n    \n    def objective(positions):\n        \"\"\"Objective to minimize (negative sum of radii).\"\"\"\n        centers_temp = positions.reshape(n, 2)\n        radii_temp = compute_max_radii(centers_temp)\n        return -np.sum(radii_temp)\n    \n    def constraint_in_square(positions):\n        \"\"\"Ensure all centers can have positive radius within square.\"\"\"\n        centers_temp = positions.reshape(n, 2)\n        radii_temp = compute_max_radii(centers_temp)\n        # Each center must be at least min_radius from boundary\n        min_radius = 0.01\n        constraints = []\n        for i in range(n):\n            constraints.append(centers_temp[i, 0] - min_radius)\n            constraints.append(1 - min_radius - centers_temp[i, 0])\n            constraints.append(centers_temp[i, 1] - min_radius)\n            constraints.append(1 - min_radius - centers_temp[i, 1])\n        return np.array(constraints)\n    \n    # Multi-start local optimization\n    best_centers = centers.copy()\n    best_sum = -np.inf\n    \n    for attempt in range(5):\n        if attempt > 0:\n            # Random restart with some structure\n            grid_size = int(np.ceil(np.sqrt(n)))\n            centers = np.zeros((n, 2))\n            idx = 0\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if idx >= n:\n                        break\n                    centers[idx] = [\n                        (i + 0.5 + np.random.uniform(-0.3, 0.3)) / grid_size,\n                        (j + 0.5 + np.random.uniform(-0.3, 0.3)) / grid_size\n                    ]\n                    idx += 1\n        \n        # Local optimization iterations\n        for iteration in range(10):\n            radii = compute_max_radii(centers)\n            \n            # Optimize each circle position individually\n            for i in range(n):\n                def obj_single(pos):\n                    centers_temp = centers.copy()\n                    centers_temp[i] = pos\n                    radii_temp = compute_max_radii(centers_temp)\n                    return -radii_temp[i]\n                \n                bounds = [(radii[i], 1 - radii[i]), (radii[i], 1 - radii[i])]\n                \n                result = minimize(\n                    obj_single,\n                    centers[i],\n                    method='L-BFGS-B',\n                    bounds=bounds,\n                    options={'maxiter': 20}\n                )\n                \n                if result.success:\n                    centers[i] = result.x\n            \n            # Compute final radii for this iteration\n            radii = compute_max_radii(centers)\n            current_sum = np.sum(radii)\n            \n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = centers.copy()\n    \n    # Final computation with best centers\n    centers = best_centers\n    radii = compute_max_radii(centers)\n    \n    # Refinement: iteratively increase radii\n    for _ in range(50):\n        improved = False\n        for i in range(n):\n            # Try to increase radius slightly\n            test_radius = radii[i] * 1.01\n            \n            # Check if valid\n            valid = True\n            # Check boundaries\n            if (centers[i, 0] - test_radius < 0 or centers[i, 0] + test_radius > 1 or\n                centers[i, 1] - test_radius < 0 or centers[i, 1] + test_radius > 1):\n                valid = False\n            \n            # Check other circles\n            if valid:\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < test_radius + radii[j]:\n                            valid = False\n                            break\n            \n            if valid:\n                radii[i] = test_radius\n                improved = True\n        \n        if not improved:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:23:47.705381",
  "cost_data": null
}