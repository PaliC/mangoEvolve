{
  "trial_id": "trial_0_9",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using genetic algorithm.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    pop_size = 100\n    n_generations = 500\n    mutation_rate = 0.3\n    tournament_size = 5\n    elite_size = 5\n    \n    def create_individual():\n        \"\"\"Create a random individual (centers and radii).\"\"\"\n        centers = np.random.rand(n_circles, 2)\n        radii = np.random.rand(n_circles) * 0.1 + 0.02\n        return centers, radii\n    \n    def calculate_max_radii(centers):\n        \"\"\"Calculate maximum possible radii for given centers.\"\"\"\n        radii = np.ones(n_circles) * 0.5\n        \n        for _ in range(50):  # Iterative refinement\n            # Distance to boundaries\n            dist_to_boundary = np.minimum(\n                np.minimum(centers[:, 0], 1 - centers[:, 0]),\n                np.minimum(centers[:, 1], 1 - centers[:, 1])\n            )\n            \n            # Distance to other circles\n            dists = cdist(centers, centers)\n            np.fill_diagonal(dists, np.inf)\n            \n            min_dists = np.full(n_circles, np.inf)\n            for i in range(n_circles):\n                for j in range(n_circles):\n                    if i != j:\n                        available = dists[i, j] - radii[j]\n                        min_dists[i] = min(min_dists[i], available)\n            \n            new_radii = np.minimum(dist_to_boundary, min_dists)\n            new_radii = np.maximum(new_radii, 0.001)\n            \n            if np.allclose(radii, new_radii, rtol=1e-4):\n                break\n            radii = new_radii * 0.95  # Safety margin\n        \n        return radii\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if packing is valid.\"\"\"\n        # Check boundaries\n        if np.any(centers - radii[:, np.newaxis] < 0) or \\\n           np.any(centers + radii[:, np.newaxis] > 1):\n            return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        np.fill_diagonal(dists, np.inf)\n        radii_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        \n        if np.any(dists < radii_sum - 1e-6):\n            return False\n        \n        return True\n    \n    def fitness(centers, radii):\n        \"\"\"Calculate fitness with penalties for invalid packings.\"\"\"\n        # Calculate theoretical max radii for these positions\n        max_radii = calculate_max_radii(centers)\n        \n        # Penalty for boundary violations\n        boundary_penalty = 0\n        min_to_boundary = np.minimum(\n            np.minimum(centers[:, 0], 1 - centers[:, 0]),\n            np.minimum(centers[:, 1], 1 - centers[:, 1])\n        )\n        violations = np.maximum(0, radii - min_to_boundary)\n        boundary_penalty = np.sum(violations) * 10\n        \n        # Penalty for overlaps\n        overlap_penalty = 0\n        dists = cdist(centers, centers)\n        np.fill_diagonal(dists, np.inf)\n        radii_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        overlaps = np.maximum(0, radii_sum - dists)\n        overlap_penalty = np.sum(overlaps) * 10\n        \n        # Use max possible radii as base fitness\n        base_fitness = np.sum(max_radii)\n        \n        return base_fitness - boundary_penalty - overlap_penalty\n    \n    def tournament_selection(population, fitnesses, tournament_size):\n        \"\"\"Select individual using tournament selection.\"\"\"\n        indices = np.random.choice(len(population), tournament_size, replace=False)\n        tournament_fitnesses = [fitnesses[i] for i in indices]\n        winner_idx = indices[np.argmax(tournament_fitnesses)]\n        return population[winner_idx]\n    \n    def crossover(parent1, parent2):\n        \"\"\"Crossover two parents.\"\"\"\n        centers1, radii1 = parent1\n        centers2, radii2 = parent2\n        \n        # Blend crossover for centers\n        alpha = np.random.rand()\n        child_centers = alpha * centers1 + (1 - alpha) * centers2\n        \n        # Mix radii\n        mask = np.random.rand(n_circles) > 0.5\n        child_radii = np.where(mask, radii1, radii2)\n        \n        return child_centers, child_radii\n    \n    def mutate(individual, mutation_rate):\n        \"\"\"Mutate an individual.\"\"\"\n        centers, radii = individual\n        centers = centers.copy()\n        radii = radii.copy()\n        \n        # Mutate centers\n        if np.random.rand() < mutation_rate:\n            n_mutate = max(1, int(n_circles * 0.2))\n            indices = np.random.choice(n_circles, n_mutate, replace=False)\n            centers[indices] += np.random.randn(n_mutate, 2) * 0.05\n            centers = np.clip(centers, 0.05, 0.95)\n        \n        # Recalculate radii based on new positions\n        radii = calculate_max_radii(centers)\n        \n        return centers, radii\n    \n    # Initialize population with diverse strategies\n    population = []\n    \n    # Grid-based initialization\n    for _ in range(pop_size // 3):\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        positions = []\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5 + np.random.randn() * 0.1) / grid_size\n            y = (row + 0.5 + np.random.randn() * 0.1) / grid_size\n            positions.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        centers = np.array(positions)\n        radii = calculate_max_radii(centers)\n        population.append((centers, radii))\n    \n    # Hexagonal-inspired initialization\n    for _ in range(pop_size // 3):\n        centers = []\n        for i in range(n_circles):\n            row = i // 6\n            col = i % 6\n            x = (col + (row % 2) * 0.5) / 6 + np.random.randn() * 0.02\n            y = row * np.sqrt(3) / 2 / 6 + np.random.randn() * 0.02\n            centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        centers = np.array(centers)\n        radii = calculate_max_radii(centers)\n        population.append((centers, radii))\n    \n    # Random initialization\n    for _ in range(pop_size - len(population)):\n        population.append(create_individual())\n    \n    # Evolutionary loop\n    best_fitness = -np.inf\n    best_individual = None\n    \n    for generation in range(n_generations):\n        # Evaluate fitness\n        fitnesses = [fitness(centers, radii) for centers, radii in population]\n        \n        # Track best\n        gen_best_idx = np.argmax(fitnesses)\n        if fitnesses[gen_best_idx] > best_fitness:\n            best_fitness = fitnesses[gen_best_idx]\n            best_individual = population[gen_best_idx]\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism\n        elite_indices = np.argsort(fitnesses)[-elite_size:]\n        for idx in elite_indices:\n            new_population.append(population[idx])\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            parent1 = tournament_selection(population, fitnesses, tournament_size)\n            parent2 = tournament_selection(population, fitnesses, tournament_size)\n            \n            child = crossover(parent1, parent2)\n            child = mutate(child, mutation_rate)\n            \n            new_population.append(child)\n        \n        population = new_population\n        \n        # Adaptive mutation\n        if generation % 50 == 0 and generation > 0:\n            mutation_rate *= 0.95\n    \n    # Return best solution with recalculated radii\n    centers, _ = best_individual\n    radii = calculate_max_radii(centers)\n    \n    # Final validation and adjustment\n    for _ in range(100):\n        if is_valid(centers, radii):\n            break\n        radii *= 0.99\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0089678764343,
    "error": "Timeout after 300s"
  },
  "prompt": "Write a genetic algorithm for circle packing 26 circles in [0,1]x[0,1].\n\nUse evolutionary approach:\n- Population: sets of (centers, radii)\n- Fitness: sum of radii (with penalty for invalid packings)\n- Operators: crossover (mix positions), mutation (adjust positions/radii)\n- Selection: tournament or roulette\n- Run for multiple generations\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use numpy\n- No printing/plotting",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using genetic algorithm.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    pop_size = 100\n    n_generations = 500\n    mutation_rate = 0.3\n    tournament_size = 5\n    elite_size = 5\n    \n    def create_individual():\n        \"\"\"Create a random individual (centers and radii).\"\"\"\n        centers = np.random.rand(n_circles, 2)\n        radii = np.random.rand(n_circles) * 0.1 + 0.02\n        return centers, radii\n    \n    def calculate_max_radii(centers):\n        \"\"\"Calculate maximum possible radii for given centers.\"\"\"\n        radii = np.ones(n_circles) * 0.5\n        \n        for _ in range(50):  # Iterative refinement\n            # Distance to boundaries\n            dist_to_boundary = np.minimum(\n                np.minimum(centers[:, 0], 1 - centers[:, 0]),\n                np.minimum(centers[:, 1], 1 - centers[:, 1])\n            )\n            \n            # Distance to other circles\n            dists = cdist(centers, centers)\n            np.fill_diagonal(dists, np.inf)\n            \n            min_dists = np.full(n_circles, np.inf)\n            for i in range(n_circles):\n                for j in range(n_circles):\n                    if i != j:\n                        available = dists[i, j] - radii[j]\n                        min_dists[i] = min(min_dists[i], available)\n            \n            new_radii = np.minimum(dist_to_boundary, min_dists)\n            new_radii = np.maximum(new_radii, 0.001)\n            \n            if np.allclose(radii, new_radii, rtol=1e-4):\n                break\n            radii = new_radii * 0.95  # Safety margin\n        \n        return radii\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if packing is valid.\"\"\"\n        # Check boundaries\n        if np.any(centers - radii[:, np.newaxis] < 0) or \\\n           np.any(centers + radii[:, np.newaxis] > 1):\n            return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        np.fill_diagonal(dists, np.inf)\n        radii_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        \n        if np.any(dists < radii_sum - 1e-6):\n            return False\n        \n        return True\n    \n    def fitness(centers, radii):\n        \"\"\"Calculate fitness with penalties for invalid packings.\"\"\"\n        # Calculate theoretical max radii for these positions\n        max_radii = calculate_max_radii(centers)\n        \n        # Penalty for boundary violations\n        boundary_penalty = 0\n        min_to_boundary = np.minimum(\n            np.minimum(centers[:, 0], 1 - centers[:, 0]),\n            np.minimum(centers[:, 1], 1 - centers[:, 1])\n        )\n        violations = np.maximum(0, radii - min_to_boundary)\n        boundary_penalty = np.sum(violations) * 10\n        \n        # Penalty for overlaps\n        overlap_penalty = 0\n        dists = cdist(centers, centers)\n        np.fill_diagonal(dists, np.inf)\n        radii_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n        overlaps = np.maximum(0, radii_sum - dists)\n        overlap_penalty = np.sum(overlaps) * 10\n        \n        # Use max possible radii as base fitness\n        base_fitness = np.sum(max_radii)\n        \n        return base_fitness - boundary_penalty - overlap_penalty\n    \n    def tournament_selection(population, fitnesses, tournament_size):\n        \"\"\"Select individual using tournament selection.\"\"\"\n        indices = np.random.choice(len(population), tournament_size, replace=False)\n        tournament_fitnesses = [fitnesses[i] for i in indices]\n        winner_idx = indices[np.argmax(tournament_fitnesses)]\n        return population[winner_idx]\n    \n    def crossover(parent1, parent2):\n        \"\"\"Crossover two parents.\"\"\"\n        centers1, radii1 = parent1\n        centers2, radii2 = parent2\n        \n        # Blend crossover for centers\n        alpha = np.random.rand()\n        child_centers = alpha * centers1 + (1 - alpha) * centers2\n        \n        # Mix radii\n        mask = np.random.rand(n_circles) > 0.5\n        child_radii = np.where(mask, radii1, radii2)\n        \n        return child_centers, child_radii\n    \n    def mutate(individual, mutation_rate):\n        \"\"\"Mutate an individual.\"\"\"\n        centers, radii = individual\n        centers = centers.copy()\n        radii = radii.copy()\n        \n        # Mutate centers\n        if np.random.rand() < mutation_rate:\n            n_mutate = max(1, int(n_circles * 0.2))\n            indices = np.random.choice(n_circles, n_mutate, replace=False)\n            centers[indices] += np.random.randn(n_mutate, 2) * 0.05\n            centers = np.clip(centers, 0.05, 0.95)\n        \n        # Recalculate radii based on new positions\n        radii = calculate_max_radii(centers)\n        \n        return centers, radii\n    \n    # Initialize population with diverse strategies\n    population = []\n    \n    # Grid-based initialization\n    for _ in range(pop_size // 3):\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        positions = []\n        for i in range(n_circles):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5 + np.random.randn() * 0.1) / grid_size\n            y = (row + 0.5 + np.random.randn() * 0.1) / grid_size\n            positions.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        centers = np.array(positions)\n        radii = calculate_max_radii(centers)\n        population.append((centers, radii))\n    \n    # Hexagonal-inspired initialization\n    for _ in range(pop_size // 3):\n        centers = []\n        for i in range(n_circles):\n            row = i // 6\n            col = i % 6\n            x = (col + (row % 2) * 0.5) / 6 + np.random.randn() * 0.02\n            y = row * np.sqrt(3) / 2 / 6 + np.random.randn() * 0.02\n            centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n        centers = np.array(centers)\n        radii = calculate_max_radii(centers)\n        population.append((centers, radii))\n    \n    # Random initialization\n    for _ in range(pop_size - len(population)):\n        population.append(create_individual())\n    \n    # Evolutionary loop\n    best_fitness = -np.inf\n    best_individual = None\n    \n    for generation in range(n_generations):\n        # Evaluate fitness\n        fitnesses = [fitness(centers, radii) for centers, radii in population]\n        \n        # Track best\n        gen_best_idx = np.argmax(fitnesses)\n        if fitnesses[gen_best_idx] > best_fitness:\n            best_fitness = fitnesses[gen_best_idx]\n            best_individual = population[gen_best_idx]\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism\n        elite_indices = np.argsort(fitnesses)[-elite_size:]\n        for idx in elite_indices:\n            new_population.append(population[idx])\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            parent1 = tournament_selection(population, fitnesses, tournament_size)\n            parent2 = tournament_selection(population, fitnesses, tournament_size)\n            \n            child = crossover(parent1, parent2)\n            child = mutate(child, mutation_rate)\n            \n            new_population.append(child)\n        \n        population = new_population\n        \n        # Adaptive mutation\n        if generation % 50 == 0 and generation > 0:\n            mutation_rate *= 0.95\n    \n    # Return best solution with recalculated radii\n    centers, _ = best_individual\n    radii = calculate_max_radii(centers)\n    \n    # Final validation and adjustment\n    for _ in range(100):\n        if is_valid(centers, radii):\n            break\n        radii *= 0.99\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:24:57.463148",
  "cost_data": null
}