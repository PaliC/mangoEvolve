{
  "trial_id": "trial_0_11",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Strategy: Place circles along boundary first, then fill interior.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Strategy: 16 boundary circles + 10 interior circles\n    n_boundary = 16\n    n_interior = 10\n    \n    def compute_radii_and_validity(params):\n        \"\"\"\n        Given center positions, compute maximum valid radii.\n        Returns radii array and validity flag.\n        \"\"\"\n        centers = params.reshape(n, 2)\n        radii = np.zeros(n)\n        \n        # For each circle, compute maximum radius\n        for i in range(n):\n            # Distance to boundaries\n            min_dist_boundary = min(\n                centers[i, 0],           # left\n                1 - centers[i, 0],       # right\n                centers[i, 1],           # bottom\n                1 - centers[i, 1]        # top\n            )\n            \n            # Distance to other circles\n            min_dist_circles = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    # We need dist >= r_i + r_j\n                    # If we set r_i to be as large as possible, r_j is already set\n                    if j < i:\n                        # r_j already computed\n                        available = dist - radii[j]\n                        min_dist_circles = min(min_dist_circles, available)\n                    else:\n                        # r_j not yet computed, assume symmetric\n                        min_dist_circles = min(min_dist_circles, dist / 2)\n            \n            radii[i] = min(min_dist_boundary, min_dist_circles)\n            \n            if radii[i] < 0:\n                return radii, False\n        \n        return radii, True\n    \n    def objective(params):\n        \"\"\"Negative sum of radii (for minimization).\"\"\"\n        radii, valid = compute_radii_and_validity(params)\n        if not valid:\n            return 1e10\n        return -np.sum(radii)\n    \n    # Initialize boundary circles\n    # Place them along the perimeter with centers offset from edges\n    boundary_centers = []\n    \n    # Bottom edge (4 circles)\n    for i in range(4):\n        x = (i + 1) / 5\n        y = 0.08\n        boundary_centers.append([x, y])\n    \n    # Right edge (4 circles)\n    for i in range(4):\n        x = 0.92\n        y = (i + 1) / 5\n        boundary_centers.append([x, y])\n    \n    # Top edge (4 circles)\n    for i in range(4):\n        x = 1 - (i + 1) / 5\n        y = 0.92\n        boundary_centers.append([x, y])\n    \n    # Left edge (4 circles)\n    for i in range(4):\n        x = 0.08\n        y = 1 - (i + 1) / 5\n        boundary_centers.append([x, y])\n    \n    # Interior circles - arranged in a grid pattern\n    interior_centers = []\n    grid_size = int(np.ceil(np.sqrt(n_interior)))\n    spacing = 0.6 / (grid_size + 1)\n    offset = 0.2\n    \n    for i in range(n_interior):\n        row = i // grid_size\n        col = i % grid_size\n        x = offset + (col + 1) * spacing\n        y = offset + (row + 1) * spacing\n        interior_centers.append([x, y])\n    \n    # Combine all centers\n    initial_centers = np.array(boundary_centers + interior_centers)\n    \n    # Optimize\n    initial_params = initial_centers.flatten()\n    \n    # Bounds: all centers must allow for positive radius\n    bounds = [(0.02, 0.98) for _ in range(2 * n)]\n    \n    # Optimize with multiple restarts\n    best_result = None\n    best_sum = -float('inf')\n    \n    for attempt in range(3):\n        if attempt > 0:\n            # Add some randomness for restarts\n            noise = np.random.randn(2 * n) * 0.05\n            init = initial_params + noise\n            init = np.clip(init, 0.02, 0.98)\n        else:\n            init = initial_params\n        \n        result = minimize(\n            objective,\n            init,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if -result.fun > best_sum:\n            best_sum = -result.fun\n            best_result = result\n    \n    # Extract final solution\n    final_centers = best_result.x.reshape(n, 2)\n    final_radii, valid = compute_radii_and_validity(best_result.x)\n    \n    # Refine radii calculation with proper constraint checking\n    # Recompute radii more carefully\n    refined_radii = np.zeros(n)\n    for i in range(n):\n        # Distance to boundaries\n        max_r = min(\n            final_centers[i, 0],\n            1 - final_centers[i, 0],\n            final_centers[i, 1],\n            1 - final_centers[i, 1]\n        )\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(final_centers[i] - final_centers[j])\n                max_r = min(max_r, (dist - refined_radii[j]) if j < i else dist / 2)\n        \n        refined_radii[i] = max(0, max_r * 0.999)  # Small safety margin\n    \n    sum_radii = np.sum(refined_radii)\n    \n    return final_centers, refined_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.445271038952942,
    "target_ratio": 0.927996599223128,
    "combined_score": 0.927996599223128,
    "eval_time": 47.9814178943634,
    "error": null
  },
  "prompt": "Write a boundary-first circle packing for 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Place circles along the boundary of the square first\n2. These can have larger radii using the boundary\n3. Fill interior with remaining circles\n4. Optimize placement for maximum sum\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use numpy\n- No printing/plotting",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Strategy: Place circles along boundary first, then fill interior.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Strategy: 16 boundary circles + 10 interior circles\n    n_boundary = 16\n    n_interior = 10\n    \n    def compute_radii_and_validity(params):\n        \"\"\"\n        Given center positions, compute maximum valid radii.\n        Returns radii array and validity flag.\n        \"\"\"\n        centers = params.reshape(n, 2)\n        radii = np.zeros(n)\n        \n        # For each circle, compute maximum radius\n        for i in range(n):\n            # Distance to boundaries\n            min_dist_boundary = min(\n                centers[i, 0],           # left\n                1 - centers[i, 0],       # right\n                centers[i, 1],           # bottom\n                1 - centers[i, 1]        # top\n            )\n            \n            # Distance to other circles\n            min_dist_circles = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    # We need dist >= r_i + r_j\n                    # If we set r_i to be as large as possible, r_j is already set\n                    if j < i:\n                        # r_j already computed\n                        available = dist - radii[j]\n                        min_dist_circles = min(min_dist_circles, available)\n                    else:\n                        # r_j not yet computed, assume symmetric\n                        min_dist_circles = min(min_dist_circles, dist / 2)\n            \n            radii[i] = min(min_dist_boundary, min_dist_circles)\n            \n            if radii[i] < 0:\n                return radii, False\n        \n        return radii, True\n    \n    def objective(params):\n        \"\"\"Negative sum of radii (for minimization).\"\"\"\n        radii, valid = compute_radii_and_validity(params)\n        if not valid:\n            return 1e10\n        return -np.sum(radii)\n    \n    # Initialize boundary circles\n    # Place them along the perimeter with centers offset from edges\n    boundary_centers = []\n    \n    # Bottom edge (4 circles)\n    for i in range(4):\n        x = (i + 1) / 5\n        y = 0.08\n        boundary_centers.append([x, y])\n    \n    # Right edge (4 circles)\n    for i in range(4):\n        x = 0.92\n        y = (i + 1) / 5\n        boundary_centers.append([x, y])\n    \n    # Top edge (4 circles)\n    for i in range(4):\n        x = 1 - (i + 1) / 5\n        y = 0.92\n        boundary_centers.append([x, y])\n    \n    # Left edge (4 circles)\n    for i in range(4):\n        x = 0.08\n        y = 1 - (i + 1) / 5\n        boundary_centers.append([x, y])\n    \n    # Interior circles - arranged in a grid pattern\n    interior_centers = []\n    grid_size = int(np.ceil(np.sqrt(n_interior)))\n    spacing = 0.6 / (grid_size + 1)\n    offset = 0.2\n    \n    for i in range(n_interior):\n        row = i // grid_size\n        col = i % grid_size\n        x = offset + (col + 1) * spacing\n        y = offset + (row + 1) * spacing\n        interior_centers.append([x, y])\n    \n    # Combine all centers\n    initial_centers = np.array(boundary_centers + interior_centers)\n    \n    # Optimize\n    initial_params = initial_centers.flatten()\n    \n    # Bounds: all centers must allow for positive radius\n    bounds = [(0.02, 0.98) for _ in range(2 * n)]\n    \n    # Optimize with multiple restarts\n    best_result = None\n    best_sum = -float('inf')\n    \n    for attempt in range(3):\n        if attempt > 0:\n            # Add some randomness for restarts\n            noise = np.random.randn(2 * n) * 0.05\n            init = initial_params + noise\n            init = np.clip(init, 0.02, 0.98)\n        else:\n            init = initial_params\n        \n        result = minimize(\n            objective,\n            init,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if -result.fun > best_sum:\n            best_sum = -result.fun\n            best_result = result\n    \n    # Extract final solution\n    final_centers = best_result.x.reshape(n, 2)\n    final_radii, valid = compute_radii_and_validity(best_result.x)\n    \n    # Refine radii calculation with proper constraint checking\n    # Recompute radii more carefully\n    refined_radii = np.zeros(n)\n    for i in range(n):\n        # Distance to boundaries\n        max_r = min(\n            final_centers[i, 0],\n            1 - final_centers[i, 0],\n            final_centers[i, 1],\n            1 - final_centers[i, 1]\n        )\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(final_centers[i] - final_centers[j])\n                max_r = min(max_r, (dist - refined_radii[j]) if j < i else dist / 2)\n        \n        refined_radii[i] = max(0, max_r * 0.999)  # Small safety margin\n    \n    sum_radii = np.sum(refined_radii)\n    \n    return final_centers, refined_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:20:38.549380",
  "cost_data": null
}