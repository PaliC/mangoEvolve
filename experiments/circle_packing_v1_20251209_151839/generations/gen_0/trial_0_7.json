{
  "trial_id": "trial_0_7",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using largest-first strategy.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = []\n    radii = []\n    \n    # Place first circle at center with maximum radius\n    first_center = np.array([0.5, 0.5])\n    first_radius = 0.5\n    centers.append(first_center)\n    radii.append(first_radius)\n    \n    # Place remaining circles\n    for i in range(1, n):\n        best_center = None\n        best_radius = 0.0\n        \n        # Generate candidate positions\n        candidates = generate_candidate_positions(centers, radii, num_candidates=100)\n        \n        # For each candidate position, find maximum valid radius\n        for candidate in candidates:\n            max_radius = find_max_radius_at_position(candidate, centers, radii)\n            if max_radius > best_radius:\n                best_radius = max_radius\n                best_center = candidate\n        \n        # Also try optimization-based placement\n        if len(centers) > 0:\n            opt_center, opt_radius = optimize_placement(centers, radii)\n            if opt_radius > best_radius:\n                best_radius = opt_radius\n                best_center = opt_center\n        \n        if best_center is not None and best_radius > 1e-6:\n            centers.append(best_center)\n            radii.append(best_radius)\n        else:\n            # Fallback: place small circle in a valid position\n            fallback_center, fallback_radius = find_fallback_position(centers, radii)\n            centers.append(fallback_center)\n            radii.append(fallback_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef generate_candidate_positions(centers: list, radii: list, num_candidates: int = 100) -> np.ndarray:\n    \"\"\"Generate candidate positions for next circle.\"\"\"\n    candidates = []\n    \n    # Grid-based candidates\n    grid_size = int(np.sqrt(num_candidates // 2))\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = (i + 0.5) / grid_size\n            y = (j + 0.5) / grid_size\n            candidates.append([x, y])\n    \n    # Positions tangent to existing circles\n    if len(centers) > 0:\n        for i, (center, radius) in enumerate(zip(centers, radii)):\n            # Try positions around each existing circle\n            for angle in np.linspace(0, 2*np.pi, 8, endpoint=False):\n                # Try different distances\n                for dist_factor in [1.1, 1.3, 1.5]:\n                    offset = dist_factor * radius * np.array([np.cos(angle), np.sin(angle)])\n                    candidate = center + offset\n                    if 0 < candidate[0] < 1 and 0 < candidate[1] < 1:\n                        candidates.append(candidate)\n    \n    # Positions in corners and edges\n    margin = 0.1\n    edge_positions = [\n        [margin, margin], [1-margin, margin], \n        [margin, 1-margin], [1-margin, 1-margin],\n        [0.5, margin], [0.5, 1-margin],\n        [margin, 0.5], [1-margin, 0.5]\n    ]\n    candidates.extend(edge_positions)\n    \n    return np.array(candidates)\n\n\ndef find_max_radius_at_position(pos: np.ndarray, centers: list, radii: list) -> float:\n    \"\"\"Find maximum radius for a circle at given position.\"\"\"\n    x, y = pos\n    \n    # Maximum radius from square boundaries\n    max_r = min(x, y, 1-x, 1-y)\n    \n    if max_r <= 0:\n        return 0.0\n    \n    # Maximum radius from existing circles\n    for center, radius in zip(centers, radii):\n        dist = np.linalg.norm(pos - center)\n        max_r = min(max_r, dist - radius)\n    \n    return max(0.0, max_r)\n\n\ndef optimize_placement(centers: list, radii: list) -> Tuple[np.ndarray, float]:\n    \"\"\"Use optimization to find best placement for next circle.\"\"\"\n    \n    def objective(x):\n        \"\"\"Negative radius (to maximize radius by minimizing negative).\"\"\"\n        pos = x[:2]\n        radius = find_max_radius_at_position(pos, centers, radii)\n        return -radius\n    \n    best_result = None\n    best_radius = 0.0\n    \n    # Try multiple starting points\n    starting_points = [\n        [0.5, 0.5],\n        [0.25, 0.25], [0.75, 0.25],\n        [0.25, 0.75], [0.75, 0.75],\n        [0.5, 0.25], [0.5, 0.75],\n        [0.25, 0.5], [0.75, 0.5]\n    ]\n    \n    for start in starting_points:\n        try:\n            result = minimize(\n                objective,\n                start,\n                method='L-BFGS-B',\n                bounds=[(0.01, 0.99), (0.01, 0.99)]\n            )\n            \n            if result.success:\n                pos = result.x\n                radius = find_max_radius_at_position(pos, centers, radii)\n                if radius > best_radius:\n                    best_radius = radius\n                    best_result = pos\n        except:\n            continue\n    \n    if best_result is not None:\n        return best_result, best_radius\n    else:\n        return np.array([0.5, 0.5]), 0.0\n\n\ndef find_fallback_position(centers: list, radii: list) -> Tuple[np.ndarray, float]:\n    \"\"\"Find a valid fallback position with small radius.\"\"\"\n    # Try to find any valid position with positive radius\n    for _ in range(100):\n        pos = np.random.uniform(0.1, 0.9, 2)\n        radius = find_max_radius_at_position(pos, centers, radii)\n        if radius > 1e-6:\n            return pos, radius\n    \n    # Last resort: place very small circle\n    return np.array([0.5, 0.5]), 1e-6\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.3035714285714282,
    "target_ratio": 0.4947140146381132,
    "combined_score": 0.4947140146381132,
    "eval_time": 0.4627809524536133,
    "error": null
  },
  "prompt": "Write a largest-first circle packing for 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Place the largest possible circle first (center of square)\n2. For each subsequent circle, find the position allowing maximum radius\n3. Consider positions near existing circles and in empty spaces\n4. Use binary search to find maximum valid radius at each position\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use numpy\n- No printing/plotting",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using largest-first strategy.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = []\n    radii = []\n    \n    # Place first circle at center with maximum radius\n    first_center = np.array([0.5, 0.5])\n    first_radius = 0.5\n    centers.append(first_center)\n    radii.append(first_radius)\n    \n    # Place remaining circles\n    for i in range(1, n):\n        best_center = None\n        best_radius = 0.0\n        \n        # Generate candidate positions\n        candidates = generate_candidate_positions(centers, radii, num_candidates=100)\n        \n        # For each candidate position, find maximum valid radius\n        for candidate in candidates:\n            max_radius = find_max_radius_at_position(candidate, centers, radii)\n            if max_radius > best_radius:\n                best_radius = max_radius\n                best_center = candidate\n        \n        # Also try optimization-based placement\n        if len(centers) > 0:\n            opt_center, opt_radius = optimize_placement(centers, radii)\n            if opt_radius > best_radius:\n                best_radius = opt_radius\n                best_center = opt_center\n        \n        if best_center is not None and best_radius > 1e-6:\n            centers.append(best_center)\n            radii.append(best_radius)\n        else:\n            # Fallback: place small circle in a valid position\n            fallback_center, fallback_radius = find_fallback_position(centers, radii)\n            centers.append(fallback_center)\n            radii.append(fallback_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef generate_candidate_positions(centers: list, radii: list, num_candidates: int = 100) -> np.ndarray:\n    \"\"\"Generate candidate positions for next circle.\"\"\"\n    candidates = []\n    \n    # Grid-based candidates\n    grid_size = int(np.sqrt(num_candidates // 2))\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = (i + 0.5) / grid_size\n            y = (j + 0.5) / grid_size\n            candidates.append([x, y])\n    \n    # Positions tangent to existing circles\n    if len(centers) > 0:\n        for i, (center, radius) in enumerate(zip(centers, radii)):\n            # Try positions around each existing circle\n            for angle in np.linspace(0, 2*np.pi, 8, endpoint=False):\n                # Try different distances\n                for dist_factor in [1.1, 1.3, 1.5]:\n                    offset = dist_factor * radius * np.array([np.cos(angle), np.sin(angle)])\n                    candidate = center + offset\n                    if 0 < candidate[0] < 1 and 0 < candidate[1] < 1:\n                        candidates.append(candidate)\n    \n    # Positions in corners and edges\n    margin = 0.1\n    edge_positions = [\n        [margin, margin], [1-margin, margin], \n        [margin, 1-margin], [1-margin, 1-margin],\n        [0.5, margin], [0.5, 1-margin],\n        [margin, 0.5], [1-margin, 0.5]\n    ]\n    candidates.extend(edge_positions)\n    \n    return np.array(candidates)\n\n\ndef find_max_radius_at_position(pos: np.ndarray, centers: list, radii: list) -> float:\n    \"\"\"Find maximum radius for a circle at given position.\"\"\"\n    x, y = pos\n    \n    # Maximum radius from square boundaries\n    max_r = min(x, y, 1-x, 1-y)\n    \n    if max_r <= 0:\n        return 0.0\n    \n    # Maximum radius from existing circles\n    for center, radius in zip(centers, radii):\n        dist = np.linalg.norm(pos - center)\n        max_r = min(max_r, dist - radius)\n    \n    return max(0.0, max_r)\n\n\ndef optimize_placement(centers: list, radii: list) -> Tuple[np.ndarray, float]:\n    \"\"\"Use optimization to find best placement for next circle.\"\"\"\n    \n    def objective(x):\n        \"\"\"Negative radius (to maximize radius by minimizing negative).\"\"\"\n        pos = x[:2]\n        radius = find_max_radius_at_position(pos, centers, radii)\n        return -radius\n    \n    best_result = None\n    best_radius = 0.0\n    \n    # Try multiple starting points\n    starting_points = [\n        [0.5, 0.5],\n        [0.25, 0.25], [0.75, 0.25],\n        [0.25, 0.75], [0.75, 0.75],\n        [0.5, 0.25], [0.5, 0.75],\n        [0.25, 0.5], [0.75, 0.5]\n    ]\n    \n    for start in starting_points:\n        try:\n            result = minimize(\n                objective,\n                start,\n                method='L-BFGS-B',\n                bounds=[(0.01, 0.99), (0.01, 0.99)]\n            )\n            \n            if result.success:\n                pos = result.x\n                radius = find_max_radius_at_position(pos, centers, radii)\n                if radius > best_radius:\n                    best_radius = radius\n                    best_result = pos\n        except:\n            continue\n    \n    if best_result is not None:\n        return best_result, best_radius\n    else:\n        return np.array([0.5, 0.5]), 0.0\n\n\ndef find_fallback_position(centers: list, radii: list) -> Tuple[np.ndarray, float]:\n    \"\"\"Find a valid fallback position with small radius.\"\"\"\n    # Try to find any valid position with positive radius\n    for _ in range(100):\n        pos = np.random.uniform(0.1, 0.9, 2)\n        radius = find_max_radius_at_position(pos, centers, radii)\n        if radius > 1e-6:\n            return pos, radius\n    \n    # Last resort: place very small circle\n    return np.array([0.5, 0.5]), 1e-6\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:19:50.435686",
  "cost_data": null
}