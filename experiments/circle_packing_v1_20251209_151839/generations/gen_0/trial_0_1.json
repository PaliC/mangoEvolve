{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = []\n    radii = []\n    \n    # Helper function to compute maximum radius at a given position\n    def max_radius_at_position(x, y, existing_centers, existing_radii):\n        \"\"\"Compute maximum radius for a circle at (x, y) given existing circles.\"\"\"\n        # Constraint from boundaries\n        max_r = min(x, y, 1 - x, 1 - y)\n        \n        # Constraint from existing circles\n        for i, (cx, cy) in enumerate(existing_centers):\n            dist = np.sqrt((x - cx)**2 + (y - cy)**2)\n            max_r = min(max_r, dist - existing_radii[i])\n        \n        return max(0, max_r)\n    \n    # Helper function to find best position for next circle\n    def find_best_position(existing_centers, existing_radii, grid_size=20):\n        \"\"\"Find position that allows maximum radius.\"\"\"\n        best_x, best_y, best_r = 0.5, 0.5, 0\n        \n        # Grid search\n        grid = np.linspace(0, 1, grid_size)\n        for x in grid:\n            for y in grid:\n                r = max_radius_at_position(x, y, existing_centers, existing_radii)\n                if r > best_r:\n                    best_x, best_y, best_r = x, y, r\n        \n        # Refine with optimization\n        if best_r > 0:\n            def objective(pos):\n                return -max_radius_at_position(pos[0], pos[1], existing_centers, existing_radii)\n            \n            result = minimize(\n                objective,\n                [best_x, best_y],\n                method='L-BFGS-B',\n                bounds=[(0, 1), (0, 1)]\n            )\n            \n            if result.success:\n                refined_r = max_radius_at_position(result.x[0], result.x[1], existing_centers, existing_radii)\n                if refined_r > best_r:\n                    best_x, best_y, best_r = result.x[0], result.x[1], refined_r\n        \n        return best_x, best_y, best_r\n    \n    # Place first circle at center with maximum radius\n    first_r = 0.5\n    centers.append([0.5, 0.5])\n    radii.append(first_r)\n    \n    # Place remaining circles greedily\n    for i in range(1, n):\n        # Try multiple strategies for better coverage\n        candidates = []\n        \n        # Strategy 1: Pure greedy - find globally best position\n        x, y, r = find_best_position(centers, radii, grid_size=15)\n        candidates.append((x, y, r))\n        \n        # Strategy 2: Try positions near existing circles\n        for cx, cy in centers[-min(5, len(centers)):]:\n            for angle in np.linspace(0, 2*np.pi, 8, endpoint=False):\n                for dist_factor in [0.8, 1.0, 1.2]:\n                    test_x = cx + dist_factor * 0.1 * np.cos(angle)\n                    test_y = cy + dist_factor * 0.1 * np.sin(angle)\n                    if 0 <= test_x <= 1 and 0 <= test_y <= 1:\n                        test_r = max_radius_at_position(test_x, test_y, centers, radii)\n                        candidates.append((test_x, test_y, test_r))\n        \n        # Strategy 3: Try corners and edges\n        edge_points = [\n            (0.05, 0.05), (0.95, 0.05), (0.05, 0.95), (0.95, 0.95),\n            (0.5, 0.05), (0.5, 0.95), (0.05, 0.5), (0.95, 0.5)\n        ]\n        for ex, ey in edge_points:\n            test_r = max_radius_at_position(ex, ey, centers, radii)\n            candidates.append((ex, ey, test_r))\n        \n        # Choose best candidate\n        best_candidate = max(candidates, key=lambda c: c[2])\n        best_x, best_y, best_r = best_candidate\n        \n        if best_r > 1e-6:\n            centers.append([best_x, best_y])\n            radii.append(best_r)\n        else:\n            # If no good position found, place tiny circle at safe location\n            # Find a spot with minimal overlap\n            safe_x, safe_y = 0.5, 0.5\n            for attempt in range(100):\n                test_x = np.random.uniform(0.1, 0.9)\n                test_y = np.random.uniform(0.1, 0.9)\n                test_r = max_radius_at_position(test_x, test_y, centers, radii)\n                if test_r > best_r:\n                    safe_x, safe_y, best_r = test_x, test_y, test_r\n            \n            centers.append([safe_x, safe_y])\n            radii.append(max(best_r, 1e-8))\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.3597521674958486,
    "target_ratio": 0.5160349781767927,
    "combined_score": 0.5160349781767927,
    "eval_time": 0.28931093215942383,
    "error": null
  },
  "prompt": "Write a greedy circle packing algorithm for 26 circles in [0,1]x[0,1].\n\nStrategy: Place circles one by one, choosing positions that allow maximum radius at each step.\n- Start with largest possible circle\n- For each subsequent circle, find the position that allows the largest radius\n- Check all constraints: boundaries and no overlaps with existing circles\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use numpy arrays\n- No printing or plotting\n- Maximize sum of radii for 26 circles",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    centers = []\n    radii = []\n    \n    # Helper function to compute maximum radius at a given position\n    def max_radius_at_position(x, y, existing_centers, existing_radii):\n        \"\"\"Compute maximum radius for a circle at (x, y) given existing circles.\"\"\"\n        # Constraint from boundaries\n        max_r = min(x, y, 1 - x, 1 - y)\n        \n        # Constraint from existing circles\n        for i, (cx, cy) in enumerate(existing_centers):\n            dist = np.sqrt((x - cx)**2 + (y - cy)**2)\n            max_r = min(max_r, dist - existing_radii[i])\n        \n        return max(0, max_r)\n    \n    # Helper function to find best position for next circle\n    def find_best_position(existing_centers, existing_radii, grid_size=20):\n        \"\"\"Find position that allows maximum radius.\"\"\"\n        best_x, best_y, best_r = 0.5, 0.5, 0\n        \n        # Grid search\n        grid = np.linspace(0, 1, grid_size)\n        for x in grid:\n            for y in grid:\n                r = max_radius_at_position(x, y, existing_centers, existing_radii)\n                if r > best_r:\n                    best_x, best_y, best_r = x, y, r\n        \n        # Refine with optimization\n        if best_r > 0:\n            def objective(pos):\n                return -max_radius_at_position(pos[0], pos[1], existing_centers, existing_radii)\n            \n            result = minimize(\n                objective,\n                [best_x, best_y],\n                method='L-BFGS-B',\n                bounds=[(0, 1), (0, 1)]\n            )\n            \n            if result.success:\n                refined_r = max_radius_at_position(result.x[0], result.x[1], existing_centers, existing_radii)\n                if refined_r > best_r:\n                    best_x, best_y, best_r = result.x[0], result.x[1], refined_r\n        \n        return best_x, best_y, best_r\n    \n    # Place first circle at center with maximum radius\n    first_r = 0.5\n    centers.append([0.5, 0.5])\n    radii.append(first_r)\n    \n    # Place remaining circles greedily\n    for i in range(1, n):\n        # Try multiple strategies for better coverage\n        candidates = []\n        \n        # Strategy 1: Pure greedy - find globally best position\n        x, y, r = find_best_position(centers, radii, grid_size=15)\n        candidates.append((x, y, r))\n        \n        # Strategy 2: Try positions near existing circles\n        for cx, cy in centers[-min(5, len(centers)):]:\n            for angle in np.linspace(0, 2*np.pi, 8, endpoint=False):\n                for dist_factor in [0.8, 1.0, 1.2]:\n                    test_x = cx + dist_factor * 0.1 * np.cos(angle)\n                    test_y = cy + dist_factor * 0.1 * np.sin(angle)\n                    if 0 <= test_x <= 1 and 0 <= test_y <= 1:\n                        test_r = max_radius_at_position(test_x, test_y, centers, radii)\n                        candidates.append((test_x, test_y, test_r))\n        \n        # Strategy 3: Try corners and edges\n        edge_points = [\n            (0.05, 0.05), (0.95, 0.05), (0.05, 0.95), (0.95, 0.95),\n            (0.5, 0.05), (0.5, 0.95), (0.05, 0.5), (0.95, 0.5)\n        ]\n        for ex, ey in edge_points:\n            test_r = max_radius_at_position(ex, ey, centers, radii)\n            candidates.append((ex, ey, test_r))\n        \n        # Choose best candidate\n        best_candidate = max(candidates, key=lambda c: c[2])\n        best_x, best_y, best_r = best_candidate\n        \n        if best_r > 1e-6:\n            centers.append([best_x, best_y])\n            radii.append(best_r)\n        else:\n            # If no good position found, place tiny circle at safe location\n            # Find a spot with minimal overlap\n            safe_x, safe_y = 0.5, 0.5\n            for attempt in range(100):\n                test_x = np.random.uniform(0.1, 0.9)\n                test_y = np.random.uniform(0.1, 0.9)\n                test_r = max_radius_at_position(test_x, test_y, centers, radii)\n                if test_r > best_r:\n                    safe_x, safe_y, best_r = test_x, test_y, test_r\n            \n            centers.append([safe_x, safe_y])\n            radii.append(max(best_r, 1e-8))\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:19:47.235686",
  "cost_data": null
}