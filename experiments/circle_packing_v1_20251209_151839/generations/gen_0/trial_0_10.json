{
  "trial_id": "trial_0_10",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using simulated annealing.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with grid-based placement\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = np.zeros((n, 2))\n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx >= n:\n                break\n            centers[idx] = [(i + 0.5) / grid_size, (j + 0.5) / grid_size]\n            idx += 1\n    \n    # Initialize radii - start with small uniform radii\n    radii = np.ones(n) * 0.05\n    \n    def calculate_max_radii(centers):\n        \"\"\"Calculate maximum possible radii given centers.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist / 2)\n            \n            radii[i] = max(0, max_r)\n        return radii\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid.\"\"\"\n        # Check boundaries\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-9:\n                    return False\n        return True\n    \n    def energy(centers, radii):\n        \"\"\"Energy function (negative sum of radii for minimization).\"\"\"\n        if not is_valid(centers, radii):\n            return 1e10  # Large penalty for invalid configurations\n        return -np.sum(radii)\n    \n    # Calculate initial radii\n    radii = calculate_max_radii(centers)\n    current_energy = energy(centers, radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_energy = current_energy\n    \n    # Simulated annealing parameters\n    T_initial = 0.1\n    T_final = 1e-6\n    cooling_rate = 0.9995\n    iterations_per_temp = 100\n    \n    T = T_initial\n    iteration = 0\n    max_iterations = 50000\n    \n    while T > T_final and iteration < max_iterations:\n        for _ in range(iterations_per_temp):\n            iteration += 1\n            \n            # Perturbation: move a random circle\n            new_centers = centers.copy()\n            idx = np.random.randint(n)\n            \n            # Random move with adaptive step size\n            step_size = T * 0.2\n            new_centers[idx] += np.random.randn(2) * step_size\n            \n            # Clip to ensure within bounds (with margin for radius)\n            margin = 0.02\n            new_centers[idx] = np.clip(new_centers[idx], margin, 1 - margin)\n            \n            # Calculate new radii\n            new_radii = calculate_max_radii(new_centers)\n            new_energy = energy(new_centers, new_radii)\n            \n            # Metropolis criterion\n            delta_E = new_energy - current_energy\n            if delta_E < 0 or np.random.rand() < np.exp(-delta_E / T):\n                centers = new_centers\n                radii = new_radii\n                current_energy = new_energy\n                \n                if current_energy < best_energy:\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    best_energy = current_energy\n        \n        # Cool down\n        T *= cooling_rate\n    \n    # Final optimization: try to expand radii slightly\n    for _ in range(100):\n        for i in range(n):\n            old_radius = best_radii[i]\n            # Try to increase radius slightly\n            best_radii[i] *= 1.001\n            if not is_valid(best_centers, best_radii):\n                best_radii[i] = old_radius\n    \n    # Ensure validity\n    if not is_valid(best_centers, best_radii):\n        best_radii = calculate_max_radii(best_centers)\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.1666666666666665,
    "target_ratio": 0.8222643896268185,
    "combined_score": 0.8222643896268185,
    "eval_time": 54.51293110847473,
    "error": null
  },
  "prompt": "Write a simulated annealing circle packing for 26 circles in [0,1]x[0,1].\n\nUse simulated annealing optimization:\n- Initial solution: random or grid placement\n- Perturbation: move circles or adjust radii\n- Acceptance: Metropolis criterion with temperature schedule\n- Cool down gradually to find good solution\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use numpy\n- No printing/plotting",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using simulated annealing.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with grid-based placement\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = np.zeros((n, 2))\n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx >= n:\n                break\n            centers[idx] = [(i + 0.5) / grid_size, (j + 0.5) / grid_size]\n            idx += 1\n    \n    # Initialize radii - start with small uniform radii\n    radii = np.ones(n) * 0.05\n    \n    def calculate_max_radii(centers):\n        \"\"\"Calculate maximum possible radii given centers.\"\"\"\n        radii = np.zeros(n)\n        for i in range(n):\n            # Distance to boundaries\n            max_r = min(centers[i, 0], 1 - centers[i, 0], \n                       centers[i, 1], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist / 2)\n            \n            radii[i] = max(0, max_r)\n        return radii\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid.\"\"\"\n        # Check boundaries\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check overlaps\n        dists = cdist(centers, centers)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if dists[i, j] < radii[i] + radii[j] - 1e-9:\n                    return False\n        return True\n    \n    def energy(centers, radii):\n        \"\"\"Energy function (negative sum of radii for minimization).\"\"\"\n        if not is_valid(centers, radii):\n            return 1e10  # Large penalty for invalid configurations\n        return -np.sum(radii)\n    \n    # Calculate initial radii\n    radii = calculate_max_radii(centers)\n    current_energy = energy(centers, radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_energy = current_energy\n    \n    # Simulated annealing parameters\n    T_initial = 0.1\n    T_final = 1e-6\n    cooling_rate = 0.9995\n    iterations_per_temp = 100\n    \n    T = T_initial\n    iteration = 0\n    max_iterations = 50000\n    \n    while T > T_final and iteration < max_iterations:\n        for _ in range(iterations_per_temp):\n            iteration += 1\n            \n            # Perturbation: move a random circle\n            new_centers = centers.copy()\n            idx = np.random.randint(n)\n            \n            # Random move with adaptive step size\n            step_size = T * 0.2\n            new_centers[idx] += np.random.randn(2) * step_size\n            \n            # Clip to ensure within bounds (with margin for radius)\n            margin = 0.02\n            new_centers[idx] = np.clip(new_centers[idx], margin, 1 - margin)\n            \n            # Calculate new radii\n            new_radii = calculate_max_radii(new_centers)\n            new_energy = energy(new_centers, new_radii)\n            \n            # Metropolis criterion\n            delta_E = new_energy - current_energy\n            if delta_E < 0 or np.random.rand() < np.exp(-delta_E / T):\n                centers = new_centers\n                radii = new_radii\n                current_energy = new_energy\n                \n                if current_energy < best_energy:\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    best_energy = current_energy\n        \n        # Cool down\n        T *= cooling_rate\n    \n    # Final optimization: try to expand radii slightly\n    for _ in range(100):\n        for i in range(n):\n            old_radius = best_radii[i]\n            # Try to increase radius slightly\n            best_radii[i] *= 1.001\n            if not is_valid(best_centers, best_radii):\n                best_radii[i] = old_radius\n    \n    # Ensure validity\n    if not is_valid(best_centers, best_radii):\n        best_radii = calculate_max_radii(best_centers)\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:20:41.541745",
  "cost_data": null
}