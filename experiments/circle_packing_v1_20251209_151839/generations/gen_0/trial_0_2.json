{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Decision variables: [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n    # Total: 3*n variables\n    \n    def objective(vars):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n        radii = vars[2::3]  # Every third element starting from index 2\n        return -np.sum(radii)\n    \n    def create_constraints():\n        \"\"\"Create constraint functions for optimization\"\"\"\n        constraints = []\n        \n        # Boundary constraints: each circle must be inside [0,1] x [0,1]\n        for i in range(n):\n            x_idx = 3*i\n            y_idx = 3*i + 1\n            r_idx = 3*i + 2\n            \n            # x - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, xi=x_idx, ri=r_idx: vars[xi] - vars[ri]\n            })\n            # x + r <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, xi=x_idx, ri=r_idx: 1 - vars[xi] - vars[ri]\n            })\n            # y - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, yi=y_idx, ri=r_idx: vars[yi] - vars[ri]\n            })\n            # y + r <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, yi=y_idx, ri=r_idx: 1 - vars[yi] - vars[ri]\n            })\n        \n        # Non-overlap constraints: distance between centers > sum of radii\n        for i in range(n):\n            for j in range(i+1, n):\n                xi_idx = 3*i\n                yi_idx = 3*i + 1\n                ri_idx = 3*i + 2\n                xj_idx = 3*j\n                yj_idx = 3*j + 1\n                rj_idx = 3*j + 2\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda vars, xi=xi_idx, yi=yi_idx, ri=ri_idx, \n                                  xj=xj_idx, yj=yj_idx, rj=rj_idx:\n                        np.sqrt((vars[xi] - vars[xj])**2 + (vars[yi] - vars[yj])**2) \n                        - vars[ri] - vars[rj]\n                })\n        \n        return constraints\n    \n    # Initialize with a grid-based layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_radius = 0.5 / grid_size\n    \n    x0 = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        r = initial_radius * 0.8  # Slightly smaller to ensure feasibility\n        x0.extend([x, y, r])\n    \n    x0 = np.array(x0)\n    \n    # Bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x\n        bounds.append((0, 1))  # y\n        bounds.append((0, 0.5))  # r\n    \n    # Create constraints\n    constraints = create_constraints()\n    \n    # Optimize with multiple random restarts to find better solutions\n    best_result = None\n    best_sum = -np.inf\n    \n    # Try multiple initial configurations\n    for attempt in range(3):\n        if attempt == 0:\n            # Use grid initialization\n            x_init = x0.copy()\n        else:\n            # Random initialization with small radii\n            x_init = []\n            for i in range(n):\n                x = np.random.uniform(0.1, 0.9)\n                y = np.random.uniform(0.1, 0.9)\n                r = np.random.uniform(0.01, 0.05)\n                x_init.extend([x, y, r])\n            x_init = np.array(x_init)\n        \n        try:\n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.success or result.fun < best_sum:\n                current_sum = -result.fun\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result\n        except:\n            continue\n    \n    # If optimization failed, use grid layout with maximum feasible radii\n    if best_result is None:\n        centers = []\n        radii = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            r = 0.4 / grid_size\n            centers.append([x, y])\n            radii.append(r)\n        centers = np.array(centers)\n        radii = np.array(radii)\n        sum_radii = np.sum(radii)\n    else:\n        # Extract solution\n        solution = best_result.x\n        centers = []\n        radii = []\n        for i in range(n):\n            x = solution[3*i]\n            y = solution[3*i + 1]\n            r = solution[3*i + 2]\n            centers.append([x, y])\n            radii.append(r)\n        \n        centers = np.array(centers)\n        radii = np.array(radii)\n        sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5874902645487325,
    "target_ratio": 0.9819697398666918,
    "combined_score": 0.9819697398666918,
    "eval_time": 7.816488981246948,
    "error": null
  },
  "prompt": "Write an optimization-based circle packing using scipy.optimize for 26 circles in [0,1]x[0,1].\n\nUse scipy.optimize.minimize to optimize circle positions and radii simultaneously.\n- Decision variables: 26 centers (x,y) and 26 radii\n- Objective: maximize sum of radii (minimize negative sum)\n- Constraints: circles in bounds, no overlaps\n- Use SLSQP method with constraints\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Import scipy.optimize\n- Use proper constraint formulation",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Decision variables: [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n    # Total: 3*n variables\n    \n    def objective(vars):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n        radii = vars[2::3]  # Every third element starting from index 2\n        return -np.sum(radii)\n    \n    def create_constraints():\n        \"\"\"Create constraint functions for optimization\"\"\"\n        constraints = []\n        \n        # Boundary constraints: each circle must be inside [0,1] x [0,1]\n        for i in range(n):\n            x_idx = 3*i\n            y_idx = 3*i + 1\n            r_idx = 3*i + 2\n            \n            # x - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, xi=x_idx, ri=r_idx: vars[xi] - vars[ri]\n            })\n            # x + r <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, xi=x_idx, ri=r_idx: 1 - vars[xi] - vars[ri]\n            })\n            # y - r >= 0\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, yi=y_idx, ri=r_idx: vars[yi] - vars[ri]\n            })\n            # y + r <= 1\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda vars, yi=y_idx, ri=r_idx: 1 - vars[yi] - vars[ri]\n            })\n        \n        # Non-overlap constraints: distance between centers > sum of radii\n        for i in range(n):\n            for j in range(i+1, n):\n                xi_idx = 3*i\n                yi_idx = 3*i + 1\n                ri_idx = 3*i + 2\n                xj_idx = 3*j\n                yj_idx = 3*j + 1\n                rj_idx = 3*j + 2\n                \n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda vars, xi=xi_idx, yi=yi_idx, ri=ri_idx, \n                                  xj=xj_idx, yj=yj_idx, rj=rj_idx:\n                        np.sqrt((vars[xi] - vars[xj])**2 + (vars[yi] - vars[yj])**2) \n                        - vars[ri] - vars[rj]\n                })\n        \n        return constraints\n    \n    # Initialize with a grid-based layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_radius = 0.5 / grid_size\n    \n    x0 = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        r = initial_radius * 0.8  # Slightly smaller to ensure feasibility\n        x0.extend([x, y, r])\n    \n    x0 = np.array(x0)\n    \n    # Bounds: x, y in [0, 1], r in [0, 0.5]\n    bounds = []\n    for i in range(n):\n        bounds.append((0, 1))  # x\n        bounds.append((0, 1))  # y\n        bounds.append((0, 0.5))  # r\n    \n    # Create constraints\n    constraints = create_constraints()\n    \n    # Optimize with multiple random restarts to find better solutions\n    best_result = None\n    best_sum = -np.inf\n    \n    # Try multiple initial configurations\n    for attempt in range(3):\n        if attempt == 0:\n            # Use grid initialization\n            x_init = x0.copy()\n        else:\n            # Random initialization with small radii\n            x_init = []\n            for i in range(n):\n                x = np.random.uniform(0.1, 0.9)\n                y = np.random.uniform(0.1, 0.9)\n                r = np.random.uniform(0.01, 0.05)\n                x_init.extend([x, y, r])\n            x_init = np.array(x_init)\n        \n        try:\n            result = minimize(\n                objective,\n                x_init,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.success or result.fun < best_sum:\n                current_sum = -result.fun\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_result = result\n        except:\n            continue\n    \n    # If optimization failed, use grid layout with maximum feasible radii\n    if best_result is None:\n        centers = []\n        radii = []\n        for i in range(n):\n            row = i // grid_size\n            col = i % grid_size\n            x = (col + 0.5) / grid_size\n            y = (row + 0.5) / grid_size\n            r = 0.4 / grid_size\n            centers.append([x, y])\n            radii.append(r)\n        centers = np.array(centers)\n        radii = np.array(radii)\n        sum_radii = np.sum(radii)\n    else:\n        # Extract solution\n        solution = best_result.x\n        centers = []\n        radii = []\n        for i in range(n):\n            x = solution[3*i]\n            y = solution[3*i + 1]\n            r = solution[3*i + 2]\n            centers.append([x, y])\n            radii.append(r)\n        \n        centers = np.array(centers)\n        radii = np.array(radii)\n        sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:19:57.258981",
  "cost_data": null
}