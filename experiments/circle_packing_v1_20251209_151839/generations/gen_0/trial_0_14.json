{
  "trial_id": "trial_0_14",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using SQP.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initial guess: place circles in a grid with small radii\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    \n    initial_centers = np.array(initial_centers)\n    initial_radii = np.full(n, 0.05)  # Start with small radii\n    \n    # Pack initial guess into single vector\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    # Objective: minimize negative sum of radii (to maximize sum)\n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    # Gradient of objective\n    def objective_grad(x):\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0  # derivative w.r.t. radii\n        return grad\n    \n    # Constraints\n    constraints = []\n    \n    # 1. Non-overlap constraints: distance between centers > sum of radii\n    for i in range(n):\n        for j in range(i+1, n):\n            def overlap_constraint(x, i=i, j=j):\n                centers = x[:2*n].reshape(n, 2)\n                radii = x[2*n:]\n                dist = np.linalg.norm(centers[i] - centers[j])\n                return dist - radii[i] - radii[j]\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': overlap_constraint\n            })\n    \n    # 2. Circles inside square: center - radius >= 0 and center + radius <= 1\n    for i in range(n):\n        # x - r >= 0\n        def left_bound(x, i=i):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return centers[i, 0] - radii[i]\n        \n        # x + r <= 1\n        def right_bound(x, i=i):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return 1.0 - centers[i, 0] - radii[i]\n        \n        # y - r >= 0\n        def bottom_bound(x, i=i):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return centers[i, 1] - radii[i]\n        \n        # y + r <= 1\n        def top_bound(x, i=i):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return 1.0 - centers[i, 1] - radii[i]\n        \n        constraints.extend([\n            {'type': 'ineq', 'fun': left_bound},\n            {'type': 'ineq', 'fun': right_bound},\n            {'type': 'ineq', 'fun': bottom_bound},\n            {'type': 'ineq', 'fun': top_bound}\n        ])\n    \n    # Bounds: centers in [0,1], radii >= 0\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Run optimization with SLSQP\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        jac=objective_grad,\n        options={\n            'maxiter': 1000,\n            'ftol': 1e-9,\n            'disp': False\n        }\n    )\n    \n    # Extract solution\n    x_opt = result.x\n    centers = x_opt[:2*n].reshape(n, 2)\n    radii = x_opt[2*n:]\n    sum_radii = np.sum(radii)\n    \n    # Try multiple restarts with different initial configurations\n    best_sum = sum_radii\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    # Additional restart with random perturbation\n    for restart in range(3):\n        x0_perturbed = x0.copy()\n        x0_perturbed[:2*n] += np.random.uniform(-0.1, 0.1, 2*n)\n        x0_perturbed[:2*n] = np.clip(x0_perturbed[:2*n], 0.1, 0.9)\n        x0_perturbed[2*n:] = np.random.uniform(0.03, 0.08, n)\n        \n        result = minimize(\n            objective,\n            x0_perturbed,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            jac=objective_grad,\n            options={\n                'maxiter': 1000,\n                'ftol': 1e-9,\n                'disp': False\n            }\n        )\n        \n        if result.success or True:  # Accept even non-converged if better\n            x_opt = result.x\n            centers_new = x_opt[:2*n].reshape(n, 2)\n            radii_new = x_opt[2*n:]\n            sum_radii_new = np.sum(radii_new)\n            \n            if sum_radii_new > best_sum:\n                best_sum = sum_radii_new\n                best_centers = centers_new.copy()\n                best_radii = radii_new.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5918782364413353,
    "target_ratio": 0.9836350043420629,
    "combined_score": 0.9836350043420629,
    "eval_time": 7.834491968154907,
    "error": null
  },
  "prompt": "Write a sequential quadratic programming (SQP) circle packing for 26 circles in [0,1]x[0,1].\n\nUse advanced optimization with SQP:\n- Variables: 26 centers (x,y) and 26 radii (52+26=78 variables)\n- Maximize sum of radii\n- Nonlinear constraints: no overlaps, circles in bounds\n- Use scipy.optimize.minimize with method='SLSQP'\n- Start from reasonable initial guess (e.g., small grid)\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use scipy.optimize\n- No printing/plotting",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using SQP.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    # Initial guess: place circles in a grid with small radii\n    grid_size = int(np.ceil(np.sqrt(n)))\n    initial_centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    \n    initial_centers = np.array(initial_centers)\n    initial_radii = np.full(n, 0.05)  # Start with small radii\n    \n    # Pack initial guess into single vector\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    # Objective: minimize negative sum of radii (to maximize sum)\n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    # Gradient of objective\n    def objective_grad(x):\n        grad = np.zeros(3*n)\n        grad[2*n:] = -1.0  # derivative w.r.t. radii\n        return grad\n    \n    # Constraints\n    constraints = []\n    \n    # 1. Non-overlap constraints: distance between centers > sum of radii\n    for i in range(n):\n        for j in range(i+1, n):\n            def overlap_constraint(x, i=i, j=j):\n                centers = x[:2*n].reshape(n, 2)\n                radii = x[2*n:]\n                dist = np.linalg.norm(centers[i] - centers[j])\n                return dist - radii[i] - radii[j]\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': overlap_constraint\n            })\n    \n    # 2. Circles inside square: center - radius >= 0 and center + radius <= 1\n    for i in range(n):\n        # x - r >= 0\n        def left_bound(x, i=i):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return centers[i, 0] - radii[i]\n        \n        # x + r <= 1\n        def right_bound(x, i=i):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return 1.0 - centers[i, 0] - radii[i]\n        \n        # y - r >= 0\n        def bottom_bound(x, i=i):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return centers[i, 1] - radii[i]\n        \n        # y + r <= 1\n        def top_bound(x, i=i):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return 1.0 - centers[i, 1] - radii[i]\n        \n        constraints.extend([\n            {'type': 'ineq', 'fun': left_bound},\n            {'type': 'ineq', 'fun': right_bound},\n            {'type': 'ineq', 'fun': bottom_bound},\n            {'type': 'ineq', 'fun': top_bound}\n        ])\n    \n    # Bounds: centers in [0,1], radii >= 0\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Run optimization with SLSQP\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        jac=objective_grad,\n        options={\n            'maxiter': 1000,\n            'ftol': 1e-9,\n            'disp': False\n        }\n    )\n    \n    # Extract solution\n    x_opt = result.x\n    centers = x_opt[:2*n].reshape(n, 2)\n    radii = x_opt[2*n:]\n    sum_radii = np.sum(radii)\n    \n    # Try multiple restarts with different initial configurations\n    best_sum = sum_radii\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    \n    # Additional restart with random perturbation\n    for restart in range(3):\n        x0_perturbed = x0.copy()\n        x0_perturbed[:2*n] += np.random.uniform(-0.1, 0.1, 2*n)\n        x0_perturbed[:2*n] = np.clip(x0_perturbed[:2*n], 0.1, 0.9)\n        x0_perturbed[2*n:] = np.random.uniform(0.03, 0.08, n)\n        \n        result = minimize(\n            objective,\n            x0_perturbed,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            jac=objective_grad,\n            options={\n                'maxiter': 1000,\n                'ftol': 1e-9,\n                'disp': False\n            }\n        )\n        \n        if result.success or True:  # Accept even non-converged if better\n            x_opt = result.x\n            centers_new = x_opt[:2*n].reshape(n, 2)\n            radii_new = x_opt[2*n:]\n            sum_radii_new = np.sum(radii_new)\n            \n            if sum_radii_new > best_sum:\n                best_sum = sum_radii_new\n                best_centers = centers_new.copy()\n                best_radii = radii_new.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:19:55.710360",
  "cost_data": null
}