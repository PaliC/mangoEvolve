{
  "trial_id": "trial_2_3",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses two-phase optimization: fast exploration + deep refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def decode_params(params):\n        \"\"\"Decode flat parameter array into centers and radii.\"\"\"\n        centers = params[:2*n].reshape(n, 2)\n        radii = params[2*n:]\n        return centers, radii\n    \n    def encode_params(centers, radii):\n        \"\"\"Encode centers and radii into flat parameter array.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(params):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        _, radii = decode_params(params)\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        \"\"\"Compute all constraints. Positive values = satisfied.\"\"\"\n        centers, radii = decode_params(params)\n        constraints = []\n        \n        # Circles must be inside unit square\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlapping constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Non-negative radii\n        for i in range(n):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    def optimize_packing(initial_params, maxiter=150):\n        \"\"\"Run optimization from initial parameters.\"\"\"\n        constraints = {'type': 'ineq', 'fun': constraints_func}\n        \n        bounds = []\n        for i in range(n):\n            bounds.append((0, 1))  # x\n            bounds.append((0, 1))  # y\n        for i in range(n):\n            bounds.append((0, 0.5))  # radii\n        \n        result = minimize(\n            objective,\n            initial_params,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        return result\n    \n    def generate_grid_pattern(noise_level=0.01):\n        \"\"\"Generate grid-based initial configuration with noise.\"\"\"\n        rows = 5\n        cols = 6\n        centers = []\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (j + 0.5) / cols + np.random.uniform(-noise_level, noise_level)\n                y = (i + 0.5) / rows + np.random.uniform(-noise_level, noise_level)\n                centers.append([x, y])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        return encode_params(centers, radii)\n    \n    def generate_hexagonal_pattern():\n        \"\"\"Generate hexagonal packing pattern.\"\"\"\n        centers = []\n        rows = 6\n        cols = 5\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                offset = 0.5 if i % 2 == 1 else 0\n                x = (j + offset) / cols + 0.1\n                y = (i + 0.5) / rows\n                x = np.clip(x, 0.1, 0.9)\n                y = np.clip(y, 0.1, 0.9)\n                centers.append([x, y])\n        \n        # Add extra circles if needed\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.2, 0.8), \n                          np.random.uniform(0.2, 0.8)])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        return encode_params(centers, radii)\n    \n    def generate_boundary_focused():\n        \"\"\"Generate pattern with circles focused on boundaries.\"\"\"\n        centers = []\n        \n        # Place circles along edges\n        n_per_edge = 6\n        for i in range(n_per_edge):\n            t = (i + 1) / (n_per_edge + 1)\n            centers.append([t, 0.05])  # bottom\n            centers.append([t, 0.95])  # top\n            centers.append([0.05, t])  # left\n            centers.append([0.95, t])  # right\n        \n        # Fill center\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.3, 0.7), \n                          np.random.uniform(0.3, 0.7)])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.07)\n        return encode_params(centers, radii)\n    \n    print(\"Phase 1: Fast Exploration (60 starts)\")\n    \n    results = []\n    \n    # Grid patterns with noise (20 starts)\n    print(\"  Testing grid patterns...\")\n    for i in range(20):\n        noise = 0.01 + i * 0.002\n        initial = generate_grid_pattern(noise_level=noise)\n        result = optimize_packing(initial, maxiter=150)\n        if result.success or len(constraints_func(result.x)[constraints_func(result.x) < -1e-6]) == 0:\n            results.append((result.fun, result.x))\n    \n    # Hexagonal patterns (20 starts)\n    print(\"  Testing hexagonal patterns...\")\n    for i in range(20):\n        initial = generate_hexagonal_pattern()\n        # Add small random perturbation\n        initial[:2*n] += np.random.uniform(-0.02, 0.02, 2*n)\n        initial[:2*n] = np.clip(initial[:2*n], 0, 1)\n        result = optimize_packing(initial, maxiter=150)\n        if result.success or len(constraints_func(result.x)[constraints_func(result.x) < -1e-6]) == 0:\n            results.append((result.fun, result.x))\n    \n    # Boundary-focused (20 starts)\n    print(\"  Testing boundary-focused patterns...\")\n    for i in range(20):\n        initial = generate_boundary_focused()\n        initial[:2*n] += np.random.uniform(-0.02, 0.02, 2*n)\n        initial[:2*n] = np.clip(initial[:2*n], 0, 1)\n        result = optimize_packing(initial, maxiter=150)\n        if result.success or len(constraints_func(result.x)[constraints_func(result.x) < -1e-6]) == 0:\n            results.append((result.fun, result.x))\n    \n    # Sort and get top 3\n    results.sort(key=lambda x: x[0])\n    top_3 = results[:3]\n    \n    print(f\"  Phase 1 complete. Top 3 scores: {[-r[0] for r in top_3]}\")\n    \n    print(\"\\nPhase 2: Deep Refinement\")\n    \n    refined_results = []\n    \n    for idx, (score, params) in enumerate(top_3):\n        print(f\"  Refining candidate {idx+1}/3 (score: {-score:.4f})...\")\n        \n        # Deep optimization\n        result = optimize_packing(params, maxiter=800)\n        refined_results.append((result.fun, result.x))\n        \n        # Try small perturbations\n        for perturbation in range(3):\n            perturbed = result.x.copy()\n            perturbed[:2*n] += np.random.uniform(-0.005, 0.005, 2*n)\n            perturbed[:2*n] = np.clip(perturbed[:2*n], 0, 1)\n            \n            result2 = optimize_packing(perturbed, maxiter=400)\n            refined_results.append((result2.fun, result2.x))\n    \n    # Get best result\n    refined_results.sort(key=lambda x: x[0])\n    best_fun, best_params = refined_results[0]\n    \n    centers, radii = decode_params(best_params)\n    sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal result: sum of radii = {sum_radii:.6f}\")\n    \n    # Validate solution\n    cons = constraints_func(best_params)\n    violations = cons[cons < -1e-6]\n    if len(violations) > 0:\n        print(f\"Warning: {len(violations)} constraint violations detected\")\n        print(f\"Max violation: {np.min(cons):.6e}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.6180682560570405,
    "target_ratio": 0.9935742907237346,
    "combined_score": 0.9935742907237346,
    "eval_time": 61.59623098373413,
    "error": null
  },
  "prompt": "Create a two-phase optimization: fast exploration + refinement.\n\nPhase 1 - Fast Exploration (60 starts):\n- Grid patterns with noise (20 starts)\n- Hexagonal patterns (20 starts)\n- Boundary-focused (20 starts)\n- Each with maxiter=150 for speed\n- Track top 3 results\n\nPhase 2 - Deep Refinement:\n- Take top 3 from phase 1\n- Run intensive optimization with maxiter=800\n- Add local search refinement\n- Try small perturbations and re-optimize\n\nUse scipy.optimize.minimize with SLSQP.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses two-phase optimization: fast exploration + deep refinement.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    \n    def decode_params(params):\n        \"\"\"Decode flat parameter array into centers and radii.\"\"\"\n        centers = params[:2*n].reshape(n, 2)\n        radii = params[2*n:]\n        return centers, radii\n    \n    def encode_params(centers, radii):\n        \"\"\"Encode centers and radii into flat parameter array.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(params):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        _, radii = decode_params(params)\n        return -np.sum(radii)\n    \n    def constraints_func(params):\n        \"\"\"Compute all constraints. Positive values = satisfied.\"\"\"\n        centers, radii = decode_params(params)\n        constraints = []\n        \n        # Circles must be inside unit square\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlapping constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Non-negative radii\n        for i in range(n):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    def optimize_packing(initial_params, maxiter=150):\n        \"\"\"Run optimization from initial parameters.\"\"\"\n        constraints = {'type': 'ineq', 'fun': constraints_func}\n        \n        bounds = []\n        for i in range(n):\n            bounds.append((0, 1))  # x\n            bounds.append((0, 1))  # y\n        for i in range(n):\n            bounds.append((0, 0.5))  # radii\n        \n        result = minimize(\n            objective,\n            initial_params,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': maxiter, 'ftol': 1e-9}\n        )\n        \n        return result\n    \n    def generate_grid_pattern(noise_level=0.01):\n        \"\"\"Generate grid-based initial configuration with noise.\"\"\"\n        rows = 5\n        cols = 6\n        centers = []\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                x = (j + 0.5) / cols + np.random.uniform(-noise_level, noise_level)\n                y = (i + 0.5) / rows + np.random.uniform(-noise_level, noise_level)\n                centers.append([x, y])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        return encode_params(centers, radii)\n    \n    def generate_hexagonal_pattern():\n        \"\"\"Generate hexagonal packing pattern.\"\"\"\n        centers = []\n        rows = 6\n        cols = 5\n        \n        for i in range(rows):\n            for j in range(cols):\n                if len(centers) >= n:\n                    break\n                offset = 0.5 if i % 2 == 1 else 0\n                x = (j + offset) / cols + 0.1\n                y = (i + 0.5) / rows\n                x = np.clip(x, 0.1, 0.9)\n                y = np.clip(y, 0.1, 0.9)\n                centers.append([x, y])\n        \n        # Add extra circles if needed\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.2, 0.8), \n                          np.random.uniform(0.2, 0.8)])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.08)\n        return encode_params(centers, radii)\n    \n    def generate_boundary_focused():\n        \"\"\"Generate pattern with circles focused on boundaries.\"\"\"\n        centers = []\n        \n        # Place circles along edges\n        n_per_edge = 6\n        for i in range(n_per_edge):\n            t = (i + 1) / (n_per_edge + 1)\n            centers.append([t, 0.05])  # bottom\n            centers.append([t, 0.95])  # top\n            centers.append([0.05, t])  # left\n            centers.append([0.95, t])  # right\n        \n        # Fill center\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.3, 0.7), \n                          np.random.uniform(0.3, 0.7)])\n        \n        centers = np.array(centers[:n])\n        radii = np.full(n, 0.07)\n        return encode_params(centers, radii)\n    \n    print(\"Phase 1: Fast Exploration (60 starts)\")\n    \n    results = []\n    \n    # Grid patterns with noise (20 starts)\n    print(\"  Testing grid patterns...\")\n    for i in range(20):\n        noise = 0.01 + i * 0.002\n        initial = generate_grid_pattern(noise_level=noise)\n        result = optimize_packing(initial, maxiter=150)\n        if result.success or len(constraints_func(result.x)[constraints_func(result.x) < -1e-6]) == 0:\n            results.append((result.fun, result.x))\n    \n    # Hexagonal patterns (20 starts)\n    print(\"  Testing hexagonal patterns...\")\n    for i in range(20):\n        initial = generate_hexagonal_pattern()\n        # Add small random perturbation\n        initial[:2*n] += np.random.uniform(-0.02, 0.02, 2*n)\n        initial[:2*n] = np.clip(initial[:2*n], 0, 1)\n        result = optimize_packing(initial, maxiter=150)\n        if result.success or len(constraints_func(result.x)[constraints_func(result.x) < -1e-6]) == 0:\n            results.append((result.fun, result.x))\n    \n    # Boundary-focused (20 starts)\n    print(\"  Testing boundary-focused patterns...\")\n    for i in range(20):\n        initial = generate_boundary_focused()\n        initial[:2*n] += np.random.uniform(-0.02, 0.02, 2*n)\n        initial[:2*n] = np.clip(initial[:2*n], 0, 1)\n        result = optimize_packing(initial, maxiter=150)\n        if result.success or len(constraints_func(result.x)[constraints_func(result.x) < -1e-6]) == 0:\n            results.append((result.fun, result.x))\n    \n    # Sort and get top 3\n    results.sort(key=lambda x: x[0])\n    top_3 = results[:3]\n    \n    print(f\"  Phase 1 complete. Top 3 scores: {[-r[0] for r in top_3]}\")\n    \n    print(\"\\nPhase 2: Deep Refinement\")\n    \n    refined_results = []\n    \n    for idx, (score, params) in enumerate(top_3):\n        print(f\"  Refining candidate {idx+1}/3 (score: {-score:.4f})...\")\n        \n        # Deep optimization\n        result = optimize_packing(params, maxiter=800)\n        refined_results.append((result.fun, result.x))\n        \n        # Try small perturbations\n        for perturbation in range(3):\n            perturbed = result.x.copy()\n            perturbed[:2*n] += np.random.uniform(-0.005, 0.005, 2*n)\n            perturbed[:2*n] = np.clip(perturbed[:2*n], 0, 1)\n            \n            result2 = optimize_packing(perturbed, maxiter=400)\n            refined_results.append((result2.fun, result2.x))\n    \n    # Get best result\n    refined_results.sort(key=lambda x: x[0])\n    best_fun, best_params = refined_results[0]\n    \n    centers, radii = decode_params(best_params)\n    sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal result: sum of radii = {sum_radii:.6f}\")\n    \n    # Validate solution\n    cons = constraints_func(best_params)\n    violations = cons[cons < -1e-6]\n    if len(violations) > 0:\n        print(f\"Warning: {len(violations)} constraint violations detected\")\n        print(f\"Max violation: {np.min(cons):.6e}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:35:25.048451",
  "cost_data": null
}