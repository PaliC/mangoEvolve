{
  "trial_id": "trial_2_12",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    temperature-based multi-start optimization.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def generate_initialization(temp_level):\n        \"\"\"Generate initialization based on temperature level (0-49)\"\"\"\n        if temp_level < 20:  # Low temperature: tight grid\n            # Create a grid pattern\n            grid_size = int(np.ceil(np.sqrt(n)))\n            positions = []\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(positions) < n:\n                        x = 0.1 + 0.8 * i / (grid_size - 1)\n                        y = 0.1 + 0.8 * j / (grid_size - 1)\n                        # Small noise based on temperature\n                        noise_scale = 0.01 + 0.02 * (temp_level / 20)\n                        x += np.random.randn() * noise_scale\n                        y += np.random.randn() * noise_scale\n                        positions.append([x, y])\n            centers = np.array(positions[:n])\n            # Start with small uniform radii\n            radii = np.full(n, 0.05 + 0.01 * temp_level / 20)\n            \n        elif temp_level < 35:  # Medium temperature: hexagonal pattern\n            # Hexagonal packing with perturbations\n            positions = []\n            rows = 5\n            cols = 6\n            for row in range(rows):\n                for col in range(cols):\n                    if len(positions) < n:\n                        x = 0.15 + 0.7 * col / (cols - 1)\n                        y = 0.15 + 0.7 * row / (rows - 1)\n                        # Offset every other row for hexagonal pattern\n                        if row % 2 == 1:\n                            x += 0.35 / (cols - 1)\n                        # Moderate perturbations\n                        noise_scale = 0.03 + 0.04 * ((temp_level - 20) / 15)\n                        x += np.random.randn() * noise_scale\n                        y += np.random.randn() * noise_scale\n                        positions.append([x, y])\n            centers = np.array(positions[:n])\n            radii = np.full(n, 0.06 + 0.02 * (temp_level - 20) / 15)\n            \n        else:  # High temperature: random exploratory\n            # More random initialization\n            centers = np.random.uniform(0.15, 0.85, (n, 2))\n            radii = np.random.uniform(0.04, 0.09, n)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraint_inside_square(x):\n        \"\"\"All circles must be inside [0,1]x[0,1]\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        \"\"\"No two circles should overlap\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_positive_radii(x):\n        \"\"\"All radii must be non-negative\"\"\"\n        radii = x[2*n:]\n        return radii\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside_square},\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_positive_radii}\n    ]\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Phase 1: Multi-start with 50 initializations\n    print(\"Phase 1: Multi-start optimization with 50 initializations...\")\n    results = []\n    \n    for temp in range(50):\n        x0 = generate_initialization(temp)\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 200, 'ftol': 1e-6}\n            )\n            \n            if result.success:\n                # Verify constraints\n                centers = result.x[:2*n].reshape(n, 2)\n                radii = result.x[2*n:]\n                \n                # Check validity\n                valid = True\n                if np.any(radii < 0):\n                    valid = False\n                if np.any(centers - radii[:, None] < -1e-6) or np.any(centers + radii[:, None] > 1 + 1e-6):\n                    valid = False\n                \n                # Check overlaps\n                dists = squareform(pdist(centers))\n                for i in range(n):\n                    for j in range(i+1, n):\n                        if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                            valid = False\n                            break\n                \n                if valid:\n                    results.append((np.sum(radii), result.x))\n                    print(f\"  Init {temp}: sum_radii = {np.sum(radii):.6f}\")\n        except:\n            pass\n    \n    # Sort and select top 8\n    results.sort(reverse=True, key=lambda x: x[0])\n    top_results = results[:min(8, len(results))]\n    \n    print(f\"\\nPhase 2: Refining top {len(top_results)} results...\")\n    refined_results = []\n    \n    for idx, (sum_r, x0) in enumerate(top_results):\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 500, 'ftol': 1e-8}\n            )\n            \n            if result.success:\n                centers = result.x[:2*n].reshape(n, 2)\n                radii = result.x[2*n:]\n                \n                # Verify\n                valid = True\n                if np.any(radii < 0):\n                    valid = False\n                if np.any(centers - radii[:, None] < -1e-6) or np.any(centers + radii[:, None] > 1 + 1e-6):\n                    valid = False\n                \n                dists = squareform(pdist(centers))\n                for i in range(n):\n                    for j in range(i+1, n):\n                        if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                            valid = False\n                            break\n                \n                if valid:\n                    refined_results.append((np.sum(radii), result.x))\n                    print(f\"  Refined {idx}: sum_radii = {np.sum(radii):.6f}\")\n        except:\n            pass\n    \n    # Select best result\n    if refined_results:\n        refined_results.sort(reverse=True, key=lambda x: x[0])\n        best_sum, best_x = refined_results[0]\n    else:\n        # Fallback to original top result\n        best_sum, best_x = top_results[0]\n    \n    print(f\"\\nPhase 3: Final local search on best solution...\")\n    # Final refinement with tight tolerances\n    try:\n        final_result = minimize(\n            objective,\n            best_x,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if final_result.success:\n            centers = final_result.x[:2*n].reshape(n, 2)\n            radii = final_result.x[2*n:]\n            \n            # Verify\n            valid = True\n            if np.any(radii < 0):\n                valid = False\n            if np.any(centers - radii[:, None] < -1e-6) or np.any(centers + radii[:, None] > 1 + 1e-6):\n                valid = False\n            \n            dists = squareform(pdist(centers))\n            for i in range(n):\n                for j in range(i+1, n):\n                    if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                        valid = False\n                        break\n            \n            if valid and np.sum(radii) > best_sum:\n                best_x = final_result.x\n                best_sum = np.sum(radii)\n                print(f\"  Final: sum_radii = {best_sum:.6f}\")\n    except:\n        pass\n    \n    # Extract final solution\n    centers = best_x[:2*n].reshape(n, 2)\n    radii = best_x[2*n:]\n    sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal solution: sum_radii = {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.613014222319754,
    "target_ratio": 0.9916562513547454,
    "combined_score": 0.9916562513547454,
    "eval_time": 44.37609100341797,
    "error": null
  },
  "prompt": "Create a temperature-based multi-start optimization.\n\nStrategy:\n1. Generate 50 initializations with varying \"temperature\":\n   - Low temp (0-20): tight grid patterns with small noise\n   - Medium temp (20-35): hexagonal with moderate perturbations\n   - High temp (35-50): more random, exploratory patterns\n2. Optimize each with maxiter=200\n3. Select top 8 results\n4. Run refinement with maxiter=500\n5. Add final local search on best\n\nUse scipy.optimize.minimize with SLSQP.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using\n    temperature-based multi-start optimization.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    def generate_initialization(temp_level):\n        \"\"\"Generate initialization based on temperature level (0-49)\"\"\"\n        if temp_level < 20:  # Low temperature: tight grid\n            # Create a grid pattern\n            grid_size = int(np.ceil(np.sqrt(n)))\n            positions = []\n            for i in range(grid_size):\n                for j in range(grid_size):\n                    if len(positions) < n:\n                        x = 0.1 + 0.8 * i / (grid_size - 1)\n                        y = 0.1 + 0.8 * j / (grid_size - 1)\n                        # Small noise based on temperature\n                        noise_scale = 0.01 + 0.02 * (temp_level / 20)\n                        x += np.random.randn() * noise_scale\n                        y += np.random.randn() * noise_scale\n                        positions.append([x, y])\n            centers = np.array(positions[:n])\n            # Start with small uniform radii\n            radii = np.full(n, 0.05 + 0.01 * temp_level / 20)\n            \n        elif temp_level < 35:  # Medium temperature: hexagonal pattern\n            # Hexagonal packing with perturbations\n            positions = []\n            rows = 5\n            cols = 6\n            for row in range(rows):\n                for col in range(cols):\n                    if len(positions) < n:\n                        x = 0.15 + 0.7 * col / (cols - 1)\n                        y = 0.15 + 0.7 * row / (rows - 1)\n                        # Offset every other row for hexagonal pattern\n                        if row % 2 == 1:\n                            x += 0.35 / (cols - 1)\n                        # Moderate perturbations\n                        noise_scale = 0.03 + 0.04 * ((temp_level - 20) / 15)\n                        x += np.random.randn() * noise_scale\n                        y += np.random.randn() * noise_scale\n                        positions.append([x, y])\n            centers = np.array(positions[:n])\n            radii = np.full(n, 0.06 + 0.02 * (temp_level - 20) / 15)\n            \n        else:  # High temperature: random exploratory\n            # More random initialization\n            centers = np.random.uniform(0.15, 0.85, (n, 2))\n            radii = np.random.uniform(0.04, 0.09, n)\n        \n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii\"\"\"\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraint_inside_square(x):\n        \"\"\"All circles must be inside [0,1]x[0,1]\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        \"\"\"No two circles should overlap\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    def constraint_positive_radii(x):\n        \"\"\"All radii must be non-negative\"\"\"\n        radii = x[2*n:]\n        return radii\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside_square},\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_positive_radii}\n    ]\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Phase 1: Multi-start with 50 initializations\n    print(\"Phase 1: Multi-start optimization with 50 initializations...\")\n    results = []\n    \n    for temp in range(50):\n        x0 = generate_initialization(temp)\n        \n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 200, 'ftol': 1e-6}\n            )\n            \n            if result.success:\n                # Verify constraints\n                centers = result.x[:2*n].reshape(n, 2)\n                radii = result.x[2*n:]\n                \n                # Check validity\n                valid = True\n                if np.any(radii < 0):\n                    valid = False\n                if np.any(centers - radii[:, None] < -1e-6) or np.any(centers + radii[:, None] > 1 + 1e-6):\n                    valid = False\n                \n                # Check overlaps\n                dists = squareform(pdist(centers))\n                for i in range(n):\n                    for j in range(i+1, n):\n                        if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                            valid = False\n                            break\n                \n                if valid:\n                    results.append((np.sum(radii), result.x))\n                    print(f\"  Init {temp}: sum_radii = {np.sum(radii):.6f}\")\n        except:\n            pass\n    \n    # Sort and select top 8\n    results.sort(reverse=True, key=lambda x: x[0])\n    top_results = results[:min(8, len(results))]\n    \n    print(f\"\\nPhase 2: Refining top {len(top_results)} results...\")\n    refined_results = []\n    \n    for idx, (sum_r, x0) in enumerate(top_results):\n        try:\n            result = minimize(\n                objective,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 500, 'ftol': 1e-8}\n            )\n            \n            if result.success:\n                centers = result.x[:2*n].reshape(n, 2)\n                radii = result.x[2*n:]\n                \n                # Verify\n                valid = True\n                if np.any(radii < 0):\n                    valid = False\n                if np.any(centers - radii[:, None] < -1e-6) or np.any(centers + radii[:, None] > 1 + 1e-6):\n                    valid = False\n                \n                dists = squareform(pdist(centers))\n                for i in range(n):\n                    for j in range(i+1, n):\n                        if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                            valid = False\n                            break\n                \n                if valid:\n                    refined_results.append((np.sum(radii), result.x))\n                    print(f\"  Refined {idx}: sum_radii = {np.sum(radii):.6f}\")\n        except:\n            pass\n    \n    # Select best result\n    if refined_results:\n        refined_results.sort(reverse=True, key=lambda x: x[0])\n        best_sum, best_x = refined_results[0]\n    else:\n        # Fallback to original top result\n        best_sum, best_x = top_results[0]\n    \n    print(f\"\\nPhase 3: Final local search on best solution...\")\n    # Final refinement with tight tolerances\n    try:\n        final_result = minimize(\n            objective,\n            best_x,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if final_result.success:\n            centers = final_result.x[:2*n].reshape(n, 2)\n            radii = final_result.x[2*n:]\n            \n            # Verify\n            valid = True\n            if np.any(radii < 0):\n                valid = False\n            if np.any(centers - radii[:, None] < -1e-6) or np.any(centers + radii[:, None] > 1 + 1e-6):\n                valid = False\n            \n            dists = squareform(pdist(centers))\n            for i in range(n):\n                for j in range(i+1, n):\n                    if dists[i, j] < radii[i] + radii[j] - 1e-6:\n                        valid = False\n                        break\n            \n            if valid and np.sum(radii) > best_sum:\n                best_x = final_result.x\n                best_sum = np.sum(radii)\n                print(f\"  Final: sum_radii = {best_sum:.6f}\")\n    except:\n        pass\n    \n    # Extract final solution\n    centers = best_x[:2*n].reshape(n, 2)\n    radii = best_x[2*n:]\n    sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal solution: sum_radii = {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:35:07.948387",
  "cost_data": null
}