{
  "trial_id": "trial_2_8",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef poisson_disk_sampling(n, seed, min_dist=0.1):\n    \"\"\"Generate well-spaced points using Poisson disk sampling.\"\"\"\n    np.random.seed(seed)\n    points = []\n    max_attempts = 30\n    \n    # Start with a random point\n    points.append(np.random.rand(2))\n    \n    while len(points) < n:\n        # Generate candidate point\n        best_candidate = None\n        best_min_dist = 0\n        \n        for _ in range(max_attempts):\n            candidate = np.random.rand(2)\n            \n            # Check distance to all existing points\n            if len(points) > 0:\n                dists = np.sqrt(np.sum((np.array(points) - candidate)**2, axis=1))\n                min_dist_to_existing = np.min(dists)\n                \n                if min_dist_to_existing > best_min_dist:\n                    best_min_dist = min_dist_to_existing\n                    best_candidate = candidate\n        \n        if best_candidate is not None:\n            points.append(best_candidate)\n        else:\n            # If we can't find a good point, add a random one\n            points.append(np.random.rand(2))\n    \n    return np.array(points)\n\ndef compute_initial_radii(centers):\n    \"\"\"Compute initial radii based on distance to nearest neighbor and boundaries.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to nearest neighbor\n        dists = cdist([centers[i]], centers)[0]\n        dists[i] = np.inf  # Exclude self\n        min_neighbor_dist = np.min(dists)\n        \n        # Distance to boundaries\n        x, y = centers[i]\n        dist_to_boundary = min(x, 1-x, y, 1-y)\n        \n        # Radius is limited by both\n        radii[i] = min(min_neighbor_dist / 2.5, dist_to_boundary * 0.95)\n    \n    return radii\n\ndef check_constraints(centers, radii):\n    \"\"\"Check if all constraints are satisfied.\"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\ndef optimize_packing(centers_init, radii_init, maxiter=300):\n    \"\"\"Optimize circle packing using SLSQP.\"\"\"\n    n = len(centers_init)\n    \n    # Flatten initial guess\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)  # Minimize negative sum = maximize sum\n    \n    def constraint_boundary(x, i, coord, sign):\n        \"\"\"Boundary constraint: sign*(center[coord] - radius) >= 0 or <= 1\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        if sign > 0:\n            return centers[i, coord] - radii[i]  # >= 0\n        else:\n            return 1 - centers[i, coord] - radii[i]  # >= 0\n    \n    def constraint_overlap(x, i, j):\n        \"\"\"Overlap constraint: distance >= sum of radii\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n        return dist - radii[i] - radii[j]\n    \n    # Build constraints\n    constraints = []\n    \n    # Boundary constraints\n    for i in range(n):\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: constraint_boundary(x, i, 0, 1)})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: constraint_boundary(x, i, 0, -1)})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: constraint_boundary(x, i, 1, 1)})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: constraint_boundary(x, i, 1, -1)})\n    \n    # Overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i, j=j: constraint_overlap(x, i, j)})\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': maxiter, 'ftol': 1e-9}\n    )\n    \n    centers = result.x[:2*n].reshape(n, 2)\n    radii = result.x[2*n:]\n    \n    return centers, radii, -result.fun\n\ndef expand_radii(centers, radii, expansion_rate=1.001, max_iterations=1000):\n    \"\"\"Iteratively expand radii while maintaining constraints.\"\"\"\n    n = len(centers)\n    improved = True\n    iteration = 0\n    \n    while improved and iteration < max_iterations:\n        improved = False\n        iteration += 1\n        \n        for i in range(n):\n            # Try to expand this circle\n            new_radius = radii[i] * expansion_rate\n            \n            # Check boundary constraints\n            x, y = centers[i]\n            if x - new_radius < 0 or x + new_radius > 1 or y - new_radius < 0 or y + new_radius > 1:\n                continue\n            \n            # Check overlap constraints\n            valid = True\n            for j in range(n):\n                if i == j:\n                    continue\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                if dist < new_radius + radii[j] - 1e-9:\n                    valid = False\n                    break\n            \n            if valid:\n                radii[i] = new_radius\n                improved = True\n    \n    return radii\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple random seeds\n    candidates = []\n    \n    print(\"Phase 1: Initial optimization with 25 seeds...\")\n    for seed in range(25):\n        # Initialize with Poisson disk sampling\n        centers_init = poisson_disk_sampling(n, seed)\n        radii_init = compute_initial_radii(centers_init)\n        \n        # Optimize\n        centers, radii, sum_radii = optimize_packing(centers_init, radii_init, maxiter=300)\n        \n        # Verify constraints\n        if check_constraints(centers, radii):\n            candidates.append((sum_radii, centers, radii, seed))\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                print(f\"  Seed {seed}: sum_radii = {sum_radii:.6f}\")\n    \n    # Sort candidates and refine top 5\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    \n    print(f\"\\nPhase 2: Refining top 5 candidates...\")\n    for i, (sum_radii, centers, radii, seed) in enumerate(candidates[:5]):\n        print(f\"  Refining candidate {i+1} (seed {seed}, initial sum = {sum_radii:.6f})...\")\n        \n        # Refinement optimization\n        centers_refined, radii_refined, sum_refined = optimize_packing(\n            centers, radii, maxiter=500\n        )\n        \n        if check_constraints(centers_refined, radii_refined):\n            # Expand radii\n            radii_expanded = expand_radii(centers_refined, radii_refined.copy())\n            sum_expanded = np.sum(radii_expanded)\n            \n            if sum_expanded > best_sum:\n                best_sum = sum_expanded\n                best_centers = centers_refined.copy()\n                best_radii = radii_expanded.copy()\n                print(f\"    New best: {sum_expanded:.6f}\")\n    \n    print(f\"\\nFinal sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.612926556270959,
    "target_ratio": 0.9916229815070053,
    "combined_score": 0.9916229815070053,
    "eval_time": 99.09056615829468,
    "error": null
  },
  "prompt": "Create a constraint-aware initialization approach.\n\nStrategy:\n1. Initialize circles with maximum spacing (Poisson disk sampling)\n2. Compute initial radii as half of minimum distance to neighbors\n3. Run optimization to adjust positions (maxiter=300)\n4. Try 25 different random seeds for Poisson sampling\n5. For top 5, run refinement (maxiter=500)\n6. Add iterative radius expansion at the end\n\nUse scipy.optimize.minimize with SLSQP.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef poisson_disk_sampling(n, seed, min_dist=0.1):\n    \"\"\"Generate well-spaced points using Poisson disk sampling.\"\"\"\n    np.random.seed(seed)\n    points = []\n    max_attempts = 30\n    \n    # Start with a random point\n    points.append(np.random.rand(2))\n    \n    while len(points) < n:\n        # Generate candidate point\n        best_candidate = None\n        best_min_dist = 0\n        \n        for _ in range(max_attempts):\n            candidate = np.random.rand(2)\n            \n            # Check distance to all existing points\n            if len(points) > 0:\n                dists = np.sqrt(np.sum((np.array(points) - candidate)**2, axis=1))\n                min_dist_to_existing = np.min(dists)\n                \n                if min_dist_to_existing > best_min_dist:\n                    best_min_dist = min_dist_to_existing\n                    best_candidate = candidate\n        \n        if best_candidate is not None:\n            points.append(best_candidate)\n        else:\n            # If we can't find a good point, add a random one\n            points.append(np.random.rand(2))\n    \n    return np.array(points)\n\ndef compute_initial_radii(centers):\n    \"\"\"Compute initial radii based on distance to nearest neighbor and boundaries.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to nearest neighbor\n        dists = cdist([centers[i]], centers)[0]\n        dists[i] = np.inf  # Exclude self\n        min_neighbor_dist = np.min(dists)\n        \n        # Distance to boundaries\n        x, y = centers[i]\n        dist_to_boundary = min(x, 1-x, y, 1-y)\n        \n        # Radius is limited by both\n        radii[i] = min(min_neighbor_dist / 2.5, dist_to_boundary * 0.95)\n    \n    return radii\n\ndef check_constraints(centers, radii):\n    \"\"\"Check if all constraints are satisfied.\"\"\"\n    n = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\ndef optimize_packing(centers_init, radii_init, maxiter=300):\n    \"\"\"Optimize circle packing using SLSQP.\"\"\"\n    n = len(centers_init)\n    \n    # Flatten initial guess\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)  # Minimize negative sum = maximize sum\n    \n    def constraint_boundary(x, i, coord, sign):\n        \"\"\"Boundary constraint: sign*(center[coord] - radius) >= 0 or <= 1\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        if sign > 0:\n            return centers[i, coord] - radii[i]  # >= 0\n        else:\n            return 1 - centers[i, coord] - radii[i]  # >= 0\n    \n    def constraint_overlap(x, i, j):\n        \"\"\"Overlap constraint: distance >= sum of radii\"\"\"\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n        return dist - radii[i] - radii[j]\n    \n    # Build constraints\n    constraints = []\n    \n    # Boundary constraints\n    for i in range(n):\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: constraint_boundary(x, i, 0, 1)})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: constraint_boundary(x, i, 0, -1)})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: constraint_boundary(x, i, 1, 1)})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: constraint_boundary(x, i, 1, -1)})\n    \n    # Overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            constraints.append({'type': 'ineq', 'fun': lambda x, i=i, j=j: constraint_overlap(x, i, j)})\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': maxiter, 'ftol': 1e-9}\n    )\n    \n    centers = result.x[:2*n].reshape(n, 2)\n    radii = result.x[2*n:]\n    \n    return centers, radii, -result.fun\n\ndef expand_radii(centers, radii, expansion_rate=1.001, max_iterations=1000):\n    \"\"\"Iteratively expand radii while maintaining constraints.\"\"\"\n    n = len(centers)\n    improved = True\n    iteration = 0\n    \n    while improved and iteration < max_iterations:\n        improved = False\n        iteration += 1\n        \n        for i in range(n):\n            # Try to expand this circle\n            new_radius = radii[i] * expansion_rate\n            \n            # Check boundary constraints\n            x, y = centers[i]\n            if x - new_radius < 0 or x + new_radius > 1 or y - new_radius < 0 or y + new_radius > 1:\n                continue\n            \n            # Check overlap constraints\n            valid = True\n            for j in range(n):\n                if i == j:\n                    continue\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                if dist < new_radius + radii[j] - 1e-9:\n                    valid = False\n                    break\n            \n            if valid:\n                radii[i] = new_radius\n                improved = True\n    \n    return radii\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n\n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple random seeds\n    candidates = []\n    \n    print(\"Phase 1: Initial optimization with 25 seeds...\")\n    for seed in range(25):\n        # Initialize with Poisson disk sampling\n        centers_init = poisson_disk_sampling(n, seed)\n        radii_init = compute_initial_radii(centers_init)\n        \n        # Optimize\n        centers, radii, sum_radii = optimize_packing(centers_init, radii_init, maxiter=300)\n        \n        # Verify constraints\n        if check_constraints(centers, radii):\n            candidates.append((sum_radii, centers, radii, seed))\n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                print(f\"  Seed {seed}: sum_radii = {sum_radii:.6f}\")\n    \n    # Sort candidates and refine top 5\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    \n    print(f\"\\nPhase 2: Refining top 5 candidates...\")\n    for i, (sum_radii, centers, radii, seed) in enumerate(candidates[:5]):\n        print(f\"  Refining candidate {i+1} (seed {seed}, initial sum = {sum_radii:.6f})...\")\n        \n        # Refinement optimization\n        centers_refined, radii_refined, sum_refined = optimize_packing(\n            centers, radii, maxiter=500\n        )\n        \n        if check_constraints(centers_refined, radii_refined):\n            # Expand radii\n            radii_expanded = expand_radii(centers_refined, radii_refined.copy())\n            sum_expanded = np.sum(radii_expanded)\n            \n            if sum_expanded > best_sum:\n                best_sum = sum_expanded\n                best_centers = centers_refined.copy()\n                best_radii = radii_expanded.copy()\n                print(f\"    New best: {sum_expanded:.6f}\")\n    \n    print(f\"\\nFinal sum of radii: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:36:02.374880",
  "cost_data": null
}