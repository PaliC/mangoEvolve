{
  "trial_id": "trial_2_6",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses boundary-optimized approach with multiple configurations.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Try different boundary/interior splits\n    configs = [(12, 14), (14, 12), (16, 10), (13, 13), (15, 11)]\n    \n    for config_idx, (n_boundary, n_interior) in enumerate(configs):\n        for trial in range(4):  # Multiple trials per config\n            \n            # Initialize boundary circles\n            boundary_centers = initialize_boundary_circles(n_boundary, trial)\n            \n            # Initialize interior circles\n            interior_centers = initialize_interior_circles(n_interior, trial)\n            \n            # Combine\n            centers = np.vstack([boundary_centers, interior_centers])\n            \n            # Optimize\n            result = optimize_packing(centers, n_boundary)\n            \n            if result['sum_radii'] > best_sum:\n                best_sum = result['sum_radii']\n                best_solution = result\n    \n    return best_solution['centers'], best_solution['radii'], best_solution['sum_radii']\n\ndef initialize_boundary_circles(n_boundary, seed):\n    \"\"\"Initialize circles along the boundary of the unit square.\"\"\"\n    np.random.seed(seed * 100)\n    centers = []\n    \n    # Distribute along edges\n    n_per_edge = n_boundary // 4\n    remainder = n_boundary % 4\n    \n    edges = [n_per_edge] * 4\n    for i in range(remainder):\n        edges[i] += 1\n    \n    # Bottom edge\n    for i in range(edges[0]):\n        x = (i + 1) / (edges[0] + 1)\n        y = 0.05 + np.random.rand() * 0.05\n        centers.append([x, y])\n    \n    # Right edge\n    for i in range(edges[1]):\n        x = 0.95 - np.random.rand() * 0.05\n        y = (i + 1) / (edges[1] + 1)\n        centers.append([x, y])\n    \n    # Top edge\n    for i in range(edges[2]):\n        x = (i + 1) / (edges[2] + 1)\n        y = 0.95 - np.random.rand() * 0.05\n        centers.append([x, y])\n    \n    # Left edge\n    for i in range(edges[3]):\n        x = 0.05 + np.random.rand() * 0.05\n        y = (i + 1) / (edges[3] + 1)\n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef initialize_interior_circles(n_interior, seed):\n    \"\"\"Initialize circles in the interior of the unit square.\"\"\"\n    np.random.seed(seed * 200 + 50)\n    \n    # Create grid-based initialization with perturbation\n    grid_size = int(np.ceil(np.sqrt(n_interior)))\n    centers = []\n    \n    for i in range(n_interior):\n        row = i // grid_size\n        col = i % grid_size\n        x = 0.2 + 0.6 * (col + 0.5 + 0.2 * (np.random.rand() - 0.5)) / grid_size\n        y = 0.2 + 0.6 * (row + 0.5 + 0.2 * (np.random.rand() - 0.5)) / grid_size\n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum radii for each circle given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        x, y = centers[i]\n        r_max = min(x, 1 - x, y, 1 - y)\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef optimize_packing(initial_centers, n_boundary):\n    \"\"\"Optimize circle packing using SLSQP.\"\"\"\n    n = len(initial_centers)\n    x0 = initial_centers.flatten()\n    \n    def objective(x):\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure all circles stay within unit square.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no circles overlap.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Bounds\n    bounds = [(0.0, 1.0)] * (2 * n)\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 400, 'ftol': 1e-9}\n    )\n    \n    # Extract solution\n    centers = result.x.reshape(n, 2)\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return {\n        'centers': centers,\n        'radii': radii,\n        'sum_radii': sum_radii\n    }\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0089981555939,
    "error": "Timeout after 300s"
  },
  "prompt": "Create a boundary-optimized packing approach.\n\nObservation: Circles near boundaries can have larger radii. Exploit this:\n1. Place 12-16 circles along the boundary (edges and corners)\n2. Optimize their positions to maximize radii (they can use the boundary)\n3. Place remaining 10-14 circles in interior\n4. Optimize full configuration\n5. Try multiple boundary/interior allocations: (12,14), (14,12), (16,10)\n6. Use SLSQP with maxiter=400 per attempt\n7. Run 20 different configurations\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses boundary-optimized approach with multiple configurations.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Try different boundary/interior splits\n    configs = [(12, 14), (14, 12), (16, 10), (13, 13), (15, 11)]\n    \n    for config_idx, (n_boundary, n_interior) in enumerate(configs):\n        for trial in range(4):  # Multiple trials per config\n            \n            # Initialize boundary circles\n            boundary_centers = initialize_boundary_circles(n_boundary, trial)\n            \n            # Initialize interior circles\n            interior_centers = initialize_interior_circles(n_interior, trial)\n            \n            # Combine\n            centers = np.vstack([boundary_centers, interior_centers])\n            \n            # Optimize\n            result = optimize_packing(centers, n_boundary)\n            \n            if result['sum_radii'] > best_sum:\n                best_sum = result['sum_radii']\n                best_solution = result\n    \n    return best_solution['centers'], best_solution['radii'], best_solution['sum_radii']\n\ndef initialize_boundary_circles(n_boundary, seed):\n    \"\"\"Initialize circles along the boundary of the unit square.\"\"\"\n    np.random.seed(seed * 100)\n    centers = []\n    \n    # Distribute along edges\n    n_per_edge = n_boundary // 4\n    remainder = n_boundary % 4\n    \n    edges = [n_per_edge] * 4\n    for i in range(remainder):\n        edges[i] += 1\n    \n    # Bottom edge\n    for i in range(edges[0]):\n        x = (i + 1) / (edges[0] + 1)\n        y = 0.05 + np.random.rand() * 0.05\n        centers.append([x, y])\n    \n    # Right edge\n    for i in range(edges[1]):\n        x = 0.95 - np.random.rand() * 0.05\n        y = (i + 1) / (edges[1] + 1)\n        centers.append([x, y])\n    \n    # Top edge\n    for i in range(edges[2]):\n        x = (i + 1) / (edges[2] + 1)\n        y = 0.95 - np.random.rand() * 0.05\n        centers.append([x, y])\n    \n    # Left edge\n    for i in range(edges[3]):\n        x = 0.05 + np.random.rand() * 0.05\n        y = (i + 1) / (edges[3] + 1)\n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef initialize_interior_circles(n_interior, seed):\n    \"\"\"Initialize circles in the interior of the unit square.\"\"\"\n    np.random.seed(seed * 200 + 50)\n    \n    # Create grid-based initialization with perturbation\n    grid_size = int(np.ceil(np.sqrt(n_interior)))\n    centers = []\n    \n    for i in range(n_interior):\n        row = i // grid_size\n        col = i % grid_size\n        x = 0.2 + 0.6 * (col + 0.5 + 0.2 * (np.random.rand() - 0.5)) / grid_size\n        y = 0.2 + 0.6 * (row + 0.5 + 0.2 * (np.random.rand() - 0.5)) / grid_size\n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum radii for each circle given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        x, y = centers[i]\n        r_max = min(x, 1 - x, y, 1 - y)\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    return radii\n\ndef optimize_packing(initial_centers, n_boundary):\n    \"\"\"Optimize circle packing using SLSQP.\"\"\"\n    n = len(initial_centers)\n    x0 = initial_centers.flatten()\n    \n    def objective(x):\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraint_boundary(x):\n        \"\"\"Ensure all circles stay within unit square.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        return np.array(constraints)\n    \n    def constraint_overlap(x):\n        \"\"\"Ensure no circles overlap.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    # Bounds\n    bounds = [(0.0, 1.0)] * (2 * n)\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 400, 'ftol': 1e-9}\n    )\n    \n    # Extract solution\n    centers = result.x.reshape(n, 2)\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return {\n        'centers': centers,\n        'radii': radii,\n        'sum_radii': sum_radii\n    }\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:39:14.723638",
  "cost_data": null
}