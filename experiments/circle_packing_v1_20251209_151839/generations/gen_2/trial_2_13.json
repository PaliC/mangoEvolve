{
  "trial_id": "trial_2_13",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Strategy: Prioritize corner and edge placement for larger circles.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple configurations with different allocations\n    configurations = [\n        (4, 12, 10),  # 4 corners, 12 edges, 10 interior\n        (4, 14, 8),   # More on edges\n        (4, 10, 12),  # More interior\n        (4, 16, 6),   # Heavy edge focus\n        (4, 8, 14),   # Heavy interior focus\n    ]\n    \n    for config_idx, (n_corner, n_edge, n_interior) in enumerate(configurations):\n        if n_corner + n_edge + n_interior != n:\n            continue\n            \n        # Try multiple random initializations for each configuration\n        for trial in range(5):\n            centers, radii = optimize_configuration(n_corner, n_edge, n_interior, trial)\n            sum_radii = np.sum(radii)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef optimize_configuration(n_corner, n_edge, n_interior, seed):\n    \"\"\"Optimize a specific configuration of corner/edge/interior circles.\"\"\"\n    n = n_corner + n_edge + n_interior\n    np.random.seed(seed * 100)\n    \n    # Initialize positions strategically\n    centers = np.zeros((n, 2))\n    idx = 0\n    \n    # Place corner circles (with small offset from exact corner)\n    corner_offset = 0.08\n    corners = [\n        [corner_offset, corner_offset],\n        [1 - corner_offset, corner_offset],\n        [corner_offset, 1 - corner_offset],\n        [1 - corner_offset, 1 - corner_offset]\n    ]\n    for i in range(min(n_corner, 4)):\n        centers[idx] = corners[i]\n        idx += 1\n    \n    # Place edge circles (distributed along edges)\n    edge_margin = 0.1\n    if n_edge > 0:\n        # Bottom edge\n        n_bottom = n_edge // 4\n        for i in range(n_bottom):\n            x = 0.15 + (0.7 * (i + 1)) / (n_bottom + 1)\n            centers[idx] = [x, edge_margin]\n            idx += 1\n        \n        # Top edge\n        n_top = n_edge // 4\n        for i in range(n_top):\n            x = 0.15 + (0.7 * (i + 1)) / (n_top + 1)\n            centers[idx] = [x, 1 - edge_margin]\n            idx += 1\n        \n        # Left edge\n        n_left = n_edge // 4\n        for i in range(n_left):\n            y = 0.15 + (0.7 * (i + 1)) / (n_left + 1)\n            centers[idx] = [edge_margin, y]\n            idx += 1\n        \n        # Right edge\n        n_right = n_edge - n_bottom - n_top - n_left\n        for i in range(n_right):\n            y = 0.15 + (0.7 * (i + 1)) / (n_right + 1)\n            centers[idx] = [1 - edge_margin, y]\n            idx += 1\n    \n    # Place interior circles in a grid\n    if n_interior > 0:\n        grid_size = int(np.ceil(np.sqrt(n_interior)))\n        interior_margin = 0.2\n        spacing = (1 - 2 * interior_margin) / (grid_size + 1)\n        \n        for i in range(n_interior):\n            row = i // grid_size\n            col = i % grid_size\n            x = interior_margin + (col + 1) * spacing\n            y = interior_margin + (row + 1) * spacing\n            centers[idx] = [x, y]\n            idx += 1\n    \n    # Add small random perturbations\n    centers += np.random.randn(n, 2) * 0.02\n    centers = np.clip(centers, 0.05, 0.95)\n    \n    # Optimize\n    def objective(x):\n        c = x.reshape(n, 2)\n        r = compute_radii(c)\n        return -np.sum(r)  # Negative because we minimize\n    \n    def constraint_inside(x):\n        c = x.reshape(n, 2)\n        r = compute_radii(c)\n        # All circles must be inside [0,1]^2\n        constraints = []\n        for i in range(n):\n            constraints.append(c[i, 0] - r[i])  # left\n            constraints.append(1 - c[i, 0] - r[i])  # right\n            constraints.append(c[i, 1] - r[i])  # bottom\n            constraints.append(1 - c[i, 1] - r[i])  # top\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        c = x.reshape(n, 2)\n        r = compute_radii(c)\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                constraints.append(dist - r[i] - r[j])\n        return np.array(constraints)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside},\n        {'type': 'ineq', 'fun': constraint_no_overlap}\n    ]\n    \n    # Bounds to keep centers in [0.01, 0.99]\n    bounds = [(0.01, 0.99) for _ in range(2 * n)]\n    \n    result = minimize(\n        objective,\n        centers.flatten(),\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 300, 'ftol': 1e-8}\n    )\n    \n    final_centers = result.x.reshape(n, 2)\n    final_radii = compute_radii(final_centers)\n    \n    return final_centers, final_radii\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum valid radius for each circle given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Maximum radius based on square boundaries\n        r_max = min(\n            centers[i, 0],  # distance to left\n            1 - centers[i, 0],  # distance to right\n            centers[i, 1],  # distance to bottom\n            1 - centers[i, 1]  # distance to top\n        )\n        \n        # Maximum radius based on other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, (dist - radii[j]) / 2 if radii[j] > 0 else dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    # Iterative refinement\n    for _ in range(10):\n        for i in range(n):\n            r_max = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, dist - radii[j])\n            \n            radii[i] = max(0, r_max)\n    \n    return radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.00574493408203,
    "error": "Timeout after 300s"
  },
  "prompt": "Create an optimization focusing on corner and edge utilization.\n\nStrategy:\n1. Place 4 circles in corners (they can use 2 boundaries)\n2. Place 12 circles along edges (they can use 1 boundary)\n3. Place 10 circles in interior\n4. Optimize positions to maximize radii\n5. Try different corner/edge/interior allocations\n6. Use maxiter=300 per configuration\n7. Try 25 different configurations\n\nCircles near boundaries can be larger - exploit this geometric property.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Strategy: Prioritize corner and edge placement for larger circles.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Try multiple configurations with different allocations\n    configurations = [\n        (4, 12, 10),  # 4 corners, 12 edges, 10 interior\n        (4, 14, 8),   # More on edges\n        (4, 10, 12),  # More interior\n        (4, 16, 6),   # Heavy edge focus\n        (4, 8, 14),   # Heavy interior focus\n    ]\n    \n    for config_idx, (n_corner, n_edge, n_interior) in enumerate(configurations):\n        if n_corner + n_edge + n_interior != n:\n            continue\n            \n        # Try multiple random initializations for each configuration\n        for trial in range(5):\n            centers, radii = optimize_configuration(n_corner, n_edge, n_interior, trial)\n            sum_radii = np.sum(radii)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef optimize_configuration(n_corner, n_edge, n_interior, seed):\n    \"\"\"Optimize a specific configuration of corner/edge/interior circles.\"\"\"\n    n = n_corner + n_edge + n_interior\n    np.random.seed(seed * 100)\n    \n    # Initialize positions strategically\n    centers = np.zeros((n, 2))\n    idx = 0\n    \n    # Place corner circles (with small offset from exact corner)\n    corner_offset = 0.08\n    corners = [\n        [corner_offset, corner_offset],\n        [1 - corner_offset, corner_offset],\n        [corner_offset, 1 - corner_offset],\n        [1 - corner_offset, 1 - corner_offset]\n    ]\n    for i in range(min(n_corner, 4)):\n        centers[idx] = corners[i]\n        idx += 1\n    \n    # Place edge circles (distributed along edges)\n    edge_margin = 0.1\n    if n_edge > 0:\n        # Bottom edge\n        n_bottom = n_edge // 4\n        for i in range(n_bottom):\n            x = 0.15 + (0.7 * (i + 1)) / (n_bottom + 1)\n            centers[idx] = [x, edge_margin]\n            idx += 1\n        \n        # Top edge\n        n_top = n_edge // 4\n        for i in range(n_top):\n            x = 0.15 + (0.7 * (i + 1)) / (n_top + 1)\n            centers[idx] = [x, 1 - edge_margin]\n            idx += 1\n        \n        # Left edge\n        n_left = n_edge // 4\n        for i in range(n_left):\n            y = 0.15 + (0.7 * (i + 1)) / (n_left + 1)\n            centers[idx] = [edge_margin, y]\n            idx += 1\n        \n        # Right edge\n        n_right = n_edge - n_bottom - n_top - n_left\n        for i in range(n_right):\n            y = 0.15 + (0.7 * (i + 1)) / (n_right + 1)\n            centers[idx] = [1 - edge_margin, y]\n            idx += 1\n    \n    # Place interior circles in a grid\n    if n_interior > 0:\n        grid_size = int(np.ceil(np.sqrt(n_interior)))\n        interior_margin = 0.2\n        spacing = (1 - 2 * interior_margin) / (grid_size + 1)\n        \n        for i in range(n_interior):\n            row = i // grid_size\n            col = i % grid_size\n            x = interior_margin + (col + 1) * spacing\n            y = interior_margin + (row + 1) * spacing\n            centers[idx] = [x, y]\n            idx += 1\n    \n    # Add small random perturbations\n    centers += np.random.randn(n, 2) * 0.02\n    centers = np.clip(centers, 0.05, 0.95)\n    \n    # Optimize\n    def objective(x):\n        c = x.reshape(n, 2)\n        r = compute_radii(c)\n        return -np.sum(r)  # Negative because we minimize\n    \n    def constraint_inside(x):\n        c = x.reshape(n, 2)\n        r = compute_radii(c)\n        # All circles must be inside [0,1]^2\n        constraints = []\n        for i in range(n):\n            constraints.append(c[i, 0] - r[i])  # left\n            constraints.append(1 - c[i, 0] - r[i])  # right\n            constraints.append(c[i, 1] - r[i])  # bottom\n            constraints.append(1 - c[i, 1] - r[i])  # top\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        c = x.reshape(n, 2)\n        r = compute_radii(c)\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                constraints.append(dist - r[i] - r[j])\n        return np.array(constraints)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside},\n        {'type': 'ineq', 'fun': constraint_no_overlap}\n    ]\n    \n    # Bounds to keep centers in [0.01, 0.99]\n    bounds = [(0.01, 0.99) for _ in range(2 * n)]\n    \n    result = minimize(\n        objective,\n        centers.flatten(),\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 300, 'ftol': 1e-8}\n    )\n    \n    final_centers = result.x.reshape(n, 2)\n    final_radii = compute_radii(final_centers)\n    \n    return final_centers, final_radii\n\ndef compute_radii(centers):\n    \"\"\"Compute maximum valid radius for each circle given centers.\"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Maximum radius based on square boundaries\n        r_max = min(\n            centers[i, 0],  # distance to left\n            1 - centers[i, 0],  # distance to right\n            centers[i, 1],  # distance to bottom\n            1 - centers[i, 1]  # distance to top\n        )\n        \n        # Maximum radius based on other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                r_max = min(r_max, (dist - radii[j]) / 2 if radii[j] > 0 else dist / 2)\n        \n        radii[i] = max(0, r_max)\n    \n    # Iterative refinement\n    for _ in range(10):\n        for i in range(n):\n            r_max = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    r_max = min(r_max, dist - radii[j])\n            \n            radii[i] = max(0, r_max)\n    \n    return radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:39:19.700335",
  "cost_data": null
}