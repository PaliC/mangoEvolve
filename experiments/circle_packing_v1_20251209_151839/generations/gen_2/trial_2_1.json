{
  "trial_id": "trial_2_1",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses multi-start optimization with hexagonal patterns.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Generate initial configurations\n    configurations = []\n    \n    # Hexagonal patterns with different parameters\n    for n_rows in [4, 5, 6]:\n        for angle in [0, 15, 30, 45]:\n            for spacing_factor in [0.9, 1.0, 1.1]:\n                for offset_factor in [0.0, 0.5]:\n                    config = generate_hex_pattern(n, n_rows, angle, spacing_factor, offset_factor)\n                    configurations.append(config)\n    \n    # Quick optimization on all configurations\n    candidates = []\n    for i, config in enumerate(configurations[:40]):  # Limit to 40 configs\n        result = optimize_packing(config, maxiter=200)\n        if result is not None:\n            candidates.append(result)\n    \n    # Sort by sum of radii\n    candidates.sort(key=lambda x: x[2], reverse=True)\n    \n    # Extended optimization on top 5\n    for centers, radii, sum_radii in candidates[:5]:\n        x0 = pack_variables(centers, radii)\n        result = optimize_packing(x0, maxiter=500)\n        if result is not None:\n            _, _, curr_sum = result\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_solution = result\n    \n    if best_solution is None:\n        # Fallback to simple grid\n        best_solution = generate_simple_grid(n)\n    \n    centers, radii, sum_radii = best_solution\n    return centers, radii, sum_radii\n\ndef generate_hex_pattern(n, n_rows, angle_deg, spacing_factor, offset_factor):\n    \"\"\"Generate hexagonal pattern configuration.\"\"\"\n    angle = np.radians(angle_deg)\n    centers = []\n    \n    # Estimate spacing\n    base_spacing = 0.18 * spacing_factor\n    \n    row_idx = 0\n    while len(centers) < n:\n        if row_idx >= n_rows:\n            # Add extra circles in remaining space\n            y = 0.5\n            x = 0.1 + (len(centers) % 5) * 0.18\n            centers.append([x, y])\n        else:\n            # Hexagonal row\n            n_in_row = (n + n_rows - 1) // n_rows\n            if row_idx % 2 == 1:\n                n_in_row = max(1, n_in_row - 1)\n            \n            y = 0.1 + row_idx * base_spacing * np.sqrt(3) / 2\n            offset = offset_factor * base_spacing if row_idx % 2 == 1 else 0\n            \n            for col_idx in range(n_in_row):\n                if len(centers) >= n:\n                    break\n                x = 0.1 + offset + col_idx * base_spacing\n                centers.append([x, y])\n        \n        row_idx += 1\n    \n    centers = np.array(centers[:n])\n    \n    # Apply rotation\n    if angle != 0:\n        rot_matrix = np.array([[np.cos(angle), -np.sin(angle)],\n                               [np.sin(angle), np.cos(angle)]])\n        center_point = np.array([0.5, 0.5])\n        centers = (centers - center_point) @ rot_matrix.T + center_point\n    \n    # Clip to valid range\n    centers = np.clip(centers, 0.05, 0.95)\n    \n    # Initialize radii\n    radii = np.full(n, 0.08)\n    \n    return pack_variables(centers, radii)\n\ndef generate_simple_grid(n):\n    \"\"\"Fallback simple grid pattern.\"\"\"\n    cols = int(np.ceil(np.sqrt(n)))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    for i in range(n):\n        row = i // cols\n        col = i % cols\n        x = (col + 0.5) / cols\n        y = (row + 0.5) / rows\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n, 0.08)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef pack_variables(centers, radii):\n    \"\"\"Pack centers and radii into single array.\"\"\"\n    return np.concatenate([centers.flatten(), radii])\n\ndef unpack_variables(x, n):\n    \"\"\"Unpack array into centers and radii.\"\"\"\n    centers = x[:2*n].reshape(n, 2)\n    radii = x[2*n:]\n    return centers, radii\n\ndef optimize_packing(x0, maxiter=200):\n    \"\"\"Optimize packing configuration.\"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        _, radii = unpack_variables(x, n)\n        return -np.sum(radii)\n    \n    def constraint_inside_square(x):\n        \"\"\"All circles inside unit square.\"\"\"\n        centers, radii = unpack_variables(x, n)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        \"\"\"No overlapping circles.\"\"\"\n        centers, radii = unpack_variables(x, n)\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside_square},\n        {'type': 'ineq', 'fun': constraint_no_overlap}\n    ]\n    \n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': maxiter, 'ftol': 1e-6}\n        )\n        \n        if result.success or result.fun < 0:\n            centers, radii = unpack_variables(result.x, n)\n            sum_radii = np.sum(radii)\n            return centers, radii, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 79.33881497383118,
    "error": "Circle 0 at (0.0, 0.0) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "Create a fast multi-start optimization focusing on hexagonal patterns.\n\nStrategy:\n1. Generate 40 different hexagonal patterns with varying:\n   - Number of rows (4, 5, 6, 7)\n   - Rotation angles (0, 15, 30, 45 degrees)\n   - Spacing parameters\n   - Offset patterns\n2. For each pattern, run quick SLSQP optimization (maxiter=200)\n3. Take top 5 results and run extended optimization (maxiter=500)\n4. Use scipy.optimize.minimize with SLSQP method\n5. Keep code simple to avoid timeouts\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom itertools import product\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses multi-start optimization with hexagonal patterns.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Generate initial configurations\n    configurations = []\n    \n    # Hexagonal patterns with different parameters\n    for n_rows in [4, 5, 6]:\n        for angle in [0, 15, 30, 45]:\n            for spacing_factor in [0.9, 1.0, 1.1]:\n                for offset_factor in [0.0, 0.5]:\n                    config = generate_hex_pattern(n, n_rows, angle, spacing_factor, offset_factor)\n                    configurations.append(config)\n    \n    # Quick optimization on all configurations\n    candidates = []\n    for i, config in enumerate(configurations[:40]):  # Limit to 40 configs\n        result = optimize_packing(config, maxiter=200)\n        if result is not None:\n            candidates.append(result)\n    \n    # Sort by sum of radii\n    candidates.sort(key=lambda x: x[2], reverse=True)\n    \n    # Extended optimization on top 5\n    for centers, radii, sum_radii in candidates[:5]:\n        x0 = pack_variables(centers, radii)\n        result = optimize_packing(x0, maxiter=500)\n        if result is not None:\n            _, _, curr_sum = result\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_solution = result\n    \n    if best_solution is None:\n        # Fallback to simple grid\n        best_solution = generate_simple_grid(n)\n    \n    centers, radii, sum_radii = best_solution\n    return centers, radii, sum_radii\n\ndef generate_hex_pattern(n, n_rows, angle_deg, spacing_factor, offset_factor):\n    \"\"\"Generate hexagonal pattern configuration.\"\"\"\n    angle = np.radians(angle_deg)\n    centers = []\n    \n    # Estimate spacing\n    base_spacing = 0.18 * spacing_factor\n    \n    row_idx = 0\n    while len(centers) < n:\n        if row_idx >= n_rows:\n            # Add extra circles in remaining space\n            y = 0.5\n            x = 0.1 + (len(centers) % 5) * 0.18\n            centers.append([x, y])\n        else:\n            # Hexagonal row\n            n_in_row = (n + n_rows - 1) // n_rows\n            if row_idx % 2 == 1:\n                n_in_row = max(1, n_in_row - 1)\n            \n            y = 0.1 + row_idx * base_spacing * np.sqrt(3) / 2\n            offset = offset_factor * base_spacing if row_idx % 2 == 1 else 0\n            \n            for col_idx in range(n_in_row):\n                if len(centers) >= n:\n                    break\n                x = 0.1 + offset + col_idx * base_spacing\n                centers.append([x, y])\n        \n        row_idx += 1\n    \n    centers = np.array(centers[:n])\n    \n    # Apply rotation\n    if angle != 0:\n        rot_matrix = np.array([[np.cos(angle), -np.sin(angle)],\n                               [np.sin(angle), np.cos(angle)]])\n        center_point = np.array([0.5, 0.5])\n        centers = (centers - center_point) @ rot_matrix.T + center_point\n    \n    # Clip to valid range\n    centers = np.clip(centers, 0.05, 0.95)\n    \n    # Initialize radii\n    radii = np.full(n, 0.08)\n    \n    return pack_variables(centers, radii)\n\ndef generate_simple_grid(n):\n    \"\"\"Fallback simple grid pattern.\"\"\"\n    cols = int(np.ceil(np.sqrt(n)))\n    rows = int(np.ceil(n / cols))\n    \n    centers = []\n    for i in range(n):\n        row = i // cols\n        col = i % cols\n        x = (col + 0.5) / cols\n        y = (row + 0.5) / rows\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n, 0.08)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef pack_variables(centers, radii):\n    \"\"\"Pack centers and radii into single array.\"\"\"\n    return np.concatenate([centers.flatten(), radii])\n\ndef unpack_variables(x, n):\n    \"\"\"Unpack array into centers and radii.\"\"\"\n    centers = x[:2*n].reshape(n, 2)\n    radii = x[2*n:]\n    return centers, radii\n\ndef optimize_packing(x0, maxiter=200):\n    \"\"\"Optimize packing configuration.\"\"\"\n    n = 26\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii.\"\"\"\n        _, radii = unpack_variables(x, n)\n        return -np.sum(radii)\n    \n    def constraint_inside_square(x):\n        \"\"\"All circles inside unit square.\"\"\"\n        centers, radii = unpack_variables(x, n)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        return np.array(constraints)\n    \n    def constraint_no_overlap(x):\n        \"\"\"No overlapping circles.\"\"\"\n        centers, radii = unpack_variables(x, n)\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        return np.array(constraints)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_inside_square},\n        {'type': 'ineq', 'fun': constraint_no_overlap}\n    ]\n    \n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': maxiter, 'ftol': 1e-6}\n        )\n        \n        if result.success or result.fun < 0:\n            centers, radii = unpack_variables(result.x, n)\n            sum_radii = np.sum(radii)\n            return centers, radii, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:35:36.522860",
  "cost_data": null
}