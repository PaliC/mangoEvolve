{
  "trial_id": "trial_2_7",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hexagonal grid.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    def create_hexagonal_grid(n_circles, scale=0.9):\n        \"\"\"Create hexagonal grid pattern scaled to fit in unit square.\"\"\"\n        # Hexagonal grid with sqrt(3)/2 vertical spacing\n        positions = []\n        rows = int(np.ceil(np.sqrt(n_circles * 2 / np.sqrt(3))))\n        cols = int(np.ceil(n_circles / rows)) + 1\n        \n        hex_spacing_x = 1.0 / (cols + 0.5)\n        hex_spacing_y = hex_spacing_x * np.sqrt(3) / 2\n        \n        for row in range(rows):\n            for col in range(cols):\n                if len(positions) >= n_circles:\n                    break\n                x = hex_spacing_x * (col + 0.5 + (row % 2) * 0.5)\n                y = hex_spacing_y * (row + 1)\n                positions.append([x, y])\n            if len(positions) >= n_circles:\n                break\n        \n        positions = np.array(positions[:n_circles])\n        \n        # Center and scale\n        center = positions.mean(axis=0)\n        positions = (positions - center) * scale + 0.5\n        \n        return positions\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum valid radii for given centers.\"\"\"\n        radii = np.full(n, 0.5)  # Start with large radii\n        \n        # Constraint from square boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r)\n        \n        # Constraint from other circles\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                max_sum = distances[i, j]\n                if radii[i] + radii[j] > max_sum:\n                    # Distribute the available distance proportionally\n                    scale = max_sum / (radii[i] + radii[j]) * 0.999\n                    radii[i] *= scale\n                    radii[j] *= scale\n        \n        return np.maximum(radii, 0)\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraints_penalty(x):\n        \"\"\"Compute constraint violations.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        penalty = 0\n        \n        # Boundary constraints\n        for i in range(n):\n            penalty += max(0, radii[i] - centers[i, 0]) ** 2\n            penalty += max(0, radii[i] - centers[i, 1]) ** 2\n            penalty += max(0, radii[i] - (1 - centers[i, 0])) ** 2\n            penalty += max(0, radii[i] - (1 - centers[i, 1])) ** 2\n        \n        # Overlap constraints\n        distances = cdist(centers, centers)\n        for i in range(n):\n            for j in range(i + 1, n):\n                overlap = radii[i] + radii[j] - distances[i, j]\n                if overlap > 0:\n                    penalty += overlap ** 2\n        \n        return penalty\n    \n    def objective_with_penalty(x):\n        \"\"\"Objective with penalty for constraint violations.\"\"\"\n        return objective(x) + 1000 * constraints_penalty(x)\n    \n    # Try multiple perturbation levels\n    perturbation_levels = [0.01, 0.015, 0.02, 0.025, 0.03]\n    n_trials_per_level = 6\n    \n    candidates = []\n    \n    for pert_level in perturbation_levels:\n        for trial in range(n_trials_per_level):\n            # Create base hexagonal grid\n            initial_centers = create_hexagonal_grid(n, scale=0.85 + trial * 0.02)\n            \n            # Add perturbation\n            np.random.seed(trial * 100 + int(pert_level * 1000))\n            perturbation = np.random.randn(n, 2) * pert_level\n            initial_centers += perturbation\n            \n            # Clip to valid range\n            initial_centers = np.clip(initial_centers, 0.05, 0.95)\n            \n            # Optimize with SLSQP\n            bounds = [(0.02, 0.98)] * (2 * n)\n            x0 = initial_centers.flatten()\n            \n            result = minimize(\n                objective_with_penalty,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                options={'maxiter': 300, 'ftol': 1e-8}\n            )\n            \n            centers = result.x.reshape(n, 2)\n            radii = compute_radii(centers)\n            sum_radii = np.sum(radii)\n            \n            candidates.append((sum_radii, centers, radii))\n    \n    # Sort and get top 5\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    \n    # Extended optimization for top 5\n    for i in range(min(5, len(candidates))):\n        _, centers, _ = candidates[i]\n        x0 = centers.flatten()\n        \n        result = minimize(\n            objective_with_penalty,\n            x0,\n            method='SLSQP',\n            bounds=[(0.02, 0.98)] * (2 * n),\n            options={'maxiter': 600, 'ftol': 1e-9}\n        )\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        # Post-optimization: incrementally expand radii\n        for expansion_iter in range(20):\n            old_radii = radii.copy()\n            \n            # Try to expand each radius slightly\n            for j in range(n):\n                test_radii = radii.copy()\n                test_radii[j] *= 1.002\n                \n                # Check if still valid\n                valid = True\n                \n                # Boundary check\n                if (test_radii[j] > centers[j, 0] or \n                    test_radii[j] > centers[j, 1] or\n                    test_radii[j] > 1 - centers[j, 0] or \n                    test_radii[j] > 1 - centers[j, 1]):\n                    valid = False\n                \n                # Overlap check\n                if valid:\n                    for k in range(n):\n                        if k != j:\n                            dist = np.linalg.norm(centers[j] - centers[k])\n                            if test_radii[j] + test_radii[k] > dist * 0.9999:\n                                valid = False\n                                break\n                \n                if valid:\n                    radii[j] = test_radii[j]\n            \n            # Stop if no improvement\n            if np.allclose(radii, old_radii):\n                break\n        \n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.461213025596214,
    "target_ratio": 0.9340466890308213,
    "combined_score": 0.9340466890308213,
    "eval_time": 97.88496208190918,
    "error": null
  },
  "prompt": "Create a hexagonal-grid hybrid initialization.\n\nStrategy:\n1. Start with perfect hexagonal lattice for 26 circles\n2. Add small random perturbations (different magnitudes: 0.01, 0.02, 0.03)\n3. Optimize with SLSQP (maxiter=300)\n4. Try 30 different perturbation patterns\n5. For top 5, run extended optimization (maxiter=600)\n6. Add post-optimization phase to expand radii incrementally\n\nFocus on hexagonal as it's theoretically optimal for infinite plane packing.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using hexagonal grid.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    def create_hexagonal_grid(n_circles, scale=0.9):\n        \"\"\"Create hexagonal grid pattern scaled to fit in unit square.\"\"\"\n        # Hexagonal grid with sqrt(3)/2 vertical spacing\n        positions = []\n        rows = int(np.ceil(np.sqrt(n_circles * 2 / np.sqrt(3))))\n        cols = int(np.ceil(n_circles / rows)) + 1\n        \n        hex_spacing_x = 1.0 / (cols + 0.5)\n        hex_spacing_y = hex_spacing_x * np.sqrt(3) / 2\n        \n        for row in range(rows):\n            for col in range(cols):\n                if len(positions) >= n_circles:\n                    break\n                x = hex_spacing_x * (col + 0.5 + (row % 2) * 0.5)\n                y = hex_spacing_y * (row + 1)\n                positions.append([x, y])\n            if len(positions) >= n_circles:\n                break\n        \n        positions = np.array(positions[:n_circles])\n        \n        # Center and scale\n        center = positions.mean(axis=0)\n        positions = (positions - center) * scale + 0.5\n        \n        return positions\n    \n    def compute_radii(centers):\n        \"\"\"Compute maximum valid radii for given centers.\"\"\"\n        radii = np.full(n, 0.5)  # Start with large radii\n        \n        # Constraint from square boundaries\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], \n                       1 - centers[i, 0], 1 - centers[i, 1])\n            radii[i] = min(radii[i], max_r)\n        \n        # Constraint from other circles\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                max_sum = distances[i, j]\n                if radii[i] + radii[j] > max_sum:\n                    # Distribute the available distance proportionally\n                    scale = max_sum / (radii[i] + radii[j]) * 0.999\n                    radii[i] *= scale\n                    radii[j] *= scale\n        \n        return np.maximum(radii, 0)\n    \n    def objective(x):\n        \"\"\"Objective: minimize negative sum of radii.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        return -np.sum(radii)\n    \n    def constraints_penalty(x):\n        \"\"\"Compute constraint violations.\"\"\"\n        centers = x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        penalty = 0\n        \n        # Boundary constraints\n        for i in range(n):\n            penalty += max(0, radii[i] - centers[i, 0]) ** 2\n            penalty += max(0, radii[i] - centers[i, 1]) ** 2\n            penalty += max(0, radii[i] - (1 - centers[i, 0])) ** 2\n            penalty += max(0, radii[i] - (1 - centers[i, 1])) ** 2\n        \n        # Overlap constraints\n        distances = cdist(centers, centers)\n        for i in range(n):\n            for j in range(i + 1, n):\n                overlap = radii[i] + radii[j] - distances[i, j]\n                if overlap > 0:\n                    penalty += overlap ** 2\n        \n        return penalty\n    \n    def objective_with_penalty(x):\n        \"\"\"Objective with penalty for constraint violations.\"\"\"\n        return objective(x) + 1000 * constraints_penalty(x)\n    \n    # Try multiple perturbation levels\n    perturbation_levels = [0.01, 0.015, 0.02, 0.025, 0.03]\n    n_trials_per_level = 6\n    \n    candidates = []\n    \n    for pert_level in perturbation_levels:\n        for trial in range(n_trials_per_level):\n            # Create base hexagonal grid\n            initial_centers = create_hexagonal_grid(n, scale=0.85 + trial * 0.02)\n            \n            # Add perturbation\n            np.random.seed(trial * 100 + int(pert_level * 1000))\n            perturbation = np.random.randn(n, 2) * pert_level\n            initial_centers += perturbation\n            \n            # Clip to valid range\n            initial_centers = np.clip(initial_centers, 0.05, 0.95)\n            \n            # Optimize with SLSQP\n            bounds = [(0.02, 0.98)] * (2 * n)\n            x0 = initial_centers.flatten()\n            \n            result = minimize(\n                objective_with_penalty,\n                x0,\n                method='SLSQP',\n                bounds=bounds,\n                options={'maxiter': 300, 'ftol': 1e-8}\n            )\n            \n            centers = result.x.reshape(n, 2)\n            radii = compute_radii(centers)\n            sum_radii = np.sum(radii)\n            \n            candidates.append((sum_radii, centers, radii))\n    \n    # Sort and get top 5\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    \n    # Extended optimization for top 5\n    for i in range(min(5, len(candidates))):\n        _, centers, _ = candidates[i]\n        x0 = centers.flatten()\n        \n        result = minimize(\n            objective_with_penalty,\n            x0,\n            method='SLSQP',\n            bounds=[(0.02, 0.98)] * (2 * n),\n            options={'maxiter': 600, 'ftol': 1e-9}\n        )\n        \n        centers = result.x.reshape(n, 2)\n        radii = compute_radii(centers)\n        \n        # Post-optimization: incrementally expand radii\n        for expansion_iter in range(20):\n            old_radii = radii.copy()\n            \n            # Try to expand each radius slightly\n            for j in range(n):\n                test_radii = radii.copy()\n                test_radii[j] *= 1.002\n                \n                # Check if still valid\n                valid = True\n                \n                # Boundary check\n                if (test_radii[j] > centers[j, 0] or \n                    test_radii[j] > centers[j, 1] or\n                    test_radii[j] > 1 - centers[j, 0] or \n                    test_radii[j] > 1 - centers[j, 1]):\n                    valid = False\n                \n                # Overlap check\n                if valid:\n                    for k in range(n):\n                        if k != j:\n                            dist = np.linalg.norm(centers[j] - centers[k])\n                            if test_radii[j] + test_radii[k] > dist * 0.9999:\n                                valid = False\n                                break\n                \n                if valid:\n                    radii[j] = test_radii[j]\n            \n            # Stop if no improvement\n            if np.allclose(radii, old_radii):\n                break\n        \n        sum_radii = np.sum(radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:35:57.979909",
  "cost_data": null
}