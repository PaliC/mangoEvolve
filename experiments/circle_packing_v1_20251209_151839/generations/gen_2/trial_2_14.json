{
  "trial_id": "trial_2_14",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Generate 30 different initialization patterns\n    patterns = []\n    \n    # 10 hexagonal variations\n    for i in range(10):\n        angle_offset = i * np.pi / 20\n        scale = 0.85 + i * 0.01\n        spacing = 0.16 + i * 0.005\n        patterns.append(generate_hexagonal_pattern(n, angle_offset, scale, spacing))\n    \n    # 10 grid variations\n    grid_configs = [\n        (5, 6), (6, 5), (4, 7), (7, 4), (3, 9),\n        (5, 6), (6, 5), (4, 7), (7, 4), (5, 6)\n    ]\n    for i, (rows, cols) in enumerate(grid_configs):\n        offset = i * 0.01\n        patterns.append(generate_grid_pattern(n, rows, cols, offset))\n    \n    # 10 boundary-focused variations\n    for i in range(10):\n        boundary_ratio = 0.4 + i * 0.04\n        patterns.append(generate_boundary_pattern(n, boundary_ratio, i))\n    \n    # Phase 1: Quick optimization on all patterns\n    pattern_results = []\n    for idx, pattern in enumerate(patterns):\n        result = optimize_packing(pattern, n, maxiter=250)\n        pattern_results.append((idx, result['sum'], result))\n        if result['sum'] > best_sum:\n            best_sum = result['sum']\n            best_solution = result\n    \n    # Sort by performance\n    pattern_results.sort(key=lambda x: x[1], reverse=True)\n    \n    # Phase 2: Extended optimization on top 5\n    for idx, _, result in pattern_results[:5]:\n        # Re-initialize from the optimized result\n        initial = np.concatenate([result['centers'].flatten(), result['radii']])\n        extended_result = optimize_packing(initial, n, maxiter=600)\n        if extended_result['sum'] > best_sum:\n            best_sum = extended_result['sum']\n            best_solution = extended_result\n    \n    # Phase 3: Radius expansion post-processing\n    final_result = expand_radii(best_solution['centers'], best_solution['radii'], n)\n    \n    return final_result['centers'], final_result['radii'], final_result['sum']\n\ndef generate_hexagonal_pattern(n, angle_offset=0, scale=0.85, spacing=0.17):\n    \"\"\"Generate hexagonal close-packing pattern.\"\"\"\n    centers = []\n    radii = []\n    \n    # Hexagonal lattice\n    rows = 6\n    for row in range(rows):\n        cols = 5 if row % 2 == 0 else 4\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = 0.1 + col * spacing * scale\n            y = 0.1 + row * spacing * 0.866 * scale\n            if row % 2 == 1:\n                x += spacing * 0.5 * scale\n            \n            # Apply rotation\n            cx, cy = 0.5, 0.5\n            x_rot = cx + (x - cx) * np.cos(angle_offset) - (y - cy) * np.sin(angle_offset)\n            y_rot = cy + (x - cx) * np.sin(angle_offset) + (y - cy) * np.cos(angle_offset)\n            \n            centers.append([x_rot, y_rot])\n            radii.append(spacing * 0.45)\n        if len(centers) >= n:\n            break\n    \n    # Fill remaining with random positions\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        radii.append(0.05)\n    \n    return np.concatenate([np.array(centers[:n]).flatten(), np.array(radii[:n])])\n\ndef generate_grid_pattern(n, rows, cols, offset=0):\n    \"\"\"Generate grid pattern.\"\"\"\n    centers = []\n    radii = []\n    \n    spacing_x = 0.9 / (cols + 0.5)\n    spacing_y = 0.9 / (rows + 0.5)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = 0.1 + (j + 0.5) * spacing_x + offset * (i % 2)\n            y = 0.1 + (i + 0.5) * spacing_y\n            centers.append([x, y])\n            radii.append(min(spacing_x, spacing_y) * 0.4)\n        if len(centers) >= n:\n            break\n    \n    while len(centers) < n:\n        centers.append([np.random.uniform(0.15, 0.85), np.random.uniform(0.15, 0.85)])\n        radii.append(0.05)\n    \n    return np.concatenate([np.array(centers[:n]).flatten(), np.array(radii[:n])])\n\ndef generate_boundary_pattern(n, boundary_ratio, seed):\n    \"\"\"Generate pattern with circles concentrated on boundaries.\"\"\"\n    np.random.seed(seed)\n    centers = []\n    radii = []\n    \n    n_boundary = int(n * boundary_ratio)\n    n_interior = n - n_boundary\n    \n    # Boundary circles\n    margin = 0.08\n    for i in range(n_boundary):\n        side = i % 4\n        if side == 0:  # bottom\n            centers.append([np.random.uniform(margin, 1-margin), margin])\n        elif side == 1:  # right\n            centers.append([1-margin, np.random.uniform(margin, 1-margin)])\n        elif side == 2:  # top\n            centers.append([np.random.uniform(margin, 1-margin), 1-margin])\n        else:  # left\n            centers.append([margin, np.random.uniform(margin, 1-margin)])\n        radii.append(0.06)\n    \n    # Interior circles\n    for i in range(n_interior):\n        centers.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n        radii.append(0.08)\n    \n    return np.concatenate([np.array(centers).flatten(), np.array(radii)])\n\ndef optimize_packing(initial, n, maxiter=250):\n    \"\"\"Optimize circle packing using SLSQP.\"\"\"\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        distances = squareform(pdist(centers))\n        np.fill_diagonal(distances, np.inf)\n        min_allowed = radii[:, None] + radii[None, :]\n        violations = min_allowed - distances\n        return -violations.flatten()\n    \n    def constraint_inside_square(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers[i, 0] - radii[i],  # left\n                1 - centers[i, 0] - radii[i],  # right\n                centers[i, 1] - radii[i],  # bottom\n                1 - centers[i, 1] - radii[i]  # top\n            ])\n        return np.array(constraints)\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_inside_square}\n    ]\n    \n    # Optimize\n    result = minimize(\n        objective,\n        initial,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': maxiter, 'ftol': 1e-9}\n    )\n    \n    centers = result.x[:2*n].reshape(n, 2)\n    radii = result.x[2*n:]\n    \n    return {\n        'centers': centers,\n        'radii': radii,\n        'sum': np.sum(radii)\n    }\n\ndef expand_radii(centers, radii, n):\n    \"\"\"Expand radii as much as possible while maintaining constraints.\"\"\"\n    expanded_radii = radii.copy()\n    \n    for iteration in range(50):\n        improved = False\n        for i in range(n):\n            # Maximum radius based on square boundaries\n            max_r = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            # Maximum radius based on other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - expanded_radii[j])\n            \n            # Try to expand\n            if max_r > expanded_radii[i] + 1e-6:\n                expanded_radii[i] = max_r - 1e-6\n                improved = True\n        \n        if not improved:\n            break\n    \n    return {\n        'centers': centers,\n        'radii': expanded_radii,\n        'sum': np.sum(expanded_radii)\n    }\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 3.305121898651123,
    "error": "Circle 0 at (0.8325015502219628, 0.0423508777458525) with radius 0.09225000000000001 extends outside y-bounds"
  },
  "prompt": "Create a pattern-matching optimization approach.\n\nStrategy:\n1. Generate 30 high-quality initialization patterns:\n   - 10 hexagonal variations (different orientations, spacings)\n   - 10 grid variations (5x6, 6x5, 4x7, etc.)\n   - 10 boundary-focused variations\n2. For each pattern, run optimization with maxiter=250\n3. Track which pattern types work best\n4. Run extended optimization (maxiter=600) on top 5\n5. Add post-optimization radius expansion\n\nUse scipy.optimize.minimize with SLSQP.\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) - (x, y) coordinates of circle centers\n        radii: np.array of shape (26,) - radius of each circle\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n = 26\n    best_solution = None\n    best_sum = 0\n    \n    # Generate 30 different initialization patterns\n    patterns = []\n    \n    # 10 hexagonal variations\n    for i in range(10):\n        angle_offset = i * np.pi / 20\n        scale = 0.85 + i * 0.01\n        spacing = 0.16 + i * 0.005\n        patterns.append(generate_hexagonal_pattern(n, angle_offset, scale, spacing))\n    \n    # 10 grid variations\n    grid_configs = [\n        (5, 6), (6, 5), (4, 7), (7, 4), (3, 9),\n        (5, 6), (6, 5), (4, 7), (7, 4), (5, 6)\n    ]\n    for i, (rows, cols) in enumerate(grid_configs):\n        offset = i * 0.01\n        patterns.append(generate_grid_pattern(n, rows, cols, offset))\n    \n    # 10 boundary-focused variations\n    for i in range(10):\n        boundary_ratio = 0.4 + i * 0.04\n        patterns.append(generate_boundary_pattern(n, boundary_ratio, i))\n    \n    # Phase 1: Quick optimization on all patterns\n    pattern_results = []\n    for idx, pattern in enumerate(patterns):\n        result = optimize_packing(pattern, n, maxiter=250)\n        pattern_results.append((idx, result['sum'], result))\n        if result['sum'] > best_sum:\n            best_sum = result['sum']\n            best_solution = result\n    \n    # Sort by performance\n    pattern_results.sort(key=lambda x: x[1], reverse=True)\n    \n    # Phase 2: Extended optimization on top 5\n    for idx, _, result in pattern_results[:5]:\n        # Re-initialize from the optimized result\n        initial = np.concatenate([result['centers'].flatten(), result['radii']])\n        extended_result = optimize_packing(initial, n, maxiter=600)\n        if extended_result['sum'] > best_sum:\n            best_sum = extended_result['sum']\n            best_solution = extended_result\n    \n    # Phase 3: Radius expansion post-processing\n    final_result = expand_radii(best_solution['centers'], best_solution['radii'], n)\n    \n    return final_result['centers'], final_result['radii'], final_result['sum']\n\ndef generate_hexagonal_pattern(n, angle_offset=0, scale=0.85, spacing=0.17):\n    \"\"\"Generate hexagonal close-packing pattern.\"\"\"\n    centers = []\n    radii = []\n    \n    # Hexagonal lattice\n    rows = 6\n    for row in range(rows):\n        cols = 5 if row % 2 == 0 else 4\n        for col in range(cols):\n            if len(centers) >= n:\n                break\n            x = 0.1 + col * spacing * scale\n            y = 0.1 + row * spacing * 0.866 * scale\n            if row % 2 == 1:\n                x += spacing * 0.5 * scale\n            \n            # Apply rotation\n            cx, cy = 0.5, 0.5\n            x_rot = cx + (x - cx) * np.cos(angle_offset) - (y - cy) * np.sin(angle_offset)\n            y_rot = cy + (x - cx) * np.sin(angle_offset) + (y - cy) * np.cos(angle_offset)\n            \n            centers.append([x_rot, y_rot])\n            radii.append(spacing * 0.45)\n        if len(centers) >= n:\n            break\n    \n    # Fill remaining with random positions\n    while len(centers) < n:\n        centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        radii.append(0.05)\n    \n    return np.concatenate([np.array(centers[:n]).flatten(), np.array(radii[:n])])\n\ndef generate_grid_pattern(n, rows, cols, offset=0):\n    \"\"\"Generate grid pattern.\"\"\"\n    centers = []\n    radii = []\n    \n    spacing_x = 0.9 / (cols + 0.5)\n    spacing_y = 0.9 / (rows + 0.5)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n:\n                break\n            x = 0.1 + (j + 0.5) * spacing_x + offset * (i % 2)\n            y = 0.1 + (i + 0.5) * spacing_y\n            centers.append([x, y])\n            radii.append(min(spacing_x, spacing_y) * 0.4)\n        if len(centers) >= n:\n            break\n    \n    while len(centers) < n:\n        centers.append([np.random.uniform(0.15, 0.85), np.random.uniform(0.15, 0.85)])\n        radii.append(0.05)\n    \n    return np.concatenate([np.array(centers[:n]).flatten(), np.array(radii[:n])])\n\ndef generate_boundary_pattern(n, boundary_ratio, seed):\n    \"\"\"Generate pattern with circles concentrated on boundaries.\"\"\"\n    np.random.seed(seed)\n    centers = []\n    radii = []\n    \n    n_boundary = int(n * boundary_ratio)\n    n_interior = n - n_boundary\n    \n    # Boundary circles\n    margin = 0.08\n    for i in range(n_boundary):\n        side = i % 4\n        if side == 0:  # bottom\n            centers.append([np.random.uniform(margin, 1-margin), margin])\n        elif side == 1:  # right\n            centers.append([1-margin, np.random.uniform(margin, 1-margin)])\n        elif side == 2:  # top\n            centers.append([np.random.uniform(margin, 1-margin), 1-margin])\n        else:  # left\n            centers.append([margin, np.random.uniform(margin, 1-margin)])\n        radii.append(0.06)\n    \n    # Interior circles\n    for i in range(n_interior):\n        centers.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n        radii.append(0.08)\n    \n    return np.concatenate([np.array(centers).flatten(), np.array(radii)])\n\ndef optimize_packing(initial, n, maxiter=250):\n    \"\"\"Optimize circle packing using SLSQP.\"\"\"\n    \n    def objective(x):\n        radii = x[2*n:]\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        distances = squareform(pdist(centers))\n        np.fill_diagonal(distances, np.inf)\n        min_allowed = radii[:, None] + radii[None, :]\n        violations = min_allowed - distances\n        return -violations.flatten()\n    \n    def constraint_inside_square(x):\n        centers = x[:2*n].reshape(n, 2)\n        radii = x[2*n:]\n        constraints = []\n        for i in range(n):\n            constraints.extend([\n                centers[i, 0] - radii[i],  # left\n                1 - centers[i, 0] - radii[i],  # right\n                centers[i, 1] - radii[i],  # bottom\n                1 - centers[i, 1] - radii[i]  # top\n            ])\n        return np.array(constraints)\n    \n    # Bounds\n    bounds = [(0, 1)] * (2*n) + [(0, 0.5)] * n\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_inside_square}\n    ]\n    \n    # Optimize\n    result = minimize(\n        objective,\n        initial,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': maxiter, 'ftol': 1e-9}\n    )\n    \n    centers = result.x[:2*n].reshape(n, 2)\n    radii = result.x[2*n:]\n    \n    return {\n        'centers': centers,\n        'radii': radii,\n        'sum': np.sum(radii)\n    }\n\ndef expand_radii(centers, radii, n):\n    \"\"\"Expand radii as much as possible while maintaining constraints.\"\"\"\n    expanded_radii = radii.copy()\n    \n    for iteration in range(50):\n        improved = False\n        for i in range(n):\n            # Maximum radius based on square boundaries\n            max_r = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            # Maximum radius based on other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = min(max_r, dist - expanded_radii[j])\n            \n            # Try to expand\n            if max_r > expanded_radii[i] + 1e-6:\n                expanded_radii[i] = max_r - 1e-6\n                improved = True\n        \n        if not improved:\n            break\n    \n    return {\n        'centers': centers,\n        'radii': expanded_radii,\n        'sum': np.sum(expanded_radii)\n    }\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-09T15:34:29.178516",
  "cost_data": null
}