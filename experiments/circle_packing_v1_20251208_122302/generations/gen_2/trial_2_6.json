{
  "trial_id": "trial_2_6",
  "generation": 2,
  "parent_id": "trial_1_13",
  "code": "",
  "metrics": {},
  "prompt": "Significantly improve this grid-based optimization approach:\n\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    # Try different initial grid configurations\n    configurations = [\n        (4, 7, False),  # 4 columns, 7 rows, no offset\n        (5, 6, False),  # 5 columns, 6 rows, no offset\n        (6, 5, False),  # 6 columns, 5 rows, no offset\n        (7, 4, False),  # 7 columns, 4 rows, no offset\n        (5, 6, True),   # 5 columns, 6 rows, hexagonal offset\n        (6, 5, True),   # 6 columns, 5 rows, hexagonal offset\n    ]\n    \n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    for cols, rows, hexagonal in configurations:\n        if cols * rows < 26:\n            continue\n            \n        centers, radii, sum_radii = try_optimized_grid(cols, rows, 26, hexagonal)\n        \n        if sum_radii > best_sum_radii:\n            best_sum_radii = sum_radii\n            best_centers = centers\n            best_radii = radii\n    \n    return best_centers, best_radii, best_sum_radii\n\n\ndef try_optimized_grid(cols, rows, n_circles, hexagonal=False):\n    \"\"\"\n    Try a specific grid configuration with optimization.\n    \n    Args:\n        cols: number of columns\n        rows: number of rows\n        n_circles: number of circles to place (26)\n        hexagonal: whether to use hexagonal offset for alternate rows\n    \n    Returns:\n        centers, radii, sum_radii\n    \"\"\"\n    # Step 1: Generate initial grid\n    centers = generate_initial_grid(cols, rows, n_circles, hexagonal)\n    \n    # Step 2: Optimize positions and radii\n    centers, radii = optimize_packing(centers)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef generate_initial_grid(cols, rows, n_circles, hexagonal=False):\n    \"\"\"Generate initial grid positions.\"\"\"\n    dx = 1.0 / (cols + 0.5) if hexagonal else 1.0 / cols\n    dy = 1.0 / rows\n    \n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n_circles:\n                break\n            \n            # Apply hexagonal offset to alternate rows\n            offset = (dx / 2.0) if (hexagonal and i % 2 == 1) else 0.0\n            \n            x = (j + 0.5) * dx + offset\n            y = (i + 0.5) * dy\n            \n            # Ensure within bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n        \n        if len(centers) >= n_circles:\n            break\n    \n    return np.array(centers[:n_circles])\n\n\ndef optimize_packing(initial_centers, max_iterations=3):\n    \"\"\"\n    Optimize circle packing starting from initial positions.\n    Uses alternating optimization: first optimize positions with uniform radii,\n    then optimize radii with fixed positions.\n    \"\"\"\n    centers = initial_centers.copy()\n    n_circles = len(centers)\n    \n    best_centers = centers.copy()\n    best_radii = calculate_optimal_radii(centers)\n    best_sum = np.sum(best_radii)\n    \n    for iteration in range(max_iterations):\n        # Step 1: Optimize positions with uniform radii\n        centers = optimize_positions(centers)\n        \n        # Step 2: Calculate optimal radii for these positions\n        radii = calculate_optimal_radii(centers)\n        \n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n        else:\n            # If no improvement, try small random perturbations\n            centers = best_centers + np.random.normal(0, 0.01, best_centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n    \n    return best_centers, best_radii\n\n\ndef optimize_positions(centers):\n    \"\"\"Optimize circle positions to maximize minimum pairwise distance.\"\"\"\n    n_circles = len(centers)\n    \n    def objective(x):\n        \"\"\"Minimize negative of minimum distance (to maximize min distance).\"\"\"\n        positions = x.reshape(n_circles, 2)\n        \n        # Penalty for going out of bounds\n        penalty = 0\n        margin = 0.02  # Keep circles away from edges\n        for pos in positions:\n            if pos[0] < margin or pos[0] > 1 - margin:\n                penalty += 100 * (margin - min(pos[0], 1 - pos[0])) ** 2\n            if pos[1] < margin or pos[1] > 1 - margin:\n                penalty += 100 * (margin - min(pos[1], 1 - pos[1])) ** 2\n        \n        # Calculate pairwise distances\n        dists = pdist(positions)\n        min_dist = np.min(dists) if len(dists) > 0 else 0\n        \n        # We want to maximize min_dist, so minimize its negative\n        return -min_dist + penalty\n    \n    # Bounds: keep all positions within [0, 1]\n    bounds = [(0.02, 0.98)] * (2 * n_circles)\n    \n    # Optimize\n    x0 = centers.flatten()\n    \n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 100}\n    )\n    \n    optimized_centers = result.x.reshape(n_circles, 2)\n    \n    return optimized_centers\n\n\ndef calculate_optimal_radii(centers):\n    \"\"\"\n    Calculate optimal radii for given center positions.\n    Each circle gets the maximum radius that doesn't violate constraints.\n    \"\"\"\n    n_circles = len(centers)\n    radii = np.zeros(n_circles)\n    \n    # Calculate distance matrix\n    dist_matrix = squareform(pdist(centers))\n    np.fill_diagonal(dist_matrix, np.inf)\n    \n    for i in range(n_circles):\n        # Constraint 1: Distance to nearest neighbor\n        min_neighbor_dist = np.min(dist_matrix[i])\n        r_neighbor = min_neighbor_dist / 2.0\n        \n        # Constraint 2: Distance to boundaries\n        x, y = centers[i]\n        r_boundary = min(x, 1 - x, y, 1 - y)\n        \n        # Take the minimum\n        radii[i] = min(r_neighbor, r_boundary)\n    \n    return radii\n\n\ndef optimize_radii_directly(centers):\n    \"\"\"\n    Alternative: Optimize radii directly to maximize sum while satisfying constraints.\n    This allows for non-uniform radii.\n    \"\"\"\n    n_circles = len(centers)\n    dist_matrix = squareform(pdist(centers))\n    np.fill_diagonal(dist_matrix, np.inf)\n    \n    def objective(radii):\n        \"\"\"Maximize sum of radii (minimize negative sum).\"\"\"\n        return -np.sum(radii)\n    \n    def constraint_no_overlap(radii, i, j):\n        \"\"\"Circles i and j should not overlap.\"\"\"\n        return dist_matrix[i, j] - (radii[i] + radii[j])\n    \n    def constraint_boundary(radii, i, axis, side):\n        \"\"\"Circle i should stay within boundary.\"\"\"\n        if axis == 0:  # x-axis\n            if side == 0:  # left\n                return centers[i, 0] - radii[i]\n            else:  # right\n                return 1 - centers[i, 0] - radii[i]\n        else:  # y-axis\n            if side == 0:  # bottom\n                return centers[i, 1] - radii[i]\n            else:  # top\n                return 1 - centers[i, 1] - radii[i]\n    \n    # Build constraints\n    constraints = []\n    \n    # No overlap constraints\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            constraints.append({\n                'type': 'ineq',\n                'fun': constraint_no_overlap,\n                'args': (i, j)\n            })\n    \n    # Boundary constraints\n    for i in range(n_circles):\n        for axis in [0, 1]:\n            for side in [0, 1]:\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': constraint_boundary,\n                    'args': (i, axis, side)\n                })\n    \n    # Initial guess: use simple calculation\n    radii_init = calculate_optimal_radii(centers)\n    \n    # Bounds: radii must be positive and reasonable\n    bounds = [(0.001, 0.5)] * n_circles\n    \n    # Optimize\n    result = minimize(\n        objective,\n        radii_init,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 200}\n    )\n    \n    if result.success:\n        return result.x\n    else:\n        # Fall back to simple calculation\n        return radii_init\n\n\ndef run_packing():\n    return construct_packing()\n\n\n# Test the implementation\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Radius range: [{np.min(radii):.6f}, {np.max(radii):.6f}]\")\n    print(f\"Radius std dev: {np.std(radii):.6f}\")\n    print(f\"\\nFirst 5 centers:\")\n    print(centers[:5])\n    print(f\"\\nFirst 5 radii:\")\n    print(radii[:5])\n    \n    # Verify constraints\n    print(\"\\n=== Verification ===\")\n    \n    # Check all circles are within bounds\n    within_bounds = True\n    for i, (center, r) in enumerate(zip(centers, radii)):\n        x, y = center\n        if x - r < -1e-9 or x + r > 1 + 1e-9 or y - r < -1e-9 or y + r > 1 + 1e-9:\n            print(f\"Circle {i} at ({x:.4f}, {y:.4f}) with r={r:.4f} is OUT OF BOUNDS\")\n            within_bounds = False\n    \n    if within_bounds:\n        print(\"\u2713 All circles are within [0,1]x[0,1]\")\n    \n    # Check no overlaps\n    no_overlaps = True\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist - 1e-6:  # small tolerance for numerical errors\n                print(f\"Circles {i} and {j} OVERLAP: dist={dist:.6f}, min_dist={min_dist:.6f}, gap={dist-min_dist:.6f}\")\n                no_overlaps = False\n    \n    if no_overlaps:\n        print(\"\u2713 No overlaps detected\")\n    \n    print(f\"\\n\u2713 Sum of radii: {sum_radii:.6f}\")\n\nMajor enhancements:\n1. Start with best known grid patterns for 26 circles (research-backed)\n2. Use multi-stage optimization: grid \u2192 local positions \u2192 radii \u2192 joint\n3. Add non-uniform radii optimization (allow different sizes)\n4. Implement boundary-aware optimization for edge circles\n5. Use trust-region methods for better convergence\n\nThis grid-based approach has potential if optimization is stronger.",
  "response": "Here's a significantly improved version with advanced optimization techniques:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution, basinhopping\nfrom scipy.spatial.distance import pdist, squareform\nfrom dataclasses import dataclass\nfrom typing import Tuple, List\nimport warnings\nwarnings.filterwarnings('ignore')\n\n@dataclass\nclass PackingResult:\n    centers: np.ndarray\n    radii: np.ndarray\n    sum_radii: float\n    config: str\n\ndef construct_packing():\n    \"\"\"\n    Enhanced multi-strategy approach for optimal circle packing.\n    \"\"\"\n    # Research-backed configurations for 26 circles\n    configurations = [\n        # (cols, rows, hexagonal, description)\n        (5, 6, True, \"hex_5x6\"),      # Hexagonal is typically better\n        (6, 5, True, \"hex_6x5\"),\n        (4, 7, True, \"hex_4x7\"),\n        (7, 4, True, \"hex_7x4\"),\n        (5, 6, False, \"grid_5x6\"),\n        (6, 5, False, \"grid_6x5\"),\n        # Irregular configurations\n        (None, None, None, \"sunflower\"),  # Sunflower pattern\n        (None, None, None, \"adaptive\"),   # Adaptive placement\n    ]\n    \n    best_result = PackingResult(None, None, 0, \"\")\n    \n    for config in configurations:\n        cols, rows, hexagonal, desc = config\n        \n        try:\n            if desc == \"sunflower\":\n                centers, radii, sum_radii = try_sunflower_pattern(26)\n            elif desc == \"adaptive\":\n                centers, radii, sum_radii = try_adaptive_placement(26)\n            else:\n                centers, radii, sum_radii = try_optimized_grid(cols, rows, 26, hexagonal, desc)\n            \n            if sum_radii > best_result.sum_radii:\n                best_result = PackingResult(centers, radii, sum_radii, desc)\n                print(f\"New best from {desc}: {sum_radii:.6f}\")\n        except Exception as e:\n            print(f\"Config {desc} failed: {e}\")\n            continue\n    \n    # Final global refinement on best result\n    print(\"\\nApplying final global refinement...\")\n    centers, radii = global_refinement(best_result.centers, iterations=3)\n    sum_radii = np.sum(radii)\n    \n    if sum_radii > best_result.sum_radii:\n        best_result = PackingResult(centers, radii, sum_radii, f\"{best_result.config}_refined\")\n        print(f\"Refinement improved to: {sum_radii:.6f}\")\n    \n    return best_result.centers, best_result.radii, best_result.sum_radii\n\n\ndef try_sunflower_pattern(n_circles):\n    \"\"\"\n    Sunflower seed arrangement - often optimal for circular packing.\n    Based on Vogel's method.\n    \"\"\"\n    golden_angle = np.pi * (3 - np.sqrt(5))  # ~137.5 degrees\n    \n    centers = []\n    for i in range(n_circles):\n        # Vogel's method\n        theta = i * golden_angle\n        r = 0.45 * np.sqrt(i / n_circles)  # Scale to fit in unit square\n        \n        x = 0.5 + r * np.cos(theta)\n        y = 0.5 + r * np.sin(theta)\n        \n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Optimize this initial configuration\n    centers, radii = multi_stage_optimization(centers)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef try_adaptive_placement(n_circles):\n    \"\"\"\n    Adaptive placement: place circles one by one in positions that maximize radius.\n    \"\"\"\n    centers = []\n    \n    # Start with center\n    centers.append([0.5, 0.5])\n    \n    # Place remaining circles\n    for i in range(1, n_circles):\n        best_pos = None\n        best_radius = 0\n        \n        # Try multiple candidate positions\n        n_candidates = 50\n        candidates = np.random.uniform(0.05, 0.95, (n_candidates, 2))\n        \n        for candidate in candidates:\n            # Calculate maximum possible radius at this position\n            r = calculate_max_radius_at_position(candidate, centers)\n            \n            if r > best_radius:\n                best_radius = r\n                best_pos = candidate\n        \n        if best_pos is not None:\n            centers.append(best_pos)\n    \n    centers = np.array(centers)\n    \n    # Optimize\n    centers, radii = multi_stage_optimization(centers)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef calculate_max_radius_at_position(pos, existing_centers):\n    \"\"\"Calculate maximum radius for a circle at given position.\"\"\"\n    if len(existing_centers) == 0:\n        return min(pos[0], 1 - pos[0], pos[1], 1 - pos[1])\n    \n    centers_array = np.array(existing_centers)\n    \n    # Distance to boundaries\n    r_boundary = min(pos[0], 1 - pos[0], pos[1], 1 - pos[1])\n    \n    # Distance to existing circles (assume they have uniform radius)\n    dists = np.linalg.norm(centers_array - pos, axis=1)\n    r_neighbor = np.min(dists) / 2.0 if len(dists) > 0 else r_boundary\n    \n    return min(r_boundary, r_neighbor)\n\n\ndef try_optimized_grid(cols, rows, n_circles, hexagonal=False, desc=\"\"):\n    \"\"\"Enhanced grid-based approach with better initialization.\"\"\"\n    centers = generate_initial_grid(cols, rows, n_circles, hexagonal)\n    \n    # Multi-stage optimization\n    centers, radii = multi_stage_optimization(centers)\n    \n    return centers, radii, np.sum(radii)\n\n\ndef generate_initial_grid(cols, rows, n_circles, hexagonal=False):\n    \"\"\"Generate initial grid with better spacing.\"\"\"\n    if hexagonal:\n        # Hexagonal packing with proper spacing\n        dx = 1.0 / (cols + 0.5)\n        dy = 1.0 / (rows * 0.866)  # sqrt(3)/2 for hexagonal\n    else:\n        dx = 1.0 / (cols + 1)\n        dy = 1.0 / (rows + 1)\n    \n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n_circles:\n                break\n            \n            if hexagonal and i % 2 == 1:\n                offset = dx / 2.0\n            else:\n                offset = 0.0\n            \n            x = (j + 1) * dx + offset\n            y = (i + 1) * dy\n            \n            # Better boundary handling\n            margin = 0.03\n            x = np.clip(x, margin, 1 - margin)\n            y = np.clip(y, margin, 1 - margin)\n            \n            centers.append([x, y])\n        \n        if len(centers) >= n_circles:\n            break\n    \n    return np.array(centers[:n_circles])\n\n\ndef multi_stage_optimization(initial_centers, stages=4):\n    \"\"\"\n    Multi-stage optimization pipeline:\n    1. Coarse position optimization (maximize min distance)\n    2. Fine position optimization (maximize sum of radii)\n    3. Joint position-radii optimization\n    4. Non-uniform radii optimization\n    \"\"\"\n    centers = initial_centers.copy()\n    n_circles = len(centers)\n    \n    # Stage 1: Maximize minimum pairwise distance\n    print(f\"  Stage 1: Maximizing minimum distance...\")\n    centers = optimize_positions_maximin(centers)\n    \n    # Stage 2: Optimize for sum of radii with uniform assumption\n    print(f\"  Stage 2: Optimizing for radius sum...\")\n    centers = optimize_positions_for_radii(centers, iterations=2)\n    \n    # Stage 3: Joint optimization\n    print(f\"  Stage 3: Joint optimization...\")\n    centers, radii = joint_optimization(centers)\n    \n    # Stage 4: Fine-tune radii with non-uniform allowance\n    print(f\"  Stage 4: Non-uniform radii optimization...\")\n    radii = optimize_radii_nonuniform(centers, radii)\n    \n    return centers, radii\n\n\ndef optimize_positions_maximin(centers):\n    \"\"\"Optimize positions to maximize minimum pairwise distance.\"\"\"\n    n_circles = len(centers)\n    \n    def objective(x):\n        positions = x.reshape(n_circles, 2)\n        \n        # Penalty for boundary violations\n        penalty = 0\n        margin = 0.01\n        for pos in positions:\n            if pos[0] < margin:\n                penalty += 1000 * (margin - pos[0]) ** 2\n            if pos[0] > 1 - margin:\n                penalty += 1000 * (pos[0] - (1 - margin)) ** 2\n            if pos[1] < margin:\n                penalty += 1000 * (margin - pos[1]) ** 2\n            if pos[1] > 1 - margin:\n                penalty += 1000 * (pos[1] - (1 - margin)) ** 2\n        \n        # Calculate minimum distance\n        dists = pdist(positions)\n        if len(dists) == 0:\n            return penalty\n        \n        min_dist = np.min(dists)\n        \n        # Also penalize very close pairs more heavily\n        close_pairs = np.sum(np.exp(-50 * (dists - min_dist)))\n        \n        return -min_dist + penalty + 0.01 * close_pairs\n    \n    bounds = [(0.01, 0.99)] * (2 * n_circles)\n    \n    result = minimize(\n        objective,\n        centers.flatten(),\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 200, 'ftol': 1e-8}\n    )\n    \n    return result.x.reshape(n_circles, 2)\n\n\ndef optimize_positions_for_radii(centers, iterations=2):\n    \"\"\"Optimize positions to maximize sum of radii.\"\"\"\n    n_circles = len(centers)\n    \n    for iteration in range(iterations):\n        def objective(x):\n            positions = x.reshape(n_circles, 2)\n            \n            # Calculate radii for these positions\n            radii = calculate_optimal_radii_fast(positions)\n            \n            # Penalty for boundary violations\n            penalty = 0\n            for i, (pos, r) in enumerate(zip(positions, radii)):\n                if pos[0] - r < 0:\n                    penalty += 100 * (r - pos[0]) ** 2\n                if pos[0] + r > 1:\n                    penalty += 100 * (pos[0] + r - 1) ** 2\n                if pos[1] - r < 0:\n                    penalty += 100 * (r - pos[1]) ** 2\n                if pos[1] + r > 1:\n                    penalty += 100 * (pos[1] + r - 1) ** 2\n            \n            return -np.sum(radii) + penalty\n        \n        bounds = [(0.01, 0.99)] * (2 * n_circles)\n        \n        result = minimize(\n            objective,\n            centers.flatten(),\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 150}\n        )\n        \n        centers = result.x.reshape(n_circles, 2)\n    \n    return centers\n\n\ndef joint_optimization(centers):\n    \"\"\"Jointly optimize positions and radii.\"\"\"\n    n_circles = len(centers)\n    radii_init = calculate_optimal_radii_fast(centers)\n    \n    # Combined state: [x1, y1, r1, x2, y2, r2, ...]\n    x0 = np.zeros(3 * n_circles)\n    for i in range(n_circles):\n        x0[3*i] = centers[i, 0]\n        x0[3*i + 1] = centers[i, 1]\n        x0[3*i + 2] = radii_init[i]\n    \n    def objective(x):\n        # Extract positions and radii\n        positions = x.reshape(n_circles, 3)[:, :2]\n        radii = x.reshape(n_circles, 3)[:, 2]\n        \n        # Penalty for overlaps\n        penalty = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(positions[i] - positions[j])\n                overlap = (radii[i] + radii[j]) - dist\n                if overlap > 0:\n                    penalty += 1000 * overlap ** 2\n        \n        # Penalty for boundary violations\n        for i in range(n_circles):\n            x, y, r = positions[i, 0], positions[i, 1], radii[i]\n            if x - r < 0:\n                penalty += 1000 * (r - x) ** 2\n            if x + r > 1:\n                penalty += 1000 * (x + r - 1) ** 2\n            if y - r < 0:\n                penalty += 1000 * (r - y) ** 2\n            if y + r > 1:\n                penalty += 1000 * (y + r - 1) ** 2\n        \n        return -np.sum(radii) + penalty\n    \n    # Bounds\n    bounds = []\n    for i in range(n_circles):\n        bounds.append((0.01, 0.99))  # x\n        bounds.append((0.01, 0.99))  # y\n        bounds.append((0.001, 0.5))  # r\n    \n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 200}\n    )\n    \n    optimized = result.x.reshape(n_circles, 3)\n    centers = optimized[:, :2]\n    radii = optimized[:, 2]\n    \n    return centers, radii\n\n\ndef optimize_radii_nonuniform(centers, radii_init):\n    \"\"\"Optimize radii allowing non-uniform sizes.\"\"\"\n    n_circles = len(centers)\n    dist_matrix = squareform(pdist(centers))\n    np.fill_diagonal(dist_matrix, np.inf)\n    \n    def objective(radii):\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # No overlap\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda r, i=i, j=j: dist_matrix[i, j] - (r[i] + r[j])\n            })\n    \n    # Boundaries\n    for i in range(n_circles):\n        x, y = centers[i]\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i, x=x: x - r[i]})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i, x=x: 1 - x - r[i]})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i, y=y: y - r[i]})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i, y=y: 1 - y - r[i]})\n    \n    bounds = [(0.001, 0.5)] * n_circles\n    \n    result = minimize(\n        objective,",
  "reasoning": "Here's a significantly improved version with advanced optimization techniques:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution, basinhopping\nfrom scipy.spatial.distance import pdist, squareform\nfrom dataclasses import dataclass\nfrom typing import Tuple, List\nimport warnings\nwarnings.filterwarnings('ignore')\n\n@dataclass\nclass PackingResult:\n    centers: np.ndarray\n    radii: np.ndarray\n    sum_radii: float\n    config: str\n\ndef construct_packing():\n    \"\"\"\n    Enhanced multi-strategy approach for optimal circle packing.\n    \"\"\"\n    # Research-backed configurations for 26 circles\n    configurations = [\n        # (cols, rows, hexagonal, description)\n        (5, 6, True, \"hex_5x6\"),      # Hexagonal is typically better\n        (6, 5, True, \"hex_6x5\"),\n        (4, 7, True, \"hex_4x7\"),\n        (7, 4, True, \"hex_7x4\"),\n        (5, 6, False, \"grid_5x6\"),\n        (6, 5, False, \"grid_6x5\"),\n        # Irregular configurations\n        (None, None, None, \"sunflower\"),  # Sunflower pattern\n        (None, None, None, \"adaptive\"),   # Adaptive placement\n    ]\n    \n    best_result = PackingResult(None, None, 0, \"\")\n    \n    for config in configurations:\n        cols, rows, hexagonal, desc = config\n        \n        try:\n            if desc == \"sunflower\":\n                centers, radii, sum_radii = try_sunflower_pattern(26)\n            elif desc == \"adaptive\":\n                centers, radii, sum_radii = try_adaptive_placement(26)\n            else:\n                centers, radii, sum_radii = try_optimized_grid(cols, rows, 26, hexagonal, desc)\n            \n            if sum_radii > best_result.sum_radii:\n                best_result = PackingResult(centers, radii, sum_radii, desc)\n                print(f\"New best from {desc}: {sum_radii:.6f}\")\n        except Exception as e:\n            print(f\"Config {desc} failed: {e}\")\n            continue\n    \n    # Final global refinement on best result\n    print(\"\\nApplying final global refinement...\")\n    centers, radii = global_refinement(best_result.centers, iterations=3)\n    sum_radii = np.sum(radii)\n    \n    if sum_radii > best_result.sum_radii:\n        best_result = PackingResult(centers, radii, sum_radii, f\"{best_result.config}_refined\")\n        print(f\"Refinement improved to: {sum_radii:.6f}\")\n    \n    return best_result.centers, best_result.radii, best_result.sum_radii\n\ndef try_sunflower_pattern(n_circles):\n    \"\"\"\n    Sunflower seed arrangement - often optimal for circular packing.\n    Based on Vogel's method.\n    \"\"\"\n    golden_angle = np.pi * (3 - np.sqrt(5))  # ~137.5 degrees\n    \n    centers = []\n    for i in range(n_circles):\n        # Vogel's method\n        theta = i * golden_angle\n        r = 0.45 * np.sqrt(i / n_circles)  # Scale to fit in unit square\n        \n        x = 0.5 + r * np.cos(theta)\n        y = 0.5 + r * np.sin(theta)\n        \n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Optimize this initial configuration\n    centers, radii = multi_stage_optimization(centers)\n    \n    return centers, radii, np.sum(radii)\n\ndef try_adaptive_placement(n_circles):\n    \"\"\"\n    Adaptive placement: place circles one by one in positions that maximize radius.\n    \"\"\"\n    centers = []\n    \n    # Start with center\n    centers.append([0.5, 0.5])\n    \n    # Place remaining circles\n    for i in range(1, n_circles):\n        best_pos = None\n        best_radius = 0\n        \n        # Try multiple candidate positions\n        n_candidates = 50\n        candidates = np.random.uniform(0.05, 0.95, (n_candidates, 2))\n        \n        for candidate in candidates:\n            # Calculate maximum possible radius at this position\n            r = calculate_max_radius_at_position(candidate, centers)\n            \n            if r > best_radius:\n                best_radius = r\n                best_pos = candidate\n        \n        if best_pos is not None:\n            centers.append(best_pos)\n    \n    centers = np.array(centers)\n    \n    # Optimize\n    centers, radii = multi_stage_optimization(centers)\n    \n    return centers, radii, np.sum(radii)\n\ndef calculate_max_radius_at_position(pos, existing_centers):\n    \"\"\"Calculate maximum radius for a circle at given position.\"\"\"\n    if len(existing_centers) == 0:\n        return min(pos[0], 1 - pos[0], pos[1], 1 - pos[1])\n    \n    centers_array = np.array(existing_centers)\n    \n    # Distance to boundaries\n    r_boundary = min(pos[0], 1 - pos[0], pos[1], 1 - pos[1])\n    \n    # Distance to existing circles (assume they have uniform radius)\n    dists = np.linalg.norm(centers_array - pos, axis=1)\n    r_neighbor = np.min(dists) / 2.0 if len(dists) > 0 else r_boundary\n    \n    return min(r_boundary, r_neighbor)\n\ndef try_optimized_grid(cols, rows, n_circles, hexagonal=False, desc=\"\"):\n    \"\"\"Enhanced grid-based approach with better initialization.\"\"\"\n    centers = generate_initial_grid(cols, rows, n_circles, hexagonal)\n    \n    # Multi-stage optimization\n    centers, radii = multi_stage_optimization(centers)\n    \n    return centers, radii, np.sum(radii)\n\ndef generate_initial_grid(cols, rows, n_circles, hexagonal=False):\n    \"\"\"Generate initial grid with better spacing.\"\"\"\n    if hexagonal:\n        # Hexagonal packing with proper spacing\n        dx = 1.0 / (cols + 0.5)\n        dy = 1.0 / (rows * 0.866)  # sqrt(3)/2 for hexagonal\n    else:\n        dx = 1.0 / (cols + 1)\n        dy = 1.0 / (rows + 1)\n    \n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            if len(centers) >= n_circles:\n                break\n            \n            if hexagonal and i % 2 == 1:\n                offset = dx / 2.0\n            else:\n                offset = 0.0\n            \n            x = (j + 1) * dx + offset\n            y = (i + 1) * dy\n            \n            # Better boundary handling\n            margin = 0.03\n            x = np.clip(x, margin, 1 - margin)\n            y = np.clip(y, margin, 1 - margin)\n            \n            centers.append([x, y])\n        \n        if len(centers) >= n_circles:\n            break\n    \n    return np.array(centers[:n_circles])\n\ndef multi_stage_optimization(initial_centers, stages=4):\n    \"\"\"\n    Multi-stage optimization pipeline:\n    1. Coarse position optimization (maximize min distance)\n    2. Fine position optimization (maximize sum of radii)\n    3. Joint position-radii optimization\n    4. Non-uniform radii optimization\n    \"\"\"\n    centers = initial_centers.copy()\n    n_circles = len(centers)\n    \n    # Stage 1: Maximize minimum pairwise distance\n    print(f\"  Stage 1: Maximizing minimum distance...\")\n    centers = optimize_positions_maximin(centers)\n    \n    # Stage 2: Optimize for sum of radii with uniform assumption\n    print(f\"  Stage 2: Optimizing for radius sum...\")\n    centers = optimize_positions_for_radii(centers, iterations=2)\n    \n    # Stage 3: Joint optimization\n    print(f\"  Stage 3: Joint optimization...\")\n    centers, radii = joint_optimization(centers)\n    \n    # Stage 4: Fine-tune radii with non-uniform allowance\n    print(f\"  Stage 4: Non-uniform radii optimization...\")\n    radii = optimize_radii_nonuniform(centers, radii)\n    \n    return centers, radii\n\ndef optimize_positions_maximin(centers):\n    \"\"\"Optimize positions to maximize minimum pairwise distance.\"\"\"\n    n_circles = len(centers)\n    \n    def objective(x):\n        positions = x.reshape(n_circles, 2)\n        \n        # Penalty for boundary violations\n        penalty = 0\n        margin = 0.01\n        for pos in positions:\n            if pos[0] < margin:\n                penalty += 1000 * (margin - pos[0]) ** 2\n            if pos[0] > 1 - margin:\n                penalty += 1000 * (pos[0] - (1 - margin)) ** 2\n            if pos[1] < margin:\n                penalty += 1000 * (margin - pos[1]) ** 2\n            if pos[1] > 1 - margin:\n                penalty += 1000 * (pos[1] - (1 - margin)) ** 2\n        \n        # Calculate minimum distance\n        dists = pdist(positions)\n        if len(dists) == 0:\n            return penalty\n        \n        min_dist = np.min(dists)\n        \n        # Also penalize very close pairs more heavily\n        close_pairs = np.sum(np.exp(-50 * (dists - min_dist)))\n        \n        return -min_dist + penalty + 0.01 * close_pairs\n    \n    bounds = [(0.01, 0.99)] * (2 * n_circles)\n    \n    result = minimize(\n        objective,\n        centers.flatten(),\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 200, 'ftol': 1e-8}\n    )\n    \n    return result.x.reshape(n_circles, 2)\n\ndef optimize_positions_for_radii(centers, iterations=2):\n    \"\"\"Optimize positions to maximize sum of radii.\"\"\"\n    n_circles = len(centers)\n    \n    for iteration in range(iterations):\n        def objective(x):\n            positions = x.reshape(n_circles, 2)\n            \n            # Calculate radii for these positions\n            radii = calculate_optimal_radii_fast(positions)\n            \n            # Penalty for boundary violations\n            penalty = 0\n            for i, (pos, r) in enumerate(zip(positions, radii)):\n                if pos[0] - r < 0:\n                    penalty += 100 * (r - pos[0]) ** 2\n                if pos[0] + r > 1:\n                    penalty += 100 * (pos[0] + r - 1) ** 2\n                if pos[1] - r < 0:\n                    penalty += 100 * (r - pos[1]) ** 2\n                if pos[1] + r > 1:\n                    penalty += 100 * (pos[1] + r - 1) ** 2\n            \n            return -np.sum(radii) + penalty\n        \n        bounds = [(0.01, 0.99)] * (2 * n_circles)\n        \n        result = minimize(\n            objective,\n            centers.flatten(),\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 150}\n        )\n        \n        centers = result.x.reshape(n_circles, 2)\n    \n    return centers\n\ndef joint_optimization(centers):\n    \"\"\"Jointly optimize positions and radii.\"\"\"\n    n_circles = len(centers)\n    radii_init = calculate_optimal_radii_fast(centers)\n    \n    # Combined state: [x1, y1, r1, x2, y2, r2, ...]\n    x0 = np.zeros(3 * n_circles)\n    for i in range(n_circles):\n        x0[3*i] = centers[i, 0]\n        x0[3*i + 1] = centers[i, 1]\n        x0[3*i + 2] = radii_init[i]\n    \n    def objective(x):\n        # Extract positions and radii\n        positions = x.reshape(n_circles, 3)[:, :2]\n        radii = x.reshape(n_circles, 3)[:, 2]\n        \n        # Penalty for overlaps\n        penalty = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(positions[i] - positions[j])\n                overlap = (radii[i] + radii[j]) - dist\n                if overlap > 0:\n                    penalty += 1000 * overlap ** 2\n        \n        # Penalty for boundary violations\n        for i in range(n_circles):\n            x, y, r = positions[i, 0], positions[i, 1], radii[i]\n            if x - r < 0:\n                penalty += 1000 * (r - x) ** 2\n            if x + r > 1:\n                penalty += 1000 * (x + r - 1) ** 2\n            if y - r < 0:\n                penalty += 1000 * (r - y) ** 2\n            if y + r > 1:\n                penalty += 1000 * (y + r - 1) ** 2\n        \n        return -np.sum(radii) + penalty\n    \n    # Bounds\n    bounds = []\n    for i in range(n_circles):\n        bounds.append((0.01, 0.99))  # x\n        bounds.append((0.01, 0.99))  # y\n        bounds.append((0.001, 0.5))  # r\n    \n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 200}\n    )\n    \n    optimized = result.x.reshape(n_circles, 3)\n    centers = optimized[:, :2]\n    radii = optimized[:, 2]\n    \n    return centers, radii\n\ndef optimize_radii_nonuniform(centers, radii_init):\n    \"\"\"Optimize radii allowing non-uniform sizes.\"\"\"\n    n_circles = len(centers)\n    dist_matrix = squareform(pdist(centers))\n    np.fill_diagonal(dist_matrix, np.inf)\n    \n    def objective(radii):\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # No overlap\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda r, i=i, j=j: dist_matrix[i, j] - (r[i] + r[j])\n            })\n    \n    # Boundaries\n    for i in range(n_circles):\n        x, y = centers[i]\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i, x=x: x - r[i]})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i, x=x: 1 - x - r[i]})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i, y=y: y - r[i]})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i, y=y: 1 - y - r[i]})\n    \n    bounds = [(0.001, 0.5)] * n_circles\n    \n    result = minimize(\n        objective,",
  "timestamp": "2025-12-08T12:40:43.995147",
  "cost_data": null
}