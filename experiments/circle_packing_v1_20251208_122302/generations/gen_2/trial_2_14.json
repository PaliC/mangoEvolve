{
  "trial_id": "trial_2_14",
  "generation": 2,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write an adaptive simulated annealing with restarts for 26 circles.\n\nStrategy:\n1. Simulated annealing with adaptive temperature schedule\n2. Smart perturbations:\n   - Move circles (magnitude decreases with temperature)\n   - Adjust radii\n   - Swap circle positions\n3. Acceptance criterion: Metropolis with constraint penalties\n4. Restart mechanism: if stuck, restart from perturbed best solution\n5. Multiple independent runs with different cooling schedules\n\nAdaptive SA can escape local optima while converging to good solutions.\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport copy\n\n@dataclass\nclass CircleConfig:\n    x: float\n    y: float\n    r: float\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, n_circles: int = 26, container_radius: float = 1.0):\n        self.n_circles = n_circles\n        self.container_radius = container_radius\n        self.best_solution = None\n        self.best_energy = float('inf')\n        self.energy_history = []\n        \n    def initialize_solution(self, min_radius: float = 0.01) -> List[CircleConfig]:\n        \"\"\"Initialize circles with random positions and radii\"\"\"\n        circles = []\n        for i in range(self.n_circles):\n            # Random position within container\n            angle = np.random.uniform(0, 2 * np.pi)\n            r_pos = np.random.uniform(0, 0.5) * self.container_radius\n            x = r_pos * np.cos(angle)\n            y = r_pos * np.sin(angle)\n            \n            # Initial radius\n            radius = np.random.uniform(min_radius, 0.15)\n            circles.append(CircleConfig(x, y, radius))\n        \n        return circles\n    \n    def calculate_energy(self, circles: List[CircleConfig], penalty_weight: float = 1000.0) -> float:\n        \"\"\"\n        Calculate energy (negative total area + penalties for violations)\n        Lower energy is better\n        \"\"\"\n        total_area = sum(np.pi * c.r ** 2 for c in circles)\n        penalty = 0.0\n        \n        # Penalty for circles outside container\n        for c in circles:\n            dist_from_center = np.sqrt(c.x**2 + c.y**2)\n            if dist_from_center + c.r > self.container_radius:\n                violation = (dist_from_center + c.r - self.container_radius)\n                penalty += penalty_weight * violation ** 2\n        \n        # Penalty for overlapping circles\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                dist = np.sqrt((circles[i].x - circles[j].x)**2 + \n                             (circles[i].y - circles[j].y)**2)\n                min_dist = circles[i].r + circles[j].r\n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    penalty += penalty_weight * overlap ** 2\n        \n        # We want to maximize area, so minimize negative area\n        return -total_area + penalty\n    \n    def is_feasible(self, circles: List[CircleConfig], tolerance: float = 1e-6) -> bool:\n        \"\"\"Check if solution is feasible (no overlaps, all inside container)\"\"\"\n        # Check container constraints\n        for c in circles:\n            dist_from_center = np.sqrt(c.x**2 + c.y**2)\n            if dist_from_center + c.r > self.container_radius + tolerance:\n                return False\n        \n        # Check overlap constraints\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                dist = np.sqrt((circles[i].x - circles[j].x)**2 + \n                             (circles[i].y - circles[j].y)**2)\n                if dist < circles[i].r + circles[j].r - tolerance:\n                    return False\n        \n        return True\n    \n    def perturb_solution(self, circles: List[CircleConfig], temperature: float, \n                        move_prob: float = 0.6, radius_prob: float = 0.3) -> List[CircleConfig]:\n        \"\"\"Apply random perturbation based on temperature\"\"\"\n        new_circles = copy.deepcopy(circles)\n        \n        # Temperature-dependent step size\n        move_scale = 0.3 * temperature\n        radius_scale = 0.05 * temperature\n        \n        rand = np.random.random()\n        \n        if rand < move_prob:\n            # Move a random circle\n            idx = np.random.randint(len(new_circles))\n            dx = np.random.normal(0, move_scale)\n            dy = np.random.normal(0, move_scale)\n            new_circles[idx].x += dx\n            new_circles[idx].y += dy\n            \n        elif rand < move_prob + radius_prob:\n            # Adjust radius of a random circle\n            idx = np.random.randint(len(new_circles))\n            dr = np.random.normal(0, radius_scale)\n            new_circles[idx].r = max(0.01, new_circles[idx].r + dr)\n            \n        else:\n            # Swap positions of two circles\n            idx1, idx2 = np.random.choice(len(new_circles), 2, replace=False)\n            new_circles[idx1].x, new_circles[idx2].x = new_circles[idx2].x, new_circles[idx1].x\n            new_circles[idx1].y, new_circles[idx2].y = new_circles[idx2].y, new_circles[idx1].y\n        \n        return new_circles\n    \n    def adaptive_cooling_schedule(self, iteration: int, max_iterations: int, \n                                  initial_temp: float, cooling_rate: float,\n                                  adaptive: bool = True) -> float:\n        \"\"\"Calculate temperature with adaptive cooling\"\"\"\n        if adaptive:\n            # Adaptive exponential cooling with reheating\n            base_temp = initial_temp * (cooling_rate ** iteration)\n            \n            # Periodic reheating to escape local optima\n            reheat_period = max_iterations // 5\n            if reheat_period > 0 and iteration % reheat_period == 0 and iteration > 0:\n                base_temp *= 5.0\n            \n            return base_temp\n        else:\n            # Standard exponential cooling\n            return initial_temp * (cooling_rate ** iteration)\n    \n    def acceptance_probability(self, current_energy: float, new_energy: float, \n                              temperature: float) -> float:\n        \"\"\"Metropolis acceptance criterion\"\"\"\n        if new_energy < current_energy:\n            return 1.0\n        else:\n            return np.exp(-(new_energy - current_energy) / temperature)\n    \n    def run_sa_iteration(self, initial_solution: List[CircleConfig], \n                        max_iterations: int, initial_temp: float, \n                        cooling_rate: float, adaptive: bool = True) -> Tuple[List[CircleConfig], float]:\n        \"\"\"Run one simulated annealing iteration\"\"\"\n        current_solution = copy.deepcopy(initial_solution)\n        current_energy = self.calculate_energy(current_solution)\n        \n        best_solution = copy.deepcopy(current_solution)\n        best_energy = current_energy\n        \n        no_improvement_count = 0\n        \n        for iteration in range(max_iterations):\n            temperature = self.adaptive_cooling_schedule(\n                iteration, max_iterations, initial_temp, cooling_rate, adaptive\n            )\n            \n            # Generate new solution\n            new_solution = self.perturb_solution(current_solution, temperature)\n            new_energy = self.calculate_energy(new_solution)\n            \n            # Accept or reject\n            if np.random.random() < self.acceptance_probability(current_energy, new_energy, temperature):\n                current_solution = new_solution\n                current_energy = new_energy\n                \n                # Update best solution\n                if current_energy < best_energy:\n                    best_solution = copy.deepcopy(current_solution)\n                    best_energy = current_energy\n                    no_improvement_count = 0\n                else:\n                    no_improvement_count += 1\n            else:\n                no_improvement_count += 1\n            \n            # Early restart if stuck\n            if no_improvement_count > max_iterations // 10:\n                # Perturb best solution and continue\n                current_solution = self.perturb_solution(best_solution, temperature * 2)\n                current_energy = self.calculate_energy(current_solution)\n                no_improvement_count = 0\n            \n            # Log progress\n            if iteration % (max_iterations // 10) == 0:\n                feasible = self.is_feasible(best_solution)\n                total_area = sum(np.pi * c.r ** 2 for c in best_solution)\n                print(f\"  Iteration {iteration}/{max_iterations}, Temp: {temperature:.4f}, \"\n                      f\"Energy: {best_energy:.4f}, Area: {total_area:.4f}, Feasible: {feasible}\")\n        \n        return best_solution, best_energy\n    \n    def optimize_with_restarts(self, n_restarts: int = 5, iterations_per_restart: int = 2000,\n                               initial_temp_range: Tuple[float, float] = (1.0, 5.0),\n                               cooling_rate_range: Tuple[float, float] = (0.995, 0.999)) -> List[CircleConfig]:\n        \"\"\"Run multiple SA iterations with different parameters and restarts\"\"\"\n        print(f\"Starting Adaptive Simulated Annealing with {n_restarts} restarts...\")\n        \n        for restart in range(n_restarts):\n            print(f\"\\n=== Restart {restart + 1}/{n_restarts} ===\")\n            \n            # Randomize parameters for each restart\n            initial_temp = np.random.uniform(*initial_temp_range)\n            cooling_rate = np.random.uniform(*cooling_rate_range)\n            \n            # Initialize solution (or perturb best if exists)\n            if restart == 0 or self.best_solution is None:\n                initial_solution = self.initialize_solution()\n            else:\n                # Start from perturbed best solution\n                initial_solution = copy.deepcopy(self.best_solution)\n                for _ in range(10):\n                    initial_solution = self.perturb_solution(initial_solution, 0.5)\n            \n            print(f\"Parameters: T0={initial_temp:.3f}, cooling_rate={cooling_rate:.5f}\")\n            \n            # Run SA\n            solution, energy = self.run_sa_iteration(\n                initial_solution, iterations_per_restart, initial_temp, cooling_rate, adaptive=True\n            )\n            \n            # Update global best\n            if energy < self.best_energy:\n                self.best_solution = copy.deepcopy(solution)\n                self.best_energy = energy\n                print(f\"  *** New best solution found! Energy: {energy:.4f}\")\n            \n            self.energy_history.append(energy)\n        \n        return self.best_solution\n    \n    def visualize_solution(self, circles: List[CircleConfig], title: str = \"Circle Packing\"):\n        \"\"\"Visualize the packing solution\"\"\"\n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        \n        # Draw container\n        container = Circle((0, 0), self.container_radius, fill=False, \n                          edgecolor='black', linewidth=2)\n        ax.add_patch(container)\n        \n        # Draw circles\n        colors = plt.cm.viridis(np.linspace(0, 1, len(circles)))\n        for i, c in enumerate(circles):\n            circle = Circle((c.x, c.y), c.r, fill=True, \n                          facecolor=colors[i], edgecolor='black', \n                          alpha=0.6, linewidth=1)\n            ax.add_patch(circle)\n        \n        # Calculate statistics\n        total_area = sum(np.pi * c.r ** 2 for c in circles)\n        container_area = np.pi * self.container_radius ** 2\n        efficiency = (total_area / container_area) * 100\n        feasible = self.is_feasible(circles)\n        \n        ax.set_xlim(-self.container_radius * 1.1, self.container_radius * 1.1)\n        ax.set_ylim(-self.container_radius * 1.1, self.container_radius * 1.1)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.set_title(f\"{title}\\nCircles: {len(circles)}, Efficiency: {efficiency:.2f}%, \"\n                    f\"Feasible: {feasible}\", fontsize=12)\n        \n        plt.tight_layout()\n        return fig\n\ndef construct_packing(n_circles: int = 26, container_radius: float = 1.0) -> AdaptiveSimulatedAnnealing:\n    \"\"\"\n    Construct a circle packing optimizer\n    \n    Args:\n        n_circles: Number of circles to pack\n        container_radius: Radius of the container circle\n    \n    Returns:\n        AdaptiveSimulatedAnnealing optimizer instance\n    \"\"\"\n    optimizer = AdaptiveSimulatedAnnealing(n_circles=n_circles, container_radius=container_radius)\n    return optimizer\n\ndef run_packing(optimizer: AdaptiveSimulatedAnnealing = None, \n                n_circles: int = 26,\n                container_radius: float = 1.0,\n                n_restarts: int = 5,\n                iterations_per_restart: int = 2000,\n                visualize: bool = True) -> Tuple[List[CircleConfig], float]:\n    \"\"\"\n    Run the adaptive simulated annealing optimization\n    \n    Args:\n        optimizer: Pre-constructed optimizer (optional)\n        n_circles: Number of circles to pack\n        container_radius: Radius of the container\n        n_restarts: Number of restart iterations\n        iterations_per_restart: SA iterations per restart\n        visualize: Whether to visualize the result\n    \n    Returns:\n        Tuple of (best_solution, best_energy)\n    \"\"\"\n    if optimizer is None:\n        optimizer = construct_packing(n_circles, container_radius)\n    \n    # Run optimization\n    best_solution = optimizer.optimize_with_restarts(\n        n_restarts=n_restarts,\n        iterations_per_restart=iterations_per_restart\n    )\n    \n    # Print final results\n    print(\"\\n\" + \"=\"*60)\n    print(\"OPTIMIZATION COMPLETE\")\n    print(\"=\"*60)\n    \n    total_area = sum(np.pi * c.r ** 2 for c in best_solution)\n    container_area = np.pi * optimizer.container_radius ** 2\n    efficiency = (total_area / container_area) * 100\n    feasible = optimizer.is_feasible(best_solution)\n    \n    print(f\"Number of circles: {len(best_solution)}\")\n    print(f\"Total area: {total_area:.6f}\")\n    print(f\"Container area: {container_area:.6f}\")\n    print(f\"Packing efficiency: {efficiency:.2f}%\")\n    print(f\"Solution feasible: {feasible}\")\n    print(f\"Best energy: {optimizer.best_energy:.6f}\")\n    \n    # Print circle details\n    print(\"\\nCircle details:\")\n    for i, c in enumerate(best_solution):\n        print(f\"  Circle {i+1}: x={c.x:.4f}, y={c.y:.4f}, r={c.r:.4f}\")\n    \n    # Visualize\n    if visualize:\n        fig = optimizer.visualize_solution(best_solution, \"Adaptive SA: Best Solution\")\n        plt.savefig('circle_packing_adaptive_sa.png', dpi=150, bbox_inches='tight')\n        print(\"\\nVisualization saved as 'circle_packing_adaptive_sa.png'\")\n        plt.show()\n    \n    return best_solution, optimizer.best_energy\n\n# Example usage\nif __name__ == \"__main__\":\n    # Set random seed for reproducibility\n    np.random.seed(42)\n    \n    # Construct and run optimization\n    print(\"Circle Packing with Adaptive Simulated Annealing\")\n    print(\"=\"*60)\n    \n    optimizer = construct_packing(n_circles=26, container_radius=1.0)\n    solution, energy = run_packing(",
  "reasoning": "```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport copy\n\n@dataclass\nclass CircleConfig:\n    x: float\n    y: float\n    r: float\n\nclass AdaptiveSimulatedAnnealing:\n    def __init__(self, n_circles: int = 26, container_radius: float = 1.0):\n        self.n_circles = n_circles\n        self.container_radius = container_radius\n        self.best_solution = None\n        self.best_energy = float('inf')\n        self.energy_history = []\n        \n    def initialize_solution(self, min_radius: float = 0.01) -> List[CircleConfig]:\n        \"\"\"Initialize circles with random positions and radii\"\"\"\n        circles = []\n        for i in range(self.n_circles):\n            # Random position within container\n            angle = np.random.uniform(0, 2 * np.pi)\n            r_pos = np.random.uniform(0, 0.5) * self.container_radius\n            x = r_pos * np.cos(angle)\n            y = r_pos * np.sin(angle)\n            \n            # Initial radius\n            radius = np.random.uniform(min_radius, 0.15)\n            circles.append(CircleConfig(x, y, radius))\n        \n        return circles\n    \n    def calculate_energy(self, circles: List[CircleConfig], penalty_weight: float = 1000.0) -> float:\n        \"\"\"\n        Calculate energy (negative total area + penalties for violations)\n        Lower energy is better\n        \"\"\"\n        total_area = sum(np.pi * c.r ** 2 for c in circles)\n        penalty = 0.0\n        \n        # Penalty for circles outside container\n        for c in circles:\n            dist_from_center = np.sqrt(c.x**2 + c.y**2)\n            if dist_from_center + c.r > self.container_radius:\n                violation = (dist_from_center + c.r - self.container_radius)\n                penalty += penalty_weight * violation ** 2\n        \n        # Penalty for overlapping circles\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                dist = np.sqrt((circles[i].x - circles[j].x)**2 + \n                             (circles[i].y - circles[j].y)**2)\n                min_dist = circles[i].r + circles[j].r\n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    penalty += penalty_weight * overlap ** 2\n        \n        # We want to maximize area, so minimize negative area\n        return -total_area + penalty\n    \n    def is_feasible(self, circles: List[CircleConfig], tolerance: float = 1e-6) -> bool:\n        \"\"\"Check if solution is feasible (no overlaps, all inside container)\"\"\"\n        # Check container constraints\n        for c in circles:\n            dist_from_center = np.sqrt(c.x**2 + c.y**2)\n            if dist_from_center + c.r > self.container_radius + tolerance:\n                return False\n        \n        # Check overlap constraints\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                dist = np.sqrt((circles[i].x - circles[j].x)**2 + \n                             (circles[i].y - circles[j].y)**2)\n                if dist < circles[i].r + circles[j].r - tolerance:\n                    return False\n        \n        return True\n    \n    def perturb_solution(self, circles: List[CircleConfig], temperature: float, \n                        move_prob: float = 0.6, radius_prob: float = 0.3) -> List[CircleConfig]:\n        \"\"\"Apply random perturbation based on temperature\"\"\"\n        new_circles = copy.deepcopy(circles)\n        \n        # Temperature-dependent step size\n        move_scale = 0.3 * temperature\n        radius_scale = 0.05 * temperature\n        \n        rand = np.random.random()\n        \n        if rand < move_prob:\n            # Move a random circle\n            idx = np.random.randint(len(new_circles))\n            dx = np.random.normal(0, move_scale)\n            dy = np.random.normal(0, move_scale)\n            new_circles[idx].x += dx\n            new_circles[idx].y += dy\n            \n        elif rand < move_prob + radius_prob:\n            # Adjust radius of a random circle\n            idx = np.random.randint(len(new_circles))\n            dr = np.random.normal(0, radius_scale)\n            new_circles[idx].r = max(0.01, new_circles[idx].r + dr)\n            \n        else:\n            # Swap positions of two circles\n            idx1, idx2 = np.random.choice(len(new_circles), 2, replace=False)\n            new_circles[idx1].x, new_circles[idx2].x = new_circles[idx2].x, new_circles[idx1].x\n            new_circles[idx1].y, new_circles[idx2].y = new_circles[idx2].y, new_circles[idx1].y\n        \n        return new_circles\n    \n    def adaptive_cooling_schedule(self, iteration: int, max_iterations: int, \n                                  initial_temp: float, cooling_rate: float,\n                                  adaptive: bool = True) -> float:\n        \"\"\"Calculate temperature with adaptive cooling\"\"\"\n        if adaptive:\n            # Adaptive exponential cooling with reheating\n            base_temp = initial_temp * (cooling_rate ** iteration)\n            \n            # Periodic reheating to escape local optima\n            reheat_period = max_iterations // 5\n            if reheat_period > 0 and iteration % reheat_period == 0 and iteration > 0:\n                base_temp *= 5.0\n            \n            return base_temp\n        else:\n            # Standard exponential cooling\n            return initial_temp * (cooling_rate ** iteration)\n    \n    def acceptance_probability(self, current_energy: float, new_energy: float, \n                              temperature: float) -> float:\n        \"\"\"Metropolis acceptance criterion\"\"\"\n        if new_energy < current_energy:\n            return 1.0\n        else:\n            return np.exp(-(new_energy - current_energy) / temperature)\n    \n    def run_sa_iteration(self, initial_solution: List[CircleConfig], \n                        max_iterations: int, initial_temp: float, \n                        cooling_rate: float, adaptive: bool = True) -> Tuple[List[CircleConfig], float]:\n        \"\"\"Run one simulated annealing iteration\"\"\"\n        current_solution = copy.deepcopy(initial_solution)\n        current_energy = self.calculate_energy(current_solution)\n        \n        best_solution = copy.deepcopy(current_solution)\n        best_energy = current_energy\n        \n        no_improvement_count = 0\n        \n        for iteration in range(max_iterations):\n            temperature = self.adaptive_cooling_schedule(\n                iteration, max_iterations, initial_temp, cooling_rate, adaptive\n            )\n            \n            # Generate new solution\n            new_solution = self.perturb_solution(current_solution, temperature)\n            new_energy = self.calculate_energy(new_solution)\n            \n            # Accept or reject\n            if np.random.random() < self.acceptance_probability(current_energy, new_energy, temperature):\n                current_solution = new_solution\n                current_energy = new_energy\n                \n                # Update best solution\n                if current_energy < best_energy:\n                    best_solution = copy.deepcopy(current_solution)\n                    best_energy = current_energy\n                    no_improvement_count = 0\n                else:\n                    no_improvement_count += 1\n            else:\n                no_improvement_count += 1\n            \n            # Early restart if stuck\n            if no_improvement_count > max_iterations // 10:\n                # Perturb best solution and continue\n                current_solution = self.perturb_solution(best_solution, temperature * 2)\n                current_energy = self.calculate_energy(current_solution)\n                no_improvement_count = 0\n            \n            # Log progress\n            if iteration % (max_iterations // 10) == 0:\n                feasible = self.is_feasible(best_solution)\n                total_area = sum(np.pi * c.r ** 2 for c in best_solution)\n                print(f\"  Iteration {iteration}/{max_iterations}, Temp: {temperature:.4f}, \"\n                      f\"Energy: {best_energy:.4f}, Area: {total_area:.4f}, Feasible: {feasible}\")\n        \n        return best_solution, best_energy\n    \n    def optimize_with_restarts(self, n_restarts: int = 5, iterations_per_restart: int = 2000,\n                               initial_temp_range: Tuple[float, float] = (1.0, 5.0),\n                               cooling_rate_range: Tuple[float, float] = (0.995, 0.999)) -> List[CircleConfig]:\n        \"\"\"Run multiple SA iterations with different parameters and restarts\"\"\"\n        print(f\"Starting Adaptive Simulated Annealing with {n_restarts} restarts...\")\n        \n        for restart in range(n_restarts):\n            print(f\"\\n=== Restart {restart + 1}/{n_restarts} ===\")\n            \n            # Randomize parameters for each restart\n            initial_temp = np.random.uniform(*initial_temp_range)\n            cooling_rate = np.random.uniform(*cooling_rate_range)\n            \n            # Initialize solution (or perturb best if exists)\n            if restart == 0 or self.best_solution is None:\n                initial_solution = self.initialize_solution()\n            else:\n                # Start from perturbed best solution\n                initial_solution = copy.deepcopy(self.best_solution)\n                for _ in range(10):\n                    initial_solution = self.perturb_solution(initial_solution, 0.5)\n            \n            print(f\"Parameters: T0={initial_temp:.3f}, cooling_rate={cooling_rate:.5f}\")\n            \n            # Run SA\n            solution, energy = self.run_sa_iteration(\n                initial_solution, iterations_per_restart, initial_temp, cooling_rate, adaptive=True\n            )\n            \n            # Update global best\n            if energy < self.best_energy:\n                self.best_solution = copy.deepcopy(solution)\n                self.best_energy = energy\n                print(f\"  *** New best solution found! Energy: {energy:.4f}\")\n            \n            self.energy_history.append(energy)\n        \n        return self.best_solution\n    \n    def visualize_solution(self, circles: List[CircleConfig], title: str = \"Circle Packing\"):\n        \"\"\"Visualize the packing solution\"\"\"\n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        \n        # Draw container\n        container = Circle((0, 0), self.container_radius, fill=False, \n                          edgecolor='black', linewidth=2)\n        ax.add_patch(container)\n        \n        # Draw circles\n        colors = plt.cm.viridis(np.linspace(0, 1, len(circles)))\n        for i, c in enumerate(circles):\n            circle = Circle((c.x, c.y), c.r, fill=True, \n                          facecolor=colors[i], edgecolor='black', \n                          alpha=0.6, linewidth=1)\n            ax.add_patch(circle)\n        \n        # Calculate statistics\n        total_area = sum(np.pi * c.r ** 2 for c in circles)\n        container_area = np.pi * self.container_radius ** 2\n        efficiency = (total_area / container_area) * 100\n        feasible = self.is_feasible(circles)\n        \n        ax.set_xlim(-self.container_radius * 1.1, self.container_radius * 1.1)\n        ax.set_ylim(-self.container_radius * 1.1, self.container_radius * 1.1)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.set_title(f\"{title}\\nCircles: {len(circles)}, Efficiency: {efficiency:.2f}%, \"\n                    f\"Feasible: {feasible}\", fontsize=12)\n        \n        plt.tight_layout()\n        return fig\n\ndef construct_packing(n_circles: int = 26, container_radius: float = 1.0) -> AdaptiveSimulatedAnnealing:\n    \"\"\"\n    Construct a circle packing optimizer\n    \n    Args:\n        n_circles: Number of circles to pack\n        container_radius: Radius of the container circle\n    \n    Returns:\n        AdaptiveSimulatedAnnealing optimizer instance\n    \"\"\"\n    optimizer = AdaptiveSimulatedAnnealing(n_circles=n_circles, container_radius=container_radius)\n    return optimizer\n\ndef run_packing(optimizer: AdaptiveSimulatedAnnealing = None, \n                n_circles: int = 26,\n                container_radius: float = 1.0,\n                n_restarts: int = 5,\n                iterations_per_restart: int = 2000,\n                visualize: bool = True) -> Tuple[List[CircleConfig], float]:\n    \"\"\"\n    Run the adaptive simulated annealing optimization\n    \n    Args:\n        optimizer: Pre-constructed optimizer (optional)\n        n_circles: Number of circles to pack\n        container_radius: Radius of the container\n        n_restarts: Number of restart iterations\n        iterations_per_restart: SA iterations per restart\n        visualize: Whether to visualize the result\n    \n    Returns:\n        Tuple of (best_solution, best_energy)\n    \"\"\"\n    if optimizer is None:\n        optimizer = construct_packing(n_circles, container_radius)\n    \n    # Run optimization\n    best_solution = optimizer.optimize_with_restarts(\n        n_restarts=n_restarts,\n        iterations_per_restart=iterations_per_restart\n    )\n    \n    # Print final results\n    print(\"\\n\" + \"=\"*60)\n    print(\"OPTIMIZATION COMPLETE\")\n    print(\"=\"*60)\n    \n    total_area = sum(np.pi * c.r ** 2 for c in best_solution)\n    container_area = np.pi * optimizer.container_radius ** 2\n    efficiency = (total_area / container_area) * 100\n    feasible = optimizer.is_feasible(best_solution)\n    \n    print(f\"Number of circles: {len(best_solution)}\")\n    print(f\"Total area: {total_area:.6f}\")\n    print(f\"Container area: {container_area:.6f}\")\n    print(f\"Packing efficiency: {efficiency:.2f}%\")\n    print(f\"Solution feasible: {feasible}\")\n    print(f\"Best energy: {optimizer.best_energy:.6f}\")\n    \n    # Print circle details\n    print(\"\\nCircle details:\")\n    for i, c in enumerate(best_solution):\n        print(f\"  Circle {i+1}: x={c.x:.4f}, y={c.y:.4f}, r={c.r:.4f}\")\n    \n    # Visualize\n    if visualize:\n        fig = optimizer.visualize_solution(best_solution, \"Adaptive SA: Best Solution\")\n        plt.savefig('circle_packing_adaptive_sa.png', dpi=150, bbox_inches='tight')\n        print(\"\\nVisualization saved as 'circle_packing_adaptive_sa.png'\")\n        plt.show()\n    \n    return best_solution, optimizer.best_energy\n\n# Example usage\nif __name__ == \"__main__\":\n    # Set random seed for reproducibility\n    np.random.seed(42)\n    \n    # Construct and run optimization\n    print(\"Circle Packing with Adaptive Simulated Annealing\")\n    print(\"=\"*60)\n    \n    optimizer = construct_packing(n_circles=26, container_radius=1.0)\n    solution, energy = run_packing(",
  "timestamp": "2025-12-08T12:40:42.934833",
  "cost_data": null
}