{
  "trial_id": "trial_2_1",
  "generation": 2,
  "parent_id": "trial_1_5",
  "code": "",
  "metrics": {},
  "prompt": "Improve this hybrid approach with better constraint handling:\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List, Optional\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Hybrid approach: Random search + local optimization\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Phase 1: Random search to find promising starting points\n    print(\"Phase 1: Random search for initial configurations...\")\n    initial_candidates = random_search_phase(n_circles, n_trials=20)\n    \n    # Phase 2: Local optimization of top candidates\n    print(\"\\nPhase 2: Local optimization of top candidates...\")\n    best_result = local_optimization_phase(initial_candidates, n_circles, top_k=5)\n    \n    if best_result is None:\n        print(\"Optimization failed, using fallback grid packing\")\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    centers, radii, sum_radii = best_result\n    print(f\"\\nFinal result: Sum of radii = {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n    \n    return centers, radii, sum_radii\n\n\ndef random_search_phase(n_circles: int, n_trials: int = 20) -> List[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Phase 1: Generate multiple random configurations with quick local optimization\n    Returns list of (centers, radii, sum_radii) tuples\n    \"\"\"\n    candidates = []\n    \n    for trial in range(n_trials):\n        # Strategy: Mix different initialization strategies\n        if trial < n_trials // 3:\n            # Pure random\n            centers = np.random.rand(n_circles, 2)\n        elif trial < 2 * n_trials // 3:\n            # Grid with noise\n            centers = create_grid_centers(n_circles)\n            centers += np.random.normal(0, 0.05, centers.shape)\n            centers = np.clip(centers, 0.1, 0.9)\n        else:\n            # Hexagonal-like pattern with noise\n            centers = create_hex_centers(n_circles)\n            centers += np.random.normal(0, 0.03, centers.shape)\n            centers = np.clip(centers, 0.1, 0.9)\n        \n        # Compute initial radii based on nearest neighbors\n        radii = compute_initial_radii(centers, n_circles)\n        \n        # Quick local optimization (few iterations)\n        result = quick_optimize(centers, radii, max_iter=100)\n        \n        if result is not None:\n            candidates.append(result)\n            print(f\"  Trial {trial+1}/{n_trials}: sum_radii = {result[2]:.6f}\")\n    \n    # Sort by sum of radii (descending)\n    candidates.sort(key=lambda x: x[2], reverse=True)\n    \n    return candidates\n\n\ndef local_optimization_phase(candidates: List[Tuple], n_circles: int, top_k: int = 5) -> Optional[Tuple]:\n    \"\"\"\n    Phase 2: Intensive local optimization of top candidates\n    \"\"\"\n    best_result = None\n    best_sum_radii = 0\n    \n    # Take top_k candidates\n    top_candidates = candidates[:min(top_k, len(candidates))]\n    \n    for idx, (centers, radii, sum_radii) in enumerate(top_candidates):\n        print(f\"\\n  Optimizing candidate {idx+1}/{len(top_candidates)} (initial sum: {sum_radii:.6f})...\")\n        \n        # Intensive optimization with scipy\n        result = intensive_optimize(centers, radii, n_circles, max_iter=1000)\n        \n        if result is not None:\n            centers_opt, radii_opt, sum_radii_opt = result\n            print(f\"    -> Optimized sum: {sum_radii_opt:.6f}\")\n            \n            if sum_radii_opt > best_sum_radii:\n                best_sum_radii = sum_radii_opt\n                best_result = result\n        \n        # Also try perturbation + re-optimization\n        if result is not None:\n            for perturb in range(2):\n                centers_pert = centers_opt + np.random.normal(0, 0.01, centers_opt.shape)\n                centers_pert = np.clip(centers_pert, 0, 1)\n                radii_pert = radii_opt * (1 + np.random.normal(0, 0.05, radii_opt.shape))\n                radii_pert = np.clip(radii_pert, 0.001, 0.5)\n                \n                result_pert = intensive_optimize(centers_pert, radii_pert, n_circles, max_iter=500)\n                \n                if result_pert is not None and result_pert[2] > best_sum_radii:\n                    best_sum_radii = result_pert[2]\n                    best_result = result_pert\n                    print(f\"    -> Perturbation improved: {best_sum_radii:.6f}\")\n    \n    return best_result\n\n\ndef quick_optimize(centers: np.ndarray, radii: np.ndarray, max_iter: int = 100) -> Optional[Tuple]:\n    \"\"\"Quick optimization with fewer iterations\"\"\"\n    n_circles = len(centers)\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    constraints = create_constraints(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-4}\n        )\n        \n        if result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            if verify_packing(centers_opt, radii_opt, tol=1e-3):\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\n\ndef intensive_optimize(centers: np.ndarray, radii: np.ndarray, n_circles: int, \n                       max_iter: int = 1000) -> Optional[Tuple]:\n    \"\"\"Intensive optimization with more iterations and tighter tolerances\"\"\"\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    constraints = create_constraints(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-8, 'disp': False}\n        )\n        \n        if result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            if verify_packing(centers_opt, radii_opt, tol=1e-4):\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\n\ndef create_constraints(n_circles: int):\n    \"\"\"Create constraint functions for optimization\"\"\"\n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Positive radii\n        constraints.extend(radii)\n        \n        return np.array(constraints)\n    \n    return {'type': 'ineq', 'fun': constraints_func}\n\n\ndef compute_initial_radii(centers: np.ndarray, n_circles: int) -> np.ndarray:\n    \"\"\"Compute initial radii based on nearest neighbor distances and boundaries\"\"\"\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Distance to boundaries\n        dist_to_boundary = min(\n            centers[i, 0], 1 - centers[i, 0],\n            centers[i, 1], 1 - centers[i, 1]\n        )\n        \n        # Distance to nearest neighbor\n        min_dist_to_neighbor = float('inf')\n        for j in range(n_circles):\n            if i != j:\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                min_dist_to_neighbor = min(min_dist_to_neighbor, dist)\n        \n        # Conservative radius estimate\n        radii[i] = min(dist_to_boundary, min_dist_to_neighbor / 2.5) * 0.9\n    \n    return np.clip(radii, 0.01, 0.5)\n\n\ndef create_grid_centers(n_circles: int) -> np.ndarray:\n    \"\"\"Create grid-based initial centers\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    \n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        centers.append([x, y])\n    \n    return np.array(centers)\n\n\ndef create_hex_centers(n_circles: int) -> np.ndarray:\n    \"\"\"Create hexagonal packing initial centers\"\"\"\n    centers = []\n    rows = int(np.ceil(np.sqrt(n_circles)))\n    \n    for row in range(rows):\n        cols = int(np.ceil(n_circles / rows))\n        offset = 0.5 if row % 2 == 1 else 0\n        \n        for col in range(cols):\n            if len(centers) >= n_circles:\n                break\n            \n            x = (col + offset + 0.5) / (cols + 0.5)\n            y = (row + 0.5) / (rows + 0.5)\n            centers.append([x, y])\n    \n    return np.array(centers[:n_circles])\n\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-4) -> bool:\n    \"\"\"Verify that a packing is valid\"\"\"\n    n_circles = len(centers)\n    \n    # Check boundaries\n    for i in range(n_circles):\n        if (centers[i, 0] - radii[i] < -tol or \n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or \n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check overlaps\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    # Check positive radii\n    if np.any(radii <= 0):\n        return False\n    \n    return True\n\n\ndef create_grid_packing(n_circles: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Fallback grid packing\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.5\n    \n    centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) * spacing\n        y = (row + 0.5) * spacing\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n_circles, radius)\n    \n    return centers, radii\n\n\ndef run_packing():\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\n{'='*50}\")\n    print(f\"FINAL RESULTS:\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n    print(f\"{'='*50}\")\n\nEnhancements:\n1. Use trust-constr method with explicit Jacobians for better constraint handling\n2. Add constraint violation repair mechanism between optimization stages\n3. Implement graduated penalty method: start with soft constraints, gradually tighten\n4. Use multiple random restarts with different penalty schedules\n5. Add feasibility restoration phase if constraints are violated\n\nFocus on achieving higher sum_radii while maintaining strict feasibility.",
  "response": "Here's an improved version with better constraint handling using trust-constr, explicit Jacobians, constraint repair, and graduated penalty methods:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom typing import Tuple, List, Optional, Dict\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Enhanced hybrid approach with advanced constraint handling\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Phase 1: Random search with graduated penalties\n    print(\"Phase 1: Random search with graduated penalty method...\")\n    initial_candidates = graduated_random_search(n_circles, n_trials=15)\n    \n    # Phase 2: Constraint repair and refinement\n    print(\"\\nPhase 2: Constraint repair and refinement...\")\n    repaired_candidates = repair_and_refine_phase(initial_candidates, n_circles)\n    \n    # Phase 3: Intensive optimization with trust-constr\n    print(\"\\nPhase 3: Trust-region constrained optimization...\")\n    best_result = trust_region_optimization_phase(repaired_candidates, n_circles, top_k=5)\n    \n    # Phase 4: Feasibility restoration if needed\n    if best_result is None or not verify_packing(best_result[0], best_result[1], tol=1e-5):\n        print(\"\\nPhase 4: Feasibility restoration...\")\n        best_result = feasibility_restoration(initial_candidates, n_circles)\n    \n    if best_result is None:\n        print(\"All methods failed, using fallback grid packing\")\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    centers, radii, sum_radii = best_result\n    print(f\"\\nFinal result: Sum of radii = {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii, tol=1e-5)}\")\n    \n    return centers, radii, sum_radii\n\n\ndef graduated_random_search(n_circles: int, n_trials: int = 15) -> List[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Phase 1: Generate configurations using graduated penalty method\n    Start with soft constraints, gradually tighten\n    \"\"\"\n    candidates = []\n    penalty_schedules = [\n        [1.0, 5.0, 10.0, 50.0],      # Gradual\n        [10.0, 50.0, 100.0],          # Medium\n        [5.0, 25.0, 100.0, 500.0],    # Aggressive\n    ]\n    \n    for trial in range(n_trials):\n        # Use different initialization strategies\n        if trial < n_trials // 3:\n            centers = np.random.rand(n_circles, 2)\n        elif trial < 2 * n_trials // 3:\n            centers = create_hex_centers(n_circles)\n            centers += np.random.normal(0, 0.03, centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n        else:\n            centers = create_optimized_grid_centers(n_circles)\n            centers += np.random.normal(0, 0.02, centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n        \n        radii = compute_initial_radii(centers, n_circles)\n        \n        # Select penalty schedule\n        penalty_schedule = penalty_schedules[trial % len(penalty_schedules)]\n        \n        # Graduated optimization\n        result = graduated_penalty_optimize(centers, radii, n_circles, penalty_schedule)\n        \n        if result is not None:\n            candidates.append(result)\n            print(f\"  Trial {trial+1}/{n_trials}: sum_radii = {result[2]:.6f}, \"\n                  f\"feasible = {verify_packing(result[0], result[1], tol=1e-3)}\")\n    \n    # Sort by sum of radii (descending)\n    candidates.sort(key=lambda x: x[2], reverse=True)\n    \n    return candidates\n\n\ndef graduated_penalty_optimize(centers: np.ndarray, radii: np.ndarray, \n                               n_circles: int, penalty_schedule: List[float]) -> Optional[Tuple]:\n    \"\"\"\n    Optimize using graduated penalty method: start soft, gradually tighten constraints\n    \"\"\"\n    x = np.concatenate([centers.flatten(), radii])\n    \n    for stage, penalty in enumerate(penalty_schedule):\n        bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n        \n        def objective(x_opt):\n            radii_opt = x_opt[2*n_circles:]\n            # Maximize sum of radii\n            obj = -np.sum(radii_opt)\n            \n            # Add penalty for constraint violations\n            penalty_term = compute_constraint_violations(x_opt, n_circles) * penalty\n            \n            return obj + penalty_term\n        \n        try:\n            result = minimize(\n                objective,\n                x,\n                method='L-BFGS-B',\n                bounds=bounds,\n                options={'maxiter': 200, 'ftol': 1e-6}\n            )\n            \n            x = result.x\n            \n        except Exception as e:\n            print(f\"    Stage {stage+1} failed: {e}\")\n            continue\n    \n    centers_opt = x[:2*n_circles].reshape(n_circles, 2)\n    radii_opt = x[2*n_circles:]\n    sum_radii = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_radii\n\n\ndef compute_constraint_violations(x: np.ndarray, n_circles: int) -> float:\n    \"\"\"Compute total constraint violation (penalty term)\"\"\"\n    centers = x[:2*n_circles].reshape(n_circles, 2)\n    radii = x[2*n_circles:]\n    \n    violation = 0.0\n    \n    # Boundary violations\n    for i in range(n_circles):\n        violation += max(0, radii[i] - centers[i, 0]) ** 2\n        violation += max(0, radii[i] - (1 - centers[i, 0])) ** 2\n        violation += max(0, radii[i] - centers[i, 1]) ** 2\n        violation += max(0, radii[i] - (1 - centers[i, 1])) ** 2\n    \n    # Overlap violations\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                violation += overlap ** 2\n    \n    return violation\n\n\ndef repair_and_refine_phase(candidates: List[Tuple], n_circles: int) -> List[Tuple]:\n    \"\"\"\n    Phase 2: Repair constraint violations and refine solutions\n    \"\"\"\n    repaired = []\n    \n    for idx, (centers, radii, sum_radii) in enumerate(candidates[:10]):\n        print(f\"  Repairing candidate {idx+1}...\")\n        \n        # Check and repair constraints\n        centers_rep, radii_rep = repair_constraints(centers, radii, n_circles)\n        \n        # Quick refinement\n        result = quick_refine(centers_rep, radii_rep, n_circles)\n        \n        if result is not None:\n            repaired.append(result)\n            print(f\"    -> Repaired sum: {result[2]:.6f}, feasible: {verify_packing(result[0], result[1], tol=1e-4)}\")\n    \n    repaired.sort(key=lambda x: x[2], reverse=True)\n    return repaired\n\n\ndef repair_constraints(centers: np.ndarray, radii: np.ndarray, n_circles: int, \n                       max_iter: int = 100) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Iteratively repair constraint violations while trying to maintain large radii\n    \"\"\"\n    centers = centers.copy()\n    radii = radii.copy()\n    \n    for iteration in range(max_iter):\n        violations_fixed = 0\n        \n        # Fix boundary violations\n        for i in range(n_circles):\n            margin = 0.001\n            \n            if centers[i, 0] - radii[i] < 0:\n                radii[i] = centers[i, 0] - margin\n                violations_fixed += 1\n            if centers[i, 0] + radii[i] > 1:\n                radii[i] = 1 - centers[i, 0] - margin\n                violations_fixed += 1\n            if centers[i, 1] - radii[i] < 0:\n                radii[i] = centers[i, 1] - margin\n                violations_fixed += 1\n            if centers[i, 1] + radii[i] > 1:\n                radii[i] = 1 - centers[i, 1] - margin\n                violations_fixed += 1\n            \n            radii[i] = max(radii[i], 0.001)\n        \n        # Fix overlap violations\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                \n                if dist < radii[i] + radii[j]:\n                    # Reduce radii proportionally\n                    overlap = radii[i] + radii[j] - dist\n                    total_radii = radii[i] + radii[j]\n                    \n                    if total_radii > 0:\n                        reduction_factor = (dist - 0.001) / total_radii\n                        radii[i] *= reduction_factor\n                        radii[j] *= reduction_factor\n                        violations_fixed += 1\n        \n        if violations_fixed == 0:\n            break\n    \n    return centers, radii\n\n\ndef quick_refine(centers: np.ndarray, radii: np.ndarray, n_circles: int) -> Optional[Tuple]:\n    \"\"\"Quick refinement with SLSQP\"\"\"\n    x0 = np.concatenate([centers.flatten(), radii])\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    constraints = create_constraints_slsqp(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 300, 'ftol': 1e-6}\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\n\ndef trust_region_optimization_phase(candidates: List[Tuple], n_circles: int, \n                                    top_k: int = 5) -> Optional[Tuple]:\n    \"\"\"\n    Phase 3: Trust-region constrained optimization with explicit Jacobians\n    \"\"\"\n    best_result = None\n    best_sum_radii = 0\n    \n    top_candidates = candidates[:min(top_k, len(candidates))]\n    \n    for idx, (centers, radii, sum_radii) in enumerate(top_candidates):\n        print(f\"\\n  Trust-region optimization {idx+1}/{len(top_candidates)} (initial: {sum_radii:.6f})...\")\n        \n        # Optimize with trust-constr\n        result = trust_constr_optimize(centers, radii, n_circles)\n        \n        if result is not None:\n            centers_opt, radii_opt, sum_radii_opt = result\n            \n            if verify_packing(centers_opt, radii_opt, tol=1e-5):\n                print(f\"    -> Optimized: {sum_radii_opt:.6f} (feasible)\")\n                \n                if sum_radii_opt > best_sum_radii:\n                    best_sum_radii = sum_radii_opt\n                    best_result = result\n            else:\n                print(f\"    -> Optimized: {sum_radii_opt:.6f} (infeasible, skipping)\")\n        \n        # Multiple restarts with perturbations\n        if result is not None:\n            for restart in range(3):\n                scale = 0.005 * (restart + 1)\n                centers_pert = centers_opt + np.random.normal(0, scale, centers_opt.shape)\n                centers_pert = np.clip(centers_pert, 0, 1)\n                radii_pert = radii_opt * (1 + np.random.normal(0, scale * 2, radii_pert.shape))\n                radii_pert = np.clip(radii_pert, 0.001, 0.5)\n                \n                result_pert = trust_constr_optimize(centers_pert, radii_pert, n_circles)\n                \n                if result_pert is not None and verify_packing(result_pert[0], result_pert[1], tol=1e-5):\n                    if result_pert[2] > best_sum_radii:\n                        best_sum_radii = result_pert[2]\n                        best_result = result_pert\n                        print(f\"    -> Restart {restart+1} improved: {best_sum_radii:.6f}\")\n    \n    return best_result\n\n\ndef trust_constr_optimize(centers: np.ndarray, radii: np.ndarray, n_circles: int) -> Optional[Tuple]:\n    \"\"\"\n    Optimize using trust-constr method with explicit Jacobians\n    \"\"\"\n    x0 = np.concatenate([centers.flatten(), radii])\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    def objective_grad(x):\n        grad = np.zeros_like(x)\n        grad[2*n_circles:] = -1.0\n        return grad\n    \n    # Create nonlinear constraints with Jacobians\n    constraints = create_nonlinear_constraints(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            jac=objective_grad,\n            bounds=bounds,\n            constraints=constraints,\n            options={\n                'maxiter': 1000,\n                'verbose': 0,\n                'gtol': 1e-6,\n                'xtol': 1e-8,\n                'barrier_tol': 1e-8\n            }\n        )\n        \n        if result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_",
  "reasoning": "Here's an improved version with better constraint handling using trust-constr, explicit Jacobians, constraint repair, and graduated penalty methods:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom typing import Tuple, List, Optional, Dict\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Enhanced hybrid approach with advanced constraint handling\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Phase 1: Random search with graduated penalties\n    print(\"Phase 1: Random search with graduated penalty method...\")\n    initial_candidates = graduated_random_search(n_circles, n_trials=15)\n    \n    # Phase 2: Constraint repair and refinement\n    print(\"\\nPhase 2: Constraint repair and refinement...\")\n    repaired_candidates = repair_and_refine_phase(initial_candidates, n_circles)\n    \n    # Phase 3: Intensive optimization with trust-constr\n    print(\"\\nPhase 3: Trust-region constrained optimization...\")\n    best_result = trust_region_optimization_phase(repaired_candidates, n_circles, top_k=5)\n    \n    # Phase 4: Feasibility restoration if needed\n    if best_result is None or not verify_packing(best_result[0], best_result[1], tol=1e-5):\n        print(\"\\nPhase 4: Feasibility restoration...\")\n        best_result = feasibility_restoration(initial_candidates, n_circles)\n    \n    if best_result is None:\n        print(\"All methods failed, using fallback grid packing\")\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    centers, radii, sum_radii = best_result\n    print(f\"\\nFinal result: Sum of radii = {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii, tol=1e-5)}\")\n    \n    return centers, radii, sum_radii\n\ndef graduated_random_search(n_circles: int, n_trials: int = 15) -> List[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Phase 1: Generate configurations using graduated penalty method\n    Start with soft constraints, gradually tighten\n    \"\"\"\n    candidates = []\n    penalty_schedules = [\n        [1.0, 5.0, 10.0, 50.0],      # Gradual\n        [10.0, 50.0, 100.0],          # Medium\n        [5.0, 25.0, 100.0, 500.0],    # Aggressive\n    ]\n    \n    for trial in range(n_trials):\n        # Use different initialization strategies\n        if trial < n_trials // 3:\n            centers = np.random.rand(n_circles, 2)\n        elif trial < 2 * n_trials // 3:\n            centers = create_hex_centers(n_circles)\n            centers += np.random.normal(0, 0.03, centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n        else:\n            centers = create_optimized_grid_centers(n_circles)\n            centers += np.random.normal(0, 0.02, centers.shape)\n            centers = np.clip(centers, 0.05, 0.95)\n        \n        radii = compute_initial_radii(centers, n_circles)\n        \n        # Select penalty schedule\n        penalty_schedule = penalty_schedules[trial % len(penalty_schedules)]\n        \n        # Graduated optimization\n        result = graduated_penalty_optimize(centers, radii, n_circles, penalty_schedule)\n        \n        if result is not None:\n            candidates.append(result)\n            print(f\"  Trial {trial+1}/{n_trials}: sum_radii = {result[2]:.6f}, \"\n                  f\"feasible = {verify_packing(result[0], result[1], tol=1e-3)}\")\n    \n    # Sort by sum of radii (descending)\n    candidates.sort(key=lambda x: x[2], reverse=True)\n    \n    return candidates\n\ndef graduated_penalty_optimize(centers: np.ndarray, radii: np.ndarray, \n                               n_circles: int, penalty_schedule: List[float]) -> Optional[Tuple]:\n    \"\"\"\n    Optimize using graduated penalty method: start soft, gradually tighten constraints\n    \"\"\"\n    x = np.concatenate([centers.flatten(), radii])\n    \n    for stage, penalty in enumerate(penalty_schedule):\n        bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n        \n        def objective(x_opt):\n            radii_opt = x_opt[2*n_circles:]\n            # Maximize sum of radii\n            obj = -np.sum(radii_opt)\n            \n            # Add penalty for constraint violations\n            penalty_term = compute_constraint_violations(x_opt, n_circles) * penalty\n            \n            return obj + penalty_term\n        \n        try:\n            result = minimize(\n                objective,\n                x,\n                method='L-BFGS-B',\n                bounds=bounds,\n                options={'maxiter': 200, 'ftol': 1e-6}\n            )\n            \n            x = result.x\n            \n        except Exception as e:\n            print(f\"    Stage {stage+1} failed: {e}\")\n            continue\n    \n    centers_opt = x[:2*n_circles].reshape(n_circles, 2)\n    radii_opt = x[2*n_circles:]\n    sum_radii = np.sum(radii_opt)\n    \n    return centers_opt, radii_opt, sum_radii\n\ndef compute_constraint_violations(x: np.ndarray, n_circles: int) -> float:\n    \"\"\"Compute total constraint violation (penalty term)\"\"\"\n    centers = x[:2*n_circles].reshape(n_circles, 2)\n    radii = x[2*n_circles:]\n    \n    violation = 0.0\n    \n    # Boundary violations\n    for i in range(n_circles):\n        violation += max(0, radii[i] - centers[i, 0]) ** 2\n        violation += max(0, radii[i] - (1 - centers[i, 0])) ** 2\n        violation += max(0, radii[i] - centers[i, 1]) ** 2\n        violation += max(0, radii[i] - (1 - centers[i, 1])) ** 2\n    \n    # Overlap violations\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                violation += overlap ** 2\n    \n    return violation\n\ndef repair_and_refine_phase(candidates: List[Tuple], n_circles: int) -> List[Tuple]:\n    \"\"\"\n    Phase 2: Repair constraint violations and refine solutions\n    \"\"\"\n    repaired = []\n    \n    for idx, (centers, radii, sum_radii) in enumerate(candidates[:10]):\n        print(f\"  Repairing candidate {idx+1}...\")\n        \n        # Check and repair constraints\n        centers_rep, radii_rep = repair_constraints(centers, radii, n_circles)\n        \n        # Quick refinement\n        result = quick_refine(centers_rep, radii_rep, n_circles)\n        \n        if result is not None:\n            repaired.append(result)\n            print(f\"    -> Repaired sum: {result[2]:.6f}, feasible: {verify_packing(result[0], result[1], tol=1e-4)}\")\n    \n    repaired.sort(key=lambda x: x[2], reverse=True)\n    return repaired\n\ndef repair_constraints(centers: np.ndarray, radii: np.ndarray, n_circles: int, \n                       max_iter: int = 100) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Iteratively repair constraint violations while trying to maintain large radii\n    \"\"\"\n    centers = centers.copy()\n    radii = radii.copy()\n    \n    for iteration in range(max_iter):\n        violations_fixed = 0\n        \n        # Fix boundary violations\n        for i in range(n_circles):\n            margin = 0.001\n            \n            if centers[i, 0] - radii[i] < 0:\n                radii[i] = centers[i, 0] - margin\n                violations_fixed += 1\n            if centers[i, 0] + radii[i] > 1:\n                radii[i] = 1 - centers[i, 0] - margin\n                violations_fixed += 1\n            if centers[i, 1] - radii[i] < 0:\n                radii[i] = centers[i, 1] - margin\n                violations_fixed += 1\n            if centers[i, 1] + radii[i] > 1:\n                radii[i] = 1 - centers[i, 1] - margin\n                violations_fixed += 1\n            \n            radii[i] = max(radii[i], 0.001)\n        \n        # Fix overlap violations\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                \n                if dist < radii[i] + radii[j]:\n                    # Reduce radii proportionally\n                    overlap = radii[i] + radii[j] - dist\n                    total_radii = radii[i] + radii[j]\n                    \n                    if total_radii > 0:\n                        reduction_factor = (dist - 0.001) / total_radii\n                        radii[i] *= reduction_factor\n                        radii[j] *= reduction_factor\n                        violations_fixed += 1\n        \n        if violations_fixed == 0:\n            break\n    \n    return centers, radii\n\ndef quick_refine(centers: np.ndarray, radii: np.ndarray, n_circles: int) -> Optional[Tuple]:\n    \"\"\"Quick refinement with SLSQP\"\"\"\n    x0 = np.concatenate([centers.flatten(), radii])\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    constraints = create_constraints_slsqp(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 300, 'ftol': 1e-6}\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef trust_region_optimization_phase(candidates: List[Tuple], n_circles: int, \n                                    top_k: int = 5) -> Optional[Tuple]:\n    \"\"\"\n    Phase 3: Trust-region constrained optimization with explicit Jacobians\n    \"\"\"\n    best_result = None\n    best_sum_radii = 0\n    \n    top_candidates = candidates[:min(top_k, len(candidates))]\n    \n    for idx, (centers, radii, sum_radii) in enumerate(top_candidates):\n        print(f\"\\n  Trust-region optimization {idx+1}/{len(top_candidates)} (initial: {sum_radii:.6f})...\")\n        \n        # Optimize with trust-constr\n        result = trust_constr_optimize(centers, radii, n_circles)\n        \n        if result is not None:\n            centers_opt, radii_opt, sum_radii_opt = result\n            \n            if verify_packing(centers_opt, radii_opt, tol=1e-5):\n                print(f\"    -> Optimized: {sum_radii_opt:.6f} (feasible)\")\n                \n                if sum_radii_opt > best_sum_radii:\n                    best_sum_radii = sum_radii_opt\n                    best_result = result\n            else:\n                print(f\"    -> Optimized: {sum_radii_opt:.6f} (infeasible, skipping)\")\n        \n        # Multiple restarts with perturbations\n        if result is not None:\n            for restart in range(3):\n                scale = 0.005 * (restart + 1)\n                centers_pert = centers_opt + np.random.normal(0, scale, centers_opt.shape)\n                centers_pert = np.clip(centers_pert, 0, 1)\n                radii_pert = radii_opt * (1 + np.random.normal(0, scale * 2, radii_pert.shape))\n                radii_pert = np.clip(radii_pert, 0.001, 0.5)\n                \n                result_pert = trust_constr_optimize(centers_pert, radii_pert, n_circles)\n                \n                if result_pert is not None and verify_packing(result_pert[0], result_pert[1], tol=1e-5):\n                    if result_pert[2] > best_sum_radii:\n                        best_sum_radii = result_pert[2]\n                        best_result = result_pert\n                        print(f\"    -> Restart {restart+1} improved: {best_sum_radii:.6f}\")\n    \n    return best_result\n\ndef trust_constr_optimize(centers: np.ndarray, radii: np.ndarray, n_circles: int) -> Optional[Tuple]:\n    \"\"\"\n    Optimize using trust-constr method with explicit Jacobians\n    \"\"\"\n    x0 = np.concatenate([centers.flatten(), radii])\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    def objective_grad(x):\n        grad = np.zeros_like(x)\n        grad[2*n_circles:] = -1.0\n        return grad\n    \n    # Create nonlinear constraints with Jacobians\n    constraints = create_nonlinear_constraints(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='trust-constr',\n            jac=objective_grad,\n            bounds=bounds,\n            constraints=constraints,\n            options={\n                'maxiter': 1000,\n                'verbose': 0,\n                'gtol': 1e-6,\n                'xtol': 1e-8,\n                'barrier_tol': 1e-8\n            }\n        )\n        \n        if result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_",
  "timestamp": "2025-12-08T12:40:41.340328",
  "cost_data": null
}