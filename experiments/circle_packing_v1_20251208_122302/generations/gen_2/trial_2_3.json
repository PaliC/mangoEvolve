{
  "trial_id": "trial_2_3",
  "generation": 2,
  "parent_id": "trial_1_0",
  "code": "",
  "metrics": {},
  "prompt": "Further improve this enhanced random search approach:\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 30  # Increased from 15\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Generate diverse initial configurations\n    initial_configs = generate_initial_configurations(n_circles, n_trials)\n    \n    for trial, (centers, radii) in enumerate(initial_configs):\n        print(f\"Trial {trial + 1}/{n_trials}...\")\n        \n        # Try multiple optimization methods\n        for method in ['SLSQP', 'trust-constr']:\n            result = optimize_packing(centers.copy(), radii.copy(), method=method)\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                if sum_radii > best_sum_radii:\n                    best_sum_radii = sum_radii\n                    best_result = result\n                    print(f\"  New best with {method}: {sum_radii:.6f}\")\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\ndef generate_initial_configurations(n_circles: int, n_configs: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"\n    Generate diverse initial configurations including structured and random layouts\n    \"\"\"\n    configs = []\n    \n    # 1. Hexagonal packing variations (4 configs)\n    for i in range(4):\n        centers, radii = create_hexagonal_packing(n_circles, offset=i*0.1)\n        configs.append((centers, radii))\n    \n    # 2. Grid variations (4 configs)\n    for grid_size in [5, 6, 7, 8]:\n        centers, radii = create_grid_packing(n_circles, grid_size=grid_size)\n        configs.append((centers, radii))\n    \n    # 3. Concentric circles (2 configs)\n    for i in range(2):\n        centers, radii = create_concentric_packing(n_circles, layers=3+i)\n        configs.append((centers, radii))\n    \n    # 4. Random with varying densities (remaining configs)\n    remaining = n_configs - len(configs)\n    for i in range(remaining):\n        if i % 3 == 0:\n            # Clustered random\n            centers = generate_clustered_centers(n_circles)\n        elif i % 3 == 1:\n            # Uniform random\n            centers = np.random.rand(n_circles, 2)\n        else:\n            # Random with repulsion\n            centers = generate_repulsed_centers(n_circles)\n        \n        # Vary initial radii\n        if i % 2 == 0:\n            radii = np.full(n_circles, 0.05)\n        else:\n            radii = np.random.uniform(0.02, 0.08, n_circles)\n        \n        configs.append((centers, radii))\n    \n    return configs[:n_configs]\n\ndef create_hexagonal_packing(n_circles: int, offset: float = 0.0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a hexagonal close-packing arrangement\n    \"\"\"\n    centers = []\n    \n    # Hexagonal packing parameters\n    rows = 6\n    cols = 6\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = (col + 0.5 + (row % 2) * 0.5) * dx + offset\n            y = (row + 0.5) * dy + offset\n            \n            # Keep within bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.06)\n    \n    return centers, radii\n\ndef create_grid_packing(n_circles: int, grid_size: int = 6) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a grid-based packing\n    \"\"\"\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.2\n    \n    centers = []\n    count = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count >= n_circles:\n                break\n            x = (i + 0.5) * spacing\n            y = (j + 0.5) * spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, radius)\n    \n    return centers, radii\n\ndef create_concentric_packing(n_circles: int, layers: int = 3) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create concentric circular arrangement\n    \"\"\"\n    centers = []\n    circles_per_layer = n_circles // layers\n    remainder = n_circles % layers\n    \n    for layer in range(layers):\n        n_in_layer = circles_per_layer + (1 if layer < remainder else 0)\n        radius_layer = 0.4 - layer * 0.12\n        \n        for i in range(n_in_layer):\n            angle = 2 * np.pi * i / n_in_layer\n            x = 0.5 + radius_layer * np.cos(angle)\n            y = 0.5 + radius_layer * np.sin(angle)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.05)\n    \n    return centers, radii\n\ndef generate_clustered_centers(n_circles: int, n_clusters: int = 4) -> np.ndarray:\n    \"\"\"\n    Generate clustered random centers\n    \"\"\"\n    centers = []\n    circles_per_cluster = n_circles // n_clusters\n    \n    cluster_centers = np.random.uniform(0.2, 0.8, (n_clusters, 2))\n    \n    for i in range(n_clusters):\n        n_in_cluster = circles_per_cluster + (1 if i < n_circles % n_clusters else 0)\n        cluster_points = cluster_centers[i] + np.random.normal(0, 0.1, (n_in_cluster, 2))\n        cluster_points = np.clip(cluster_points, 0.05, 0.95)\n        centers.extend(cluster_points)\n    \n    return np.array(centers[:n_circles])\n\ndef generate_repulsed_centers(n_circles: int, iterations: int = 50) -> np.ndarray:\n    \"\"\"\n    Generate centers with mutual repulsion for better initial spacing\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist > 0:\n                        # Repulsive force inversely proportional to distance\n                        force = diff / (dist ** 3 + 0.01)\n                        forces[i] += force\n        \n        # Update positions\n        centers += 0.01 * forces\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    return centers\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, method: str = 'SLSQP') -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Optimize a packing configuration using scipy.optimize\n    \"\"\"\n    n_circles = len(centers_init)\n    \n    # Pack parameters: [centers (flattened), radii]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        # Minimize negative sum of radii (maximize sum of radii)\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Constraint: circles inside unit square\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n        \n        # Constraint: no overlaps (distance >= sum of radii)\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Constraint: radii positive\n        for i in range(n_circles):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    # Bounds for variables\n    bounds = []\n    # Centers: [0, 1]\n    for i in range(2*n_circles):\n        bounds.append((0, 1))\n    # Radii: [0.001, 0.5]\n    for i in range(n_circles):\n        bounds.append((0.001, 0.5))\n    \n    # Constraints\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    # Optimize with increased iterations\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6}  # Increased from 500\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify solution\n            if verify_packing(centers_opt, radii_opt):\n                return centers_opt, radii_opt, sum_radii\n    except Exception as e:\n        print(f\"  Optimization failed with {method}: {e}\")\n    \n    return None\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-4) -> bool:\n    \"\"\"\n    Verify that a packing is valid\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check circles inside unit square\n    for i in range(n_circles):\n        if (centers[i, 0] - radii[i] < -tol or \n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or \n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check no overlaps\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    # Check positive radii\n    if np.any(radii < 0):\n        return False\n    \n    return True\n\ndef run_packing():\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nFinal Results:\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n\nAdditional improvements:\n1. Increase trials to 50 with better distribution across strategies\n2. Add Latin Hypercube Sampling for better space coverage\n3. Implement adaptive method selection based on success rates\n4. Use warm-start optimization: use best solution from one method to initialize another\n5. Add constraint-aware initialization that respects boundary and overlap constraints\n\nTarget: exceed 2.62 sum_radii.",
  "response": "Here's a significantly improved version with all your requested enhancements:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.stats import qmc\nfrom typing import Tuple, List, Optional, Dict\nimport time\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 50\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Track method success rates for adaptive selection\n    method_stats = {\n        'SLSQP': {'successes': 0, 'attempts': 0, 'avg_score': 0},\n        'trust-constr': {'successes': 0, 'attempts': 0, 'avg_score': 0},\n        'COBYLA': {'successes': 0, 'attempts': 0, 'avg_score': 0}\n    }\n    \n    # Generate diverse initial configurations\n    print(\"Generating initial configurations...\")\n    initial_configs = generate_initial_configurations(n_circles, n_trials)\n    \n    for trial, (centers, radii) in enumerate(initial_configs):\n        print(f\"\\nTrial {trial + 1}/{n_trials}...\")\n        \n        # Select methods adaptively based on success rates\n        methods = select_methods_adaptively(method_stats, trial, n_trials)\n        \n        trial_best = None\n        trial_best_score = 0\n        \n        for method in methods:\n            method_stats[method]['attempts'] += 1\n            \n            result = optimize_packing(\n                centers.copy(), \n                radii.copy(), \n                method=method,\n                warm_start=trial_best  # Use best from previous method\n            )\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                method_stats[method]['successes'] += 1\n                method_stats[method]['avg_score'] = (\n                    (method_stats[method]['avg_score'] * (method_stats[method]['successes'] - 1) + sum_radii) \n                    / method_stats[method]['successes']\n                )\n                \n                if sum_radii > trial_best_score:\n                    trial_best_score = sum_radii\n                    trial_best = result\n                \n                if sum_radii > best_sum_radii:\n                    best_sum_radii = sum_radii\n                    best_result = result\n                    print(f\"  \u2713 New best with {method}: {sum_radii:.6f}\")\n                else:\n                    print(f\"  \u2022 {method}: {sum_radii:.6f}\")\n        \n        # Try refinement on best result so far every 10 trials\n        if trial % 10 == 9 and best_result is not None:\n            print(f\"  Refining best solution...\")\n            refined = refine_solution(best_result, n_iterations=3)\n            if refined is not None and refined[2] > best_sum_radii:\n                best_sum_radii = refined[2]\n                best_result = refined\n                print(f\"  \u2713 Refined to: {best_sum_radii:.6f}\")\n    \n    # Final refinement phase\n    if best_result is not None:\n        print(\"\\n\" + \"=\"*50)\n        print(\"Final refinement phase...\")\n        refined = refine_solution(best_result, n_iterations=5)\n        if refined is not None and refined[2] > best_sum_radii:\n            best_sum_radii = refined[2]\n            best_result = refined\n            print(f\"\u2713 Final refined result: {best_sum_radii:.6f}\")\n    \n    if best_result is None:\n        # Fallback\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    print(\"\\n\" + \"=\"*50)\n    print(\"Method Statistics:\")\n    for method, stats in method_stats.items():\n        if stats['attempts'] > 0:\n            success_rate = stats['successes'] / stats['attempts'] * 100\n            print(f\"  {method}: {success_rate:.1f}% success, avg score: {stats['avg_score']:.6f}\")\n    \n    return best_result\n\ndef generate_initial_configurations(n_circles: int, n_configs: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"\n    Generate diverse initial configurations with constraint-aware initialization\n    \"\"\"\n    configs = []\n    \n    # 1. Hexagonal packing variations (6 configs) - usually best for circle packing\n    for i in range(6):\n        centers, radii = create_hexagonal_packing(n_circles, offset=i*0.05, scale=0.95 + i*0.01)\n        configs.append((centers, radii))\n    \n    # 2. Optimized hexagonal with constraint-aware radii (4 configs)\n    for i in range(4):\n        centers, radii = create_constrained_hexagonal_packing(n_circles, variant=i)\n        configs.append((centers, radii))\n    \n    # 3. Grid variations (4 configs)\n    for grid_size in [5, 6, 7, 8]:\n        centers, radii = create_grid_packing(n_circles, grid_size=grid_size)\n        configs.append((centers, radii))\n    \n    # 4. Concentric circles (3 configs)\n    for i in range(3):\n        centers, radii = create_concentric_packing(n_circles, layers=3+i)\n        configs.append((centers, radii))\n    \n    # 5. Latin Hypercube Sampling (8 configs) - better space coverage\n    for i in range(8):\n        centers, radii = create_lhs_packing(n_circles, seed=i)\n        configs.append((centers, radii))\n    \n    # 6. Sunflower spiral pattern (4 configs) - efficient natural packing\n    for i in range(4):\n        centers, radii = create_sunflower_packing(n_circles, alpha=i*0.5)\n        configs.append((centers, radii))\n    \n    # 7. Random with repulsion (8 configs)\n    for i in range(8):\n        centers = generate_repulsed_centers(n_circles, iterations=100 + i*20)\n        radii = compute_constraint_aware_radii(centers)\n        configs.append((centers, radii))\n    \n    # 8. Clustered with constraint-aware radii (5 configs)\n    for i in range(5):\n        centers = generate_clustered_centers(n_circles, n_clusters=3+i)\n        radii = compute_constraint_aware_radii(centers)\n        configs.append((centers, radii))\n    \n    # 9. Hybrid: best patterns combined (remaining configs)\n    remaining = n_configs - len(configs)\n    for i in range(remaining):\n        if i % 3 == 0:\n            centers, radii = create_hybrid_packing(n_circles, \"hex_grid\")\n        elif i % 3 == 1:\n            centers, radii = create_hybrid_packing(n_circles, \"sunflower_concentric\")\n        else:\n            centers, radii = create_hybrid_packing(n_circles, \"lhs_repulsed\")\n        configs.append((centers, radii))\n    \n    return configs[:n_configs]\n\ndef create_constrained_hexagonal_packing(n_circles: int, variant: int = 0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Hexagonal packing with constraint-aware radius initialization\n    \"\"\"\n    centers = []\n    \n    # Adjust packing density based on variant\n    rows = 6 + (variant % 2)\n    cols = 6 + (variant // 2)\n    \n    # Add margin to keep circles well within bounds\n    margin = 0.08\n    dx = (1.0 - 2*margin) / (cols + 0.5)\n    dy = (1.0 - 2*margin) / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = margin + (col + 0.5 + (row % 2) * 0.5) * dx\n            y = margin + (row + 0.5) * dy\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = compute_constraint_aware_radii(centers)\n    \n    return centers, radii\n\ndef create_lhs_packing(n_circles: int, seed: int = 0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create packing using Latin Hypercube Sampling for better space coverage\n    \"\"\"\n    sampler = qmc.LatinHypercube(d=2, seed=seed)\n    sample = sampler.random(n=n_circles)\n    \n    # Scale to [0.08, 0.92] to leave margin for radii\n    centers = 0.08 + sample * 0.84\n    \n    radii = compute_constraint_aware_radii(centers)\n    \n    return centers, radii\n\ndef create_sunflower_packing(n_circles: int, alpha: float = 0.0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create sunflower spiral pattern - efficient natural packing\n    \"\"\"\n    centers = []\n    golden_angle = np.pi * (3 - np.sqrt(5))  # Golden angle in radians\n    \n    for i in range(n_circles):\n        # Sunflower seed arrangement\n        angle = i * golden_angle + alpha\n        radius = 0.35 * np.sqrt(i / n_circles)  # Scale to fit in unit square\n        \n        x = 0.5 + radius * np.cos(angle)\n        y = 0.5 + radius * np.sin(angle)\n        \n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = compute_constraint_aware_radii(centers)\n    \n    return centers, radii\n\ndef create_hybrid_packing(n_circles: int, pattern: str) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create hybrid patterns combining multiple strategies\n    \"\"\"\n    if pattern == \"hex_grid\":\n        # Half hexagonal, half grid\n        n_hex = n_circles // 2\n        centers_hex, _ = create_hexagonal_packing(n_hex)\n        centers_grid, _ = create_grid_packing(n_circles - n_hex)\n        # Shift grid to different region\n        centers_grid = centers_grid * 0.4 + 0.55\n        centers = np.vstack([centers_hex, centers_grid])\n    \n    elif pattern == \"sunflower_concentric\":\n        # Inner sunflower, outer concentric\n        n_sun = n_circles * 2 // 3\n        centers_sun, _ = create_sunflower_packing(n_sun)\n        centers_con, _ = create_concentric_packing(n_circles - n_sun, layers=2)\n        centers = np.vstack([centers_sun, centers_con])\n    \n    else:  # \"lhs_repulsed\"\n        # Start with LHS, then apply repulsion\n        centers, _ = create_lhs_packing(n_circles)\n        centers = apply_repulsion(centers, iterations=50)\n    \n    centers = np.clip(centers, 0.05, 0.95)\n    radii = compute_constraint_aware_radii(centers)\n    \n    return centers, radii\n\ndef compute_constraint_aware_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute initial radii that respect boundary and overlap constraints\n    \"\"\"\n    n_circles = len(centers)\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Maximum radius based on boundary constraints\n        max_r_boundary = min(\n            centers[i, 0],\n            1 - centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 1]\n        )\n        \n        # Maximum radius based on distance to nearest neighbor\n        max_r_overlap = float('inf')\n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r_overlap = min(max_r_overlap, dist / 2.5)  # Conservative factor\n        \n        # Take minimum and add safety margin\n        radii[i] = min(max_r_boundary, max_r_overlap) * 0.9\n        radii[i] = max(radii[i], 0.01)  # Ensure positive\n    \n    return radii\n\ndef apply_repulsion(centers: np.ndarray, iterations: int = 50) -> np.ndarray:\n    \"\"\"\n    Apply repulsion forces to improve spacing\n    \"\"\"\n    centers = centers.copy()\n    n_circles = len(centers)\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist > 0:\n                        force = diff / (dist ** 3 + 0.001)\n                        forces[i] += force\n        \n        centers += 0.005 * forces\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    return centers\n\ndef select_methods_adaptively(method_stats: Dict, trial: int, total_trials: int) -> List[str]:\n    \"\"\"\n    Adaptively select optimization methods based on success rates\n    \"\"\"\n    # Early phase: try all methods\n    if trial < 10:\n        return ['SLSQP', 'trust-constr', 'COBYLA']\n    \n    # Calculate success rates\n    methods_with_scores = []\n    for method, stats in method_stats.items():\n        if stats['attempts'] > 0:\n            success_rate = stats['successes'] / stats['attempts']\n            avg_score = stats['avg_score']\n            # Combined metric: success rate and average score\n            combined_score = success_rate * 0.4 + (avg_score / 3.0) * 0.6\n            methods_with_scores.append((method, combined_score))\n    \n    # Sort by combined score\n    methods_with_scores.sort(key=lambda x: x[1], reverse=True)\n    \n    # Middle phase: focus on top 2 methods\n    if trial < total_trials * 0.7:\n        return [m[0] for m in methods_with_scores[:2]]\n    \n    # Late phase: focus on best method + occasional exploration\n    if np.random.rand() < 0.2:  # 20% exploration\n        return [m[0] for m in methods_with_scores]\n    else:\n        return [methods_with_scores[0][0]]\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, \n                     method: str = 'SLSQP', \n                     warm_start: Optional[Tuple] = None) -> Optional[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Optimize packing with warm-start capability\n    \"\"\"\n    n_circles = len(centers_init)\n    \n    # Use warm start if available and better\n    if warm_start is not None:\n        ",
  "reasoning": "Here's a significantly improved version with all your requested enhancements:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom scipy.stats import qmc\nfrom typing import Tuple, List, Optional, Dict\nimport time\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 50\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Track method success rates for adaptive selection\n    method_stats = {\n        'SLSQP': {'successes': 0, 'attempts': 0, 'avg_score': 0},\n        'trust-constr': {'successes': 0, 'attempts': 0, 'avg_score': 0},\n        'COBYLA': {'successes': 0, 'attempts': 0, 'avg_score': 0}\n    }\n    \n    # Generate diverse initial configurations\n    print(\"Generating initial configurations...\")\n    initial_configs = generate_initial_configurations(n_circles, n_trials)\n    \n    for trial, (centers, radii) in enumerate(initial_configs):\n        print(f\"\\nTrial {trial + 1}/{n_trials}...\")\n        \n        # Select methods adaptively based on success rates\n        methods = select_methods_adaptively(method_stats, trial, n_trials)\n        \n        trial_best = None\n        trial_best_score = 0\n        \n        for method in methods:\n            method_stats[method]['attempts'] += 1\n            \n            result = optimize_packing(\n                centers.copy(), \n                radii.copy(), \n                method=method,\n                warm_start=trial_best  # Use best from previous method\n            )\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                method_stats[method]['successes'] += 1\n                method_stats[method]['avg_score'] = (\n                    (method_stats[method]['avg_score'] * (method_stats[method]['successes'] - 1) + sum_radii) \n                    / method_stats[method]['successes']\n                )\n                \n                if sum_radii > trial_best_score:\n                    trial_best_score = sum_radii\n                    trial_best = result\n                \n                if sum_radii > best_sum_radii:\n                    best_sum_radii = sum_radii\n                    best_result = result\n                    print(f\"  \u2713 New best with {method}: {sum_radii:.6f}\")\n                else:\n                    print(f\"  \u2022 {method}: {sum_radii:.6f}\")\n        \n        # Try refinement on best result so far every 10 trials\n        if trial % 10 == 9 and best_result is not None:\n            print(f\"  Refining best solution...\")\n            refined = refine_solution(best_result, n_iterations=3)\n            if refined is not None and refined[2] > best_sum_radii:\n                best_sum_radii = refined[2]\n                best_result = refined\n                print(f\"  \u2713 Refined to: {best_sum_radii:.6f}\")\n    \n    # Final refinement phase\n    if best_result is not None:\n        print(\"\\n\" + \"=\"*50)\n        print(\"Final refinement phase...\")\n        refined = refine_solution(best_result, n_iterations=5)\n        if refined is not None and refined[2] > best_sum_radii:\n            best_sum_radii = refined[2]\n            best_result = refined\n            print(f\"\u2713 Final refined result: {best_sum_radii:.6f}\")\n    \n    if best_result is None:\n        # Fallback\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    print(\"\\n\" + \"=\"*50)\n    print(\"Method Statistics:\")\n    for method, stats in method_stats.items():\n        if stats['attempts'] > 0:\n            success_rate = stats['successes'] / stats['attempts'] * 100\n            print(f\"  {method}: {success_rate:.1f}% success, avg score: {stats['avg_score']:.6f}\")\n    \n    return best_result\n\ndef generate_initial_configurations(n_circles: int, n_configs: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"\n    Generate diverse initial configurations with constraint-aware initialization\n    \"\"\"\n    configs = []\n    \n    # 1. Hexagonal packing variations (6 configs) - usually best for circle packing\n    for i in range(6):\n        centers, radii = create_hexagonal_packing(n_circles, offset=i*0.05, scale=0.95 + i*0.01)\n        configs.append((centers, radii))\n    \n    # 2. Optimized hexagonal with constraint-aware radii (4 configs)\n    for i in range(4):\n        centers, radii = create_constrained_hexagonal_packing(n_circles, variant=i)\n        configs.append((centers, radii))\n    \n    # 3. Grid variations (4 configs)\n    for grid_size in [5, 6, 7, 8]:\n        centers, radii = create_grid_packing(n_circles, grid_size=grid_size)\n        configs.append((centers, radii))\n    \n    # 4. Concentric circles (3 configs)\n    for i in range(3):\n        centers, radii = create_concentric_packing(n_circles, layers=3+i)\n        configs.append((centers, radii))\n    \n    # 5. Latin Hypercube Sampling (8 configs) - better space coverage\n    for i in range(8):\n        centers, radii = create_lhs_packing(n_circles, seed=i)\n        configs.append((centers, radii))\n    \n    # 6. Sunflower spiral pattern (4 configs) - efficient natural packing\n    for i in range(4):\n        centers, radii = create_sunflower_packing(n_circles, alpha=i*0.5)\n        configs.append((centers, radii))\n    \n    # 7. Random with repulsion (8 configs)\n    for i in range(8):\n        centers = generate_repulsed_centers(n_circles, iterations=100 + i*20)\n        radii = compute_constraint_aware_radii(centers)\n        configs.append((centers, radii))\n    \n    # 8. Clustered with constraint-aware radii (5 configs)\n    for i in range(5):\n        centers = generate_clustered_centers(n_circles, n_clusters=3+i)\n        radii = compute_constraint_aware_radii(centers)\n        configs.append((centers, radii))\n    \n    # 9. Hybrid: best patterns combined (remaining configs)\n    remaining = n_configs - len(configs)\n    for i in range(remaining):\n        if i % 3 == 0:\n            centers, radii = create_hybrid_packing(n_circles, \"hex_grid\")\n        elif i % 3 == 1:\n            centers, radii = create_hybrid_packing(n_circles, \"sunflower_concentric\")\n        else:\n            centers, radii = create_hybrid_packing(n_circles, \"lhs_repulsed\")\n        configs.append((centers, radii))\n    \n    return configs[:n_configs]\n\ndef create_constrained_hexagonal_packing(n_circles: int, variant: int = 0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Hexagonal packing with constraint-aware radius initialization\n    \"\"\"\n    centers = []\n    \n    # Adjust packing density based on variant\n    rows = 6 + (variant % 2)\n    cols = 6 + (variant // 2)\n    \n    # Add margin to keep circles well within bounds\n    margin = 0.08\n    dx = (1.0 - 2*margin) / (cols + 0.5)\n    dy = (1.0 - 2*margin) / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = margin + (col + 0.5 + (row % 2) * 0.5) * dx\n            y = margin + (row + 0.5) * dy\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = compute_constraint_aware_radii(centers)\n    \n    return centers, radii\n\ndef create_lhs_packing(n_circles: int, seed: int = 0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create packing using Latin Hypercube Sampling for better space coverage\n    \"\"\"\n    sampler = qmc.LatinHypercube(d=2, seed=seed)\n    sample = sampler.random(n=n_circles)\n    \n    # Scale to [0.08, 0.92] to leave margin for radii\n    centers = 0.08 + sample * 0.84\n    \n    radii = compute_constraint_aware_radii(centers)\n    \n    return centers, radii\n\ndef create_sunflower_packing(n_circles: int, alpha: float = 0.0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create sunflower spiral pattern - efficient natural packing\n    \"\"\"\n    centers = []\n    golden_angle = np.pi * (3 - np.sqrt(5))  # Golden angle in radians\n    \n    for i in range(n_circles):\n        # Sunflower seed arrangement\n        angle = i * golden_angle + alpha\n        radius = 0.35 * np.sqrt(i / n_circles)  # Scale to fit in unit square\n        \n        x = 0.5 + radius * np.cos(angle)\n        y = 0.5 + radius * np.sin(angle)\n        \n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = compute_constraint_aware_radii(centers)\n    \n    return centers, radii\n\ndef create_hybrid_packing(n_circles: int, pattern: str) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create hybrid patterns combining multiple strategies\n    \"\"\"\n    if pattern == \"hex_grid\":\n        # Half hexagonal, half grid\n        n_hex = n_circles // 2\n        centers_hex, _ = create_hexagonal_packing(n_hex)\n        centers_grid, _ = create_grid_packing(n_circles - n_hex)\n        # Shift grid to different region\n        centers_grid = centers_grid * 0.4 + 0.55\n        centers = np.vstack([centers_hex, centers_grid])\n    \n    elif pattern == \"sunflower_concentric\":\n        # Inner sunflower, outer concentric\n        n_sun = n_circles * 2 // 3\n        centers_sun, _ = create_sunflower_packing(n_sun)\n        centers_con, _ = create_concentric_packing(n_circles - n_sun, layers=2)\n        centers = np.vstack([centers_sun, centers_con])\n    \n    else:  # \"lhs_repulsed\"\n        # Start with LHS, then apply repulsion\n        centers, _ = create_lhs_packing(n_circles)\n        centers = apply_repulsion(centers, iterations=50)\n    \n    centers = np.clip(centers, 0.05, 0.95)\n    radii = compute_constraint_aware_radii(centers)\n    \n    return centers, radii\n\ndef compute_constraint_aware_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute initial radii that respect boundary and overlap constraints\n    \"\"\"\n    n_circles = len(centers)\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Maximum radius based on boundary constraints\n        max_r_boundary = min(\n            centers[i, 0],\n            1 - centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 1]\n        )\n        \n        # Maximum radius based on distance to nearest neighbor\n        max_r_overlap = float('inf')\n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r_overlap = min(max_r_overlap, dist / 2.5)  # Conservative factor\n        \n        # Take minimum and add safety margin\n        radii[i] = min(max_r_boundary, max_r_overlap) * 0.9\n        radii[i] = max(radii[i], 0.01)  # Ensure positive\n    \n    return radii\n\ndef apply_repulsion(centers: np.ndarray, iterations: int = 50) -> np.ndarray:\n    \"\"\"\n    Apply repulsion forces to improve spacing\n    \"\"\"\n    centers = centers.copy()\n    n_circles = len(centers)\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist > 0:\n                        force = diff / (dist ** 3 + 0.001)\n                        forces[i] += force\n        \n        centers += 0.005 * forces\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    return centers\n\ndef select_methods_adaptively(method_stats: Dict, trial: int, total_trials: int) -> List[str]:\n    \"\"\"\n    Adaptively select optimization methods based on success rates\n    \"\"\"\n    # Early phase: try all methods\n    if trial < 10:\n        return ['SLSQP', 'trust-constr', 'COBYLA']\n    \n    # Calculate success rates\n    methods_with_scores = []\n    for method, stats in method_stats.items():\n        if stats['attempts'] > 0:\n            success_rate = stats['successes'] / stats['attempts']\n            avg_score = stats['avg_score']\n            # Combined metric: success rate and average score\n            combined_score = success_rate * 0.4 + (avg_score / 3.0) * 0.6\n            methods_with_scores.append((method, combined_score))\n    \n    # Sort by combined score\n    methods_with_scores.sort(key=lambda x: x[1], reverse=True)\n    \n    # Middle phase: focus on top 2 methods\n    if trial < total_trials * 0.7:\n        return [m[0] for m in methods_with_scores[:2]]\n    \n    # Late phase: focus on best method + occasional exploration\n    if np.random.rand() < 0.2:  # 20% exploration\n        return [m[0] for m in methods_with_scores]\n    else:\n        return [methods_with_scores[0][0]]\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, \n                     method: str = 'SLSQP', \n                     warm_start: Optional[Tuple] = None) -> Optional[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Optimize packing with warm-start capability\n    \"\"\"\n    n_circles = len(centers_init)\n    \n    # Use warm start if available and better\n    if warm_start is not None:",
  "timestamp": "2025-12-08T12:40:44.763260",
  "cost_data": null
}