{
  "trial_id": "trial_2_9",
  "generation": 2,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a multi-objective optimization for 26 circles in [0,1]x[0,1].\n\nObjectives:\n1. Maximize sum of radii (primary)\n2. Maximize minimum radius (secondary - ensures balanced packing)\n3. Minimize variance in radii (tertiary - promotes uniformity)\n\nStrategy:\n1. Use weighted sum approach with adaptive weights\n2. Explore Pareto front of trade-offs\n3. Select solution with best sum_radii from feasible Pareto solutions\n4. Use NSGA-II or similar multi-objective optimizer\n5. Add constraint handling through penalty functions\n\nMulti-objective view may find solutions missed by single-objective optimization.\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport matplotlib.pyplot as plt\n\n@dataclass\nclass PackingSolution:\n    \"\"\"Represents a circle packing solution\"\"\"\n    centers: np.ndarray  # (n, 2) array of circle centers\n    radii: np.ndarray    # (n,) array of radii\n    objectives: dict     # Dictionary of objective values\n    feasible: bool       # Whether solution satisfies all constraints\n    \n    def __repr__(self):\n        return (f\"PackingSolution(sum_radii={self.objectives['sum_radii']:.4f}, \"\n                f\"min_radius={self.objectives['min_radius']:.4f}, \"\n                f\"variance={self.objectives['variance']:.6f}, \"\n                f\"feasible={self.feasible})\")\n\nclass MultiObjectiveCirclePacking:\n    \"\"\"Multi-objective optimizer for circle packing\"\"\"\n    \n    def __init__(self, n_circles: int, bounds: Tuple[float, float] = (0, 1)):\n        self.n_circles = n_circles\n        self.bounds = bounds\n        self.min_bound, self.max_bound = bounds\n        \n    def decode_solution(self, x: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Decode flat parameter vector into centers and radii\"\"\"\n        # x = [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n        centers = x.reshape(-1, 3)[:, :2]\n        radii = x.reshape(-1, 3)[:, 2]\n        return centers, radii\n    \n    def check_feasibility(self, centers: np.ndarray, radii: np.ndarray) -> Tuple[bool, float]:\n        \"\"\"Check if packing is feasible and return violation amount\"\"\"\n        violation = 0.0\n        \n        # Check boundary constraints\n        for i in range(len(centers)):\n            # Check if circle is within bounds\n            if (centers[i, 0] - radii[i] < self.min_bound or\n                centers[i, 0] + radii[i] > self.max_bound or\n                centers[i, 1] - radii[i] < self.min_bound or\n                centers[i, 1] + radii[i] > self.max_bound):\n                \n                violation += max(\n                    self.min_bound - (centers[i, 0] - radii[i]),\n                    centers[i, 0] + radii[i] - self.max_bound,\n                    self.min_bound - (centers[i, 1] - radii[i]),\n                    centers[i, 1] + radii[i] - self.max_bound,\n                    0\n                )\n        \n        # Check circle overlap constraints\n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required_dist = radii[i] + radii[j]\n                if dist < required_dist:\n                    violation += required_dist - dist\n        \n        return violation < 1e-6, violation\n    \n    def compute_objectives(self, centers: np.ndarray, radii: np.ndarray) -> dict:\n        \"\"\"Compute all objective values\"\"\"\n        return {\n            'sum_radii': np.sum(radii),\n            'min_radius': np.min(radii),\n            'variance': np.var(radii),\n            'std_dev': np.std(radii)\n        }\n    \n    def weighted_objective(self, x: np.ndarray, weights: dict, penalty_coef: float = 1000.0) -> float:\n        \"\"\"Compute weighted multi-objective function with penalties\"\"\"\n        centers, radii = self.decode_solution(x)\n        \n        # Check feasibility\n        feasible, violation = self.check_feasibility(centers, radii)\n        \n        # Compute objectives\n        obj = self.compute_objectives(centers, radii)\n        \n        # Weighted sum (negative because we minimize)\n        score = (\n            -weights['sum_radii'] * obj['sum_radii'] +\n            -weights['min_radius'] * obj['min_radius'] +\n            weights['variance'] * obj['variance']\n        )\n        \n        # Add penalty for constraint violations\n        if not feasible:\n            score += penalty_coef * violation\n        \n        return score\n    \n    def optimize_with_weights(self, weights: dict, max_iter: int = 300, \n                             popsize: int = 20, seed: int = None) -> PackingSolution:\n        \"\"\"Run optimization with specific weight configuration\"\"\"\n        # Define bounds for differential evolution\n        # Each circle: (x, y, r) where x,y in [0,1] and r in [0, 0.5]\n        bounds = []\n        for _ in range(self.n_circles):\n            bounds.extend([\n                (self.min_bound, self.max_bound),  # x\n                (self.min_bound, self.max_bound),  # y\n                (0.001, 0.5)  # radius\n            ])\n        \n        # Run optimization\n        result = differential_evolution(\n            lambda x: self.weighted_objective(x, weights),\n            bounds,\n            maxiter=max_iter,\n            popsize=popsize,\n            seed=seed,\n            polish=True,\n            atol=1e-8,\n            tol=1e-8,\n            workers=1\n        )\n        \n        # Decode solution\n        centers, radii = self.decode_solution(result.x)\n        feasible, _ = self.check_feasibility(centers, radii)\n        objectives = self.compute_objectives(centers, radii)\n        \n        return PackingSolution(centers, radii, objectives, feasible)\n    \n    def pareto_dominates(self, sol1: PackingSolution, sol2: PackingSolution) -> bool:\n        \"\"\"Check if sol1 Pareto dominates sol2\"\"\"\n        if not sol1.feasible or not sol2.feasible:\n            return sol1.feasible and not sol2.feasible\n        \n        # For maximization objectives (sum_radii, min_radius), sol1 should be >=\n        # For minimization objective (variance), sol1 should be <=\n        better_sum = sol1.objectives['sum_radii'] >= sol2.objectives['sum_radii']\n        better_min = sol1.objectives['min_radius'] >= sol2.objectives['min_radius']\n        better_var = sol1.objectives['variance'] <= sol2.objectives['variance']\n        \n        # At least one strictly better\n        strictly_better = (\n            sol1.objectives['sum_radii'] > sol2.objectives['sum_radii'] or\n            sol1.objectives['min_radius'] > sol2.objectives['min_radius'] or\n            sol1.objectives['variance'] < sol2.objectives['variance']\n        )\n        \n        return better_sum and better_min and better_var and strictly_better\n    \n    def find_pareto_front(self, solutions: List[PackingSolution]) -> List[PackingSolution]:\n        \"\"\"Extract Pareto front from set of solutions\"\"\"\n        pareto_front = []\n        \n        for sol in solutions:\n            dominated = False\n            for other in solutions:\n                if self.pareto_dominates(other, sol):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_front.append(sol)\n        \n        return pareto_front\n\ndef construct_packing(n_circles: int = 26, n_weight_configs: int = 15, \n                     max_iter: int = 400, seed: int = 42) -> PackingSolution:\n    \"\"\"\n    Construct circle packing using multi-objective optimization.\n    \n    Args:\n        n_circles: Number of circles to pack\n        n_weight_configs: Number of different weight configurations to try\n        max_iter: Maximum iterations per optimization run\n        seed: Random seed for reproducibility\n        \n    Returns:\n        Best PackingSolution found\n    \"\"\"\n    optimizer = MultiObjectiveCirclePacking(n_circles)\n    \n    print(f\"Multi-Objective Circle Packing for {n_circles} circles\")\n    print(\"=\" * 60)\n    \n    # Generate diverse weight configurations\n    weight_configs = []\n    \n    # Strategy 1: Focus on sum of radii\n    weight_configs.append({\n        'sum_radii': 1.0,\n        'min_radius': 0.1,\n        'variance': 0.01\n    })\n    \n    # Strategy 2: Balance sum and minimum radius\n    weight_configs.append({\n        'sum_radii': 0.7,\n        'min_radius': 0.3,\n        'variance': 0.01\n    })\n    \n    # Strategy 3: Emphasize uniformity\n    weight_configs.append({\n        'sum_radii': 0.5,\n        'min_radius': 0.2,\n        'variance': 0.5\n    })\n    \n    # Strategy 4: Focus on minimum radius\n    weight_configs.append({\n        'sum_radii': 0.3,\n        'min_radius': 0.7,\n        'variance': 0.05\n    })\n    \n    # Strategy 5: Pure sum maximization\n    weight_configs.append({\n        'sum_radii': 1.0,\n        'min_radius': 0.0,\n        'variance': 0.0\n    })\n    \n    # Add interpolated configurations\n    for alpha in np.linspace(0, 1, n_weight_configs - 5):\n        weight_configs.append({\n            'sum_radii': 1.0 - 0.5 * alpha,\n            'min_radius': 0.3 * alpha,\n            'variance': 0.2 * alpha\n        })\n    \n    # Run optimization with each weight configuration\n    solutions = []\n    np.random.seed(seed)\n    \n    for i, weights in enumerate(weight_configs):\n        print(f\"\\nRun {i+1}/{len(weight_configs)}: \"\n              f\"w_sum={weights['sum_radii']:.2f}, \"\n              f\"w_min={weights['min_radius']:.2f}, \"\n              f\"w_var={weights['variance']:.2f}\")\n        \n        sol = optimizer.optimize_with_weights(\n            weights, \n            max_iter=max_iter,\n            popsize=15,\n            seed=seed + i\n        )\n        \n        solutions.append(sol)\n        print(f\"  Result: {sol}\")\n    \n    # Find Pareto front\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Extracting Pareto Front...\")\n    pareto_front = optimizer.find_pareto_front(solutions)\n    \n    print(f\"\\nFound {len(pareto_front)} Pareto optimal solutions:\")\n    for i, sol in enumerate(pareto_front):\n        print(f\"  {i+1}. {sol}\")\n    \n    # Select best solution from Pareto front (maximize sum_radii among feasible)\n    feasible_pareto = [sol for sol in pareto_front if sol.feasible]\n    \n    if not feasible_pareto:\n        print(\"\\nWarning: No feasible Pareto solutions found!\")\n        feasible_solutions = [sol for sol in solutions if sol.feasible]\n        if feasible_solutions:\n            best_solution = max(feasible_solutions, \n                              key=lambda s: s.objectives['sum_radii'])\n        else:\n            best_solution = max(solutions, \n                              key=lambda s: s.objectives['sum_radii'])\n    else:\n        best_solution = max(feasible_pareto, \n                           key=lambda s: s.objectives['sum_radii'])\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"BEST SOLUTION:\")\n    print(best_solution)\n    print(f\"  Sum of radii: {best_solution.objectives['sum_radii']:.6f}\")\n    print(f\"  Min radius: {best_solution.objectives['min_radius']:.6f}\")\n    print(f\"  Max radius: {np.max(best_solution.radii):.6f}\")\n    print(f\"  Variance: {best_solution.objectives['variance']:.6f}\")\n    print(f\"  Std dev: {best_solution.objectives['std_dev']:.6f}\")\n    print(f\"  Feasible: {best_solution.feasible}\")\n    \n    return best_solution\n\ndef run_packing(solution: PackingSolution, save_plot: bool = True, \n                filename: str = \"circle_packing.png\"):\n    \"\"\"\n    Visualize and analyze the packing solution.\n    \n    Args:\n        solution: PackingSolution to visualize\n        save_plot: Whether to save the plot to file\n        filename: Output filename for plot\n    \"\"\"\n    fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n    \n    # Plot 1: Circle packing visualization\n    ax1 = axes[0]\n    ax1.set_xlim(0, 1)\n    ax1.set_ylim(0, 1)\n    ax1.set_aspect('equal')\n    ax1.set_title(f'Circle Packing ({len(solution.radii)} circles)', fontsize=14, fontweight='bold')\n    ax1.set_xlabel('x')\n    ax1.set_ylabel('y')\n    ax1.grid(True, alpha=0.3)\n    \n    # Draw circles with color based on radius\n    radii_normalized = (solution.radii - solution.radii.min()) / (solution.radii.max() - solution.radii.min() + 1e-10)\n    \n    for i, (center, radius) in enumerate(zip(solution.centers, solution.radii)):\n        circle = plt.Circle(center, radius, \n                          color=plt.cm.viridis(radii_normalized[i]),\n                          alpha=0.6, ec='black', linewidth=1.5)\n        ax1.add_patch(circle)\n        ax1.plot(center[0], center[1], 'k.', markersize=3)\n    \n    # Add colorbar\n    sm = plt.cm.ScalarMappable(cmap=plt.cm.viridis, \n                               norm=plt.Normalize(vmin=solution.radii.min(), \n                                                 vmax=solution.radii.max()))\n    sm.set_array([])\n    cbar = plt.colorbar(sm, ax=ax1)\n    cbar.set_label('Radius', rotation=270, labelpad=15)\n    \n    # Plot 2: Radius distribution\n    ax2 = axes[1]\n    ax2.hist(solution.radii, bins=15, color='steelblue', alpha=0.7, edgecolor='black')\n    ax2.axvline(solution.objectives['min_radius'], color='red', \n                linestyle='--', linewidth=2, label=f\"Min: {solution.objectives['min_radius']:.4f}\")\n    ax2.axvline(np.mean(solution.radii), color='green', \n                linestyle='--', linewidth=2, label=f\"Mean: {np.mean(solution.radii):.4f}\")\n    ax2.axvline(np.max(solution.radii), color='orange', \n                linestyle='--', linewidth=2, label=f\"Max: {np.max(solution.radii):.4f}\")\n    ax2.set_xlabel('Radius')\n    ax2.set_ylabel('Frequency')\n    ax2.set_title('Radius Distribution', fontsize=14, fontweight='bold')\n    ax2.legend()\n    ax2.grid(True, alpha=0.3)\n    \n    # Add statistics text\n    stats_text = (\n        f\"Objectives:\\n\"\n        f\"  Sum of radii: {solution.objectives['sum_radii']:.4f}\\n\"\n        f\"  Min radius: {solution.objectives['min_radius']:.4f}\\n\"\n        f\"  Variance: {solution.objectives['variance']:.6f}\\n\"\n        f",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport matplotlib.pyplot as plt\n\n@dataclass\nclass PackingSolution:\n    \"\"\"Represents a circle packing solution\"\"\"\n    centers: np.ndarray  # (n, 2) array of circle centers\n    radii: np.ndarray    # (n,) array of radii\n    objectives: dict     # Dictionary of objective values\n    feasible: bool       # Whether solution satisfies all constraints\n    \n    def __repr__(self):\n        return (f\"PackingSolution(sum_radii={self.objectives['sum_radii']:.4f}, \"\n                f\"min_radius={self.objectives['min_radius']:.4f}, \"\n                f\"variance={self.objectives['variance']:.6f}, \"\n                f\"feasible={self.feasible})\")\n\nclass MultiObjectiveCirclePacking:\n    \"\"\"Multi-objective optimizer for circle packing\"\"\"\n    \n    def __init__(self, n_circles: int, bounds: Tuple[float, float] = (0, 1)):\n        self.n_circles = n_circles\n        self.bounds = bounds\n        self.min_bound, self.max_bound = bounds\n        \n    def decode_solution(self, x: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Decode flat parameter vector into centers and radii\"\"\"\n        # x = [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n        centers = x.reshape(-1, 3)[:, :2]\n        radii = x.reshape(-1, 3)[:, 2]\n        return centers, radii\n    \n    def check_feasibility(self, centers: np.ndarray, radii: np.ndarray) -> Tuple[bool, float]:\n        \"\"\"Check if packing is feasible and return violation amount\"\"\"\n        violation = 0.0\n        \n        # Check boundary constraints\n        for i in range(len(centers)):\n            # Check if circle is within bounds\n            if (centers[i, 0] - radii[i] < self.min_bound or\n                centers[i, 0] + radii[i] > self.max_bound or\n                centers[i, 1] - radii[i] < self.min_bound or\n                centers[i, 1] + radii[i] > self.max_bound):\n                \n                violation += max(\n                    self.min_bound - (centers[i, 0] - radii[i]),\n                    centers[i, 0] + radii[i] - self.max_bound,\n                    self.min_bound - (centers[i, 1] - radii[i]),\n                    centers[i, 1] + radii[i] - self.max_bound,\n                    0\n                )\n        \n        # Check circle overlap constraints\n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required_dist = radii[i] + radii[j]\n                if dist < required_dist:\n                    violation += required_dist - dist\n        \n        return violation < 1e-6, violation\n    \n    def compute_objectives(self, centers: np.ndarray, radii: np.ndarray) -> dict:\n        \"\"\"Compute all objective values\"\"\"\n        return {\n            'sum_radii': np.sum(radii),\n            'min_radius': np.min(radii),\n            'variance': np.var(radii),\n            'std_dev': np.std(radii)\n        }\n    \n    def weighted_objective(self, x: np.ndarray, weights: dict, penalty_coef: float = 1000.0) -> float:\n        \"\"\"Compute weighted multi-objective function with penalties\"\"\"\n        centers, radii = self.decode_solution(x)\n        \n        # Check feasibility\n        feasible, violation = self.check_feasibility(centers, radii)\n        \n        # Compute objectives\n        obj = self.compute_objectives(centers, radii)\n        \n        # Weighted sum (negative because we minimize)\n        score = (\n            -weights['sum_radii'] * obj['sum_radii'] +\n            -weights['min_radius'] * obj['min_radius'] +\n            weights['variance'] * obj['variance']\n        )\n        \n        # Add penalty for constraint violations\n        if not feasible:\n            score += penalty_coef * violation\n        \n        return score\n    \n    def optimize_with_weights(self, weights: dict, max_iter: int = 300, \n                             popsize: int = 20, seed: int = None) -> PackingSolution:\n        \"\"\"Run optimization with specific weight configuration\"\"\"\n        # Define bounds for differential evolution\n        # Each circle: (x, y, r) where x,y in [0,1] and r in [0, 0.5]\n        bounds = []\n        for _ in range(self.n_circles):\n            bounds.extend([\n                (self.min_bound, self.max_bound),  # x\n                (self.min_bound, self.max_bound),  # y\n                (0.001, 0.5)  # radius\n            ])\n        \n        # Run optimization\n        result = differential_evolution(\n            lambda x: self.weighted_objective(x, weights),\n            bounds,\n            maxiter=max_iter,\n            popsize=popsize,\n            seed=seed,\n            polish=True,\n            atol=1e-8,\n            tol=1e-8,\n            workers=1\n        )\n        \n        # Decode solution\n        centers, radii = self.decode_solution(result.x)\n        feasible, _ = self.check_feasibility(centers, radii)\n        objectives = self.compute_objectives(centers, radii)\n        \n        return PackingSolution(centers, radii, objectives, feasible)\n    \n    def pareto_dominates(self, sol1: PackingSolution, sol2: PackingSolution) -> bool:\n        \"\"\"Check if sol1 Pareto dominates sol2\"\"\"\n        if not sol1.feasible or not sol2.feasible:\n            return sol1.feasible and not sol2.feasible\n        \n        # For maximization objectives (sum_radii, min_radius), sol1 should be >=\n        # For minimization objective (variance), sol1 should be <=\n        better_sum = sol1.objectives['sum_radii'] >= sol2.objectives['sum_radii']\n        better_min = sol1.objectives['min_radius'] >= sol2.objectives['min_radius']\n        better_var = sol1.objectives['variance'] <= sol2.objectives['variance']\n        \n        # At least one strictly better\n        strictly_better = (\n            sol1.objectives['sum_radii'] > sol2.objectives['sum_radii'] or\n            sol1.objectives['min_radius'] > sol2.objectives['min_radius'] or\n            sol1.objectives['variance'] < sol2.objectives['variance']\n        )\n        \n        return better_sum and better_min and better_var and strictly_better\n    \n    def find_pareto_front(self, solutions: List[PackingSolution]) -> List[PackingSolution]:\n        \"\"\"Extract Pareto front from set of solutions\"\"\"\n        pareto_front = []\n        \n        for sol in solutions:\n            dominated = False\n            for other in solutions:\n                if self.pareto_dominates(other, sol):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_front.append(sol)\n        \n        return pareto_front\n\ndef construct_packing(n_circles: int = 26, n_weight_configs: int = 15, \n                     max_iter: int = 400, seed: int = 42) -> PackingSolution:\n    \"\"\"\n    Construct circle packing using multi-objective optimization.\n    \n    Args:\n        n_circles: Number of circles to pack\n        n_weight_configs: Number of different weight configurations to try\n        max_iter: Maximum iterations per optimization run\n        seed: Random seed for reproducibility\n        \n    Returns:\n        Best PackingSolution found\n    \"\"\"\n    optimizer = MultiObjectiveCirclePacking(n_circles)\n    \n    print(f\"Multi-Objective Circle Packing for {n_circles} circles\")\n    print(\"=\" * 60)\n    \n    # Generate diverse weight configurations\n    weight_configs = []\n    \n    # Strategy 1: Focus on sum of radii\n    weight_configs.append({\n        'sum_radii': 1.0,\n        'min_radius': 0.1,\n        'variance': 0.01\n    })\n    \n    # Strategy 2: Balance sum and minimum radius\n    weight_configs.append({\n        'sum_radii': 0.7,\n        'min_radius': 0.3,\n        'variance': 0.01\n    })\n    \n    # Strategy 3: Emphasize uniformity\n    weight_configs.append({\n        'sum_radii': 0.5,\n        'min_radius': 0.2,\n        'variance': 0.5\n    })\n    \n    # Strategy 4: Focus on minimum radius\n    weight_configs.append({\n        'sum_radii': 0.3,\n        'min_radius': 0.7,\n        'variance': 0.05\n    })\n    \n    # Strategy 5: Pure sum maximization\n    weight_configs.append({\n        'sum_radii': 1.0,\n        'min_radius': 0.0,\n        'variance': 0.0\n    })\n    \n    # Add interpolated configurations\n    for alpha in np.linspace(0, 1, n_weight_configs - 5):\n        weight_configs.append({\n            'sum_radii': 1.0 - 0.5 * alpha,\n            'min_radius': 0.3 * alpha,\n            'variance': 0.2 * alpha\n        })\n    \n    # Run optimization with each weight configuration\n    solutions = []\n    np.random.seed(seed)\n    \n    for i, weights in enumerate(weight_configs):\n        print(f\"\\nRun {i+1}/{len(weight_configs)}: \"\n              f\"w_sum={weights['sum_radii']:.2f}, \"\n              f\"w_min={weights['min_radius']:.2f}, \"\n              f\"w_var={weights['variance']:.2f}\")\n        \n        sol = optimizer.optimize_with_weights(\n            weights, \n            max_iter=max_iter,\n            popsize=15,\n            seed=seed + i\n        )\n        \n        solutions.append(sol)\n        print(f\"  Result: {sol}\")\n    \n    # Find Pareto front\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Extracting Pareto Front...\")\n    pareto_front = optimizer.find_pareto_front(solutions)\n    \n    print(f\"\\nFound {len(pareto_front)} Pareto optimal solutions:\")\n    for i, sol in enumerate(pareto_front):\n        print(f\"  {i+1}. {sol}\")\n    \n    # Select best solution from Pareto front (maximize sum_radii among feasible)\n    feasible_pareto = [sol for sol in pareto_front if sol.feasible]\n    \n    if not feasible_pareto:\n        print(\"\\nWarning: No feasible Pareto solutions found!\")\n        feasible_solutions = [sol for sol in solutions if sol.feasible]\n        if feasible_solutions:\n            best_solution = max(feasible_solutions, \n                              key=lambda s: s.objectives['sum_radii'])\n        else:\n            best_solution = max(solutions, \n                              key=lambda s: s.objectives['sum_radii'])\n    else:\n        best_solution = max(feasible_pareto, \n                           key=lambda s: s.objectives['sum_radii'])\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"BEST SOLUTION:\")\n    print(best_solution)\n    print(f\"  Sum of radii: {best_solution.objectives['sum_radii']:.6f}\")\n    print(f\"  Min radius: {best_solution.objectives['min_radius']:.6f}\")\n    print(f\"  Max radius: {np.max(best_solution.radii):.6f}\")\n    print(f\"  Variance: {best_solution.objectives['variance']:.6f}\")\n    print(f\"  Std dev: {best_solution.objectives['std_dev']:.6f}\")\n    print(f\"  Feasible: {best_solution.feasible}\")\n    \n    return best_solution\n\ndef run_packing(solution: PackingSolution, save_plot: bool = True, \n                filename: str = \"circle_packing.png\"):\n    \"\"\"\n    Visualize and analyze the packing solution.\n    \n    Args:\n        solution: PackingSolution to visualize\n        save_plot: Whether to save the plot to file\n        filename: Output filename for plot\n    \"\"\"\n    fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n    \n    # Plot 1: Circle packing visualization\n    ax1 = axes[0]\n    ax1.set_xlim(0, 1)\n    ax1.set_ylim(0, 1)\n    ax1.set_aspect('equal')\n    ax1.set_title(f'Circle Packing ({len(solution.radii)} circles)', fontsize=14, fontweight='bold')\n    ax1.set_xlabel('x')\n    ax1.set_ylabel('y')\n    ax1.grid(True, alpha=0.3)\n    \n    # Draw circles with color based on radius\n    radii_normalized = (solution.radii - solution.radii.min()) / (solution.radii.max() - solution.radii.min() + 1e-10)\n    \n    for i, (center, radius) in enumerate(zip(solution.centers, solution.radii)):\n        circle = plt.Circle(center, radius, \n                          color=plt.cm.viridis(radii_normalized[i]),\n                          alpha=0.6, ec='black', linewidth=1.5)\n        ax1.add_patch(circle)\n        ax1.plot(center[0], center[1], 'k.', markersize=3)\n    \n    # Add colorbar\n    sm = plt.cm.ScalarMappable(cmap=plt.cm.viridis, \n                               norm=plt.Normalize(vmin=solution.radii.min(), \n                                                 vmax=solution.radii.max()))\n    sm.set_array([])\n    cbar = plt.colorbar(sm, ax=ax1)\n    cbar.set_label('Radius', rotation=270, labelpad=15)\n    \n    # Plot 2: Radius distribution\n    ax2 = axes[1]\n    ax2.hist(solution.radii, bins=15, color='steelblue', alpha=0.7, edgecolor='black')\n    ax2.axvline(solution.objectives['min_radius'], color='red', \n                linestyle='--', linewidth=2, label=f\"Min: {solution.objectives['min_radius']:.4f}\")\n    ax2.axvline(np.mean(solution.radii), color='green', \n                linestyle='--', linewidth=2, label=f\"Mean: {np.mean(solution.radii):.4f}\")\n    ax2.axvline(np.max(solution.radii), color='orange', \n                linestyle='--', linewidth=2, label=f\"Max: {np.max(solution.radii):.4f}\")\n    ax2.set_xlabel('Radius')\n    ax2.set_ylabel('Frequency')\n    ax2.set_title('Radius Distribution', fontsize=14, fontweight='bold')\n    ax2.legend()\n    ax2.grid(True, alpha=0.3)\n    \n    # Add statistics text\n    stats_text = (\n        f\"Objectives:\\n\"\n        f\"  Sum of radii: {solution.objectives['sum_radii']:.4f}\\n\"\n        f\"  Min radius: {solution.objectives['min_radius']:.4f}\\n\"\n        f\"  Variance: {solution.objectives['variance']:.6f}\\n\"\n        f",
  "timestamp": "2025-12-08T12:40:42.897076",
  "cost_data": null
}