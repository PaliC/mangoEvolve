{
  "trial_id": "trial_2_11",
  "generation": 2,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a CMA-ES (Covariance Matrix Adaptation Evolution Strategy) optimizer for 26 circles.\n\nStrategy:\n1. Use CMA-ES for global search (excellent for continuous optimization)\n2. Encode solution as: [x1, y1, r1, ..., x26, y26, r26]\n3. Handle constraints through penalty functions with adaptive weights\n4. Use restarts with increasing population size if stuck\n5. Post-process best solution with local optimization (SLSQP)\n\nCMA-ES is state-of-art for difficult continuous optimization problems.\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom dataclasses import dataclass\nfrom typing import List, Tuple, Optional\nimport time\n\n@dataclass\nclass Circle:\n    x: float\n    y: float\n    r: float\n\nclass CMAESOptimizer:\n    \"\"\"CMA-ES optimizer for circle packing problem.\"\"\"\n    \n    def __init__(self, n_circles: int, container_radius: float = 1.0):\n        self.n_circles = n_circles\n        self.container_radius = container_radius\n        self.dim = 3 * n_circles  # x, y, r for each circle\n        \n        # CMA-ES parameters\n        self.lambda_ = 4 + int(3 * np.log(self.dim))  # population size\n        self.mu = self.lambda_ // 2  # number of parents\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights /= np.sum(self.weights)\n        self.mu_eff = 1.0 / np.sum(self.weights ** 2)\n        \n        # Adaptation parameters\n        self.cc = (4 + self.mu_eff / self.dim) / (self.dim + 4 + 2 * self.mu_eff / self.dim)\n        self.cs = (self.mu_eff + 2) / (self.dim + self.mu_eff + 5)\n        self.c1 = 2 / ((self.dim + 1.3) ** 2 + self.mu_eff)\n        self.cmu = min(1 - self.c1, 2 * (self.mu_eff - 2 + 1 / self.mu_eff) / \n                       ((self.dim + 2) ** 2 + self.mu_eff))\n        self.damps = 1 + 2 * max(0, np.sqrt((self.mu_eff - 1) / (self.dim + 1)) - 1) + self.cs\n        \n        # Dynamic state\n        self.mean = None\n        self.sigma = None\n        self.pc = None\n        self.ps = None\n        self.C = None\n        self.B = None\n        self.D = None\n        self.BD = None\n        self.eigeneval = 0\n        self.counteval = 0\n        self.chi_n = self.dim ** 0.5 * (1 - 1 / (4 * self.dim) + 1 / (21 * self.dim ** 2))\n        \n        # Best solution tracking\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        \n        # Penalty weights (adaptive)\n        self.penalty_overlap = 1000.0\n        self.penalty_container = 1000.0\n        self.penalty_radius = 100.0\n        \n    def initialize(self, mean: Optional[np.ndarray] = None, sigma: float = 0.3):\n        \"\"\"Initialize CMA-ES state.\"\"\"\n        if mean is None:\n            # Smart initialization: arrange circles in a grid-like pattern\n            mean = self._smart_initialization()\n        \n        self.mean = mean.copy()\n        self.sigma = sigma\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.C = np.eye(self.dim)\n        self.B = np.eye(self.dim)\n        self.D = np.ones(self.dim)\n        self.BD = self.B * self.D\n        self.eigeneval = 0\n        self.counteval = 0\n        \n    def _smart_initialization(self) -> np.ndarray:\n        \"\"\"Create a smart initial solution.\"\"\"\n        mean = np.zeros(self.dim)\n        \n        # Estimate reasonable radius\n        area_per_circle = np.pi * self.container_radius ** 2 / self.n_circles\n        r_init = np.sqrt(area_per_circle / np.pi) * 0.7  # Conservative estimate\n        \n        # Arrange in concentric circles\n        n_inner = min(6, self.n_circles)\n        n_outer = self.n_circles - n_inner\n        \n        idx = 0\n        # Inner circle\n        r_inner = self.container_radius * 0.3\n        for i in range(n_inner):\n            angle = 2 * np.pi * i / n_inner\n            mean[idx * 3] = r_inner * np.cos(angle)\n            mean[idx * 3 + 1] = r_inner * np.sin(angle)\n            mean[idx * 3 + 2] = r_init\n            idx += 1\n        \n        # Outer circle\n        if n_outer > 0:\n            r_outer = self.container_radius * 0.65\n            for i in range(n_outer):\n                angle = 2 * np.pi * i / n_outer\n                mean[idx * 3] = r_outer * np.cos(angle)\n                mean[idx * 3 + 1] = r_outer * np.sin(angle)\n                mean[idx * 3 + 2] = r_init\n                idx += 1\n        \n        return mean\n    \n    def decode_solution(self, x: np.ndarray) -> List[Circle]:\n        \"\"\"Decode flat array to list of circles.\"\"\"\n        circles = []\n        for i in range(self.n_circles):\n            circles.append(Circle(\n                x=x[i * 3],\n                y=x[i * 3 + 1],\n                r=abs(x[i * 3 + 2])  # Ensure positive radius\n            ))\n        return circles\n    \n    def objective(self, x: np.ndarray) -> float:\n        \"\"\"\n        Objective function: minimize the negative of minimum radius\n        (i.e., maximize minimum radius) with penalties for constraint violations.\n        \"\"\"\n        circles = self.decode_solution(x)\n        \n        # Primary objective: maximize minimum radius\n        min_radius = min(c.r for c in circles)\n        fitness = -min_radius\n        \n        # Penalty for overlap between circles\n        overlap_penalty = 0.0\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                dist = np.sqrt((circles[i].x - circles[j].x) ** 2 + \n                              (circles[i].y - circles[j].y) ** 2)\n                required_dist = circles[i].r + circles[j].r\n                if dist < required_dist:\n                    overlap = required_dist - dist\n                    overlap_penalty += overlap ** 2\n        \n        # Penalty for circles outside container\n        container_penalty = 0.0\n        for c in circles:\n            dist_from_center = np.sqrt(c.x ** 2 + c.y ** 2)\n            if dist_from_center + c.r > self.container_radius:\n                violation = dist_from_center + c.r - self.container_radius\n                container_penalty += violation ** 2\n        \n        # Penalty for very small or negative radii\n        radius_penalty = 0.0\n        for c in circles:\n            if c.r < 0.001:\n                radius_penalty += (0.001 - c.r) ** 2\n        \n        # Combined fitness\n        total_penalty = (self.penalty_overlap * overlap_penalty + \n                        self.penalty_container * container_penalty +\n                        self.penalty_radius * radius_penalty)\n        \n        return fitness + total_penalty\n    \n    def ask(self) -> np.ndarray:\n        \"\"\"Generate new population.\"\"\"\n        population = np.zeros((self.lambda_, self.dim))\n        \n        for k in range(self.lambda_):\n            z = np.random.randn(self.dim)\n            y = self.BD @ z\n            population[k] = self.mean + self.sigma * y\n        \n        return population\n    \n    def tell(self, population: np.ndarray, fitness: np.ndarray):\n        \"\"\"Update distribution based on fitness.\"\"\"\n        # Sort by fitness\n        idx = np.argsort(fitness)\n        old_mean = self.mean.copy()\n        \n        # Update mean\n        self.mean = population[idx[:self.mu]].T @ self.weights\n        \n        # Update evolution paths\n        y = (self.mean - old_mean) / self.sigma\n        z = np.linalg.solve(self.BD, y)\n        \n        self.ps = (1 - self.cs) * self.ps + \\\n                  np.sqrt(self.cs * (2 - self.cs) * self.mu_eff) * (self.B @ z)\n        \n        hsig = (np.linalg.norm(self.ps) / \n                np.sqrt(1 - (1 - self.cs) ** (2 * self.counteval / self.lambda_)) / \n                self.chi_n < 1.4 + 2 / (self.dim + 1))\n        \n        self.pc = (1 - self.cc) * self.pc + \\\n                  hsig * np.sqrt(self.cc * (2 - self.cc) * self.mu_eff) * y\n        \n        # Update covariance matrix\n        artmp = (population[idx[:self.mu]] - old_mean).T / self.sigma\n        self.C = (1 - self.c1 - self.cmu) * self.C + \\\n                 self.c1 * (np.outer(self.pc, self.pc) + \n                           (1 - hsig) * self.cc * (2 - self.cc) * self.C) + \\\n                 self.cmu * artmp @ np.diag(self.weights) @ artmp.T\n        \n        # Update step size\n        self.sigma *= np.exp((self.cs / self.damps) * \n                            (np.linalg.norm(self.ps) / self.chi_n - 1))\n        \n        # Update B, D from C\n        if self.counteval - self.eigeneval > self.lambda_ / (self.c1 + self.cmu) / self.dim / 10:\n            self.eigeneval = self.counteval\n            self.C = np.triu(self.C) + np.triu(self.C, 1).T  # Enforce symmetry\n            self.D, self.B = np.linalg.eigh(self.C)\n            self.D = np.sqrt(np.maximum(self.D, 0))\n            self.BD = self.B * self.D\n        \n        # Track best solution\n        if fitness[idx[0]] < self.best_fitness:\n            self.best_fitness = fitness[idx[0]]\n            self.best_solution = population[idx[0]].copy()\n        \n        self.counteval += self.lambda_\n    \n    def optimize(self, max_iter: int = 1000, tol: float = 1e-10, verbose: bool = True) -> Tuple[np.ndarray, float]:\n        \"\"\"Run CMA-ES optimization.\"\"\"\n        self.initialize()\n        \n        for iteration in range(max_iter):\n            # Generate and evaluate population\n            population = self.ask()\n            fitness = np.array([self.objective(ind) for ind in population])\n            \n            # Update distribution\n            self.tell(population, fitness)\n            \n            if verbose and iteration % 50 == 0:\n                print(f\"Iteration {iteration}: Best fitness = {self.best_fitness:.6f}, \"\n                      f\"Min radius = {-self.best_fitness:.6f}, Sigma = {self.sigma:.6f}\")\n            \n            # Convergence check\n            if self.sigma < tol:\n                if verbose:\n                    print(f\"Converged at iteration {iteration}\")\n                break\n        \n        return self.best_solution, self.best_fitness\n\ndef local_refinement(solution: np.ndarray, n_circles: int, container_radius: float) -> np.ndarray:\n    \"\"\"Refine solution using local optimization (SLSQP).\"\"\"\n    \n    def objective(x):\n        min_r = min(abs(x[i * 3 + 2]) for i in range(n_circles))\n        return -min_r\n    \n    def constraint_no_overlap(x, i, j):\n        xi, yi, ri = x[i*3], x[i*3+1], abs(x[i*3+2])\n        xj, yj, rj = x[j*3], x[j*3+1], abs(x[j*3+2])\n        dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n        return dist - (ri + rj)\n    \n    def constraint_in_container(x, i):\n        xi, yi, ri = x[i*3], x[i*3+1], abs(x[i*3+2])\n        dist = np.sqrt(xi**2 + yi**2)\n        return container_radius - (dist + ri)\n    \n    constraints = []\n    \n    # No overlap constraints\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            constraints.append({\n                'type': 'ineq',\n                'fun': constraint_no_overlap,\n                'args': (i, j)\n            })\n    \n    # Container constraints\n    for i in range(n_circles):\n        constraints.append({\n            'type': 'ineq',\n            'fun': constraint_in_container,\n            'args': (i,)\n        })\n    \n    # Bounds: radius must be positive\n    bounds = []\n    for i in range(n_circles):\n        bounds.extend([(-container_radius, container_radius),  # x\n                      (-container_radius, container_radius),  # y\n                      (0.001, container_radius)])  # r\n    \n    result = minimize(objective, solution, method='SLSQP', \n                     bounds=bounds, constraints=constraints,\n                     options={'maxiter': 500, 'ftol': 1e-9})\n    \n    return result.x if result.success else solution\n\ndef construct_packing(n_circles: int = 26, container_radius: float = 1.0) -> CMAESOptimizer:\n    \"\"\"Construct a CMA-ES optimizer for circle packing.\"\"\"\n    return CMAESOptimizer(n_circles, container_radius)\n\ndef run_packing(optimizer: CMAESOptimizer, max_time: float = 60.0, \n                n_restarts: int = 3, verbose: bool = True) -> List[Circle]:\n    \"\"\"\n    Run circle packing optimization with restarts.\n    \n    Args:\n        optimizer: CMA-ES optimizer instance\n        max_time: Maximum time in seconds\n        n_restarts: Number of restarts with increasing population\n        verbose: Print progress\n    \n    Returns:\n        List of optimized circles\n    \"\"\"\n    start_time = time.time()\n    best_solution = None\n    best_fitness = float('inf')\n    \n    for restart in range(n_restarts):\n        if time.time() - start_time > max_time:\n            break\n        \n        if verbose:\n            print(f\"\\n{'='*60}\")\n            print(f\"Restart {restart + 1}/{n_restarts}\")\n            print(f\"{'='*60}\")\n        \n        # Increase population size with restarts\n        optimizer.lambda_ = (4 + int(3 * np.log(optimizer.dim))) * (restart + 1)\n        optimizer.mu = optimizer.lambda_ // 2\n        optimizer.weights = np.log(optimizer.mu + 0.5) - np.log(np.arange(1, optimizer.mu + 1))\n        optimizer.weights /= np.sum(optimizer.weights)\n        optimizer.mu_eff = 1.0 / np.sum(optimizer.weights ** 2)\n        \n        # Adjust initial sigma based on restart\n        sigma = 0.3 / (restart + 1)\n        \n        # Run optimization\n        remaining_time = max_time - (time.time() - start_time)\n        max_iter = min(500, int(remaining",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom dataclasses import dataclass\nfrom typing import List, Tuple, Optional\nimport time\n\n@dataclass\nclass Circle:\n    x: float\n    y: float\n    r: float\n\nclass CMAESOptimizer:\n    \"\"\"CMA-ES optimizer for circle packing problem.\"\"\"\n    \n    def __init__(self, n_circles: int, container_radius: float = 1.0):\n        self.n_circles = n_circles\n        self.container_radius = container_radius\n        self.dim = 3 * n_circles  # x, y, r for each circle\n        \n        # CMA-ES parameters\n        self.lambda_ = 4 + int(3 * np.log(self.dim))  # population size\n        self.mu = self.lambda_ // 2  # number of parents\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights /= np.sum(self.weights)\n        self.mu_eff = 1.0 / np.sum(self.weights ** 2)\n        \n        # Adaptation parameters\n        self.cc = (4 + self.mu_eff / self.dim) / (self.dim + 4 + 2 * self.mu_eff / self.dim)\n        self.cs = (self.mu_eff + 2) / (self.dim + self.mu_eff + 5)\n        self.c1 = 2 / ((self.dim + 1.3) ** 2 + self.mu_eff)\n        self.cmu = min(1 - self.c1, 2 * (self.mu_eff - 2 + 1 / self.mu_eff) / \n                       ((self.dim + 2) ** 2 + self.mu_eff))\n        self.damps = 1 + 2 * max(0, np.sqrt((self.mu_eff - 1) / (self.dim + 1)) - 1) + self.cs\n        \n        # Dynamic state\n        self.mean = None\n        self.sigma = None\n        self.pc = None\n        self.ps = None\n        self.C = None\n        self.B = None\n        self.D = None\n        self.BD = None\n        self.eigeneval = 0\n        self.counteval = 0\n        self.chi_n = self.dim ** 0.5 * (1 - 1 / (4 * self.dim) + 1 / (21 * self.dim ** 2))\n        \n        # Best solution tracking\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        \n        # Penalty weights (adaptive)\n        self.penalty_overlap = 1000.0\n        self.penalty_container = 1000.0\n        self.penalty_radius = 100.0\n        \n    def initialize(self, mean: Optional[np.ndarray] = None, sigma: float = 0.3):\n        \"\"\"Initialize CMA-ES state.\"\"\"\n        if mean is None:\n            # Smart initialization: arrange circles in a grid-like pattern\n            mean = self._smart_initialization()\n        \n        self.mean = mean.copy()\n        self.sigma = sigma\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.C = np.eye(self.dim)\n        self.B = np.eye(self.dim)\n        self.D = np.ones(self.dim)\n        self.BD = self.B * self.D\n        self.eigeneval = 0\n        self.counteval = 0\n        \n    def _smart_initialization(self) -> np.ndarray:\n        \"\"\"Create a smart initial solution.\"\"\"\n        mean = np.zeros(self.dim)\n        \n        # Estimate reasonable radius\n        area_per_circle = np.pi * self.container_radius ** 2 / self.n_circles\n        r_init = np.sqrt(area_per_circle / np.pi) * 0.7  # Conservative estimate\n        \n        # Arrange in concentric circles\n        n_inner = min(6, self.n_circles)\n        n_outer = self.n_circles - n_inner\n        \n        idx = 0\n        # Inner circle\n        r_inner = self.container_radius * 0.3\n        for i in range(n_inner):\n            angle = 2 * np.pi * i / n_inner\n            mean[idx * 3] = r_inner * np.cos(angle)\n            mean[idx * 3 + 1] = r_inner * np.sin(angle)\n            mean[idx * 3 + 2] = r_init\n            idx += 1\n        \n        # Outer circle\n        if n_outer > 0:\n            r_outer = self.container_radius * 0.65\n            for i in range(n_outer):\n                angle = 2 * np.pi * i / n_outer\n                mean[idx * 3] = r_outer * np.cos(angle)\n                mean[idx * 3 + 1] = r_outer * np.sin(angle)\n                mean[idx * 3 + 2] = r_init\n                idx += 1\n        \n        return mean\n    \n    def decode_solution(self, x: np.ndarray) -> List[Circle]:\n        \"\"\"Decode flat array to list of circles.\"\"\"\n        circles = []\n        for i in range(self.n_circles):\n            circles.append(Circle(\n                x=x[i * 3],\n                y=x[i * 3 + 1],\n                r=abs(x[i * 3 + 2])  # Ensure positive radius\n            ))\n        return circles\n    \n    def objective(self, x: np.ndarray) -> float:\n        \"\"\"\n        Objective function: minimize the negative of minimum radius\n        (i.e., maximize minimum radius) with penalties for constraint violations.\n        \"\"\"\n        circles = self.decode_solution(x)\n        \n        # Primary objective: maximize minimum radius\n        min_radius = min(c.r for c in circles)\n        fitness = -min_radius\n        \n        # Penalty for overlap between circles\n        overlap_penalty = 0.0\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                dist = np.sqrt((circles[i].x - circles[j].x) ** 2 + \n                              (circles[i].y - circles[j].y) ** 2)\n                required_dist = circles[i].r + circles[j].r\n                if dist < required_dist:\n                    overlap = required_dist - dist\n                    overlap_penalty += overlap ** 2\n        \n        # Penalty for circles outside container\n        container_penalty = 0.0\n        for c in circles:\n            dist_from_center = np.sqrt(c.x ** 2 + c.y ** 2)\n            if dist_from_center + c.r > self.container_radius:\n                violation = dist_from_center + c.r - self.container_radius\n                container_penalty += violation ** 2\n        \n        # Penalty for very small or negative radii\n        radius_penalty = 0.0\n        for c in circles:\n            if c.r < 0.001:\n                radius_penalty += (0.001 - c.r) ** 2\n        \n        # Combined fitness\n        total_penalty = (self.penalty_overlap * overlap_penalty + \n                        self.penalty_container * container_penalty +\n                        self.penalty_radius * radius_penalty)\n        \n        return fitness + total_penalty\n    \n    def ask(self) -> np.ndarray:\n        \"\"\"Generate new population.\"\"\"\n        population = np.zeros((self.lambda_, self.dim))\n        \n        for k in range(self.lambda_):\n            z = np.random.randn(self.dim)\n            y = self.BD @ z\n            population[k] = self.mean + self.sigma * y\n        \n        return population\n    \n    def tell(self, population: np.ndarray, fitness: np.ndarray):\n        \"\"\"Update distribution based on fitness.\"\"\"\n        # Sort by fitness\n        idx = np.argsort(fitness)\n        old_mean = self.mean.copy()\n        \n        # Update mean\n        self.mean = population[idx[:self.mu]].T @ self.weights\n        \n        # Update evolution paths\n        y = (self.mean - old_mean) / self.sigma\n        z = np.linalg.solve(self.BD, y)\n        \n        self.ps = (1 - self.cs) * self.ps + \\\n                  np.sqrt(self.cs * (2 - self.cs) * self.mu_eff) * (self.B @ z)\n        \n        hsig = (np.linalg.norm(self.ps) / \n                np.sqrt(1 - (1 - self.cs) ** (2 * self.counteval / self.lambda_)) / \n                self.chi_n < 1.4 + 2 / (self.dim + 1))\n        \n        self.pc = (1 - self.cc) * self.pc + \\\n                  hsig * np.sqrt(self.cc * (2 - self.cc) * self.mu_eff) * y\n        \n        # Update covariance matrix\n        artmp = (population[idx[:self.mu]] - old_mean).T / self.sigma\n        self.C = (1 - self.c1 - self.cmu) * self.C + \\\n                 self.c1 * (np.outer(self.pc, self.pc) + \n                           (1 - hsig) * self.cc * (2 - self.cc) * self.C) + \\\n                 self.cmu * artmp @ np.diag(self.weights) @ artmp.T\n        \n        # Update step size\n        self.sigma *= np.exp((self.cs / self.damps) * \n                            (np.linalg.norm(self.ps) / self.chi_n - 1))\n        \n        # Update B, D from C\n        if self.counteval - self.eigeneval > self.lambda_ / (self.c1 + self.cmu) / self.dim / 10:\n            self.eigeneval = self.counteval\n            self.C = np.triu(self.C) + np.triu(self.C, 1).T  # Enforce symmetry\n            self.D, self.B = np.linalg.eigh(self.C)\n            self.D = np.sqrt(np.maximum(self.D, 0))\n            self.BD = self.B * self.D\n        \n        # Track best solution\n        if fitness[idx[0]] < self.best_fitness:\n            self.best_fitness = fitness[idx[0]]\n            self.best_solution = population[idx[0]].copy()\n        \n        self.counteval += self.lambda_\n    \n    def optimize(self, max_iter: int = 1000, tol: float = 1e-10, verbose: bool = True) -> Tuple[np.ndarray, float]:\n        \"\"\"Run CMA-ES optimization.\"\"\"\n        self.initialize()\n        \n        for iteration in range(max_iter):\n            # Generate and evaluate population\n            population = self.ask()\n            fitness = np.array([self.objective(ind) for ind in population])\n            \n            # Update distribution\n            self.tell(population, fitness)\n            \n            if verbose and iteration % 50 == 0:\n                print(f\"Iteration {iteration}: Best fitness = {self.best_fitness:.6f}, \"\n                      f\"Min radius = {-self.best_fitness:.6f}, Sigma = {self.sigma:.6f}\")\n            \n            # Convergence check\n            if self.sigma < tol:\n                if verbose:\n                    print(f\"Converged at iteration {iteration}\")\n                break\n        \n        return self.best_solution, self.best_fitness\n\ndef local_refinement(solution: np.ndarray, n_circles: int, container_radius: float) -> np.ndarray:\n    \"\"\"Refine solution using local optimization (SLSQP).\"\"\"\n    \n    def objective(x):\n        min_r = min(abs(x[i * 3 + 2]) for i in range(n_circles))\n        return -min_r\n    \n    def constraint_no_overlap(x, i, j):\n        xi, yi, ri = x[i*3], x[i*3+1], abs(x[i*3+2])\n        xj, yj, rj = x[j*3], x[j*3+1], abs(x[j*3+2])\n        dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n        return dist - (ri + rj)\n    \n    def constraint_in_container(x, i):\n        xi, yi, ri = x[i*3], x[i*3+1], abs(x[i*3+2])\n        dist = np.sqrt(xi**2 + yi**2)\n        return container_radius - (dist + ri)\n    \n    constraints = []\n    \n    # No overlap constraints\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            constraints.append({\n                'type': 'ineq',\n                'fun': constraint_no_overlap,\n                'args': (i, j)\n            })\n    \n    # Container constraints\n    for i in range(n_circles):\n        constraints.append({\n            'type': 'ineq',\n            'fun': constraint_in_container,\n            'args': (i,)\n        })\n    \n    # Bounds: radius must be positive\n    bounds = []\n    for i in range(n_circles):\n        bounds.extend([(-container_radius, container_radius),  # x\n                      (-container_radius, container_radius),  # y\n                      (0.001, container_radius)])  # r\n    \n    result = minimize(objective, solution, method='SLSQP', \n                     bounds=bounds, constraints=constraints,\n                     options={'maxiter': 500, 'ftol': 1e-9})\n    \n    return result.x if result.success else solution\n\ndef construct_packing(n_circles: int = 26, container_radius: float = 1.0) -> CMAESOptimizer:\n    \"\"\"Construct a CMA-ES optimizer for circle packing.\"\"\"\n    return CMAESOptimizer(n_circles, container_radius)\n\ndef run_packing(optimizer: CMAESOptimizer, max_time: float = 60.0, \n                n_restarts: int = 3, verbose: bool = True) -> List[Circle]:\n    \"\"\"\n    Run circle packing optimization with restarts.\n    \n    Args:\n        optimizer: CMA-ES optimizer instance\n        max_time: Maximum time in seconds\n        n_restarts: Number of restarts with increasing population\n        verbose: Print progress\n    \n    Returns:\n        List of optimized circles\n    \"\"\"\n    start_time = time.time()\n    best_solution = None\n    best_fitness = float('inf')\n    \n    for restart in range(n_restarts):\n        if time.time() - start_time > max_time:\n            break\n        \n        if verbose:\n            print(f\"\\n{'='*60}\")\n            print(f\"Restart {restart + 1}/{n_restarts}\")\n            print(f\"{'='*60}\")\n        \n        # Increase population size with restarts\n        optimizer.lambda_ = (4 + int(3 * np.log(optimizer.dim))) * (restart + 1)\n        optimizer.mu = optimizer.lambda_ // 2\n        optimizer.weights = np.log(optimizer.mu + 0.5) - np.log(np.arange(1, optimizer.mu + 1))\n        optimizer.weights /= np.sum(optimizer.weights)\n        optimizer.mu_eff = 1.0 / np.sum(optimizer.weights ** 2)\n        \n        # Adjust initial sigma based on restart\n        sigma = 0.3 / (restart + 1)\n        \n        # Run optimization\n        remaining_time = max_time - (time.time() - start_time)\n        max_iter = min(500, int(remaining",
  "timestamp": "2025-12-08T12:40:48.832391",
  "cost_data": null
}