{
  "trial_id": "trial_2_10",
  "generation": 2,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a basin-hopping with local refinement for 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Use scipy.optimize.basinhopping for global optimization\n2. Configure with:\n   - Custom step-taking function (smart perturbations)\n   - Accept test based on feasibility and improvement\n   - Local minimizer: trust-constr with tight tolerances\n3. Add temperature schedule that balances exploration/exploitation\n4. Use multiple independent basin-hopping runs\n5. Return best feasible solution found\n\nBasin-hopping is excellent for escaping local optima in constrained problems.\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize, NonlinearConstraint\nfrom dataclasses import dataclass\nimport time\n\n@dataclass\nclass PackingResult:\n    \"\"\"Result of circle packing optimization\"\"\"\n    radius: float\n    positions: np.ndarray\n    success: bool\n    n_iterations: int\n    time_elapsed: float\n    objective_value: float\n\nclass CirclePackingProblem:\n    \"\"\"Circle packing problem definition\"\"\"\n    \n    def __init__(self, n_circles: int):\n        self.n_circles = n_circles\n        self.n_vars = 2 * n_circles + 1  # x, y coordinates + radius\n        \n    def decode_solution(self, x: np.ndarray):\n        \"\"\"Decode flat array into radius and positions\"\"\"\n        radius = x[0]\n        positions = x[1:].reshape((self.n_circles, 2))\n        return radius, positions\n    \n    def encode_solution(self, radius: float, positions: np.ndarray):\n        \"\"\"Encode radius and positions into flat array\"\"\"\n        return np.concatenate([[radius], positions.flatten()])\n    \n    def objective(self, x: np.ndarray):\n        \"\"\"Objective: minimize negative radius (maximize radius)\"\"\"\n        return -x[0]\n    \n    def constraint_boundary(self, x: np.ndarray):\n        \"\"\"Constraints: circles must be inside [0,1]x[0,1]\"\"\"\n        radius, positions = self.decode_solution(x)\n        \n        # Each circle must satisfy: r <= x <= 1-r and r <= y <= 1-r\n        constraints = np.zeros(4 * self.n_circles)\n        \n        for i in range(self.n_circles):\n            constraints[4*i] = positions[i, 0] - radius      # x >= r\n            constraints[4*i+1] = 1 - radius - positions[i, 0]  # x <= 1-r\n            constraints[4*i+2] = positions[i, 1] - radius      # y >= r\n            constraints[4*i+3] = 1 - radius - positions[i, 1]  # y <= 1-r\n            \n        return constraints\n    \n    def constraint_separation(self, x: np.ndarray):\n        \"\"\"Constraints: circles must not overlap\"\"\"\n        radius, positions = self.decode_solution(x)\n        \n        n_pairs = self.n_circles * (self.n_circles - 1) // 2\n        constraints = np.zeros(n_pairs)\n        \n        idx = 0\n        for i in range(self.n_circles):\n            for j in range(i + 1, self.n_circles):\n                dist = np.linalg.norm(positions[i] - positions[j])\n                constraints[idx] = dist - 2 * radius\n                idx += 1\n                \n        return constraints\n    \n    def constraint_radius_positive(self, x: np.ndarray):\n        \"\"\"Constraint: radius must be positive\"\"\"\n        return np.array([x[0]])\n    \n    def is_feasible(self, x: np.ndarray, tol: float = 1e-6):\n        \"\"\"Check if solution is feasible\"\"\"\n        if x[0] <= 0:\n            return False\n        \n        boundary = self.constraint_boundary(x)\n        if np.any(boundary < -tol):\n            return False\n        \n        separation = self.constraint_separation(x)\n        if np.any(separation < -tol):\n            return False\n        \n        return True\n\nclass SmartStepTaker:\n    \"\"\"Custom step-taking class for basin-hopping\"\"\"\n    \n    def __init__(self, problem: CirclePackingProblem, stepsize: float = 0.1):\n        self.problem = problem\n        self.stepsize = stepsize\n        self.n_calls = 0\n        \n    def __call__(self, x: np.ndarray):\n        \"\"\"Take a random step\"\"\"\n        self.n_calls += 1\n        \n        # Adaptive step size based on current radius\n        radius = x[0]\n        position_stepsize = self.stepsize * min(radius, 0.1)\n        radius_stepsize = self.stepsize * radius * 0.5\n        \n        # Perturb radius (small changes)\n        x_new = x.copy()\n        x_new[0] += np.random.uniform(-radius_stepsize, radius_stepsize)\n        x_new[0] = max(0.001, min(0.5, x_new[0]))  # Keep reasonable bounds\n        \n        # Perturb positions\n        n_circles = self.problem.n_circles\n        positions = x_new[1:].reshape((n_circles, 2))\n        \n        # Randomly perturb a subset of circles\n        n_perturb = max(1, np.random.randint(1, n_circles // 2 + 1))\n        indices = np.random.choice(n_circles, n_perturb, replace=False)\n        \n        for i in indices:\n            perturbation = np.random.uniform(-position_stepsize, position_stepsize, 2)\n            positions[i] += perturbation\n            # Keep within bounds\n            positions[i] = np.clip(positions[i], x_new[0], 1 - x_new[0])\n        \n        x_new[1:] = positions.flatten()\n        \n        return x_new\n\nclass FeasibilityAcceptTest:\n    \"\"\"Custom accept test that prioritizes feasibility\"\"\"\n    \n    def __init__(self, problem: CirclePackingProblem):\n        self.problem = problem\n        self.best_feasible_obj = np.inf\n        \n    def __call__(self, f_new, x_new, f_old, x_old):\n        \"\"\"Accept if feasible and better, or if exploring\"\"\"\n        is_feasible_new = self.problem.is_feasible(x_new)\n        is_feasible_old = self.problem.is_feasible(x_old)\n        \n        # Always accept if new is feasible and old wasn't\n        if is_feasible_new and not is_feasible_old:\n            if f_new < self.best_feasible_obj:\n                self.best_feasible_obj = f_new\n            return True\n        \n        # Never accept if new is infeasible and old was feasible\n        if not is_feasible_new and is_feasible_old:\n            return False\n        \n        # Both feasible: accept if better\n        if is_feasible_new and is_feasible_old:\n            accept = f_new < f_old\n            if accept and f_new < self.best_feasible_obj:\n                self.best_feasible_obj = f_new\n            return accept\n        \n        # Both infeasible: accept with some probability to explore\n        return np.random.rand() < 0.3\n\ndef construct_packing(n_circles: int):\n    \"\"\"\n    Construct the circle packing optimization problem.\n    \n    Args:\n        n_circles: Number of circles to pack\n        \n    Returns:\n        CirclePackingProblem instance\n    \"\"\"\n    return CirclePackingProblem(n_circles)\n\ndef generate_initial_solution(problem: CirclePackingProblem):\n    \"\"\"Generate initial feasible solution with grid layout\"\"\"\n    n = problem.n_circles\n    \n    # Create a grid layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    radius = 0.5 / grid_size\n    \n    positions = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = radius + col * (2 * radius)\n        y = radius + row * (2 * radius)\n        positions.append([x, y])\n    \n    positions = np.array(positions)\n    \n    # Add small random perturbations\n    positions += np.random.uniform(-radius*0.1, radius*0.1, positions.shape)\n    positions = np.clip(positions, radius, 1 - radius)\n    \n    return problem.encode_solution(radius * 0.95, positions)\n\ndef local_minimization(x0: np.ndarray, problem: CirclePackingProblem):\n    \"\"\"Perform local optimization with trust-constr\"\"\"\n    \n    # Bounds: radius in (0, 0.5), positions in (0, 1)\n    bounds = [(0.001, 0.5)]  # radius\n    for _ in range(problem.n_circles):\n        bounds.extend([(0, 1), (0, 1)])  # x, y positions\n    \n    # Constraints\n    constraints = [\n        NonlinearConstraint(\n            problem.constraint_boundary,\n            0, np.inf,\n            jac='2-point'\n        ),\n        NonlinearConstraint(\n            problem.constraint_separation,\n            0, np.inf,\n            jac='2-point'\n        ),\n        NonlinearConstraint(\n            problem.constraint_radius_positive,\n            0.001, np.inf,\n            jac='2-point'\n        )\n    ]\n    \n    result = minimize(\n        problem.objective,\n        x0,\n        method='trust-constr',\n        bounds=bounds,\n        constraints=constraints,\n        options={\n            'maxiter': 500,\n            'verbose': 0,\n            'gtol': 1e-6,\n            'xtol': 1e-8,\n            'barrier_tol': 1e-8\n        }\n    )\n    \n    return result\n\ndef run_packing(n_circles: int = 26, \n                n_runs: int = 3,\n                n_iterations: int = 100,\n                temperature: float = 1.0,\n                stepsize: float = 0.15,\n                verbose: bool = True):\n    \"\"\"\n    Run basin-hopping optimization for circle packing.\n    \n    Args:\n        n_circles: Number of circles to pack (default: 26)\n        n_runs: Number of independent basin-hopping runs\n        n_iterations: Number of basin-hopping iterations per run\n        temperature: Temperature for basin-hopping acceptance\n        stepsize: Step size for perturbations\n        verbose: Whether to print progress\n        \n    Returns:\n        PackingResult with best solution found\n    \"\"\"\n    \n    if verbose:\n        print(f\"Circle Packing with Basin-Hopping\")\n        print(f\"{'='*60}\")\n        print(f\"Number of circles: {n_circles}\")\n        print(f\"Number of runs: {n_runs}\")\n        print(f\"Iterations per run: {n_iterations}\")\n        print(f\"Temperature: {temperature}\")\n        print(f\"Step size: {stepsize}\")\n        print()\n    \n    problem = construct_packing(n_circles)\n    \n    best_result = None\n    best_radius = 0\n    start_time = time.time()\n    \n    for run in range(n_runs):\n        if verbose:\n            print(f\"Run {run + 1}/{n_runs}\")\n            print(\"-\" * 40)\n        \n        # Generate initial solution\n        x0 = generate_initial_solution(problem)\n        \n        # Initial local optimization\n        if verbose:\n            print(\"  Initial local optimization...\")\n        local_result = local_minimization(x0, problem)\n        x0 = local_result.x\n        \n        initial_radius = x0[0]\n        if verbose:\n            print(f\"  Initial radius: {initial_radius:.6f}\")\n        \n        # Set up basin-hopping\n        step_taker = SmartStepTaker(problem, stepsize=stepsize)\n        accept_test = FeasibilityAcceptTest(problem)\n        \n        # Run basin-hopping\n        if verbose:\n            print(f\"  Running basin-hopping...\")\n        \n        result = basinhopping(\n            problem.objective,\n            x0,\n            minimizer_kwargs={\n                'method': 'trust-constr',\n                'bounds': [(0.001, 0.5)] + [(0, 1)] * (2 * n_circles),\n                'constraints': [\n                    NonlinearConstraint(problem.constraint_boundary, 0, np.inf, jac='2-point'),\n                    NonlinearConstraint(problem.constraint_separation, 0, np.inf, jac='2-point'),\n                    NonlinearConstraint(problem.constraint_radius_positive, 0.001, np.inf, jac='2-point')\n                ],\n                'options': {'maxiter': 300, 'verbose': 0}\n            },\n            niter=n_iterations,\n            T=temperature,\n            stepsize=stepsize,\n            take_step=step_taker,\n            accept_test=accept_test,\n            interval=20,\n            disp=verbose,\n            niter_success=None\n        )\n        \n        # Check if solution is feasible and better\n        if problem.is_feasible(result.x):\n            radius = result.x[0]\n            if verbose:\n                print(f\"  Final radius: {radius:.6f}\")\n                print(f\"  Improvement: {(radius - initial_radius):.6f}\")\n            \n            if radius > best_radius:\n                best_radius = radius\n                best_result = result\n                if verbose:\n                    print(f\"  *** New best radius: {best_radius:.6f} ***\")\n        else:\n            if verbose:\n                print(f\"  Solution infeasible, skipping\")\n        \n        if verbose:\n            print()\n    \n    elapsed_time = time.time() - start_time\n    \n    if best_result is None:\n        if verbose:\n            print(\"No feasible solution found!\")\n        return PackingResult(\n            radius=0,\n            positions=np.zeros((n_circles, 2)),\n            success=False,\n            n_iterations=n_runs * n_iterations,\n            time_elapsed=elapsed_time,\n            objective_value=np.inf\n        )\n    \n    radius, positions = problem.decode_solution(best_result.x)\n    \n    if verbose:\n        print(f\"{'='*60}\")\n        print(f\"Optimization Complete!\")\n        print(f\"Best radius found: {radius:.6f}\")\n        print(f\"Total time: {elapsed_time:.2f} seconds\")\n        print(f\"Feasible: {problem.is_feasible(best_result.x)}\")\n        print()\n        \n        # Verify constraints\n        boundary = problem.constraint_boundary(best_result.x)\n        separation = problem.constraint_separation(best_result.x)\n        print(f\"Boundary constraint violations: {np.sum(boundary < -1e-6)}\")\n        print(f\"Separation constraint violations: {np.sum(separation < -1e-6)}\")\n        if np.any(boundary < -1e-6):\n            print(f\"  Min boundary margin: {np.min(boundary):.6e}\")\n        if np.any(separation < -1e-6):\n            print(f\"  Min separation margin: {np.min(separation):.6e}\")\n    \n    return PackingResult(\n        radius=radius,\n        positions=positions,\n        success=True,\n        n_iterations=n_runs * n_iterations,\n        time_elapsed=elapsed_time,\n        objective_value=-best_result.fun\n    )\n\n# Example usage and visualization\nif __name__ == \"__main__\":\n    # Run optimization\n    result = run_packing(\n        n_circles=26,\n        n_runs=3,\n        n_iterations=100,\n        temperature=1.0,\n        stepsize=0.15,\n        verbose=True\n    )\n    \n    # Visualize result\n    if result.success:\n        try:\n            import matplotlib.pyplot as plt\n            from matplotlib.patches import Circle\n            \n            fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n            \n            # Draw unit square\n            ax.add_patch(plt.Rectangle((0, 0), 1, 1, fill=False, edgecolor='black', linewidth=2))\n            \n            # Draw circles\n            for i, pos in enumerate(result.positions):\n                circle = Circle(pos, result.radius, fill=False, edgecolor='blue', linewidth=1.5)\n                ax.add_patch(circle)\n                ax.plot(pos[0], pos[",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize, NonlinearConstraint\nfrom dataclasses import dataclass\nimport time\n\n@dataclass\nclass PackingResult:\n    \"\"\"Result of circle packing optimization\"\"\"\n    radius: float\n    positions: np.ndarray\n    success: bool\n    n_iterations: int\n    time_elapsed: float\n    objective_value: float\n\nclass CirclePackingProblem:\n    \"\"\"Circle packing problem definition\"\"\"\n    \n    def __init__(self, n_circles: int):\n        self.n_circles = n_circles\n        self.n_vars = 2 * n_circles + 1  # x, y coordinates + radius\n        \n    def decode_solution(self, x: np.ndarray):\n        \"\"\"Decode flat array into radius and positions\"\"\"\n        radius = x[0]\n        positions = x[1:].reshape((self.n_circles, 2))\n        return radius, positions\n    \n    def encode_solution(self, radius: float, positions: np.ndarray):\n        \"\"\"Encode radius and positions into flat array\"\"\"\n        return np.concatenate([[radius], positions.flatten()])\n    \n    def objective(self, x: np.ndarray):\n        \"\"\"Objective: minimize negative radius (maximize radius)\"\"\"\n        return -x[0]\n    \n    def constraint_boundary(self, x: np.ndarray):\n        \"\"\"Constraints: circles must be inside [0,1]x[0,1]\"\"\"\n        radius, positions = self.decode_solution(x)\n        \n        # Each circle must satisfy: r <= x <= 1-r and r <= y <= 1-r\n        constraints = np.zeros(4 * self.n_circles)\n        \n        for i in range(self.n_circles):\n            constraints[4*i] = positions[i, 0] - radius      # x >= r\n            constraints[4*i+1] = 1 - radius - positions[i, 0]  # x <= 1-r\n            constraints[4*i+2] = positions[i, 1] - radius      # y >= r\n            constraints[4*i+3] = 1 - radius - positions[i, 1]  # y <= 1-r\n            \n        return constraints\n    \n    def constraint_separation(self, x: np.ndarray):\n        \"\"\"Constraints: circles must not overlap\"\"\"\n        radius, positions = self.decode_solution(x)\n        \n        n_pairs = self.n_circles * (self.n_circles - 1) // 2\n        constraints = np.zeros(n_pairs)\n        \n        idx = 0\n        for i in range(self.n_circles):\n            for j in range(i + 1, self.n_circles):\n                dist = np.linalg.norm(positions[i] - positions[j])\n                constraints[idx] = dist - 2 * radius\n                idx += 1\n                \n        return constraints\n    \n    def constraint_radius_positive(self, x: np.ndarray):\n        \"\"\"Constraint: radius must be positive\"\"\"\n        return np.array([x[0]])\n    \n    def is_feasible(self, x: np.ndarray, tol: float = 1e-6):\n        \"\"\"Check if solution is feasible\"\"\"\n        if x[0] <= 0:\n            return False\n        \n        boundary = self.constraint_boundary(x)\n        if np.any(boundary < -tol):\n            return False\n        \n        separation = self.constraint_separation(x)\n        if np.any(separation < -tol):\n            return False\n        \n        return True\n\nclass SmartStepTaker:\n    \"\"\"Custom step-taking class for basin-hopping\"\"\"\n    \n    def __init__(self, problem: CirclePackingProblem, stepsize: float = 0.1):\n        self.problem = problem\n        self.stepsize = stepsize\n        self.n_calls = 0\n        \n    def __call__(self, x: np.ndarray):\n        \"\"\"Take a random step\"\"\"\n        self.n_calls += 1\n        \n        # Adaptive step size based on current radius\n        radius = x[0]\n        position_stepsize = self.stepsize * min(radius, 0.1)\n        radius_stepsize = self.stepsize * radius * 0.5\n        \n        # Perturb radius (small changes)\n        x_new = x.copy()\n        x_new[0] += np.random.uniform(-radius_stepsize, radius_stepsize)\n        x_new[0] = max(0.001, min(0.5, x_new[0]))  # Keep reasonable bounds\n        \n        # Perturb positions\n        n_circles = self.problem.n_circles\n        positions = x_new[1:].reshape((n_circles, 2))\n        \n        # Randomly perturb a subset of circles\n        n_perturb = max(1, np.random.randint(1, n_circles // 2 + 1))\n        indices = np.random.choice(n_circles, n_perturb, replace=False)\n        \n        for i in indices:\n            perturbation = np.random.uniform(-position_stepsize, position_stepsize, 2)\n            positions[i] += perturbation\n            # Keep within bounds\n            positions[i] = np.clip(positions[i], x_new[0], 1 - x_new[0])\n        \n        x_new[1:] = positions.flatten()\n        \n        return x_new\n\nclass FeasibilityAcceptTest:\n    \"\"\"Custom accept test that prioritizes feasibility\"\"\"\n    \n    def __init__(self, problem: CirclePackingProblem):\n        self.problem = problem\n        self.best_feasible_obj = np.inf\n        \n    def __call__(self, f_new, x_new, f_old, x_old):\n        \"\"\"Accept if feasible and better, or if exploring\"\"\"\n        is_feasible_new = self.problem.is_feasible(x_new)\n        is_feasible_old = self.problem.is_feasible(x_old)\n        \n        # Always accept if new is feasible and old wasn't\n        if is_feasible_new and not is_feasible_old:\n            if f_new < self.best_feasible_obj:\n                self.best_feasible_obj = f_new\n            return True\n        \n        # Never accept if new is infeasible and old was feasible\n        if not is_feasible_new and is_feasible_old:\n            return False\n        \n        # Both feasible: accept if better\n        if is_feasible_new and is_feasible_old:\n            accept = f_new < f_old\n            if accept and f_new < self.best_feasible_obj:\n                self.best_feasible_obj = f_new\n            return accept\n        \n        # Both infeasible: accept with some probability to explore\n        return np.random.rand() < 0.3\n\ndef construct_packing(n_circles: int):\n    \"\"\"\n    Construct the circle packing optimization problem.\n    \n    Args:\n        n_circles: Number of circles to pack\n        \n    Returns:\n        CirclePackingProblem instance\n    \"\"\"\n    return CirclePackingProblem(n_circles)\n\ndef generate_initial_solution(problem: CirclePackingProblem):\n    \"\"\"Generate initial feasible solution with grid layout\"\"\"\n    n = problem.n_circles\n    \n    # Create a grid layout\n    grid_size = int(np.ceil(np.sqrt(n)))\n    radius = 0.5 / grid_size\n    \n    positions = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = radius + col * (2 * radius)\n        y = radius + row * (2 * radius)\n        positions.append([x, y])\n    \n    positions = np.array(positions)\n    \n    # Add small random perturbations\n    positions += np.random.uniform(-radius*0.1, radius*0.1, positions.shape)\n    positions = np.clip(positions, radius, 1 - radius)\n    \n    return problem.encode_solution(radius * 0.95, positions)\n\ndef local_minimization(x0: np.ndarray, problem: CirclePackingProblem):\n    \"\"\"Perform local optimization with trust-constr\"\"\"\n    \n    # Bounds: radius in (0, 0.5), positions in (0, 1)\n    bounds = [(0.001, 0.5)]  # radius\n    for _ in range(problem.n_circles):\n        bounds.extend([(0, 1), (0, 1)])  # x, y positions\n    \n    # Constraints\n    constraints = [\n        NonlinearConstraint(\n            problem.constraint_boundary,\n            0, np.inf,\n            jac='2-point'\n        ),\n        NonlinearConstraint(\n            problem.constraint_separation,\n            0, np.inf,\n            jac='2-point'\n        ),\n        NonlinearConstraint(\n            problem.constraint_radius_positive,\n            0.001, np.inf,\n            jac='2-point'\n        )\n    ]\n    \n    result = minimize(\n        problem.objective,\n        x0,\n        method='trust-constr',\n        bounds=bounds,\n        constraints=constraints,\n        options={\n            'maxiter': 500,\n            'verbose': 0,\n            'gtol': 1e-6,\n            'xtol': 1e-8,\n            'barrier_tol': 1e-8\n        }\n    )\n    \n    return result\n\ndef run_packing(n_circles: int = 26, \n                n_runs: int = 3,\n                n_iterations: int = 100,\n                temperature: float = 1.0,\n                stepsize: float = 0.15,\n                verbose: bool = True):\n    \"\"\"\n    Run basin-hopping optimization for circle packing.\n    \n    Args:\n        n_circles: Number of circles to pack (default: 26)\n        n_runs: Number of independent basin-hopping runs\n        n_iterations: Number of basin-hopping iterations per run\n        temperature: Temperature for basin-hopping acceptance\n        stepsize: Step size for perturbations\n        verbose: Whether to print progress\n        \n    Returns:\n        PackingResult with best solution found\n    \"\"\"\n    \n    if verbose:\n        print(f\"Circle Packing with Basin-Hopping\")\n        print(f\"{'='*60}\")\n        print(f\"Number of circles: {n_circles}\")\n        print(f\"Number of runs: {n_runs}\")\n        print(f\"Iterations per run: {n_iterations}\")\n        print(f\"Temperature: {temperature}\")\n        print(f\"Step size: {stepsize}\")\n        print()\n    \n    problem = construct_packing(n_circles)\n    \n    best_result = None\n    best_radius = 0\n    start_time = time.time()\n    \n    for run in range(n_runs):\n        if verbose:\n            print(f\"Run {run + 1}/{n_runs}\")\n            print(\"-\" * 40)\n        \n        # Generate initial solution\n        x0 = generate_initial_solution(problem)\n        \n        # Initial local optimization\n        if verbose:\n            print(\"  Initial local optimization...\")\n        local_result = local_minimization(x0, problem)\n        x0 = local_result.x\n        \n        initial_radius = x0[0]\n        if verbose:\n            print(f\"  Initial radius: {initial_radius:.6f}\")\n        \n        # Set up basin-hopping\n        step_taker = SmartStepTaker(problem, stepsize=stepsize)\n        accept_test = FeasibilityAcceptTest(problem)\n        \n        # Run basin-hopping\n        if verbose:\n            print(f\"  Running basin-hopping...\")\n        \n        result = basinhopping(\n            problem.objective,\n            x0,\n            minimizer_kwargs={\n                'method': 'trust-constr',\n                'bounds': [(0.001, 0.5)] + [(0, 1)] * (2 * n_circles),\n                'constraints': [\n                    NonlinearConstraint(problem.constraint_boundary, 0, np.inf, jac='2-point'),\n                    NonlinearConstraint(problem.constraint_separation, 0, np.inf, jac='2-point'),\n                    NonlinearConstraint(problem.constraint_radius_positive, 0.001, np.inf, jac='2-point')\n                ],\n                'options': {'maxiter': 300, 'verbose': 0}\n            },\n            niter=n_iterations,\n            T=temperature,\n            stepsize=stepsize,\n            take_step=step_taker,\n            accept_test=accept_test,\n            interval=20,\n            disp=verbose,\n            niter_success=None\n        )\n        \n        # Check if solution is feasible and better\n        if problem.is_feasible(result.x):\n            radius = result.x[0]\n            if verbose:\n                print(f\"  Final radius: {radius:.6f}\")\n                print(f\"  Improvement: {(radius - initial_radius):.6f}\")\n            \n            if radius > best_radius:\n                best_radius = radius\n                best_result = result\n                if verbose:\n                    print(f\"  *** New best radius: {best_radius:.6f} ***\")\n        else:\n            if verbose:\n                print(f\"  Solution infeasible, skipping\")\n        \n        if verbose:\n            print()\n    \n    elapsed_time = time.time() - start_time\n    \n    if best_result is None:\n        if verbose:\n            print(\"No feasible solution found!\")\n        return PackingResult(\n            radius=0,\n            positions=np.zeros((n_circles, 2)),\n            success=False,\n            n_iterations=n_runs * n_iterations,\n            time_elapsed=elapsed_time,\n            objective_value=np.inf\n        )\n    \n    radius, positions = problem.decode_solution(best_result.x)\n    \n    if verbose:\n        print(f\"{'='*60}\")\n        print(f\"Optimization Complete!\")\n        print(f\"Best radius found: {radius:.6f}\")\n        print(f\"Total time: {elapsed_time:.2f} seconds\")\n        print(f\"Feasible: {problem.is_feasible(best_result.x)}\")\n        print()\n        \n        # Verify constraints\n        boundary = problem.constraint_boundary(best_result.x)\n        separation = problem.constraint_separation(best_result.x)\n        print(f\"Boundary constraint violations: {np.sum(boundary < -1e-6)}\")\n        print(f\"Separation constraint violations: {np.sum(separation < -1e-6)}\")\n        if np.any(boundary < -1e-6):\n            print(f\"  Min boundary margin: {np.min(boundary):.6e}\")\n        if np.any(separation < -1e-6):\n            print(f\"  Min separation margin: {np.min(separation):.6e}\")\n    \n    return PackingResult(\n        radius=radius,\n        positions=positions,\n        success=True,\n        n_iterations=n_runs * n_iterations,\n        time_elapsed=elapsed_time,\n        objective_value=-best_result.fun\n    )\n\n# Example usage and visualization\nif __name__ == \"__main__\":\n    # Run optimization\n    result = run_packing(\n        n_circles=26,\n        n_runs=3,\n        n_iterations=100,\n        temperature=1.0,\n        stepsize=0.15,\n        verbose=True\n    )\n    \n    # Visualize result\n    if result.success:\n        try:\n            import matplotlib.pyplot as plt\n            from matplotlib.patches import Circle\n            \n            fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n            \n            # Draw unit square\n            ax.add_patch(plt.Rectangle((0, 0), 1, 1, fill=False, edgecolor='black', linewidth=2))\n            \n            # Draw circles\n            for i, pos in enumerate(result.positions):\n                circle = Circle(pos, result.radius, fill=False, edgecolor='blue', linewidth=1.5)\n                ax.add_patch(circle)\n                ax.plot(pos[0], pos[",
  "timestamp": "2025-12-08T12:40:45.338716",
  "cost_data": null
}