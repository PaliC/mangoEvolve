{
  "trial_id": "trial_3_7",
  "generation": 3,
  "parent_id": "trial_1_5",
  "code": "",
  "metrics": {},
  "prompt": "Write a simple improvement to trial_1_5 that adds differential_evolution:\n\nTake this code:\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List, Optional\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Hybrid approach: Random search + local optimization\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Phase 1: Random search to find promising starting points\n    print(\"Phase 1: Random search for initial configurations...\")\n    initial_candidates = random_search_phase(n_circles, n_trials=20)\n    \n    # Phase 2: Local optimization of top candidates\n    print(\"\\nPhase 2: Local optimization of top candidates...\")\n    best_result = local_optimization_phase(initial_candidates, n_circles, top_k=5)\n    \n    if best_result is None:\n        print(\"Optimization failed, using fallback grid packing\")\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    centers, radii, sum_radii = best_result\n    print(f\"\\nFinal result: Sum of radii = {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n    \n    return centers, radii, sum_radii\n\n\ndef random_search_phase(n_circles: int, n_trials: int = 20) -> List[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Phase 1: Generate multiple random configurations with quick local optimization\n    Returns list of (centers, radii, sum_radii) tuples\n    \"\"\"\n    candidates = []\n    \n    for trial in range(n_trials):\n        # Strategy: Mix different initialization strategies\n        if trial < n_trials // 3:\n            # Pure random\n            centers = np.random.rand(n_circles, 2)\n        elif trial < 2 * n_trials // 3:\n            # Grid with noise\n            centers = create_grid_centers(n_circles)\n            centers += np.random.normal(0, 0.05, centers.shape)\n            centers = np.clip(centers, 0.1, 0.9)\n        else:\n            # Hexagonal-like pattern with noise\n            centers = create_hex_centers(n_circles)\n            centers += np.random.normal(0, 0.03, centers.shape)\n            centers = np.clip(centers, 0.1, 0.9)\n        \n        # Compute initial radii based on nearest neighbors\n        radii = compute_initial_radii(centers, n_circles)\n        \n        # Quick local optimization (few iterations)\n        result = quick_optimize(centers, radii, max_iter=100)\n        \n        if result is not None:\n            candidates.append(result)\n            print(f\"  Trial {trial+1}/{n_trials}: sum_radii = {result[2]:.6f}\")\n    \n    # Sort by sum of radii (descending)\n    candidates.sort(key=lambda x: x[2], reverse=True)\n    \n    return candidates\n\n\ndef local_optimization_phase(candidates: List[Tuple], n_circles: int, top_k: int = 5) -> Optional[Tuple]:\n    \"\"\"\n    Phase 2: Intensive local optimization of top candidates\n    \"\"\"\n    best_result = None\n    best_sum_radii = 0\n    \n    # Take top_k candidates\n    top_candidates = candidates[:min(top_k, len(candidates))]\n    \n    for idx, (centers, radii, sum_radii) in enumerate(top_candidates):\n        print(f\"\\n  Optimizing candidate {idx+1}/{len(top_candidates)} (initial sum: {sum_radii:.6f})...\")\n        \n        # Intensive optimization with scipy\n        result = intensive_optimize(centers, radii, n_circles, max_iter=1000)\n        \n        if result is not None:\n            centers_opt, radii_opt, sum_radii_opt = result\n            print(f\"    -> Optimized sum: {sum_radii_opt:.6f}\")\n            \n            if sum_radii_opt > best_sum_radii:\n                best_sum_radii = sum_radii_opt\n                best_result = result\n        \n        # Also try perturbation + re-optimization\n        if result is not None:\n            for perturb in range(2):\n                centers_pert = centers_opt + np.random.normal(0, 0.01, centers_opt.shape)\n                centers_pert = np.clip(centers_pert, 0, 1)\n                radii_pert = radii_opt * (1 + np.random.normal(0, 0.05, radii_opt.shape))\n                radii_pert = np.clip(radii_pert, 0.001, 0.5)\n                \n                result_pert = intensive_optimize(centers_pert, radii_pert, n_circles, max_iter=500)\n                \n                if result_pert is not None and result_pert[2] > best_sum_radii:\n                    best_sum_radii = result_pert[2]\n                    best_result = result_pert\n                    print(f\"    -> Perturbation improved: {best_sum_radii:.6f}\")\n    \n    return best_result\n\n\ndef quick_optimize(centers: np.ndarray, radii: np.ndarray, max_iter: int = 100) -> Optional[Tuple]:\n    \"\"\"Quick optimization with fewer iterations\"\"\"\n    n_circles = len(centers)\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    constraints = create_constraints(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-4}\n        )\n        \n        if result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            if verify_packing(centers_opt, radii_opt, tol=1e-3):\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\n\ndef intensive_optimize(centers: np.ndarray, radii: np.ndarray, n_circles: int, \n                       max_iter: int = 1000) -> Optional[Tuple]:\n    \"\"\"Intensive optimization with more iterations and tighter tolerances\"\"\"\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    constraints = create_constraints(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-8, 'disp': False}\n        )\n        \n        if result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            if verify_packing(centers_opt, radii_opt, tol=1e-4):\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\n\ndef create_constraints(n_circles: int):\n    \"\"\"Create constraint functions for optimization\"\"\"\n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Positive radii\n        constraints.extend(radii)\n        \n        return np.array(constraints)\n    \n    return {'type': 'ineq', 'fun': constraints_func}\n\n\ndef compute_initial_radii(centers: np.ndarray, n_circles: int) -> np.ndarray:\n    \"\"\"Compute initial radii based on nearest neighbor distances and boundaries\"\"\"\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Distance to boundaries\n        dist_to_boundary = min(\n            centers[i, 0], 1 - centers[i, 0],\n            centers[i, 1], 1 - centers[i, 1]\n        )\n        \n        # Distance to nearest neighbor\n        min_dist_to_neighbor = float('inf')\n        for j in range(n_circles):\n            if i != j:\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                min_dist_to_neighbor = min(min_dist_to_neighbor, dist)\n        \n        # Conservative radius estimate\n        radii[i] = min(dist_to_boundary, min_dist_to_neighbor / 2.5) * 0.9\n    \n    return np.clip(radii, 0.01, 0.5)\n\n\ndef create_grid_centers(n_circles: int) -> np.ndarray:\n    \"\"\"Create grid-based initial centers\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    \n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        centers.append([x, y])\n    \n    return np.array(centers)\n\n\ndef create_hex_centers(n_circles: int) -> np.ndarray:\n    \"\"\"Create hexagonal packing initial centers\"\"\"\n    centers = []\n    rows = int(np.ceil(np.sqrt(n_circles)))\n    \n    for row in range(rows):\n        cols = int(np.ceil(n_circles / rows))\n        offset = 0.5 if row % 2 == 1 else 0\n        \n        for col in range(cols):\n            if len(centers) >= n_circles:\n                break\n            \n            x = (col + offset + 0.5) / (cols + 0.5)\n            y = (row + 0.5) / (rows + 0.5)\n            centers.append([x, y])\n    \n    return np.array(centers[:n_circles])\n\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-4) -> bool:\n    \"\"\"Verify that a packing is valid\"\"\"\n    n_circles = len(centers)\n    \n    # Check boundaries\n    for i in range(n_circles):\n        if (centers[i, 0] - radii[i] < -tol or \n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or \n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check overlaps\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    # Check positive radii\n    if np.any(radii <= 0):\n        return False\n    \n    return True\n\n\ndef create_grid_packing(n_circles: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Fallback grid packing\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.5\n    \n    centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) * spacing\n        y = (row + 0.5) * spacing\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n_circles, radius)\n    \n    return centers, radii\n\n\ndef run_packing():\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\n{'='*50}\")\n    print(f\"FINAL RESULTS:\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n    print(f\"{'='*50}\")\n\nAdd a new function differential_evolution_refine() that:\n1. Takes best solution from phase 2\n2. Uses scipy.optimize.differential_evolution with bounds and penalty for constraints\n3. Runs for 200 iterations with popsize=10\n4. Returns improved solution if better\n\nCall this in construct_packing after phase 2, before phase 3.\n\nReturn complete working code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom typing import Tuple, List, Optional\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Hybrid approach: Random search + local optimization + differential evolution\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Phase 1: Random search to find promising starting points\n    print(\"Phase 1: Random search for initial configurations...\")\n    initial_candidates = random_search_phase(n_circles, n_trials=20)\n    \n    # Phase 2: Local optimization of top candidates\n    print(\"\\nPhase 2: Local optimization of top candidates...\")\n    best_result = local_optimization_phase(initial_candidates, n_circles, top_k=5)\n    \n    # Phase 3: Differential evolution refinement\n    if best_result is not None:\n        print(\"\\nPhase 3: Differential evolution refinement...\")\n        de_result = differential_evolution_refine(best_result, n_circles)\n        if de_result is not None and de_result[2] > best_result[2]:\n            print(f\"  Differential evolution improved: {de_result[2]:.6f}\")\n            best_result = de_result\n        else:\n            print(f\"  Differential evolution did not improve solution\")\n    \n    if best_result is None:\n        print(\"Optimization failed, using fallback grid packing\")\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    centers, radii, sum_radii = best_result\n    print(f\"\\nFinal result: Sum of radii = {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n    \n    return centers, radii, sum_radii\n\n\ndef differential_evolution_refine(initial_solution: Tuple[np.ndarray, np.ndarray, float], \n                                   n_circles: int) -> Optional[Tuple]:\n    \"\"\"\n    Phase 3: Use differential evolution for global refinement\n    \n    Args:\n        initial_solution: (centers, radii, sum_radii) tuple from previous phase\n        n_circles: number of circles\n        \n    Returns:\n        Improved solution or None if failed\n    \"\"\"\n    centers_init, radii_init, sum_radii_init = initial_solution\n    \n    # Set up bounds for all variables\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective_with_penalty(x):\n        \"\"\"\n        Objective function with penalty for constraint violations\n        We want to maximize sum of radii, so minimize negative sum\n        \"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        # Base objective: negative sum of radii (to maximize radii)\n        obj = -np.sum(radii)\n        \n        # Penalty for constraint violations\n        penalty = 0.0\n        penalty_weight = 1000.0\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                penalty += penalty_weight * (radii[i] - centers[i, 0])**2\n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                penalty += penalty_weight * (centers[i, 0] + radii[i] - 1)**2\n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                penalty += penalty_weight * (radii[i] - centers[i, 1])**2\n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                penalty += penalty_weight * (centers[i, 1] + radii[i] - 1)**2\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += penalty_weight * overlap**2\n        \n        # Penalty for very small radii (encourage larger radii)\n        for i in range(n_circles):\n            if radii[i] < 0.001:\n                penalty += penalty_weight * (0.001 - radii[i])**2\n        \n        return obj + penalty\n    \n    try:\n        # Use differential evolution with the initial solution as a seed\n        result = differential_evolution(\n            objective_with_penalty,\n            bounds,\n            maxiter=200,\n            popsize=10,\n            seed=42,\n            atol=1e-8,\n            tol=1e-8,\n            workers=1,\n            updating='deferred',\n            polish=True,  # Use L-BFGS-B to polish the best solution\n            disp=False\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify the solution is valid\n            if verify_packing(centers_opt, radii_opt, tol=1e-3):\n                return centers_opt, radii_opt, sum_radii\n            else:\n                # Try to fix minor violations with local optimization\n                fixed_result = intensive_optimize(centers_opt, radii_opt, n_circles, max_iter=500)\n                if fixed_result is not None:\n                    return fixed_result\n        \n    except Exception as e:\n        print(f\"  Differential evolution failed: {e}\")\n    \n    return None\n\n\ndef random_search_phase(n_circles: int, n_trials: int = 20) -> List[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Phase 1: Generate multiple random configurations with quick local optimization\n    Returns list of (centers, radii, sum_radii) tuples\n    \"\"\"\n    candidates = []\n    \n    for trial in range(n_trials):\n        # Strategy: Mix different initialization strategies\n        if trial < n_trials // 3:\n            # Pure random\n            centers = np.random.rand(n_circles, 2)\n        elif trial < 2 * n_trials // 3:\n            # Grid with noise\n            centers = create_grid_centers(n_circles)\n            centers += np.random.normal(0, 0.05, centers.shape)\n            centers = np.clip(centers, 0.1, 0.9)\n        else:\n            # Hexagonal-like pattern with noise\n            centers = create_hex_centers(n_circles)\n            centers += np.random.normal(0, 0.03, centers.shape)\n            centers = np.clip(centers, 0.1, 0.9)\n        \n        # Compute initial radii based on nearest neighbors\n        radii = compute_initial_radii(centers, n_circles)\n        \n        # Quick local optimization (few iterations)\n        result = quick_optimize(centers, radii, max_iter=100)\n        \n        if result is not None:\n            candidates.append(result)\n            print(f\"  Trial {trial+1}/{n_trials}: sum_radii = {result[2]:.6f}\")\n    \n    # Sort by sum of radii (descending)\n    candidates.sort(key=lambda x: x[2], reverse=True)\n    \n    return candidates\n\n\ndef local_optimization_phase(candidates: List[Tuple], n_circles: int, top_k: int = 5) -> Optional[Tuple]:\n    \"\"\"\n    Phase 2: Intensive local optimization of top candidates\n    \"\"\"\n    best_result = None\n    best_sum_radii = 0\n    \n    # Take top_k candidates\n    top_candidates = candidates[:min(top_k, len(candidates))]\n    \n    for idx, (centers, radii, sum_radii) in enumerate(top_candidates):\n        print(f\"\\n  Optimizing candidate {idx+1}/{len(top_candidates)} (initial sum: {sum_radii:.6f})...\")\n        \n        # Intensive optimization with scipy\n        result = intensive_optimize(centers, radii, n_circles, max_iter=1000)\n        \n        if result is not None:\n            centers_opt, radii_opt, sum_radii_opt = result\n            print(f\"    -> Optimized sum: {sum_radii_opt:.6f}\")\n            \n            if sum_radii_opt > best_sum_radii:\n                best_sum_radii = sum_radii_opt\n                best_result = result\n        \n        # Also try perturbation + re-optimization\n        if result is not None:\n            for perturb in range(2):\n                centers_pert = centers_opt + np.random.normal(0, 0.01, centers_opt.shape)\n                centers_pert = np.clip(centers_pert, 0, 1)\n                radii_pert = radii_opt * (1 + np.random.normal(0, 0.05, radii_opt.shape))\n                radii_pert = np.clip(radii_pert, 0.001, 0.5)\n                \n                result_pert = intensive_optimize(centers_pert, radii_pert, n_circles, max_iter=500)\n                \n                if result_pert is not None and result_pert[2] > best_sum_radii:\n                    best_sum_radii = result_pert[2]\n                    best_result = result_pert\n                    print(f\"    -> Perturbation improved: {best_sum_radii:.6f}\")\n    \n    return best_result\n\n\ndef quick_optimize(centers: np.ndarray, radii: np.ndarray, max_iter: int = 100) -> Optional[Tuple]:\n    \"\"\"Quick optimization with fewer iterations\"\"\"\n    n_circles = len(centers)\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    constraints = create_constraints(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-4}\n        )\n        \n        if result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            if verify_packing(centers_opt, radii_opt, tol=1e-3):\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\n\ndef intensive_optimize(centers: np.ndarray, radii: np.ndarray, n_circles: int, \n                       max_iter: int = 1000) -> Optional[Tuple]:\n    \"\"\"Intensive optimization with more iterations and tighter tolerances\"\"\"\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    constraints = create_constraints(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-8, 'disp': False}\n        )\n        \n        if result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            if verify_packing(centers_opt, radii_opt, tol=1e-4):\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\n\ndef create_constraints(n_circles: int):\n    \"\"\"Create constraint functions for optimization\"\"\"\n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Positive radii\n        constraints.extend(radii)\n        \n        return np.array(constraints)\n    \n    return {'type': 'ineq', 'fun': constraints_func}\n\n\ndef compute_initial_radii(centers: np.ndarray, n_circles: int) -> np.ndarray:\n    \"\"\"Compute initial radii based on nearest neighbor distances and boundaries\"\"\"\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Distance to boundaries\n        dist_to_boundary = min(\n            centers[i, 0], 1 - centers[i, 0],\n            centers[i, 1], 1 - centers[i, 1]\n        )\n        \n        # Distance to nearest neighbor\n        min_dist_to_neighbor = float('inf')\n        for j in range(n_circles):\n            if i != j:\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                min_dist_to_neighbor = min(min_dist_to_neighbor, dist)\n        \n        # Conservative radius estimate\n        radii[i] = min(dist_to_boundary, min_dist_to_neighbor / 2.5) * 0.9\n    \n    return np.clip(radii, 0.01, 0.5)\n\n\ndef create_grid_centers(n_circles: int) -> np.ndarray:\n    \"\"\"Create grid-based initial centers\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    \n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        centers.append([x, y])\n    \n    ",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom typing import Tuple, List, Optional\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Hybrid approach: Random search + local optimization + differential evolution\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Phase 1: Random search to find promising starting points\n    print(\"Phase 1: Random search for initial configurations...\")\n    initial_candidates = random_search_phase(n_circles, n_trials=20)\n    \n    # Phase 2: Local optimization of top candidates\n    print(\"\\nPhase 2: Local optimization of top candidates...\")\n    best_result = local_optimization_phase(initial_candidates, n_circles, top_k=5)\n    \n    # Phase 3: Differential evolution refinement\n    if best_result is not None:\n        print(\"\\nPhase 3: Differential evolution refinement...\")\n        de_result = differential_evolution_refine(best_result, n_circles)\n        if de_result is not None and de_result[2] > best_result[2]:\n            print(f\"  Differential evolution improved: {de_result[2]:.6f}\")\n            best_result = de_result\n        else:\n            print(f\"  Differential evolution did not improve solution\")\n    \n    if best_result is None:\n        print(\"Optimization failed, using fallback grid packing\")\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    centers, radii, sum_radii = best_result\n    print(f\"\\nFinal result: Sum of radii = {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n    \n    return centers, radii, sum_radii\n\ndef differential_evolution_refine(initial_solution: Tuple[np.ndarray, np.ndarray, float], \n                                   n_circles: int) -> Optional[Tuple]:\n    \"\"\"\n    Phase 3: Use differential evolution for global refinement\n    \n    Args:\n        initial_solution: (centers, radii, sum_radii) tuple from previous phase\n        n_circles: number of circles\n        \n    Returns:\n        Improved solution or None if failed\n    \"\"\"\n    centers_init, radii_init, sum_radii_init = initial_solution\n    \n    # Set up bounds for all variables\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective_with_penalty(x):\n        \"\"\"\n        Objective function with penalty for constraint violations\n        We want to maximize sum of radii, so minimize negative sum\n        \"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        # Base objective: negative sum of radii (to maximize radii)\n        obj = -np.sum(radii)\n        \n        # Penalty for constraint violations\n        penalty = 0.0\n        penalty_weight = 1000.0\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                penalty += penalty_weight * (radii[i] - centers[i, 0])**2\n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                penalty += penalty_weight * (centers[i, 0] + radii[i] - 1)**2\n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                penalty += penalty_weight * (radii[i] - centers[i, 1])**2\n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                penalty += penalty_weight * (centers[i, 1] + radii[i] - 1)**2\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += penalty_weight * overlap**2\n        \n        # Penalty for very small radii (encourage larger radii)\n        for i in range(n_circles):\n            if radii[i] < 0.001:\n                penalty += penalty_weight * (0.001 - radii[i])**2\n        \n        return obj + penalty\n    \n    try:\n        # Use differential evolution with the initial solution as a seed\n        result = differential_evolution(\n            objective_with_penalty,\n            bounds,\n            maxiter=200,\n            popsize=10,\n            seed=42,\n            atol=1e-8,\n            tol=1e-8,\n            workers=1,\n            updating='deferred',\n            polish=True,  # Use L-BFGS-B to polish the best solution\n            disp=False\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify the solution is valid\n            if verify_packing(centers_opt, radii_opt, tol=1e-3):\n                return centers_opt, radii_opt, sum_radii\n            else:\n                # Try to fix minor violations with local optimization\n                fixed_result = intensive_optimize(centers_opt, radii_opt, n_circles, max_iter=500)\n                if fixed_result is not None:\n                    return fixed_result\n        \n    except Exception as e:\n        print(f\"  Differential evolution failed: {e}\")\n    \n    return None\n\ndef random_search_phase(n_circles: int, n_trials: int = 20) -> List[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Phase 1: Generate multiple random configurations with quick local optimization\n    Returns list of (centers, radii, sum_radii) tuples\n    \"\"\"\n    candidates = []\n    \n    for trial in range(n_trials):\n        # Strategy: Mix different initialization strategies\n        if trial < n_trials // 3:\n            # Pure random\n            centers = np.random.rand(n_circles, 2)\n        elif trial < 2 * n_trials // 3:\n            # Grid with noise\n            centers = create_grid_centers(n_circles)\n            centers += np.random.normal(0, 0.05, centers.shape)\n            centers = np.clip(centers, 0.1, 0.9)\n        else:\n            # Hexagonal-like pattern with noise\n            centers = create_hex_centers(n_circles)\n            centers += np.random.normal(0, 0.03, centers.shape)\n            centers = np.clip(centers, 0.1, 0.9)\n        \n        # Compute initial radii based on nearest neighbors\n        radii = compute_initial_radii(centers, n_circles)\n        \n        # Quick local optimization (few iterations)\n        result = quick_optimize(centers, radii, max_iter=100)\n        \n        if result is not None:\n            candidates.append(result)\n            print(f\"  Trial {trial+1}/{n_trials}: sum_radii = {result[2]:.6f}\")\n    \n    # Sort by sum of radii (descending)\n    candidates.sort(key=lambda x: x[2], reverse=True)\n    \n    return candidates\n\ndef local_optimization_phase(candidates: List[Tuple], n_circles: int, top_k: int = 5) -> Optional[Tuple]:\n    \"\"\"\n    Phase 2: Intensive local optimization of top candidates\n    \"\"\"\n    best_result = None\n    best_sum_radii = 0\n    \n    # Take top_k candidates\n    top_candidates = candidates[:min(top_k, len(candidates))]\n    \n    for idx, (centers, radii, sum_radii) in enumerate(top_candidates):\n        print(f\"\\n  Optimizing candidate {idx+1}/{len(top_candidates)} (initial sum: {sum_radii:.6f})...\")\n        \n        # Intensive optimization with scipy\n        result = intensive_optimize(centers, radii, n_circles, max_iter=1000)\n        \n        if result is not None:\n            centers_opt, radii_opt, sum_radii_opt = result\n            print(f\"    -> Optimized sum: {sum_radii_opt:.6f}\")\n            \n            if sum_radii_opt > best_sum_radii:\n                best_sum_radii = sum_radii_opt\n                best_result = result\n        \n        # Also try perturbation + re-optimization\n        if result is not None:\n            for perturb in range(2):\n                centers_pert = centers_opt + np.random.normal(0, 0.01, centers_opt.shape)\n                centers_pert = np.clip(centers_pert, 0, 1)\n                radii_pert = radii_opt * (1 + np.random.normal(0, 0.05, radii_opt.shape))\n                radii_pert = np.clip(radii_pert, 0.001, 0.5)\n                \n                result_pert = intensive_optimize(centers_pert, radii_pert, n_circles, max_iter=500)\n                \n                if result_pert is not None and result_pert[2] > best_sum_radii:\n                    best_sum_radii = result_pert[2]\n                    best_result = result_pert\n                    print(f\"    -> Perturbation improved: {best_sum_radii:.6f}\")\n    \n    return best_result\n\ndef quick_optimize(centers: np.ndarray, radii: np.ndarray, max_iter: int = 100) -> Optional[Tuple]:\n    \"\"\"Quick optimization with fewer iterations\"\"\"\n    n_circles = len(centers)\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    constraints = create_constraints(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-4}\n        )\n        \n        if result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            if verify_packing(centers_opt, radii_opt, tol=1e-3):\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef intensive_optimize(centers: np.ndarray, radii: np.ndarray, n_circles: int, \n                       max_iter: int = 1000) -> Optional[Tuple]:\n    \"\"\"Intensive optimization with more iterations and tighter tolerances\"\"\"\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    def objective(x):\n        return -np.sum(x[2*n_circles:])\n    \n    constraints = create_constraints(n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': max_iter, 'ftol': 1e-8, 'disp': False}\n        )\n        \n        if result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            if verify_packing(centers_opt, radii_opt, tol=1e-4):\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef create_constraints(n_circles: int):\n    \"\"\"Create constraint functions for optimization\"\"\"\n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # left\n            constraints.append(1 - centers[i, 0] - radii[i])  # right\n            constraints.append(centers[i, 1] - radii[i])  # bottom\n            constraints.append(1 - centers[i, 1] - radii[i])  # top\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Positive radii\n        constraints.extend(radii)\n        \n        return np.array(constraints)\n    \n    return {'type': 'ineq', 'fun': constraints_func}\n\ndef compute_initial_radii(centers: np.ndarray, n_circles: int) -> np.ndarray:\n    \"\"\"Compute initial radii based on nearest neighbor distances and boundaries\"\"\"\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Distance to boundaries\n        dist_to_boundary = min(\n            centers[i, 0], 1 - centers[i, 0],\n            centers[i, 1], 1 - centers[i, 1]\n        )\n        \n        # Distance to nearest neighbor\n        min_dist_to_neighbor = float('inf')\n        for j in range(n_circles):\n            if i != j:\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                min_dist_to_neighbor = min(min_dist_to_neighbor, dist)\n        \n        # Conservative radius estimate\n        radii[i] = min(dist_to_boundary, min_dist_to_neighbor / 2.5) * 0.9\n    \n    return np.clip(radii, 0.01, 0.5)\n\ndef create_grid_centers(n_circles: int) -> np.ndarray:\n    \"\"\"Create grid-based initial centers\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    \n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        centers.append([x, y])",
  "timestamp": "2025-12-08T13:05:24.672156",
  "cost_data": null
}