{
  "trial_id": "trial_3_13",
  "generation": 3,
  "parent_id": "trial_1_0",
  "code": "",
  "metrics": {},
  "prompt": "Improve trial_1_0 with better method selection:\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 30  # Increased from 15\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Generate diverse initial configurations\n    initial_configs = generate_initial_configurations(n_circles, n_trials)\n    \n    for trial, (centers, radii) in enumerate(initial_configs):\n        print(f\"Trial {trial + 1}/{n_trials}...\")\n        \n        # Try multiple optimization methods\n        for method in ['SLSQP', 'trust-constr']:\n            result = optimize_packing(centers.copy(), radii.copy(), method=method)\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                if sum_radii > best_sum_radii:\n                    best_sum_radii = sum_radii\n                    best_result = result\n                    print(f\"  New best with {method}: {sum_radii:.6f}\")\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\ndef generate_initial_configurations(n_circles: int, n_configs: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"\n    Generate diverse initial configurations including structured and random layouts\n    \"\"\"\n    configs = []\n    \n    # 1. Hexagonal packing variations (4 configs)\n    for i in range(4):\n        centers, radii = create_hexagonal_packing(n_circles, offset=i*0.1)\n        configs.append((centers, radii))\n    \n    # 2. Grid variations (4 configs)\n    for grid_size in [5, 6, 7, 8]:\n        centers, radii = create_grid_packing(n_circles, grid_size=grid_size)\n        configs.append((centers, radii))\n    \n    # 3. Concentric circles (2 configs)\n    for i in range(2):\n        centers, radii = create_concentric_packing(n_circles, layers=3+i)\n        configs.append((centers, radii))\n    \n    # 4. Random with varying densities (remaining configs)\n    remaining = n_configs - len(configs)\n    for i in range(remaining):\n        if i % 3 == 0:\n            # Clustered random\n            centers = generate_clustered_centers(n_circles)\n        elif i % 3 == 1:\n            # Uniform random\n            centers = np.random.rand(n_circles, 2)\n        else:\n            # Random with repulsion\n            centers = generate_repulsed_centers(n_circles)\n        \n        # Vary initial radii\n        if i % 2 == 0:\n            radii = np.full(n_circles, 0.05)\n        else:\n            radii = np.random.uniform(0.02, 0.08, n_circles)\n        \n        configs.append((centers, radii))\n    \n    return configs[:n_configs]\n\ndef create_hexagonal_packing(n_circles: int, offset: float = 0.0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a hexagonal close-packing arrangement\n    \"\"\"\n    centers = []\n    \n    # Hexagonal packing parameters\n    rows = 6\n    cols = 6\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = (col + 0.5 + (row % 2) * 0.5) * dx + offset\n            y = (row + 0.5) * dy + offset\n            \n            # Keep within bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.06)\n    \n    return centers, radii\n\ndef create_grid_packing(n_circles: int, grid_size: int = 6) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a grid-based packing\n    \"\"\"\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.2\n    \n    centers = []\n    count = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count >= n_circles:\n                break\n            x = (i + 0.5) * spacing\n            y = (j + 0.5) * spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, radius)\n    \n    return centers, radii\n\ndef create_concentric_packing(n_circles: int, layers: int = 3) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create concentric circular arrangement\n    \"\"\"\n    centers = []\n    circles_per_layer = n_circles // layers\n    remainder = n_circles % layers\n    \n    for layer in range(layers):\n        n_in_layer = circles_per_layer + (1 if layer < remainder else 0)\n        radius_layer = 0.4 - layer * 0.12\n        \n        for i in range(n_in_layer):\n            angle = 2 * np.pi * i / n_in_layer\n            x = 0.5 + radius_layer * np.cos(angle)\n            y = 0.5 + radius_layer * np.sin(angle)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.05)\n    \n    return centers, radii\n\ndef generate_clustered_centers(n_circles: int, n_clusters: int = 4) -> np.ndarray:\n    \"\"\"\n    Generate clustered random centers\n    \"\"\"\n    centers = []\n    circles_per_cluster = n_circles // n_clusters\n    \n    cluster_centers = np.random.uniform(0.2, 0.8, (n_clusters, 2))\n    \n    for i in range(n_clusters):\n        n_in_cluster = circles_per_cluster + (1 if i < n_circles % n_clusters else 0)\n        cluster_points = cluster_centers[i] + np.random.normal(0, 0.1, (n_in_cluster, 2))\n        cluster_points = np.clip(cluster_points, 0.05, 0.95)\n        centers.extend(cluster_points)\n    \n    return np.array(centers[:n_circles])\n\ndef generate_repulsed_centers(n_circles: int, iterations: int = 50) -> np.ndarray:\n    \"\"\"\n    Generate centers with mutual repulsion for better initial spacing\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist > 0:\n                        # Repulsive force inversely proportional to distance\n                        force = diff / (dist ** 3 + 0.01)\n                        forces[i] += force\n        \n        # Update positions\n        centers += 0.01 * forces\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    return centers\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, method: str = 'SLSQP') -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Optimize a packing configuration using scipy.optimize\n    \"\"\"\n    n_circles = len(centers_init)\n    \n    # Pack parameters: [centers (flattened), radii]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        # Minimize negative sum of radii (maximize sum of radii)\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Constraint: circles inside unit square\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n        \n        # Constraint: no overlaps (distance >= sum of radii)\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Constraint: radii positive\n        for i in range(n_circles):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    # Bounds for variables\n    bounds = []\n    # Centers: [0, 1]\n    for i in range(2*n_circles):\n        bounds.append((0, 1))\n    # Radii: [0.001, 0.5]\n    for i in range(n_circles):\n        bounds.append((0.001, 0.5))\n    \n    # Constraints\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    # Optimize with increased iterations\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6}  # Increased from 500\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify solution\n            if verify_packing(centers_opt, radii_opt):\n                return centers_opt, radii_opt, sum_radii\n    except Exception as e:\n        print(f\"  Optimization failed with {method}: {e}\")\n    \n    return None\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-4) -> bool:\n    \"\"\"\n    Verify that a packing is valid\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check circles inside unit square\n    for i in range(n_circles):\n        if (centers[i, 0] - radii[i] < -tol or \n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or \n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check no overlaps\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    # Check positive radii\n    if np.any(radii < 0):\n        return False\n    \n    return True\n\ndef run_packing():\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nFinal Results:\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n\nIn optimize_packing:\n1. Try both SLSQP and trust-constr for each configuration\n2. Keep the better result from each method\n3. Track which method works best and prioritize it in later trials\n\nReturn complete working code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List, Optional\nfrom collections import defaultdict\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 30\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Track method performance\n    method_stats = defaultdict(lambda: {'successes': 0, 'total': 0, 'best_score': 0})\n    \n    # Generate diverse initial configurations\n    initial_configs = generate_initial_configurations(n_circles, n_trials)\n    \n    # First phase: try all methods on first few configs to establish baseline\n    methods_to_try = ['SLSQP', 'trust-constr']\n    \n    for trial, (centers, radii) in enumerate(initial_configs):\n        print(f\"Trial {trial + 1}/{n_trials}...\")\n        \n        trial_best_result = None\n        trial_best_sum = 0\n        trial_best_method = None\n        \n        # Try all methods for this configuration\n        for method in methods_to_try:\n            result = optimize_packing(centers.copy(), radii.copy(), method=method)\n            \n            method_stats[method]['total'] += 1\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                method_stats[method]['successes'] += 1\n                \n                # Track best for this trial\n                if sum_radii > trial_best_sum:\n                    trial_best_sum = sum_radii\n                    trial_best_result = result\n                    trial_best_method = method\n                \n                # Track method performance\n                if sum_radii > method_stats[method]['best_score']:\n                    method_stats[method]['best_score'] = sum_radii\n        \n        # Update global best\n        if trial_best_result is not None and trial_best_sum > best_sum_radii:\n            best_sum_radii = trial_best_sum\n            best_result = trial_best_result\n            print(f\"  New best with {trial_best_method}: {best_sum_radii:.6f}\")\n        \n        # After 10 trials, prioritize better-performing methods\n        if trial == 9:\n            methods_to_try = rank_methods(method_stats)\n            print(f\"\\nMethod ranking after 10 trials: {methods_to_try}\")\n            print_method_stats(method_stats)\n    \n    # Print final statistics\n    print(\"\\nFinal method statistics:\")\n    print_method_stats(method_stats)\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\ndef rank_methods(method_stats: dict) -> List[str]:\n    \"\"\"\n    Rank methods by their performance (success rate and best score)\n    \"\"\"\n    method_scores = []\n    \n    for method, stats in method_stats.items():\n        if stats['total'] > 0:\n            success_rate = stats['successes'] / stats['total']\n            # Combined score: 70% best result, 30% success rate\n            score = 0.7 * stats['best_score'] + 0.3 * success_rate\n            method_scores.append((method, score))\n    \n    # Sort by score descending\n    method_scores.sort(key=lambda x: x[1], reverse=True)\n    \n    return [method for method, _ in method_scores]\n\ndef print_method_stats(method_stats: dict):\n    \"\"\"\n    Print statistics for each method\n    \"\"\"\n    for method, stats in method_stats.items():\n        if stats['total'] > 0:\n            success_rate = 100 * stats['successes'] / stats['total']\n            print(f\"  {method}: {stats['successes']}/{stats['total']} successes \"\n                  f\"({success_rate:.1f}%), best score: {stats['best_score']:.6f}\")\n\ndef generate_initial_configurations(n_circles: int, n_configs: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"\n    Generate diverse initial configurations including structured and random layouts\n    \"\"\"\n    configs = []\n    \n    # 1. Hexagonal packing variations (4 configs)\n    for i in range(4):\n        centers, radii = create_hexagonal_packing(n_circles, offset=i*0.1)\n        configs.append((centers, radii))\n    \n    # 2. Grid variations (4 configs)\n    for grid_size in [5, 6, 7, 8]:\n        centers, radii = create_grid_packing(n_circles, grid_size=grid_size)\n        configs.append((centers, radii))\n    \n    # 3. Concentric circles (2 configs)\n    for i in range(2):\n        centers, radii = create_concentric_packing(n_circles, layers=3+i)\n        configs.append((centers, radii))\n    \n    # 4. Random with varying densities (remaining configs)\n    remaining = n_configs - len(configs)\n    for i in range(remaining):\n        if i % 3 == 0:\n            # Clustered random\n            centers = generate_clustered_centers(n_circles)\n        elif i % 3 == 1:\n            # Uniform random\n            centers = np.random.rand(n_circles, 2)\n        else:\n            # Random with repulsion\n            centers = generate_repulsed_centers(n_circles)\n        \n        # Vary initial radii\n        if i % 2 == 0:\n            radii = np.full(n_circles, 0.05)\n        else:\n            radii = np.random.uniform(0.02, 0.08, n_circles)\n        \n        configs.append((centers, radii))\n    \n    return configs[:n_configs]\n\ndef create_hexagonal_packing(n_circles: int, offset: float = 0.0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a hexagonal close-packing arrangement\n    \"\"\"\n    centers = []\n    \n    # Hexagonal packing parameters\n    rows = 6\n    cols = 6\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = (col + 0.5 + (row % 2) * 0.5) * dx + offset\n            y = (row + 0.5) * dy + offset\n            \n            # Keep within bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.06)\n    \n    return centers, radii\n\ndef create_grid_packing(n_circles: int, grid_size: int = 6) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a grid-based packing\n    \"\"\"\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.2\n    \n    centers = []\n    count = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count >= n_circles:\n                break\n            x = (i + 0.5) * spacing\n            y = (j + 0.5) * spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, radius)\n    \n    return centers, radii\n\ndef create_concentric_packing(n_circles: int, layers: int = 3) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create concentric circular arrangement\n    \"\"\"\n    centers = []\n    circles_per_layer = n_circles // layers\n    remainder = n_circles % layers\n    \n    for layer in range(layers):\n        n_in_layer = circles_per_layer + (1 if layer < remainder else 0)\n        radius_layer = 0.4 - layer * 0.12\n        \n        for i in range(n_in_layer):\n            angle = 2 * np.pi * i / n_in_layer\n            x = 0.5 + radius_layer * np.cos(angle)\n            y = 0.5 + radius_layer * np.sin(angle)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.05)\n    \n    return centers, radii\n\ndef generate_clustered_centers(n_circles: int, n_clusters: int = 4) -> np.ndarray:\n    \"\"\"\n    Generate clustered random centers\n    \"\"\"\n    centers = []\n    circles_per_cluster = n_circles // n_clusters\n    \n    cluster_centers = np.random.uniform(0.2, 0.8, (n_clusters, 2))\n    \n    for i in range(n_clusters):\n        n_in_cluster = circles_per_cluster + (1 if i < n_circles % n_clusters else 0)\n        cluster_points = cluster_centers[i] + np.random.normal(0, 0.1, (n_in_cluster, 2))\n        cluster_points = np.clip(cluster_points, 0.05, 0.95)\n        centers.extend(cluster_points)\n    \n    return np.array(centers[:n_circles])\n\ndef generate_repulsed_centers(n_circles: int, iterations: int = 50) -> np.ndarray:\n    \"\"\"\n    Generate centers with mutual repulsion for better initial spacing\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist > 0:\n                        # Repulsive force inversely proportional to distance\n                        force = diff / (dist ** 3 + 0.01)\n                        forces[i] += force\n        \n        # Update positions\n        centers += 0.01 * forces\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    return centers\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, method: str = 'SLSQP') -> Optional[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Optimize a packing configuration using scipy.optimize\n    \"\"\"\n    n_circles = len(centers_init)\n    \n    # Pack parameters: [centers (flattened), radii]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        # Minimize negative sum of radii (maximize sum of radii)\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Constraint: circles inside unit square\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n        \n        # Constraint: no overlaps (distance >= sum of radii)\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Constraint: radii positive\n        for i in range(n_circles):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    # Bounds for variables\n    bounds = []\n    # Centers: [0, 1]\n    for i in range(2*n_circles):\n        bounds.append((0, 1))\n    # Radii: [0.001, 0.5]\n    for i in range(n_circles):\n        bounds.append((0.001, 0.5))\n    \n    # Constraints\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    # Method-specific options\n    options = {\n        'SLSQP': {'maxiter': 1000, 'ftol': 1e-7},\n        'trust-constr': {'maxiter': 1000, 'gtol': 1e-6, 'xtol': 1e-8}\n    }\n    \n    # Optimize\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            bounds=bounds,\n            constraints=constraints,\n            options=options.get(method, {'maxiter': 1000})\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify solution\n            if verify_packing(centers_opt, radii_opt):\n                return centers_opt, radii_opt, sum_radii\n    except Exception as e:\n        print(f\"  Optimization failed with {method}: {str(e)[:50]}\")\n    \n    return None\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-4) -> bool:\n    \"\"\"\n    Verify that a packing is valid\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check circles inside unit square\n    for i in range(n_circles):\n        if (centers[i, 0] - radii[i] < -tol or \n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or \n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check no overlaps\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    ",
  "reasoning": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List, Optional\nfrom collections import defaultdict\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 30\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Track method performance\n    method_stats = defaultdict(lambda: {'successes': 0, 'total': 0, 'best_score': 0})\n    \n    # Generate diverse initial configurations\n    initial_configs = generate_initial_configurations(n_circles, n_trials)\n    \n    # First phase: try all methods on first few configs to establish baseline\n    methods_to_try = ['SLSQP', 'trust-constr']\n    \n    for trial, (centers, radii) in enumerate(initial_configs):\n        print(f\"Trial {trial + 1}/{n_trials}...\")\n        \n        trial_best_result = None\n        trial_best_sum = 0\n        trial_best_method = None\n        \n        # Try all methods for this configuration\n        for method in methods_to_try:\n            result = optimize_packing(centers.copy(), radii.copy(), method=method)\n            \n            method_stats[method]['total'] += 1\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                method_stats[method]['successes'] += 1\n                \n                # Track best for this trial\n                if sum_radii > trial_best_sum:\n                    trial_best_sum = sum_radii\n                    trial_best_result = result\n                    trial_best_method = method\n                \n                # Track method performance\n                if sum_radii > method_stats[method]['best_score']:\n                    method_stats[method]['best_score'] = sum_radii\n        \n        # Update global best\n        if trial_best_result is not None and trial_best_sum > best_sum_radii:\n            best_sum_radii = trial_best_sum\n            best_result = trial_best_result\n            print(f\"  New best with {trial_best_method}: {best_sum_radii:.6f}\")\n        \n        # After 10 trials, prioritize better-performing methods\n        if trial == 9:\n            methods_to_try = rank_methods(method_stats)\n            print(f\"\\nMethod ranking after 10 trials: {methods_to_try}\")\n            print_method_stats(method_stats)\n    \n    # Print final statistics\n    print(\"\\nFinal method statistics:\")\n    print_method_stats(method_stats)\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\ndef rank_methods(method_stats: dict) -> List[str]:\n    \"\"\"\n    Rank methods by their performance (success rate and best score)\n    \"\"\"\n    method_scores = []\n    \n    for method, stats in method_stats.items():\n        if stats['total'] > 0:\n            success_rate = stats['successes'] / stats['total']\n            # Combined score: 70% best result, 30% success rate\n            score = 0.7 * stats['best_score'] + 0.3 * success_rate\n            method_scores.append((method, score))\n    \n    # Sort by score descending\n    method_scores.sort(key=lambda x: x[1], reverse=True)\n    \n    return [method for method, _ in method_scores]\n\ndef print_method_stats(method_stats: dict):\n    \"\"\"\n    Print statistics for each method\n    \"\"\"\n    for method, stats in method_stats.items():\n        if stats['total'] > 0:\n            success_rate = 100 * stats['successes'] / stats['total']\n            print(f\"  {method}: {stats['successes']}/{stats['total']} successes \"\n                  f\"({success_rate:.1f}%), best score: {stats['best_score']:.6f}\")\n\ndef generate_initial_configurations(n_circles: int, n_configs: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"\n    Generate diverse initial configurations including structured and random layouts\n    \"\"\"\n    configs = []\n    \n    # 1. Hexagonal packing variations (4 configs)\n    for i in range(4):\n        centers, radii = create_hexagonal_packing(n_circles, offset=i*0.1)\n        configs.append((centers, radii))\n    \n    # 2. Grid variations (4 configs)\n    for grid_size in [5, 6, 7, 8]:\n        centers, radii = create_grid_packing(n_circles, grid_size=grid_size)\n        configs.append((centers, radii))\n    \n    # 3. Concentric circles (2 configs)\n    for i in range(2):\n        centers, radii = create_concentric_packing(n_circles, layers=3+i)\n        configs.append((centers, radii))\n    \n    # 4. Random with varying densities (remaining configs)\n    remaining = n_configs - len(configs)\n    for i in range(remaining):\n        if i % 3 == 0:\n            # Clustered random\n            centers = generate_clustered_centers(n_circles)\n        elif i % 3 == 1:\n            # Uniform random\n            centers = np.random.rand(n_circles, 2)\n        else:\n            # Random with repulsion\n            centers = generate_repulsed_centers(n_circles)\n        \n        # Vary initial radii\n        if i % 2 == 0:\n            radii = np.full(n_circles, 0.05)\n        else:\n            radii = np.random.uniform(0.02, 0.08, n_circles)\n        \n        configs.append((centers, radii))\n    \n    return configs[:n_configs]\n\ndef create_hexagonal_packing(n_circles: int, offset: float = 0.0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a hexagonal close-packing arrangement\n    \"\"\"\n    centers = []\n    \n    # Hexagonal packing parameters\n    rows = 6\n    cols = 6\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = (col + 0.5 + (row % 2) * 0.5) * dx + offset\n            y = (row + 0.5) * dy + offset\n            \n            # Keep within bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.06)\n    \n    return centers, radii\n\ndef create_grid_packing(n_circles: int, grid_size: int = 6) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a grid-based packing\n    \"\"\"\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.2\n    \n    centers = []\n    count = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count >= n_circles:\n                break\n            x = (i + 0.5) * spacing\n            y = (j + 0.5) * spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, radius)\n    \n    return centers, radii\n\ndef create_concentric_packing(n_circles: int, layers: int = 3) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create concentric circular arrangement\n    \"\"\"\n    centers = []\n    circles_per_layer = n_circles // layers\n    remainder = n_circles % layers\n    \n    for layer in range(layers):\n        n_in_layer = circles_per_layer + (1 if layer < remainder else 0)\n        radius_layer = 0.4 - layer * 0.12\n        \n        for i in range(n_in_layer):\n            angle = 2 * np.pi * i / n_in_layer\n            x = 0.5 + radius_layer * np.cos(angle)\n            y = 0.5 + radius_layer * np.sin(angle)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.05)\n    \n    return centers, radii\n\ndef generate_clustered_centers(n_circles: int, n_clusters: int = 4) -> np.ndarray:\n    \"\"\"\n    Generate clustered random centers\n    \"\"\"\n    centers = []\n    circles_per_cluster = n_circles // n_clusters\n    \n    cluster_centers = np.random.uniform(0.2, 0.8, (n_clusters, 2))\n    \n    for i in range(n_clusters):\n        n_in_cluster = circles_per_cluster + (1 if i < n_circles % n_clusters else 0)\n        cluster_points = cluster_centers[i] + np.random.normal(0, 0.1, (n_in_cluster, 2))\n        cluster_points = np.clip(cluster_points, 0.05, 0.95)\n        centers.extend(cluster_points)\n    \n    return np.array(centers[:n_circles])\n\ndef generate_repulsed_centers(n_circles: int, iterations: int = 50) -> np.ndarray:\n    \"\"\"\n    Generate centers with mutual repulsion for better initial spacing\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist > 0:\n                        # Repulsive force inversely proportional to distance\n                        force = diff / (dist ** 3 + 0.01)\n                        forces[i] += force\n        \n        # Update positions\n        centers += 0.01 * forces\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    return centers\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, method: str = 'SLSQP') -> Optional[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Optimize a packing configuration using scipy.optimize\n    \"\"\"\n    n_circles = len(centers_init)\n    \n    # Pack parameters: [centers (flattened), radii]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        # Minimize negative sum of radii (maximize sum of radii)\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Constraint: circles inside unit square\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n        \n        # Constraint: no overlaps (distance >= sum of radii)\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Constraint: radii positive\n        for i in range(n_circles):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    # Bounds for variables\n    bounds = []\n    # Centers: [0, 1]\n    for i in range(2*n_circles):\n        bounds.append((0, 1))\n    # Radii: [0.001, 0.5]\n    for i in range(n_circles):\n        bounds.append((0.001, 0.5))\n    \n    # Constraints\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    # Method-specific options\n    options = {\n        'SLSQP': {'maxiter': 1000, 'ftol': 1e-7},\n        'trust-constr': {'maxiter': 1000, 'gtol': 1e-6, 'xtol': 1e-8}\n    }\n    \n    # Optimize\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            bounds=bounds,\n            constraints=constraints,\n            options=options.get(method, {'maxiter': 1000})\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify solution\n            if verify_packing(centers_opt, radii_opt):\n                return centers_opt, radii_opt, sum_radii\n    except Exception as e:\n        print(f\"  Optimization failed with {method}: {str(e)[:50]}\")\n    \n    return None\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-4) -> bool:\n    \"\"\"\n    Verify that a packing is valid\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check circles inside unit square\n    for i in range(n_circles):\n        if (centers[i, 0] - radii[i] < -tol or \n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or \n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check no overlaps\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False",
  "timestamp": "2025-12-08T13:05:25.320562",
  "cost_data": null
}