{
  "trial_id": "trial_3_11",
  "generation": 3,
  "parent_id": "trial_1_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 30  # Increased from 15\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Generate diverse initial configurations\n    initial_configs = generate_initial_configurations(n_circles, n_trials)\n    \n    for trial, (centers, radii) in enumerate(initial_configs):\n        print(f\"Trial {trial + 1}/{n_trials}...\")\n        \n        # Try multiple optimization methods\n        for method in ['SLSQP', 'trust-constr']:\n            result = optimize_packing(centers.copy(), radii.copy(), method=method)\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                if sum_radii > best_sum_radii:\n                    best_sum_radii = sum_radii\n                    best_result = result\n                    print(f\"  New best with {method}: {sum_radii:.6f}\")\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\ndef generate_initial_configurations(n_circles: int, n_configs: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"\n    Generate diverse initial configurations including structured and random layouts\n    \"\"\"\n    configs = []\n    \n    # 1. Hexagonal packing variations (4 configs)\n    for i in range(4):\n        centers, radii = create_hexagonal_packing(n_circles, offset=i*0.1)\n        configs.append((centers, radii))\n    \n    # 2. Grid variations (4 configs)\n    for grid_size in [5, 6, 7, 8]:\n        centers, radii = create_grid_packing(n_circles, grid_size=grid_size)\n        configs.append((centers, radii))\n    \n    # 3. Concentric circles (6 configs - increased from 2)\n    for i in range(6):\n        centers, radii = create_concentric_packing(n_circles, layers=3+i)\n        configs.append((centers, radii))\n    \n    # 4. Random with varying densities (remaining configs)\n    remaining = n_configs - len(configs)\n    for i in range(remaining):\n        if i % 3 == 0:\n            # Clustered random\n            centers = generate_clustered_centers(n_circles)\n        elif i % 3 == 1:\n            # Uniform random\n            centers = np.random.rand(n_circles, 2)\n        else:\n            # Random with repulsion\n            centers = generate_repulsed_centers(n_circles)\n        \n        # Vary initial radii\n        if i % 2 == 0:\n            radii = np.full(n_circles, 0.05)\n        else:\n            radii = np.random.uniform(0.02, 0.08, n_circles)\n        \n        configs.append((centers, radii))\n    \n    return configs[:n_configs]\n\ndef create_hexagonal_packing(n_circles: int, offset: float = 0.0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a hexagonal close-packing arrangement\n    \"\"\"\n    centers = []\n    \n    # Hexagonal packing parameters\n    rows = 6\n    cols = 6\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = (col + 0.5 + (row % 2) * 0.5) * dx + offset\n            y = (row + 0.5) * dy + offset\n            \n            # Keep within bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.06)\n    \n    return centers, radii\n\ndef create_grid_packing(n_circles: int, grid_size: int = 6) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a grid-based packing\n    \"\"\"\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.2\n    \n    centers = []\n    count = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count >= n_circles:\n                break\n            x = (i + 0.5) * spacing\n            y = (j + 0.5) * spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, radius)\n    \n    return centers, radii\n\ndef create_concentric_packing(n_circles: int, layers: int = 3) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create concentric circular arrangement\n    \"\"\"\n    centers = []\n    circles_per_layer = n_circles // layers\n    remainder = n_circles % layers\n    \n    for layer in range(layers):\n        n_in_layer = circles_per_layer + (1 if layer < remainder else 0)\n        radius_layer = 0.4 - layer * 0.12\n        \n        for i in range(n_in_layer):\n            angle = 2 * np.pi * i / n_in_layer\n            x = 0.5 + radius_layer * np.cos(angle)\n            y = 0.5 + radius_layer * np.sin(angle)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.05)\n    \n    return centers, radii\n\ndef generate_clustered_centers(n_circles: int, n_clusters: int = 4) -> np.ndarray:\n    \"\"\"\n    Generate clustered random centers\n    \"\"\"\n    centers = []\n    circles_per_cluster = n_circles // n_clusters\n    \n    cluster_centers = np.random.uniform(0.2, 0.8, (n_clusters, 2))\n    \n    for i in range(n_clusters):\n        n_in_cluster = circles_per_cluster + (1 if i < n_circles % n_clusters else 0)\n        cluster_points = cluster_centers[i] + np.random.normal(0, 0.1, (n_in_cluster, 2))\n        cluster_points = np.clip(cluster_points, 0.05, 0.95)\n        centers.extend(cluster_points)\n    \n    return np.array(centers[:n_circles])\n\ndef generate_repulsed_centers(n_circles: int, iterations: int = 50) -> np.ndarray:\n    \"\"\"\n    Generate centers with mutual repulsion for better initial spacing\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist > 0:\n                        # Repulsive force inversely proportional to distance\n                        force = diff / (dist ** 3 + 0.01)\n                        forces[i] += force\n        \n        # Update positions\n        centers += 0.01 * forces\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    return centers\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, method: str = 'SLSQP') -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Optimize a packing configuration using scipy.optimize\n    \"\"\"\n    n_circles = len(centers_init)\n    \n    # Pack parameters: [centers (flattened), radii]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        # Minimize negative sum of radii (maximize sum of radii)\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Constraint: circles inside unit square\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n        \n        # Constraint: no overlaps (distance >= sum of radii)\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Constraint: radii positive\n        for i in range(n_circles):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    # Bounds for variables\n    bounds = []\n    # Centers: [0, 1]\n    for i in range(2*n_circles):\n        bounds.append((0, 1))\n    # Radii: [0.001, 0.5]\n    for i in range(n_circles):\n        bounds.append((0.001, 0.5))\n    \n    # Constraints\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    # Optimize with increased iterations\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1200, 'ftol': 1e-6}  # Increased from 1000\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify solution\n            if verify_packing(centers_opt, radii_opt):\n                return centers_opt, radii_opt, sum_radii\n    except Exception as e:\n        print(f\"  Optimization failed with {method}: {e}\")\n    \n    return None\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-4) -> bool:\n    \"\"\"\n    Verify that a packing is valid\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check circles inside unit square\n    for i in range(n_circles):\n        if (centers[i, 0] - radii[i] < -tol or \n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or \n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check no overlaps\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    # Check positive radii\n    if np.any(radii < 0):\n        return False\n    \n    return True\n\ndef run_packing():\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nFinal Results:\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.597898920671808,
    "target_ratio": 0.9859198939930961,
    "combined_score": 0.9859198939930961,
    "eval_time": 30.09066081047058,
    "error": null
  },
  "prompt": "Make a small improvement to trial_1_0:\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 30  # Increased from 15\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Generate diverse initial configurations\n    initial_configs = generate_initial_configurations(n_circles, n_trials)\n    \n    for trial, (centers, radii) in enumerate(initial_configs):\n        print(f\"Trial {trial + 1}/{n_trials}...\")\n        \n        # Try multiple optimization methods\n        for method in ['SLSQP', 'trust-constr']:\n            result = optimize_packing(centers.copy(), radii.copy(), method=method)\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                if sum_radii > best_sum_radii:\n                    best_sum_radii = sum_radii\n                    best_result = result\n                    print(f\"  New best with {method}: {sum_radii:.6f}\")\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\ndef generate_initial_configurations(n_circles: int, n_configs: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"\n    Generate diverse initial configurations including structured and random layouts\n    \"\"\"\n    configs = []\n    \n    # 1. Hexagonal packing variations (4 configs)\n    for i in range(4):\n        centers, radii = create_hexagonal_packing(n_circles, offset=i*0.1)\n        configs.append((centers, radii))\n    \n    # 2. Grid variations (4 configs)\n    for grid_size in [5, 6, 7, 8]:\n        centers, radii = create_grid_packing(n_circles, grid_size=grid_size)\n        configs.append((centers, radii))\n    \n    # 3. Concentric circles (2 configs)\n    for i in range(2):\n        centers, radii = create_concentric_packing(n_circles, layers=3+i)\n        configs.append((centers, radii))\n    \n    # 4. Random with varying densities (remaining configs)\n    remaining = n_configs - len(configs)\n    for i in range(remaining):\n        if i % 3 == 0:\n            # Clustered random\n            centers = generate_clustered_centers(n_circles)\n        elif i % 3 == 1:\n            # Uniform random\n            centers = np.random.rand(n_circles, 2)\n        else:\n            # Random with repulsion\n            centers = generate_repulsed_centers(n_circles)\n        \n        # Vary initial radii\n        if i % 2 == 0:\n            radii = np.full(n_circles, 0.05)\n        else:\n            radii = np.random.uniform(0.02, 0.08, n_circles)\n        \n        configs.append((centers, radii))\n    \n    return configs[:n_configs]\n\ndef create_hexagonal_packing(n_circles: int, offset: float = 0.0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a hexagonal close-packing arrangement\n    \"\"\"\n    centers = []\n    \n    # Hexagonal packing parameters\n    rows = 6\n    cols = 6\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = (col + 0.5 + (row % 2) * 0.5) * dx + offset\n            y = (row + 0.5) * dy + offset\n            \n            # Keep within bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.06)\n    \n    return centers, radii\n\ndef create_grid_packing(n_circles: int, grid_size: int = 6) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a grid-based packing\n    \"\"\"\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.2\n    \n    centers = []\n    count = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count >= n_circles:\n                break\n            x = (i + 0.5) * spacing\n            y = (j + 0.5) * spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, radius)\n    \n    return centers, radii\n\ndef create_concentric_packing(n_circles: int, layers: int = 3) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create concentric circular arrangement\n    \"\"\"\n    centers = []\n    circles_per_layer = n_circles // layers\n    remainder = n_circles % layers\n    \n    for layer in range(layers):\n        n_in_layer = circles_per_layer + (1 if layer < remainder else 0)\n        radius_layer = 0.4 - layer * 0.12\n        \n        for i in range(n_in_layer):\n            angle = 2 * np.pi * i / n_in_layer\n            x = 0.5 + radius_layer * np.cos(angle)\n            y = 0.5 + radius_layer * np.sin(angle)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.05)\n    \n    return centers, radii\n\ndef generate_clustered_centers(n_circles: int, n_clusters: int = 4) -> np.ndarray:\n    \"\"\"\n    Generate clustered random centers\n    \"\"\"\n    centers = []\n    circles_per_cluster = n_circles // n_clusters\n    \n    cluster_centers = np.random.uniform(0.2, 0.8, (n_clusters, 2))\n    \n    for i in range(n_clusters):\n        n_in_cluster = circles_per_cluster + (1 if i < n_circles % n_clusters else 0)\n        cluster_points = cluster_centers[i] + np.random.normal(0, 0.1, (n_in_cluster, 2))\n        cluster_points = np.clip(cluster_points, 0.05, 0.95)\n        centers.extend(cluster_points)\n    \n    return np.array(centers[:n_circles])\n\ndef generate_repulsed_centers(n_circles: int, iterations: int = 50) -> np.ndarray:\n    \"\"\"\n    Generate centers with mutual repulsion for better initial spacing\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist > 0:\n                        # Repulsive force inversely proportional to distance\n                        force = diff / (dist ** 3 + 0.01)\n                        forces[i] += force\n        \n        # Update positions\n        centers += 0.01 * forces\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    return centers\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, method: str = 'SLSQP') -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Optimize a packing configuration using scipy.optimize\n    \"\"\"\n    n_circles = len(centers_init)\n    \n    # Pack parameters: [centers (flattened), radii]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        # Minimize negative sum of radii (maximize sum of radii)\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Constraint: circles inside unit square\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n        \n        # Constraint: no overlaps (distance >= sum of radii)\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Constraint: radii positive\n        for i in range(n_circles):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    # Bounds for variables\n    bounds = []\n    # Centers: [0, 1]\n    for i in range(2*n_circles):\n        bounds.append((0, 1))\n    # Radii: [0.001, 0.5]\n    for i in range(n_circles):\n        bounds.append((0.001, 0.5))\n    \n    # Constraints\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    # Optimize with increased iterations\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6}  # Increased from 500\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify solution\n            if verify_packing(centers_opt, radii_opt):\n                return centers_opt, radii_opt, sum_radii\n    except Exception as e:\n        print(f\"  Optimization failed with {method}: {e}\")\n    \n    return None\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-4) -> bool:\n    \"\"\"\n    Verify that a packing is valid\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check circles inside unit square\n    for i in range(n_circles):\n        if (centers[i, 0] - radii[i] < -tol or \n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or \n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check no overlaps\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    # Check positive radii\n    if np.any(radii < 0):\n        return False\n    \n    return True\n\ndef run_packing():\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nFinal Results:\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n\nOnly change:\n1. In generate_diverse_configurations, add 4 more concentric patterns with layers 6,7,8,9\n2. Increase maxiter in optimize_packing from 1000 to 1200\n\nReturn complete working code.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 30  # Increased from 15\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Generate diverse initial configurations\n    initial_configs = generate_initial_configurations(n_circles, n_trials)\n    \n    for trial, (centers, radii) in enumerate(initial_configs):\n        print(f\"Trial {trial + 1}/{n_trials}...\")\n        \n        # Try multiple optimization methods\n        for method in ['SLSQP', 'trust-constr']:\n            result = optimize_packing(centers.copy(), radii.copy(), method=method)\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                if sum_radii > best_sum_radii:\n                    best_sum_radii = sum_radii\n                    best_result = result\n                    print(f\"  New best with {method}: {sum_radii:.6f}\")\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\ndef generate_initial_configurations(n_circles: int, n_configs: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"\n    Generate diverse initial configurations including structured and random layouts\n    \"\"\"\n    configs = []\n    \n    # 1. Hexagonal packing variations (4 configs)\n    for i in range(4):\n        centers, radii = create_hexagonal_packing(n_circles, offset=i*0.1)\n        configs.append((centers, radii))\n    \n    # 2. Grid variations (4 configs)\n    for grid_size in [5, 6, 7, 8]:\n        centers, radii = create_grid_packing(n_circles, grid_size=grid_size)\n        configs.append((centers, radii))\n    \n    # 3. Concentric circles (6 configs - increased from 2)\n    for i in range(6):\n        centers, radii = create_concentric_packing(n_circles, layers=3+i)\n        configs.append((centers, radii))\n    \n    # 4. Random with varying densities (remaining configs)\n    remaining = n_configs - len(configs)\n    for i in range(remaining):\n        if i % 3 == 0:\n            # Clustered random\n            centers = generate_clustered_centers(n_circles)\n        elif i % 3 == 1:\n            # Uniform random\n            centers = np.random.rand(n_circles, 2)\n        else:\n            # Random with repulsion\n            centers = generate_repulsed_centers(n_circles)\n        \n        # Vary initial radii\n        if i % 2 == 0:\n            radii = np.full(n_circles, 0.05)\n        else:\n            radii = np.random.uniform(0.02, 0.08, n_circles)\n        \n        configs.append((centers, radii))\n    \n    return configs[:n_configs]\n\ndef create_hexagonal_packing(n_circles: int, offset: float = 0.0) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a hexagonal close-packing arrangement\n    \"\"\"\n    centers = []\n    \n    # Hexagonal packing parameters\n    rows = 6\n    cols = 6\n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = (col + 0.5 + (row % 2) * 0.5) * dx + offset\n            y = (row + 0.5) * dy + offset\n            \n            # Keep within bounds\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.06)\n    \n    return centers, radii\n\ndef create_grid_packing(n_circles: int, grid_size: int = 6) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a grid-based packing\n    \"\"\"\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.2\n    \n    centers = []\n    count = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count >= n_circles:\n                break\n            x = (i + 0.5) * spacing\n            y = (j + 0.5) * spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, radius)\n    \n    return centers, radii\n\ndef create_concentric_packing(n_circles: int, layers: int = 3) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create concentric circular arrangement\n    \"\"\"\n    centers = []\n    circles_per_layer = n_circles // layers\n    remainder = n_circles % layers\n    \n    for layer in range(layers):\n        n_in_layer = circles_per_layer + (1 if layer < remainder else 0)\n        radius_layer = 0.4 - layer * 0.12\n        \n        for i in range(n_in_layer):\n            angle = 2 * np.pi * i / n_in_layer\n            x = 0.5 + radius_layer * np.cos(angle)\n            y = 0.5 + radius_layer * np.sin(angle)\n            centers.append([x, y])\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, 0.05)\n    \n    return centers, radii\n\ndef generate_clustered_centers(n_circles: int, n_clusters: int = 4) -> np.ndarray:\n    \"\"\"\n    Generate clustered random centers\n    \"\"\"\n    centers = []\n    circles_per_cluster = n_circles // n_clusters\n    \n    cluster_centers = np.random.uniform(0.2, 0.8, (n_clusters, 2))\n    \n    for i in range(n_clusters):\n        n_in_cluster = circles_per_cluster + (1 if i < n_circles % n_clusters else 0)\n        cluster_points = cluster_centers[i] + np.random.normal(0, 0.1, (n_in_cluster, 2))\n        cluster_points = np.clip(cluster_points, 0.05, 0.95)\n        centers.extend(cluster_points)\n    \n    return np.array(centers[:n_circles])\n\ndef generate_repulsed_centers(n_circles: int, iterations: int = 50) -> np.ndarray:\n    \"\"\"\n    Generate centers with mutual repulsion for better initial spacing\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    \n    for _ in range(iterations):\n        forces = np.zeros_like(centers)\n        \n        for i in range(n_circles):\n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist > 0:\n                        # Repulsive force inversely proportional to distance\n                        force = diff / (dist ** 3 + 0.01)\n                        forces[i] += force\n        \n        # Update positions\n        centers += 0.01 * forces\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    return centers\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray, method: str = 'SLSQP') -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Optimize a packing configuration using scipy.optimize\n    \"\"\"\n    n_circles = len(centers_init)\n    \n    # Pack parameters: [centers (flattened), radii]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        # Minimize negative sum of radii (maximize sum of radii)\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Constraint: circles inside unit square\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n        \n        # Constraint: no overlaps (distance >= sum of radii)\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Constraint: radii positive\n        for i in range(n_circles):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    # Bounds for variables\n    bounds = []\n    # Centers: [0, 1]\n    for i in range(2*n_circles):\n        bounds.append((0, 1))\n    # Radii: [0.001, 0.5]\n    for i in range(n_circles):\n        bounds.append((0.001, 0.5))\n    \n    # Constraints\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    # Optimize with increased iterations\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method=method,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1200, 'ftol': 1e-6}  # Increased from 1000\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify solution\n            if verify_packing(centers_opt, radii_opt):\n                return centers_opt, radii_opt, sum_radii\n    except Exception as e:\n        print(f\"  Optimization failed with {method}: {e}\")\n    \n    return None\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-4) -> bool:\n    \"\"\"\n    Verify that a packing is valid\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check circles inside unit square\n    for i in range(n_circles):\n        if (centers[i, 0] - radii[i] < -tol or \n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or \n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check no overlaps\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    # Check positive radii\n    if np.any(radii < 0):\n        return False\n    \n    return True\n\ndef run_packing():\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nFinal Results:\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T13:05:39.400186",
  "cost_data": null
}