{
  "trial_id": "trial_1_9",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\n\ndef construct_packing(n_circles=26, penalty_weights=None, n_restarts=5, verbose=True):\n    \"\"\"\n    Construct circle packing using penalty method optimization.\n    \n    Args:\n        n_circles: Number of circles to pack\n        penalty_weights: List of penalty weights to use (increasing)\n        n_restarts: Number of random initializations to try\n        verbose: Whether to print progress\n    \n    Returns:\n        best_x: Best solution found (x1, y1, r1, x2, y2, r2, ...)\n        best_obj: Best objective value\n        history: Optimization history\n    \"\"\"\n    if penalty_weights is None:\n        penalty_weights = [1.0, 10.0, 100.0, 1000.0, 10000.0]\n    \n    def objective(params, penalty_weight):\n        \"\"\"\n        Objective: maximize sum of radii - penalty * violations\n        We minimize the negative of this.\n        \"\"\"\n        n = len(params) // 3\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        # Maximize sum of radii (minimize negative)\n        total_radius = np.sum(r)\n        \n        # Boundary violations\n        boundary_violations = 0.0\n        for i in range(n):\n            # Distance from boundaries\n            boundary_violations += np.maximum(0, r[i] - x[i])**2  # left\n            boundary_violations += np.maximum(0, r[i] - y[i])**2  # bottom\n            boundary_violations += np.maximum(0, x[i] + r[i] - 1.0)**2  # right\n            boundary_violations += np.maximum(0, y[i] + r[i] - 1.0)**2  # top\n        \n        # Overlap violations\n        overlap_violations = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                dist = np.sqrt(dx**2 + dy**2)\n                min_dist = r[i] + r[j]\n                if dist < min_dist:\n                    overlap_violations += (min_dist - dist)**2\n        \n        # Total penalty\n        total_penalty = penalty_weight * (boundary_violations + overlap_violations)\n        \n        # Minimize negative radius sum plus penalty\n        return -total_radius + total_penalty\n    \n    def gradient(params, penalty_weight):\n        \"\"\"Compute gradient of objective function.\"\"\"\n        n = len(params) // 3\n        grad = np.zeros_like(params)\n        \n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        # Gradient of -sum(r)\n        grad[2::3] = -1.0\n        \n        # Gradient of boundary violations\n        for i in range(n):\n            # Left boundary: r[i] - x[i] > 0\n            if r[i] > x[i]:\n                violation = r[i] - x[i]\n                grad[3*i] += penalty_weight * 2 * violation * (-1)  # d/dx\n                grad[3*i + 2] += penalty_weight * 2 * violation  # d/dr\n            \n            # Bottom boundary: r[i] - y[i] > 0\n            if r[i] > y[i]:\n                violation = r[i] - y[i]\n                grad[3*i + 1] += penalty_weight * 2 * violation * (-1)  # d/dy\n                grad[3*i + 2] += penalty_weight * 2 * violation  # d/dr\n            \n            # Right boundary: x[i] + r[i] - 1 > 0\n            if x[i] + r[i] > 1.0:\n                violation = x[i] + r[i] - 1.0\n                grad[3*i] += penalty_weight * 2 * violation  # d/dx\n                grad[3*i + 2] += penalty_weight * 2 * violation  # d/dr\n            \n            # Top boundary: y[i] + r[i] - 1 > 0\n            if y[i] + r[i] > 1.0:\n                violation = y[i] + r[i] - 1.0\n                grad[3*i + 1] += penalty_weight * 2 * violation  # d/dy\n                grad[3*i + 2] += penalty_weight * 2 * violation  # d/dr\n        \n        # Gradient of overlap violations\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                dist = np.sqrt(dx**2 + dy**2 + 1e-10)\n                min_dist = r[i] + r[j]\n                \n                if dist < min_dist:\n                    violation = min_dist - dist\n                    factor = penalty_weight * 2 * violation\n                    \n                    # Gradient w.r.t. positions\n                    grad[3*i] += factor * (-dx / dist)\n                    grad[3*i + 1] += factor * (-dy / dist)\n                    grad[3*j] += factor * (dx / dist)\n                    grad[3*j + 1] += factor * (dy / dist)\n                    \n                    # Gradient w.r.t. radii\n                    grad[3*i + 2] += factor\n                    grad[3*j + 2] += factor\n        \n        return grad\n    \n    # Bounds: positions in [0, 1], radii in [0.001, 0.5]\n    bounds = []\n    for i in range(n_circles):\n        bounds.extend([(0.0, 1.0), (0.0, 1.0), (0.001, 0.5)])\n    \n    best_solution = None\n    best_objective = float('inf')\n    history = []\n    \n    # Try multiple random initializations\n    for restart in range(n_restarts):\n        if verbose:\n            print(f\"\\n=== Restart {restart + 1}/{n_restarts} ===\")\n        \n        # Random initialization\n        x0 = np.random.rand(3 * n_circles)\n        x0[2::3] = np.random.uniform(0.02, 0.1, n_circles)  # Small initial radii\n        \n        # Gradually increase penalty weight\n        current_x = x0.copy()\n        \n        for pw_idx, penalty_weight in enumerate(penalty_weights):\n            if verbose:\n                print(f\"\\nPenalty weight: {penalty_weight}\")\n            \n            result = minimize(\n                fun=lambda p: objective(p, penalty_weight),\n                x0=current_x,\n                method='L-BFGS-B',\n                jac=lambda p: gradient(p, penalty_weight),\n                bounds=bounds,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            current_x = result.x\n            \n            # Compute actual metrics\n            x = current_x[0::3]\n            y = current_x[1::3]\n            r = current_x[2::3]\n            total_radius = np.sum(r)\n            \n            # Check violations\n            max_boundary_violation = 0.0\n            for i in range(n_circles):\n                max_boundary_violation = max(max_boundary_violation,\n                                            max(0, r[i] - x[i]),\n                                            max(0, r[i] - y[i]),\n                                            max(0, x[i] + r[i] - 1.0),\n                                            max(0, y[i] + r[i] - 1.0))\n            \n            max_overlap_violation = 0.0\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                    max_overlap_violation = max(max_overlap_violation,\n                                               max(0, r[i] + r[j] - dist))\n            \n            if verbose:\n                print(f\"  Total radius: {total_radius:.6f}\")\n                print(f\"  Max boundary violation: {max_boundary_violation:.6e}\")\n                print(f\"  Max overlap violation: {max_overlap_violation:.6e}\")\n            \n            history.append({\n                'restart': restart,\n                'penalty_weight': penalty_weight,\n                'total_radius': total_radius,\n                'max_boundary_violation': max_boundary_violation,\n                'max_overlap_violation': max_overlap_violation,\n                'solution': current_x.copy()\n            })\n        \n        # Evaluate final solution\n        final_obj = objective(current_x, penalty_weights[-1])\n        if final_obj < best_objective:\n            best_objective = final_obj\n            best_solution = current_x.copy()\n            if verbose:\n                print(f\"\\n*** New best solution found! Objective: {final_obj:.6f}\")\n    \n    return best_solution, best_objective, history\n\n\ndef run_packing(n_circles=26, penalty_weights=None, n_restarts=5, \n                plot=True, save_fig=None):\n    \"\"\"\n    Run the circle packing optimization and visualize results.\n    \n    Args:\n        n_circles: Number of circles to pack\n        penalty_weights: List of penalty weights\n        n_restarts: Number of random restarts\n        plot: Whether to create visualization\n        save_fig: Filename to save figure (optional)\n    \n    Returns:\n        Dictionary with results\n    \"\"\"\n    print(f\"Circle Packing Problem: {n_circles} circles in [0,1]x[0,1]\")\n    print(\"=\" * 60)\n    \n    # Run optimization\n    solution, objective, history = construct_packing(\n        n_circles=n_circles,\n        penalty_weights=penalty_weights,\n        n_restarts=n_restarts,\n        verbose=True\n    )\n    \n    # Extract solution\n    x = solution[0::3]\n    y = solution[1::3]\n    r = solution[2::3]\n    \n    # Compute final statistics\n    total_radius = np.sum(r)\n    total_area = np.sum(np.pi * r**2)\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"FINAL RESULTS\")\n    print(\"=\" * 60)\n    print(f\"Total radius sum: {total_radius:.6f}\")\n    print(f\"Total area: {total_area:.6f}\")\n    print(f\"Average radius: {np.mean(r):.6f}\")\n    print(f\"Min radius: {np.min(r):.6f}\")\n    print(f\"Max radius: {np.max(r):.6f}\")\n    \n    # Verify constraints\n    print(\"\\nConstraint Verification:\")\n    boundary_ok = True\n    for i in range(n_circles):\n        if r[i] > x[i] or r[i] > y[i] or x[i] + r[i] > 1.0 or y[i] + r[i] > 1.0:\n            boundary_ok = False\n            print(f\"  Circle {i}: BOUNDARY VIOLATION\")\n    \n    overlap_ok = True\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n            if dist < r[i] + r[j] - 1e-6:\n                overlap_ok = False\n                print(f\"  Circles {i} and {j}: OVERLAP (gap: {dist - r[i] - r[j]:.6e})\")\n    \n    if boundary_ok:\n        print(\"  \u2713 All circles within boundaries\")\n    if overlap_ok:\n        print(\"  \u2713 No overlaps detected\")\n    \n    # Visualization\n    if plot:\n        fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n        \n        # Plot 1: Final packing\n        ax = axes[0]\n        ax.set_xlim(-0.05, 1.05)\n        ax.set_ylim(-0.05, 1.05)\n        ax.set_aspect('equal')\n        ax.set_title(f'Circle Packing: {n_circles} circles\\nTotal radius: {total_radius:.4f}', \n                     fontsize=12, fontweight='bold')\n        ax.set_xlabel('x')\n        ax.set_ylabel('y')\n        \n        # Draw boundary\n        ax.plot([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], 'k-', linewidth=2)\n        \n        # Draw circles\n        colors = plt.cm.viridis(np.linspace(0, 1, n_circles))\n        for i in range(n_circles):\n            circle = Circle((x[i], y[i]), r[i], color=colors[i], alpha=0.6, \n                          edgecolor='black', linewidth=1)\n            ax.add_patch(circle)\n        \n        ax.grid(True, alpha=0.3)\n        \n        # Plot 2: Convergence history\n        ax = axes[1]\n        \n        # Extract best result at each penalty weight\n        penalty_vals = sorted(set(h['penalty_weight'] for h in history))\n        best_radius_per_penalty = []\n        \n        for pw in penalty_vals:\n            matching = [h for h in history if h['penalty_weight'] == pw]\n            best = max(matching, key=lambda h: h['total_radius'])\n            best_radius_per_penalty.append(best['total_radius'])\n        \n        ax.plot(range(len(penalty_vals)), best_radius_per_penalty, 'bo-', \n                linewidth=2, markersize=8)\n        ax.set_xlabel('Penalty Stage', fontsize=11)\n        ax.set_ylabel('Total Radius Sum', fontsize=11)\n        ax.set_title('Convergence History\\n(Best across restarts)', \n                     fontsize=12, fontweight='bold')\n        ax.grid(True, alpha=0.3)\n        \n        # Add penalty weight labels\n        ax2 = ax.twiny()\n        ax2.set_xlim(ax.get_xlim())\n        ax2.set_xticks(range(len(penalty_vals)))\n        ax2.set_xticklabels([f'{pw:.0f}' for pw in penalty_vals], rotation=45)\n        ax2.set_xlabel('Penalty Weight', fontsize=10)\n        \n        plt.tight_layout()\n        \n        if save_fig:\n            plt.savefig(save_fig, dpi=300, bbox_inches='tight')\n            print(f\"\\nFigure saved to {save_fig}\")\n        \n        plt.show()\n    \n    return {\n        'solution': solution,\n        'x': x,\n        'y': y,\n        'r': r,\n        'total_radius': total_radius,\n        'total_area': total_area,\n        'history': history,\n        'boundary_ok': boundary_ok,\n        'overlap_ok': overlap_ok\n    }\n\n\nif __name__ == \"__main__\":\n    # Run with default parameters\n    results = run_packing(\n        n_circles=26,\n        penalty_weights=[1.0, 10.0, 100.0, 1000.0, 10000.0],\n        n_restarts=5,\n        plot=True,\n        save_fig='circle_packing_26.png'\n    )",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 431.3752691745758,
    "error": "Timeout after 300s"
  },
  "prompt": "Write a penalty method optimization for 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Formulate as unconstrained optimization with penalty terms:\n   - Objective: sum_radii - penalty_weight * (boundary_violations + overlap_violations)\n2. Start with low penalty weight and gradually increase\n3. Use L-BFGS-B optimizer (unconstrained, handles bounds)\n4. After each penalty increase, warm-start from previous solution\n5. Use multiple random initializations\n\nThe penalty method can be more robust than constrained optimization.\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\n\ndef construct_packing(n_circles=26, penalty_weights=None, n_restarts=5, verbose=True):\n    \"\"\"\n    Construct circle packing using penalty method optimization.\n    \n    Args:\n        n_circles: Number of circles to pack\n        penalty_weights: List of penalty weights to use (increasing)\n        n_restarts: Number of random initializations to try\n        verbose: Whether to print progress\n    \n    Returns:\n        best_x: Best solution found (x1, y1, r1, x2, y2, r2, ...)\n        best_obj: Best objective value\n        history: Optimization history\n    \"\"\"\n    if penalty_weights is None:\n        penalty_weights = [1.0, 10.0, 100.0, 1000.0, 10000.0]\n    \n    def objective(params, penalty_weight):\n        \"\"\"\n        Objective: maximize sum of radii - penalty * violations\n        We minimize the negative of this.\n        \"\"\"\n        n = len(params) // 3\n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        # Maximize sum of radii (minimize negative)\n        total_radius = np.sum(r)\n        \n        # Boundary violations\n        boundary_violations = 0.0\n        for i in range(n):\n            # Distance from boundaries\n            boundary_violations += np.maximum(0, r[i] - x[i])**2  # left\n            boundary_violations += np.maximum(0, r[i] - y[i])**2  # bottom\n            boundary_violations += np.maximum(0, x[i] + r[i] - 1.0)**2  # right\n            boundary_violations += np.maximum(0, y[i] + r[i] - 1.0)**2  # top\n        \n        # Overlap violations\n        overlap_violations = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                dist = np.sqrt(dx**2 + dy**2)\n                min_dist = r[i] + r[j]\n                if dist < min_dist:\n                    overlap_violations += (min_dist - dist)**2\n        \n        # Total penalty\n        total_penalty = penalty_weight * (boundary_violations + overlap_violations)\n        \n        # Minimize negative radius sum plus penalty\n        return -total_radius + total_penalty\n    \n    def gradient(params, penalty_weight):\n        \"\"\"Compute gradient of objective function.\"\"\"\n        n = len(params) // 3\n        grad = np.zeros_like(params)\n        \n        x = params[0::3]\n        y = params[1::3]\n        r = params[2::3]\n        \n        # Gradient of -sum(r)\n        grad[2::3] = -1.0\n        \n        # Gradient of boundary violations\n        for i in range(n):\n            # Left boundary: r[i] - x[i] > 0\n            if r[i] > x[i]:\n                violation = r[i] - x[i]\n                grad[3*i] += penalty_weight * 2 * violation * (-1)  # d/dx\n                grad[3*i + 2] += penalty_weight * 2 * violation  # d/dr\n            \n            # Bottom boundary: r[i] - y[i] > 0\n            if r[i] > y[i]:\n                violation = r[i] - y[i]\n                grad[3*i + 1] += penalty_weight * 2 * violation * (-1)  # d/dy\n                grad[3*i + 2] += penalty_weight * 2 * violation  # d/dr\n            \n            # Right boundary: x[i] + r[i] - 1 > 0\n            if x[i] + r[i] > 1.0:\n                violation = x[i] + r[i] - 1.0\n                grad[3*i] += penalty_weight * 2 * violation  # d/dx\n                grad[3*i + 2] += penalty_weight * 2 * violation  # d/dr\n            \n            # Top boundary: y[i] + r[i] - 1 > 0\n            if y[i] + r[i] > 1.0:\n                violation = y[i] + r[i] - 1.0\n                grad[3*i + 1] += penalty_weight * 2 * violation  # d/dy\n                grad[3*i + 2] += penalty_weight * 2 * violation  # d/dr\n        \n        # Gradient of overlap violations\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                dist = np.sqrt(dx**2 + dy**2 + 1e-10)\n                min_dist = r[i] + r[j]\n                \n                if dist < min_dist:\n                    violation = min_dist - dist\n                    factor = penalty_weight * 2 * violation\n                    \n                    # Gradient w.r.t. positions\n                    grad[3*i] += factor * (-dx / dist)\n                    grad[3*i + 1] += factor * (-dy / dist)\n                    grad[3*j] += factor * (dx / dist)\n                    grad[3*j + 1] += factor * (dy / dist)\n                    \n                    # Gradient w.r.t. radii\n                    grad[3*i + 2] += factor\n                    grad[3*j + 2] += factor\n        \n        return grad\n    \n    # Bounds: positions in [0, 1], radii in [0.001, 0.5]\n    bounds = []\n    for i in range(n_circles):\n        bounds.extend([(0.0, 1.0), (0.0, 1.0), (0.001, 0.5)])\n    \n    best_solution = None\n    best_objective = float('inf')\n    history = []\n    \n    # Try multiple random initializations\n    for restart in range(n_restarts):\n        if verbose:\n            print(f\"\\n=== Restart {restart + 1}/{n_restarts} ===\")\n        \n        # Random initialization\n        x0 = np.random.rand(3 * n_circles)\n        x0[2::3] = np.random.uniform(0.02, 0.1, n_circles)  # Small initial radii\n        \n        # Gradually increase penalty weight\n        current_x = x0.copy()\n        \n        for pw_idx, penalty_weight in enumerate(penalty_weights):\n            if verbose:\n                print(f\"\\nPenalty weight: {penalty_weight}\")\n            \n            result = minimize(\n                fun=lambda p: objective(p, penalty_weight),\n                x0=current_x,\n                method='L-BFGS-B',\n                jac=lambda p: gradient(p, penalty_weight),\n                bounds=bounds,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            current_x = result.x\n            \n            # Compute actual metrics\n            x = current_x[0::3]\n            y = current_x[1::3]\n            r = current_x[2::3]\n            total_radius = np.sum(r)\n            \n            # Check violations\n            max_boundary_violation = 0.0\n            for i in range(n_circles):\n                max_boundary_violation = max(max_boundary_violation,\n                                            max(0, r[i] - x[i]),\n                                            max(0, r[i] - y[i]),\n                                            max(0, x[i] + r[i] - 1.0),\n                                            max(0, y[i] + r[i] - 1.0))\n            \n            max_overlap_violation = 0.0\n            for i in range(n_circles):\n                for j in range(i + 1, n_circles):\n                    dist = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n                    max_overlap_violation = max(max_overlap_violation,\n                                               max(0, r[i] + r[j] - dist))\n            \n            if verbose:\n                print(f\"  Total radius: {total_radius:.6f}\")\n                print(f\"  Max boundary violation: {max_boundary_violation:.6e}\")\n                print(f\"  Max overlap violation: {max_overlap_violation:.6e}\")\n            \n            history.append({\n                'restart': restart,\n                'penalty_weight': penalty_weight,\n                'total_radius': total_radius,\n                'max_boundary_violation': max_boundary_violation,\n                'max_overlap_violation': max_overlap_violation,\n                'solution': current_x.copy()\n            })\n        \n        # Evaluate final solution\n        final_obj = objective(current_x, penalty_weights[-1])\n        if final_obj < best_objective:\n            best_objective = final_obj\n            best_solution = current_x.copy()\n            if verbose:\n                print(f\"\\n*** New best solution found! Objective: {final_obj:.6f}\")\n    \n    return best_solution, best_objective, history\n\n\ndef run_packing(n_circles=26, penalty_weights=None, n_restarts=5, \n                plot=True, save_fig=None):\n    \"\"\"\n    Run the circle packing optimization and visualize results.\n    \n    Args:\n        n_circles: Number of circles to pack\n        penalty_weights: List of penalty weights\n        n_restarts: Number of random restarts\n        plot: Whether to create visualization\n        save_fig: Filename to save figure (optional)\n    \n    Returns:\n        Dictionary with results\n    \"\"\"\n    print(f\"Circle Packing Problem: {n_circles} circles in [0,1]x[0,1]\")\n    print(\"=\" * 60)\n    \n    # Run optimization\n    solution, objective, history = construct_packing(\n        n_circles=n_circles,\n        penalty_weights=penalty_weights,\n        n_restarts=n_restarts,\n        verbose=True\n    )\n    \n    # Extract solution\n    x = solution[0::3]\n    y = solution[1::3]\n    r = solution[2::3]\n    \n    # Compute final statistics\n    total_radius = np.sum(r)\n    total_area = np.sum(np.pi * r**2)\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"FINAL RESULTS\")\n    print(\"=\" * 60)\n    print(f\"Total radius sum: {total_radius:.6f}\")\n    print(f\"Total area: {total_area:.6f}\")\n    print(f\"Average radius: {np.mean(r):.6f}\")\n    print(f\"Min radius: {np.min(r):.6f}\")\n    print(f\"Max radius: {np.max(r):.6f}\")\n    \n    # Verify constraints\n    print(\"\\nConstraint Verification:\")\n    boundary_ok = True\n    for i in range(n_circles):\n        if r[i] > x[i] or r[i] > y[i] or x[i] + r[i] > 1.0 or y[i] + r[i] > 1.0:\n            boundary_ok = False\n            print(f\"  Circle {i}: BOUNDARY VIOLATION\")\n    \n    overlap_ok = True\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n            if dist < r[i] + r[j] - 1e-6:\n                overlap_ok = False\n                print(f\"  Circles {i} and {j}: OVERLAP (gap: {dist - r[i] - r[j]:.6e})\")\n    \n    if boundary_ok:\n        print(\"  \u2713 All circles within boundaries\")\n    if overlap_ok:\n        print(\"  \u2713 No overlaps detected\")\n    \n    # Visualization\n    if plot:\n        fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n        \n        # Plot 1: Final packing\n        ax = axes[0]\n        ax.set_xlim(-0.05, 1.05)\n        ax.set_ylim(-0.05, 1.05)\n        ax.set_aspect('equal')\n        ax.set_title(f'Circle Packing: {n_circles} circles\\nTotal radius: {total_radius:.4f}', \n                     fontsize=12, fontweight='bold')\n        ax.set_xlabel('x')\n        ax.set_ylabel('y')\n        \n        # Draw boundary\n        ax.plot([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], 'k-', linewidth=2)\n        \n        # Draw circles\n        colors = plt.cm.viridis(np.linspace(0, 1, n_circles))\n        for i in range(n_circles):\n            circle = Circle((x[i], y[i]), r[i], color=colors[i], alpha=0.6, \n                          edgecolor='black', linewidth=1)\n            ax.add_patch(circle)\n        \n        ax.grid(True, alpha=0.3)\n        \n        # Plot 2: Convergence history\n        ax = axes[1]\n        \n        # Extract best result at each penalty weight\n        penalty_vals = sorted(set(h['penalty_weight'] for h in history))\n        best_radius_per_penalty = []\n        \n        for pw in penalty_vals:\n            matching = [h for h in history if h['penalty_weight'] == pw]\n            best = max(matching, key=lambda h: h['total_radius'])\n            best_radius_per_penalty.append(best['total_radius'])\n        \n        ax.plot(range(len(penalty_vals)), best_radius_per_penalty, 'bo-', \n                linewidth=2, markersize=8)\n        ax.set_xlabel('Penalty Stage', fontsize=11)\n        ax.set_ylabel('Total Radius Sum', fontsize=11)\n        ax.set_title('Convergence History\\n(Best across restarts)', \n                     fontsize=12, fontweight='bold')\n        ax.grid(True, alpha=0.3)\n        \n        # Add penalty weight labels\n        ax2 = ax.twiny()\n        ax2.set_xlim(ax.get_xlim())\n        ax2.set_xticks(range(len(penalty_vals)))\n        ax2.set_xticklabels([f'{pw:.0f}' for pw in penalty_vals], rotation=45)\n        ax2.set_xlabel('Penalty Weight', fontsize=10)\n        \n        plt.tight_layout()\n        \n        if save_fig:\n            plt.savefig(save_fig, dpi=300, bbox_inches='tight')\n            print(f\"\\nFigure saved to {save_fig}\")\n        \n        plt.show()\n    \n    return {\n        'solution': solution,\n        'x': x,\n        'y': y,\n        'r': r,\n        'total_radius': total_radius,\n        'total_area': total_area,\n        'history': history,\n        'boundary_ok': boundary_ok,\n        'overlap_ok': overlap_ok\n    }\n\n\nif __name__ == \"__main__\":\n    # Run with default parameters\n    results = run_packing(\n        n_circles=26,\n        penalty_weights=[1.0, 10.0, 100.0, 1000.0, 10000.0],\n        n_restarts=5,\n        plot=True,\n        save_fig='circle_packing_26.png'\n    )\n```\n\nThis implementation provides:\n\n1. **Penalty Metho",
  "reasoning": "This implementation provides:\n\n1. **Penalty Metho",
  "timestamp": "2025-12-08T12:38:35.502793",
  "cost_data": null
}