{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": "trial_0_4",
  "code": "",
  "metrics": {},
  "prompt": "Improve this random search with local optimization approach:\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 15\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    for trial in range(n_trials):\n        # Generate random initial configuration\n        centers = np.random.rand(n_circles, 2)\n        \n        # Initial guess for radii (small values)\n        radii = np.full(n_circles, 0.05)\n        \n        # Optimize\n        result = optimize_packing(centers, radii)\n        \n        if result is not None:\n            centers_opt, radii_opt, sum_radii = result\n            if sum_radii > best_sum_radii:\n                best_sum_radii = sum_radii\n                best_result = result\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\ndef optimize_packing(centers_init: np.ndarray, radii_init: np.ndarray) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Optimize a packing configuration using scipy.optimize\n    \"\"\"\n    n_circles = len(centers_init)\n    \n    # Pack parameters: [centers (flattened), radii]\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        # Minimize negative sum of radii (maximize sum of radii)\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Constraint: circles inside unit square\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])  # x - r >= 0\n            constraints.append(1 - centers[i, 0] - radii[i])  # 1 - x - r >= 0\n            constraints.append(centers[i, 1] - radii[i])  # y - r >= 0\n            constraints.append(1 - centers[i, 1] - radii[i])  # 1 - y - r >= 0\n        \n        # Constraint: no overlaps (distance >= sum of radii)\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Constraint: radii positive\n        for i in range(n_circles):\n            constraints.append(radii[i])\n        \n        return np.array(constraints)\n    \n    # Bounds for variables\n    bounds = []\n    # Centers: [0, 1]\n    for i in range(2*n_circles):\n        bounds.append((0, 1))\n    # Radii: [0.001, 0.5]\n    for i in range(n_circles):\n        bounds.append((0.001, 0.5))\n    \n    # Constraints\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    # Optimize\n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 500, 'ftol': 1e-6}\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            sum_radii = np.sum(radii_opt)\n            \n            # Verify solution\n            if verify_packing(centers_opt, radii_opt):\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tol: float = 1e-4) -> bool:\n    \"\"\"\n    Verify that a packing is valid\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check circles inside unit square\n    for i in range(n_circles):\n        if (centers[i, 0] - radii[i] < -tol or \n            centers[i, 0] + radii[i] > 1 + tol or\n            centers[i, 1] - radii[i] < -tol or \n            centers[i, 1] + radii[i] > 1 + tol):\n            return False\n    \n    # Check no overlaps\n    for i in range(n_circles):\n        for j in range(i+1, n_circles):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            if dist < radii[i] + radii[j] - tol:\n                return False\n    \n    # Check positive radii\n    if np.any(radii < 0):\n        return False\n    \n    return True\n\ndef create_grid_packing(n_circles: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Create a simple grid-based packing as fallback\n    \"\"\"\n    # Create a 6x5 grid (30 positions, use 26)\n    grid_size = 6\n    spacing = 1.0 / grid_size\n    radius = spacing / 2.2  # Leave some margin\n    \n    centers = []\n    count = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if count >= n_circles:\n                break\n            x = (i + 0.5) * spacing\n            y = (j + 0.5) * spacing\n            centers.append([x, y])\n            count += 1\n        if count >= n_circles:\n            break\n    \n    centers = np.array(centers[:n_circles])\n    radii = np.full(n_circles, radius)\n    \n    return centers, radii\n\ndef run_packing():\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Valid packing: {verify_packing(centers, radii)}\")\n\nMake these improvements:\n1. Use smarter initial configurations based on known good patterns (hexagonal, Fibonacci spiral)\n2. Add a two-stage optimization: first optimize positions with fixed radii, then optimize both\n3. Implement constraint violation repair mechanism\n4. Add local perturbation search after scipy optimization\n\nFocus on finding better local optima through staged optimization.",
  "response": "Here's an improved version with smarter initialization, staged optimization, constraint repair, and local perturbation search:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom typing import Tuple, Optional\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 20\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Try different initialization strategies\n    init_strategies = [\n        ('hexagonal', 6),\n        ('fibonacci', 5),\n        ('sunflower', 5),\n        ('random_optimized', 4)\n    ]\n    \n    trial_count = 0\n    for strategy_name, n_attempts in init_strategies:\n        for attempt in range(n_attempts):\n            if trial_count >= n_trials:\n                break\n            \n            # Generate initial configuration\n            if strategy_name == 'hexagonal':\n                centers = create_hexagonal_pattern(n_circles, attempt)\n            elif strategy_name == 'fibonacci':\n                centers = create_fibonacci_spiral(n_circles, attempt)\n            elif strategy_name == 'sunflower':\n                centers = create_sunflower_pattern(n_circles, attempt)\n            else:\n                centers = np.random.rand(n_circles, 2)\n            \n            # Staged optimization\n            result = staged_optimize_packing(centers, n_circles)\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                \n                # Apply local perturbation search\n                result_perturbed = local_perturbation_search(\n                    centers_opt, radii_opt, n_iterations=30\n                )\n                \n                if result_perturbed is not None:\n                    centers_opt, radii_opt, sum_radii = result_perturbed\n                \n                if sum_radii > best_sum_radii:\n                    best_sum_radii = sum_radii\n                    best_result = (centers_opt, radii_opt, sum_radii)\n                    print(f\"Trial {trial_count}: {strategy_name} - Sum radii: {sum_radii:.6f}\")\n            \n            trial_count += 1\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\ndef create_hexagonal_pattern(n_circles: int, seed: int = 0) -> np.ndarray:\n    \"\"\"Create hexagonal packing pattern with some randomization\"\"\"\n    np.random.seed(seed)\n    centers = []\n    \n    # Hexagonal grid parameters\n    rows = int(np.ceil(np.sqrt(n_circles * 2/np.sqrt(3))))\n    cols = int(np.ceil(n_circles / rows)) + 1\n    \n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = (col + 0.5 + (row % 2) * 0.5) * dx\n            y = (row + 0.5) * dy\n            \n            # Add small random perturbation\n            x += np.random.normal(0, dx * 0.1)\n            y += np.random.normal(0, dy * 0.1)\n            \n            # Clip to valid range\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    return np.array(centers[:n_circles])\n\ndef create_fibonacci_spiral(n_circles: int, seed: int = 0) -> np.ndarray:\n    \"\"\"Create Fibonacci spiral pattern\"\"\"\n    np.random.seed(seed)\n    centers = []\n    \n    golden_angle = np.pi * (3 - np.sqrt(5))\n    \n    for i in range(n_circles):\n        theta = i * golden_angle + np.random.normal(0, 0.1)\n        r = np.sqrt(i / n_circles) * 0.45 + 0.05\n        \n        x = 0.5 + r * np.cos(theta)\n        y = 0.5 + r * np.sin(theta)\n        \n        x = np.clip(x, 0.05, 0.95)\n        y = np.clip(y, 0.05, 0.95)\n        \n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef create_sunflower_pattern(n_circles: int, seed: int = 0) -> np.ndarray:\n    \"\"\"Create sunflower seed pattern\"\"\"\n    np.random.seed(seed)\n    centers = []\n    \n    golden_angle = np.pi * (3 - np.sqrt(5))\n    \n    for i in range(n_circles):\n        theta = i * golden_angle\n        r = np.sqrt((i + 0.5) / (n_circles + 1)) * 0.45\n        \n        x = 0.5 + r * np.cos(theta)\n        y = 0.5 + r * np.sin(theta)\n        \n        # Add noise\n        x += np.random.normal(0, 0.02)\n        y += np.random.normal(0, 0.02)\n        \n        x = np.clip(x, 0.05, 0.95)\n        y = np.clip(y, 0.05, 0.95)\n        \n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef staged_optimize_packing(centers_init: np.ndarray, n_circles: int) -> Optional[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Two-stage optimization:\n    1. Optimize positions with fixed radii\n    2. Optimize both positions and radii\n    \"\"\"\n    \n    # Stage 1: Optimize positions with fixed small radii\n    radii_fixed = estimate_initial_radii(centers_init)\n    centers_stage1 = optimize_positions_only(centers_init, radii_fixed)\n    \n    if centers_stage1 is None:\n        centers_stage1 = centers_init\n    \n    # Repair any constraint violations\n    centers_stage1, radii_fixed = repair_configuration(centers_stage1, radii_fixed)\n    \n    # Stage 2: Optimize both positions and radii\n    result = optimize_full_packing(centers_stage1, radii_fixed)\n    \n    return result\n\ndef estimate_initial_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Estimate reasonable initial radii based on nearest neighbor distances\"\"\"\n    n_circles = len(centers)\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Find distance to nearest neighbor\n        min_dist = float('inf')\n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = min(min_dist, dist)\n        \n        # Find distance to boundaries\n        boundary_dist = min(\n            centers[i, 0],\n            1 - centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 1]\n        )\n        \n        # Set radius to be conservative\n        radii[i] = min(min_dist / 2.5, boundary_dist * 0.8, 0.1)\n    \n    return radii\n\ndef optimize_positions_only(centers_init: np.ndarray, radii: np.ndarray) -> Optional[np.ndarray]:\n    \"\"\"Optimize only circle positions with fixed radii\"\"\"\n    n_circles = len(centers_init)\n    x0 = centers_init.flatten()\n    \n    def objective(x):\n        # Minimize overlap and boundary violations\n        centers = x.reshape(n_circles, 2)\n        penalty = 0\n        \n        # Penalize overlaps\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required_dist = radii[i] + radii[j]\n                if dist < required_dist:\n                    penalty += (required_dist - dist) ** 2\n        \n        # Penalize boundary violations\n        for i in range(n_circles):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 0]) ** 2\n            if centers[i, 0] + radii[i] > 1:\n                penalty += (centers[i, 0] + radii[i] - 1) ** 2\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 1]) ** 2\n            if centers[i, 1] + radii[i] > 1:\n                penalty += (centers[i, 1] + radii[i] - 1) ** 2\n        \n        return penalty\n    \n    bounds = [(0, 1)] * (2 * n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 300}\n        )\n        \n        if result.fun < 0.01:  # Low penalty means good configuration\n            return result.x.reshape(n_circles, 2)\n    except:\n        pass\n    \n    return None\n\ndef repair_configuration(centers: np.ndarray, radii: np.ndarray, max_iterations: int = 50) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Repair constraint violations by adjusting positions and radii\"\"\"\n    n_circles = len(centers)\n    centers = centers.copy()\n    radii = radii.copy()\n    \n    for iteration in range(max_iterations):\n        violations = 0\n        \n        # Fix boundary violations\n        for i in range(n_circles):\n            margin = 0.001\n            if centers[i, 0] - radii[i] < margin:\n                centers[i, 0] = radii[i] + margin\n            if centers[i, 0] + radii[i] > 1 - margin:\n                centers[i, 0] = 1 - radii[i] - margin\n            if centers[i, 1] - radii[i] < margin:\n                centers[i, 1] = radii[i] + margin\n            if centers[i, 1] + radii[i] > 1 - margin:\n                centers[i, 1] = 1 - radii[i] - margin\n        \n        # Fix overlaps\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required_dist = radii[i] + radii[j]\n                \n                if dist < required_dist - 1e-6:\n                    violations += 1\n                    # Push circles apart\n                    direction = centers[j] - centers[i]\n                    if np.linalg.norm(direction) > 1e-10:\n                        direction = direction / np.linalg.norm(direction)\n                        overlap = required_dist - dist\n                        centers[i] -= direction * overlap * 0.5\n                        centers[j] += direction * overlap * 0.5\n        \n        if violations == 0:\n            break\n    \n    return centers, radii\n\ndef optimize_full_packing(centers_init: np.ndarray, radii_init: np.ndarray) -> Optional[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"Optimize both positions and radii\"\"\"\n    n_circles = len(centers_init)\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Positive radii\n        for i in range(n_circles):\n            constraints.append(radii[i] - 0.001)\n        \n        return np.array(constraints)\n    \n    bounds = [(0, 1)] * (2*n_circles) + [(0.001, 0.5)] * n_circles\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 500, 'ftol': 1e-8}\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            \n            if verify_packing(centers_opt, radii_opt):\n                sum_radii = np.sum(radii_opt)\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef local_perturbation_search(centers: np.ndarray, radii: np.ndarray, \n                              n_iterations: int = 30) -> Optional[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"Apply local perturbation search to escape local optima\"\"\"\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    n_circles = len(centers)\n    \n    for iteration in range(n_iterations):\n        # Try different perturbation strategies\n        if iteration % 3 == 0:\n            # Small random perturbations\n            perturbed_centers = centers + np.random.normal(0, 0.02, centers.shape)\n            perturbed_radii = radii * (1 + np.random.normal(0, 0.05, radii.shape))\n        elif iteration % 3 == 1:\n            # Swap two circles\n            perturbed_centers = centers.copy()\n            i, j = np.random.choice(n_circles, 2, replace=False)\n            perturbed_centers[[i, j]] = perturbed_centers[[j, i]]\n            perturbed_radii = radii.copy()\n        else:\n            # Perturb a subset",
  "reasoning": "Here's an improved version with smarter initialization, staged optimization, constraint repair, and local perturbation search:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nfrom typing import Tuple, Optional\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    n_trials = 20\n    \n    best_result = None\n    best_sum_radii = 0\n    \n    # Try different initialization strategies\n    init_strategies = [\n        ('hexagonal', 6),\n        ('fibonacci', 5),\n        ('sunflower', 5),\n        ('random_optimized', 4)\n    ]\n    \n    trial_count = 0\n    for strategy_name, n_attempts in init_strategies:\n        for attempt in range(n_attempts):\n            if trial_count >= n_trials:\n                break\n            \n            # Generate initial configuration\n            if strategy_name == 'hexagonal':\n                centers = create_hexagonal_pattern(n_circles, attempt)\n            elif strategy_name == 'fibonacci':\n                centers = create_fibonacci_spiral(n_circles, attempt)\n            elif strategy_name == 'sunflower':\n                centers = create_sunflower_pattern(n_circles, attempt)\n            else:\n                centers = np.random.rand(n_circles, 2)\n            \n            # Staged optimization\n            result = staged_optimize_packing(centers, n_circles)\n            \n            if result is not None:\n                centers_opt, radii_opt, sum_radii = result\n                \n                # Apply local perturbation search\n                result_perturbed = local_perturbation_search(\n                    centers_opt, radii_opt, n_iterations=30\n                )\n                \n                if result_perturbed is not None:\n                    centers_opt, radii_opt, sum_radii = result_perturbed\n                \n                if sum_radii > best_sum_radii:\n                    best_sum_radii = sum_radii\n                    best_result = (centers_opt, radii_opt, sum_radii)\n                    print(f\"Trial {trial_count}: {strategy_name} - Sum radii: {sum_radii:.6f}\")\n            \n            trial_count += 1\n    \n    if best_result is None:\n        # Fallback: return a simple grid configuration\n        centers, radii = create_grid_packing(n_circles)\n        sum_radii = np.sum(radii)\n        best_result = (centers, radii, sum_radii)\n    \n    return best_result\n\ndef create_hexagonal_pattern(n_circles: int, seed: int = 0) -> np.ndarray:\n    \"\"\"Create hexagonal packing pattern with some randomization\"\"\"\n    np.random.seed(seed)\n    centers = []\n    \n    # Hexagonal grid parameters\n    rows = int(np.ceil(np.sqrt(n_circles * 2/np.sqrt(3))))\n    cols = int(np.ceil(n_circles / rows)) + 1\n    \n    dx = 1.0 / (cols + 0.5)\n    dy = 1.0 / (rows + 0.5)\n    \n    count = 0\n    for row in range(rows):\n        for col in range(cols):\n            if count >= n_circles:\n                break\n            \n            x = (col + 0.5 + (row % 2) * 0.5) * dx\n            y = (row + 0.5) * dy\n            \n            # Add small random perturbation\n            x += np.random.normal(0, dx * 0.1)\n            y += np.random.normal(0, dy * 0.1)\n            \n            # Clip to valid range\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            \n            centers.append([x, y])\n            count += 1\n        \n        if count >= n_circles:\n            break\n    \n    return np.array(centers[:n_circles])\n\ndef create_fibonacci_spiral(n_circles: int, seed: int = 0) -> np.ndarray:\n    \"\"\"Create Fibonacci spiral pattern\"\"\"\n    np.random.seed(seed)\n    centers = []\n    \n    golden_angle = np.pi * (3 - np.sqrt(5))\n    \n    for i in range(n_circles):\n        theta = i * golden_angle + np.random.normal(0, 0.1)\n        r = np.sqrt(i / n_circles) * 0.45 + 0.05\n        \n        x = 0.5 + r * np.cos(theta)\n        y = 0.5 + r * np.sin(theta)\n        \n        x = np.clip(x, 0.05, 0.95)\n        y = np.clip(y, 0.05, 0.95)\n        \n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef create_sunflower_pattern(n_circles: int, seed: int = 0) -> np.ndarray:\n    \"\"\"Create sunflower seed pattern\"\"\"\n    np.random.seed(seed)\n    centers = []\n    \n    golden_angle = np.pi * (3 - np.sqrt(5))\n    \n    for i in range(n_circles):\n        theta = i * golden_angle\n        r = np.sqrt((i + 0.5) / (n_circles + 1)) * 0.45\n        \n        x = 0.5 + r * np.cos(theta)\n        y = 0.5 + r * np.sin(theta)\n        \n        # Add noise\n        x += np.random.normal(0, 0.02)\n        y += np.random.normal(0, 0.02)\n        \n        x = np.clip(x, 0.05, 0.95)\n        y = np.clip(y, 0.05, 0.95)\n        \n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef staged_optimize_packing(centers_init: np.ndarray, n_circles: int) -> Optional[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"\n    Two-stage optimization:\n    1. Optimize positions with fixed radii\n    2. Optimize both positions and radii\n    \"\"\"\n    \n    # Stage 1: Optimize positions with fixed small radii\n    radii_fixed = estimate_initial_radii(centers_init)\n    centers_stage1 = optimize_positions_only(centers_init, radii_fixed)\n    \n    if centers_stage1 is None:\n        centers_stage1 = centers_init\n    \n    # Repair any constraint violations\n    centers_stage1, radii_fixed = repair_configuration(centers_stage1, radii_fixed)\n    \n    # Stage 2: Optimize both positions and radii\n    result = optimize_full_packing(centers_stage1, radii_fixed)\n    \n    return result\n\ndef estimate_initial_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Estimate reasonable initial radii based on nearest neighbor distances\"\"\"\n    n_circles = len(centers)\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Find distance to nearest neighbor\n        min_dist = float('inf')\n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = min(min_dist, dist)\n        \n        # Find distance to boundaries\n        boundary_dist = min(\n            centers[i, 0],\n            1 - centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 1]\n        )\n        \n        # Set radius to be conservative\n        radii[i] = min(min_dist / 2.5, boundary_dist * 0.8, 0.1)\n    \n    return radii\n\ndef optimize_positions_only(centers_init: np.ndarray, radii: np.ndarray) -> Optional[np.ndarray]:\n    \"\"\"Optimize only circle positions with fixed radii\"\"\"\n    n_circles = len(centers_init)\n    x0 = centers_init.flatten()\n    \n    def objective(x):\n        # Minimize overlap and boundary violations\n        centers = x.reshape(n_circles, 2)\n        penalty = 0\n        \n        # Penalize overlaps\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required_dist = radii[i] + radii[j]\n                if dist < required_dist:\n                    penalty += (required_dist - dist) ** 2\n        \n        # Penalize boundary violations\n        for i in range(n_circles):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 0]) ** 2\n            if centers[i, 0] + radii[i] > 1:\n                penalty += (centers[i, 0] + radii[i] - 1) ** 2\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 1]) ** 2\n            if centers[i, 1] + radii[i] > 1:\n                penalty += (centers[i, 1] + radii[i] - 1) ** 2\n        \n        return penalty\n    \n    bounds = [(0, 1)] * (2 * n_circles)\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 300}\n        )\n        \n        if result.fun < 0.01:  # Low penalty means good configuration\n            return result.x.reshape(n_circles, 2)\n    except:\n        pass\n    \n    return None\n\ndef repair_configuration(centers: np.ndarray, radii: np.ndarray, max_iterations: int = 50) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Repair constraint violations by adjusting positions and radii\"\"\"\n    n_circles = len(centers)\n    centers = centers.copy()\n    radii = radii.copy()\n    \n    for iteration in range(max_iterations):\n        violations = 0\n        \n        # Fix boundary violations\n        for i in range(n_circles):\n            margin = 0.001\n            if centers[i, 0] - radii[i] < margin:\n                centers[i, 0] = radii[i] + margin\n            if centers[i, 0] + radii[i] > 1 - margin:\n                centers[i, 0] = 1 - radii[i] - margin\n            if centers[i, 1] - radii[i] < margin:\n                centers[i, 1] = radii[i] + margin\n            if centers[i, 1] + radii[i] > 1 - margin:\n                centers[i, 1] = 1 - radii[i] - margin\n        \n        # Fix overlaps\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required_dist = radii[i] + radii[j]\n                \n                if dist < required_dist - 1e-6:\n                    violations += 1\n                    # Push circles apart\n                    direction = centers[j] - centers[i]\n                    if np.linalg.norm(direction) > 1e-10:\n                        direction = direction / np.linalg.norm(direction)\n                        overlap = required_dist - dist\n                        centers[i] -= direction * overlap * 0.5\n                        centers[j] += direction * overlap * 0.5\n        \n        if violations == 0:\n            break\n    \n    return centers, radii\n\ndef optimize_full_packing(centers_init: np.ndarray, radii_init: np.ndarray) -> Optional[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"Optimize both positions and radii\"\"\"\n    n_circles = len(centers_init)\n    x0 = np.concatenate([centers_init.flatten(), radii_init])\n    \n    def objective(x):\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraints_func(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        constraints = []\n        \n        # Boundary constraints\n        for i in range(n_circles):\n            constraints.append(centers[i, 0] - radii[i])\n            constraints.append(1 - centers[i, 0] - radii[i])\n            constraints.append(centers[i, 1] - radii[i])\n            constraints.append(1 - centers[i, 1] - radii[i])\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - radii[i] - radii[j])\n        \n        # Positive radii\n        for i in range(n_circles):\n            constraints.append(radii[i] - 0.001)\n        \n        return np.array(constraints)\n    \n    bounds = [(0, 1)] * (2*n_circles) + [(0.001, 0.5)] * n_circles\n    constraints = {'type': 'ineq', 'fun': constraints_func}\n    \n    try:\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 500, 'ftol': 1e-8}\n        )\n        \n        if result.success or result.fun < 0:\n            centers_opt = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii_opt = result.x[2*n_circles:]\n            \n            if verify_packing(centers_opt, radii_opt):\n                sum_radii = np.sum(radii_opt)\n                return centers_opt, radii_opt, sum_radii\n    except:\n        pass\n    \n    return None\n\ndef local_perturbation_search(centers: np.ndarray, radii: np.ndarray, \n                              n_iterations: int = 30) -> Optional[Tuple[np.ndarray, np.ndarray, float]]:\n    \"\"\"Apply local perturbation search to escape local optima\"\"\"\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    n_circles = len(centers)\n    \n    for iteration in range(n_iterations):\n        # Try different perturbation strategies\n        if iteration % 3 == 0:\n            # Small random perturbations\n            perturbed_centers = centers + np.random.normal(0, 0.02, centers.shape)\n            perturbed_radii = radii * (1 + np.random.normal(0, 0.05, radii.shape))\n        elif iteration % 3 == 1:\n            # Swap two circles\n            perturbed_centers = centers.copy()\n            i, j = np.random.choice(n_circles, 2, replace=False)\n            perturbed_centers[[i, j]] = perturbed_centers[[j, i]]\n            perturbed_radii = radii.copy()\n        else:\n            # Perturb a subset",
  "timestamp": "2025-12-08T12:31:21.309641",
  "cost_data": null
}