{
  "trial_id": "trial_1_14",
  "generation": 1,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a force-directed layout with radius optimization for 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Initialize circles with small radii in random or grid positions\n2. Simulate forces:\n   - Repulsion between overlapping circles\n   - Attraction to maximize radii (pressure to expand)\n   - Boundary forces to keep circles inside\n3. After force simulation converges, run scipy optimization to fine-tune\n4. Use multiple random initializations\n\nCombine physics intuition with mathematical optimization.\n\nInclude construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom scipy.optimize import minimize\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport warnings\nwarnings.filterwarnings('ignore')\n\n@dataclass\nclass CirclePacking:\n    \"\"\"Represents a circle packing configuration\"\"\"\n    centers: np.ndarray  # Shape (n, 2)\n    radii: np.ndarray    # Shape (n,)\n    n_circles: int\n    \n    def get_params(self) -> np.ndarray:\n        \"\"\"Flatten to parameter vector [x1, y1, ..., xn, yn, r1, ..., rn]\"\"\"\n        return np.concatenate([self.centers.flatten(), self.radii])\n    \n    @classmethod\n    def from_params(cls, params: np.ndarray, n_circles: int):\n        \"\"\"Create from parameter vector\"\"\"\n        centers = params[:2*n_circles].reshape(n_circles, 2)\n        radii = params[2*n_circles:]\n        return cls(centers, radii, n_circles)\n    \n    def compute_overlap(self) -> float:\n        \"\"\"Compute total overlap penalty\"\"\"\n        overlap = 0.0\n        for i in range(self.n_circles):\n            for j in range(i+1, self.n_circles):\n                dist = np.linalg.norm(self.centers[i] - self.centers[j])\n                required_dist = self.radii[i] + self.radii[j]\n                if dist < required_dist:\n                    overlap += (required_dist - dist) ** 2\n        return overlap\n    \n    def compute_boundary_violation(self) -> float:\n        \"\"\"Compute boundary violation penalty\"\"\"\n        violation = 0.0\n        for i in range(self.n_circles):\n            x, y = self.centers[i]\n            r = self.radii[i]\n            # Check all four boundaries\n            violation += max(0, r - x) ** 2  # left\n            violation += max(0, x + r - 1) ** 2  # right\n            violation += max(0, r - y) ** 2  # bottom\n            violation += max(0, y + r - 1) ** 2  # top\n        return violation\n\ndef construct_packing(n_circles: int = 26, \n                     init_type: str = 'grid',\n                     seed: int = None) -> CirclePacking:\n    \"\"\"\n    Initialize a circle packing configuration.\n    \n    Args:\n        n_circles: Number of circles to pack\n        init_type: 'grid', 'random', or 'hexagonal'\n        seed: Random seed for reproducibility\n    \n    Returns:\n        CirclePacking object with initial configuration\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    if init_type == 'grid':\n        # Grid initialization\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n_circles:\n                    x = (i + 1) * spacing\n                    y = (j + 1) * spacing\n                    centers.append([x, y])\n        centers = np.array(centers)\n        \n    elif init_type == 'hexagonal':\n        # Hexagonal grid initialization\n        centers = []\n        rows = int(np.ceil(np.sqrt(n_circles)))\n        spacing = 1.0 / (rows + 1)\n        for row in range(rows):\n            cols = int(np.ceil(n_circles / rows))\n            offset = (row % 2) * spacing * 0.5\n            for col in range(cols):\n                if len(centers) < n_circles:\n                    x = (col + 1) * spacing + offset\n                    y = (row + 1) * spacing * 0.866  # sqrt(3)/2\n                    x = min(max(x, 0.1), 0.9)\n                    y = min(max(y, 0.1), 0.9)\n                    centers.append([x, y])\n        centers = np.array(centers)\n        \n    else:  # random\n        # Random initialization with some margin\n        centers = np.random.uniform(0.15, 0.85, size=(n_circles, 2))\n    \n    # Initialize with small radii\n    initial_radius = 0.02\n    radii = np.full(n_circles, initial_radius)\n    \n    return CirclePacking(centers, radii, n_circles)\n\ndef force_directed_simulation(packing: CirclePacking, \n                              n_iterations: int = 1000,\n                              dt: float = 0.01,\n                              damping: float = 0.9,\n                              verbose: bool = False) -> CirclePacking:\n    \"\"\"\n    Run force-directed simulation to optimize circle positions and radii.\n    \n    Forces:\n    1. Repulsion between overlapping circles\n    2. Boundary repulsion\n    3. Radius expansion pressure\n    \"\"\"\n    centers = packing.centers.copy()\n    radii = packing.radii.copy()\n    velocities = np.zeros_like(centers)\n    radius_velocities = np.zeros_like(radii)\n    \n    for iteration in range(n_iterations):\n        forces = np.zeros_like(centers)\n        radius_forces = np.zeros_like(radii)\n        \n        # 1. Circle-circle repulsion\n        for i in range(packing.n_circles):\n            for j in range(i+1, packing.n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                if dist < 1e-6:\n                    diff = np.random.randn(2) * 0.01\n                    dist = np.linalg.norm(diff)\n                \n                required_dist = radii[i] + radii[j]\n                \n                if dist < required_dist:\n                    # Strong repulsion when overlapping\n                    overlap = required_dist - dist\n                    force_magnitude = overlap * 10.0\n                    force_dir = diff / dist\n                    forces[i] += force_dir * force_magnitude\n                    forces[j] -= force_dir * force_magnitude\n                    \n                    # Also encourage radius reduction\n                    radius_forces[i] -= overlap * 2.0\n                    radius_forces[j] -= overlap * 2.0\n        \n        # 2. Boundary forces\n        for i in range(packing.n_circles):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Left boundary\n            if x - r < 0:\n                forces[i, 0] += (r - x) * 20.0\n                radius_forces[i] -= (r - x) * 5.0\n            \n            # Right boundary\n            if x + r > 1:\n                forces[i, 0] -= (x + r - 1) * 20.0\n                radius_forces[i] -= (x + r - 1) * 5.0\n            \n            # Bottom boundary\n            if y - r < 0:\n                forces[i, 1] += (r - y) * 20.0\n                radius_forces[i] -= (r - y) * 5.0\n            \n            # Top boundary\n            if y + r > 1:\n                forces[i, 1] -= (y + r - 1) * 20.0\n                radius_forces[i] -= (y + r - 1) * 5.0\n        \n        # 3. Radius expansion pressure (want to maximize radii)\n        radius_forces += 1.0\n        \n        # Update velocities with damping\n        velocities = velocities * damping + forces * dt\n        radius_velocities = radius_velocities * damping + radius_forces * dt\n        \n        # Update positions and radii\n        centers += velocities * dt\n        radii += radius_velocities * dt\n        \n        # Clamp radii to reasonable bounds\n        radii = np.clip(radii, 0.005, 0.2)\n        \n        # Clamp centers to stay well within bounds\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        if verbose and iteration % 100 == 0:\n            overlap = packing.compute_overlap()\n            avg_radius = np.mean(radii)\n            print(f\"Iteration {iteration}: overlap={overlap:.6f}, avg_radius={avg_radius:.4f}\")\n    \n    return CirclePacking(centers, radii, packing.n_circles)\n\ndef optimize_packing(packing: CirclePacking, \n                    max_iter: int = 500,\n                    verbose: bool = False) -> CirclePacking:\n    \"\"\"\n    Fine-tune packing using scipy optimization.\n    Objective: maximize minimum radius while maintaining constraints.\n    \"\"\"\n    n = packing.n_circles\n    \n    def objective(params):\n        \"\"\"Minimize negative sum of radii (= maximize radii)\"\"\"\n        p = CirclePacking.from_params(params, n)\n        # Primary: maximize radii\n        # Secondary: penalize overlap and boundary violations\n        overlap_penalty = p.compute_overlap() * 1000\n        boundary_penalty = p.compute_boundary_violation() * 1000\n        radius_reward = -np.sum(p.radii)  # Negative because we minimize\n        \n        return radius_reward + overlap_penalty + boundary_penalty\n    \n    def constraint_no_overlap(params):\n        \"\"\"Constraint: all circles should not overlap\"\"\"\n        p = CirclePacking.from_params(params, n)\n        min_separation = float('inf')\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(p.centers[i] - p.centers[j])\n                separation = dist - (p.radii[i] + p.radii[j])\n                min_separation = min(min_separation, separation)\n        return min_separation\n    \n    def constraint_boundary(params):\n        \"\"\"Constraint: all circles inside [0,1]x[0,1]\"\"\"\n        p = CirclePacking.from_params(params, n)\n        min_margin = float('inf')\n        for i in range(n):\n            x, y = p.centers[i]\n            r = p.radii[i]\n            margins = [x - r, 1 - x - r, y - r, 1 - y - r]\n            min_margin = min(min_margin, min(margins))\n        return min_margin\n    \n    # Bounds\n    bounds = [(0.01, 0.99)] * (2 * n)  # centers\n    bounds += [(0.005, 0.2)] * n  # radii\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_boundary}\n    ]\n    \n    # Initial parameters\n    x0 = packing.get_params()\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': max_iter, 'disp': verbose}\n    )\n    \n    return CirclePacking.from_params(result.x, n)\n\ndef run_packing(n_circles: int = 26,\n                n_trials: int = 5,\n                simulation_iterations: int = 1000,\n                optimization_iterations: int = 500,\n                verbose: bool = True) -> CirclePacking:\n    \"\"\"\n    Run complete packing optimization with multiple trials.\n    \n    Args:\n        n_circles: Number of circles to pack\n        n_trials: Number of random initializations to try\n        simulation_iterations: Iterations for force-directed simulation\n        optimization_iterations: Iterations for scipy optimization\n        verbose: Print progress\n    \n    Returns:\n        Best CirclePacking found\n    \"\"\"\n    best_packing = None\n    best_min_radius = 0\n    \n    init_types = ['grid', 'hexagonal', 'random']\n    \n    for trial in range(n_trials):\n        if verbose:\n            print(f\"\\n{'='*60}\")\n            print(f\"Trial {trial + 1}/{n_trials}\")\n            print(f\"{'='*60}\")\n        \n        # Choose initialization strategy\n        init_type = init_types[trial % len(init_types)]\n        seed = trial\n        \n        if verbose:\n            print(f\"Initialization: {init_type}, seed={seed}\")\n        \n        # 1. Initialize\n        packing = construct_packing(n_circles, init_type=init_type, seed=seed)\n        \n        # 2. Force-directed simulation\n        if verbose:\n            print(\"\\nRunning force-directed simulation...\")\n        packing = force_directed_simulation(\n            packing, \n            n_iterations=simulation_iterations,\n            verbose=verbose\n        )\n        \n        # 3. Scipy optimization\n        if verbose:\n            print(\"\\nRunning scipy optimization...\")\n        packing = optimize_packing(\n            packing,\n            max_iter=optimization_iterations,\n            verbose=verbose\n        )\n        \n        # Evaluate\n        min_radius = np.min(packing.radii)\n        avg_radius = np.mean(packing.radii)\n        overlap = packing.compute_overlap()\n        boundary_violation = packing.compute_boundary_violation()\n        \n        if verbose:\n            print(f\"\\nResults:\")\n            print(f\"  Min radius: {min_radius:.6f}\")\n            print(f\"  Avg radius: {avg_radius:.6f}\")\n            print(f\"  Max radius: {np.max(packing.radii):.6f}\")\n            print(f\"  Overlap: {overlap:.8f}\")\n            print(f\"  Boundary violation: {boundary_violation:.8f}\")\n        \n        # Keep best (prioritize min radius, then low violations)\n        if overlap < 1e-6 and boundary_violation < 1e-6:\n            if min_radius > best_min_radius:\n                best_min_radius = min_radius\n                best_packing = packing\n                if verbose:\n                    print(f\"  *** New best packing! ***\")\n    \n    if best_packing is None:\n        print(\"\\nWarning: No valid packing found. Returning last attempt.\")\n        best_packing = packing\n    \n    return best_packing\n\ndef visualize_packing(packing: CirclePacking, title: str = \"Circle Packing\"):\n    \"\"\"Visualize the circle packing\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw circles\n    for i in range(packing.n_circles):\n        circle = Circle(\n            packing.centers[i], \n            packing.radii[i],\n            fill=True,\n            facecolor=plt.cm.tab20(i % 20),\n            edgecolor='black',\n            linewidth=1.5,\n            alpha=0.7\n        )\n        ax.add_patch(circle)\n        \n        # Add label\n        ax.text(\n            packing.centers[i, 0],\n            packing.centers[i, 1],\n            str(i+1),\n            ha='center',\n            va='center',\n            fontsize=8,\n            fontweight='bold'\n        )\n    \n    # Set limits and aspect\n    ax.set_xlim(-0.05, 1.05)\n    ax.set_ylim(-0.05, 1.05)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    \n    # Draw boundary\n    boundary = plt.Rectangle((0, 0), 1, 1, fill=False, \n                            edgecolor='red', linewidth=2)\n    ax.add_patch(boundary)\n    \n    # Title with statistics\n    min_r = np.min(packing.radii)\n    avg_r = np.mean(p",
  "reasoning": "```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom scipy.optimize import minimize\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport warnings\nwarnings.filterwarnings('ignore')\n\n@dataclass\nclass CirclePacking:\n    \"\"\"Represents a circle packing configuration\"\"\"\n    centers: np.ndarray  # Shape (n, 2)\n    radii: np.ndarray    # Shape (n,)\n    n_circles: int\n    \n    def get_params(self) -> np.ndarray:\n        \"\"\"Flatten to parameter vector [x1, y1, ..., xn, yn, r1, ..., rn]\"\"\"\n        return np.concatenate([self.centers.flatten(), self.radii])\n    \n    @classmethod\n    def from_params(cls, params: np.ndarray, n_circles: int):\n        \"\"\"Create from parameter vector\"\"\"\n        centers = params[:2*n_circles].reshape(n_circles, 2)\n        radii = params[2*n_circles:]\n        return cls(centers, radii, n_circles)\n    \n    def compute_overlap(self) -> float:\n        \"\"\"Compute total overlap penalty\"\"\"\n        overlap = 0.0\n        for i in range(self.n_circles):\n            for j in range(i+1, self.n_circles):\n                dist = np.linalg.norm(self.centers[i] - self.centers[j])\n                required_dist = self.radii[i] + self.radii[j]\n                if dist < required_dist:\n                    overlap += (required_dist - dist) ** 2\n        return overlap\n    \n    def compute_boundary_violation(self) -> float:\n        \"\"\"Compute boundary violation penalty\"\"\"\n        violation = 0.0\n        for i in range(self.n_circles):\n            x, y = self.centers[i]\n            r = self.radii[i]\n            # Check all four boundaries\n            violation += max(0, r - x) ** 2  # left\n            violation += max(0, x + r - 1) ** 2  # right\n            violation += max(0, r - y) ** 2  # bottom\n            violation += max(0, y + r - 1) ** 2  # top\n        return violation\n\ndef construct_packing(n_circles: int = 26, \n                     init_type: str = 'grid',\n                     seed: int = None) -> CirclePacking:\n    \"\"\"\n    Initialize a circle packing configuration.\n    \n    Args:\n        n_circles: Number of circles to pack\n        init_type: 'grid', 'random', or 'hexagonal'\n        seed: Random seed for reproducibility\n    \n    Returns:\n        CirclePacking object with initial configuration\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    if init_type == 'grid':\n        # Grid initialization\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        spacing = 1.0 / (grid_size + 1)\n        centers = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) < n_circles:\n                    x = (i + 1) * spacing\n                    y = (j + 1) * spacing\n                    centers.append([x, y])\n        centers = np.array(centers)\n        \n    elif init_type == 'hexagonal':\n        # Hexagonal grid initialization\n        centers = []\n        rows = int(np.ceil(np.sqrt(n_circles)))\n        spacing = 1.0 / (rows + 1)\n        for row in range(rows):\n            cols = int(np.ceil(n_circles / rows))\n            offset = (row % 2) * spacing * 0.5\n            for col in range(cols):\n                if len(centers) < n_circles:\n                    x = (col + 1) * spacing + offset\n                    y = (row + 1) * spacing * 0.866  # sqrt(3)/2\n                    x = min(max(x, 0.1), 0.9)\n                    y = min(max(y, 0.1), 0.9)\n                    centers.append([x, y])\n        centers = np.array(centers)\n        \n    else:  # random\n        # Random initialization with some margin\n        centers = np.random.uniform(0.15, 0.85, size=(n_circles, 2))\n    \n    # Initialize with small radii\n    initial_radius = 0.02\n    radii = np.full(n_circles, initial_radius)\n    \n    return CirclePacking(centers, radii, n_circles)\n\ndef force_directed_simulation(packing: CirclePacking, \n                              n_iterations: int = 1000,\n                              dt: float = 0.01,\n                              damping: float = 0.9,\n                              verbose: bool = False) -> CirclePacking:\n    \"\"\"\n    Run force-directed simulation to optimize circle positions and radii.\n    \n    Forces:\n    1. Repulsion between overlapping circles\n    2. Boundary repulsion\n    3. Radius expansion pressure\n    \"\"\"\n    centers = packing.centers.copy()\n    radii = packing.radii.copy()\n    velocities = np.zeros_like(centers)\n    radius_velocities = np.zeros_like(radii)\n    \n    for iteration in range(n_iterations):\n        forces = np.zeros_like(centers)\n        radius_forces = np.zeros_like(radii)\n        \n        # 1. Circle-circle repulsion\n        for i in range(packing.n_circles):\n            for j in range(i+1, packing.n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                if dist < 1e-6:\n                    diff = np.random.randn(2) * 0.01\n                    dist = np.linalg.norm(diff)\n                \n                required_dist = radii[i] + radii[j]\n                \n                if dist < required_dist:\n                    # Strong repulsion when overlapping\n                    overlap = required_dist - dist\n                    force_magnitude = overlap * 10.0\n                    force_dir = diff / dist\n                    forces[i] += force_dir * force_magnitude\n                    forces[j] -= force_dir * force_magnitude\n                    \n                    # Also encourage radius reduction\n                    radius_forces[i] -= overlap * 2.0\n                    radius_forces[j] -= overlap * 2.0\n        \n        # 2. Boundary forces\n        for i in range(packing.n_circles):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Left boundary\n            if x - r < 0:\n                forces[i, 0] += (r - x) * 20.0\n                radius_forces[i] -= (r - x) * 5.0\n            \n            # Right boundary\n            if x + r > 1:\n                forces[i, 0] -= (x + r - 1) * 20.0\n                radius_forces[i] -= (x + r - 1) * 5.0\n            \n            # Bottom boundary\n            if y - r < 0:\n                forces[i, 1] += (r - y) * 20.0\n                radius_forces[i] -= (r - y) * 5.0\n            \n            # Top boundary\n            if y + r > 1:\n                forces[i, 1] -= (y + r - 1) * 20.0\n                radius_forces[i] -= (y + r - 1) * 5.0\n        \n        # 3. Radius expansion pressure (want to maximize radii)\n        radius_forces += 1.0\n        \n        # Update velocities with damping\n        velocities = velocities * damping + forces * dt\n        radius_velocities = radius_velocities * damping + radius_forces * dt\n        \n        # Update positions and radii\n        centers += velocities * dt\n        radii += radius_velocities * dt\n        \n        # Clamp radii to reasonable bounds\n        radii = np.clip(radii, 0.005, 0.2)\n        \n        # Clamp centers to stay well within bounds\n        centers = np.clip(centers, 0.05, 0.95)\n        \n        if verbose and iteration % 100 == 0:\n            overlap = packing.compute_overlap()\n            avg_radius = np.mean(radii)\n            print(f\"Iteration {iteration}: overlap={overlap:.6f}, avg_radius={avg_radius:.4f}\")\n    \n    return CirclePacking(centers, radii, packing.n_circles)\n\ndef optimize_packing(packing: CirclePacking, \n                    max_iter: int = 500,\n                    verbose: bool = False) -> CirclePacking:\n    \"\"\"\n    Fine-tune packing using scipy optimization.\n    Objective: maximize minimum radius while maintaining constraints.\n    \"\"\"\n    n = packing.n_circles\n    \n    def objective(params):\n        \"\"\"Minimize negative sum of radii (= maximize radii)\"\"\"\n        p = CirclePacking.from_params(params, n)\n        # Primary: maximize radii\n        # Secondary: penalize overlap and boundary violations\n        overlap_penalty = p.compute_overlap() * 1000\n        boundary_penalty = p.compute_boundary_violation() * 1000\n        radius_reward = -np.sum(p.radii)  # Negative because we minimize\n        \n        return radius_reward + overlap_penalty + boundary_penalty\n    \n    def constraint_no_overlap(params):\n        \"\"\"Constraint: all circles should not overlap\"\"\"\n        p = CirclePacking.from_params(params, n)\n        min_separation = float('inf')\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(p.centers[i] - p.centers[j])\n                separation = dist - (p.radii[i] + p.radii[j])\n                min_separation = min(min_separation, separation)\n        return min_separation\n    \n    def constraint_boundary(params):\n        \"\"\"Constraint: all circles inside [0,1]x[0,1]\"\"\"\n        p = CirclePacking.from_params(params, n)\n        min_margin = float('inf')\n        for i in range(n):\n            x, y = p.centers[i]\n            r = p.radii[i]\n            margins = [x - r, 1 - x - r, y - r, 1 - y - r]\n            min_margin = min(min_margin, min(margins))\n        return min_margin\n    \n    # Bounds\n    bounds = [(0.01, 0.99)] * (2 * n)  # centers\n    bounds += [(0.005, 0.2)] * n  # radii\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_boundary}\n    ]\n    \n    # Initial parameters\n    x0 = packing.get_params()\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': max_iter, 'disp': verbose}\n    )\n    \n    return CirclePacking.from_params(result.x, n)\n\ndef run_packing(n_circles: int = 26,\n                n_trials: int = 5,\n                simulation_iterations: int = 1000,\n                optimization_iterations: int = 500,\n                verbose: bool = True) -> CirclePacking:\n    \"\"\"\n    Run complete packing optimization with multiple trials.\n    \n    Args:\n        n_circles: Number of circles to pack\n        n_trials: Number of random initializations to try\n        simulation_iterations: Iterations for force-directed simulation\n        optimization_iterations: Iterations for scipy optimization\n        verbose: Print progress\n    \n    Returns:\n        Best CirclePacking found\n    \"\"\"\n    best_packing = None\n    best_min_radius = 0\n    \n    init_types = ['grid', 'hexagonal', 'random']\n    \n    for trial in range(n_trials):\n        if verbose:\n            print(f\"\\n{'='*60}\")\n            print(f\"Trial {trial + 1}/{n_trials}\")\n            print(f\"{'='*60}\")\n        \n        # Choose initialization strategy\n        init_type = init_types[trial % len(init_types)]\n        seed = trial\n        \n        if verbose:\n            print(f\"Initialization: {init_type}, seed={seed}\")\n        \n        # 1. Initialize\n        packing = construct_packing(n_circles, init_type=init_type, seed=seed)\n        \n        # 2. Force-directed simulation\n        if verbose:\n            print(\"\\nRunning force-directed simulation...\")\n        packing = force_directed_simulation(\n            packing, \n            n_iterations=simulation_iterations,\n            verbose=verbose\n        )\n        \n        # 3. Scipy optimization\n        if verbose:\n            print(\"\\nRunning scipy optimization...\")\n        packing = optimize_packing(\n            packing,\n            max_iter=optimization_iterations,\n            verbose=verbose\n        )\n        \n        # Evaluate\n        min_radius = np.min(packing.radii)\n        avg_radius = np.mean(packing.radii)\n        overlap = packing.compute_overlap()\n        boundary_violation = packing.compute_boundary_violation()\n        \n        if verbose:\n            print(f\"\\nResults:\")\n            print(f\"  Min radius: {min_radius:.6f}\")\n            print(f\"  Avg radius: {avg_radius:.6f}\")\n            print(f\"  Max radius: {np.max(packing.radii):.6f}\")\n            print(f\"  Overlap: {overlap:.8f}\")\n            print(f\"  Boundary violation: {boundary_violation:.8f}\")\n        \n        # Keep best (prioritize min radius, then low violations)\n        if overlap < 1e-6 and boundary_violation < 1e-6:\n            if min_radius > best_min_radius:\n                best_min_radius = min_radius\n                best_packing = packing\n                if verbose:\n                    print(f\"  *** New best packing! ***\")\n    \n    if best_packing is None:\n        print(\"\\nWarning: No valid packing found. Returning last attempt.\")\n        best_packing = packing\n    \n    return best_packing\n\ndef visualize_packing(packing: CirclePacking, title: str = \"Circle Packing\"):\n    \"\"\"Visualize the circle packing\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw circles\n    for i in range(packing.n_circles):\n        circle = Circle(\n            packing.centers[i], \n            packing.radii[i],\n            fill=True,\n            facecolor=plt.cm.tab20(i % 20),\n            edgecolor='black',\n            linewidth=1.5,\n            alpha=0.7\n        )\n        ax.add_patch(circle)\n        \n        # Add label\n        ax.text(\n            packing.centers[i, 0],\n            packing.centers[i, 1],\n            str(i+1),\n            ha='center',\n            va='center',\n            fontsize=8,\n            fontweight='bold'\n        )\n    \n    # Set limits and aspect\n    ax.set_xlim(-0.05, 1.05)\n    ax.set_ylim(-0.05, 1.05)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    \n    # Draw boundary\n    boundary = plt.Rectangle((0, 0), 1, 1, fill=False, \n                            edgecolor='red', linewidth=2)\n    ax.add_patch(boundary)\n    \n    # Title with statistics\n    min_r = np.min(packing.radii)\n    avg_r = np.mean(p",
  "timestamp": "2025-12-08T12:31:27.763579",
  "cost_data": null
}