{
  "trial_id": "trial_1_12",
  "generation": 1,
  "parent_id": "trial_0_7",
  "code": "",
  "metrics": {},
  "prompt": "Improve the divide-and-conquer approach:\n\nimport numpy as np\nfrom scipy.optimize import minimize\nimport itertools\n\ndef pack_circles_in_region(n_circles, x_min, x_max, y_min, y_max):\n    \"\"\"Pack n circles in a rectangular region using grid layout.\"\"\"\n    width = x_max - x_min\n    height = y_max - y_min\n    \n    if n_circles == 0:\n        return np.array([]), np.array([])\n    \n    # Find best grid arrangement\n    best_r = 0\n    best_centers = None\n    \n    for nx in range(1, n_circles + 1):\n        ny = (n_circles + nx - 1) // nx\n        if nx * ny < n_circles:\n            continue\n            \n        # Calculate maximum radius for this grid\n        r_x = width / (2 * nx)\n        r_y = height / (2 * ny)\n        r = min(r_x, r_y)\n        \n        if r > best_r:\n            best_r = r\n            centers = []\n            count = 0\n            for i in range(ny):\n                for j in range(nx):\n                    if count >= n_circles:\n                        break\n                    x = x_min + r + j * 2 * r\n                    y = y_min + r + i * 2 * r\n                    centers.append([x, y])\n                    count += 1\n                if count >= n_circles:\n                    break\n            best_centers = np.array(centers)\n    \n    radii = np.full(n_circles, best_r)\n    return best_centers, radii\n\ndef pack_uniform_grid(n_circles, nx, ny):\n    \"\"\"Pack circles using uniform grid subdivision.\"\"\"\n    regions = []\n    for i in range(ny):\n        for j in range(nx):\n            x_min = j / nx\n            x_max = (j + 1) / nx\n            y_min = i / ny\n            y_max = (i + 1) / ny\n            regions.append((x_min, x_max, y_min, y_max))\n    \n    # Distribute circles among regions\n    n_regions = len(regions)\n    base_count = n_circles // n_regions\n    extra = n_circles % n_regions\n    \n    all_centers = []\n    all_radii = []\n    \n    for idx, (x_min, x_max, y_min, y_max) in enumerate(regions):\n        n = base_count + (1 if idx < extra else 0)\n        if n > 0:\n            centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max)\n            all_centers.append(centers)\n            all_radii.append(radii)\n    \n    if all_centers:\n        centers = np.vstack(all_centers)\n        radii = np.hstack(all_radii)\n    else:\n        centers = np.array([]).reshape(0, 2)\n        radii = np.array([])\n    \n    return centers, radii\n\ndef pack_adaptive_regions(n_circles):\n    \"\"\"Pack circles using adaptive region allocation.\"\"\"\n    # Strategy: Create regions of different sizes based on circle allocation\n    # Use 2x3 grid with custom allocation\n    regions = [\n        (0.0, 0.5, 0.0, 0.5, 5),    # Bottom-left: 5 circles\n        (0.5, 1.0, 0.0, 0.5, 5),    # Bottom-right: 5 circles\n        (0.0, 0.5, 0.5, 1.0, 5),    # Top-left: 5 circles\n        (0.5, 1.0, 0.5, 1.0, 5),    # Top-right: 5 circles\n        (0.0, 0.5, 0.0, 1.0, 3),    # Left half: 3 circles\n        (0.5, 1.0, 0.0, 1.0, 3),    # Right half: 3 circles\n    ]\n    \n    # Try different allocations\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n    \n    # Strategy 1: 5x5 + 1 row of 1\n    allocation1 = [5, 5, 5, 5, 3, 3]\n    \n    # Strategy 2: Balanced 2x3\n    allocation2 = [4, 4, 4, 5, 5, 4]\n    \n    # Strategy 3: 3x3 grid with extra\n    for alloc in [allocation1, allocation2]:\n        if sum(alloc) != n_circles:\n            continue\n        \n        all_centers = []\n        all_radii = []\n        \n        for idx, (x_min, x_max, y_min, y_max, _) in enumerate(regions[:len(alloc)]):\n            n = alloc[idx]\n            if n > 0:\n                centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max)\n                all_centers.append(centers)\n                all_radii.append(radii)\n        \n        if all_centers:\n            centers = np.vstack(all_centers)\n            radii = np.hstack(all_radii)\n            sum_radii = np.sum(radii)\n            \n            if sum_radii > best_sum:\n                best_sum = sum_radii\n                best_centers = centers\n                best_radii = radii\n    \n    return best_centers, best_radii\n\ndef construct_packing():\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    n_circles = 26\n    \n    # Try different strategies\n    strategies = []\n    \n    # 2x2 grid\n    centers, radii = pack_uniform_grid(n_circles, 2, 2)\n    strategies.append((centers, radii, np.sum(radii)))\n    \n    # 3x3 grid\n    centers, radii = pack_uniform_grid(n_circles, 3, 3)\n    strategies.append((centers, radii, np.sum(radii)))\n    \n    # 2x3 grid\n    centers, radii = pack_uniform_grid(n_circles, 2, 3)\n    strategies.append((centers, radii, np.sum(radii)))\n    \n    # 3x2 grid\n    centers, radii = pack_uniform_grid(n_circles, 3, 2)\n    strategies.append((centers, radii, np.sum(radii)))\n    \n    # 4x4 grid\n    centers, radii = pack_uniform_grid(n_circles, 4, 4)\n    strategies.append((centers, radii, np.sum(radii)))\n    \n    # 5x5 grid\n    centers, radii = pack_uniform_grid(n_circles, 5, 5)\n    strategies.append((centers, radii, np.sum(radii)))\n    \n    # 6x5 grid\n    centers, radii = pack_uniform_grid(n_circles, 6, 5)\n    strategies.append((centers, radii, np.sum(radii)))\n    \n    # Find best strategy\n    best_idx = np.argmax([s[2] for s in strategies])\n    centers, radii, sum_radii = strategies[best_idx]\n    \n    # Verify constraints\n    assert len(centers) == n_circles, f\"Expected {n_circles} circles, got {len(centers)}\"\n    assert np.all(centers - radii[:, None] >= 0), \"Some circles outside left/bottom boundary\"\n    assert np.all(centers + radii[:, None] <= 1), \"Some circles outside right/top boundary\"\n    \n    # Check for overlaps\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            assert dist >= radii[i] + radii[j] - 1e-6, f\"Circles {i} and {j} overlap\"\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n\n# Test the packing\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n\nImprovements:\n1. Add adaptive subdivision based on circle count\n2. Use scipy optimization within each region instead of just grid\n3. Add boundary optimization: optimize circles near region boundaries\n4. Try irregular subdivisions (not just uniform grids)\n\nFocus on better region packing through local optimization.",
  "response": "Here's an improved divide-and-conquer approach with adaptive subdivision, local optimization, and boundary refinement:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nimport itertools\n\ndef pack_circles_in_region(n_circles, x_min, x_max, y_min, y_max, optimize=True):\n    \"\"\"Pack n circles in a rectangular region using grid layout + optimization.\"\"\"\n    width = x_max - x_min\n    height = y_max - y_min\n    \n    if n_circles == 0:\n        return np.array([]), np.array([])\n    \n    # Find best grid arrangement\n    best_r = 0\n    best_centers = None\n    \n    for nx in range(1, n_circles + 1):\n        ny = (n_circles + nx - 1) // nx\n        if nx * ny < n_circles:\n            continue\n            \n        # Calculate maximum radius for this grid\n        r_x = width / (2 * nx)\n        r_y = height / (2 * ny)\n        r = min(r_x, r_y)\n        \n        if r > best_r:\n            best_r = r\n            centers = []\n            count = 0\n            for i in range(ny):\n                for j in range(nx):\n                    if count >= n_circles:\n                        break\n                    x = x_min + r + j * 2 * r\n                    y = y_min + r + i * 2 * r\n                    centers.append([x, y])\n                    count += 1\n                if count >= n_circles:\n                    break\n            best_centers = np.array(centers)\n    \n    radii = np.full(n_circles, best_r)\n    \n    # Apply local optimization if requested\n    if optimize and n_circles > 1 and n_circles <= 15:\n        centers, radii = optimize_region_packing(best_centers, radii, x_min, x_max, y_min, y_max)\n    \n    return centers, radii\n\ndef optimize_region_packing(centers, radii, x_min, x_max, y_min, y_max, max_iter=100):\n    \"\"\"Optimize circle packing within a region using scipy.\"\"\"\n    n = len(centers)\n    \n    # Initial guess: flatten centers and use uniform radii\n    initial_r = np.min(radii)\n    x0 = np.concatenate([centers.flatten(), [initial_r]])\n    \n    def objective(x):\n        r = x[-1]\n        return -r  # Maximize radius\n    \n    def constraint_no_overlap(x):\n        r = x[-1]\n        centers_opt = x[:-1].reshape(-1, 2)\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                constraints.append(dist - 2 * r)\n        return np.array(constraints)\n    \n    def constraint_boundaries(x):\n        r = x[-1]\n        centers_opt = x[:-1].reshape(-1, 2)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers_opt[i, 0] - r - x_min)  # Left\n            constraints.append(x_max - centers_opt[i, 0] - r)  # Right\n            constraints.append(centers_opt[i, 1] - r - y_min)  # Bottom\n            constraints.append(y_max - centers_opt[i, 1] - r)  # Top\n        return np.array(constraints)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_boundaries}\n    ]\n    \n    # Bounds for optimization\n    bounds = []\n    for i in range(n):\n        bounds.append((x_min, x_max))  # x coordinate\n        bounds.append((y_min, y_max))  # y coordinate\n    bounds.append((1e-6, min(x_max - x_min, y_max - y_min) / 2))  # radius\n    \n    try:\n        result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                         constraints=constraints, options={'maxiter': max_iter})\n        \n        if result.success:\n            optimized_r = result.x[-1]\n            optimized_centers = result.x[:-1].reshape(-1, 2)\n            optimized_radii = np.full(n, optimized_r)\n            \n            # Verify solution is better\n            if optimized_r > initial_r * 0.99:  # Accept if at least 99% of initial\n                return optimized_centers, optimized_radii\n    except:\n        pass\n    \n    return centers, radii\n\ndef pack_irregular_subdivision(n_circles):\n    \"\"\"Pack circles using irregular adaptive subdivision.\"\"\"\n    \n    # Define irregular regions based on optimal partitioning\n    # Try different subdivision strategies\n    strategies = []\n    \n    # Strategy 1: Vertical split with different ratios\n    for ratio in [0.4, 0.5, 0.6]:\n        n_left = int(n_circles * ratio)\n        n_right = n_circles - n_left\n        \n        centers_left, radii_left = pack_circles_in_region(n_left, 0, ratio, 0, 1, optimize=True)\n        centers_right, radii_right = pack_circles_in_region(n_right, ratio, 1, 0, 1, optimize=True)\n        \n        if len(centers_left) > 0 and len(centers_right) > 0:\n            centers = np.vstack([centers_left, centers_right])\n            radii = np.hstack([radii_left, radii_right])\n            strategies.append((centers, radii, np.sum(radii)))\n        elif len(centers_left) > 0:\n            strategies.append((centers_left, radii_left, np.sum(radii_left)))\n        elif len(centers_right) > 0:\n            strategies.append((centers_right, radii_right, np.sum(radii_right)))\n    \n    # Strategy 2: Horizontal split with different ratios\n    for ratio in [0.4, 0.5, 0.6]:\n        n_bottom = int(n_circles * ratio)\n        n_top = n_circles - n_bottom\n        \n        centers_bottom, radii_bottom = pack_circles_in_region(n_bottom, 0, 1, 0, ratio, optimize=True)\n        centers_top, radii_top = pack_circles_in_region(n_top, 0, 1, ratio, 1, optimize=True)\n        \n        if len(centers_bottom) > 0 and len(centers_top) > 0:\n            centers = np.vstack([centers_bottom, centers_top])\n            radii = np.hstack([radii_bottom, radii_top])\n            strategies.append((centers, radii, np.sum(radii)))\n    \n    # Strategy 3: Quadrant split with adaptive allocation\n    allocations = [\n        [7, 7, 6, 6],  # Balanced\n        [8, 7, 6, 5],  # Slightly unbalanced\n        [9, 6, 6, 5],  # More unbalanced\n    ]\n    \n    for alloc in allocations:\n        if sum(alloc) != n_circles:\n            continue\n        \n        regions = [\n            (0.0, 0.5, 0.0, 0.5, alloc[0]),\n            (0.5, 1.0, 0.0, 0.5, alloc[1]),\n            (0.0, 0.5, 0.5, 1.0, alloc[2]),\n            (0.5, 1.0, 0.5, 1.0, alloc[3]),\n        ]\n        \n        all_centers = []\n        all_radii = []\n        \n        for x_min, x_max, y_min, y_max, n in regions:\n            if n > 0:\n                centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max, optimize=True)\n                all_centers.append(centers)\n                all_radii.append(radii)\n        \n        if all_centers:\n            centers = np.vstack(all_centers)\n            radii = np.hstack(all_radii)\n            strategies.append((centers, radii, np.sum(radii)))\n    \n    # Strategy 4: Non-uniform grid (e.g., 2x3 with different sizes)\n    for split_x in [0.4, 0.5, 0.6]:\n        for split_y1 in [0.33, 0.4]:\n            split_y2 = 1 - split_y1\n            \n            regions = [\n                (0.0, split_x, 0.0, split_y1),\n                (split_x, 1.0, 0.0, split_y1),\n                (0.0, split_x, split_y1, split_y2),\n                (split_x, 1.0, split_y1, split_y2),\n                (0.0, split_x, split_y2, 1.0),\n                (split_x, 1.0, split_y2, 1.0),\n            ]\n            \n            # Calculate area-proportional allocation\n            areas = [(x1-x0)*(y1-y0) for x0, x1, y0, y1 in regions]\n            total_area = sum(areas)\n            alloc = [max(1, int(n_circles * a / total_area)) for a in areas]\n            \n            # Adjust to match total\n            while sum(alloc) < n_circles:\n                idx = np.argmax(areas)\n                alloc[idx] += 1\n            while sum(alloc) > n_circles:\n                idx = np.argmax(alloc)\n                if alloc[idx] > 1:\n                    alloc[idx] -= 1\n            \n            all_centers = []\n            all_radii = []\n            \n            for (x_min, x_max, y_min, y_max), n in zip(regions, alloc):\n                if n > 0:\n                    centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max, optimize=False)\n                    all_centers.append(centers)\n                    all_radii.append(radii)\n            \n            if all_centers:\n                centers = np.vstack(all_centers)\n                radii = np.hstack(all_radii)\n                strategies.append((centers, radii, np.sum(radii)))\n    \n    if not strategies:\n        return None, None, 0\n    \n    # Return best strategy\n    best_idx = np.argmax([s[2] for s in strategies])\n    return strategies[best_idx]\n\ndef optimize_boundary_circles(centers, radii):\n    \"\"\"Optimize circles near region boundaries to maximize radii.\"\"\"\n    n = len(centers)\n    \n    # Identify boundary circles (close to edges)\n    boundary_threshold = 0.15\n    boundary_mask = (\n        (centers[:, 0] < boundary_threshold) |\n        (centers[:, 0] > 1 - boundary_threshold) |\n        (centers[:, 1] < boundary_threshold) |\n        (centers[:, 1] > 1 - boundary_threshold)\n    )\n    \n    boundary_indices = np.where(boundary_mask)[0]\n    \n    if len(boundary_indices) == 0:\n        return centers, radii\n    \n    # Try to expand boundary circles\n    for idx in boundary_indices:\n        # Calculate maximum possible radius for this circle\n        max_r = min(\n            centers[idx, 0],  # Distance to left\n            1 - centers[idx, 0],  # Distance to right\n            centers[idx, 1],  # Distance to bottom\n            1 - centers[idx, 1]  # Distance to top\n        )\n        \n        # Check distances to other circles\n        for j in range(n):\n            if j != idx:\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                max_r = min(max_r, dist - radii[j])\n        \n        # Update radius if we can increase it\n        if max_r > radii[idx]:\n            radii[idx] = max_r * 0.99  # Use 99% for safety margin\n    \n    return centers, radii\n\ndef pack_uniform_grid(n_circles, nx, ny, optimize=False):\n    \"\"\"Pack circles using uniform grid subdivision.\"\"\"\n    regions = []\n    for i in range(ny):\n        for j in range(nx):\n            x_min = j / nx\n            x_max = (j + 1) / nx\n            y_min = i / ny\n            y_max = (i + 1) / ny\n            regions.append((x_min, x_max, y_min, y_max))\n    \n    # Distribute circles among regions\n    n_regions = len(regions)\n    base_count = n_circles // n_regions\n    extra = n_circles % n_regions\n    \n    all_centers = []\n    all_radii = []\n    \n    for idx, (x_min, x_max, y_min, y_max) in enumerate(regions):\n        n = base_count + (1 if idx < extra else 0)\n        if n > 0:\n            centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max, optimize=optimize)\n            all_centers.append(centers)\n            all_radii.append(radii)\n    \n    if all_centers:\n        centers = np.vstack(all_centers)\n        radii = np.hstack(all_radii)\n    else:\n        centers = np.array([]).reshape(0, 2)\n        radii = np.array([])\n    \n    return centers, radii\n\ndef global_radius_optimization(centers, radii):\n    \"\"\"Globally optimize all radii while keeping centers fixed.\"\"\"\n    n = len(centers)\n    \n    def objective(r_vec):\n        return -np.sum(r_vec)  # Maximize sum of radii\n    \n    def constraint_no_overlap(r_vec):\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - r_vec[i] - r_vec[j])\n        return np.array(constraints)\n    \n    def constraint_boundaries(r_vec):\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - r_vec[i])  # Left\n            constraints.append(1 - centers[i, 0] - r_vec[i])  # Right\n            constraints.append(centers[i, 1] - r_vec[i])  # Bottom\n            constraints.append(1 - centers[i, 1] - r_vec[i])  # Top\n        return np.array(constraints)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_boundaries}\n    ]\n    \n    bounds = [(1e-6, 0.5) for _ in range(n)]\n    \n    try:\n        result = minimize(objective, radii, method='SLSQP', bounds=bounds, \n                         constraints=constraints, options={'maxiter': 200})\n        \n        if result.success and np.sum(result.x) > np.sum(radii) * 0.99:\n            return result.x\n    except:\n        pass\n    \n    return radii\n\ndef construct_packing():\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)",
  "reasoning": "Here's an improved divide-and-conquer approach with adaptive subdivision, local optimization, and boundary refinement:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, differential_evolution\nimport itertools\n\ndef pack_circles_in_region(n_circles, x_min, x_max, y_min, y_max, optimize=True):\n    \"\"\"Pack n circles in a rectangular region using grid layout + optimization.\"\"\"\n    width = x_max - x_min\n    height = y_max - y_min\n    \n    if n_circles == 0:\n        return np.array([]), np.array([])\n    \n    # Find best grid arrangement\n    best_r = 0\n    best_centers = None\n    \n    for nx in range(1, n_circles + 1):\n        ny = (n_circles + nx - 1) // nx\n        if nx * ny < n_circles:\n            continue\n            \n        # Calculate maximum radius for this grid\n        r_x = width / (2 * nx)\n        r_y = height / (2 * ny)\n        r = min(r_x, r_y)\n        \n        if r > best_r:\n            best_r = r\n            centers = []\n            count = 0\n            for i in range(ny):\n                for j in range(nx):\n                    if count >= n_circles:\n                        break\n                    x = x_min + r + j * 2 * r\n                    y = y_min + r + i * 2 * r\n                    centers.append([x, y])\n                    count += 1\n                if count >= n_circles:\n                    break\n            best_centers = np.array(centers)\n    \n    radii = np.full(n_circles, best_r)\n    \n    # Apply local optimization if requested\n    if optimize and n_circles > 1 and n_circles <= 15:\n        centers, radii = optimize_region_packing(best_centers, radii, x_min, x_max, y_min, y_max)\n    \n    return centers, radii\n\ndef optimize_region_packing(centers, radii, x_min, x_max, y_min, y_max, max_iter=100):\n    \"\"\"Optimize circle packing within a region using scipy.\"\"\"\n    n = len(centers)\n    \n    # Initial guess: flatten centers and use uniform radii\n    initial_r = np.min(radii)\n    x0 = np.concatenate([centers.flatten(), [initial_r]])\n    \n    def objective(x):\n        r = x[-1]\n        return -r  # Maximize radius\n    \n    def constraint_no_overlap(x):\n        r = x[-1]\n        centers_opt = x[:-1].reshape(-1, 2)\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                constraints.append(dist - 2 * r)\n        return np.array(constraints)\n    \n    def constraint_boundaries(x):\n        r = x[-1]\n        centers_opt = x[:-1].reshape(-1, 2)\n        constraints = []\n        for i in range(n):\n            constraints.append(centers_opt[i, 0] - r - x_min)  # Left\n            constraints.append(x_max - centers_opt[i, 0] - r)  # Right\n            constraints.append(centers_opt[i, 1] - r - y_min)  # Bottom\n            constraints.append(y_max - centers_opt[i, 1] - r)  # Top\n        return np.array(constraints)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_boundaries}\n    ]\n    \n    # Bounds for optimization\n    bounds = []\n    for i in range(n):\n        bounds.append((x_min, x_max))  # x coordinate\n        bounds.append((y_min, y_max))  # y coordinate\n    bounds.append((1e-6, min(x_max - x_min, y_max - y_min) / 2))  # radius\n    \n    try:\n        result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                         constraints=constraints, options={'maxiter': max_iter})\n        \n        if result.success:\n            optimized_r = result.x[-1]\n            optimized_centers = result.x[:-1].reshape(-1, 2)\n            optimized_radii = np.full(n, optimized_r)\n            \n            # Verify solution is better\n            if optimized_r > initial_r * 0.99:  # Accept if at least 99% of initial\n                return optimized_centers, optimized_radii\n    except:\n        pass\n    \n    return centers, radii\n\ndef pack_irregular_subdivision(n_circles):\n    \"\"\"Pack circles using irregular adaptive subdivision.\"\"\"\n    \n    # Define irregular regions based on optimal partitioning\n    # Try different subdivision strategies\n    strategies = []\n    \n    # Strategy 1: Vertical split with different ratios\n    for ratio in [0.4, 0.5, 0.6]:\n        n_left = int(n_circles * ratio)\n        n_right = n_circles - n_left\n        \n        centers_left, radii_left = pack_circles_in_region(n_left, 0, ratio, 0, 1, optimize=True)\n        centers_right, radii_right = pack_circles_in_region(n_right, ratio, 1, 0, 1, optimize=True)\n        \n        if len(centers_left) > 0 and len(centers_right) > 0:\n            centers = np.vstack([centers_left, centers_right])\n            radii = np.hstack([radii_left, radii_right])\n            strategies.append((centers, radii, np.sum(radii)))\n        elif len(centers_left) > 0:\n            strategies.append((centers_left, radii_left, np.sum(radii_left)))\n        elif len(centers_right) > 0:\n            strategies.append((centers_right, radii_right, np.sum(radii_right)))\n    \n    # Strategy 2: Horizontal split with different ratios\n    for ratio in [0.4, 0.5, 0.6]:\n        n_bottom = int(n_circles * ratio)\n        n_top = n_circles - n_bottom\n        \n        centers_bottom, radii_bottom = pack_circles_in_region(n_bottom, 0, 1, 0, ratio, optimize=True)\n        centers_top, radii_top = pack_circles_in_region(n_top, 0, 1, ratio, 1, optimize=True)\n        \n        if len(centers_bottom) > 0 and len(centers_top) > 0:\n            centers = np.vstack([centers_bottom, centers_top])\n            radii = np.hstack([radii_bottom, radii_top])\n            strategies.append((centers, radii, np.sum(radii)))\n    \n    # Strategy 3: Quadrant split with adaptive allocation\n    allocations = [\n        [7, 7, 6, 6],  # Balanced\n        [8, 7, 6, 5],  # Slightly unbalanced\n        [9, 6, 6, 5],  # More unbalanced\n    ]\n    \n    for alloc in allocations:\n        if sum(alloc) != n_circles:\n            continue\n        \n        regions = [\n            (0.0, 0.5, 0.0, 0.5, alloc[0]),\n            (0.5, 1.0, 0.0, 0.5, alloc[1]),\n            (0.0, 0.5, 0.5, 1.0, alloc[2]),\n            (0.5, 1.0, 0.5, 1.0, alloc[3]),\n        ]\n        \n        all_centers = []\n        all_radii = []\n        \n        for x_min, x_max, y_min, y_max, n in regions:\n            if n > 0:\n                centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max, optimize=True)\n                all_centers.append(centers)\n                all_radii.append(radii)\n        \n        if all_centers:\n            centers = np.vstack(all_centers)\n            radii = np.hstack(all_radii)\n            strategies.append((centers, radii, np.sum(radii)))\n    \n    # Strategy 4: Non-uniform grid (e.g., 2x3 with different sizes)\n    for split_x in [0.4, 0.5, 0.6]:\n        for split_y1 in [0.33, 0.4]:\n            split_y2 = 1 - split_y1\n            \n            regions = [\n                (0.0, split_x, 0.0, split_y1),\n                (split_x, 1.0, 0.0, split_y1),\n                (0.0, split_x, split_y1, split_y2),\n                (split_x, 1.0, split_y1, split_y2),\n                (0.0, split_x, split_y2, 1.0),\n                (split_x, 1.0, split_y2, 1.0),\n            ]\n            \n            # Calculate area-proportional allocation\n            areas = [(x1-x0)*(y1-y0) for x0, x1, y0, y1 in regions]\n            total_area = sum(areas)\n            alloc = [max(1, int(n_circles * a / total_area)) for a in areas]\n            \n            # Adjust to match total\n            while sum(alloc) < n_circles:\n                idx = np.argmax(areas)\n                alloc[idx] += 1\n            while sum(alloc) > n_circles:\n                idx = np.argmax(alloc)\n                if alloc[idx] > 1:\n                    alloc[idx] -= 1\n            \n            all_centers = []\n            all_radii = []\n            \n            for (x_min, x_max, y_min, y_max), n in zip(regions, alloc):\n                if n > 0:\n                    centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max, optimize=False)\n                    all_centers.append(centers)\n                    all_radii.append(radii)\n            \n            if all_centers:\n                centers = np.vstack(all_centers)\n                radii = np.hstack(all_radii)\n                strategies.append((centers, radii, np.sum(radii)))\n    \n    if not strategies:\n        return None, None, 0\n    \n    # Return best strategy\n    best_idx = np.argmax([s[2] for s in strategies])\n    return strategies[best_idx]\n\ndef optimize_boundary_circles(centers, radii):\n    \"\"\"Optimize circles near region boundaries to maximize radii.\"\"\"\n    n = len(centers)\n    \n    # Identify boundary circles (close to edges)\n    boundary_threshold = 0.15\n    boundary_mask = (\n        (centers[:, 0] < boundary_threshold) |\n        (centers[:, 0] > 1 - boundary_threshold) |\n        (centers[:, 1] < boundary_threshold) |\n        (centers[:, 1] > 1 - boundary_threshold)\n    )\n    \n    boundary_indices = np.where(boundary_mask)[0]\n    \n    if len(boundary_indices) == 0:\n        return centers, radii\n    \n    # Try to expand boundary circles\n    for idx in boundary_indices:\n        # Calculate maximum possible radius for this circle\n        max_r = min(\n            centers[idx, 0],  # Distance to left\n            1 - centers[idx, 0],  # Distance to right\n            centers[idx, 1],  # Distance to bottom\n            1 - centers[idx, 1]  # Distance to top\n        )\n        \n        # Check distances to other circles\n        for j in range(n):\n            if j != idx:\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                max_r = min(max_r, dist - radii[j])\n        \n        # Update radius if we can increase it\n        if max_r > radii[idx]:\n            radii[idx] = max_r * 0.99  # Use 99% for safety margin\n    \n    return centers, radii\n\ndef pack_uniform_grid(n_circles, nx, ny, optimize=False):\n    \"\"\"Pack circles using uniform grid subdivision.\"\"\"\n    regions = []\n    for i in range(ny):\n        for j in range(nx):\n            x_min = j / nx\n            x_max = (j + 1) / nx\n            y_min = i / ny\n            y_max = (i + 1) / ny\n            regions.append((x_min, x_max, y_min, y_max))\n    \n    # Distribute circles among regions\n    n_regions = len(regions)\n    base_count = n_circles // n_regions\n    extra = n_circles % n_regions\n    \n    all_centers = []\n    all_radii = []\n    \n    for idx, (x_min, x_max, y_min, y_max) in enumerate(regions):\n        n = base_count + (1 if idx < extra else 0)\n        if n > 0:\n            centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max, optimize=optimize)\n            all_centers.append(centers)\n            all_radii.append(radii)\n    \n    if all_centers:\n        centers = np.vstack(all_centers)\n        radii = np.hstack(all_radii)\n    else:\n        centers = np.array([]).reshape(0, 2)\n        radii = np.array([])\n    \n    return centers, radii\n\ndef global_radius_optimization(centers, radii):\n    \"\"\"Globally optimize all radii while keeping centers fixed.\"\"\"\n    n = len(centers)\n    \n    def objective(r_vec):\n        return -np.sum(r_vec)  # Maximize sum of radii\n    \n    def constraint_no_overlap(r_vec):\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - r_vec[i] - r_vec[j])\n        return np.array(constraints)\n    \n    def constraint_boundaries(r_vec):\n        constraints = []\n        for i in range(n):\n            constraints.append(centers[i, 0] - r_vec[i])  # Left\n            constraints.append(1 - centers[i, 0] - r_vec[i])  # Right\n            constraints.append(centers[i, 1] - r_vec[i])  # Bottom\n            constraints.append(1 - centers[i, 1] - r_vec[i])  # Top\n        return np.array(constraints)\n    \n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_boundaries}\n    ]\n    \n    bounds = [(1e-6, 0.5) for _ in range(n)]\n    \n    try:\n        result = minimize(objective, radii, method='SLSQP', bounds=bounds, \n                         constraints=constraints, options={'maxiter': 200})\n        \n        if result.success and np.sum(result.x) > np.sum(radii) * 0.99:\n            return result.x\n    except:\n        pass\n    \n    return radii\n\ndef construct_packing():\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)",
  "timestamp": "2025-12-08T12:31:23.523842",
  "cost_data": null
}