{
  "trial_id": "trial_0_13",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial import Voronoi, voronoi_plot_2d\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    # Initialize with optimized grid layout for 26 points\n    np.random.seed(42)\n    \n    # Start with a good initial configuration (5x5 grid + 1 extra)\n    grid_size = 6\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xx, yy = np.meshgrid(x, y)\n    initial_points = np.column_stack([xx.ravel(), yy.ravel()])\n    \n    # Take 26 points from the grid\n    indices = np.random.choice(len(initial_points), 26, replace=False)\n    points = initial_points[indices]\n    \n    # Optimize point positions using Lloyd's algorithm (centroidal Voronoi tessellation)\n    for iteration in range(50):\n        centers, radii = compute_circles_from_voronoi(points)\n        points = centers.copy()\n    \n    # Final computation\n    centers, radii = compute_circles_from_voronoi(points)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef compute_circles_from_voronoi(points):\n    \"\"\"\n    Compute circle centers and radii from Voronoi tessellation.\n    \"\"\"\n    n_points = len(points)\n    \n    # Add boundary points to constrain Voronoi to [0,1]x[0,1]\n    boundary_points = create_boundary_points()\n    extended_points = np.vstack([points, boundary_points])\n    \n    # Compute Voronoi tessellation\n    vor = Voronoi(extended_points)\n    \n    centers = np.zeros((n_points, 2))\n    radii = np.zeros(n_points)\n    \n    for i in range(n_points):\n        region_index = vor.point_region[i]\n        vertex_indices = vor.regions[region_index]\n        \n        if -1 in vertex_indices or len(vertex_indices) == 0:\n            # Unbounded region - use original point and small radius\n            centers[i] = points[i]\n            radii[i] = 0.02\n            continue\n        \n        # Get vertices of the Voronoi cell\n        vertices = vor.vertices[vertex_indices]\n        \n        # Clip vertices to [0,1]x[0,1]\n        vertices = clip_polygon_to_square(vertices)\n        \n        if len(vertices) < 3:\n            centers[i] = points[i]\n            radii[i] = 0.02\n            continue\n        \n        # Compute centroid of the clipped polygon\n        centroid = compute_polygon_centroid(vertices)\n        \n        # Ensure centroid is within bounds\n        centroid = np.clip(centroid, 0.01, 0.99)\n        \n        # Compute maximum radius: distance to nearest boundary\n        radius = compute_max_radius(centroid, vertices, points, i)\n        \n        # Ensure circle stays within [0,1]x[0,1]\n        max_radius_boundary = min(\n            centroid[0], 1 - centroid[0],\n            centroid[1], 1 - centroid[1]\n        )\n        radius = min(radius, max_radius_boundary)\n        \n        centers[i] = centroid\n        radii[i] = max(radius, 0.01)  # Minimum radius\n    \n    # Ensure no overlaps\n    radii = resolve_overlaps(centers, radii)\n    \n    return centers, radii\n\ndef create_boundary_points():\n    \"\"\"Create boundary points to constrain Voronoi tessellation.\"\"\"\n    boundary = []\n    n_boundary = 20\n    \n    # Bottom and top edges\n    for x in np.linspace(-0.5, 1.5, n_boundary):\n        boundary.append([x, -0.5])\n        boundary.append([x, 1.5])\n    \n    # Left and right edges\n    for y in np.linspace(-0.5, 1.5, n_boundary):\n        boundary.append([-0.5, y])\n        boundary.append([1.5, y])\n    \n    return np.array(boundary)\n\ndef clip_polygon_to_square(vertices):\n    \"\"\"Clip polygon vertices to [0,1]x[0,1] square.\"\"\"\n    clipped = []\n    for v in vertices:\n        clipped.append(np.clip(v, 0, 1))\n    return np.array(clipped)\n\ndef compute_polygon_centroid(vertices):\n    \"\"\"Compute centroid of a polygon.\"\"\"\n    return np.mean(vertices, axis=0)\n\ndef compute_max_radius(center, vertices, all_points, point_index):\n    \"\"\"Compute maximum radius for a circle centered at 'center'.\"\"\"\n    # Distance to Voronoi cell boundary\n    min_dist_boundary = float('inf')\n    for i in range(len(vertices)):\n        v1 = vertices[i]\n        v2 = vertices[(i + 1) % len(vertices)]\n        dist = point_to_segment_distance(center, v1, v2)\n        min_dist_boundary = min(min_dist_boundary, dist)\n    \n    # Distance to nearest other point (divided by 2 to avoid overlap)\n    min_dist_points = float('inf')\n    for i, p in enumerate(all_points):\n        if i != point_index:\n            dist = np.linalg.norm(center - p) / 2.0\n            min_dist_points = min(min_dist_points, dist)\n    \n    return min(min_dist_boundary, min_dist_points) * 0.95  # Safety factor\n\ndef point_to_segment_distance(point, seg_start, seg_end):\n    \"\"\"Compute distance from point to line segment.\"\"\"\n    seg_vec = seg_end - seg_start\n    point_vec = point - seg_start\n    seg_len = np.linalg.norm(seg_vec)\n    \n    if seg_len < 1e-10:\n        return np.linalg.norm(point_vec)\n    \n    seg_unit = seg_vec / seg_len\n    proj_length = np.dot(point_vec, seg_unit)\n    \n    if proj_length < 0:\n        return np.linalg.norm(point_vec)\n    elif proj_length > seg_len:\n        return np.linalg.norm(point - seg_end)\n    else:\n        proj_point = seg_start + proj_length * seg_unit\n        return np.linalg.norm(point - proj_point)\n\ndef resolve_overlaps(centers, radii):\n    \"\"\"Reduce radii to resolve any overlaps.\"\"\"\n    n = len(centers)\n    radii = radii.copy()\n    \n    for _ in range(10):  # Multiple passes\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                \n                if overlap > 0:\n                    # Reduce both radii proportionally\n                    reduction = (overlap / 2) * 1.05  # Safety factor\n                    radii[i] = max(radii[i] - reduction, 0.01)\n                    radii[j] = max(radii[j] - reduction, 0.01)\n    \n    return radii\n\ndef run_packing():\n    return construct_packing()\n\n# Visualization function\ndef visualize_packing(centers, radii):\n    \"\"\"Visualize the circle packing.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw circles\n    for center, radius in zip(centers, radii):\n        circle = plt.Circle(center, radius, fill=False, edgecolor='blue')\n        ax.add_patch(circle)\n        ax.plot(center[0], center[1], 'ro', markersize=3)\n    \n    # Draw boundary\n    ax.plot([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], 'k-', linewidth=2)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Voronoi-based Circle Packing (26 circles)\\nSum of radii: {np.sum(radii):.4f}')\n    \n    plt.tight_layout()\n    plt.savefig('voronoi_packing.png', dpi=150, bbox_inches='tight')\n    plt.show()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    visualize_packing(centers, radii)",
  "metrics": {
    "valid": true,
    "sum_radii": 1.8457548383615106,
    "target_ratio": 0.7004762194920344,
    "combined_score": 0.7004762194920344,
    "eval_time": 0.7243950366973877,
    "error": null
  },
  "prompt": "Write a Voronoi-based circle packing for 26 circles in a unit square [0,1]x[0,1].\n\nUse Voronoi tessellation to divide the square into regions, then place one circle in each region with radius based on the region's size.\n\nStrategy:\n1. Generate 26 seed points (e.g., random or grid)\n2. Compute Voronoi tessellation\n3. Place circle at centroid of each Voronoi cell\n4. Set radius based on distance to cell boundaries\n5. Optionally iterate to improve\n\nRequirements:\n- All circles must be entirely inside [0,1]x[0,1]\n- No overlaps between circles\n- Maximize sum of radii\n\nInclude these functions:\n```python\nimport numpy as np\nfrom scipy.spatial import Voronoi\n\ndef construct_packing():\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    pass\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial import Voronoi, voronoi_plot_2d\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    # Initialize with optimized grid layout for 26 points\n    np.random.seed(42)\n    \n    # Start with a good initial configuration (5x5 grid + 1 extra)\n    grid_size = 6\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xx, yy = np.meshgrid(x, y)\n    initial_points = np.column_stack([xx.ravel(), yy.ravel()])\n    \n    # Take 26 points from the grid\n    indices = np.random.choice(len(initial_points), 26, replace=False)\n    points = initial_points[indices]\n    \n    # Optimize point positions using Lloyd's algorithm (centroidal Voronoi tessellation)\n    for iteration in range(50):\n        centers, radii = compute_circles_from_voronoi(points)\n        points = centers.copy()\n    \n    # Final computation\n    centers, radii = compute_circles_from_voronoi(points)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef compute_circles_from_voronoi(points):\n    \"\"\"\n    Compute circle centers and radii from Voronoi tessellation.\n    \"\"\"\n    n_points = len(points)\n    \n    # Add boundary points to constrain Voronoi to [0,1]x[0,1]\n    boundary_points = create_boundary_points()\n    extended_points = np.vstack([points, boundary_points])\n    \n    # Compute Voronoi tessellation\n    vor = Voronoi(extended_points)\n    \n    centers = np.zeros((n_points, 2))\n    radii = np.zeros(n_points)\n    \n    for i in range(n_points):\n        region_index = vor.point_region[i]\n        vertex_indices = vor.regions[region_index]\n        \n        if -1 in vertex_indices or len(vertex_indices) == 0:\n            # Unbounded region - use original point and small radius\n            centers[i] = points[i]\n            radii[i] = 0.02\n            continue\n        \n        # Get vertices of the Voronoi cell\n        vertices = vor.vertices[vertex_indices]\n        \n        # Clip vertices to [0,1]x[0,1]\n        vertices = clip_polygon_to_square(vertices)\n        \n        if len(vertices) < 3:\n            centers[i] = points[i]\n            radii[i] = 0.02\n            continue\n        \n        # Compute centroid of the clipped polygon\n        centroid = compute_polygon_centroid(vertices)\n        \n        # Ensure centroid is within bounds\n        centroid = np.clip(centroid, 0.01, 0.99)\n        \n        # Compute maximum radius: distance to nearest boundary\n        radius = compute_max_radius(centroid, vertices, points, i)\n        \n        # Ensure circle stays within [0,1]x[0,1]\n        max_radius_boundary = min(\n            centroid[0], 1 - centroid[0],\n            centroid[1], 1 - centroid[1]\n        )\n        radius = min(radius, max_radius_boundary)\n        \n        centers[i] = centroid\n        radii[i] = max(radius, 0.01)  # Minimum radius\n    \n    # Ensure no overlaps\n    radii = resolve_overlaps(centers, radii)\n    \n    return centers, radii\n\ndef create_boundary_points():\n    \"\"\"Create boundary points to constrain Voronoi tessellation.\"\"\"\n    boundary = []\n    n_boundary = 20\n    \n    # Bottom and top edges\n    for x in np.linspace(-0.5, 1.5, n_boundary):\n        boundary.append([x, -0.5])\n        boundary.append([x, 1.5])\n    \n    # Left and right edges\n    for y in np.linspace(-0.5, 1.5, n_boundary):\n        boundary.append([-0.5, y])\n        boundary.append([1.5, y])\n    \n    return np.array(boundary)\n\ndef clip_polygon_to_square(vertices):\n    \"\"\"Clip polygon vertices to [0,1]x[0,1] square.\"\"\"\n    clipped = []\n    for v in vertices:\n        clipped.append(np.clip(v, 0, 1))\n    return np.array(clipped)\n\ndef compute_polygon_centroid(vertices):\n    \"\"\"Compute centroid of a polygon.\"\"\"\n    return np.mean(vertices, axis=0)\n\ndef compute_max_radius(center, vertices, all_points, point_index):\n    \"\"\"Compute maximum radius for a circle centered at 'center'.\"\"\"\n    # Distance to Voronoi cell boundary\n    min_dist_boundary = float('inf')\n    for i in range(len(vertices)):\n        v1 = vertices[i]\n        v2 = vertices[(i + 1) % len(vertices)]\n        dist = point_to_segment_distance(center, v1, v2)\n        min_dist_boundary = min(min_dist_boundary, dist)\n    \n    # Distance to nearest other point (divided by 2 to avoid overlap)\n    min_dist_points = float('inf')\n    for i, p in enumerate(all_points):\n        if i != point_index:\n            dist = np.linalg.norm(center - p) / 2.0\n            min_dist_points = min(min_dist_points, dist)\n    \n    return min(min_dist_boundary, min_dist_points) * 0.95  # Safety factor\n\ndef point_to_segment_distance(point, seg_start, seg_end):\n    \"\"\"Compute distance from point to line segment.\"\"\"\n    seg_vec = seg_end - seg_start\n    point_vec = point - seg_start\n    seg_len = np.linalg.norm(seg_vec)\n    \n    if seg_len < 1e-10:\n        return np.linalg.norm(point_vec)\n    \n    seg_unit = seg_vec / seg_len\n    proj_length = np.dot(point_vec, seg_unit)\n    \n    if proj_length < 0:\n        return np.linalg.norm(point_vec)\n    elif proj_length > seg_len:\n        return np.linalg.norm(point - seg_end)\n    else:\n        proj_point = seg_start + proj_length * seg_unit\n        return np.linalg.norm(point - proj_point)\n\ndef resolve_overlaps(centers, radii):\n    \"\"\"Reduce radii to resolve any overlaps.\"\"\"\n    n = len(centers)\n    radii = radii.copy()\n    \n    for _ in range(10):  # Multiple passes\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                \n                if overlap > 0:\n                    # Reduce both radii proportionally\n                    reduction = (overlap / 2) * 1.05  # Safety factor\n                    radii[i] = max(radii[i] - reduction, 0.01)\n                    radii[j] = max(radii[j] - reduction, 0.01)\n    \n    return radii\n\ndef run_packing():\n    return construct_packing()\n\n# Visualization function\ndef visualize_packing(centers, radii):\n    \"\"\"Visualize the circle packing.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw circles\n    for center, radius in zip(centers, radii):\n        circle = plt.Circle(center, radius, fill=False, edgecolor='blue')\n        ax.add_patch(circle)\n        ax.plot(center[0], center[1], 'ro', markersize=3)\n    \n    # Draw boundary\n    ax.plot([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], 'k-', linewidth=2)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Voronoi-based Circle Packing (26 circles)\\nSum of radii: {np.sum(radii):.4f}')\n    \n    plt.tight_layout()\n    plt.savefig('voronoi_packing.png', dpi=150, bbox_inches='tight')\n    plt.show()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    visualize_packing(centers, radii)\n```\n\nThis implementation:\n\n1. **Initializes** 26 seed points in a grid pattern\n2. **Uses Lloyd's algorithm** to iteratively move points to Voronoi cell centroids for better distribution\n3. **Computes Voronoi tessellation** with boundary constraints\n4. **Places circles** at cell centroids with radii based on distance to cell boundaries and neighboring points\n5. **Resolves overlaps** to ensure no circles intersect\n6. **Ensures all circles** are within [0,1]x[0,1]\n\nThe algorithm maximizes the sum of radii by using the centroidal Voronoi tessellation, which creates more uniform cell sizes and allows larger circles.",
  "reasoning": "This implementation:\n\n1. **Initializes** 26 seed points in a grid pattern\n2. **Uses Lloyd's algorithm** to iteratively move points to Voronoi cell centroids for better distribution\n3. **Computes Voronoi tessellation** with boundary constraints\n4. **Places circles** at cell centroids with radii based on distance to cell boundaries and neighboring points\n5. **Resolves overlaps** to ensure no circles intersect\n6. **Ensures all circles** are within [0,1]x[0,1]\n\nThe algorithm maximizes the sum of radii by using the centroidal Voronoi tessellation, which creates more uniform cell sizes and allows larger circles.",
  "timestamp": "2025-12-08T12:24:27.711490",
  "cost_data": null
}