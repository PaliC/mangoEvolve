{
  "trial_id": "trial_1_8",
  "generation": 1,
  "parent_id": "trial_0_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial import ConvexHull\n\ndef is_inside_container(x, y):\n    \"\"\"Check if point (x, y) is inside the container.\"\"\"\n    return (abs(x) <= 1 and abs(y) <= 1) or (x**2 + y**2 <= 1)\n\ndef distance_to_boundary(x, y):\n    \"\"\"Calculate minimum distance from point to container boundary.\"\"\"\n    # Check distance to square boundaries\n    dist_square = min(1 - abs(x), 1 - abs(y)) if abs(x) <= 1 and abs(y) <= 1 else -1\n    \n    # Check distance to circle boundary\n    dist_circle = 1 - np.sqrt(x**2 + y**2)\n    \n    # Return maximum (least negative or most positive)\n    return max(dist_square, dist_circle)\n\ndef generate_hexagonal_lattice(spacing):\n    \"\"\"Generate hexagonal lattice points.\"\"\"\n    centers = []\n    \n    # Hexagonal lattice parameters\n    dx = spacing\n    dy = spacing * np.sqrt(3) / 2\n    \n    y = -1.2\n    row = 0\n    while y <= 1.2:\n        x_start = -1.2 if row % 2 == 0 else -1.2 + dx / 2\n        x = x_start\n        while x <= 1.2:\n            if is_inside_container(x, y):\n                centers.append([x, y])\n            x += dx\n        y += dy\n        row += 1\n    \n    return np.array(centers)\n\ndef classify_circles(centers, interior_threshold=0.15):\n    \"\"\"Classify circles as boundary or interior based on distance to boundary.\"\"\"\n    is_interior = []\n    boundary_distances = []\n    \n    for center in centers:\n        dist = distance_to_boundary(center[0], center[1])\n        boundary_distances.append(dist)\n        is_interior.append(dist > interior_threshold)\n    \n    return np.array(is_interior), np.array(boundary_distances)\n\ndef compute_max_radius(center, centers, radii, idx, boundary_dist):\n    \"\"\"Compute maximum allowable radius for a circle.\"\"\"\n    max_r = boundary_dist\n    \n    # Check distance to other circles\n    for i, other_center in enumerate(centers):\n        if i != idx:\n            dist = np.linalg.norm(center - other_center)\n            max_r_from_circle = dist - radii[i]\n            max_r = min(max_r, max_r_from_circle)\n    \n    return max(max_r, 0.001)\n\ndef optimize_radii_iterative(centers, max_iterations=50):\n    \"\"\"Iteratively optimize radii with boundary awareness.\"\"\"\n    n = len(centers)\n    \n    # Classify circles\n    is_interior, boundary_distances = classify_circles(centers)\n    \n    # Initialize radii conservatively\n    radii = np.full(n, 0.05)\n    \n    # Iterative refinement\n    for iteration in range(max_iterations):\n        old_radii = radii.copy()\n        \n        # Sort by interior status (interior first) and boundary distance (furthest first)\n        priority = is_interior.astype(float) * 10 + boundary_distances\n        order = np.argsort(-priority)\n        \n        for idx in order:\n            center = centers[idx]\n            boundary_dist = boundary_distances[idx]\n            \n            # Compute maximum allowable radius\n            max_r = compute_max_radius(center, centers, radii, idx, boundary_dist)\n            \n            # Set radius with some margin for stability\n            radii[idx] = max_r * 0.98\n        \n        # Check convergence\n        if np.allclose(radii, old_radii, rtol=1e-4):\n            break\n    \n    return radii\n\ndef refine_with_optimization(centers, radii):\n    \"\"\"Fine-tune radii using constrained optimization.\"\"\"\n    n = len(centers)\n    _, boundary_distances = classify_circles(centers)\n    \n    def objective(r):\n        return -np.sum(r)  # Maximize sum = minimize negative sum\n    \n    def constraint_boundary(r, idx):\n        return boundary_distances[idx] - r[idx]\n    \n    def constraint_overlap(r, i, j):\n        dist = np.linalg.norm(centers[i] - centers[j])\n        return dist - r[i] - r[j]\n    \n    # Build constraints\n    constraints = []\n    \n    # Boundary constraints\n    for i in range(n):\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda r, idx=i: constraint_boundary(r, idx)\n        })\n    \n    # Overlap constraints (sample to reduce computation)\n    for i in range(n):\n        distances = np.linalg.norm(centers - centers[i], axis=1)\n        nearest_indices = np.argsort(distances)[1:7]  # 6 nearest neighbors\n        for j in nearest_indices:\n            if j > i:\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda r, i=i, j=j: constraint_overlap(r, i, j)\n                })\n    \n    # Bounds\n    bounds = [(0.001, 0.5) for _ in range(n)]\n    \n    # Optimize\n    result = minimize(objective, radii, method='SLSQP', bounds=bounds, \n                     constraints=constraints, options={'maxiter': 100, 'ftol': 1e-6})\n    \n    if result.success:\n        return result.x\n    else:\n        return radii\n\ndef construct_packing():\n    \"\"\"Construct optimized hexagonal packing with boundary-aware radius adjustment.\"\"\"\n    # Try different spacings and pick the best\n    best_sum = 0\n    best_result = None\n    \n    for spacing in [0.18, 0.19, 0.20, 0.21, 0.22]:\n        centers = generate_hexagonal_lattice(spacing)\n        \n        if len(centers) == 0:\n            continue\n        \n        # Optimize radii iteratively\n        radii = optimize_radii_iterative(centers, max_iterations=50)\n        \n        # Refine with optimization\n        radii = refine_with_optimization(centers, radii)\n        \n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_result = (centers, radii, current_sum)\n    \n    return best_result\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 8.55964207649231,
    "error": "Invalid centers shape: (143, 2), expected (26, 2)"
  },
  "prompt": "Create an optimized hexagonal packing with boundary-aware radius adjustment.\n\nStart with hexagonal lattice, then:\n1. Identify circles near boundaries (can be constrained)\n2. Identify interior circles (can be larger)\n3. Optimize radii with these considerations\n4. Use iterative refinement to maximize sum\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Hexagonal base with smart radius optimization\n- Do not print or plot anything",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial import ConvexHull\n\ndef is_inside_container(x, y):\n    \"\"\"Check if point (x, y) is inside the container.\"\"\"\n    return (abs(x) <= 1 and abs(y) <= 1) or (x**2 + y**2 <= 1)\n\ndef distance_to_boundary(x, y):\n    \"\"\"Calculate minimum distance from point to container boundary.\"\"\"\n    # Check distance to square boundaries\n    dist_square = min(1 - abs(x), 1 - abs(y)) if abs(x) <= 1 and abs(y) <= 1 else -1\n    \n    # Check distance to circle boundary\n    dist_circle = 1 - np.sqrt(x**2 + y**2)\n    \n    # Return maximum (least negative or most positive)\n    return max(dist_square, dist_circle)\n\ndef generate_hexagonal_lattice(spacing):\n    \"\"\"Generate hexagonal lattice points.\"\"\"\n    centers = []\n    \n    # Hexagonal lattice parameters\n    dx = spacing\n    dy = spacing * np.sqrt(3) / 2\n    \n    y = -1.2\n    row = 0\n    while y <= 1.2:\n        x_start = -1.2 if row % 2 == 0 else -1.2 + dx / 2\n        x = x_start\n        while x <= 1.2:\n            if is_inside_container(x, y):\n                centers.append([x, y])\n            x += dx\n        y += dy\n        row += 1\n    \n    return np.array(centers)\n\ndef classify_circles(centers, interior_threshold=0.15):\n    \"\"\"Classify circles as boundary or interior based on distance to boundary.\"\"\"\n    is_interior = []\n    boundary_distances = []\n    \n    for center in centers:\n        dist = distance_to_boundary(center[0], center[1])\n        boundary_distances.append(dist)\n        is_interior.append(dist > interior_threshold)\n    \n    return np.array(is_interior), np.array(boundary_distances)\n\ndef compute_max_radius(center, centers, radii, idx, boundary_dist):\n    \"\"\"Compute maximum allowable radius for a circle.\"\"\"\n    max_r = boundary_dist\n    \n    # Check distance to other circles\n    for i, other_center in enumerate(centers):\n        if i != idx:\n            dist = np.linalg.norm(center - other_center)\n            max_r_from_circle = dist - radii[i]\n            max_r = min(max_r, max_r_from_circle)\n    \n    return max(max_r, 0.001)\n\ndef optimize_radii_iterative(centers, max_iterations=50):\n    \"\"\"Iteratively optimize radii with boundary awareness.\"\"\"\n    n = len(centers)\n    \n    # Classify circles\n    is_interior, boundary_distances = classify_circles(centers)\n    \n    # Initialize radii conservatively\n    radii = np.full(n, 0.05)\n    \n    # Iterative refinement\n    for iteration in range(max_iterations):\n        old_radii = radii.copy()\n        \n        # Sort by interior status (interior first) and boundary distance (furthest first)\n        priority = is_interior.astype(float) * 10 + boundary_distances\n        order = np.argsort(-priority)\n        \n        for idx in order:\n            center = centers[idx]\n            boundary_dist = boundary_distances[idx]\n            \n            # Compute maximum allowable radius\n            max_r = compute_max_radius(center, centers, radii, idx, boundary_dist)\n            \n            # Set radius with some margin for stability\n            radii[idx] = max_r * 0.98\n        \n        # Check convergence\n        if np.allclose(radii, old_radii, rtol=1e-4):\n            break\n    \n    return radii\n\ndef refine_with_optimization(centers, radii):\n    \"\"\"Fine-tune radii using constrained optimization.\"\"\"\n    n = len(centers)\n    _, boundary_distances = classify_circles(centers)\n    \n    def objective(r):\n        return -np.sum(r)  # Maximize sum = minimize negative sum\n    \n    def constraint_boundary(r, idx):\n        return boundary_distances[idx] - r[idx]\n    \n    def constraint_overlap(r, i, j):\n        dist = np.linalg.norm(centers[i] - centers[j])\n        return dist - r[i] - r[j]\n    \n    # Build constraints\n    constraints = []\n    \n    # Boundary constraints\n    for i in range(n):\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda r, idx=i: constraint_boundary(r, idx)\n        })\n    \n    # Overlap constraints (sample to reduce computation)\n    for i in range(n):\n        distances = np.linalg.norm(centers - centers[i], axis=1)\n        nearest_indices = np.argsort(distances)[1:7]  # 6 nearest neighbors\n        for j in nearest_indices:\n            if j > i:\n                constraints.append({\n                    'type': 'ineq',\n                    'fun': lambda r, i=i, j=j: constraint_overlap(r, i, j)\n                })\n    \n    # Bounds\n    bounds = [(0.001, 0.5) for _ in range(n)]\n    \n    # Optimize\n    result = minimize(objective, radii, method='SLSQP', bounds=bounds, \n                     constraints=constraints, options={'maxiter': 100, 'ftol': 1e-6})\n    \n    if result.success:\n        return result.x\n    else:\n        return radii\n\ndef construct_packing():\n    \"\"\"Construct optimized hexagonal packing with boundary-aware radius adjustment.\"\"\"\n    # Try different spacings and pick the best\n    best_sum = 0\n    best_result = None\n    \n    for spacing in [0.18, 0.19, 0.20, 0.21, 0.22]:\n        centers = generate_hexagonal_lattice(spacing)\n        \n        if len(centers) == 0:\n            continue\n        \n        # Optimize radii iteratively\n        radii = optimize_radii_iterative(centers, max_iterations=50)\n        \n        # Refine with optimization\n        radii = refine_with_optimization(centers, radii)\n        \n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_result = (centers, radii, current_sum)\n    \n    return best_result\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:38:05.050849",
  "cost_data": null
}