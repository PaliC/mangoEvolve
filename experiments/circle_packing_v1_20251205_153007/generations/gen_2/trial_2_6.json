{
  "trial_id": "trial_2_6",
  "generation": 2,
  "parent_id": "trial_1_9",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct initial packing with adaptive radii based on:\n    1. Distance to boundaries\n    2. Local density of neighbors\n    3. Position in the packing\n    \n    Returns:\n        centers: array of shape (n, 2) with circle centers\n        radii: array of shape (n,) with circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    # Create initial grid of centers\n    n_side = 8\n    spacing = 1.0 / (n_side + 1)\n    x = np.linspace(spacing, 1 - spacing, n_side)\n    y = np.linspace(spacing, 1 - spacing, n_side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.column_stack([xv.ravel(), yv.ravel()])\n    n = len(centers)\n    \n    # Calculate adaptive initial radii\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        cx, cy = centers[i]\n        \n        # 1. Distance to boundaries\n        dist_to_boundary = min(cx, cy, 1 - cx, 1 - cy)\n        \n        # 2. Local density - distance to nearest neighbors\n        distances = cdist([centers[i]], centers)[0]\n        distances[i] = np.inf  # Exclude self\n        nearest_distances = np.sort(distances)[:6]  # 6 nearest neighbors\n        avg_neighbor_dist = np.mean(nearest_distances)\n        \n        # 3. Position in packing - favor center slightly\n        center_dist = np.sqrt((cx - 0.5)**2 + (cy - 0.5)**2)\n        center_factor = 1.0 + 0.1 * (1 - center_dist / 0.707)  # Max distance is ~0.707\n        \n        # Combine factors to get adaptive radius\n        # Start with boundary constraint\n        base_radius = dist_to_boundary * 0.8\n        # Adjust based on neighbor density\n        density_radius = avg_neighbor_dist * 0.4\n        # Take minimum to be conservative\n        adaptive_radius = min(base_radius, density_radius) * center_factor\n        \n        radii[i] = adaptive_radius\n    \n    # Normalize radii to be reasonable\n    radii = np.clip(radii, 0.02, 0.15)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for packing optimization using SLSQP with adaptive initial radii.\n    \n    Returns:\n        centers: optimized circle centers\n        radii: optimized circle radii\n        sum_radii: sum of optimized radii\n    \"\"\"\n    centers, radii_init, _ = construct_packing()\n    n = len(centers)\n    \n    # Optimization variables: radii only (centers are fixed)\n    x0 = radii_init.copy()\n    \n    def objective(r):\n        \"\"\"Negative sum of radii (minimize negative = maximize positive)\"\"\"\n        return -np.sum(r)\n    \n    def constraint_boundary(r):\n        \"\"\"All circles must be inside unit square\"\"\"\n        constraints = []\n        for i in range(n):\n            cx, cy = centers[i]\n            constraints.extend([\n                cx - r[i],  # left boundary\n                cy - r[i],  # bottom boundary\n                1 - cx - r[i],  # right boundary\n                1 - cy - r[i]   # top boundary\n            ])\n        return np.array(constraints)\n    \n    def constraint_nonoverlap(r):\n        \"\"\"Circles must not overlap\"\"\"\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - r[i] - r[j])\n        return np.array(constraints)\n    \n    # Bounds: radii must be positive and reasonable\n    bounds = [(0.001, 0.2) for _ in range(n)]\n    \n    # Constraints in SLSQP format\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_nonoverlap}\n    ]\n    \n    # Run optimization\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    radii_opt = result.x\n    sum_radii = np.sum(radii_opt)\n    \n    return centers, radii_opt, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.5897021293640137,
    "error": "Invalid centers shape: (64, 2), expected (26, 2)"
  },
  "prompt": "Create SLSQP variable radii optimization with adaptive initial radius.\n\nInstead of uniform initial radii, calculate adaptive initial radii based on:\n1. Distance to boundaries\n2. Local density of neighbors\n3. Position in the packing\n\nThen optimize with SLSQP like trial_1_9.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Adaptive initial radii\n- SLSQP optimization\n- Do not print or plot anything",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct initial packing with adaptive radii based on:\n    1. Distance to boundaries\n    2. Local density of neighbors\n    3. Position in the packing\n    \n    Returns:\n        centers: array of shape (n, 2) with circle centers\n        radii: array of shape (n,) with circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    # Create initial grid of centers\n    n_side = 8\n    spacing = 1.0 / (n_side + 1)\n    x = np.linspace(spacing, 1 - spacing, n_side)\n    y = np.linspace(spacing, 1 - spacing, n_side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.column_stack([xv.ravel(), yv.ravel()])\n    n = len(centers)\n    \n    # Calculate adaptive initial radii\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        cx, cy = centers[i]\n        \n        # 1. Distance to boundaries\n        dist_to_boundary = min(cx, cy, 1 - cx, 1 - cy)\n        \n        # 2. Local density - distance to nearest neighbors\n        distances = cdist([centers[i]], centers)[0]\n        distances[i] = np.inf  # Exclude self\n        nearest_distances = np.sort(distances)[:6]  # 6 nearest neighbors\n        avg_neighbor_dist = np.mean(nearest_distances)\n        \n        # 3. Position in packing - favor center slightly\n        center_dist = np.sqrt((cx - 0.5)**2 + (cy - 0.5)**2)\n        center_factor = 1.0 + 0.1 * (1 - center_dist / 0.707)  # Max distance is ~0.707\n        \n        # Combine factors to get adaptive radius\n        # Start with boundary constraint\n        base_radius = dist_to_boundary * 0.8\n        # Adjust based on neighbor density\n        density_radius = avg_neighbor_dist * 0.4\n        # Take minimum to be conservative\n        adaptive_radius = min(base_radius, density_radius) * center_factor\n        \n        radii[i] = adaptive_radius\n    \n    # Normalize radii to be reasonable\n    radii = np.clip(radii, 0.02, 0.15)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for packing optimization using SLSQP with adaptive initial radii.\n    \n    Returns:\n        centers: optimized circle centers\n        radii: optimized circle radii\n        sum_radii: sum of optimized radii\n    \"\"\"\n    centers, radii_init, _ = construct_packing()\n    n = len(centers)\n    \n    # Optimization variables: radii only (centers are fixed)\n    x0 = radii_init.copy()\n    \n    def objective(r):\n        \"\"\"Negative sum of radii (minimize negative = maximize positive)\"\"\"\n        return -np.sum(r)\n    \n    def constraint_boundary(r):\n        \"\"\"All circles must be inside unit square\"\"\"\n        constraints = []\n        for i in range(n):\n            cx, cy = centers[i]\n            constraints.extend([\n                cx - r[i],  # left boundary\n                cy - r[i],  # bottom boundary\n                1 - cx - r[i],  # right boundary\n                1 - cy - r[i]   # top boundary\n            ])\n        return np.array(constraints)\n    \n    def constraint_nonoverlap(r):\n        \"\"\"Circles must not overlap\"\"\"\n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                constraints.append(dist - r[i] - r[j])\n        return np.array(constraints)\n    \n    # Bounds: radii must be positive and reasonable\n    bounds = [(0.001, 0.2) for _ in range(n)]\n    \n    # Constraints in SLSQP format\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_boundary},\n        {'type': 'ineq', 'fun': constraint_nonoverlap}\n    ]\n    \n    # Run optimization\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    radii_opt = result.x\n    sum_radii = np.sum(radii_opt)\n    \n    return centers, radii_opt, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:39:40.054038",
  "cost_data": null
}