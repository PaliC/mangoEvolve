{
  "trial_id": "trial_2_12",
  "generation": 2,
  "parent_id": "trial_1_9",
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom itertools import combinations\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing using trust-region constrained optimization.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Decision variables: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n    n_vars = 3 * n_circles\n    \n    # Initial guess: grid layout with small radii\n    x0 = []\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = 0.1 + col * 0.8 / grid_size\n        y = 0.1 + row * 0.8 / grid_size\n        r = 0.05\n        x0.extend([x, y, r])\n    x0 = np.array(x0)\n    \n    # Objective: maximize sum of radii = minimize negative sum of radii\n    def objective(vars):\n        radii = vars[2::3]\n        return -np.sum(radii)\n    \n    # Gradient of objective\n    def objective_grad(vars):\n        grad = np.zeros(n_vars)\n        grad[2::3] = -1.0\n        return grad\n    \n    # Bounds: x, y in [0, 1], r > 0\n    bounds = []\n    for i in range(n_circles):\n        bounds.append((0.0, 1.0))  # x\n        bounds.append((0.0, 1.0))  # y\n        bounds.append((0.001, 0.5))  # r\n    \n    # Constraints\n    constraints = []\n    \n    # 1. Circle must be inside unit square: x - r >= 0, x + r <= 1, y - r >= 0, y + r <= 1\n    def boundary_constraints(vars):\n        result = []\n        for i in range(n_circles):\n            x = vars[3*i]\n            y = vars[3*i + 1]\n            r = vars[3*i + 2]\n            result.append(x - r)  # left boundary\n            result.append(1.0 - x - r)  # right boundary\n            result.append(y - r)  # bottom boundary\n            result.append(1.0 - y - r)  # top boundary\n        return np.array(result)\n    \n    def boundary_constraints_jac(vars):\n        n_constraints = 4 * n_circles\n        jac = np.zeros((n_constraints, n_vars))\n        for i in range(n_circles):\n            # left boundary: x - r >= 0\n            jac[4*i, 3*i] = 1.0\n            jac[4*i, 3*i + 2] = -1.0\n            # right boundary: 1 - x - r >= 0\n            jac[4*i + 1, 3*i] = -1.0\n            jac[4*i + 1, 3*i + 2] = -1.0\n            # bottom boundary: y - r >= 0\n            jac[4*i + 2, 3*i + 1] = 1.0\n            jac[4*i + 2, 3*i + 2] = -1.0\n            # top boundary: 1 - y - r >= 0\n            jac[4*i + 3, 3*i + 1] = -1.0\n            jac[4*i + 3, 3*i + 2] = -1.0\n        return jac\n    \n    boundary_constraint = NonlinearConstraint(\n        boundary_constraints,\n        0.0,\n        np.inf,\n        jac=boundary_constraints_jac\n    )\n    constraints.append(boundary_constraint)\n    \n    # 2. Non-overlap constraints: distance between centers >= sum of radii\n    pairs = list(combinations(range(n_circles), 2))\n    \n    def overlap_constraints(vars):\n        result = []\n        for i, j in pairs:\n            xi, yi, ri = vars[3*i], vars[3*i + 1], vars[3*i + 2]\n            xj, yj, rj = vars[3*j], vars[3*j + 1], vars[3*j + 2]\n            dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n            result.append(dist - ri - rj)\n        return np.array(result)\n    \n    def overlap_constraints_jac(vars):\n        n_constraints = len(pairs)\n        jac = np.zeros((n_constraints, n_vars))\n        for idx, (i, j) in enumerate(pairs):\n            xi, yi, ri = vars[3*i], vars[3*i + 1], vars[3*i + 2]\n            xj, yj, rj = vars[3*j], vars[3*j + 1], vars[3*j + 2]\n            dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n            if dist > 1e-10:\n                # Gradient w.r.t. xi\n                jac[idx, 3*i] = (xi - xj) / dist\n                # Gradient w.r.t. yi\n                jac[idx, 3*i + 1] = (yi - yj) / dist\n                # Gradient w.r.t. ri\n                jac[idx, 3*i + 2] = -1.0\n                # Gradient w.r.t. xj\n                jac[idx, 3*j] = (xj - xi) / dist\n                # Gradient w.r.t. yj\n                jac[idx, 3*j + 1] = (yj - yi) / dist\n                # Gradient w.r.t. rj\n                jac[idx, 3*j + 2] = -1.0\n        return jac\n    \n    overlap_constraint = NonlinearConstraint(\n        overlap_constraints,\n        0.0,\n        np.inf,\n        jac=overlap_constraints_jac\n    )\n    constraints.append(overlap_constraint)\n    \n    # Optimize using trust-constr\n    result = minimize(\n        objective,\n        x0,\n        method='trust-constr',\n        jac=objective_grad,\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 1000, 'verbose': 0}\n    )\n    \n    # Extract results\n    vars_opt = result.x\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        centers[i, 0] = vars_opt[3*i]\n        centers[i, 1] = vars_opt[3*i + 1]\n        radii[i] = vars_opt[3*i + 2]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.571040607012939,
    "target_ratio": 0.9757269855836581,
    "combined_score": 0.9757269855836581,
    "eval_time": 1.2079198360443115,
    "error": null
  },
  "prompt": "Create a trust-region optimization version of trial_1_9.\n\nUse scipy.optimize.minimize with method='trust-constr' instead of SLSQP:\n1. Same objective: maximize sum of variable radii\n2. Same constraints: boundaries and non-overlap\n3. Trust-region methods can handle constraints better\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use trust-constr method\n- Variable radii for 26 circles\n- Do not print or plot anything",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nfrom itertools import combinations\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing using trust-region constrained optimization.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Decision variables: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n    n_vars = 3 * n_circles\n    \n    # Initial guess: grid layout with small radii\n    x0 = []\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = 0.1 + col * 0.8 / grid_size\n        y = 0.1 + row * 0.8 / grid_size\n        r = 0.05\n        x0.extend([x, y, r])\n    x0 = np.array(x0)\n    \n    # Objective: maximize sum of radii = minimize negative sum of radii\n    def objective(vars):\n        radii = vars[2::3]\n        return -np.sum(radii)\n    \n    # Gradient of objective\n    def objective_grad(vars):\n        grad = np.zeros(n_vars)\n        grad[2::3] = -1.0\n        return grad\n    \n    # Bounds: x, y in [0, 1], r > 0\n    bounds = []\n    for i in range(n_circles):\n        bounds.append((0.0, 1.0))  # x\n        bounds.append((0.0, 1.0))  # y\n        bounds.append((0.001, 0.5))  # r\n    \n    # Constraints\n    constraints = []\n    \n    # 1. Circle must be inside unit square: x - r >= 0, x + r <= 1, y - r >= 0, y + r <= 1\n    def boundary_constraints(vars):\n        result = []\n        for i in range(n_circles):\n            x = vars[3*i]\n            y = vars[3*i + 1]\n            r = vars[3*i + 2]\n            result.append(x - r)  # left boundary\n            result.append(1.0 - x - r)  # right boundary\n            result.append(y - r)  # bottom boundary\n            result.append(1.0 - y - r)  # top boundary\n        return np.array(result)\n    \n    def boundary_constraints_jac(vars):\n        n_constraints = 4 * n_circles\n        jac = np.zeros((n_constraints, n_vars))\n        for i in range(n_circles):\n            # left boundary: x - r >= 0\n            jac[4*i, 3*i] = 1.0\n            jac[4*i, 3*i + 2] = -1.0\n            # right boundary: 1 - x - r >= 0\n            jac[4*i + 1, 3*i] = -1.0\n            jac[4*i + 1, 3*i + 2] = -1.0\n            # bottom boundary: y - r >= 0\n            jac[4*i + 2, 3*i + 1] = 1.0\n            jac[4*i + 2, 3*i + 2] = -1.0\n            # top boundary: 1 - y - r >= 0\n            jac[4*i + 3, 3*i + 1] = -1.0\n            jac[4*i + 3, 3*i + 2] = -1.0\n        return jac\n    \n    boundary_constraint = NonlinearConstraint(\n        boundary_constraints,\n        0.0,\n        np.inf,\n        jac=boundary_constraints_jac\n    )\n    constraints.append(boundary_constraint)\n    \n    # 2. Non-overlap constraints: distance between centers >= sum of radii\n    pairs = list(combinations(range(n_circles), 2))\n    \n    def overlap_constraints(vars):\n        result = []\n        for i, j in pairs:\n            xi, yi, ri = vars[3*i], vars[3*i + 1], vars[3*i + 2]\n            xj, yj, rj = vars[3*j], vars[3*j + 1], vars[3*j + 2]\n            dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n            result.append(dist - ri - rj)\n        return np.array(result)\n    \n    def overlap_constraints_jac(vars):\n        n_constraints = len(pairs)\n        jac = np.zeros((n_constraints, n_vars))\n        for idx, (i, j) in enumerate(pairs):\n            xi, yi, ri = vars[3*i], vars[3*i + 1], vars[3*i + 2]\n            xj, yj, rj = vars[3*j], vars[3*j + 1], vars[3*j + 2]\n            dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n            if dist > 1e-10:\n                # Gradient w.r.t. xi\n                jac[idx, 3*i] = (xi - xj) / dist\n                # Gradient w.r.t. yi\n                jac[idx, 3*i + 1] = (yi - yj) / dist\n                # Gradient w.r.t. ri\n                jac[idx, 3*i + 2] = -1.0\n                # Gradient w.r.t. xj\n                jac[idx, 3*j] = (xj - xi) / dist\n                # Gradient w.r.t. yj\n                jac[idx, 3*j + 1] = (yj - yi) / dist\n                # Gradient w.r.t. rj\n                jac[idx, 3*j + 2] = -1.0\n        return jac\n    \n    overlap_constraint = NonlinearConstraint(\n        overlap_constraints,\n        0.0,\n        np.inf,\n        jac=overlap_constraints_jac\n    )\n    constraints.append(overlap_constraint)\n    \n    # Optimize using trust-constr\n    result = minimize(\n        objective,\n        x0,\n        method='trust-constr',\n        jac=objective_grad,\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 1000, 'verbose': 0}\n    )\n    \n    # Extract results\n    vars_opt = result.x\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        centers[i, 0] = vars_opt[3*i]\n        centers[i, 1] = vars_opt[3*i + 1]\n        radii[i] = vars_opt[3*i + 2]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:39:49.165947",
  "cost_data": null
}