{
  "trial_id": "trial_2_2",
  "generation": 2,
  "parent_id": "trial_1_9",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Multi-start SLSQP optimization for circle packing with variable radii.\n    Returns the best result across multiple starting configurations.\n    \"\"\"\n    \n    def create_hexagonal_start(n_circles=19):\n        \"\"\"Create hexagonal pattern initial guess\"\"\"\n        centers = []\n        radii = []\n        \n        # Hexagonal layers\n        centers.append([0.0, 0.0])\n        radii.append(0.15)\n        \n        # First ring: 6 circles\n        for i in range(6):\n            angle = i * np.pi / 3\n            centers.append([0.3 * np.cos(angle), 0.3 * np.sin(angle)])\n            radii.append(0.12)\n        \n        # Second ring: 12 circles\n        for i in range(12):\n            angle = i * np.pi / 6\n            centers.append([0.55 * np.cos(angle), 0.55 * np.sin(angle)])\n            radii.append(0.10)\n        \n        return np.array(centers[:n_circles]), np.array(radii[:n_circles])\n    \n    def create_grid_start(n_circles=19):\n        \"\"\"Create grid pattern with noise\"\"\"\n        np.random.seed(42)\n        centers = []\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        spacing = 1.8 / (grid_size + 1)\n        \n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n_circles:\n                    break\n                x = -0.9 + (i + 1) * spacing + np.random.uniform(-0.05, 0.05)\n                y = -0.9 + (j + 1) * spacing + np.random.uniform(-0.05, 0.05)\n                centers.append([x, y])\n        \n        centers = np.array(centers[:n_circles])\n        radii = np.full(n_circles, 0.11)\n        return centers, radii\n    \n    def create_random_start(n_circles=19):\n        \"\"\"Create random positions with small uniform radii\"\"\"\n        np.random.seed(123)\n        angles = np.random.uniform(0, 2*np.pi, n_circles)\n        distances = np.random.uniform(0, 0.7, n_circles)\n        \n        centers = np.column_stack([\n            distances * np.cos(angles),\n            distances * np.sin(angles)\n        ])\n        radii = np.full(n_circles, 0.10)\n        return centers, radii\n    \n    def create_perturbed_best(n_circles=19):\n        \"\"\"Create perturbed version of a good known configuration\"\"\"\n        np.random.seed(456)\n        centers, radii = create_hexagonal_start(n_circles)\n        \n        # Add small perturbations\n        centers += np.random.uniform(-0.08, 0.08, centers.shape)\n        radii += np.random.uniform(-0.02, 0.02, radii.shape)\n        radii = np.clip(radii, 0.05, 0.20)\n        \n        return centers, radii\n    \n    def optimize_packing(initial_centers, initial_radii):\n        \"\"\"Run SLSQP optimization from given initial configuration\"\"\"\n        n_circles = len(initial_centers)\n        \n        # Pack variables: [x1, y1, ..., xn, yn, r1, ..., rn]\n        x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n        \n        def objective(x):\n            \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n            radii = x[2*n_circles:]\n            return -np.sum(radii)\n        \n        def constraint_container(x):\n            \"\"\"All circles must be inside container\"\"\"\n            centers = x[:2*n_circles].reshape(n_circles, 2)\n            radii = x[2*n_circles:]\n            \n            distances_from_origin = np.sqrt(centers[:, 0]**2 + centers[:, 1]**2)\n            return 1.0 - (distances_from_origin + radii)\n        \n        def constraint_overlap(x):\n            \"\"\"Circles must not overlap\"\"\"\n            centers = x[:2*n_circles].reshape(n_circles, 2)\n            radii = x[2*n_circles:]\n            \n            constraints = []\n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                 (centers[i, 1] - centers[j, 1])**2)\n                    constraints.append(dist - radii[i] - radii[j])\n            \n            return np.array(constraints)\n        \n        # Bounds: centers in [-1, 1], radii in [0.05, 0.25]\n        bounds = []\n        for _ in range(n_circles):\n            bounds.extend([(-1.0, 1.0), (-1.0, 1.0)])\n        for _ in range(n_circles):\n            bounds.append((0.05, 0.25))\n        \n        # Constraints\n        constraints = [\n            {'type': 'ineq', 'fun': constraint_container},\n            {'type': 'ineq', 'fun': constraint_overlap}\n        ]\n        \n        # Run optimization\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-8}\n        )\n        \n        if result.success:\n            centers = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii = result.x[2*n_circles:]\n            return centers, radii, np.sum(radii), result.success\n        else:\n            return initial_centers, initial_radii, np.sum(initial_radii), False\n    \n    # Run multiple optimizations with different starts\n    n_circles = 19\n    \n    starts = [\n        (\"Hexagonal\", create_hexagonal_start(n_circles)),\n        (\"Grid\", create_grid_start(n_circles)),\n        (\"Random\", create_random_start(n_circles)),\n        (\"Perturbed\", create_perturbed_best(n_circles)),\n    ]\n    \n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    for name, (init_centers, init_radii) in starts:\n        centers, radii, sum_radii, success = optimize_packing(init_centers, init_radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers\n            best_radii = radii\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point for the packing optimization\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.7693681716918945,
    "error": "Invalid centers shape: (19, 2), expected (26, 2)"
  },
  "prompt": "Create a multi-start version of trial_1_9's SLSQP variable radii approach.\n\nRun the optimization from 3-5 different random initial configurations:\n1. Hexagonal pattern (like trial_1_9)\n2. Grid pattern with noise\n3. Random positions with small uniform radii\n4. Perturbed version of trial_1_9's best result\n\nKeep the best result across all starts.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Multiple optimization runs with different starts\n- Same SLSQP structure as trial_1_9\n- Do not print or plot anything",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Multi-start SLSQP optimization for circle packing with variable radii.\n    Returns the best result across multiple starting configurations.\n    \"\"\"\n    \n    def create_hexagonal_start(n_circles=19):\n        \"\"\"Create hexagonal pattern initial guess\"\"\"\n        centers = []\n        radii = []\n        \n        # Hexagonal layers\n        centers.append([0.0, 0.0])\n        radii.append(0.15)\n        \n        # First ring: 6 circles\n        for i in range(6):\n            angle = i * np.pi / 3\n            centers.append([0.3 * np.cos(angle), 0.3 * np.sin(angle)])\n            radii.append(0.12)\n        \n        # Second ring: 12 circles\n        for i in range(12):\n            angle = i * np.pi / 6\n            centers.append([0.55 * np.cos(angle), 0.55 * np.sin(angle)])\n            radii.append(0.10)\n        \n        return np.array(centers[:n_circles]), np.array(radii[:n_circles])\n    \n    def create_grid_start(n_circles=19):\n        \"\"\"Create grid pattern with noise\"\"\"\n        np.random.seed(42)\n        centers = []\n        grid_size = int(np.ceil(np.sqrt(n_circles)))\n        spacing = 1.8 / (grid_size + 1)\n        \n        for i in range(grid_size):\n            for j in range(grid_size):\n                if len(centers) >= n_circles:\n                    break\n                x = -0.9 + (i + 1) * spacing + np.random.uniform(-0.05, 0.05)\n                y = -0.9 + (j + 1) * spacing + np.random.uniform(-0.05, 0.05)\n                centers.append([x, y])\n        \n        centers = np.array(centers[:n_circles])\n        radii = np.full(n_circles, 0.11)\n        return centers, radii\n    \n    def create_random_start(n_circles=19):\n        \"\"\"Create random positions with small uniform radii\"\"\"\n        np.random.seed(123)\n        angles = np.random.uniform(0, 2*np.pi, n_circles)\n        distances = np.random.uniform(0, 0.7, n_circles)\n        \n        centers = np.column_stack([\n            distances * np.cos(angles),\n            distances * np.sin(angles)\n        ])\n        radii = np.full(n_circles, 0.10)\n        return centers, radii\n    \n    def create_perturbed_best(n_circles=19):\n        \"\"\"Create perturbed version of a good known configuration\"\"\"\n        np.random.seed(456)\n        centers, radii = create_hexagonal_start(n_circles)\n        \n        # Add small perturbations\n        centers += np.random.uniform(-0.08, 0.08, centers.shape)\n        radii += np.random.uniform(-0.02, 0.02, radii.shape)\n        radii = np.clip(radii, 0.05, 0.20)\n        \n        return centers, radii\n    \n    def optimize_packing(initial_centers, initial_radii):\n        \"\"\"Run SLSQP optimization from given initial configuration\"\"\"\n        n_circles = len(initial_centers)\n        \n        # Pack variables: [x1, y1, ..., xn, yn, r1, ..., rn]\n        x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n        \n        def objective(x):\n            \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n            radii = x[2*n_circles:]\n            return -np.sum(radii)\n        \n        def constraint_container(x):\n            \"\"\"All circles must be inside container\"\"\"\n            centers = x[:2*n_circles].reshape(n_circles, 2)\n            radii = x[2*n_circles:]\n            \n            distances_from_origin = np.sqrt(centers[:, 0]**2 + centers[:, 1]**2)\n            return 1.0 - (distances_from_origin + radii)\n        \n        def constraint_overlap(x):\n            \"\"\"Circles must not overlap\"\"\"\n            centers = x[:2*n_circles].reshape(n_circles, 2)\n            radii = x[2*n_circles:]\n            \n            constraints = []\n            for i in range(n_circles):\n                for j in range(i+1, n_circles):\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                 (centers[i, 1] - centers[j, 1])**2)\n                    constraints.append(dist - radii[i] - radii[j])\n            \n            return np.array(constraints)\n        \n        # Bounds: centers in [-1, 1], radii in [0.05, 0.25]\n        bounds = []\n        for _ in range(n_circles):\n            bounds.extend([(-1.0, 1.0), (-1.0, 1.0)])\n        for _ in range(n_circles):\n            bounds.append((0.05, 0.25))\n        \n        # Constraints\n        constraints = [\n            {'type': 'ineq', 'fun': constraint_container},\n            {'type': 'ineq', 'fun': constraint_overlap}\n        ]\n        \n        # Run optimization\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-8}\n        )\n        \n        if result.success:\n            centers = result.x[:2*n_circles].reshape(n_circles, 2)\n            radii = result.x[2*n_circles:]\n            return centers, radii, np.sum(radii), result.success\n        else:\n            return initial_centers, initial_radii, np.sum(initial_radii), False\n    \n    # Run multiple optimizations with different starts\n    n_circles = 19\n    \n    starts = [\n        (\"Hexagonal\", create_hexagonal_start(n_circles)),\n        (\"Grid\", create_grid_start(n_circles)),\n        (\"Random\", create_random_start(n_circles)),\n        (\"Perturbed\", create_perturbed_best(n_circles)),\n    ]\n    \n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    \n    for name, (init_centers, init_radii) in starts:\n        centers, radii, sum_radii, success = optimize_packing(init_centers, init_radii)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers\n            best_radii = radii\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point for the packing optimization\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:39:44.201427",
  "cost_data": null
}