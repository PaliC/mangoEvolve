{
  "trial_id": "trial_0_11",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing using force-directed approach.\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize circles with random positions\n    np.random.seed(42)\n    centers = np.random.uniform(0.1, 0.9, size=(n_circles, 2))\n    radii = np.ones(n_circles) * 0.05  # Start with small radii\n    \n    # Simulation parameters\n    n_iterations = 2000\n    dt = 0.01\n    damping = 0.9\n    velocities = np.zeros_like(centers)\n    \n    # Growth and force parameters\n    growth_rate = 0.0005\n    repulsion_strength = 0.1\n    boundary_strength = 0.2\n    \n    for iteration in range(n_iterations):\n        forces = np.zeros_like(centers)\n        \n        # Compute repulsive forces between circles\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist < 1e-6:\n                    # Avoid division by zero\n                    diff = np.random.randn(2) * 0.01\n                    dist = np.linalg.norm(diff)\n                \n                overlap = radii[i] + radii[j] - dist\n                \n                if overlap > 0:\n                    # Circles overlap - apply repulsive force\n                    direction = diff / dist\n                    force_magnitude = repulsion_strength * overlap\n                    forces[i] += direction * force_magnitude\n                    forces[j] -= direction * force_magnitude\n        \n        # Boundary forces to keep circles inside [0,1]x[0,1]\n        for i in range(n_circles):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                overlap = radii[i] - centers[i, 0]\n                forces[i, 0] += boundary_strength * overlap\n            \n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                overlap = centers[i, 0] + radii[i] - 1\n                forces[i, 0] -= boundary_strength * overlap\n            \n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                overlap = radii[i] - centers[i, 1]\n                forces[i, 1] += boundary_strength * overlap\n            \n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                overlap = centers[i, 1] + radii[i] - 1\n                forces[i, 1] -= boundary_strength * overlap\n        \n        # Update velocities and positions\n        velocities = velocities * damping + forces * dt\n        centers += velocities * dt\n        \n        # Keep centers strictly within bounds\n        centers = np.clip(centers, 0, 1)\n        \n        # Try to grow radii if no strong overlaps\n        if iteration % 10 == 0:\n            can_grow = np.ones(n_circles, dtype=bool)\n            \n            # Check for overlaps\n            for i in range(n_circles):\n                # Check boundary constraints\n                if (centers[i, 0] - radii[i] < 0.01 or \n                    centers[i, 0] + radii[i] > 0.99 or\n                    centers[i, 1] - radii[i] < 0.01 or \n                    centers[i, 1] + radii[i] > 0.99):\n                    can_grow[i] = False\n                \n                # Check circle overlaps\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < radii[i] + radii[j] + 0.005:\n                            can_grow[i] = False\n                            break\n            \n            # Grow circles that can grow\n            radii[can_grow] += growth_rate\n            \n            # Ensure minimum radius\n            radii = np.maximum(radii, 0.01)\n    \n    # Final refinement: ensure no overlaps and all circles are within bounds\n    for i in range(n_circles):\n        # Enforce boundary constraints\n        max_radius_x = min(centers[i, 0], 1 - centers[i, 0])\n        max_radius_y = min(centers[i, 1], 1 - centers[i, 1])\n        max_radius_boundary = min(max_radius_x, max_radius_y)\n        \n        # Enforce circle separation constraints\n        max_radius_circles = float('inf')\n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_radius_circles = min(max_radius_circles, dist - radii[j])\n        \n        radii[i] = min(radii[i], max_radius_boundary, max_radius_circles)\n        radii[i] = max(radii[i], 0.005)  # Minimum radius\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for circle packing.\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.1242183491391968,
    "target_ratio": 0.4266483298440975,
    "combined_score": 0.4266483298440975,
    "eval_time": 1.2683207988739014,
    "error": null
  },
  "prompt": "Write a circle packing using a force-directed approach for 26 circles in [0,1]x[0,1].\n\nSimulate physical forces: circles repel each other and are attracted to maximize their radii.\nIterate until equilibrium is reached.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Simulate repulsive forces between overlapping circles\n- Simulate boundary forces to keep circles inside\n- Iterate until forces balance\n- Return proper numpy arrays\n- Do not print or plot anything",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing using force-directed approach.\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize circles with random positions\n    np.random.seed(42)\n    centers = np.random.uniform(0.1, 0.9, size=(n_circles, 2))\n    radii = np.ones(n_circles) * 0.05  # Start with small radii\n    \n    # Simulation parameters\n    n_iterations = 2000\n    dt = 0.01\n    damping = 0.9\n    velocities = np.zeros_like(centers)\n    \n    # Growth and force parameters\n    growth_rate = 0.0005\n    repulsion_strength = 0.1\n    boundary_strength = 0.2\n    \n    for iteration in range(n_iterations):\n        forces = np.zeros_like(centers)\n        \n        # Compute repulsive forces between circles\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist < 1e-6:\n                    # Avoid division by zero\n                    diff = np.random.randn(2) * 0.01\n                    dist = np.linalg.norm(diff)\n                \n                overlap = radii[i] + radii[j] - dist\n                \n                if overlap > 0:\n                    # Circles overlap - apply repulsive force\n                    direction = diff / dist\n                    force_magnitude = repulsion_strength * overlap\n                    forces[i] += direction * force_magnitude\n                    forces[j] -= direction * force_magnitude\n        \n        # Boundary forces to keep circles inside [0,1]x[0,1]\n        for i in range(n_circles):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                overlap = radii[i] - centers[i, 0]\n                forces[i, 0] += boundary_strength * overlap\n            \n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                overlap = centers[i, 0] + radii[i] - 1\n                forces[i, 0] -= boundary_strength * overlap\n            \n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                overlap = radii[i] - centers[i, 1]\n                forces[i, 1] += boundary_strength * overlap\n            \n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                overlap = centers[i, 1] + radii[i] - 1\n                forces[i, 1] -= boundary_strength * overlap\n        \n        # Update velocities and positions\n        velocities = velocities * damping + forces * dt\n        centers += velocities * dt\n        \n        # Keep centers strictly within bounds\n        centers = np.clip(centers, 0, 1)\n        \n        # Try to grow radii if no strong overlaps\n        if iteration % 10 == 0:\n            can_grow = np.ones(n_circles, dtype=bool)\n            \n            # Check for overlaps\n            for i in range(n_circles):\n                # Check boundary constraints\n                if (centers[i, 0] - radii[i] < 0.01 or \n                    centers[i, 0] + radii[i] > 0.99 or\n                    centers[i, 1] - radii[i] < 0.01 or \n                    centers[i, 1] + radii[i] > 0.99):\n                    can_grow[i] = False\n                \n                # Check circle overlaps\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < radii[i] + radii[j] + 0.005:\n                            can_grow[i] = False\n                            break\n            \n            # Grow circles that can grow\n            radii[can_grow] += growth_rate\n            \n            # Ensure minimum radius\n            radii = np.maximum(radii, 0.01)\n    \n    # Final refinement: ensure no overlaps and all circles are within bounds\n    for i in range(n_circles):\n        # Enforce boundary constraints\n        max_radius_x = min(centers[i, 0], 1 - centers[i, 0])\n        max_radius_y = min(centers[i, 1], 1 - centers[i, 1])\n        max_radius_boundary = min(max_radius_x, max_radius_y)\n        \n        # Enforce circle separation constraints\n        max_radius_circles = float('inf')\n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_radius_circles = min(max_radius_circles, dist - radii[j])\n        \n        radii[i] = min(radii[i], max_radius_boundary, max_radius_circles)\n        radii[i] = max(radii[i], 0.005)  # Minimum radius\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for circle packing.\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:31:12.399790",
  "cost_data": null
}