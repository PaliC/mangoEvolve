{
  "trial_id": "trial_0_13",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a circle packing using a genetic algorithm.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    return run_packing()\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Entry point for the genetic algorithm circle packing.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    population_size = 100\n    n_generations = 500\n    tournament_size = 5\n    mutation_rate = 0.1\n    crossover_rate = 0.7\n    \n    # Initialize population\n    population = [create_random_configuration(n_circles) for _ in range(population_size)]\n    \n    best_config = None\n    best_fitness = -np.inf\n    \n    for generation in range(n_generations):\n        # Evaluate fitness for all configurations\n        fitness_scores = [evaluate_fitness(config) for config in population]\n        \n        # Track best configuration\n        gen_best_idx = np.argmax(fitness_scores)\n        if fitness_scores[gen_best_idx] > best_fitness:\n            best_fitness = fitness_scores[gen_best_idx]\n            best_config = population[gen_best_idx].copy()\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism: keep best configuration\n        new_population.append(best_config.copy())\n        \n        while len(new_population) < population_size:\n            # Tournament selection\n            parent1 = tournament_selection(population, fitness_scores, tournament_size)\n            parent2 = tournament_selection(population, fitness_scores, tournament_size)\n            \n            # Crossover\n            if np.random.random() < crossover_rate:\n                child = crossover(parent1, parent2)\n            else:\n                child = parent1.copy()\n            \n            # Mutation\n            if np.random.random() < mutation_rate:\n                child = mutate(child)\n            \n            new_population.append(child)\n        \n        population = new_population\n    \n    # Extract best configuration\n    centers = best_config[:, :2]\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef create_random_configuration(n_circles: int) -> np.ndarray:\n    \"\"\"\n    Create a random configuration of circle centers.\n    \n    Args:\n        n_circles: number of circles\n    \n    Returns:\n        (n_circles, 2) array of center coordinates\n    \"\"\"\n    return np.random.random((n_circles, 2))\n\ndef compute_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute maximum valid radius for each circle given centers.\n    \n    Args:\n        centers: (n, 2) array of circle centers\n    \n    Returns:\n        (n,) array of radii\n    \"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        min_radius = min(\n            centers[i, 0],  # left boundary\n            1 - centers[i, 0],  # right boundary\n            centers[i, 1],  # bottom boundary\n            1 - centers[i, 1]  # top boundary\n        )\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                # Maximum radius is half the distance minus the other circle's radius\n                # We compute iteratively\n                min_radius = min(min_radius, dist)\n        \n        radii[i] = min_radius\n    \n    # Iteratively refine radii considering other circles' radii\n    for _ in range(10):  # Multiple iterations for convergence\n        new_radii = radii.copy()\n        for i in range(n):\n            min_radius = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = dist - radii[j]\n                    min_radius = min(min_radius, max_r)\n            \n            new_radii[i] = max(0, min_radius)\n        \n        radii = new_radii\n    \n    return radii\n\ndef evaluate_fitness(config: np.ndarray) -> float:\n    \"\"\"\n    Evaluate fitness of a configuration (sum of radii with penalties).\n    \n    Args:\n        config: (n, 2) array of circle centers\n    \n    Returns:\n        fitness score\n    \"\"\"\n    centers = config[:, :2]\n    radii = compute_radii(centers)\n    \n    # Base fitness: sum of radii\n    fitness = np.sum(radii)\n    \n    # Penalty for circles too close to boundaries\n    boundary_penalty = 0\n    for i in range(len(centers)):\n        if radii[i] < 0.01:\n            boundary_penalty += 0.1\n    \n    fitness -= boundary_penalty\n    \n    return fitness\n\ndef tournament_selection(population: List[np.ndarray], \n                        fitness_scores: List[float], \n                        tournament_size: int) -> np.ndarray:\n    \"\"\"\n    Select an individual using tournament selection.\n    \n    Args:\n        population: list of configurations\n        fitness_scores: list of fitness scores\n        tournament_size: number of individuals in tournament\n    \n    Returns:\n        selected configuration\n    \"\"\"\n    indices = np.random.choice(len(population), tournament_size, replace=False)\n    tournament_fitness = [fitness_scores[i] for i in indices]\n    winner_idx = indices[np.argmax(tournament_fitness)]\n    return population[winner_idx].copy()\n\ndef crossover(parent1: np.ndarray, parent2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Perform crossover between two parent configurations.\n    \n    Args:\n        parent1: (n, 2) array\n        parent2: (n, 2) array\n    \n    Returns:\n        child configuration\n    \"\"\"\n    n = len(parent1)\n    crossover_point = np.random.randint(1, n)\n    \n    child = np.zeros_like(parent1)\n    child[:crossover_point] = parent1[:crossover_point]\n    child[crossover_point:] = parent2[crossover_point:]\n    \n    return child\n\ndef mutate(config: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Mutate a configuration.\n    \n    Args:\n        config: (n, 2) array\n    \n    Returns:\n        mutated configuration\n    \"\"\"\n    mutated = config.copy()\n    n = len(mutated)\n    \n    # Choose mutation type\n    mutation_type = np.random.choice(['perturb', 'swap', 'random'])\n    \n    if mutation_type == 'perturb':\n        # Perturb random circle positions\n        n_mutate = np.random.randint(1, max(2, n // 5))\n        indices = np.random.choice(n, n_mutate, replace=False)\n        mutated[indices] += np.random.normal(0, 0.1, (n_mutate, 2))\n        mutated[indices] = np.clip(mutated[indices], 0, 1)\n    \n    elif mutation_type == 'swap':\n        # Swap two circles\n        i, j = np.random.choice(n, 2, replace=False)\n        mutated[[i, j]] = mutated[[j, i]]\n    \n    else:  # random\n        # Replace random circle with new random position\n        i = np.random.randint(n)\n        mutated[i] = np.random.random(2)\n    \n    return mutated",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.00924801826477,
    "error": "Timeout after 300s"
  },
  "prompt": "Write a circle packing using a genetic algorithm for 26 circles in [0,1]x[0,1].\n\nEvolve a population of circle configurations over multiple generations.\nUse crossover and mutation to explore the solution space.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Maintain population of configurations\n- Use tournament selection, crossover, and mutation\n- Evolve for fixed number of generations\n- Return best configuration found\n- Do not print or plot anything",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a circle packing using a genetic algorithm.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    return run_packing()\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Entry point for the genetic algorithm circle packing.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    population_size = 100\n    n_generations = 500\n    tournament_size = 5\n    mutation_rate = 0.1\n    crossover_rate = 0.7\n    \n    # Initialize population\n    population = [create_random_configuration(n_circles) for _ in range(population_size)]\n    \n    best_config = None\n    best_fitness = -np.inf\n    \n    for generation in range(n_generations):\n        # Evaluate fitness for all configurations\n        fitness_scores = [evaluate_fitness(config) for config in population]\n        \n        # Track best configuration\n        gen_best_idx = np.argmax(fitness_scores)\n        if fitness_scores[gen_best_idx] > best_fitness:\n            best_fitness = fitness_scores[gen_best_idx]\n            best_config = population[gen_best_idx].copy()\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism: keep best configuration\n        new_population.append(best_config.copy())\n        \n        while len(new_population) < population_size:\n            # Tournament selection\n            parent1 = tournament_selection(population, fitness_scores, tournament_size)\n            parent2 = tournament_selection(population, fitness_scores, tournament_size)\n            \n            # Crossover\n            if np.random.random() < crossover_rate:\n                child = crossover(parent1, parent2)\n            else:\n                child = parent1.copy()\n            \n            # Mutation\n            if np.random.random() < mutation_rate:\n                child = mutate(child)\n            \n            new_population.append(child)\n        \n        population = new_population\n    \n    # Extract best configuration\n    centers = best_config[:, :2]\n    radii = compute_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef create_random_configuration(n_circles: int) -> np.ndarray:\n    \"\"\"\n    Create a random configuration of circle centers.\n    \n    Args:\n        n_circles: number of circles\n    \n    Returns:\n        (n_circles, 2) array of center coordinates\n    \"\"\"\n    return np.random.random((n_circles, 2))\n\ndef compute_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute maximum valid radius for each circle given centers.\n    \n    Args:\n        centers: (n, 2) array of circle centers\n    \n    Returns:\n        (n,) array of radii\n    \"\"\"\n    n = len(centers)\n    radii = np.zeros(n)\n    \n    for i in range(n):\n        # Distance to boundaries\n        min_radius = min(\n            centers[i, 0],  # left boundary\n            1 - centers[i, 0],  # right boundary\n            centers[i, 1],  # bottom boundary\n            1 - centers[i, 1]  # top boundary\n        )\n        \n        # Distance to other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                # Maximum radius is half the distance minus the other circle's radius\n                # We compute iteratively\n                min_radius = min(min_radius, dist)\n        \n        radii[i] = min_radius\n    \n    # Iteratively refine radii considering other circles' radii\n    for _ in range(10):  # Multiple iterations for convergence\n        new_radii = radii.copy()\n        for i in range(n):\n            min_radius = min(\n                centers[i, 0],\n                1 - centers[i, 0],\n                centers[i, 1],\n                1 - centers[i, 1]\n            )\n            \n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = dist - radii[j]\n                    min_radius = min(min_radius, max_r)\n            \n            new_radii[i] = max(0, min_radius)\n        \n        radii = new_radii\n    \n    return radii\n\ndef evaluate_fitness(config: np.ndarray) -> float:\n    \"\"\"\n    Evaluate fitness of a configuration (sum of radii with penalties).\n    \n    Args:\n        config: (n, 2) array of circle centers\n    \n    Returns:\n        fitness score\n    \"\"\"\n    centers = config[:, :2]\n    radii = compute_radii(centers)\n    \n    # Base fitness: sum of radii\n    fitness = np.sum(radii)\n    \n    # Penalty for circles too close to boundaries\n    boundary_penalty = 0\n    for i in range(len(centers)):\n        if radii[i] < 0.01:\n            boundary_penalty += 0.1\n    \n    fitness -= boundary_penalty\n    \n    return fitness\n\ndef tournament_selection(population: List[np.ndarray], \n                        fitness_scores: List[float], \n                        tournament_size: int) -> np.ndarray:\n    \"\"\"\n    Select an individual using tournament selection.\n    \n    Args:\n        population: list of configurations\n        fitness_scores: list of fitness scores\n        tournament_size: number of individuals in tournament\n    \n    Returns:\n        selected configuration\n    \"\"\"\n    indices = np.random.choice(len(population), tournament_size, replace=False)\n    tournament_fitness = [fitness_scores[i] for i in indices]\n    winner_idx = indices[np.argmax(tournament_fitness)]\n    return population[winner_idx].copy()\n\ndef crossover(parent1: np.ndarray, parent2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Perform crossover between two parent configurations.\n    \n    Args:\n        parent1: (n, 2) array\n        parent2: (n, 2) array\n    \n    Returns:\n        child configuration\n    \"\"\"\n    n = len(parent1)\n    crossover_point = np.random.randint(1, n)\n    \n    child = np.zeros_like(parent1)\n    child[:crossover_point] = parent1[:crossover_point]\n    child[crossover_point:] = parent2[crossover_point:]\n    \n    return child\n\ndef mutate(config: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Mutate a configuration.\n    \n    Args:\n        config: (n, 2) array\n    \n    Returns:\n        mutated configuration\n    \"\"\"\n    mutated = config.copy()\n    n = len(mutated)\n    \n    # Choose mutation type\n    mutation_type = np.random.choice(['perturb', 'swap', 'random'])\n    \n    if mutation_type == 'perturb':\n        # Perturb random circle positions\n        n_mutate = np.random.randint(1, max(2, n // 5))\n        indices = np.random.choice(n, n_mutate, replace=False)\n        mutated[indices] += np.random.normal(0, 0.1, (n_mutate, 2))\n        mutated[indices] = np.clip(mutated[indices], 0, 1)\n    \n    elif mutation_type == 'swap':\n        # Swap two circles\n        i, j = np.random.choice(n, 2, replace=False)\n        mutated[[i, j]] = mutated[[j, i]]\n    \n    else:  # random\n        # Replace random circle with new random position\n        i = np.random.randint(n)\n        mutated[i] = np.random.random(2)\n    \n    return mutated\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:36:15.878177",
  "cost_data": null
}