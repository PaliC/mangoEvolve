{
  "trial_id": "trial_0_12",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for 26 circles using divide-and-conquer strategy.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    \n    def pack_circles_in_region(n_circles, x_min, x_max, y_min, y_max):\n        \"\"\"Pack n circles in a rectangular region using grid layout.\"\"\"\n        if n_circles == 0:\n            return np.array([]), np.array([])\n        \n        # Determine grid dimensions\n        aspect_ratio = (x_max - x_min) / (y_max - y_min)\n        cols = int(np.ceil(np.sqrt(n_circles * aspect_ratio)))\n        rows = int(np.ceil(n_circles / cols))\n        \n        # Calculate maximum radius that fits\n        cell_width = (x_max - x_min) / cols\n        cell_height = (y_max - y_min) / rows\n        radius = min(cell_width, cell_height) / 2 * 0.95  # 0.95 for margin\n        \n        centers = []\n        for i in range(n_circles):\n            row = i // cols\n            col = i % cols\n            x = x_min + (col + 0.5) * cell_width\n            y = y_min + (row + 0.5) * cell_height\n            centers.append([x, y])\n        \n        centers = np.array(centers)\n        radii = np.full(n_circles, radius)\n        \n        return centers, radii\n    \n    def evaluate_packing(divisions):\n        \"\"\"Evaluate a packing configuration given division parameters.\"\"\"\n        # Unpack division parameters\n        if len(divisions) == 1:\n            # Vertical split\n            x_split = divisions[0]\n            regions = [\n                (0, x_split, 0, 1),\n                (x_split, 1, 0, 1)\n            ]\n            n_circles_per_region = [13, 13]\n        elif len(divisions) == 2:\n            # Horizontal and vertical split (4 regions)\n            x_split, y_split = divisions\n            regions = [\n                (0, x_split, 0, y_split),\n                (x_split, 1, 0, y_split),\n                (0, x_split, y_split, 1),\n                (x_split, 1, y_split, 1)\n            ]\n            n_circles_per_region = [7, 6, 7, 6]\n        else:\n            # Three regions (custom split)\n            x_split, y_split = divisions\n            regions = [\n                (0, x_split, 0, 1),\n                (x_split, 1, 0, y_split),\n                (x_split, 1, y_split, 1)\n            ]\n            n_circles_per_region = [10, 8, 8]\n        \n        all_centers = []\n        all_radii = []\n        \n        for (x_min, x_max, y_min, y_max), n in zip(regions, n_circles_per_region):\n            centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max)\n            if len(centers) > 0:\n                all_centers.append(centers)\n                all_radii.append(radii)\n        \n        if len(all_centers) == 0:\n            return np.array([]), np.array([]), 0\n        \n        centers = np.vstack(all_centers)\n        radii = np.concatenate(all_radii)\n        \n        return centers, radii, np.sum(radii)\n    \n    def objective(divisions):\n        \"\"\"Objective function to minimize (negative sum of radii).\"\"\"\n        _, _, sum_radii = evaluate_packing(divisions)\n        return -sum_radii\n    \n    # Try different division strategies\n    best_packing = None\n    best_sum = 0\n    \n    # Strategy 1: 4 regions (roughly equal)\n    result = minimize(objective, [0.5, 0.5], bounds=[(0.3, 0.7), (0.3, 0.7)], method='L-BFGS-B')\n    centers, radii, sum_radii = evaluate_packing(result.x)\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_packing = (centers, radii, sum_radii)\n    \n    # Strategy 2: 3 regions (left large, right split)\n    result = minimize(lambda x: objective([x[0], x[1]]), [0.6, 0.5], \n                     bounds=[(0.4, 0.7), (0.3, 0.7)], method='L-BFGS-B')\n    regions = [\n        (0, result.x[0], 0, 1),\n        (result.x[0], 1, 0, result.x[1]),\n        (result.x[0], 1, result.x[1], 1)\n    ]\n    n_circles_per_region = [10, 8, 8]\n    \n    all_centers = []\n    all_radii = []\n    for (x_min, x_max, y_min, y_max), n in zip(regions, n_circles_per_region):\n        centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max)\n        if len(centers) > 0:\n            all_centers.append(centers)\n            all_radii.append(radii)\n    \n    centers = np.vstack(all_centers)\n    radii = np.concatenate(all_radii)\n    sum_radii = np.sum(radii)\n    \n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_packing = (centers, radii, sum_radii)\n    \n    # Strategy 3: Simple 2x3 grid approach\n    centers, radii = pack_circles_in_region(26, 0, 1, 0, 1)\n    sum_radii = np.sum(radii)\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_packing = (centers, radii, sum_radii)\n    \n    return best_packing\n\ndef run_packing():\n    \"\"\"Entry point for circle packing.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.058333333333333,
    "target_ratio": 0.7811511701454775,
    "combined_score": 0.7811511701454775,
    "eval_time": 0.25387072563171387,
    "error": null
  },
  "prompt": "Write a circle packing using a divide-and-conquer strategy for 26 circles in [0,1]x[0,1].\n\nRecursively divide the square into regions and pack circles in each region.\nCombine sub-packings to create the final configuration.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Divide square into 2-4 regions\n- Pack circles in each region independently\n- Optimize division points for best overall packing\n- Return proper numpy arrays\n- Do not print or plot anything",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for 26 circles using divide-and-conquer strategy.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    \n    def pack_circles_in_region(n_circles, x_min, x_max, y_min, y_max):\n        \"\"\"Pack n circles in a rectangular region using grid layout.\"\"\"\n        if n_circles == 0:\n            return np.array([]), np.array([])\n        \n        # Determine grid dimensions\n        aspect_ratio = (x_max - x_min) / (y_max - y_min)\n        cols = int(np.ceil(np.sqrt(n_circles * aspect_ratio)))\n        rows = int(np.ceil(n_circles / cols))\n        \n        # Calculate maximum radius that fits\n        cell_width = (x_max - x_min) / cols\n        cell_height = (y_max - y_min) / rows\n        radius = min(cell_width, cell_height) / 2 * 0.95  # 0.95 for margin\n        \n        centers = []\n        for i in range(n_circles):\n            row = i // cols\n            col = i % cols\n            x = x_min + (col + 0.5) * cell_width\n            y = y_min + (row + 0.5) * cell_height\n            centers.append([x, y])\n        \n        centers = np.array(centers)\n        radii = np.full(n_circles, radius)\n        \n        return centers, radii\n    \n    def evaluate_packing(divisions):\n        \"\"\"Evaluate a packing configuration given division parameters.\"\"\"\n        # Unpack division parameters\n        if len(divisions) == 1:\n            # Vertical split\n            x_split = divisions[0]\n            regions = [\n                (0, x_split, 0, 1),\n                (x_split, 1, 0, 1)\n            ]\n            n_circles_per_region = [13, 13]\n        elif len(divisions) == 2:\n            # Horizontal and vertical split (4 regions)\n            x_split, y_split = divisions\n            regions = [\n                (0, x_split, 0, y_split),\n                (x_split, 1, 0, y_split),\n                (0, x_split, y_split, 1),\n                (x_split, 1, y_split, 1)\n            ]\n            n_circles_per_region = [7, 6, 7, 6]\n        else:\n            # Three regions (custom split)\n            x_split, y_split = divisions\n            regions = [\n                (0, x_split, 0, 1),\n                (x_split, 1, 0, y_split),\n                (x_split, 1, y_split, 1)\n            ]\n            n_circles_per_region = [10, 8, 8]\n        \n        all_centers = []\n        all_radii = []\n        \n        for (x_min, x_max, y_min, y_max), n in zip(regions, n_circles_per_region):\n            centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max)\n            if len(centers) > 0:\n                all_centers.append(centers)\n                all_radii.append(radii)\n        \n        if len(all_centers) == 0:\n            return np.array([]), np.array([]), 0\n        \n        centers = np.vstack(all_centers)\n        radii = np.concatenate(all_radii)\n        \n        return centers, radii, np.sum(radii)\n    \n    def objective(divisions):\n        \"\"\"Objective function to minimize (negative sum of radii).\"\"\"\n        _, _, sum_radii = evaluate_packing(divisions)\n        return -sum_radii\n    \n    # Try different division strategies\n    best_packing = None\n    best_sum = 0\n    \n    # Strategy 1: 4 regions (roughly equal)\n    result = minimize(objective, [0.5, 0.5], bounds=[(0.3, 0.7), (0.3, 0.7)], method='L-BFGS-B')\n    centers, radii, sum_radii = evaluate_packing(result.x)\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_packing = (centers, radii, sum_radii)\n    \n    # Strategy 2: 3 regions (left large, right split)\n    result = minimize(lambda x: objective([x[0], x[1]]), [0.6, 0.5], \n                     bounds=[(0.4, 0.7), (0.3, 0.7)], method='L-BFGS-B')\n    regions = [\n        (0, result.x[0], 0, 1),\n        (result.x[0], 1, 0, result.x[1]),\n        (result.x[0], 1, result.x[1], 1)\n    ]\n    n_circles_per_region = [10, 8, 8]\n    \n    all_centers = []\n    all_radii = []\n    for (x_min, x_max, y_min, y_max), n in zip(regions, n_circles_per_region):\n        centers, radii = pack_circles_in_region(n, x_min, x_max, y_min, y_max)\n        if len(centers) > 0:\n            all_centers.append(centers)\n            all_radii.append(radii)\n    \n    centers = np.vstack(all_centers)\n    radii = np.concatenate(all_radii)\n    sum_radii = np.sum(radii)\n    \n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_packing = (centers, radii, sum_radii)\n    \n    # Strategy 3: Simple 2x3 grid approach\n    centers, radii = pack_circles_in_region(26, 0, 1, 0, 1)\n    sum_radii = np.sum(radii)\n    if sum_radii > best_sum:\n        best_sum = sum_radii\n        best_packing = (centers, radii, sum_radii)\n    \n    return best_packing\n\ndef run_packing():\n    \"\"\"Entry point for circle packing.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:31:12.168517",
  "cost_data": null
}