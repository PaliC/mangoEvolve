{
  "trial_id": "trial_0_14",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Two-phase circle packing for 26 circles in [0,1]x[0,1].\n    \n    Phase 1: Grid-based initial placement\n    Phase 2: Local optimization to maximize radii\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Phase 1: Initial placement on a grid\n    # Use a 6x5 grid (30 positions) and select 26\n    grid_rows = 5\n    grid_cols = 6\n    \n    # Create grid with margins\n    margin = 0.08\n    x_positions = np.linspace(margin, 1 - margin, grid_cols)\n    y_positions = np.linspace(margin, 1 - margin, grid_rows)\n    \n    # Generate all grid positions\n    grid_centers = []\n    for y in y_positions:\n        for x in x_positions:\n            grid_centers.append([x, y])\n    \n    # Take first 26 positions\n    initial_centers = np.array(grid_centers[:n_circles])\n    \n    # Estimate initial radius based on minimum pairwise distance\n    distances = cdist(initial_centers, initial_centers)\n    np.fill_diagonal(distances, np.inf)\n    min_dist = np.min(distances)\n    initial_radius = min_dist / 2.5  # Conservative estimate\n    \n    # Phase 2: Local optimization\n    # Optimize positions and a shared radius multiplier\n    def objective(x):\n        # x contains: [centers (52 values), radius_multiplier (1 value)]\n        centers = x[:52].reshape(26, 2)\n        radius_mult = x[52]\n        radius = initial_radius * radius_mult\n        \n        # Maximize sum of radii = maximize radius (since all equal)\n        # Minimize negative radius\n        return -radius\n    \n    def constraints_func(x):\n        centers = x[:52].reshape(26, 2)\n        radius_mult = x[52]\n        radius = initial_radius * radius_mult\n        \n        constraints = []\n        \n        # 1. Circles must be inside [0,1]x[0,1]\n        for i in range(26):\n            constraints.append(centers[i, 0] - radius)  # left\n            constraints.append(1 - centers[i, 0] - radius)  # right\n            constraints.append(centers[i, 1] - radius)  # bottom\n            constraints.append(1 - centers[i, 1] - radius)  # top\n        \n        # 2. Circles must not overlap\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - 2 * radius)\n        \n        # 3. Radius must be positive\n        constraints.append(radius_mult)\n        \n        return np.array(constraints)\n    \n    # Initial guess\n    x0 = np.concatenate([initial_centers.flatten(), [1.0]])\n    \n    # Bounds\n    bounds = [(0, 1) for _ in range(52)] + [(0.1, 5.0)]  # centers + radius multiplier\n    \n    # Constraint dictionary\n    constraint_dict = {\n        'type': 'ineq',\n        'fun': constraints_func\n    }\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraint_dict,\n        options={'maxiter': 500, 'ftol': 1e-8}\n    )\n    \n    # Extract results\n    optimized_centers = result.x[:52].reshape(26, 2)\n    optimized_radius_mult = result.x[52]\n    optimized_radius = initial_radius * optimized_radius_mult\n    \n    # Create radii array (all equal in this approach)\n    radii = np.full(n_circles, optimized_radius)\n    \n    # Ensure constraints are satisfied (clamp if needed)\n    optimized_centers = np.clip(optimized_centers, optimized_radius, 1 - optimized_radius)\n    \n    # Verify and adjust if any violations\n    distances = cdist(optimized_centers, optimized_centers)\n    np.fill_diagonal(distances, np.inf)\n    min_pair_dist = np.min(distances)\n    \n    if min_pair_dist < 2 * optimized_radius:\n        # Reduce radius slightly to ensure no overlap\n        optimized_radius = min_pair_dist / 2.01\n        radii = np.full(n_circles, optimized_radius)\n    \n    sum_radii = np.sum(radii)\n    \n    return optimized_centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for circle packing.\n    \n    Returns:\n        centers: numpy array of shape (26, 2)\n        radii: numpy array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.155887225466117,
    "target_ratio": 0.8181735201009933,
    "combined_score": 0.8181735201009933,
    "eval_time": 0.308516263961792,
    "error": null
  },
  "prompt": "Write a circle packing using a two-phase approach for 26 circles in [0,1]x[0,1].\n\nPhase 1: Find good positions using a fast heuristic (e.g., grid or greedy)\nPhase 2: Refine with local optimization to maximize radii\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Phase 1: Quick initial placement\n- Phase 2: Local optimization (scipy.optimize)\n- Ensure all constraints satisfied\n- Return proper numpy arrays\n- Do not print or plot anything",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Two-phase circle packing for 26 circles in [0,1]x[0,1].\n    \n    Phase 1: Grid-based initial placement\n    Phase 2: Local optimization to maximize radii\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Phase 1: Initial placement on a grid\n    # Use a 6x5 grid (30 positions) and select 26\n    grid_rows = 5\n    grid_cols = 6\n    \n    # Create grid with margins\n    margin = 0.08\n    x_positions = np.linspace(margin, 1 - margin, grid_cols)\n    y_positions = np.linspace(margin, 1 - margin, grid_rows)\n    \n    # Generate all grid positions\n    grid_centers = []\n    for y in y_positions:\n        for x in x_positions:\n            grid_centers.append([x, y])\n    \n    # Take first 26 positions\n    initial_centers = np.array(grid_centers[:n_circles])\n    \n    # Estimate initial radius based on minimum pairwise distance\n    distances = cdist(initial_centers, initial_centers)\n    np.fill_diagonal(distances, np.inf)\n    min_dist = np.min(distances)\n    initial_radius = min_dist / 2.5  # Conservative estimate\n    \n    # Phase 2: Local optimization\n    # Optimize positions and a shared radius multiplier\n    def objective(x):\n        # x contains: [centers (52 values), radius_multiplier (1 value)]\n        centers = x[:52].reshape(26, 2)\n        radius_mult = x[52]\n        radius = initial_radius * radius_mult\n        \n        # Maximize sum of radii = maximize radius (since all equal)\n        # Minimize negative radius\n        return -radius\n    \n    def constraints_func(x):\n        centers = x[:52].reshape(26, 2)\n        radius_mult = x[52]\n        radius = initial_radius * radius_mult\n        \n        constraints = []\n        \n        # 1. Circles must be inside [0,1]x[0,1]\n        for i in range(26):\n            constraints.append(centers[i, 0] - radius)  # left\n            constraints.append(1 - centers[i, 0] - radius)  # right\n            constraints.append(centers[i, 1] - radius)  # bottom\n            constraints.append(1 - centers[i, 1] - radius)  # top\n        \n        # 2. Circles must not overlap\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                constraints.append(dist - 2 * radius)\n        \n        # 3. Radius must be positive\n        constraints.append(radius_mult)\n        \n        return np.array(constraints)\n    \n    # Initial guess\n    x0 = np.concatenate([initial_centers.flatten(), [1.0]])\n    \n    # Bounds\n    bounds = [(0, 1) for _ in range(52)] + [(0.1, 5.0)]  # centers + radius multiplier\n    \n    # Constraint dictionary\n    constraint_dict = {\n        'type': 'ineq',\n        'fun': constraints_func\n    }\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraint_dict,\n        options={'maxiter': 500, 'ftol': 1e-8}\n    )\n    \n    # Extract results\n    optimized_centers = result.x[:52].reshape(26, 2)\n    optimized_radius_mult = result.x[52]\n    optimized_radius = initial_radius * optimized_radius_mult\n    \n    # Create radii array (all equal in this approach)\n    radii = np.full(n_circles, optimized_radius)\n    \n    # Ensure constraints are satisfied (clamp if needed)\n    optimized_centers = np.clip(optimized_centers, optimized_radius, 1 - optimized_radius)\n    \n    # Verify and adjust if any violations\n    distances = cdist(optimized_centers, optimized_centers)\n    np.fill_diagonal(distances, np.inf)\n    min_pair_dist = np.min(distances)\n    \n    if min_pair_dist < 2 * optimized_radius:\n        # Reduce radius slightly to ensure no overlap\n        optimized_radius = min_pair_dist / 2.01\n        radii = np.full(n_circles, optimized_radius)\n    \n    sum_radii = np.sum(radii)\n    \n    return optimized_centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for circle packing.\n    \n    Returns:\n        centers: numpy array of shape (26, 2)\n        radii: numpy array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:31:11.970417",
  "cost_data": null
}