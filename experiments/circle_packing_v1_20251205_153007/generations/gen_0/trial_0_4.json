{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing of 26 circles in [0,1]x[0,1] using simulated annealing.\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    np.random.seed(42)\n    \n    # Initialize random configuration\n    centers = np.random.rand(n_circles, 2)\n    radii = np.full(n_circles, 0.05)\n    \n    # Simulated annealing parameters\n    initial_temp = 1.0\n    final_temp = 1e-6\n    cooling_rate = 0.9995\n    max_iterations = 50000\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration satisfies all constraints\"\"\"\n        # Check boundary constraints\n        if np.any(centers[:, 0] - radii < 0) or np.any(centers[:, 0] + radii > 1):\n            return False\n        if np.any(centers[:, 1] - radii < 0) or np.any(centers[:, 1] + radii > 1):\n            return False\n        \n        # Check circle overlap constraints\n        for i in range(len(radii)):\n            for j in range(i + 1, len(radii)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    return False\n        return True\n    \n    def energy(radii):\n        \"\"\"Energy function: negative sum of radii (we want to maximize sum)\"\"\"\n        return -np.sum(radii)\n    \n    def perturb_configuration(centers, radii, temp):\n        \"\"\"Generate a neighbor configuration\"\"\"\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Choose random perturbation type\n        choice = np.random.rand()\n        \n        if choice < 0.4:\n            # Move a random circle\n            idx = np.random.randint(n_circles)\n            step_size = 0.1 * temp\n            new_centers[idx] += np.random.randn(2) * step_size\n            new_centers[idx] = np.clip(new_centers[idx], 0, 1)\n        elif choice < 0.7:\n            # Change radius of a random circle\n            idx = np.random.randint(n_circles)\n            step_size = 0.05 * temp\n            new_radii[idx] += np.random.randn() * step_size\n            new_radii[idx] = np.clip(new_radii[idx], 0.001, 0.5)\n        else:\n            # Change all radii uniformly\n            scale = 1.0 + np.random.randn() * 0.02 * temp\n            new_radii *= scale\n            new_radii = np.clip(new_radii, 0.001, 0.5)\n        \n        return new_centers, new_radii\n    \n    # Ensure initial configuration is valid\n    while not is_valid(centers, radii):\n        centers = np.random.rand(n_circles, 2)\n        radii = np.full(n_circles, 0.03)\n    \n    current_energy = energy(radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_energy = current_energy\n    \n    temp = initial_temp\n    \n    for iteration in range(max_iterations):\n        # Generate neighbor configuration\n        new_centers, new_radii = perturb_configuration(centers, radii, temp)\n        \n        # Check if valid\n        if is_valid(new_centers, new_radii):\n            new_energy = energy(new_radii)\n            delta_energy = new_energy - current_energy\n            \n            # Accept or reject based on Metropolis criterion\n            if delta_energy < 0 or np.random.rand() < np.exp(-delta_energy / temp):\n                centers = new_centers\n                radii = new_radii\n                current_energy = new_energy\n                \n                # Update best solution\n                if current_energy < best_energy:\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    best_energy = current_energy\n        \n        # Cool down\n        temp *= cooling_rate\n        \n        if temp < final_temp:\n            break\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for circle packing optimization.\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 0.9959403885777394,
    "target_ratio": 0.3779659918701099,
    "combined_score": 0.3779659918701099,
    "eval_time": 12.429512977600098,
    "error": null
  },
  "prompt": "Write a simulated annealing circle packing for 26 circles in [0,1]x[0,1].\n\nUse simulated annealing to optimize circle positions and radii.\nStart with random configuration and iteratively improve through random perturbations.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Implement simulated annealing with temperature schedule\n- Accept/reject moves based on energy (sum of radii)\n- Ensure constraints are satisfied\n- Return proper numpy arrays\n- Do not print or plot anything",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing of 26 circles in [0,1]x[0,1] using simulated annealing.\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    np.random.seed(42)\n    \n    # Initialize random configuration\n    centers = np.random.rand(n_circles, 2)\n    radii = np.full(n_circles, 0.05)\n    \n    # Simulated annealing parameters\n    initial_temp = 1.0\n    final_temp = 1e-6\n    cooling_rate = 0.9995\n    max_iterations = 50000\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration satisfies all constraints\"\"\"\n        # Check boundary constraints\n        if np.any(centers[:, 0] - radii < 0) or np.any(centers[:, 0] + radii > 1):\n            return False\n        if np.any(centers[:, 1] - radii < 0) or np.any(centers[:, 1] + radii > 1):\n            return False\n        \n        # Check circle overlap constraints\n        for i in range(len(radii)):\n            for j in range(i + 1, len(radii)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    return False\n        return True\n    \n    def energy(radii):\n        \"\"\"Energy function: negative sum of radii (we want to maximize sum)\"\"\"\n        return -np.sum(radii)\n    \n    def perturb_configuration(centers, radii, temp):\n        \"\"\"Generate a neighbor configuration\"\"\"\n        new_centers = centers.copy()\n        new_radii = radii.copy()\n        \n        # Choose random perturbation type\n        choice = np.random.rand()\n        \n        if choice < 0.4:\n            # Move a random circle\n            idx = np.random.randint(n_circles)\n            step_size = 0.1 * temp\n            new_centers[idx] += np.random.randn(2) * step_size\n            new_centers[idx] = np.clip(new_centers[idx], 0, 1)\n        elif choice < 0.7:\n            # Change radius of a random circle\n            idx = np.random.randint(n_circles)\n            step_size = 0.05 * temp\n            new_radii[idx] += np.random.randn() * step_size\n            new_radii[idx] = np.clip(new_radii[idx], 0.001, 0.5)\n        else:\n            # Change all radii uniformly\n            scale = 1.0 + np.random.randn() * 0.02 * temp\n            new_radii *= scale\n            new_radii = np.clip(new_radii, 0.001, 0.5)\n        \n        return new_centers, new_radii\n    \n    # Ensure initial configuration is valid\n    while not is_valid(centers, radii):\n        centers = np.random.rand(n_circles, 2)\n        radii = np.full(n_circles, 0.03)\n    \n    current_energy = energy(radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_energy = current_energy\n    \n    temp = initial_temp\n    \n    for iteration in range(max_iterations):\n        # Generate neighbor configuration\n        new_centers, new_radii = perturb_configuration(centers, radii, temp)\n        \n        # Check if valid\n        if is_valid(new_centers, new_radii):\n            new_energy = energy(new_radii)\n            delta_energy = new_energy - current_energy\n            \n            # Accept or reject based on Metropolis criterion\n            if delta_energy < 0 or np.random.rand() < np.exp(-delta_energy / temp):\n                centers = new_centers\n                radii = new_radii\n                current_energy = new_energy\n                \n                # Update best solution\n                if current_energy < best_energy:\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n                    best_energy = current_energy\n        \n        # Cool down\n        temp *= cooling_rate\n        \n        if temp < final_temp:\n            break\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for circle packing optimization.\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:31:19.738617",
  "cost_data": null
}