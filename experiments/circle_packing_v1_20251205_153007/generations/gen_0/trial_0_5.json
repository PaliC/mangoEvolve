{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing using largest circle first approach.\n    \n    Returns:\n        centers: np.array of shape (n, 2) with circle centers\n        radii: np.array of shape (n,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    centers = []\n    radii = []\n    \n    # Start with the largest possible circle\n    # The largest circle that fits in [0,1]x[0,1] has radius 0.5 centered at (0.5, 0.5)\n    first_radius = 0.5\n    centers.append([0.5, 0.5])\n    radii.append(first_radius)\n    \n    # Add remaining circles\n    for i in range(1, n_circles):\n        # Try to find the largest circle that fits\n        best_center, best_radius = find_largest_circle(centers, radii)\n        centers.append(best_center)\n        radii.append(best_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef find_largest_circle(existing_centers, existing_radii):\n    \"\"\"\n    Find the largest circle that can fit without overlapping existing circles\n    and staying within [0,1]x[0,1].\n    \"\"\"\n    existing_centers = np.array(existing_centers)\n    existing_radii = np.array(existing_radii)\n    \n    best_radius = 0\n    best_center = None\n    \n    # Try multiple candidate positions\n    # Sample grid points\n    grid_size = 20\n    for x in np.linspace(0, 1, grid_size):\n        for y in np.linspace(0, 1, grid_size):\n            candidate = np.array([x, y])\n            max_r = compute_max_radius(candidate, existing_centers, existing_radii)\n            if max_r > best_radius:\n                best_radius = max_r\n                best_center = candidate\n    \n    # Also try positions near existing circles (tangent positions)\n    for i, center in enumerate(existing_centers):\n        r = existing_radii[i]\n        # Try positions around this circle\n        for angle in np.linspace(0, 2*np.pi, 16):\n            for dist_factor in [0.5, 0.7, 0.9, 1.1, 1.3]:\n                offset = dist_factor * r * np.array([np.cos(angle), np.sin(angle)])\n                candidate = center + offset\n                if 0 <= candidate[0] <= 1 and 0 <= candidate[1] <= 1:\n                    max_r = compute_max_radius(candidate, existing_centers, existing_radii)\n                    if max_r > best_radius:\n                        best_radius = max_r\n                        best_center = candidate\n    \n    # Try optimization-based approach for the best candidate\n    if best_center is not None:\n        # Refine using optimization\n        def objective(pos):\n            return -compute_max_radius(pos, existing_centers, existing_radii)\n        \n        result = differential_evolution(\n            objective,\n            bounds=[(0, 1), (0, 1)],\n            seed=42,\n            maxiter=100,\n            popsize=10,\n            atol=1e-6,\n            tol=1e-6\n        )\n        \n        optimized_center = result.x\n        optimized_radius = compute_max_radius(optimized_center, existing_centers, existing_radii)\n        \n        if optimized_radius > best_radius:\n            best_radius = optimized_radius\n            best_center = optimized_center\n    \n    # Ensure minimum radius\n    if best_radius < 1e-6:\n        best_radius = 1e-6\n        if best_center is None:\n            best_center = np.array([0.5, 0.5])\n    \n    return best_center, best_radius\n\n\ndef compute_max_radius(center, existing_centers, existing_radii):\n    \"\"\"\n    Compute the maximum radius for a circle at given center\n    without overlapping existing circles and staying in [0,1]x[0,1].\n    \"\"\"\n    x, y = center\n    \n    # Distance to boundaries\n    dist_to_boundaries = min(x, y, 1-x, 1-y)\n    \n    if dist_to_boundaries <= 0:\n        return 0\n    \n    max_radius = dist_to_boundaries\n    \n    # Distance to existing circles\n    if len(existing_centers) > 0:\n        distances = np.sqrt(np.sum((existing_centers - center)**2, axis=1))\n        min_distances = distances - existing_radii\n        \n        if len(min_distances) > 0:\n            max_radius = min(max_radius, np.min(min_distances))\n    \n    return max(0, max_radius)\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for circle packing.\n    \n    Returns:\n        centers: np.array of shape (n, 2) with circle centers\n        radii: np.array of shape (n,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.4700046676968623,
    "target_ratio": 0.5578765342303084,
    "combined_score": 0.5578765342303084,
    "eval_time": 1.1312429904937744,
    "error": null
  },
  "prompt": "Write a circle packing using the largest circle first approach for 26 circles in [0,1]x[0,1].\n\nStart by placing the largest possible circle, then iteratively add smaller circles in remaining space.\nUse a decreasing radius strategy to pack efficiently.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Place circles in decreasing size order\n- Find best position for each new circle\n- Ensure no overlaps and all inside square\n- Return proper numpy arrays\n- Do not print or plot anything",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing using largest circle first approach.\n    \n    Returns:\n        centers: np.array of shape (n, 2) with circle centers\n        radii: np.array of shape (n,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    centers = []\n    radii = []\n    \n    # Start with the largest possible circle\n    # The largest circle that fits in [0,1]x[0,1] has radius 0.5 centered at (0.5, 0.5)\n    first_radius = 0.5\n    centers.append([0.5, 0.5])\n    radii.append(first_radius)\n    \n    # Add remaining circles\n    for i in range(1, n_circles):\n        # Try to find the largest circle that fits\n        best_center, best_radius = find_largest_circle(centers, radii)\n        centers.append(best_center)\n        radii.append(best_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef find_largest_circle(existing_centers, existing_radii):\n    \"\"\"\n    Find the largest circle that can fit without overlapping existing circles\n    and staying within [0,1]x[0,1].\n    \"\"\"\n    existing_centers = np.array(existing_centers)\n    existing_radii = np.array(existing_radii)\n    \n    best_radius = 0\n    best_center = None\n    \n    # Try multiple candidate positions\n    # Sample grid points\n    grid_size = 20\n    for x in np.linspace(0, 1, grid_size):\n        for y in np.linspace(0, 1, grid_size):\n            candidate = np.array([x, y])\n            max_r = compute_max_radius(candidate, existing_centers, existing_radii)\n            if max_r > best_radius:\n                best_radius = max_r\n                best_center = candidate\n    \n    # Also try positions near existing circles (tangent positions)\n    for i, center in enumerate(existing_centers):\n        r = existing_radii[i]\n        # Try positions around this circle\n        for angle in np.linspace(0, 2*np.pi, 16):\n            for dist_factor in [0.5, 0.7, 0.9, 1.1, 1.3]:\n                offset = dist_factor * r * np.array([np.cos(angle), np.sin(angle)])\n                candidate = center + offset\n                if 0 <= candidate[0] <= 1 and 0 <= candidate[1] <= 1:\n                    max_r = compute_max_radius(candidate, existing_centers, existing_radii)\n                    if max_r > best_radius:\n                        best_radius = max_r\n                        best_center = candidate\n    \n    # Try optimization-based approach for the best candidate\n    if best_center is not None:\n        # Refine using optimization\n        def objective(pos):\n            return -compute_max_radius(pos, existing_centers, existing_radii)\n        \n        result = differential_evolution(\n            objective,\n            bounds=[(0, 1), (0, 1)],\n            seed=42,\n            maxiter=100,\n            popsize=10,\n            atol=1e-6,\n            tol=1e-6\n        )\n        \n        optimized_center = result.x\n        optimized_radius = compute_max_radius(optimized_center, existing_centers, existing_radii)\n        \n        if optimized_radius > best_radius:\n            best_radius = optimized_radius\n            best_center = optimized_center\n    \n    # Ensure minimum radius\n    if best_radius < 1e-6:\n        best_radius = 1e-6\n        if best_center is None:\n            best_center = np.array([0.5, 0.5])\n    \n    return best_center, best_radius\n\n\ndef compute_max_radius(center, existing_centers, existing_radii):\n    \"\"\"\n    Compute the maximum radius for a circle at given center\n    without overlapping existing circles and staying in [0,1]x[0,1].\n    \"\"\"\n    x, y = center\n    \n    # Distance to boundaries\n    dist_to_boundaries = min(x, y, 1-x, 1-y)\n    \n    if dist_to_boundaries <= 0:\n        return 0\n    \n    max_radius = dist_to_boundaries\n    \n    # Distance to existing circles\n    if len(existing_centers) > 0:\n        distances = np.sqrt(np.sum((existing_centers - center)**2, axis=1))\n        min_distances = distances - existing_radii\n        \n        if len(min_distances) > 0:\n            max_radius = min(max_radius, np.min(min_distances))\n    \n    return max(0, max_radius)\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for circle packing.\n    \n    Returns:\n        centers: np.array of shape (n, 2) with circle centers\n        radii: np.array of shape (n,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()\n\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:31:10.756154",
  "cost_data": null
}