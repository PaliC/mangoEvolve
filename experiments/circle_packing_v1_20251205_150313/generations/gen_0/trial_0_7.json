{
  "trial_id": "trial_0_7",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Hierarchical packing of 26 circles in [0,1]x[0,1].\n    \n    Strategy:\n    - Tier 1: 4 large circles in corners\n    - Tier 2: 9 medium circles in gaps\n    - Tier 3: 13 small circles filling remaining spaces\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Tier 1: Large circles (4 circles)\n    # Place in corners with optimal radius\n    large_radius = 0.17\n    large_positions = [\n        (large_radius, large_radius),\n        (1 - large_radius, large_radius),\n        (large_radius, 1 - large_radius),\n        (1 - large_radius, 1 - large_radius)\n    ]\n    \n    for pos in large_positions:\n        centers.append(pos)\n        radii.append(large_radius)\n    \n    # Tier 2: Medium circles (9 circles)\n    # Place along edges and center\n    medium_radius = 0.095\n    medium_positions = [\n        # Edge midpoints\n        (0.5, medium_radius),\n        (0.5, 1 - medium_radius),\n        (medium_radius, 0.5),\n        (1 - medium_radius, 0.5),\n        # Center\n        (0.5, 0.5),\n        # Diagonal positions between large circles\n        (0.35, 0.35),\n        (0.65, 0.35),\n        (0.35, 0.65),\n        (0.65, 0.65)\n    ]\n    \n    for pos in medium_positions:\n        if is_valid_placement(pos, medium_radius, centers, radii):\n            centers.append(pos)\n            radii.append(medium_radius)\n    \n    # Tier 3: Small circles (13 circles)\n    # Fill remaining gaps using a grid-based search\n    small_radius = 0.055\n    \n    # Generate candidate positions in a fine grid\n    grid_size = 20\n    candidates = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = (i + 0.5) / grid_size\n            y = (j + 0.5) / grid_size\n            candidates.append((x, y))\n    \n    # Score each candidate by distance to existing circles (prefer gaps)\n    scored_candidates = []\n    for pos in candidates:\n        if is_valid_placement(pos, small_radius, centers, radii):\n            # Score: minimum distance to existing circles (higher is better)\n            min_dist = min_distance_to_circles(pos, centers, radii)\n            scored_candidates.append((min_dist, pos))\n    \n    # Sort by score (descending) and take best positions\n    scored_candidates.sort(reverse=True)\n    \n    small_count = 0\n    target_small = 26 - len(centers)\n    \n    for score, pos in scored_candidates:\n        if small_count >= target_small:\n            break\n        if is_valid_placement(pos, small_radius, centers, radii):\n            centers.append(pos)\n            radii.append(small_radius)\n            small_count += 1\n    \n    # Convert to numpy arrays\n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef is_valid_placement(pos: Tuple[float, float], radius: float, \n                       existing_centers: List, existing_radii: List) -> bool:\n    \"\"\"\n    Check if a circle can be placed without overlapping existing circles or boundaries.\n    \"\"\"\n    x, y = pos\n    \n    # Check boundary constraints\n    if x - radius < 0 or x + radius > 1:\n        return False\n    if y - radius < 0 or y + radius > 1:\n        return False\n    \n    # Check overlap with existing circles\n    for center, r in zip(existing_centers, existing_radii):\n        dist = np.sqrt((x - center[0])**2 + (y - center[1])**2)\n        if dist < radius + r - 1e-6:  # Small tolerance\n            return False\n    \n    return True\n\n\ndef min_distance_to_circles(pos: Tuple[float, float], \n                            centers: List, radii: List) -> float:\n    \"\"\"\n    Calculate minimum distance from position to surface of existing circles.\n    \"\"\"\n    if not centers:\n        return float('inf')\n    \n    x, y = pos\n    min_dist = float('inf')\n    \n    for center, r in zip(centers, radii):\n        dist = np.sqrt((x - center[0])**2 + (y - center[1])**2)\n        surface_dist = dist - r\n        min_dist = min(min_dist, surface_dist)\n    \n    return min_dist\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the packing algorithm.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Hierarchical Packing Results:\")\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"\\nRadius distribution:\")\n    print(f\"  Large circles (r={radii[0]:.3f}): {np.sum(radii > 0.15)}\")\n    print(f\"  Medium circles (r\u22480.095): {np.sum((radii > 0.08) & (radii < 0.12))}\")\n    print(f\"  Small circles (r\u22480.055): {np.sum(radii < 0.08)}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.06533503532409668,
    "error": "Invalid centers shape: (21, 2), expected (26, 2)"
  },
  "prompt": "Write a hierarchical packing algorithm for 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Pack a few large circles first (e.g., 4-6 circles)\n2. Pack medium circles in remaining gaps\n3. Pack small circles in final gaps\n4. This creates a multi-scale packing\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Use 3 size tiers: large, medium, small\n- Optimize placement at each tier\n- Ensure total is 26 circles\n- Define run_packing() as entry point\n- Import numpy as np",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Hierarchical packing of 26 circles in [0,1]x[0,1].\n    \n    Strategy:\n    - Tier 1: 4 large circles in corners\n    - Tier 2: 9 medium circles in gaps\n    - Tier 3: 13 small circles filling remaining spaces\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Tier 1: Large circles (4 circles)\n    # Place in corners with optimal radius\n    large_radius = 0.17\n    large_positions = [\n        (large_radius, large_radius),\n        (1 - large_radius, large_radius),\n        (large_radius, 1 - large_radius),\n        (1 - large_radius, 1 - large_radius)\n    ]\n    \n    for pos in large_positions:\n        centers.append(pos)\n        radii.append(large_radius)\n    \n    # Tier 2: Medium circles (9 circles)\n    # Place along edges and center\n    medium_radius = 0.095\n    medium_positions = [\n        # Edge midpoints\n        (0.5, medium_radius),\n        (0.5, 1 - medium_radius),\n        (medium_radius, 0.5),\n        (1 - medium_radius, 0.5),\n        # Center\n        (0.5, 0.5),\n        # Diagonal positions between large circles\n        (0.35, 0.35),\n        (0.65, 0.35),\n        (0.35, 0.65),\n        (0.65, 0.65)\n    ]\n    \n    for pos in medium_positions:\n        if is_valid_placement(pos, medium_radius, centers, radii):\n            centers.append(pos)\n            radii.append(medium_radius)\n    \n    # Tier 3: Small circles (13 circles)\n    # Fill remaining gaps using a grid-based search\n    small_radius = 0.055\n    \n    # Generate candidate positions in a fine grid\n    grid_size = 20\n    candidates = []\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = (i + 0.5) / grid_size\n            y = (j + 0.5) / grid_size\n            candidates.append((x, y))\n    \n    # Score each candidate by distance to existing circles (prefer gaps)\n    scored_candidates = []\n    for pos in candidates:\n        if is_valid_placement(pos, small_radius, centers, radii):\n            # Score: minimum distance to existing circles (higher is better)\n            min_dist = min_distance_to_circles(pos, centers, radii)\n            scored_candidates.append((min_dist, pos))\n    \n    # Sort by score (descending) and take best positions\n    scored_candidates.sort(reverse=True)\n    \n    small_count = 0\n    target_small = 26 - len(centers)\n    \n    for score, pos in scored_candidates:\n        if small_count >= target_small:\n            break\n        if is_valid_placement(pos, small_radius, centers, radii):\n            centers.append(pos)\n            radii.append(small_radius)\n            small_count += 1\n    \n    # Convert to numpy arrays\n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef is_valid_placement(pos: Tuple[float, float], radius: float, \n                       existing_centers: List, existing_radii: List) -> bool:\n    \"\"\"\n    Check if a circle can be placed without overlapping existing circles or boundaries.\n    \"\"\"\n    x, y = pos\n    \n    # Check boundary constraints\n    if x - radius < 0 or x + radius > 1:\n        return False\n    if y - radius < 0 or y + radius > 1:\n        return False\n    \n    # Check overlap with existing circles\n    for center, r in zip(existing_centers, existing_radii):\n        dist = np.sqrt((x - center[0])**2 + (y - center[1])**2)\n        if dist < radius + r - 1e-6:  # Small tolerance\n            return False\n    \n    return True\n\n\ndef min_distance_to_circles(pos: Tuple[float, float], \n                            centers: List, radii: List) -> float:\n    \"\"\"\n    Calculate minimum distance from position to surface of existing circles.\n    \"\"\"\n    if not centers:\n        return float('inf')\n    \n    x, y = pos\n    min_dist = float('inf')\n    \n    for center, r in zip(centers, radii):\n        dist = np.sqrt((x - center[0])**2 + (y - center[1])**2)\n        surface_dist = dist - r\n        min_dist = min(min_dist, surface_dist)\n    \n    return min_dist\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the packing algorithm.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Hierarchical Packing Results:\")\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"\\nRadius distribution:\")\n    print(f\"  Large circles (r={radii[0]:.3f}): {np.sum(radii > 0.15)}\")\n    print(f\"  Medium circles (r\u22480.095): {np.sum((radii > 0.08) & (radii < 0.12))}\")\n    print(f\"  Small circles (r\u22480.055): {np.sum(radii < 0.08)}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```\n\nThis hierarchical packing algorithm:\n\n1. **Tier 1 (Large)**: Places 4 large circles (r=0.17) in the corners\n2. **Tier 2 (Medium)**: Places 9 medium circles (r=0.095) along edges, center, and diagonal positions\n3. **Tier 3 (Small)**: Places 13 small circles (r=0.055) in remaining gaps using a grid-based search that prioritizes positions furthest from existing circles\n\nThe algorithm ensures no overlaps by checking all constraints before placement and uses a greedy approach at each tier to maximize space utilization.",
  "reasoning": "This hierarchical packing algorithm:\n\n1. **Tier 1 (Large)**: Places 4 large circles (r=0.17) in the corners\n2. **Tier 2 (Medium)**: Places 9 medium circles (r=0.095) along edges, center, and diagonal positions\n3. **Tier 3 (Small)**: Places 13 small circles (r=0.055) in remaining gaps using a grid-based search that prioritizes positions furthest from existing circles\n\nThe algorithm ensures no overlaps by checking all constraints before placement and uses a greedy approach at each tier to maximize space utilization.",
  "timestamp": "2025-12-05T15:04:13.374054",
  "cost_data": null
}