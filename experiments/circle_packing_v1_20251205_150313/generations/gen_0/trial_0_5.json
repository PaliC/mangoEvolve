{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Boundary-first packing algorithm for 26 circles in [0,1]x[0,1].\n    \n    Strategy:\n    1. Place 4 circles at corners (largest)\n    2. Place 8 circles along edges (medium-large)\n    3. Place 14 circles in interior (smaller, optimized layout)\n    \n    Returns:\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Step 1: Corner circles (4 circles)\n    # These can be larger since they use the corner space efficiently\n    corner_radius = 0.09\n    corner_offset = corner_radius  # Distance from corner\n    \n    corners = [\n        (corner_offset, corner_offset),  # Bottom-left\n        (1 - corner_offset, corner_offset),  # Bottom-right\n        (1 - corner_offset, 1 - corner_offset),  # Top-right\n        (corner_offset, 1 - corner_offset),  # Top-left\n    ]\n    \n    for corner in corners:\n        centers.append(corner)\n        radii.append(corner_radius)\n    \n    # Step 2: Edge circles (8 circles, 2 per edge)\n    # Place between corners, slightly smaller than corner circles\n    edge_radius = 0.075\n    \n    # Bottom edge (2 circles)\n    for i in range(2):\n        x = 0.25 + i * 0.5\n        centers.append((x, edge_radius))\n        radii.append(edge_radius)\n    \n    # Top edge (2 circles)\n    for i in range(2):\n        x = 0.25 + i * 0.5\n        centers.append((x, 1 - edge_radius))\n        radii.append(edge_radius)\n    \n    # Left edge (2 circles)\n    for i in range(2):\n        y = 0.25 + i * 0.5\n        centers.append((edge_radius, y))\n        radii.append(edge_radius)\n    \n    # Right edge (2 circles)\n    for i in range(2):\n        y = 0.25 + i * 0.5\n        centers.append((1 - edge_radius, y))\n        radii.append(edge_radius)\n    \n    # Step 3: Interior circles (14 circles)\n    # Use a grid-like pattern with varying radii based on density\n    interior_radius = 0.065\n    \n    # Create a 4x4 grid pattern in the interior region, selecting 14 positions\n    interior_margin = 0.20\n    grid_positions = []\n    \n    # Generate grid points\n    for i in range(4):\n        for j in range(4):\n            x = interior_margin + (1 - 2 * interior_margin) * i / 3\n            y = interior_margin + (1 - 2 * interior_margin) * j / 3\n            grid_positions.append((x, y))\n    \n    # Select 14 positions that are well-distributed\n    # Remove 2 positions from the grid to get 14 circles\n    selected_indices = [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 15]\n    \n    for idx in selected_indices:\n        x, y = grid_positions[idx]\n        centers.append((x, y))\n        \n        # Vary interior radii slightly based on position\n        # Central circles can be slightly larger\n        dist_from_center = np.sqrt((x - 0.5)**2 + (y - 0.5)**2)\n        radius_adjustment = 0.01 * (1 - dist_from_center * 2)\n        radii.append(interior_radius + radius_adjustment)\n    \n    # Convert to numpy arrays\n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Optimization: Fine-tune positions to maximize radii while avoiding overlaps\n    centers, radii = optimize_packing(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef optimize_packing(centers, radii, iterations=100):\n    \"\"\"\n    Optimize the packing by adjusting radii to maximize sum while ensuring no overlaps.\n    \n    Args:\n        centers: Initial center positions\n        radii: Initial radii\n        iterations: Number of optimization iterations\n    \n    Returns:\n        centers: Optimized centers (unchanged in this simple version)\n        radii: Optimized radii\n    \"\"\"\n    n = len(centers)\n    optimized_radii = radii.copy()\n    \n    for _ in range(iterations):\n        # For each circle, compute maximum possible radius\n        for i in range(n):\n            max_radius = optimized_radii[i]\n            \n            # Check boundary constraints\n            x, y = centers[i]\n            max_radius = min(max_radius, x, y, 1 - x, 1 - y)\n            \n            # Check overlap constraints with other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_allowed = dist - optimized_radii[j]\n                    max_radius = min(max_radius, max_allowed)\n            \n            # Grow radius slightly if possible (conservative growth)\n            optimized_radii[i] = min(max_radius * 0.99, optimized_radii[i] * 1.01)\n    \n    return centers, optimized_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the packing algorithm.\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    # Verify packing validity\n    n = len(centers)\n    assert n == 26, f\"Expected 26 circles, got {n}\"\n    \n    # Check boundary constraints\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        assert r <= x <= 1 - r, f\"Circle {i} violates x-boundary\"\n        assert r <= y <= 1 - r, f\"Circle {i} violates y-boundary\"\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            assert dist >= min_dist - 1e-6, f\"Circles {i} and {j} overlap\"\n    \n    print(f\"Successfully packed 26 circles\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {sum_radii / 26:.6f}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 0.6788140756134909,
    "target_ratio": 0.25761444994819394,
    "combined_score": 0.25761444994819394,
    "eval_time": 0.1602921485900879,
    "error": null
  },
  "prompt": "Write a boundary-first packing algorithm for 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Place circles along the boundary of the square first (corners, edges)\n2. These boundary circles can be larger since they're constrained by fewer neighbors\n3. Fill interior space with remaining circles\n4. Optimize radii based on available space\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Place 12-16 circles on boundary, rest in interior\n- Vary radii based on position\n- Ensure no overlaps\n- Define run_packing() as entry point\n- Import numpy as np",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Boundary-first packing algorithm for 26 circles in [0,1]x[0,1].\n    \n    Strategy:\n    1. Place 4 circles at corners (largest)\n    2. Place 8 circles along edges (medium-large)\n    3. Place 14 circles in interior (smaller, optimized layout)\n    \n    Returns:\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Step 1: Corner circles (4 circles)\n    # These can be larger since they use the corner space efficiently\n    corner_radius = 0.09\n    corner_offset = corner_radius  # Distance from corner\n    \n    corners = [\n        (corner_offset, corner_offset),  # Bottom-left\n        (1 - corner_offset, corner_offset),  # Bottom-right\n        (1 - corner_offset, 1 - corner_offset),  # Top-right\n        (corner_offset, 1 - corner_offset),  # Top-left\n    ]\n    \n    for corner in corners:\n        centers.append(corner)\n        radii.append(corner_radius)\n    \n    # Step 2: Edge circles (8 circles, 2 per edge)\n    # Place between corners, slightly smaller than corner circles\n    edge_radius = 0.075\n    \n    # Bottom edge (2 circles)\n    for i in range(2):\n        x = 0.25 + i * 0.5\n        centers.append((x, edge_radius))\n        radii.append(edge_radius)\n    \n    # Top edge (2 circles)\n    for i in range(2):\n        x = 0.25 + i * 0.5\n        centers.append((x, 1 - edge_radius))\n        radii.append(edge_radius)\n    \n    # Left edge (2 circles)\n    for i in range(2):\n        y = 0.25 + i * 0.5\n        centers.append((edge_radius, y))\n        radii.append(edge_radius)\n    \n    # Right edge (2 circles)\n    for i in range(2):\n        y = 0.25 + i * 0.5\n        centers.append((1 - edge_radius, y))\n        radii.append(edge_radius)\n    \n    # Step 3: Interior circles (14 circles)\n    # Use a grid-like pattern with varying radii based on density\n    interior_radius = 0.065\n    \n    # Create a 4x4 grid pattern in the interior region, selecting 14 positions\n    interior_margin = 0.20\n    grid_positions = []\n    \n    # Generate grid points\n    for i in range(4):\n        for j in range(4):\n            x = interior_margin + (1 - 2 * interior_margin) * i / 3\n            y = interior_margin + (1 - 2 * interior_margin) * j / 3\n            grid_positions.append((x, y))\n    \n    # Select 14 positions that are well-distributed\n    # Remove 2 positions from the grid to get 14 circles\n    selected_indices = [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 15]\n    \n    for idx in selected_indices:\n        x, y = grid_positions[idx]\n        centers.append((x, y))\n        \n        # Vary interior radii slightly based on position\n        # Central circles can be slightly larger\n        dist_from_center = np.sqrt((x - 0.5)**2 + (y - 0.5)**2)\n        radius_adjustment = 0.01 * (1 - dist_from_center * 2)\n        radii.append(interior_radius + radius_adjustment)\n    \n    # Convert to numpy arrays\n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Optimization: Fine-tune positions to maximize radii while avoiding overlaps\n    centers, radii = optimize_packing(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef optimize_packing(centers, radii, iterations=100):\n    \"\"\"\n    Optimize the packing by adjusting radii to maximize sum while ensuring no overlaps.\n    \n    Args:\n        centers: Initial center positions\n        radii: Initial radii\n        iterations: Number of optimization iterations\n    \n    Returns:\n        centers: Optimized centers (unchanged in this simple version)\n        radii: Optimized radii\n    \"\"\"\n    n = len(centers)\n    optimized_radii = radii.copy()\n    \n    for _ in range(iterations):\n        # For each circle, compute maximum possible radius\n        for i in range(n):\n            max_radius = optimized_radii[i]\n            \n            # Check boundary constraints\n            x, y = centers[i]\n            max_radius = min(max_radius, x, y, 1 - x, 1 - y)\n            \n            # Check overlap constraints with other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_allowed = dist - optimized_radii[j]\n                    max_radius = min(max_radius, max_allowed)\n            \n            # Grow radius slightly if possible (conservative growth)\n            optimized_radii[i] = min(max_radius * 0.99, optimized_radii[i] * 1.01)\n    \n    return centers, optimized_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the packing algorithm.\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    # Verify packing validity\n    n = len(centers)\n    assert n == 26, f\"Expected 26 circles, got {n}\"\n    \n    # Check boundary constraints\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        assert r <= x <= 1 - r, f\"Circle {i} violates x-boundary\"\n        assert r <= y <= 1 - r, f\"Circle {i} violates y-boundary\"\n    \n    # Check overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            assert dist >= min_dist - 1e-6, f\"Circles {i} and {j} overlap\"\n    \n    print(f\"Successfully packed 26 circles\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {sum_radii / 26:.6f}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```\n\nThis implementation follows a boundary-first strategy:\n\n1. **Corner circles (4)**: Placed at corners with radius 0.09, taking advantage of corner space\n2. **Edge circles (8)**: Two per edge with radius 0.075, positioned between corners\n3. **Interior circles (14)**: Grid-based layout with radius ~0.065, with slight variations based on distance from center\n\nThe algorithm includes an optimization phase that attempts to grow radii while maintaining constraints. The packing achieves a good balance between boundary and interior coverage, with larger circles on the boundary where they have more freedom.",
  "reasoning": "This implementation follows a boundary-first strategy:\n\n1. **Corner circles (4)**: Placed at corners with radius 0.09, taking advantage of corner space\n2. **Edge circles (8)**: Two per edge with radius 0.075, positioned between corners\n3. **Interior circles (14)**: Grid-based layout with radius ~0.065, with slight variations based on distance from center\n\nThe algorithm includes an optimization phase that attempts to grow radii while maintaining constraints. The packing achieves a good balance between boundary and interior coverage, with larger circles on the boundary where they have more freedom.",
  "timestamp": "2025-12-05T15:04:19.883266",
  "cost_data": null
}