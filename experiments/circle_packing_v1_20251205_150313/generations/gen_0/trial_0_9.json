{
  "trial_id": "trial_0_9",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing(individual):\n    \"\"\"\n    Construct packing from individual representation.\n    \n    Args:\n        individual: array of length 78 (26*3: x, y, radius for each circle)\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    individual = np.array(individual)\n    centers = individual[:52].reshape(26, 2)\n    radii = individual[52:]\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef check_constraints(centers, radii):\n    \"\"\"\n    Check if packing satisfies constraints.\n    \n    Returns:\n        penalty: constraint violation penalty (0 if valid)\n    \"\"\"\n    penalty = 0.0\n    \n    # Check boundary constraints\n    for i in range(len(centers)):\n        x, y = centers[i]\n        r = radii[i]\n        \n        # Circles must be inside [0,1]x[0,1]\n        if x - r < 0:\n            penalty += (0 - (x - r)) ** 2\n        if x + r > 1:\n            penalty += ((x + r) - 1) ** 2\n        if y - r < 0:\n            penalty += (0 - (y - r)) ** 2\n        if y + r > 1:\n            penalty += ((y + r) - 1) ** 2\n    \n    # Check non-overlapping constraints\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            \n            if dist < min_dist:\n                penalty += (min_dist - dist) ** 2\n    \n    return penalty\n\n\ndef fitness(individual):\n    \"\"\"\n    Fitness function: maximize sum of radii, penalize constraint violations.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing(individual)\n    penalty = check_constraints(centers, radii)\n    \n    # Fitness = sum of radii - large penalty for violations\n    return sum_radii - 1000 * penalty\n\n\ndef initialize_population(pop_size, n_circles=26):\n    \"\"\"\n    Initialize population with random packings.\n    \"\"\"\n    population = []\n    \n    for _ in range(pop_size):\n        # Random positions in [0,1]x[0,1]\n        positions = np.random.uniform(0, 1, size=(n_circles, 2))\n        \n        # Random small radii to start\n        radii = np.random.uniform(0.01, 0.1, size=n_circles)\n        \n        # Flatten into individual\n        individual = np.concatenate([positions.flatten(), radii])\n        population.append(individual)\n    \n    return population\n\n\ndef tournament_selection(population, fitnesses, tournament_size=3):\n    \"\"\"\n    Select an individual using tournament selection.\n    \"\"\"\n    indices = np.random.choice(len(population), size=tournament_size, replace=False)\n    tournament_fitnesses = [fitnesses[i] for i in indices]\n    winner_idx = indices[np.argmax(tournament_fitnesses)]\n    return population[winner_idx].copy()\n\n\ndef crossover(parent1, parent2, crossover_rate=0.7):\n    \"\"\"\n    Blend crossover: create offspring by blending parent genes.\n    \"\"\"\n    if np.random.random() > crossover_rate:\n        return parent1.copy()\n    \n    # Blend with random weight\n    alpha = np.random.uniform(0.3, 0.7)\n    offspring = alpha * parent1 + (1 - alpha) * parent2\n    \n    return offspring\n\n\ndef mutate(individual, mutation_rate=0.2, mutation_strength=0.1):\n    \"\"\"\n    Mutate individual by perturbing positions and radii.\n    \"\"\"\n    individual = individual.copy()\n    \n    for i in range(len(individual)):\n        if np.random.random() < mutation_rate:\n            # Add Gaussian noise\n            individual[i] += np.random.normal(0, mutation_strength)\n    \n    # Clip positions to valid range\n    individual[:52] = np.clip(individual[:52], 0, 1)\n    \n    # Clip radii to reasonable range\n    individual[52:] = np.clip(individual[52:], 0.001, 0.5)\n    \n    return individual\n\n\ndef adaptive_mutation(individual, generation, max_generations, base_rate=0.2):\n    \"\"\"\n    Mutation with adaptive strength that decreases over generations.\n    \"\"\"\n    # Decrease mutation strength over time\n    strength = 0.2 * (1 - generation / max_generations) + 0.01\n    return mutate(individual, mutation_rate=base_rate, mutation_strength=strength)\n\n\ndef run_packing(pop_size=40, n_generations=100, n_circles=26, verbose=True):\n    \"\"\"\n    Run genetic algorithm for circle packing.\n    \n    Args:\n        pop_size: population size\n        n_generations: number of generations to evolve\n        n_circles: number of circles to pack (default 26)\n        verbose: print progress\n    \n    Returns:\n        best_individual: best packing found\n        best_fitness: fitness of best packing\n        centers: circle centers\n        radii: circle radii\n    \"\"\"\n    # Initialize population\n    population = initialize_population(pop_size, n_circles)\n    \n    best_individual = None\n    best_fitness = -np.inf\n    \n    for generation in range(n_generations):\n        # Evaluate fitness\n        fitnesses = [fitness(ind) for ind in population]\n        \n        # Track best individual\n        gen_best_idx = np.argmax(fitnesses)\n        gen_best_fitness = fitnesses[gen_best_idx]\n        \n        if gen_best_fitness > best_fitness:\n            best_fitness = gen_best_fitness\n            best_individual = population[gen_best_idx].copy()\n        \n        if verbose and generation % 10 == 0:\n            centers, radii, sum_radii = construct_packing(best_individual)\n            penalty = check_constraints(centers, radii)\n            print(f\"Generation {generation}: Best fitness = {best_fitness:.6f}, \"\n                  f\"Sum radii = {sum_radii:.6f}, Penalty = {penalty:.6f}\")\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism: keep best individual\n        new_population.append(best_individual.copy())\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            # Selection\n            parent1 = tournament_selection(population, fitnesses)\n            parent2 = tournament_selection(population, fitnesses)\n            \n            # Crossover\n            offspring = crossover(parent1, parent2)\n            \n            # Mutation\n            offspring = adaptive_mutation(offspring, generation, n_generations)\n            \n            new_population.append(offspring)\n        \n        population = new_population\n    \n    # Final evaluation\n    centers, radii, sum_radii = construct_packing(best_individual)\n    penalty = check_constraints(centers, radii)\n    \n    if verbose:\n        print(f\"\\nFinal result:\")\n        print(f\"Best fitness: {best_fitness:.6f}\")\n        print(f\"Sum of radii: {sum_radii:.6f}\")\n        print(f\"Constraint penalty: {penalty:.6f}\")\n        print(f\"Valid packing: {penalty < 1e-6}\")\n    \n    return best_individual, best_fitness, centers, radii\n\n\nif __name__ == \"__main__\":\n    # Run the genetic algorithm\n    best_individual, best_fitness, centers, radii = run_packing(\n        pop_size=40,\n        n_generations=100,\n        verbose=True\n    )\n    \n    print(f\"\\nCircle radii: {radii}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 2.0969998836517334,
    "error": "ValueError: too many values to unpack (expected 3, got 4)"
  },
  "prompt": "Write a genetic algorithm for circle packing 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Population of packings (each: 26 positions + radii)\n2. Fitness = sum of radii (with penalty for constraint violations)\n3. Selection: tournament or roulette\n4. Crossover: blend positions/radii from two parents\n5. Mutation: perturb positions/radii\n6. Evolve for multiple generations\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Population size 20-50, run 50-100 generations\n- Implement selection, crossover, mutation\n- Return best individual\n- Define run_packing() as entry point\n- Import numpy as np",
  "response": "```python\nimport numpy as np\n\ndef construct_packing(individual):\n    \"\"\"\n    Construct packing from individual representation.\n    \n    Args:\n        individual: array of length 78 (26*3: x, y, radius for each circle)\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    individual = np.array(individual)\n    centers = individual[:52].reshape(26, 2)\n    radii = individual[52:]\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef check_constraints(centers, radii):\n    \"\"\"\n    Check if packing satisfies constraints.\n    \n    Returns:\n        penalty: constraint violation penalty (0 if valid)\n    \"\"\"\n    penalty = 0.0\n    \n    # Check boundary constraints\n    for i in range(len(centers)):\n        x, y = centers[i]\n        r = radii[i]\n        \n        # Circles must be inside [0,1]x[0,1]\n        if x - r < 0:\n            penalty += (0 - (x - r)) ** 2\n        if x + r > 1:\n            penalty += ((x + r) - 1) ** 2\n        if y - r < 0:\n            penalty += (0 - (y - r)) ** 2\n        if y + r > 1:\n            penalty += ((y + r) - 1) ** 2\n    \n    # Check non-overlapping constraints\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            \n            if dist < min_dist:\n                penalty += (min_dist - dist) ** 2\n    \n    return penalty\n\n\ndef fitness(individual):\n    \"\"\"\n    Fitness function: maximize sum of radii, penalize constraint violations.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing(individual)\n    penalty = check_constraints(centers, radii)\n    \n    # Fitness = sum of radii - large penalty for violations\n    return sum_radii - 1000 * penalty\n\n\ndef initialize_population(pop_size, n_circles=26):\n    \"\"\"\n    Initialize population with random packings.\n    \"\"\"\n    population = []\n    \n    for _ in range(pop_size):\n        # Random positions in [0,1]x[0,1]\n        positions = np.random.uniform(0, 1, size=(n_circles, 2))\n        \n        # Random small radii to start\n        radii = np.random.uniform(0.01, 0.1, size=n_circles)\n        \n        # Flatten into individual\n        individual = np.concatenate([positions.flatten(), radii])\n        population.append(individual)\n    \n    return population\n\n\ndef tournament_selection(population, fitnesses, tournament_size=3):\n    \"\"\"\n    Select an individual using tournament selection.\n    \"\"\"\n    indices = np.random.choice(len(population), size=tournament_size, replace=False)\n    tournament_fitnesses = [fitnesses[i] for i in indices]\n    winner_idx = indices[np.argmax(tournament_fitnesses)]\n    return population[winner_idx].copy()\n\n\ndef crossover(parent1, parent2, crossover_rate=0.7):\n    \"\"\"\n    Blend crossover: create offspring by blending parent genes.\n    \"\"\"\n    if np.random.random() > crossover_rate:\n        return parent1.copy()\n    \n    # Blend with random weight\n    alpha = np.random.uniform(0.3, 0.7)\n    offspring = alpha * parent1 + (1 - alpha) * parent2\n    \n    return offspring\n\n\ndef mutate(individual, mutation_rate=0.2, mutation_strength=0.1):\n    \"\"\"\n    Mutate individual by perturbing positions and radii.\n    \"\"\"\n    individual = individual.copy()\n    \n    for i in range(len(individual)):\n        if np.random.random() < mutation_rate:\n            # Add Gaussian noise\n            individual[i] += np.random.normal(0, mutation_strength)\n    \n    # Clip positions to valid range\n    individual[:52] = np.clip(individual[:52], 0, 1)\n    \n    # Clip radii to reasonable range\n    individual[52:] = np.clip(individual[52:], 0.001, 0.5)\n    \n    return individual\n\n\ndef adaptive_mutation(individual, generation, max_generations, base_rate=0.2):\n    \"\"\"\n    Mutation with adaptive strength that decreases over generations.\n    \"\"\"\n    # Decrease mutation strength over time\n    strength = 0.2 * (1 - generation / max_generations) + 0.01\n    return mutate(individual, mutation_rate=base_rate, mutation_strength=strength)\n\n\ndef run_packing(pop_size=40, n_generations=100, n_circles=26, verbose=True):\n    \"\"\"\n    Run genetic algorithm for circle packing.\n    \n    Args:\n        pop_size: population size\n        n_generations: number of generations to evolve\n        n_circles: number of circles to pack (default 26)\n        verbose: print progress\n    \n    Returns:\n        best_individual: best packing found\n        best_fitness: fitness of best packing\n        centers: circle centers\n        radii: circle radii\n    \"\"\"\n    # Initialize population\n    population = initialize_population(pop_size, n_circles)\n    \n    best_individual = None\n    best_fitness = -np.inf\n    \n    for generation in range(n_generations):\n        # Evaluate fitness\n        fitnesses = [fitness(ind) for ind in population]\n        \n        # Track best individual\n        gen_best_idx = np.argmax(fitnesses)\n        gen_best_fitness = fitnesses[gen_best_idx]\n        \n        if gen_best_fitness > best_fitness:\n            best_fitness = gen_best_fitness\n            best_individual = population[gen_best_idx].copy()\n        \n        if verbose and generation % 10 == 0:\n            centers, radii, sum_radii = construct_packing(best_individual)\n            penalty = check_constraints(centers, radii)\n            print(f\"Generation {generation}: Best fitness = {best_fitness:.6f}, \"\n                  f\"Sum radii = {sum_radii:.6f}, Penalty = {penalty:.6f}\")\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism: keep best individual\n        new_population.append(best_individual.copy())\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            # Selection\n            parent1 = tournament_selection(population, fitnesses)\n            parent2 = tournament_selection(population, fitnesses)\n            \n            # Crossover\n            offspring = crossover(parent1, parent2)\n            \n            # Mutation\n            offspring = adaptive_mutation(offspring, generation, n_generations)\n            \n            new_population.append(offspring)\n        \n        population = new_population\n    \n    # Final evaluation\n    centers, radii, sum_radii = construct_packing(best_individual)\n    penalty = check_constraints(centers, radii)\n    \n    if verbose:\n        print(f\"\\nFinal result:\")\n        print(f\"Best fitness: {best_fitness:.6f}\")\n        print(f\"Sum of radii: {sum_radii:.6f}\")\n        print(f\"Constraint penalty: {penalty:.6f}\")\n        print(f\"Valid packing: {penalty < 1e-6}\")\n    \n    return best_individual, best_fitness, centers, radii\n\n\nif __name__ == \"__main__\":\n    # Run the genetic algorithm\n    best_individual, best_fitness, centers, radii = run_packing(\n        pop_size=40,\n        n_generations=100,\n        verbose=True\n    )\n    \n    print(f\"\\nCircle radii: {radii}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n```\n\nThis genetic algorithm implementation includes:\n\n1. **Representation**: Each individual is a flat array of 78 values (26 circles \u00d7 3 parameters: x, y, radius)\n\n2. **Fitness Function**: Maximizes sum of radii while heavily penalizing constraint violations (boundary and overlap)\n\n3. **Selection**: Tournament selection (picks best from random subset)\n\n4. **Crossover**: Blend crossover that combines parent genes with random weights\n\n5. **Mutation**: Gaussian perturbation with adaptive strength that decreases over generations\n\n6. **Elitism**: Best individual always survives to next generation\n\n7. **Constraints**: \n   - Circles must stay within [0,1]\u00d7[0,1] bounds\n   - Circles cannot overlap\n\nThe algorithm typically converges to a valid packing with reasonable circle sizes after 50-100 generations.",
  "reasoning": "This genetic algorithm implementation includes:\n\n1. **Representation**: Each individual is a flat array of 78 values (26 circles \u00d7 3 parameters: x, y, radius)\n\n2. **Fitness Function**: Maximizes sum of radii while heavily penalizing constraint violations (boundary and overlap)\n\n3. **Selection**: Tournament selection (picks best from random subset)\n\n4. **Crossover**: Blend crossover that combines parent genes with random weights\n\n5. **Mutation**: Gaussian perturbation with adaptive strength that decreases over generations\n\n6. **Elitism**: Best individual always survives to next generation\n\n7. **Constraints**: \n   - Circles must stay within [0,1]\u00d7[0,1] bounds\n   - Circles cannot overlap\n\nThe algorithm typically converges to a valid packing with reasonable circle sizes after 50-100 generations.",
  "timestamp": "2025-12-05T15:04:22.224960",
  "cost_data": null
}