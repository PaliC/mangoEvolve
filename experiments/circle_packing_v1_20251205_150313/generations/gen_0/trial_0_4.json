{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing(seed=42, n_circles=26, n_iterations=100, growth_rate=0.001):\n    \"\"\"\n    Construct a circle packing using random placement with local optimization.\n    \n    Args:\n        seed: Random seed for reproducibility\n        n_circles: Number of circles to pack\n        n_iterations: Number of optimization iterations\n        growth_rate: Rate at which to grow radii\n    \n    Returns:\n        centers: Array of shape (n_circles, 2) with circle centers\n        radii: Array of shape (n_circles,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    np.random.seed(seed)\n    \n    # Step 1: Random initialization\n    centers = np.random.rand(n_circles, 2)\n    radii = np.full(n_circles, 0.01)\n    \n    # Step 2: Iterative radius growth with constraint maintenance\n    for iteration in range(n_iterations):\n        # Try to grow all radii\n        radii_new = radii + growth_rate\n        \n        # Check and enforce constraints\n        for i in range(n_circles):\n            # Boundary constraints\n            max_radius = min(\n                centers[i, 0],  # left boundary\n                1 - centers[i, 0],  # right boundary\n                centers[i, 1],  # bottom boundary\n                1 - centers[i, 1]  # top boundary\n            )\n            \n            # Circle overlap constraints\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_radius = min(max_radius, dist - radii[j])\n            \n            # Update radius if valid\n            if max_radius > radii[i]:\n                radii_new[i] = min(radii_new[i], max_radius)\n            else:\n                radii_new[i] = radii[i]\n        \n        radii = radii_new\n        \n        # Step 3: Local position optimization every 10 iterations\n        if iteration % 10 == 0 and iteration > 0:\n            centers, radii = local_optimization(centers, radii)\n    \n    # Final local optimization\n    centers, radii = local_optimization(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef local_optimization(centers, radii, n_local_iters=5):\n    \"\"\"\n    Apply local position adjustments to maximize packing density.\n    \"\"\"\n    n_circles = len(radii)\n    \n    for _ in range(n_local_iters):\n        # Try to adjust each circle's position\n        for i in range(n_circles):\n            # Try small random perturbations\n            best_center = centers[i].copy()\n            best_radius = radii[i]\n            \n            for _ in range(10):\n                # Random perturbation\n                delta = (np.random.rand(2) - 0.5) * 0.05\n                new_center = centers[i] + delta\n                \n                # Check if new position is valid\n                if not (0 <= new_center[0] <= 1 and 0 <= new_center[1] <= 1):\n                    continue\n                \n                # Calculate maximum possible radius at new position\n                max_radius = min(\n                    new_center[0],\n                    1 - new_center[0],\n                    new_center[1],\n                    1 - new_center[1]\n                )\n                \n                # Check against other circles\n                valid = True\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(new_center - centers[j])\n                        max_radius = min(max_radius, dist - radii[j])\n                        if max_radius <= 0:\n                            valid = False\n                            break\n                \n                # Update if improvement found\n                if valid and max_radius > best_radius:\n                    best_center = new_center\n                    best_radius = max_radius\n            \n            centers[i] = best_center\n            radii[i] = best_radius\n    \n    return centers, radii\n\n\ndef run_packing(n_restarts=5, n_circles=26):\n    \"\"\"\n    Entry point: Run multiple random restarts and keep best result.\n    \n    Args:\n        n_restarts: Number of random restarts to try\n        n_circles: Number of circles to pack\n    \n    Returns:\n        centers: Best circle centers found\n        radii: Best circle radii found\n        sum_radii: Sum of best radii\n    \"\"\"\n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    for restart in range(n_restarts):\n        centers, radii, sum_radii = construct_packing(\n            seed=restart * 123,\n            n_circles=n_circles,\n            n_iterations=150,\n            growth_rate=0.001\n        )\n        \n        print(f\"Restart {restart + 1}/{n_restarts}: sum_radii = {sum_radii:.4f}\")\n        \n        if sum_radii > best_sum_radii:\n            best_sum_radii = sum_radii\n            best_centers = centers\n            best_radii = radii\n    \n    print(f\"\\nBest result: sum_radii = {best_sum_radii:.4f}\")\n    return best_centers, best_radii, best_sum_radii\n\n\n# Run the packing\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing(n_restarts=5, n_circles=26)\n    \n    print(f\"\\nFinal packing statistics:\")\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"Average radius: {np.mean(radii):.4f}\")\n    print(f\"Min radius: {np.min(radii):.4f}\")\n    print(f\"Max radius: {np.max(radii):.4f}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.3370952456991536,
    "target_ratio": 0.8869431672482557,
    "combined_score": 0.8869431672482557,
    "eval_time": 4.075589179992676,
    "error": null
  },
  "prompt": "Write a random placement with local optimization for 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Randomly place 26 circles with small initial radii\n2. Iteratively grow radii while maintaining constraints\n3. Apply local position adjustments to maximize packing density\n4. Run multiple random restarts and keep best result\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Use random initialization with seed for reproducibility\n- Implement iterative radius growth\n- Define run_packing() as entry point\n- Import numpy as np",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing(seed=42, n_circles=26, n_iterations=100, growth_rate=0.001):\n    \"\"\"\n    Construct a circle packing using random placement with local optimization.\n    \n    Args:\n        seed: Random seed for reproducibility\n        n_circles: Number of circles to pack\n        n_iterations: Number of optimization iterations\n        growth_rate: Rate at which to grow radii\n    \n    Returns:\n        centers: Array of shape (n_circles, 2) with circle centers\n        radii: Array of shape (n_circles,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    np.random.seed(seed)\n    \n    # Step 1: Random initialization\n    centers = np.random.rand(n_circles, 2)\n    radii = np.full(n_circles, 0.01)\n    \n    # Step 2: Iterative radius growth with constraint maintenance\n    for iteration in range(n_iterations):\n        # Try to grow all radii\n        radii_new = radii + growth_rate\n        \n        # Check and enforce constraints\n        for i in range(n_circles):\n            # Boundary constraints\n            max_radius = min(\n                centers[i, 0],  # left boundary\n                1 - centers[i, 0],  # right boundary\n                centers[i, 1],  # bottom boundary\n                1 - centers[i, 1]  # top boundary\n            )\n            \n            # Circle overlap constraints\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_radius = min(max_radius, dist - radii[j])\n            \n            # Update radius if valid\n            if max_radius > radii[i]:\n                radii_new[i] = min(radii_new[i], max_radius)\n            else:\n                radii_new[i] = radii[i]\n        \n        radii = radii_new\n        \n        # Step 3: Local position optimization every 10 iterations\n        if iteration % 10 == 0 and iteration > 0:\n            centers, radii = local_optimization(centers, radii)\n    \n    # Final local optimization\n    centers, radii = local_optimization(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef local_optimization(centers, radii, n_local_iters=5):\n    \"\"\"\n    Apply local position adjustments to maximize packing density.\n    \"\"\"\n    n_circles = len(radii)\n    \n    for _ in range(n_local_iters):\n        # Try to adjust each circle's position\n        for i in range(n_circles):\n            # Try small random perturbations\n            best_center = centers[i].copy()\n            best_radius = radii[i]\n            \n            for _ in range(10):\n                # Random perturbation\n                delta = (np.random.rand(2) - 0.5) * 0.05\n                new_center = centers[i] + delta\n                \n                # Check if new position is valid\n                if not (0 <= new_center[0] <= 1 and 0 <= new_center[1] <= 1):\n                    continue\n                \n                # Calculate maximum possible radius at new position\n                max_radius = min(\n                    new_center[0],\n                    1 - new_center[0],\n                    new_center[1],\n                    1 - new_center[1]\n                )\n                \n                # Check against other circles\n                valid = True\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(new_center - centers[j])\n                        max_radius = min(max_radius, dist - radii[j])\n                        if max_radius <= 0:\n                            valid = False\n                            break\n                \n                # Update if improvement found\n                if valid and max_radius > best_radius:\n                    best_center = new_center\n                    best_radius = max_radius\n            \n            centers[i] = best_center\n            radii[i] = best_radius\n    \n    return centers, radii\n\n\ndef run_packing(n_restarts=5, n_circles=26):\n    \"\"\"\n    Entry point: Run multiple random restarts and keep best result.\n    \n    Args:\n        n_restarts: Number of random restarts to try\n        n_circles: Number of circles to pack\n    \n    Returns:\n        centers: Best circle centers found\n        radii: Best circle radii found\n        sum_radii: Sum of best radii\n    \"\"\"\n    best_sum_radii = 0\n    best_centers = None\n    best_radii = None\n    \n    for restart in range(n_restarts):\n        centers, radii, sum_radii = construct_packing(\n            seed=restart * 123,\n            n_circles=n_circles,\n            n_iterations=150,\n            growth_rate=0.001\n        )\n        \n        print(f\"Restart {restart + 1}/{n_restarts}: sum_radii = {sum_radii:.4f}\")\n        \n        if sum_radii > best_sum_radii:\n            best_sum_radii = sum_radii\n            best_centers = centers\n            best_radii = radii\n    \n    print(f\"\\nBest result: sum_radii = {best_sum_radii:.4f}\")\n    return best_centers, best_radii, best_sum_radii\n\n\n# Run the packing\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing(n_restarts=5, n_circles=26)\n    \n    print(f\"\\nFinal packing statistics:\")\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"Average radius: {np.mean(radii):.4f}\")\n    print(f\"Min radius: {np.min(radii):.4f}\")\n    print(f\"Max radius: {np.max(radii):.4f}\")\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T15:04:14.696465",
  "cost_data": null
}