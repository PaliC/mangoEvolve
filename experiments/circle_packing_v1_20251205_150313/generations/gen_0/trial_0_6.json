{
  "trial_id": "trial_0_6",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple, List\n\ndef check_constraints(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"Check if circles are within bounds and don't overlap.\"\"\"\n    n = len(radii)\n    \n    # Check boundary constraints\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n            centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n            return False\n    \n    # Check non-overlapping constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:  # Small tolerance for numerical errors\n                return False\n    \n    return True\n\ndef initialize_packing(n: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Initialize circles in a grid pattern with small radii.\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n)))\n    spacing = 1.0 / (grid_size + 1)\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 1) * spacing + np.random.uniform(-0.01, 0.01)\n        y = (row + 1) * spacing + np.random.uniform(-0.01, 0.01)\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Start with small radii and try to grow them\n    radii = np.full(n, 0.02)\n    \n    # Try to maximize initial radii while maintaining constraints\n    for i in range(n):\n        max_r = min(centers[i, 0], 1 - centers[i, 0], \n                    centers[i, 1], 1 - centers[i, 1])\n        \n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = min(max_r, dist - radii[j])\n        \n        radii[i] = max(0.01, max_r * 0.9)  # Use 90% of max to ensure feasibility\n    \n    return centers, radii\n\ndef perturb_packing(centers: np.ndarray, radii: np.ndarray, \n                    temperature: float) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Generate a neighboring solution by perturbing positions or radii.\"\"\"\n    n = len(radii)\n    new_centers = centers.copy()\n    new_radii = radii.copy()\n    \n    # Choose perturbation type\n    perturbation_type = np.random.choice(['move', 'resize', 'grow_all'])\n    \n    if perturbation_type == 'move':\n        # Move a random circle\n        idx = np.random.randint(n)\n        step_size = 0.05 * temperature\n        new_centers[idx] += np.random.uniform(-step_size, step_size, 2)\n        new_centers[idx] = np.clip(new_centers[idx], new_radii[idx], 1 - new_radii[idx])\n        \n    elif perturbation_type == 'resize':\n        # Resize a random circle\n        idx = np.random.randint(n)\n        delta = np.random.uniform(-0.01, 0.02) * temperature\n        new_radii[idx] = max(0.005, new_radii[idx] + delta)\n        \n    else:  # grow_all\n        # Try to grow all circles slightly\n        scale = 1.0 + 0.01 * temperature * np.random.uniform(0, 1)\n        new_radii = radii * scale\n    \n    return new_centers, new_radii\n\ndef construct_packing(n: int = 26, max_iterations: int = 50000, \n                     initial_temp: float = 1.0, \n                     cooling_rate: float = 0.9999) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct circle packing using simulated annealing.\n    \n    Returns:\n        centers: (n, 2) array of circle centers\n        radii: (n,) array of circle radii\n        sum_radii: sum of all radii (objective value)\n    \"\"\"\n    # Initialize\n    centers, radii = initialize_packing(n)\n    current_sum = np.sum(radii)\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = current_sum\n    \n    temperature = initial_temp\n    \n    for iteration in range(max_iterations):\n        # Generate neighbor\n        new_centers, new_radii = perturb_packing(centers, radii, temperature)\n        \n        # Check constraints\n        if not check_constraints(new_centers, new_radii):\n            continue\n        \n        new_sum = np.sum(new_radii)\n        delta = new_sum - current_sum\n        \n        # Accept or reject\n        if delta > 0 or np.random.random() < np.exp(delta / temperature):\n            centers = new_centers\n            radii = new_radii\n            current_sum = new_sum\n            \n            # Update best solution\n            if current_sum > best_sum:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_sum = current_sum\n        \n        # Cool down\n        temperature *= cooling_rate\n        \n        # Progress report\n        if (iteration + 1) % 10000 == 0:\n            print(f\"Iteration {iteration + 1}: Best sum = {best_sum:.4f}, \"\n                  f\"Current sum = {current_sum:.4f}, Temp = {temperature:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing(n: int = 26) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Entry point for running the circle packing algorithm.\n    \n    Args:\n        n: Number of circles to pack (default: 26)\n    \n    Returns:\n        centers: (n, 2) array of circle centers\n        radii: (n,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    print(f\"Starting simulated annealing for packing {n} circles...\")\n    centers, radii, sum_radii = construct_packing(n)\n    \n    print(f\"\\nFinal result:\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"Average radius: {sum_radii/n:.4f}\")\n    print(f\"Constraints satisfied: {check_constraints(centers, radii)}\")\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    # Run the packing algorithm\n    centers, radii, sum_radii = run_packing(26)\n    \n    # Optional: Visualize the result\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        \n        for i in range(len(radii)):\n            circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n            ax.add_patch(circle)\n            ax.plot(centers[i, 0], centers[i, 1], 'r.', markersize=3)\n        \n        ax.set_title(f'Circle Packing: 26 circles, Sum of radii = {sum_radii:.4f}')\n        ax.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('circle_packing.png', dpi=150)\n        print(\"\\nVisualization saved as 'circle_packing.png'\")\n        plt.show()\n    except ImportError:\n        print(\"\\nMatplotlib not available for visualization\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.3302030264603646,
    "target_ratio": 0.8843275242733832,
    "combined_score": 0.8843275242733832,
    "eval_time": 11.70891785621643,
    "error": null
  },
  "prompt": "Write a simulated annealing algorithm for circle packing 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Start with initial random or grid configuration\n2. Use simulated annealing to optimize positions and radii\n3. Accept moves that increase sum of radii, occasionally accept worse moves\n4. Cool temperature over iterations\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Implement SA with temperature schedule\n- Perturbation moves: adjust positions and radii\n- Check constraints after each move\n- Define run_packing() as entry point\n- Import numpy as np",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple, List\n\ndef check_constraints(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"Check if circles are within bounds and don't overlap.\"\"\"\n    n = len(radii)\n    \n    # Check boundary constraints\n    for i in range(n):\n        if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n            centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n            return False\n    \n    # Check non-overlapping constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:  # Small tolerance for numerical errors\n                return False\n    \n    return True\n\ndef initialize_packing(n: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Initialize circles in a grid pattern with small radii.\"\"\"\n    grid_size = int(np.ceil(np.sqrt(n)))\n    spacing = 1.0 / (grid_size + 1)\n    \n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 1) * spacing + np.random.uniform(-0.01, 0.01)\n        y = (row + 1) * spacing + np.random.uniform(-0.01, 0.01)\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    \n    # Start with small radii and try to grow them\n    radii = np.full(n, 0.02)\n    \n    # Try to maximize initial radii while maintaining constraints\n    for i in range(n):\n        max_r = min(centers[i, 0], 1 - centers[i, 0], \n                    centers[i, 1], 1 - centers[i, 1])\n        \n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_r = min(max_r, dist - radii[j])\n        \n        radii[i] = max(0.01, max_r * 0.9)  # Use 90% of max to ensure feasibility\n    \n    return centers, radii\n\ndef perturb_packing(centers: np.ndarray, radii: np.ndarray, \n                    temperature: float) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Generate a neighboring solution by perturbing positions or radii.\"\"\"\n    n = len(radii)\n    new_centers = centers.copy()\n    new_radii = radii.copy()\n    \n    # Choose perturbation type\n    perturbation_type = np.random.choice(['move', 'resize', 'grow_all'])\n    \n    if perturbation_type == 'move':\n        # Move a random circle\n        idx = np.random.randint(n)\n        step_size = 0.05 * temperature\n        new_centers[idx] += np.random.uniform(-step_size, step_size, 2)\n        new_centers[idx] = np.clip(new_centers[idx], new_radii[idx], 1 - new_radii[idx])\n        \n    elif perturbation_type == 'resize':\n        # Resize a random circle\n        idx = np.random.randint(n)\n        delta = np.random.uniform(-0.01, 0.02) * temperature\n        new_radii[idx] = max(0.005, new_radii[idx] + delta)\n        \n    else:  # grow_all\n        # Try to grow all circles slightly\n        scale = 1.0 + 0.01 * temperature * np.random.uniform(0, 1)\n        new_radii = radii * scale\n    \n    return new_centers, new_radii\n\ndef construct_packing(n: int = 26, max_iterations: int = 50000, \n                     initial_temp: float = 1.0, \n                     cooling_rate: float = 0.9999) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct circle packing using simulated annealing.\n    \n    Returns:\n        centers: (n, 2) array of circle centers\n        radii: (n,) array of circle radii\n        sum_radii: sum of all radii (objective value)\n    \"\"\"\n    # Initialize\n    centers, radii = initialize_packing(n)\n    current_sum = np.sum(radii)\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = current_sum\n    \n    temperature = initial_temp\n    \n    for iteration in range(max_iterations):\n        # Generate neighbor\n        new_centers, new_radii = perturb_packing(centers, radii, temperature)\n        \n        # Check constraints\n        if not check_constraints(new_centers, new_radii):\n            continue\n        \n        new_sum = np.sum(new_radii)\n        delta = new_sum - current_sum\n        \n        # Accept or reject\n        if delta > 0 or np.random.random() < np.exp(delta / temperature):\n            centers = new_centers\n            radii = new_radii\n            current_sum = new_sum\n            \n            # Update best solution\n            if current_sum > best_sum:\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n                best_sum = current_sum\n        \n        # Cool down\n        temperature *= cooling_rate\n        \n        # Progress report\n        if (iteration + 1) % 10000 == 0:\n            print(f\"Iteration {iteration + 1}: Best sum = {best_sum:.4f}, \"\n                  f\"Current sum = {current_sum:.4f}, Temp = {temperature:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef run_packing(n: int = 26) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Entry point for running the circle packing algorithm.\n    \n    Args:\n        n: Number of circles to pack (default: 26)\n    \n    Returns:\n        centers: (n, 2) array of circle centers\n        radii: (n,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    print(f\"Starting simulated annealing for packing {n} circles...\")\n    centers, radii, sum_radii = construct_packing(n)\n    \n    print(f\"\\nFinal result:\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"Average radius: {sum_radii/n:.4f}\")\n    print(f\"Constraints satisfied: {check_constraints(centers, radii)}\")\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    # Run the packing algorithm\n    centers, radii, sum_radii = run_packing(26)\n    \n    # Optional: Visualize the result\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        \n        for i in range(len(radii)):\n            circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n            ax.add_patch(circle)\n            ax.plot(centers[i, 0], centers[i, 1], 'r.', markersize=3)\n        \n        ax.set_title(f'Circle Packing: 26 circles, Sum of radii = {sum_radii:.4f}')\n        ax.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('circle_packing.png', dpi=150)\n        print(\"\\nVisualization saved as 'circle_packing.png'\")\n        plt.show()\n    except ImportError:\n        print(\"\\nMatplotlib not available for visualization\")\n```\n\nThis implementation includes:\n\n1. **Initialization**: Grid-based initialization with small radii that are grown as much as possible while maintaining constraints\n\n2. **Simulated Annealing**: \n   - Temperature schedule with exponential cooling\n   - Acceptance probability based on Metropolis criterion\n   - Tracks best solution found\n\n3. **Perturbation moves**:\n   - Move circles to new positions\n   - Resize individual circles\n   - Scale all circles uniformly\n\n4. **Constraint checking**: Verifies circles stay within bounds and don't overlap\n\n5. **Entry point**: `run_packing()` function that orchestrates the optimization\n\nThe algorithm maximizes the sum of radii, which encourages larger circles while maintaining feasibility. You can adjust hyperparameters like `max_iterations`, `initial_temp`, and `cooling_rate` to tune performance.",
  "reasoning": "This implementation includes:\n\n1. **Initialization**: Grid-based initialization with small radii that are grown as much as possible while maintaining constraints\n\n2. **Simulated Annealing**: \n   - Temperature schedule with exponential cooling\n   - Acceptance probability based on Metropolis criterion\n   - Tracks best solution found\n\n3. **Perturbation moves**:\n   - Move circles to new positions\n   - Resize individual circles\n   - Scale all circles uniformly\n\n4. **Constraint checking**: Verifies circles stay within bounds and don't overlap\n\n5. **Entry point**: `run_packing()` function that orchestrates the optimization\n\nThe algorithm maximizes the sum of radii, which encourages larger circles while maintaining feasibility. You can adjust hyperparameters like `max_iterations`, `initial_temp`, and `cooling_rate` to tune performance.",
  "timestamp": "2025-12-05T15:04:31.729886",
  "cost_data": null
}