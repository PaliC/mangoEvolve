{
  "trial_id": "trial_1_7",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\n\ndef physics_based_relaxation(num_circles=26, width=100, height=100, iterations=5000):\n    \"\"\"\n    Physics-based relaxation algorithm for circle packing.\n    \n    Simulates circles as particles with repulsive forces, boundary forces,\n    and growth pressure to naturally find optimal configurations.\n    \"\"\"\n    # Initialize circles with small radii at random positions\n    np.random.seed(42)\n    centers = np.random.rand(num_circles, 2) * [width, height]\n    radii = np.ones(num_circles) * 2.0  # Start with small radii\n    \n    # Physics parameters\n    velocities = np.zeros((num_circles, 2))\n    damping = 0.8  # Velocity damping for convergence\n    \n    for iteration in range(iterations):\n        # Decreasing learning rate for stability\n        lr = 0.5 * (1 - iteration / iterations) + 0.05\n        growth_rate = 0.02 * (1 - iteration / iterations) + 0.005\n        \n        forces = np.zeros((num_circles, 2))\n        growth_pressure = np.ones(num_circles)\n        \n        # 1. Circle-circle repulsion forces\n        for i in range(num_circles):\n            for j in range(i + 1, num_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist < 1e-6:  # Avoid division by zero\n                    diff = np.random.rand(2) * 0.1\n                    dist = np.linalg.norm(diff)\n                \n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist * 1.5:  # Repel if too close\n                    overlap = min_dist - dist\n                    force_magnitude = max(0, overlap) * 2.0\n                    \n                    # Also add inverse square repulsion\n                    if dist > 0:\n                        force_magnitude += (min_dist ** 2) / (dist ** 2) * 0.5\n                    \n                    force_dir = diff / dist\n                    force = force_dir * force_magnitude\n                    \n                    forces[i] += force\n                    forces[j] -= force\n                    \n                    # Reduce growth pressure if circles are colliding\n                    if overlap > 0:\n                        growth_pressure[i] *= 0.5\n                        growth_pressure[j] *= 0.5\n        \n        # 2. Boundary repulsion forces\n        boundary_margin = 2.0\n        \n        for i in range(num_circles):\n            r = radii[i]\n            x, y = centers[i]\n            \n            # Left boundary\n            if x - r < boundary_margin:\n                force_mag = (boundary_margin - (x - r)) * 3.0\n                forces[i, 0] += force_mag\n                growth_pressure[i] *= 0.7\n            \n            # Right boundary\n            if x + r > width - boundary_margin:\n                force_mag = (x + r - (width - boundary_margin)) * 3.0\n                forces[i, 0] -= force_mag\n                growth_pressure[i] *= 0.7\n            \n            # Top boundary\n            if y - r < boundary_margin:\n                force_mag = (boundary_margin - (y - r)) * 3.0\n                forces[i, 1] += force_mag\n                growth_pressure[i] *= 0.7\n            \n            # Bottom boundary\n            if y + r > height - boundary_margin:\n                force_mag = (y + r - (height - boundary_margin)) * 3.0\n                forces[i, 1] -= force_mag\n                growth_pressure[i] *= 0.7\n        \n        # 3. Update velocities with damping\n        velocities = velocities * damping + forces * lr\n        \n        # 4. Update positions\n        centers += velocities\n        \n        # 5. Clamp positions to boundaries\n        for i in range(num_circles):\n            centers[i, 0] = np.clip(centers[i, 0], radii[i], width - radii[i])\n            centers[i, 1] = np.clip(centers[i, 1], radii[i], height - radii[i])\n        \n        # 6. Growth phase - circles try to expand when they have space\n        for i in range(num_circles):\n            can_grow = True\n            potential_radius = radii[i] + growth_rate * growth_pressure[i]\n            \n            # Check if growth would cause collision\n            for j in range(num_circles):\n                if i == j:\n                    continue\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < potential_radius + radii[j] + 0.5:\n                    can_grow = False\n                    break\n            \n            # Check boundary constraints\n            x, y = centers[i]\n            if (x - potential_radius < 0 or x + potential_radius > width or\n                y - potential_radius < 0 or y + potential_radius > height):\n                can_grow = False\n            \n            # Grow if space allows\n            if can_grow and growth_pressure[i] > 0.3:\n                radii[i] = potential_radius\n        \n        # 7. Occasional shake to escape local minima (early iterations)\n        if iteration < iterations // 3 and iteration % 200 == 0:\n            shake = np.random.randn(num_circles, 2) * 0.5 * (1 - iteration / iterations)\n            centers += shake\n            centers = np.clip(centers, [[0, 0]], [[width, height]])\n    \n    # Final refinement: ensure no overlaps\n    for _ in range(100):\n        for i in range(num_circles):\n            for j in range(i + 1, num_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist and dist > 0:\n                    overlap = min_dist - dist\n                    move = (diff / dist) * (overlap / 2 + 0.01)\n                    centers[i] += move\n                    centers[j] -= move\n    \n    # Ensure circles stay in bounds\n    for i in range(num_circles):\n        centers[i, 0] = np.clip(centers[i, 0], radii[i], width - radii[i])\n        centers[i, 1] = np.clip(centers[i, 1], radii[i], height - radii[i])\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\n# Test the algorithm\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = physics_based_relaxation()\n    \n    print(f\"Total radius sum: {sum_radii:.2f}\")\n    print(f\"Average radius: {np.mean(radii):.2f}\")\n    print(f\"Radius range: [{np.min(radii):.2f}, {np.max(radii):.2f}]\")\n    \n    # Verify no overlaps\n    num_circles = len(radii)\n    max_overlap = 0\n    for i in range(num_circles):\n        for j in range(i + 1, num_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > max_overlap:\n                max_overlap = overlap\n    \n    print(f\"Maximum overlap: {max_overlap:.4f}\")\n    \n    # Optional: Visualize if matplotlib is available\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 100)\n        ax.set_ylim(0, 100)\n        ax.set_aspect('equal')\n        \n        for i in range(num_circles):\n            circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n            ax.add_patch(circle)\n        \n        ax.set_title(f'Physics-Based Circle Packing (Sum of radii: {sum_radii:.2f})')\n        plt.grid(True, alpha=0.3)\n        plt.show()\n    except ImportError:\n        print(\"Matplotlib not available for visualization\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.0661468505859375,
    "error": "ValueError: Code must define run_packing() or construct_packing()"
  },
  "prompt": "Create a physics-based relaxation algorithm.\n\nSimulate circles as particles with repulsive forces:\n\n1. Initialize 26 circles with small radii in random positions\n2. Apply forces:\n   - Circles repel each other (stronger when closer)\n   - Boundaries repel circles\n   - Each circle has \"growth pressure\" wanting to expand\n3. Iteratively:\n   - Update positions based on forces\n   - Grow radii when space allows\n   - Apply damping to converge\n4. Run for 5000 iterations with decreasing learning rate\n\nThis naturally finds good configurations by physical simulation.\n\nUse numpy for efficient computation.\nReturn centers, radii, sum_radii.",
  "response": "```python\nimport numpy as np\n\ndef physics_based_relaxation(num_circles=26, width=100, height=100, iterations=5000):\n    \"\"\"\n    Physics-based relaxation algorithm for circle packing.\n    \n    Simulates circles as particles with repulsive forces, boundary forces,\n    and growth pressure to naturally find optimal configurations.\n    \"\"\"\n    # Initialize circles with small radii at random positions\n    np.random.seed(42)\n    centers = np.random.rand(num_circles, 2) * [width, height]\n    radii = np.ones(num_circles) * 2.0  # Start with small radii\n    \n    # Physics parameters\n    velocities = np.zeros((num_circles, 2))\n    damping = 0.8  # Velocity damping for convergence\n    \n    for iteration in range(iterations):\n        # Decreasing learning rate for stability\n        lr = 0.5 * (1 - iteration / iterations) + 0.05\n        growth_rate = 0.02 * (1 - iteration / iterations) + 0.005\n        \n        forces = np.zeros((num_circles, 2))\n        growth_pressure = np.ones(num_circles)\n        \n        # 1. Circle-circle repulsion forces\n        for i in range(num_circles):\n            for j in range(i + 1, num_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist < 1e-6:  # Avoid division by zero\n                    diff = np.random.rand(2) * 0.1\n                    dist = np.linalg.norm(diff)\n                \n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist * 1.5:  # Repel if too close\n                    overlap = min_dist - dist\n                    force_magnitude = max(0, overlap) * 2.0\n                    \n                    # Also add inverse square repulsion\n                    if dist > 0:\n                        force_magnitude += (min_dist ** 2) / (dist ** 2) * 0.5\n                    \n                    force_dir = diff / dist\n                    force = force_dir * force_magnitude\n                    \n                    forces[i] += force\n                    forces[j] -= force\n                    \n                    # Reduce growth pressure if circles are colliding\n                    if overlap > 0:\n                        growth_pressure[i] *= 0.5\n                        growth_pressure[j] *= 0.5\n        \n        # 2. Boundary repulsion forces\n        boundary_margin = 2.0\n        \n        for i in range(num_circles):\n            r = radii[i]\n            x, y = centers[i]\n            \n            # Left boundary\n            if x - r < boundary_margin:\n                force_mag = (boundary_margin - (x - r)) * 3.0\n                forces[i, 0] += force_mag\n                growth_pressure[i] *= 0.7\n            \n            # Right boundary\n            if x + r > width - boundary_margin:\n                force_mag = (x + r - (width - boundary_margin)) * 3.0\n                forces[i, 0] -= force_mag\n                growth_pressure[i] *= 0.7\n            \n            # Top boundary\n            if y - r < boundary_margin:\n                force_mag = (boundary_margin - (y - r)) * 3.0\n                forces[i, 1] += force_mag\n                growth_pressure[i] *= 0.7\n            \n            # Bottom boundary\n            if y + r > height - boundary_margin:\n                force_mag = (y + r - (height - boundary_margin)) * 3.0\n                forces[i, 1] -= force_mag\n                growth_pressure[i] *= 0.7\n        \n        # 3. Update velocities with damping\n        velocities = velocities * damping + forces * lr\n        \n        # 4. Update positions\n        centers += velocities\n        \n        # 5. Clamp positions to boundaries\n        for i in range(num_circles):\n            centers[i, 0] = np.clip(centers[i, 0], radii[i], width - radii[i])\n            centers[i, 1] = np.clip(centers[i, 1], radii[i], height - radii[i])\n        \n        # 6. Growth phase - circles try to expand when they have space\n        for i in range(num_circles):\n            can_grow = True\n            potential_radius = radii[i] + growth_rate * growth_pressure[i]\n            \n            # Check if growth would cause collision\n            for j in range(num_circles):\n                if i == j:\n                    continue\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < potential_radius + radii[j] + 0.5:\n                    can_grow = False\n                    break\n            \n            # Check boundary constraints\n            x, y = centers[i]\n            if (x - potential_radius < 0 or x + potential_radius > width or\n                y - potential_radius < 0 or y + potential_radius > height):\n                can_grow = False\n            \n            # Grow if space allows\n            if can_grow and growth_pressure[i] > 0.3:\n                radii[i] = potential_radius\n        \n        # 7. Occasional shake to escape local minima (early iterations)\n        if iteration < iterations // 3 and iteration % 200 == 0:\n            shake = np.random.randn(num_circles, 2) * 0.5 * (1 - iteration / iterations)\n            centers += shake\n            centers = np.clip(centers, [[0, 0]], [[width, height]])\n    \n    # Final refinement: ensure no overlaps\n    for _ in range(100):\n        for i in range(num_circles):\n            for j in range(i + 1, num_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist and dist > 0:\n                    overlap = min_dist - dist\n                    move = (diff / dist) * (overlap / 2 + 0.01)\n                    centers[i] += move\n                    centers[j] -= move\n    \n    # Ensure circles stay in bounds\n    for i in range(num_circles):\n        centers[i, 0] = np.clip(centers[i, 0], radii[i], width - radii[i])\n        centers[i, 1] = np.clip(centers[i, 1], radii[i], height - radii[i])\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\n# Test the algorithm\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = physics_based_relaxation()\n    \n    print(f\"Total radius sum: {sum_radii:.2f}\")\n    print(f\"Average radius: {np.mean(radii):.2f}\")\n    print(f\"Radius range: [{np.min(radii):.2f}, {np.max(radii):.2f}]\")\n    \n    # Verify no overlaps\n    num_circles = len(radii)\n    max_overlap = 0\n    for i in range(num_circles):\n        for j in range(i + 1, num_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            overlap = radii[i] + radii[j] - dist\n            if overlap > max_overlap:\n                max_overlap = overlap\n    \n    print(f\"Maximum overlap: {max_overlap:.4f}\")\n    \n    # Optional: Visualize if matplotlib is available\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 100)\n        ax.set_ylim(0, 100)\n        ax.set_aspect('equal')\n        \n        for i in range(num_circles):\n            circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n            ax.add_patch(circle)\n        \n        ax.set_title(f'Physics-Based Circle Packing (Sum of radii: {sum_radii:.2f})')\n        plt.grid(True, alpha=0.3)\n        plt.show()\n    except ImportError:\n        print(\"Matplotlib not available for visualization\")\n```\n\nThis physics-based relaxation algorithm simulates circles as particles with:\n\n1. **Repulsive Forces**: Circles push each other away when too close, with force proportional to overlap\n2. **Boundary Forces**: Walls repel circles to keep them inside the canvas\n3. **Growth Pressure**: Each circle tries to expand when it has space\n4. **Damping**: Velocities decay to help the system converge to stable configurations\n5. **Decreasing Learning Rate**: Step sizes reduce over time for fine-tuning\n\nThe algorithm naturally finds good configurations through physical simulation, avoiding local minima through early-stage \"shaking\" and achieving efficient packing through the balance of repulsion and growth forces.",
  "reasoning": "This physics-based relaxation algorithm simulates circles as particles with:\n\n1. **Repulsive Forces**: Circles push each other away when too close, with force proportional to overlap\n2. **Boundary Forces**: Walls repel circles to keep them inside the canvas\n3. **Growth Pressure**: Each circle tries to expand when it has space\n4. **Damping**: Velocities decay to help the system converge to stable configurations\n5. **Decreasing Learning Rate**: Step sizes reduce over time for fine-tuning\n\nThe algorithm naturally finds good configurations through physical simulation, avoiding local minima through early-stage \"shaking\" and achieving efficient packing through the balance of repulsion and growth forces.",
  "timestamp": "2025-12-05T15:06:14.894495",
  "cost_data": null
}