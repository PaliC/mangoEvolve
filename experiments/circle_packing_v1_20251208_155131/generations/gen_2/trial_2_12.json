{
  "trial_id": "trial_2_12",
  "generation": 2,
  "parent_id": "trial_1_7",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List\nimport copy\n\n# Configuration\nNUM_PARTICLES = 40\nNUM_CIRCLES = 26\nNUM_ITERATIONS = 200\nINERTIA = 0.7\nCOGNITIVE = 1.5\nSOCIAL = 1.5\nCONTAINER_RADIUS = 1.0\nMIN_RADIUS = 0.01\nMAX_RADIUS = 0.3\n\nclass Particle:\n    def __init__(self):\n        # Position: [x1, y1, r1, x2, y2, r2, ...]\n        self.position = np.zeros(NUM_CIRCLES * 3)\n        self.velocity = np.zeros(NUM_CIRCLES * 3)\n        self.best_position = None\n        self.best_fitness = -np.inf\n        \n    def initialize_random(self):\n        \"\"\"Initialize particle with random valid configuration\"\"\"\n        for i in range(NUM_CIRCLES):\n            # Random angle and distance from center\n            angle = np.random.uniform(0, 2 * np.pi)\n            r = np.random.uniform(0, 0.7) * CONTAINER_RADIUS\n            \n            self.position[i*3] = r * np.cos(angle)  # x\n            self.position[i*3 + 1] = r * np.sin(angle)  # y\n            self.position[i*3 + 2] = np.random.uniform(MIN_RADIUS, MAX_RADIUS)  # radius\n        \n        self.velocity = np.random.uniform(-0.1, 0.1, NUM_CIRCLES * 3)\n        self.best_position = self.position.copy()\n\ndef extract_circles(position: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Extract centers and radii from position vector\"\"\"\n    centers = position.reshape(NUM_CIRCLES, 3)[:, :2]\n    radii = position.reshape(NUM_CIRCLES, 3)[:, 2]\n    return centers, radii\n\ndef calculate_fitness(position: np.ndarray) -> float:\n    \"\"\"Calculate fitness as sum of radii minus penalties for violations\"\"\"\n    centers, radii = extract_circles(position)\n    \n    # Base fitness: sum of radii\n    fitness = np.sum(radii)\n    \n    # Penalty for circles outside container\n    distances = np.sqrt(centers[:, 0]**2 + centers[:, 1]**2)\n    violations = distances + radii - CONTAINER_RADIUS\n    container_penalty = np.sum(np.maximum(0, violations)**2) * 100\n    \n    # Penalty for overlapping circles\n    overlap_penalty = 0.0\n    for i in range(NUM_CIRCLES):\n        for j in range(i + 1, NUM_CIRCLES):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                overlap_penalty += overlap**2 * 100\n    \n    # Penalty for invalid radii\n    radius_penalty = np.sum(np.maximum(0, MIN_RADIUS - radii)**2) * 100\n    radius_penalty += np.sum(np.maximum(0, radii - MAX_RADIUS)**2) * 100\n    \n    return fitness - container_penalty - overlap_penalty - radius_penalty\n\ndef repair_particle(position: np.ndarray) -> np.ndarray:\n    \"\"\"Project particle to valid configuration\"\"\"\n    position = position.copy()\n    centers, radii = extract_circles(position)\n    \n    # Clamp radii\n    radii = np.clip(radii, MIN_RADIUS, MAX_RADIUS)\n    \n    # Project circles to be inside container\n    distances = np.sqrt(centers[:, 0]**2 + centers[:, 1]**2)\n    for i in range(NUM_CIRCLES):\n        if distances[i] + radii[i] > CONTAINER_RADIUS:\n            max_dist = CONTAINER_RADIUS - radii[i]\n            if distances[i] > 1e-6:\n                scale = max_dist / distances[i]\n                centers[i] *= scale\n            else:\n                centers[i] = np.array([0.0, 0.0])\n    \n    # Separate overlapping circles (simple push apart)\n    for _ in range(5):  # Multiple iterations\n        for i in range(NUM_CIRCLES):\n            for j in range(i + 1, NUM_CIRCLES):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist and dist > 1e-6:\n                    # Push apart\n                    overlap = min_dist - dist\n                    direction = (centers[j] - centers[i]) / dist\n                    centers[i] -= direction * overlap * 0.5\n                    centers[j] += direction * overlap * 0.5\n    \n    # Reconstruct position\n    for i in range(NUM_CIRCLES):\n        position[i*3] = centers[i, 0]\n        position[i*3 + 1] = centers[i, 1]\n        position[i*3 + 2] = radii[i]\n    \n    return position\n\ndef pso_optimize() -> Tuple[np.ndarray, float]:\n    \"\"\"Run PSO optimization\"\"\"\n    # Initialize particles\n    particles = [Particle() for _ in range(NUM_PARTICLES)]\n    for p in particles:\n        p.initialize_random()\n        p.position = repair_particle(p.position)\n        p.best_position = p.position.copy()\n        p.best_fitness = calculate_fitness(p.position)\n    \n    # Find global best\n    global_best_position = particles[0].best_position.copy()\n    global_best_fitness = particles[0].best_fitness\n    \n    for p in particles:\n        if p.best_fitness > global_best_fitness:\n            global_best_fitness = p.best_fitness\n            global_best_position = p.best_position.copy()\n    \n    # PSO iterations\n    for iteration in range(NUM_ITERATIONS):\n        for p in particles:\n            # Update velocity\n            r1 = np.random.random(NUM_CIRCLES * 3)\n            r2 = np.random.random(NUM_CIRCLES * 3)\n            \n            cognitive = COGNITIVE * r1 * (p.best_position - p.position)\n            social = SOCIAL * r2 * (global_best_position - p.position)\n            \n            p.velocity = INERTIA * p.velocity + cognitive + social\n            \n            # Limit velocity\n            max_velocity = 0.2\n            p.velocity = np.clip(p.velocity, -max_velocity, max_velocity)\n            \n            # Update position\n            p.position = p.position + p.velocity\n            \n            # Repair\n            p.position = repair_particle(p.position)\n            \n            # Evaluate fitness\n            fitness = calculate_fitness(p.position)\n            \n            # Update personal best\n            if fitness > p.best_fitness:\n                p.best_fitness = fitness\n                p.best_position = p.position.copy()\n                \n                # Update global best\n                if fitness > global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best_position = p.best_position.copy()\n        \n        if (iteration + 1) % 50 == 0:\n            print(f\"Iteration {iteration + 1}/{NUM_ITERATIONS}, Best fitness: {global_best_fitness:.4f}\")\n    \n    return global_best_position, global_best_fitness\n\ndef local_optimization(position: np.ndarray) -> np.ndarray:\n    \"\"\"Local optimization using gradient descent\"\"\"\n    \n    def objective(x):\n        return -calculate_fitness(x)  # Minimize negative fitness\n    \n    result = minimize(\n        objective,\n        position,\n        method='L-BFGS-B',\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n    \n    return repair_particle(result.x)\n\ndef construct_packing() -> Tuple[List[Tuple[float, float]], List[float], float]:\n    \"\"\"\n    Construct circle packing using PSO.\n    \n    Returns:\n        centers: List of (x, y) tuples for circle centers\n        radii: List of circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    print(\"Starting PSO optimization...\")\n    best_position, best_fitness = pso_optimize()\n    \n    print(\"\\nPerforming local optimization...\")\n    optimized_position = local_optimization(best_position)\n    \n    # Extract final configuration\n    centers_array, radii_array = extract_circles(optimized_position)\n    \n    centers = [(float(c[0]), float(c[1])) for c in centers_array]\n    radii = [float(r) for r in radii_array]\n    sum_radii = float(np.sum(radii_array))\n    \n    print(f\"\\nFinal sum of radii: {sum_radii:.4f}\")\n    print(f\"Target: > 2.3\")\n    \n    # Verify constraints\n    valid = True\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        dist = np.sqrt(center[0]**2 + center[1]**2)\n        if dist + radius > CONTAINER_RADIUS + 1e-6:\n            print(f\"Warning: Circle {i} outside container\")\n            valid = False\n    \n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.sqrt((centers[i][0] - centers[j][0])**2 + \n                          (centers[i][1] - centers[j][1])**2)\n            if dist < radii[i] + radii[j] - 1e-6:\n                print(f\"Warning: Circles {i} and {j} overlap\")\n                valid = False\n    \n    if valid:\n        print(\"All constraints satisfied!\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point for circle packing optimization\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nPacked {len(centers)} circles with total radius sum: {sum_radii:.4f}\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 20.00311017036438,
    "error": "Circle 0 at (0.7491739306933685, -0.10125262777532719) with radius 0.24659750954110962 extends outside y-bounds"
  },
  "prompt": "Create a particle swarm optimizer for circle packing:\n\nUse PSO to explore the solution space.\n\nStrategy:\n1. Initialize 40 particles (configurations)\n2. Each particle: 26 circles with positions and radii\n3. Update velocities based on personal best and global best\n4. Run for 200 iterations\n5. Inertia weight: 0.7, cognitive: 1.5, social: 1.5\n6. Repair invalid particles using projection\n7. Final local optimization on best particle\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Target sum_radii > 2.3",
  "response": "Here's a particle swarm optimizer for circle packing:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List\nimport copy\n\n# Configuration\nNUM_PARTICLES = 40\nNUM_CIRCLES = 26\nNUM_ITERATIONS = 200\nINERTIA = 0.7\nCOGNITIVE = 1.5\nSOCIAL = 1.5\nCONTAINER_RADIUS = 1.0\nMIN_RADIUS = 0.01\nMAX_RADIUS = 0.3\n\nclass Particle:\n    def __init__(self):\n        # Position: [x1, y1, r1, x2, y2, r2, ...]\n        self.position = np.zeros(NUM_CIRCLES * 3)\n        self.velocity = np.zeros(NUM_CIRCLES * 3)\n        self.best_position = None\n        self.best_fitness = -np.inf\n        \n    def initialize_random(self):\n        \"\"\"Initialize particle with random valid configuration\"\"\"\n        for i in range(NUM_CIRCLES):\n            # Random angle and distance from center\n            angle = np.random.uniform(0, 2 * np.pi)\n            r = np.random.uniform(0, 0.7) * CONTAINER_RADIUS\n            \n            self.position[i*3] = r * np.cos(angle)  # x\n            self.position[i*3 + 1] = r * np.sin(angle)  # y\n            self.position[i*3 + 2] = np.random.uniform(MIN_RADIUS, MAX_RADIUS)  # radius\n        \n        self.velocity = np.random.uniform(-0.1, 0.1, NUM_CIRCLES * 3)\n        self.best_position = self.position.copy()\n\ndef extract_circles(position: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Extract centers and radii from position vector\"\"\"\n    centers = position.reshape(NUM_CIRCLES, 3)[:, :2]\n    radii = position.reshape(NUM_CIRCLES, 3)[:, 2]\n    return centers, radii\n\ndef calculate_fitness(position: np.ndarray) -> float:\n    \"\"\"Calculate fitness as sum of radii minus penalties for violations\"\"\"\n    centers, radii = extract_circles(position)\n    \n    # Base fitness: sum of radii\n    fitness = np.sum(radii)\n    \n    # Penalty for circles outside container\n    distances = np.sqrt(centers[:, 0]**2 + centers[:, 1]**2)\n    violations = distances + radii - CONTAINER_RADIUS\n    container_penalty = np.sum(np.maximum(0, violations)**2) * 100\n    \n    # Penalty for overlapping circles\n    overlap_penalty = 0.0\n    for i in range(NUM_CIRCLES):\n        for j in range(i + 1, NUM_CIRCLES):\n            dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                          (centers[i, 1] - centers[j, 1])**2)\n            overlap = radii[i] + radii[j] - dist\n            if overlap > 0:\n                overlap_penalty += overlap**2 * 100\n    \n    # Penalty for invalid radii\n    radius_penalty = np.sum(np.maximum(0, MIN_RADIUS - radii)**2) * 100\n    radius_penalty += np.sum(np.maximum(0, radii - MAX_RADIUS)**2) * 100\n    \n    return fitness - container_penalty - overlap_penalty - radius_penalty\n\ndef repair_particle(position: np.ndarray) -> np.ndarray:\n    \"\"\"Project particle to valid configuration\"\"\"\n    position = position.copy()\n    centers, radii = extract_circles(position)\n    \n    # Clamp radii\n    radii = np.clip(radii, MIN_RADIUS, MAX_RADIUS)\n    \n    # Project circles to be inside container\n    distances = np.sqrt(centers[:, 0]**2 + centers[:, 1]**2)\n    for i in range(NUM_CIRCLES):\n        if distances[i] + radii[i] > CONTAINER_RADIUS:\n            max_dist = CONTAINER_RADIUS - radii[i]\n            if distances[i] > 1e-6:\n                scale = max_dist / distances[i]\n                centers[i] *= scale\n            else:\n                centers[i] = np.array([0.0, 0.0])\n    \n    # Separate overlapping circles (simple push apart)\n    for _ in range(5):  # Multiple iterations\n        for i in range(NUM_CIRCLES):\n            for j in range(i + 1, NUM_CIRCLES):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                              (centers[i, 1] - centers[j, 1])**2)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist and dist > 1e-6:\n                    # Push apart\n                    overlap = min_dist - dist\n                    direction = (centers[j] - centers[i]) / dist\n                    centers[i] -= direction * overlap * 0.5\n                    centers[j] += direction * overlap * 0.5\n    \n    # Reconstruct position\n    for i in range(NUM_CIRCLES):\n        position[i*3] = centers[i, 0]\n        position[i*3 + 1] = centers[i, 1]\n        position[i*3 + 2] = radii[i]\n    \n    return position\n\ndef pso_optimize() -> Tuple[np.ndarray, float]:\n    \"\"\"Run PSO optimization\"\"\"\n    # Initialize particles\n    particles = [Particle() for _ in range(NUM_PARTICLES)]\n    for p in particles:\n        p.initialize_random()\n        p.position = repair_particle(p.position)\n        p.best_position = p.position.copy()\n        p.best_fitness = calculate_fitness(p.position)\n    \n    # Find global best\n    global_best_position = particles[0].best_position.copy()\n    global_best_fitness = particles[0].best_fitness\n    \n    for p in particles:\n        if p.best_fitness > global_best_fitness:\n            global_best_fitness = p.best_fitness\n            global_best_position = p.best_position.copy()\n    \n    # PSO iterations\n    for iteration in range(NUM_ITERATIONS):\n        for p in particles:\n            # Update velocity\n            r1 = np.random.random(NUM_CIRCLES * 3)\n            r2 = np.random.random(NUM_CIRCLES * 3)\n            \n            cognitive = COGNITIVE * r1 * (p.best_position - p.position)\n            social = SOCIAL * r2 * (global_best_position - p.position)\n            \n            p.velocity = INERTIA * p.velocity + cognitive + social\n            \n            # Limit velocity\n            max_velocity = 0.2\n            p.velocity = np.clip(p.velocity, -max_velocity, max_velocity)\n            \n            # Update position\n            p.position = p.position + p.velocity\n            \n            # Repair\n            p.position = repair_particle(p.position)\n            \n            # Evaluate fitness\n            fitness = calculate_fitness(p.position)\n            \n            # Update personal best\n            if fitness > p.best_fitness:\n                p.best_fitness = fitness\n                p.best_position = p.position.copy()\n                \n                # Update global best\n                if fitness > global_best_fitness:\n                    global_best_fitness = fitness\n                    global_best_position = p.best_position.copy()\n        \n        if (iteration + 1) % 50 == 0:\n            print(f\"Iteration {iteration + 1}/{NUM_ITERATIONS}, Best fitness: {global_best_fitness:.4f}\")\n    \n    return global_best_position, global_best_fitness\n\ndef local_optimization(position: np.ndarray) -> np.ndarray:\n    \"\"\"Local optimization using gradient descent\"\"\"\n    \n    def objective(x):\n        return -calculate_fitness(x)  # Minimize negative fitness\n    \n    result = minimize(\n        objective,\n        position,\n        method='L-BFGS-B',\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n    \n    return repair_particle(result.x)\n\ndef construct_packing() -> Tuple[List[Tuple[float, float]], List[float], float]:\n    \"\"\"\n    Construct circle packing using PSO.\n    \n    Returns:\n        centers: List of (x, y) tuples for circle centers\n        radii: List of circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    print(\"Starting PSO optimization...\")\n    best_position, best_fitness = pso_optimize()\n    \n    print(\"\\nPerforming local optimization...\")\n    optimized_position = local_optimization(best_position)\n    \n    # Extract final configuration\n    centers_array, radii_array = extract_circles(optimized_position)\n    \n    centers = [(float(c[0]), float(c[1])) for c in centers_array]\n    radii = [float(r) for r in radii_array]\n    sum_radii = float(np.sum(radii_array))\n    \n    print(f\"\\nFinal sum of radii: {sum_radii:.4f}\")\n    print(f\"Target: > 2.3\")\n    \n    # Verify constraints\n    valid = True\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        dist = np.sqrt(center[0]**2 + center[1]**2)\n        if dist + radius > CONTAINER_RADIUS + 1e-6:\n            print(f\"Warning: Circle {i} outside container\")\n            valid = False\n    \n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.sqrt((centers[i][0] - centers[j][0])**2 + \n                          (centers[i][1] - centers[j][1])**2)\n            if dist < radii[i] + radii[j] - 1e-6:\n                print(f\"Warning: Circles {i} and {j} overlap\")\n                valid = False\n    \n    if valid:\n        print(\"All constraints satisfied!\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point for circle packing optimization\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nPacked {len(centers)} circles with total radius sum: {sum_radii:.4f}\")\n```\n\nThis implementation:\n\n1. **PSO Framework**: Uses 40 particles, each representing a complete circle packing configuration\n2. **Particle Representation**: Each particle is a vector of [x\u2081, y\u2081, r\u2081, x\u2082, y\u2082, r\u2082, ...] for 26 circles\n3. **Fitness Function**: Maximizes sum of radii while penalizing constraint violations\n4. **Repair Mechanism**: Projects invalid particles back to feasible space by:\n   - Clamping radii to valid range\n   - Moving circles inside container\n   - Separating overlapping circles\n5. **PSO Updates**: Standard velocity and position updates with inertia, cognitive, and social components\n6. **Local Optimization**: Final refinement using L-BFGS-B gradient descent\n7. **Validation**: Checks all constraints are satisfied\n\nThe algorithm should achieve sum_radii > 2.3 through intelligent exploration of the solution space.",
  "reasoning": "Here's a particle swarm optimizer for circle packing:\n\nThis implementation:\n\n1. **PSO Framework**: Uses 40 particles, each representing a complete circle packing configuration\n2. **Particle Representation**: Each particle is a vector of [x\u2081, y\u2081, r\u2081, x\u2082, y\u2082, r\u2082, ...] for 26 circles\n3. **Fitness Function**: Maximizes sum of radii while penalizing constraint violations\n4. **Repair Mechanism**: Projects invalid particles back to feasible space by:\n   - Clamping radii to valid range\n   - Moving circles inside container\n   - Separating overlapping circles\n5. **PSO Updates**: Standard velocity and position updates with inertia, cognitive, and social components\n6. **Local Optimization**: Final refinement using L-BFGS-B gradient descent\n7. **Validation**: Checks all constraints are satisfied\n\nThe algorithm should achieve sum_radii > 2.3 through intelligent exploration of the solution space.",
  "timestamp": "2025-12-08T16:02:46.004750",
  "cost_data": null
}