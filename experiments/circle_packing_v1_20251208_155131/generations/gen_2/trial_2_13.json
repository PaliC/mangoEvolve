{
  "trial_id": "trial_2_13",
  "generation": 2,
  "parent_id": "trial_1_7",
  "code": "",
  "metrics": {},
  "prompt": "Implement a variable neighborhood search:\n\nSystematically explore different neighborhood structures.\n\nStrategy:\n1. Start from trial_1_7's configuration\n2. Define 5 neighborhood structures:\n   - Move single circle\n   - Swap two circles\n   - Perturb all radii\n   - Rotate configuration\n   - Scale configuration\n3. For each neighborhood, apply local search\n4. If improvement found, restart from structure 1\n5. Run for 100 VNS iterations\n\nThis explores diverse modifications systematically.",
  "response": "I'll implement a Variable Neighborhood Search (VNS) to systematically explore different neighborhood structures starting from trial_1_7's configuration.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nimport json\n\ndef load_best_solution():\n    \"\"\"Load trial_1_7 configuration\"\"\"\n    try:\n        with open('trial_1_7.json', 'r') as f:\n            data = json.load(f)\n            return np.array(data['coordinates']), np.array(data['radii'])\n    except:\n        # Fallback if file doesn't exist\n        return None, None\n\ndef calculate_coverage(coordinates, radii):\n    \"\"\"Calculate total coverage area using Monte Carlo sampling\"\"\"\n    n_samples = 100000\n    points = np.random.rand(n_samples, 2)\n    \n    covered = np.zeros(n_samples, dtype=bool)\n    for (cx, cy), r in zip(coordinates, radii):\n        distances = np.sqrt((points[:, 0] - cx)**2 + (points[:, 1] - cy)**2)\n        covered |= (distances <= r)\n    \n    return np.sum(covered) / n_samples\n\ndef check_constraints(coordinates, radii):\n    \"\"\"Check if configuration satisfies all constraints\"\"\"\n    # Check boundaries\n    for (x, y), r in zip(coordinates, radii):\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n    \n    # Check non-overlapping\n    for i in range(len(coordinates)):\n        for j in range(i + 1, len(coordinates)):\n            dist = np.linalg.norm(coordinates[i] - coordinates[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\ndef repair_solution(coordinates, radii, max_iterations=100):\n    \"\"\"Repair solution to satisfy constraints\"\"\"\n    coords = coordinates.copy()\n    rads = radii.copy()\n    \n    for iteration in range(max_iterations):\n        if check_constraints(coords, rads):\n            return coords, rads\n        \n        # Fix boundary violations\n        for i in range(len(coords)):\n            coords[i, 0] = np.clip(coords[i, 0], rads[i], 1 - rads[i])\n            coords[i, 1] = np.clip(coords[i, 1], rads[i], 1 - rads[i])\n        \n        # Fix overlaps by moving circles apart\n        for i in range(len(coords)):\n            for j in range(i + 1, len(coords)):\n                dist = np.linalg.norm(coords[i] - coords[j])\n                min_dist = rads[i] + rads[j]\n                \n                if dist < min_dist:\n                    # Move circles apart\n                    direction = coords[j] - coords[i]\n                    if np.linalg.norm(direction) > 0:\n                        direction = direction / np.linalg.norm(direction)\n                    else:\n                        direction = np.random.randn(2)\n                        direction = direction / np.linalg.norm(direction)\n                    \n                    overlap = min_dist - dist\n                    coords[i] -= direction * overlap * 0.5\n                    coords[j] += direction * overlap * 0.5\n    \n    return coords, rads\n\n# Neighborhood structures\ndef neighborhood_move_single(coordinates, radii, intensity=0.05):\n    \"\"\"Move a single random circle\"\"\"\n    coords = coordinates.copy()\n    idx = np.random.randint(len(coords))\n    coords[idx] += np.random.randn(2) * intensity\n    return repair_solution(coords, radii)\n\ndef neighborhood_swap_two(coordinates, radii):\n    \"\"\"Swap positions of two random circles\"\"\"\n    coords = coordinates.copy()\n    idx1, idx2 = np.random.choice(len(coords), 2, replace=False)\n    coords[idx1], coords[idx2] = coords[idx2].copy(), coords[idx1].copy()\n    return repair_solution(coords, radii)\n\ndef neighborhood_perturb_radii(coordinates, radii, intensity=0.02):\n    \"\"\"Perturb all radii slightly while maintaining sum\"\"\"\n    rads = radii.copy()\n    perturbation = np.random.randn(len(rads)) * intensity\n    perturbation -= perturbation.mean()  # Keep sum constant\n    rads += perturbation\n    rads = np.clip(rads, 0.01, 0.5)\n    # Normalize to maintain sum\n    rads = rads * (radii.sum() / rads.sum())\n    return repair_solution(coordinates, rads)\n\ndef neighborhood_rotate(coordinates, radii, angle_range=0.2):\n    \"\"\"Rotate configuration around center\"\"\"\n    coords = coordinates.copy()\n    center = coords.mean(axis=0)\n    angle = np.random.uniform(-angle_range, angle_range)\n    \n    # Rotate around center\n    cos_a, sin_a = np.cos(angle), np.sin(angle)\n    rotation_matrix = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n    \n    coords = coords - center\n    coords = coords @ rotation_matrix.T\n    coords = coords + center\n    \n    return repair_solution(coords, radii)\n\ndef neighborhood_scale(coordinates, radii, scale_range=0.1):\n    \"\"\"Scale configuration around center\"\"\"\n    coords = coordinates.copy()\n    center = coords.mean(axis=0)\n    scale = 1.0 + np.random.uniform(-scale_range, scale_range)\n    \n    coords = center + (coords - center) * scale\n    \n    return repair_solution(coords, radii)\n\ndef local_search(coordinates, radii, max_iterations=20):\n    \"\"\"Apply local search to improve solution\"\"\"\n    best_coords = coordinates.copy()\n    best_rads = radii.copy()\n    best_coverage = calculate_coverage(best_coords, best_rads)\n    \n    for _ in range(max_iterations):\n        # Try small random moves\n        for i in range(len(best_coords)):\n            coords = best_coords.copy()\n            coords[i] += np.random.randn(2) * 0.02\n            coords, rads = repair_solution(coords, best_rads)\n            \n            if check_constraints(coords, rads):\n                coverage = calculate_coverage(coords, rads)\n                if coverage > best_coverage:\n                    best_coords = coords\n                    best_rads = rads\n                    best_coverage = coverage\n    \n    return best_coords, best_rads, best_coverage\n\ndef variable_neighborhood_search(initial_coords, initial_radii, max_iterations=100):\n    \"\"\"Main VNS algorithm\"\"\"\n    neighborhoods = [\n        neighborhood_move_single,\n        neighborhood_swap_two,\n        neighborhood_perturb_radii,\n        neighborhood_rotate,\n        neighborhood_scale\n    ]\n    \n    neighborhood_names = [\n        \"Move Single Circle\",\n        \"Swap Two Circles\",\n        \"Perturb Radii\",\n        \"Rotate Configuration\",\n        \"Scale Configuration\"\n    ]\n    \n    best_coords = initial_coords.copy()\n    best_radii = initial_radii.copy()\n    best_coverage = calculate_coverage(best_coords, best_radii)\n    \n    print(f\"Initial coverage: {best_coverage:.6f}\")\n    print(f\"Starting VNS with {max_iterations} iterations...\\n\")\n    \n    coverage_history = [best_coverage]\n    improvements = {name: 0 for name in neighborhood_names}\n    \n    for iteration in range(max_iterations):\n        improved = False\n        \n        # Try each neighborhood structure\n        for k, (neighborhood, name) in enumerate(zip(neighborhoods, neighborhood_names)):\n            # Generate neighbor\n            coords, rads = neighborhood(best_coords, best_radii)\n            \n            if not check_constraints(coords, rads):\n                continue\n            \n            # Apply local search\n            coords, rads, coverage = local_search(coords, rads)\n            \n            # Check for improvement\n            if coverage > best_coverage + 1e-8:\n                best_coords = coords\n                best_radii = rads\n                best_coverage = coverage\n                improved = True\n                improvements[name] += 1\n                \n                print(f\"Iteration {iteration + 1}: Improved with '{name}'\")\n                print(f\"  New coverage: {best_coverage:.6f}\")\n                \n                # Restart from first neighborhood\n                break\n        \n        coverage_history.append(best_coverage)\n        \n        if (iteration + 1) % 10 == 0:\n            print(f\"\\nIteration {iteration + 1}/{max_iterations}\")\n            print(f\"  Current best coverage: {best_coverage:.6f}\")\n            print(f\"  Improvements by neighborhood:\")\n            for name, count in improvements.items():\n                print(f\"    {name}: {count}\")\n            print()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"VNS COMPLETE\")\n    print(\"=\"*60)\n    print(f\"Final coverage: {best_coverage:.6f}\")\n    print(f\"\\nTotal improvements by neighborhood:\")\n    for name, count in improvements.items():\n        print(f\"  {name}: {count}\")\n    \n    return best_coords, best_radii, best_coverage, coverage_history, improvements\n\ndef visualize_solution(coordinates, radii, coverage, filename='vns_solution.png'):\n    \"\"\"Visualize the final solution\"\"\"\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))\n    \n    # Plot circles\n    ax1.set_xlim(0, 1)\n    ax1.set_ylim(0, 1)\n    ax1.set_aspect('equal')\n    ax1.set_title(f'VNS Solution - Coverage: {coverage:.6f}')\n    \n    colors = plt.cm.Set3(np.linspace(0, 1, len(coordinates)))\n    \n    for i, ((x, y), r) in enumerate(zip(coordinates, radii)):\n        circle = Circle((x, y), r, color=colors[i], alpha=0.6, ec='black', linewidth=1.5)\n        ax1.add_patch(circle)\n        ax1.plot(x, y, 'k.', markersize=8)\n        ax1.text(x, y, str(i+1), ha='center', va='center', fontsize=10, fontweight='bold')\n    \n    ax1.grid(True, alpha=0.3)\n    ax1.set_xlabel('X')\n    ax1.set_ylabel('Y')\n    \n    # Plot coverage grid\n    resolution = 200\n    x = np.linspace(0, 1, resolution)\n    y = np.linspace(0, 1, resolution)\n    X, Y = np.meshgrid(x, y)\n    \n    Z = np.zeros_like(X)\n    for (cx, cy), r in zip(coordinates, radii):\n        dist = np.sqrt((X - cx)**2 + (Y - cy)**2)\n        Z = np.maximum(Z, (dist <= r).astype(float))\n    \n    ax2.contourf(X, Y, Z, levels=[0, 0.5, 1], colors=['white', 'lightblue'], alpha=0.7)\n    \n    for i, ((x, y), r) in enumerate(zip(coordinates, radii)):\n        circle = Circle((x, y), r, fill=False, ec='red', linewidth=2)\n        ax2.add_patch(circle)\n    \n    ax2.set_xlim(0, 1)\n    ax2.set_ylim(0, 1)\n    ax2.set_aspect('equal')\n    ax2.set_title('Coverage Map')\n    ax2.grid(True, alpha=0.3)\n    ax2.set_xlabel('X')\n    ax2.set_ylabel('Y')\n    \n    plt.tight_layout()\n    plt.savefig(filename, dpi=150, bbox_inches='tight')\n    print(f\"\\nVisualization saved as '{filename}'\")\n    plt.close()\n\ndef plot_convergence(coverage_history, improvements, filename='vns_convergence.png'):\n    \"\"\"Plot convergence history\"\"\"\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n    \n    # Convergence plot\n    ax1.plot(coverage_history, linewidth=2, color='blue')\n    ax1.set_xlabel('Iteration')\n    ax1.set_ylabel('Coverage')\n    ax1.set_title('VNS Convergence History')\n    ax1.grid(True, alpha=0.3)\n    \n    # Improvements by neighborhood\n    names = list(improvements.keys())\n    counts = list(improvements.values())\n    colors = plt.cm.Set2(np.linspace(0, 1, len(names)))\n    \n    bars = ax2.bar(range(len(names)), counts, color=colors, alpha=0.7, edgecolor='black')\n    ax2.set_xticks(range(len(names)))\n    ax2.set_xticklabels([name.replace(' ', '\\n') for name in names], fontsize=9)\n    ax2.set_ylabel('Number of Improvements')\n    ax2.set_title('Improvements by Neighborhood Structure')\n    ax2.grid(True, alpha=0.3, axis='y')\n    \n    # Add value labels on bars\n    for bar in bars:\n        height = bar.get_height()\n        if height > 0:\n            ax2.text(bar.get_x() + bar.get_width()/2., height,\n                    f'{int(height)}', ha='center', va='bottom', fontweight='bold')\n    \n    plt.tight_layout()\n    plt.savefig(filename, dpi=150, bbox_inches='tight')\n    print(f\"Convergence plot saved as '{filename}'\")\n    plt.close()\n\ndef save_solution(coordinates, radii, coverage, filename='vns_solution.json'):\n    \"\"\"Save solution to file\"\"\"\n    solution = {\n        'coverage': float(coverage),\n        'num_circles': len(coordinates),\n        'coordinates': coordinates.tolist(),\n        'radii': radii.tolist()\n    }\n    \n    with open(filename, 'w') as f:\n        json.dump(solution, f, indent=2)\n    \n    print(f\"Solution saved as '{filename}'\")\n\n# Main execution\nif __name__ == \"__main__\":\n    print(\"=\"*60)\n    print(\"VARIABLE NEIGHBORHOOD SEARCH\")\n    print(\"=\"*60)\n    \n    # Load initial solution\n    initial_coords, initial_radii = load_best_solution()\n    \n    if initial_coords is None:\n        print(\"Could not load trial_1_7.json, using default configuration\")\n        # Use a reasonable default\n        initial_coords = np.array([\n            [0.15, 0.15], [0.45, 0.15], [0.75, 0.15],\n            [0.15, 0.45], [0.45, 0.45], [0.75, 0.45],\n            [0.15, 0.75], [0.45, 0.75], [0.75, 0.75]\n        ])\n        initial_radii = np.array([0.12, 0.12, 0.12, 0.12, 0.12, 0.12, 0.12, 0.12, 0.12])\n    \n    print(f\"\\nStarting configuration:\")\n    print(f\"  Number of circles: {len(initial_coords)}\")\n    print(f\"  Sum of radii: {initial_radii.sum():.6f}\")\n    \n    # Run VNS\n    best_coords, best_radii, best_coverage, history, improvements = variable_neighborhood_search(\n        initial_coords, initial_radii, max_iterations=100\n    )\n    \n    # Verify final solution\n    print(",
  "reasoning": "I'll implement a Variable Neighborhood Search (VNS) to systematically explore different neighborhood structures starting from trial_1_7's configuration.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nimport json\n\ndef load_best_solution():\n    \"\"\"Load trial_1_7 configuration\"\"\"\n    try:\n        with open('trial_1_7.json', 'r') as f:\n            data = json.load(f)\n            return np.array(data['coordinates']), np.array(data['radii'])\n    except:\n        # Fallback if file doesn't exist\n        return None, None\n\ndef calculate_coverage(coordinates, radii):\n    \"\"\"Calculate total coverage area using Monte Carlo sampling\"\"\"\n    n_samples = 100000\n    points = np.random.rand(n_samples, 2)\n    \n    covered = np.zeros(n_samples, dtype=bool)\n    for (cx, cy), r in zip(coordinates, radii):\n        distances = np.sqrt((points[:, 0] - cx)**2 + (points[:, 1] - cy)**2)\n        covered |= (distances <= r)\n    \n    return np.sum(covered) / n_samples\n\ndef check_constraints(coordinates, radii):\n    \"\"\"Check if configuration satisfies all constraints\"\"\"\n    # Check boundaries\n    for (x, y), r in zip(coordinates, radii):\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n    \n    # Check non-overlapping\n    for i in range(len(coordinates)):\n        for j in range(i + 1, len(coordinates)):\n            dist = np.linalg.norm(coordinates[i] - coordinates[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\ndef repair_solution(coordinates, radii, max_iterations=100):\n    \"\"\"Repair solution to satisfy constraints\"\"\"\n    coords = coordinates.copy()\n    rads = radii.copy()\n    \n    for iteration in range(max_iterations):\n        if check_constraints(coords, rads):\n            return coords, rads\n        \n        # Fix boundary violations\n        for i in range(len(coords)):\n            coords[i, 0] = np.clip(coords[i, 0], rads[i], 1 - rads[i])\n            coords[i, 1] = np.clip(coords[i, 1], rads[i], 1 - rads[i])\n        \n        # Fix overlaps by moving circles apart\n        for i in range(len(coords)):\n            for j in range(i + 1, len(coords)):\n                dist = np.linalg.norm(coords[i] - coords[j])\n                min_dist = rads[i] + rads[j]\n                \n                if dist < min_dist:\n                    # Move circles apart\n                    direction = coords[j] - coords[i]\n                    if np.linalg.norm(direction) > 0:\n                        direction = direction / np.linalg.norm(direction)\n                    else:\n                        direction = np.random.randn(2)\n                        direction = direction / np.linalg.norm(direction)\n                    \n                    overlap = min_dist - dist\n                    coords[i] -= direction * overlap * 0.5\n                    coords[j] += direction * overlap * 0.5\n    \n    return coords, rads\n\n# Neighborhood structures\ndef neighborhood_move_single(coordinates, radii, intensity=0.05):\n    \"\"\"Move a single random circle\"\"\"\n    coords = coordinates.copy()\n    idx = np.random.randint(len(coords))\n    coords[idx] += np.random.randn(2) * intensity\n    return repair_solution(coords, radii)\n\ndef neighborhood_swap_two(coordinates, radii):\n    \"\"\"Swap positions of two random circles\"\"\"\n    coords = coordinates.copy()\n    idx1, idx2 = np.random.choice(len(coords), 2, replace=False)\n    coords[idx1], coords[idx2] = coords[idx2].copy(), coords[idx1].copy()\n    return repair_solution(coords, radii)\n\ndef neighborhood_perturb_radii(coordinates, radii, intensity=0.02):\n    \"\"\"Perturb all radii slightly while maintaining sum\"\"\"\n    rads = radii.copy()\n    perturbation = np.random.randn(len(rads)) * intensity\n    perturbation -= perturbation.mean()  # Keep sum constant\n    rads += perturbation\n    rads = np.clip(rads, 0.01, 0.5)\n    # Normalize to maintain sum\n    rads = rads * (radii.sum() / rads.sum())\n    return repair_solution(coordinates, rads)\n\ndef neighborhood_rotate(coordinates, radii, angle_range=0.2):\n    \"\"\"Rotate configuration around center\"\"\"\n    coords = coordinates.copy()\n    center = coords.mean(axis=0)\n    angle = np.random.uniform(-angle_range, angle_range)\n    \n    # Rotate around center\n    cos_a, sin_a = np.cos(angle), np.sin(angle)\n    rotation_matrix = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n    \n    coords = coords - center\n    coords = coords @ rotation_matrix.T\n    coords = coords + center\n    \n    return repair_solution(coords, radii)\n\ndef neighborhood_scale(coordinates, radii, scale_range=0.1):\n    \"\"\"Scale configuration around center\"\"\"\n    coords = coordinates.copy()\n    center = coords.mean(axis=0)\n    scale = 1.0 + np.random.uniform(-scale_range, scale_range)\n    \n    coords = center + (coords - center) * scale\n    \n    return repair_solution(coords, radii)\n\ndef local_search(coordinates, radii, max_iterations=20):\n    \"\"\"Apply local search to improve solution\"\"\"\n    best_coords = coordinates.copy()\n    best_rads = radii.copy()\n    best_coverage = calculate_coverage(best_coords, best_rads)\n    \n    for _ in range(max_iterations):\n        # Try small random moves\n        for i in range(len(best_coords)):\n            coords = best_coords.copy()\n            coords[i] += np.random.randn(2) * 0.02\n            coords, rads = repair_solution(coords, best_rads)\n            \n            if check_constraints(coords, rads):\n                coverage = calculate_coverage(coords, rads)\n                if coverage > best_coverage:\n                    best_coords = coords\n                    best_rads = rads\n                    best_coverage = coverage\n    \n    return best_coords, best_rads, best_coverage\n\ndef variable_neighborhood_search(initial_coords, initial_radii, max_iterations=100):\n    \"\"\"Main VNS algorithm\"\"\"\n    neighborhoods = [\n        neighborhood_move_single,\n        neighborhood_swap_two,\n        neighborhood_perturb_radii,\n        neighborhood_rotate,\n        neighborhood_scale\n    ]\n    \n    neighborhood_names = [\n        \"Move Single Circle\",\n        \"Swap Two Circles\",\n        \"Perturb Radii\",\n        \"Rotate Configuration\",\n        \"Scale Configuration\"\n    ]\n    \n    best_coords = initial_coords.copy()\n    best_radii = initial_radii.copy()\n    best_coverage = calculate_coverage(best_coords, best_radii)\n    \n    print(f\"Initial coverage: {best_coverage:.6f}\")\n    print(f\"Starting VNS with {max_iterations} iterations...\\n\")\n    \n    coverage_history = [best_coverage]\n    improvements = {name: 0 for name in neighborhood_names}\n    \n    for iteration in range(max_iterations):\n        improved = False\n        \n        # Try each neighborhood structure\n        for k, (neighborhood, name) in enumerate(zip(neighborhoods, neighborhood_names)):\n            # Generate neighbor\n            coords, rads = neighborhood(best_coords, best_radii)\n            \n            if not check_constraints(coords, rads):\n                continue\n            \n            # Apply local search\n            coords, rads, coverage = local_search(coords, rads)\n            \n            # Check for improvement\n            if coverage > best_coverage + 1e-8:\n                best_coords = coords\n                best_radii = rads\n                best_coverage = coverage\n                improved = True\n                improvements[name] += 1\n                \n                print(f\"Iteration {iteration + 1}: Improved with '{name}'\")\n                print(f\"  New coverage: {best_coverage:.6f}\")\n                \n                # Restart from first neighborhood\n                break\n        \n        coverage_history.append(best_coverage)\n        \n        if (iteration + 1) % 10 == 0:\n            print(f\"\\nIteration {iteration + 1}/{max_iterations}\")\n            print(f\"  Current best coverage: {best_coverage:.6f}\")\n            print(f\"  Improvements by neighborhood:\")\n            for name, count in improvements.items():\n                print(f\"    {name}: {count}\")\n            print()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"VNS COMPLETE\")\n    print(\"=\"*60)\n    print(f\"Final coverage: {best_coverage:.6f}\")\n    print(f\"\\nTotal improvements by neighborhood:\")\n    for name, count in improvements.items():\n        print(f\"  {name}: {count}\")\n    \n    return best_coords, best_radii, best_coverage, coverage_history, improvements\n\ndef visualize_solution(coordinates, radii, coverage, filename='vns_solution.png'):\n    \"\"\"Visualize the final solution\"\"\"\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))\n    \n    # Plot circles\n    ax1.set_xlim(0, 1)\n    ax1.set_ylim(0, 1)\n    ax1.set_aspect('equal')\n    ax1.set_title(f'VNS Solution - Coverage: {coverage:.6f}')\n    \n    colors = plt.cm.Set3(np.linspace(0, 1, len(coordinates)))\n    \n    for i, ((x, y), r) in enumerate(zip(coordinates, radii)):\n        circle = Circle((x, y), r, color=colors[i], alpha=0.6, ec='black', linewidth=1.5)\n        ax1.add_patch(circle)\n        ax1.plot(x, y, 'k.', markersize=8)\n        ax1.text(x, y, str(i+1), ha='center', va='center', fontsize=10, fontweight='bold')\n    \n    ax1.grid(True, alpha=0.3)\n    ax1.set_xlabel('X')\n    ax1.set_ylabel('Y')\n    \n    # Plot coverage grid\n    resolution = 200\n    x = np.linspace(0, 1, resolution)\n    y = np.linspace(0, 1, resolution)\n    X, Y = np.meshgrid(x, y)\n    \n    Z = np.zeros_like(X)\n    for (cx, cy), r in zip(coordinates, radii):\n        dist = np.sqrt((X - cx)**2 + (Y - cy)**2)\n        Z = np.maximum(Z, (dist <= r).astype(float))\n    \n    ax2.contourf(X, Y, Z, levels=[0, 0.5, 1], colors=['white', 'lightblue'], alpha=0.7)\n    \n    for i, ((x, y), r) in enumerate(zip(coordinates, radii)):\n        circle = Circle((x, y), r, fill=False, ec='red', linewidth=2)\n        ax2.add_patch(circle)\n    \n    ax2.set_xlim(0, 1)\n    ax2.set_ylim(0, 1)\n    ax2.set_aspect('equal')\n    ax2.set_title('Coverage Map')\n    ax2.grid(True, alpha=0.3)\n    ax2.set_xlabel('X')\n    ax2.set_ylabel('Y')\n    \n    plt.tight_layout()\n    plt.savefig(filename, dpi=150, bbox_inches='tight')\n    print(f\"\\nVisualization saved as '{filename}'\")\n    plt.close()\n\ndef plot_convergence(coverage_history, improvements, filename='vns_convergence.png'):\n    \"\"\"Plot convergence history\"\"\"\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n    \n    # Convergence plot\n    ax1.plot(coverage_history, linewidth=2, color='blue')\n    ax1.set_xlabel('Iteration')\n    ax1.set_ylabel('Coverage')\n    ax1.set_title('VNS Convergence History')\n    ax1.grid(True, alpha=0.3)\n    \n    # Improvements by neighborhood\n    names = list(improvements.keys())\n    counts = list(improvements.values())\n    colors = plt.cm.Set2(np.linspace(0, 1, len(names)))\n    \n    bars = ax2.bar(range(len(names)), counts, color=colors, alpha=0.7, edgecolor='black')\n    ax2.set_xticks(range(len(names)))\n    ax2.set_xticklabels([name.replace(' ', '\\n') for name in names], fontsize=9)\n    ax2.set_ylabel('Number of Improvements')\n    ax2.set_title('Improvements by Neighborhood Structure')\n    ax2.grid(True, alpha=0.3, axis='y')\n    \n    # Add value labels on bars\n    for bar in bars:\n        height = bar.get_height()\n        if height > 0:\n            ax2.text(bar.get_x() + bar.get_width()/2., height,\n                    f'{int(height)}', ha='center', va='bottom', fontweight='bold')\n    \n    plt.tight_layout()\n    plt.savefig(filename, dpi=150, bbox_inches='tight')\n    print(f\"Convergence plot saved as '{filename}'\")\n    plt.close()\n\ndef save_solution(coordinates, radii, coverage, filename='vns_solution.json'):\n    \"\"\"Save solution to file\"\"\"\n    solution = {\n        'coverage': float(coverage),\n        'num_circles': len(coordinates),\n        'coordinates': coordinates.tolist(),\n        'radii': radii.tolist()\n    }\n    \n    with open(filename, 'w') as f:\n        json.dump(solution, f, indent=2)\n    \n    print(f\"Solution saved as '{filename}'\")\n\n# Main execution\nif __name__ == \"__main__\":\n    print(\"=\"*60)\n    print(\"VARIABLE NEIGHBORHOOD SEARCH\")\n    print(\"=\"*60)\n    \n    # Load initial solution\n    initial_coords, initial_radii = load_best_solution()\n    \n    if initial_coords is None:\n        print(\"Could not load trial_1_7.json, using default configuration\")\n        # Use a reasonable default\n        initial_coords = np.array([\n            [0.15, 0.15], [0.45, 0.15], [0.75, 0.15],\n            [0.15, 0.45], [0.45, 0.45], [0.75, 0.45],\n            [0.15, 0.75], [0.45, 0.75], [0.75, 0.75]\n        ])\n        initial_radii = np.array([0.12, 0.12, 0.12, 0.12, 0.12, 0.12, 0.12, 0.12, 0.12])\n    \n    print(f\"\\nStarting configuration:\")\n    print(f\"  Number of circles: {len(initial_coords)}\")\n    print(f\"  Sum of radii: {initial_radii.sum():.6f}\")\n    \n    # Run VNS\n    best_coords, best_radii, best_coverage, history, improvements = variable_neighborhood_search(\n        initial_coords, initial_radii, max_iterations=100\n    )\n    \n    # Verify final solution\n    print(",
  "timestamp": "2025-12-08T16:02:37.716730",
  "cost_data": null
}