{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Progressive packing algorithm for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Step 1: Place 4 large circles in corners\n    # Use symmetric placement for optimal packing\n    r1 = 0.15  # Initial radius for corner circles\n    corner_positions = [\n        (r1, r1),           # bottom-left\n        (1-r1, r1),         # bottom-right\n        (r1, 1-r1),         # top-left\n        (1-r1, 1-r1)        # top-right\n    ]\n    \n    for pos in corner_positions:\n        centers.append(pos)\n        radii.append(r1)\n    \n    # Step 2: Place 2 circles on edges (left and right)\n    r2 = 0.12\n    edge_positions = [\n        (r2, 0.5),          # left edge\n        (1-r2, 0.5)         # right edge\n    ]\n    \n    for pos in edge_positions:\n        centers.append(pos)\n        radii.append(r2)\n    \n    # Step 3: Progressive packing - add remaining 20 circles\n    num_remaining = 26 - len(centers)\n    \n    for i in range(num_remaining):\n        # Find the best location for the next circle\n        best_center, best_radius = find_largest_gap(\n            np.array(centers), \n            np.array(radii)\n        )\n        \n        if best_radius > 0:\n            centers.append(best_center)\n            radii.append(best_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef find_largest_gap(centers: np.ndarray, radii: np.ndarray) -> Tuple[Tuple[float, float], float]:\n    \"\"\"\n    Find the location and radius of the largest circle that can fit in remaining space.\n    \n    Args:\n        centers: (n, 2) array of existing circle centers\n        radii: (n,) array of existing circle radii\n    \n    Returns:\n        best_center: (x, y) coordinates of new circle\n        best_radius: radius of new circle\n    \"\"\"\n    best_radius = 0\n    best_center = (0.5, 0.5)\n    \n    # Generate candidate positions using a grid search\n    # and also positions between existing circles\n    candidates = generate_candidate_positions(centers, radii)\n    \n    for candidate in candidates:\n        # Find maximum radius that fits at this position\n        max_r = compute_max_radius(candidate, centers, radii)\n        \n        if max_r > best_radius:\n            best_radius = max_r\n            best_center = candidate\n    \n    # Refine the best position using local optimization\n    if best_radius > 0:\n        result = optimize_position(best_center, centers, radii)\n        best_center = result['center']\n        best_radius = result['radius']\n    \n    return best_center, best_radius\n\n\ndef generate_candidate_positions(centers: np.ndarray, radii: np.ndarray, \n                                 grid_size: int = 20) -> List[Tuple[float, float]]:\n    \"\"\"\n    Generate candidate positions for new circles.\n    \n    Combines grid search with positions between existing circles.\n    \"\"\"\n    candidates = []\n    \n    # Grid-based candidates\n    x_grid = np.linspace(0.05, 0.95, grid_size)\n    y_grid = np.linspace(0.05, 0.95, grid_size)\n    \n    for x in x_grid:\n        for y in y_grid:\n            candidates.append((x, y))\n    \n    # Add positions between pairs of circles\n    n = len(centers)\n    for i in range(n):\n        for j in range(i+1, n):\n            # Midpoint between two circles\n            mid = (centers[i] + centers[j]) / 2\n            candidates.append(tuple(mid))\n            \n            # Points along the line between circles\n            for t in [0.3, 0.7]:\n                point = centers[i] * t + centers[j] * (1 - t)\n                candidates.append(tuple(point))\n    \n    # Add positions in Voronoi-like gaps (perpendicular to edges)\n    for i in range(n):\n        for j in range(i+1, n):\n            mid = (centers[i] + centers[j]) / 2\n            direction = centers[j] - centers[i]\n            perp = np.array([-direction[1], direction[0]])\n            if np.linalg.norm(perp) > 0:\n                perp = perp / np.linalg.norm(perp)\n                \n                for offset in [0.05, 0.1, 0.15]:\n                    for sign in [-1, 1]:\n                        point = mid + sign * offset * perp\n                        if 0 < point[0] < 1 and 0 < point[1] < 1:\n                            candidates.append(tuple(point))\n    \n    return candidates\n\n\ndef compute_max_radius(center: Tuple[float, float], \n                       centers: np.ndarray, \n                       radii: np.ndarray,\n                       margin: float = 1e-6) -> float:\n    \"\"\"\n    Compute the maximum radius for a circle at the given center.\n    \n    Constraints:\n    - Must not overlap with existing circles\n    - Must stay within [0,1]x[0,1] bounds\n    \"\"\"\n    x, y = center\n    \n    # Distance to boundaries\n    dist_to_boundaries = min(x, y, 1-x, 1-y)\n    \n    # Distance to existing circles\n    if len(centers) > 0:\n        distances = np.sqrt(np.sum((centers - np.array(center))**2, axis=1))\n        min_dist_to_circles = np.min(distances - radii)\n    else:\n        min_dist_to_circles = float('inf')\n    \n    # Maximum radius is the minimum of all constraints\n    max_r = min(dist_to_boundaries, min_dist_to_circles) - margin\n    \n    return max(0, max_r)\n\n\ndef optimize_position(initial_center: Tuple[float, float],\n                     centers: np.ndarray,\n                     radii: np.ndarray) -> dict:\n    \"\"\"\n    Optimize the position of a new circle to maximize its radius.\n    \"\"\"\n    def objective(pos):\n        # Negative because we want to maximize radius\n        return -compute_max_radius(tuple(pos), centers, radii)\n    \n    # Bounds to keep circle center within reasonable range\n    bounds = [(0.02, 0.98), (0.02, 0.98)]\n    \n    result = minimize(\n        objective,\n        x0=initial_center,\n        method='L-BFGS-B',\n        bounds=bounds\n    )\n    \n    optimized_center = tuple(result.x)\n    optimized_radius = compute_max_radius(optimized_center, centers, radii)\n    \n    return {\n        'center': optimized_center,\n        'radius': optimized_radius\n    }\n\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Successfully packed {len(centers)} circles\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Verify packing is valid\n    verify_packing(centers, radii)\n    \n    return centers, radii, sum_radii\n\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tolerance: float = 1e-5):\n    \"\"\"\n    Verify that the packing is valid (no overlaps, all circles within bounds).\n    \"\"\"\n    n = len(centers)\n    \n    # Check bounds\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        assert x - r >= -tolerance, f\"Circle {i} exceeds left boundary\"\n        assert x + r <= 1 + tolerance, f\"Circle {i} exceeds right boundary\"\n        assert y - r >= -tolerance, f\"Circle {i} exceeds bottom boundary\"\n        assert y + r <= 1 + tolerance, f\"Circle {i} exceeds top boundary\"\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            assert dist >= min_dist - tolerance, \\\n                f\"Circles {i} and {j} overlap: dist={dist:.6f}, min_dist={min_dist:.6f}\"\n    \n    print(\"\u2713 Packing verified: all circles within bounds and no overlaps\")\n\n\nif __name__ == \"__main__\":\n    run_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.2386199960193336,
    "target_ratio": 0.8495711559845669,
    "combined_score": 0.8495711559845669,
    "eval_time": 0.4260287284851074,
    "error": null
  },
  "prompt": "Write a progressive packing algorithm for 26 circles in [0,1]x[0,1].\n\nStart by placing a few large circles optimally, then progressively add smaller circles in the remaining gaps. This mimics how humans might pack circles.\n\nStrategy:\n1. Place 4-6 large circles in corners/edges\n2. Find largest gaps between existing circles\n3. Place new circles in these gaps\n4. Repeat until all 26 circles are placed\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use a gap-finding algorithm to identify promising locations\n- Compute maximum radius for each new circle given existing circles\n- Use numpy for efficient distance calculations",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Progressive packing algorithm for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Step 1: Place 4 large circles in corners\n    # Use symmetric placement for optimal packing\n    r1 = 0.15  # Initial radius for corner circles\n    corner_positions = [\n        (r1, r1),           # bottom-left\n        (1-r1, r1),         # bottom-right\n        (r1, 1-r1),         # top-left\n        (1-r1, 1-r1)        # top-right\n    ]\n    \n    for pos in corner_positions:\n        centers.append(pos)\n        radii.append(r1)\n    \n    # Step 2: Place 2 circles on edges (left and right)\n    r2 = 0.12\n    edge_positions = [\n        (r2, 0.5),          # left edge\n        (1-r2, 0.5)         # right edge\n    ]\n    \n    for pos in edge_positions:\n        centers.append(pos)\n        radii.append(r2)\n    \n    # Step 3: Progressive packing - add remaining 20 circles\n    num_remaining = 26 - len(centers)\n    \n    for i in range(num_remaining):\n        # Find the best location for the next circle\n        best_center, best_radius = find_largest_gap(\n            np.array(centers), \n            np.array(radii)\n        )\n        \n        if best_radius > 0:\n            centers.append(best_center)\n            radii.append(best_radius)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef find_largest_gap(centers: np.ndarray, radii: np.ndarray) -> Tuple[Tuple[float, float], float]:\n    \"\"\"\n    Find the location and radius of the largest circle that can fit in remaining space.\n    \n    Args:\n        centers: (n, 2) array of existing circle centers\n        radii: (n,) array of existing circle radii\n    \n    Returns:\n        best_center: (x, y) coordinates of new circle\n        best_radius: radius of new circle\n    \"\"\"\n    best_radius = 0\n    best_center = (0.5, 0.5)\n    \n    # Generate candidate positions using a grid search\n    # and also positions between existing circles\n    candidates = generate_candidate_positions(centers, radii)\n    \n    for candidate in candidates:\n        # Find maximum radius that fits at this position\n        max_r = compute_max_radius(candidate, centers, radii)\n        \n        if max_r > best_radius:\n            best_radius = max_r\n            best_center = candidate\n    \n    # Refine the best position using local optimization\n    if best_radius > 0:\n        result = optimize_position(best_center, centers, radii)\n        best_center = result['center']\n        best_radius = result['radius']\n    \n    return best_center, best_radius\n\n\ndef generate_candidate_positions(centers: np.ndarray, radii: np.ndarray, \n                                 grid_size: int = 20) -> List[Tuple[float, float]]:\n    \"\"\"\n    Generate candidate positions for new circles.\n    \n    Combines grid search with positions between existing circles.\n    \"\"\"\n    candidates = []\n    \n    # Grid-based candidates\n    x_grid = np.linspace(0.05, 0.95, grid_size)\n    y_grid = np.linspace(0.05, 0.95, grid_size)\n    \n    for x in x_grid:\n        for y in y_grid:\n            candidates.append((x, y))\n    \n    # Add positions between pairs of circles\n    n = len(centers)\n    for i in range(n):\n        for j in range(i+1, n):\n            # Midpoint between two circles\n            mid = (centers[i] + centers[j]) / 2\n            candidates.append(tuple(mid))\n            \n            # Points along the line between circles\n            for t in [0.3, 0.7]:\n                point = centers[i] * t + centers[j] * (1 - t)\n                candidates.append(tuple(point))\n    \n    # Add positions in Voronoi-like gaps (perpendicular to edges)\n    for i in range(n):\n        for j in range(i+1, n):\n            mid = (centers[i] + centers[j]) / 2\n            direction = centers[j] - centers[i]\n            perp = np.array([-direction[1], direction[0]])\n            if np.linalg.norm(perp) > 0:\n                perp = perp / np.linalg.norm(perp)\n                \n                for offset in [0.05, 0.1, 0.15]:\n                    for sign in [-1, 1]:\n                        point = mid + sign * offset * perp\n                        if 0 < point[0] < 1 and 0 < point[1] < 1:\n                            candidates.append(tuple(point))\n    \n    return candidates\n\n\ndef compute_max_radius(center: Tuple[float, float], \n                       centers: np.ndarray, \n                       radii: np.ndarray,\n                       margin: float = 1e-6) -> float:\n    \"\"\"\n    Compute the maximum radius for a circle at the given center.\n    \n    Constraints:\n    - Must not overlap with existing circles\n    - Must stay within [0,1]x[0,1] bounds\n    \"\"\"\n    x, y = center\n    \n    # Distance to boundaries\n    dist_to_boundaries = min(x, y, 1-x, 1-y)\n    \n    # Distance to existing circles\n    if len(centers) > 0:\n        distances = np.sqrt(np.sum((centers - np.array(center))**2, axis=1))\n        min_dist_to_circles = np.min(distances - radii)\n    else:\n        min_dist_to_circles = float('inf')\n    \n    # Maximum radius is the minimum of all constraints\n    max_r = min(dist_to_boundaries, min_dist_to_circles) - margin\n    \n    return max(0, max_r)\n\n\ndef optimize_position(initial_center: Tuple[float, float],\n                     centers: np.ndarray,\n                     radii: np.ndarray) -> dict:\n    \"\"\"\n    Optimize the position of a new circle to maximize its radius.\n    \"\"\"\n    def objective(pos):\n        # Negative because we want to maximize radius\n        return -compute_max_radius(tuple(pos), centers, radii)\n    \n    # Bounds to keep circle center within reasonable range\n    bounds = [(0.02, 0.98), (0.02, 0.98)]\n    \n    result = minimize(\n        objective,\n        x0=initial_center,\n        method='L-BFGS-B',\n        bounds=bounds\n    )\n    \n    optimized_center = tuple(result.x)\n    optimized_radius = compute_max_radius(optimized_center, centers, radii)\n    \n    return {\n        'center': optimized_center,\n        'radius': optimized_radius\n    }\n\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Successfully packed {len(centers)} circles\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Verify packing is valid\n    verify_packing(centers, radii)\n    \n    return centers, radii, sum_radii\n\n\ndef verify_packing(centers: np.ndarray, radii: np.ndarray, tolerance: float = 1e-5):\n    \"\"\"\n    Verify that the packing is valid (no overlaps, all circles within bounds).\n    \"\"\"\n    n = len(centers)\n    \n    # Check bounds\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        assert x - r >= -tolerance, f\"Circle {i} exceeds left boundary\"\n        assert x + r <= 1 + tolerance, f\"Circle {i} exceeds right boundary\"\n        assert y - r >= -tolerance, f\"Circle {i} exceeds bottom boundary\"\n        assert y + r <= 1 + tolerance, f\"Circle {i} exceeds top boundary\"\n    \n    # Check overlaps\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            assert dist >= min_dist - tolerance, \\\n                f\"Circles {i} and {j} overlap: dist={dist:.6f}, min_dist={min_dist:.6f}\"\n    \n    print(\"\u2713 Packing verified: all circles within bounds and no overlaps\")\n\n\nif __name__ == \"__main__\":\n    run_packing()\n```\n\nThis implementation provides a progressive packing algorithm that:\n\n1. **Starts with large circles**: Places 6 large circles strategically (4 in corners, 2 on edges)\n\n2. **Progressive filling**: Adds remaining 20 circles by repeatedly finding the largest gap\n\n3. **Smart gap finding**: \n   - Uses grid search for broad coverage\n   - Checks positions between existing circles\n   - Explores perpendicular directions from circle pairs\n\n4. **Optimization**: Locally optimizes each new circle's position to maximize its radius\n\n5. **Validation**: Verifies no overlaps and all circles stay within bounds\n\nThe algorithm mimics human intuition by starting with obvious placements and then filling gaps progressively, achieving a good balance between packing density and computational efficiency.",
  "reasoning": "This implementation provides a progressive packing algorithm that:\n\n1. **Starts with large circles**: Places 6 large circles strategically (4 in corners, 2 on edges)\n\n2. **Progressive filling**: Adds remaining 20 circles by repeatedly finding the largest gap\n\n3. **Smart gap finding**: \n   - Uses grid search for broad coverage\n   - Checks positions between existing circles\n   - Explores perpendicular directions from circle pairs\n\n4. **Optimization**: Locally optimizes each new circle's position to maximize its radius\n\n5. **Validation**: Verifies no overlaps and all circles stay within bounds\n\nThe algorithm mimics human intuition by starting with obvious placements and then filling gaps progressively, achieving a good balance between packing density and computational efficiency.",
  "timestamp": "2025-12-08T15:53:10.498089",
  "cost_data": null
}