{
  "trial_id": "trial_0_13",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple, List\nimport random\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Constructs a circle packing using random restart hill climbing.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    n_restarts = 40\n    \n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    for restart in range(n_restarts):\n        centers, radii, sum_radii = hill_climbing(n_circles)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef hill_climbing(n_circles: int, max_iterations: int = 1000) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Performs hill climbing to optimize circle packing.\n    \"\"\"\n    # Generate random initial configuration\n    centers, radii = generate_random_configuration(n_circles)\n    current_sum = np.sum(radii)\n    \n    # Hill climbing loop\n    no_improvement_count = 0\n    max_no_improvement = 100\n    \n    for iteration in range(max_iterations):\n        if no_improvement_count >= max_no_improvement:\n            break\n        \n        # Try a perturbation\n        new_centers, new_radii, perturbation_type, perturb_idx = perturb_configuration(\n            centers.copy(), radii.copy()\n        )\n        \n        new_sum = np.sum(new_radii)\n        \n        # Accept if improvement\n        if new_sum > current_sum:\n            centers = new_centers\n            radii = new_radii\n            current_sum = new_sum\n            no_improvement_count = 0\n        else:\n            no_improvement_count += 1\n    \n    return centers, radii, current_sum\n\n\ndef generate_random_configuration(n_circles: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generates a random valid initial configuration.\n    Uses a strategy that places circles with small initial radii.\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    \n    # Start with small radii\n    radii = np.full(n_circles, 0.01)\n    \n    # Try to grow each radius\n    for i in range(n_circles):\n        radii[i] = compute_max_radius(centers, radii, i)\n    \n    return centers, radii\n\n\ndef compute_max_radius(centers: np.ndarray, radii: np.ndarray, circle_idx: int) -> float:\n    \"\"\"\n    Computes the maximum valid radius for a given circle.\n    \"\"\"\n    cx, cy = centers[circle_idx]\n    n_circles = len(centers)\n    \n    # Constraints from boundaries\n    max_r = min(cx, cy, 1 - cx, 1 - cy)\n    \n    # Constraints from other circles\n    for j in range(n_circles):\n        if j == circle_idx:\n            continue\n        \n        dist = np.linalg.norm(centers[circle_idx] - centers[j])\n        max_r_from_j = dist - radii[j]\n        \n        if max_r_from_j < max_r:\n            max_r = max_r_from_j\n    \n    return max(max_r, 0.001)  # Minimum radius to avoid degenerate cases\n\n\ndef perturb_configuration(centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray, str, int]:\n    \"\"\"\n    Applies a random perturbation to the configuration.\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Choose perturbation type\n    perturb_type = random.choice(['move', 'grow', 'swap'])\n    \n    if perturb_type == 'move':\n        # Move a random circle\n        idx = random.randint(0, n_circles - 1)\n        \n        # Small random movement\n        step_size = 0.05\n        new_center = centers[idx] + np.random.randn(2) * step_size\n        new_center = np.clip(new_center, 0, 1)\n        \n        centers[idx] = new_center\n        \n        # Recompute radius for moved circle\n        radii[idx] = compute_max_radius(centers, radii, idx)\n        \n        # Recompute radii for nearby circles\n        for j in range(n_circles):\n            if j != idx:\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                if dist < radii[idx] + radii[j] + 0.1:\n                    radii[j] = compute_max_radius(centers, radii, j)\n        \n        return centers, radii, 'move', idx\n    \n    elif perturb_type == 'grow':\n        # Try to grow a random circle\n        idx = random.randint(0, n_circles - 1)\n        new_radius = compute_max_radius(centers, radii, idx)\n        radii[idx] = new_radius\n        \n        return centers, radii, 'grow', idx\n    \n    else:  # swap\n        # Swap positions of two circles\n        idx1 = random.randint(0, n_circles - 1)\n        idx2 = random.randint(0, n_circles - 1)\n        \n        centers[[idx1, idx2]] = centers[[idx2, idx1]]\n        \n        # Recompute radii for both\n        radii[idx1] = compute_max_radius(centers, radii, idx1)\n        radii[idx2] = compute_max_radius(centers, radii, idx2)\n        \n        return centers, radii, 'swap', idx1\n\n\ndef is_valid_configuration(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a configuration is valid (no overlaps, within bounds).\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n_circles):\n        cx, cy = centers[i]\n        r = radii[i]\n        \n        if cx - r < -1e-6 or cx + r > 1 + 1e-6:\n            return False\n        if cy - r < -1e-6 or cy + r > 1 + 1e-6:\n            return False\n    \n    # Check circle-circle constraints\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for running the circle packing algorithm.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Best sum of radii: {sum_radii:.6f}\")\n    print(f\"Configuration valid: {is_valid_configuration(centers, radii)}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Print some statistics\n    print(f\"\\nNumber of circles: {len(centers)}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.1914707806254747,
    "target_ratio": 0.8316777156073909,
    "combined_score": 0.8316777156073909,
    "eval_time": 2.9033658504486084,
    "error": null
  },
  "prompt": "Write a random restart hill climbing algorithm for 26 circles in [0,1]x[0,1].\n\nPerform multiple hill climbing runs from different random initial configurations, keeping the best result.\n\nHill climbing:\n1. Start with a random valid configuration\n2. Try small perturbations (move circles, adjust radii)\n3. Accept improvements, reject worse solutions\n4. Repeat until local optimum\n\nRandom restart: Run hill climbing 20-50 times with different initializations.\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Generate diverse random initial configurations\n- Implement efficient local search\n- Track and return best solution across all restarts",
  "response": "Here's a random restart hill climbing algorithm for packing 26 circles:\n\n```python\nimport numpy as np\nfrom typing import Tuple, List\nimport random\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Constructs a circle packing using random restart hill climbing.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    n_restarts = 40\n    \n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    for restart in range(n_restarts):\n        centers, radii, sum_radii = hill_climbing(n_circles)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef hill_climbing(n_circles: int, max_iterations: int = 1000) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Performs hill climbing to optimize circle packing.\n    \"\"\"\n    # Generate random initial configuration\n    centers, radii = generate_random_configuration(n_circles)\n    current_sum = np.sum(radii)\n    \n    # Hill climbing loop\n    no_improvement_count = 0\n    max_no_improvement = 100\n    \n    for iteration in range(max_iterations):\n        if no_improvement_count >= max_no_improvement:\n            break\n        \n        # Try a perturbation\n        new_centers, new_radii, perturbation_type, perturb_idx = perturb_configuration(\n            centers.copy(), radii.copy()\n        )\n        \n        new_sum = np.sum(new_radii)\n        \n        # Accept if improvement\n        if new_sum > current_sum:\n            centers = new_centers\n            radii = new_radii\n            current_sum = new_sum\n            no_improvement_count = 0\n        else:\n            no_improvement_count += 1\n    \n    return centers, radii, current_sum\n\n\ndef generate_random_configuration(n_circles: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generates a random valid initial configuration.\n    Uses a strategy that places circles with small initial radii.\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    \n    # Start with small radii\n    radii = np.full(n_circles, 0.01)\n    \n    # Try to grow each radius\n    for i in range(n_circles):\n        radii[i] = compute_max_radius(centers, radii, i)\n    \n    return centers, radii\n\n\ndef compute_max_radius(centers: np.ndarray, radii: np.ndarray, circle_idx: int) -> float:\n    \"\"\"\n    Computes the maximum valid radius for a given circle.\n    \"\"\"\n    cx, cy = centers[circle_idx]\n    n_circles = len(centers)\n    \n    # Constraints from boundaries\n    max_r = min(cx, cy, 1 - cx, 1 - cy)\n    \n    # Constraints from other circles\n    for j in range(n_circles):\n        if j == circle_idx:\n            continue\n        \n        dist = np.linalg.norm(centers[circle_idx] - centers[j])\n        max_r_from_j = dist - radii[j]\n        \n        if max_r_from_j < max_r:\n            max_r = max_r_from_j\n    \n    return max(max_r, 0.001)  # Minimum radius to avoid degenerate cases\n\n\ndef perturb_configuration(centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray, str, int]:\n    \"\"\"\n    Applies a random perturbation to the configuration.\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Choose perturbation type\n    perturb_type = random.choice(['move', 'grow', 'swap'])\n    \n    if perturb_type == 'move':\n        # Move a random circle\n        idx = random.randint(0, n_circles - 1)\n        \n        # Small random movement\n        step_size = 0.05\n        new_center = centers[idx] + np.random.randn(2) * step_size\n        new_center = np.clip(new_center, 0, 1)\n        \n        centers[idx] = new_center\n        \n        # Recompute radius for moved circle\n        radii[idx] = compute_max_radius(centers, radii, idx)\n        \n        # Recompute radii for nearby circles\n        for j in range(n_circles):\n            if j != idx:\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                if dist < radii[idx] + radii[j] + 0.1:\n                    radii[j] = compute_max_radius(centers, radii, j)\n        \n        return centers, radii, 'move', idx\n    \n    elif perturb_type == 'grow':\n        # Try to grow a random circle\n        idx = random.randint(0, n_circles - 1)\n        new_radius = compute_max_radius(centers, radii, idx)\n        radii[idx] = new_radius\n        \n        return centers, radii, 'grow', idx\n    \n    else:  # swap\n        # Swap positions of two circles\n        idx1 = random.randint(0, n_circles - 1)\n        idx2 = random.randint(0, n_circles - 1)\n        \n        centers[[idx1, idx2]] = centers[[idx2, idx1]]\n        \n        # Recompute radii for both\n        radii[idx1] = compute_max_radius(centers, radii, idx1)\n        radii[idx2] = compute_max_radius(centers, radii, idx2)\n        \n        return centers, radii, 'swap', idx1\n\n\ndef is_valid_configuration(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a configuration is valid (no overlaps, within bounds).\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n_circles):\n        cx, cy = centers[i]\n        r = radii[i]\n        \n        if cx - r < -1e-6 or cx + r > 1 + 1e-6:\n            return False\n        if cy - r < -1e-6 or cy + r > 1 + 1e-6:\n            return False\n    \n    # Check circle-circle constraints\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for running the circle packing algorithm.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Best sum of radii: {sum_radii:.6f}\")\n    print(f\"Configuration valid: {is_valid_configuration(centers, radii)}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Print some statistics\n    print(f\"\\nNumber of circles: {len(centers)}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n```\n\nThis implementation includes:\n\n1. **Random Restart**: Runs hill climbing 40 times with different initializations\n2. **Hill Climbing**: Iteratively improves configurations through local search\n3. **Multiple Perturbation Types**:\n   - Move: Relocate a circle to a nearby position\n   - Grow: Maximize a circle's radius given constraints\n   - Swap: Exchange positions of two circles\n4. **Constraint Handling**: Ensures circles don't overlap and stay within [0,1]\u00d7[0,1]\n5. **Efficient Radius Computation**: Computes maximum valid radius for each circle\n6. **Early Stopping**: Terminates when no improvement is found for 100 iterations\n\nThe algorithm balances exploration (random restarts) with exploitation (hill climbing) to find good circle packings.",
  "reasoning": "Here's a random restart hill climbing algorithm for packing 26 circles:\n\nThis implementation includes:\n\n1. **Random Restart**: Runs hill climbing 40 times with different initializations\n2. **Hill Climbing**: Iteratively improves configurations through local search\n3. **Multiple Perturbation Types**:\n   - Move: Relocate a circle to a nearby position\n   - Grow: Maximize a circle's radius given constraints\n   - Swap: Exchange positions of two circles\n4. **Constraint Handling**: Ensures circles don't overlap and stay within [0,1]\u00d7[0,1]\n5. **Efficient Radius Computation**: Computes maximum valid radius for each circle\n6. **Early Stopping**: Terminates when no improvement is found for 100 iterations\n\nThe algorithm balances exploration (random restarts) with exploitation (hill climbing) to find good circle packings.",
  "timestamp": "2025-12-08T15:53:04.494123",
  "cost_data": null
}