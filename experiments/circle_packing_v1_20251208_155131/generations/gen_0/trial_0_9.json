{
  "trial_id": "trial_0_9",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a force-directed circle packing for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    n_circles = 26\n    np.random.seed(42)\n    \n    # Initialize circles in a grid pattern with small radii\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = 0.15 + (col * 0.7 / (grid_size - 1))\n        y = 0.15 + (row * 0.7 / (grid_size - 1))\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n_circles, 0.02)\n    \n    # Simulation parameters\n    n_steps = 1000\n    dt = 0.01\n    friction = 0.9\n    \n    # Force weights\n    overlap_strength = 0.5\n    boundary_strength = 0.3\n    radius_expansion_rate = 0.0001\n    \n    velocities = np.zeros_like(centers)\n    \n    for step in range(n_steps):\n        forces = np.zeros_like(centers)\n        \n        # 1. Overlap repulsion forces\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist and dist > 1e-6:\n                    # Circles overlap, push apart\n                    overlap = min_dist - dist\n                    direction = diff / dist\n                    force_magnitude = overlap_strength * overlap\n                    \n                    forces[i] += direction * force_magnitude\n                    forces[j] -= direction * force_magnitude\n        \n        # 2. Boundary forces (keep circles inside [0,1]x[0,1])\n        for i in range(n_circles):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 0]\n                forces[i, 0] += boundary_strength * penetration\n            \n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                penetration = centers[i, 0] + radii[i] - 1\n                forces[i, 0] -= boundary_strength * penetration\n            \n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 1]\n                forces[i, 1] += boundary_strength * penetration\n            \n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                penetration = centers[i, 1] + radii[i] - 1\n                forces[i, 1] -= boundary_strength * penetration\n        \n        # 3. Update velocities and positions\n        velocities += forces * dt\n        velocities *= friction  # Apply friction\n        centers += velocities * dt\n        \n        # Clamp positions to valid range\n        centers = np.clip(centers, 0, 1)\n        \n        # 4. Radius expansion (try to grow all circles)\n        if step % 10 == 0:  # Don't expand every step for stability\n            can_expand = np.ones(n_circles, dtype=bool)\n            \n            # Check if expansion would cause overlap or boundary violation\n            test_radii = radii + radius_expansion_rate\n            \n            for i in range(n_circles):\n                # Check boundary constraints\n                if (centers[i, 0] - test_radii[i] < 0 or \n                    centers[i, 0] + test_radii[i] > 1 or\n                    centers[i, 1] - test_radii[i] < 0 or \n                    centers[i, 1] + test_radii[i] > 1):\n                    can_expand[i] = False\n                    continue\n                \n                # Check overlap with other circles\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < test_radii[i] + test_radii[j]:\n                            can_expand[i] = False\n                            break\n            \n            # Expand circles that can grow\n            radii[can_expand] += radius_expansion_rate\n        \n        # 5. Adaptive radius expansion rate (slow down as we converge)\n        if step > 500:\n            radius_expansion_rate *= 0.999\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Entry point for running the circle packing algorithm.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Circle packing complete!\")\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"Average radius: {np.mean(radii):.4f}\")\n    print(f\"Min radius: {np.min(radii):.4f}\")\n    print(f\"Max radius: {np.max(radii):.4f}\")\n    \n    # Verify no overlaps\n    overlaps = 0\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                overlaps += 1\n    \n    print(f\"Number of overlaps: {overlaps}\")\n    \n    # Verify boundary constraints\n    out_of_bounds = 0\n    for i in range(len(centers)):\n        if (centers[i, 0] - radii[i] < -1e-6 or \n            centers[i, 0] + radii[i] > 1 + 1e-6 or\n            centers[i, 1] - radii[i] < -1e-6 or \n            centers[i, 1] + radii[i] > 1 + 1e-6):\n            out_of_bounds += 1\n    \n    print(f\"Circles out of bounds: {out_of_bounds}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 0.7529031588676515,
    "target_ratio": 0.28573174909588295,
    "combined_score": 0.28573174909588295,
    "eval_time": 0.5314679145812988,
    "error": null
  },
  "prompt": "Write a force-directed circle packing algorithm for 26 circles in [0,1]x[0,1].\n\nSimulate physical forces between circles: repulsion when overlapping, attraction to maximize radii, and boundary forces to keep circles inside the square.\n\nForces:\n- Overlap repulsion: Push overlapping circles apart\n- Radius expansion: Try to increase all radii uniformly\n- Boundary forces: Push circles away from edges (with margin for radius)\n- Friction: Dampen movement for stability\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Initialize with random or grid positions, small radii\n- Iteratively update positions and radii based on forces\n- Run simulation for enough steps to reach equilibrium (e.g., 1000 steps)",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a force-directed circle packing for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    n_circles = 26\n    np.random.seed(42)\n    \n    # Initialize circles in a grid pattern with small radii\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = 0.15 + (col * 0.7 / (grid_size - 1))\n        y = 0.15 + (row * 0.7 / (grid_size - 1))\n        centers.append([x, y])\n    \n    centers = np.array(centers)\n    radii = np.full(n_circles, 0.02)\n    \n    # Simulation parameters\n    n_steps = 1000\n    dt = 0.01\n    friction = 0.9\n    \n    # Force weights\n    overlap_strength = 0.5\n    boundary_strength = 0.3\n    radius_expansion_rate = 0.0001\n    \n    velocities = np.zeros_like(centers)\n    \n    for step in range(n_steps):\n        forces = np.zeros_like(centers)\n        \n        # 1. Overlap repulsion forces\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist and dist > 1e-6:\n                    # Circles overlap, push apart\n                    overlap = min_dist - dist\n                    direction = diff / dist\n                    force_magnitude = overlap_strength * overlap\n                    \n                    forces[i] += direction * force_magnitude\n                    forces[j] -= direction * force_magnitude\n        \n        # 2. Boundary forces (keep circles inside [0,1]x[0,1])\n        for i in range(n_circles):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 0]\n                forces[i, 0] += boundary_strength * penetration\n            \n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                penetration = centers[i, 0] + radii[i] - 1\n                forces[i, 0] -= boundary_strength * penetration\n            \n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 1]\n                forces[i, 1] += boundary_strength * penetration\n            \n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                penetration = centers[i, 1] + radii[i] - 1\n                forces[i, 1] -= boundary_strength * penetration\n        \n        # 3. Update velocities and positions\n        velocities += forces * dt\n        velocities *= friction  # Apply friction\n        centers += velocities * dt\n        \n        # Clamp positions to valid range\n        centers = np.clip(centers, 0, 1)\n        \n        # 4. Radius expansion (try to grow all circles)\n        if step % 10 == 0:  # Don't expand every step for stability\n            can_expand = np.ones(n_circles, dtype=bool)\n            \n            # Check if expansion would cause overlap or boundary violation\n            test_radii = radii + radius_expansion_rate\n            \n            for i in range(n_circles):\n                # Check boundary constraints\n                if (centers[i, 0] - test_radii[i] < 0 or \n                    centers[i, 0] + test_radii[i] > 1 or\n                    centers[i, 1] - test_radii[i] < 0 or \n                    centers[i, 1] + test_radii[i] > 1):\n                    can_expand[i] = False\n                    continue\n                \n                # Check overlap with other circles\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < test_radii[i] + test_radii[j]:\n                            can_expand[i] = False\n                            break\n            \n            # Expand circles that can grow\n            radii[can_expand] += radius_expansion_rate\n        \n        # 5. Adaptive radius expansion rate (slow down as we converge)\n        if step > 500:\n            radius_expansion_rate *= 0.999\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Entry point for running the circle packing algorithm.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Circle packing complete!\")\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"Average radius: {np.mean(radii):.4f}\")\n    print(f\"Min radius: {np.min(radii):.4f}\")\n    print(f\"Max radius: {np.max(radii):.4f}\")\n    \n    # Verify no overlaps\n    overlaps = 0\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                overlaps += 1\n    \n    print(f\"Number of overlaps: {overlaps}\")\n    \n    # Verify boundary constraints\n    out_of_bounds = 0\n    for i in range(len(centers)):\n        if (centers[i, 0] - radii[i] < -1e-6 or \n            centers[i, 0] + radii[i] > 1 + 1e-6 or\n            centers[i, 1] - radii[i] < -1e-6 or \n            centers[i, 1] + radii[i] > 1 + 1e-6):\n            out_of_bounds += 1\n    \n    print(f\"Circles out of bounds: {out_of_bounds}\")\n```\n\nThis implementation creates a force-directed circle packing algorithm with the following features:\n\n1. **Initialization**: Circles start in a grid pattern with small radii to avoid initial overlaps\n\n2. **Forces**:\n   - **Overlap repulsion**: Pushes overlapping circles apart proportional to overlap amount\n   - **Boundary forces**: Pushes circles away from edges when they penetrate boundaries\n   - **Radius expansion**: Periodically attempts to grow all circles uniformly\n   - **Friction**: Dampens velocities for stability\n\n3. **Simulation**: Runs for 1000 steps using velocity Verlet-style integration\n\n4. **Adaptive behavior**: Expansion rate decreases over time for better convergence\n\nThe algorithm balances competing objectives: maximizing circle sizes while preventing overlaps and maintaining boundary constraints.",
  "reasoning": "This implementation creates a force-directed circle packing algorithm with the following features:\n\n1. **Initialization**: Circles start in a grid pattern with small radii to avoid initial overlaps\n\n2. **Forces**:\n   - **Overlap repulsion**: Pushes overlapping circles apart proportional to overlap amount\n   - **Boundary forces**: Pushes circles away from edges when they penetrate boundaries\n   - **Radius expansion**: Periodically attempts to grow all circles uniformly\n   - **Friction**: Dampens velocities for stability\n\n3. **Simulation**: Runs for 1000 steps using velocity Verlet-style integration\n\n4. **Adaptive behavior**: Expansion rate decreases over time for better convergence\n\nThe algorithm balances competing objectives: maximizing circle sizes while preventing overlaps and maintaining boundary constraints.",
  "timestamp": "2025-12-08T15:53:00.075291",
  "cost_data": null
}