{
  "trial_id": "trial_0_11",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Multi-scale circle packing algorithm for 26 circles in [0,1]x[0,1].\n    Uses size hierarchy: large, medium, small circles.\n    \"\"\"\n    np.random.seed(42)\n    \n    # Size distribution: 3 large, 7 medium, 16 small\n    n_large = 3\n    n_medium = 7\n    n_small = 16\n    n_total = n_large + n_medium + n_small\n    \n    assert n_total == 26, \"Total circles must be 26\"\n    \n    # Initial size estimates\n    r_large_init = 0.18\n    r_medium_init = 0.10\n    r_small_init = 0.05\n    \n    centers = []\n    radii = []\n    \n    # Step 1: Place large circles with strategic positioning\n    # Use a triangular/hexagonal-like pattern for efficiency\n    large_positions = [\n        [0.25, 0.25],\n        [0.75, 0.25],\n        [0.5, 0.65]\n    ]\n    \n    for pos in large_positions:\n        centers.append(pos)\n        radii.append(r_large_init)\n    \n    # Step 2: Place medium circles around large circles\n    # Try positions in a grid pattern, keep valid ones\n    medium_candidates = []\n    grid_size = 5\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = (i + 0.5) / grid_size\n            y = (j + 0.5) / grid_size\n            medium_candidates.append([x, y])\n    \n    # Score candidates by distance to existing circles (prefer gaps)\n    medium_centers = []\n    for _ in range(n_medium):\n        best_pos = None\n        best_score = -np.inf\n        \n        for cand in medium_candidates:\n            if len(centers) == 0:\n                score = 0\n            else:\n                # Score = minimum distance to existing circles\n                dists = [np.sqrt((cand[0]-c[0])**2 + (cand[1]-c[1])**2) - r \n                        for c, r in zip(centers, radii)]\n                score = min(dists) if dists else 0\n            \n            # Penalize being too close to boundaries\n            boundary_dist = min(cand[0], cand[1], 1-cand[0], 1-cand[1])\n            score = min(score, boundary_dist - r_medium_init)\n            \n            if score > best_score:\n                best_score = score\n                best_pos = cand\n        \n        if best_pos is not None:\n            medium_centers.append(best_pos)\n            centers.append(best_pos)\n            radii.append(r_medium_init)\n            medium_candidates.remove(best_pos)\n    \n    # Step 3: Place small circles to fill gaps\n    # Use denser grid and greedy placement\n    small_candidates = []\n    grid_size = 12\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = (i + 0.5) / grid_size\n            y = (j + 0.5) / grid_size\n            small_candidates.append([x, y])\n    \n    for _ in range(n_small):\n        best_pos = None\n        best_score = -np.inf\n        \n        for cand in small_candidates:\n            # Score = minimum clearance\n            dists = [np.sqrt((cand[0]-c[0])**2 + (cand[1]-c[1])**2) - r \n                    for c, r in zip(centers, radii)]\n            score = min(dists) if dists else 0\n            \n            boundary_dist = min(cand[0], cand[1], 1-cand[0], 1-cand[1])\n            score = min(score, boundary_dist - r_small_init)\n            \n            if score > best_score:\n                best_score = score\n                best_pos = cand\n        \n        if best_pos is not None:\n            centers.append(best_pos)\n            radii.append(r_small_init)\n            small_candidates.remove(best_pos)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Step 4: Optimize positions and radii\n    centers, radii = optimize_packing(centers, radii, n_large, n_medium, n_small)\n    \n    # Step 5: Final radius maximization while keeping positions fixed\n    radii = optimize_radii_only(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef optimize_packing(centers, radii, n_large, n_medium, n_small, iterations=3):\n    \"\"\"Iteratively optimize positions and radii.\"\"\"\n    \n    for iteration in range(iterations):\n        # Optimize positions\n        centers = optimize_positions(centers, radii)\n        \n        # Optimize radii\n        radii = optimize_radii_only(centers, radii)\n    \n    return centers, radii\n\n\ndef optimize_positions(centers, radii):\n    \"\"\"Optimize circle positions while keeping radii fixed.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        # Minimize negative sum of radii (we'll adjust radii after)\n        # Penalize constraint violations heavily\n        centers_new = x.reshape(n, 2)\n        penalty = 0\n        \n        # Check overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers_new[i] - centers_new[j])\n                required = radii[i] + radii[j]\n                if dist < required:\n                    penalty += 1000 * (required - dist)**2\n        \n        # Check boundaries\n        for i in range(n):\n            if centers_new[i, 0] < radii[i]:\n                penalty += 1000 * (radii[i] - centers_new[i, 0])**2\n            if centers_new[i, 0] > 1 - radii[i]:\n                penalty += 1000 * (centers_new[i, 0] - (1 - radii[i]))**2\n            if centers_new[i, 1] < radii[i]:\n                penalty += 1000 * (radii[i] - centers_new[i, 1])**2\n            if centers_new[i, 1] > 1 - radii[i]:\n                penalty += 1000 * (centers_new[i, 1] - (1 - radii[i]))**2\n        \n        return penalty\n    \n    x0 = centers.flatten()\n    result = minimize(objective, x0, method='L-BFGS-B', \n                     options={'maxiter': 100})\n    \n    return result.x.reshape(n, 2)\n\n\ndef optimize_radii_only(centers, radii):\n    \"\"\"Optimize radii with fixed positions to maximize sum.\"\"\"\n    n = len(centers)\n    \n    def objective(r):\n        return -np.sum(r)  # Maximize sum of radii\n    \n    def constraint_overlap(r, i, j):\n        dist = np.linalg.norm(centers[i] - centers[j])\n        return dist - r[i] - r[j]\n    \n    def constraint_boundary(r, i, dim, side):\n        if side == 'low':\n            return centers[i, dim] - r[i]\n        else:\n            return 1 - centers[i, dim] - r[i]\n    \n    constraints = []\n    \n    # Overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda r, i=i, j=j: constraint_overlap(r, i, j)\n            })\n    \n    # Boundary constraints\n    for i in range(n):\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i: constraint_boundary(r, i, 0, 'low')})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i: constraint_boundary(r, i, 0, 'high')})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i: constraint_boundary(r, i, 1, 'low')})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i: constraint_boundary(r, i, 1, 'high')})\n    \n    bounds = [(0.01, 0.5) for _ in range(n)]\n    \n    result = minimize(objective, radii, method='SLSQP', \n                     bounds=bounds, constraints=constraints,\n                     options={'maxiter': 200})\n    \n    return result.x\n\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    # Validation\n    n = len(centers)\n    assert n == 26, f\"Expected 26 circles, got {n}\"\n    \n    # Check no overlaps\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            assert dist >= radii[i] + radii[j] - 1e-6, f\"Circles {i} and {j} overlap\"\n    \n    # Check boundaries\n    for i in range(n):\n        assert centers[i, 0] >= radii[i] - 1e-6, f\"Circle {i} violates left boundary\"\n        assert centers[i, 0] <= 1 - radii[i] + 1e-6, f\"Circle {i} violates right boundary\"\n        assert centers[i, 1] >= radii[i] - 1e-6, f\"Circle {i} violates bottom boundary\"\n        assert centers[i, 1] <= 1 - radii[i] + 1e-6, f\"Circle {i} violates top boundary\"\n    \n    print(f\"Successfully packed {n} circles\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Radii range: [{radii.min():.4f}, {radii.max():.4f}]\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.0674714034290327,
    "target_ratio": 0.7846191284360656,
    "combined_score": 0.7846191284360656,
    "eval_time": 2.155384063720703,
    "error": null
  },
  "prompt": "Write a multi-scale circle packing algorithm for 26 circles in [0,1]x[0,1].\n\nUse circles of varying sizes: a few large circles, some medium circles, and many small circles to fill gaps.\n\nStrategy:\n1. Determine size distribution (e.g., 4 large, 8 medium, 14 small)\n2. Place large circles first in optimal positions\n3. Place medium circles in remaining space\n4. Fill gaps with small circles\n5. Adjust all radii to maximize sum while maintaining validity\n\nRequirements:\n- Define construct_packing() that returns (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use 3-4 distinct size classes\n- Optimize placement for each size class\n- Fine-tune radii at the end",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Multi-scale circle packing algorithm for 26 circles in [0,1]x[0,1].\n    Uses size hierarchy: large, medium, small circles.\n    \"\"\"\n    np.random.seed(42)\n    \n    # Size distribution: 3 large, 7 medium, 16 small\n    n_large = 3\n    n_medium = 7\n    n_small = 16\n    n_total = n_large + n_medium + n_small\n    \n    assert n_total == 26, \"Total circles must be 26\"\n    \n    # Initial size estimates\n    r_large_init = 0.18\n    r_medium_init = 0.10\n    r_small_init = 0.05\n    \n    centers = []\n    radii = []\n    \n    # Step 1: Place large circles with strategic positioning\n    # Use a triangular/hexagonal-like pattern for efficiency\n    large_positions = [\n        [0.25, 0.25],\n        [0.75, 0.25],\n        [0.5, 0.65]\n    ]\n    \n    for pos in large_positions:\n        centers.append(pos)\n        radii.append(r_large_init)\n    \n    # Step 2: Place medium circles around large circles\n    # Try positions in a grid pattern, keep valid ones\n    medium_candidates = []\n    grid_size = 5\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = (i + 0.5) / grid_size\n            y = (j + 0.5) / grid_size\n            medium_candidates.append([x, y])\n    \n    # Score candidates by distance to existing circles (prefer gaps)\n    medium_centers = []\n    for _ in range(n_medium):\n        best_pos = None\n        best_score = -np.inf\n        \n        for cand in medium_candidates:\n            if len(centers) == 0:\n                score = 0\n            else:\n                # Score = minimum distance to existing circles\n                dists = [np.sqrt((cand[0]-c[0])**2 + (cand[1]-c[1])**2) - r \n                        for c, r in zip(centers, radii)]\n                score = min(dists) if dists else 0\n            \n            # Penalize being too close to boundaries\n            boundary_dist = min(cand[0], cand[1], 1-cand[0], 1-cand[1])\n            score = min(score, boundary_dist - r_medium_init)\n            \n            if score > best_score:\n                best_score = score\n                best_pos = cand\n        \n        if best_pos is not None:\n            medium_centers.append(best_pos)\n            centers.append(best_pos)\n            radii.append(r_medium_init)\n            medium_candidates.remove(best_pos)\n    \n    # Step 3: Place small circles to fill gaps\n    # Use denser grid and greedy placement\n    small_candidates = []\n    grid_size = 12\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = (i + 0.5) / grid_size\n            y = (j + 0.5) / grid_size\n            small_candidates.append([x, y])\n    \n    for _ in range(n_small):\n        best_pos = None\n        best_score = -np.inf\n        \n        for cand in small_candidates:\n            # Score = minimum clearance\n            dists = [np.sqrt((cand[0]-c[0])**2 + (cand[1]-c[1])**2) - r \n                    for c, r in zip(centers, radii)]\n            score = min(dists) if dists else 0\n            \n            boundary_dist = min(cand[0], cand[1], 1-cand[0], 1-cand[1])\n            score = min(score, boundary_dist - r_small_init)\n            \n            if score > best_score:\n                best_score = score\n                best_pos = cand\n        \n        if best_pos is not None:\n            centers.append(best_pos)\n            radii.append(r_small_init)\n            small_candidates.remove(best_pos)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    \n    # Step 4: Optimize positions and radii\n    centers, radii = optimize_packing(centers, radii, n_large, n_medium, n_small)\n    \n    # Step 5: Final radius maximization while keeping positions fixed\n    radii = optimize_radii_only(centers, radii)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef optimize_packing(centers, radii, n_large, n_medium, n_small, iterations=3):\n    \"\"\"Iteratively optimize positions and radii.\"\"\"\n    \n    for iteration in range(iterations):\n        # Optimize positions\n        centers = optimize_positions(centers, radii)\n        \n        # Optimize radii\n        radii = optimize_radii_only(centers, radii)\n    \n    return centers, radii\n\n\ndef optimize_positions(centers, radii):\n    \"\"\"Optimize circle positions while keeping radii fixed.\"\"\"\n    n = len(centers)\n    \n    def objective(x):\n        # Minimize negative sum of radii (we'll adjust radii after)\n        # Penalize constraint violations heavily\n        centers_new = x.reshape(n, 2)\n        penalty = 0\n        \n        # Check overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers_new[i] - centers_new[j])\n                required = radii[i] + radii[j]\n                if dist < required:\n                    penalty += 1000 * (required - dist)**2\n        \n        # Check boundaries\n        for i in range(n):\n            if centers_new[i, 0] < radii[i]:\n                penalty += 1000 * (radii[i] - centers_new[i, 0])**2\n            if centers_new[i, 0] > 1 - radii[i]:\n                penalty += 1000 * (centers_new[i, 0] - (1 - radii[i]))**2\n            if centers_new[i, 1] < radii[i]:\n                penalty += 1000 * (radii[i] - centers_new[i, 1])**2\n            if centers_new[i, 1] > 1 - radii[i]:\n                penalty += 1000 * (centers_new[i, 1] - (1 - radii[i]))**2\n        \n        return penalty\n    \n    x0 = centers.flatten()\n    result = minimize(objective, x0, method='L-BFGS-B', \n                     options={'maxiter': 100})\n    \n    return result.x.reshape(n, 2)\n\n\ndef optimize_radii_only(centers, radii):\n    \"\"\"Optimize radii with fixed positions to maximize sum.\"\"\"\n    n = len(centers)\n    \n    def objective(r):\n        return -np.sum(r)  # Maximize sum of radii\n    \n    def constraint_overlap(r, i, j):\n        dist = np.linalg.norm(centers[i] - centers[j])\n        return dist - r[i] - r[j]\n    \n    def constraint_boundary(r, i, dim, side):\n        if side == 'low':\n            return centers[i, dim] - r[i]\n        else:\n            return 1 - centers[i, dim] - r[i]\n    \n    constraints = []\n    \n    # Overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda r, i=i, j=j: constraint_overlap(r, i, j)\n            })\n    \n    # Boundary constraints\n    for i in range(n):\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i: constraint_boundary(r, i, 0, 'low')})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i: constraint_boundary(r, i, 0, 'high')})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i: constraint_boundary(r, i, 1, 'low')})\n        constraints.append({'type': 'ineq', 'fun': lambda r, i=i: constraint_boundary(r, i, 1, 'high')})\n    \n    bounds = [(0.01, 0.5) for _ in range(n)]\n    \n    result = minimize(objective, radii, method='SLSQP', \n                     bounds=bounds, constraints=constraints,\n                     options={'maxiter': 200})\n    \n    return result.x\n\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    # Validation\n    n = len(centers)\n    assert n == 26, f\"Expected 26 circles, got {n}\"\n    \n    # Check no overlaps\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            assert dist >= radii[i] + radii[j] - 1e-6, f\"Circles {i} and {j} overlap\"\n    \n    # Check boundaries\n    for i in range(n):\n        assert centers[i, 0] >= radii[i] - 1e-6, f\"Circle {i} violates left boundary\"\n        assert centers[i, 0] <= 1 - radii[i] + 1e-6, f\"Circle {i} violates right boundary\"\n        assert centers[i, 1] >= radii[i] - 1e-6, f\"Circle {i} violates bottom boundary\"\n        assert centers[i, 1] <= 1 - radii[i] + 1e-6, f\"Circle {i} violates top boundary\"\n    \n    print(f\"Successfully packed {n} circles\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Radii range: [{radii.min():.4f}, {radii.max():.4f}]\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T15:53:11.716815",
  "cost_data": null
}