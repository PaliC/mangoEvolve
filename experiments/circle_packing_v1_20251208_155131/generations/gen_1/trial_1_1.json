{
  "trial_id": "trial_1_1",
  "generation": 1,
  "parent_id": "trial_0_13",
  "code": "",
  "metrics": {},
  "prompt": "Improve this hill climbing algorithm with better perturbations:\n\nimport numpy as np\nfrom typing import Tuple, List\nimport random\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Constructs a circle packing using random restart hill climbing.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    n_restarts = 40\n    \n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    for restart in range(n_restarts):\n        centers, radii, sum_radii = hill_climbing(n_circles)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\ndef hill_climbing(n_circles: int, max_iterations: int = 1000) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Performs hill climbing to optimize circle packing.\n    \"\"\"\n    # Generate random initial configuration\n    centers, radii = generate_random_configuration(n_circles)\n    current_sum = np.sum(radii)\n    \n    # Hill climbing loop\n    no_improvement_count = 0\n    max_no_improvement = 100\n    \n    for iteration in range(max_iterations):\n        if no_improvement_count >= max_no_improvement:\n            break\n        \n        # Try a perturbation\n        new_centers, new_radii, perturbation_type, perturb_idx = perturb_configuration(\n            centers.copy(), radii.copy()\n        )\n        \n        new_sum = np.sum(new_radii)\n        \n        # Accept if improvement\n        if new_sum > current_sum:\n            centers = new_centers\n            radii = new_radii\n            current_sum = new_sum\n            no_improvement_count = 0\n        else:\n            no_improvement_count += 1\n    \n    return centers, radii, current_sum\n\n\ndef generate_random_configuration(n_circles: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generates a random valid initial configuration.\n    Uses a strategy that places circles with small initial radii.\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    \n    # Start with small radii\n    radii = np.full(n_circles, 0.01)\n    \n    # Try to grow each radius\n    for i in range(n_circles):\n        radii[i] = compute_max_radius(centers, radii, i)\n    \n    return centers, radii\n\n\ndef compute_max_radius(centers: np.ndarray, radii: np.ndarray, circle_idx: int) -> float:\n    \"\"\"\n    Computes the maximum valid radius for a given circle.\n    \"\"\"\n    cx, cy = centers[circle_idx]\n    n_circles = len(centers)\n    \n    # Constraints from boundaries\n    max_r = min(cx, cy, 1 - cx, 1 - cy)\n    \n    # Constraints from other circles\n    for j in range(n_circles):\n        if j == circle_idx:\n            continue\n        \n        dist = np.linalg.norm(centers[circle_idx] - centers[j])\n        max_r_from_j = dist - radii[j]\n        \n        if max_r_from_j < max_r:\n            max_r = max_r_from_j\n    \n    return max(max_r, 0.001)  # Minimum radius to avoid degenerate cases\n\n\ndef perturb_configuration(centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray, str, int]:\n    \"\"\"\n    Applies a random perturbation to the configuration.\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Choose perturbation type\n    perturb_type = random.choice(['move', 'grow', 'swap'])\n    \n    if perturb_type == 'move':\n        # Move a random circle\n        idx = random.randint(0, n_circles - 1)\n        \n        # Small random movement\n        step_size = 0.05\n        new_center = centers[idx] + np.random.randn(2) * step_size\n        new_center = np.clip(new_center, 0, 1)\n        \n        centers[idx] = new_center\n        \n        # Recompute radius for moved circle\n        radii[idx] = compute_max_radius(centers, radii, idx)\n        \n        # Recompute radii for nearby circles\n        for j in range(n_circles):\n            if j != idx:\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                if dist < radii[idx] + radii[j] + 0.1:\n                    radii[j] = compute_max_radius(centers, radii, j)\n        \n        return centers, radii, 'move', idx\n    \n    elif perturb_type == 'grow':\n        # Try to grow a random circle\n        idx = random.randint(0, n_circles - 1)\n        new_radius = compute_max_radius(centers, radii, idx)\n        radii[idx] = new_radius\n        \n        return centers, radii, 'grow', idx\n    \n    else:  # swap\n        # Swap positions of two circles\n        idx1 = random.randint(0, n_circles - 1)\n        idx2 = random.randint(0, n_circles - 1)\n        \n        centers[[idx1, idx2]] = centers[[idx2, idx1]]\n        \n        # Recompute radii for both\n        radii[idx1] = compute_max_radius(centers, radii, idx1)\n        radii[idx2] = compute_max_radius(centers, radii, idx2)\n        \n        return centers, radii, 'swap', idx1\n\n\ndef is_valid_configuration(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a configuration is valid (no overlaps, within bounds).\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n_circles):\n        cx, cy = centers[i]\n        r = radii[i]\n        \n        if cx - r < -1e-6 or cx + r > 1 + 1e-6:\n            return False\n        if cy - r < -1e-6 or cy + r > 1 + 1e-6:\n            return False\n    \n    # Check circle-circle constraints\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for running the circle packing algorithm.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Best sum of radii: {sum_radii:.6f}\")\n    print(f\"Configuration valid: {is_valid_configuration(centers, radii)}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Print some statistics\n    print(f\"\\nNumber of circles: {len(centers)}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n\nEnhancements:\n1. Add a \"squeeze\" perturbation that tries to grow all radii uniformly\n2. Implement adaptive step sizes that decrease over time\n3. Increase restarts to 60 for better exploration\n4. Add a final optimization phase using scipy.optimize on the best solution\n5. Use smarter initial configurations (try both grid and hexagonal starts)\n\nTarget: exceed sum_radii=2.1915.",
  "response": "Here's an improved version with all the requested enhancements:\n\n```python\nimport numpy as np\nfrom typing import Tuple, List\nimport random\nfrom scipy.optimize import minimize\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Constructs a circle packing using random restart hill climbing with multiple strategies.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    n_restarts = 60\n    \n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    for restart in range(n_restarts):\n        # Use different initialization strategies\n        if restart < 10:\n            init_type = 'grid'\n        elif restart < 20:\n            init_type = 'hexagonal'\n        else:\n            init_type = 'random'\n        \n        centers, radii, sum_radii = hill_climbing(n_circles, init_type=init_type)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n            print(f\"Restart {restart}: New best = {sum_radii:.6f}\")\n    \n    # Final optimization phase using scipy\n    print(\"\\nApplying final scipy optimization...\")\n    best_centers, best_radii, best_sum = scipy_optimize(best_centers, best_radii)\n    print(f\"After scipy optimization: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\n\ndef hill_climbing(n_circles: int, max_iterations: int = 2000, init_type: str = 'random') -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Performs hill climbing to optimize circle packing with adaptive step sizes.\n    \"\"\"\n    # Generate initial configuration\n    centers, radii = generate_initial_configuration(n_circles, init_type)\n    current_sum = np.sum(radii)\n    \n    # Hill climbing loop with adaptive parameters\n    no_improvement_count = 0\n    max_no_improvement = 150\n    \n    for iteration in range(max_iterations):\n        if no_improvement_count >= max_no_improvement:\n            break\n        \n        # Adaptive step size (decreases over time)\n        progress = iteration / max_iterations\n        step_size = 0.1 * (1 - 0.8 * progress)  # Decreases from 0.1 to 0.02\n        \n        # Try a perturbation\n        new_centers, new_radii, perturbation_type, perturb_idx = perturb_configuration(\n            centers.copy(), radii.copy(), step_size, iteration\n        )\n        \n        new_sum = np.sum(new_radii)\n        \n        # Accept if improvement\n        if new_sum > current_sum:\n            centers = new_centers\n            radii = new_radii\n            current_sum = new_sum\n            no_improvement_count = 0\n        else:\n            no_improvement_count += 1\n    \n    return centers, radii, current_sum\n\n\ndef generate_initial_configuration(n_circles: int, init_type: str = 'random') -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generates initial configuration using different strategies.\n    \"\"\"\n    if init_type == 'grid':\n        centers = generate_grid_configuration(n_circles)\n    elif init_type == 'hexagonal':\n        centers = generate_hexagonal_configuration(n_circles)\n    else:\n        centers = np.random.rand(n_circles, 2)\n    \n    # Start with small radii\n    radii = np.full(n_circles, 0.01)\n    \n    # Try to grow each radius\n    for i in range(n_circles):\n        radii[i] = compute_max_radius(centers, radii, i)\n    \n    return centers, radii\n\n\ndef generate_grid_configuration(n_circles: int) -> np.ndarray:\n    \"\"\"\n    Generates a grid-based initial configuration.\n    \"\"\"\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    \n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        \n        # Add small random jitter\n        x = (col + 0.5 + np.random.randn() * 0.05) / grid_size\n        y = (row + 0.5 + np.random.randn() * 0.05) / grid_size\n        \n        x = np.clip(x, 0.05, 0.95)\n        y = np.clip(y, 0.05, 0.95)\n        \n        centers.append([x, y])\n    \n    return np.array(centers)\n\n\ndef generate_hexagonal_configuration(n_circles: int) -> np.ndarray:\n    \"\"\"\n    Generates a hexagonal packing initial configuration.\n    \"\"\"\n    centers = []\n    row = 0\n    col = 0\n    \n    dx = 0.15\n    dy = 0.15 * np.sqrt(3) / 2\n    \n    while len(centers) < n_circles:\n        x = col * dx + (row % 2) * dx / 2 + 0.1\n        y = row * dy + 0.1\n        \n        if x <= 0.9 and y <= 0.9:\n            # Add small random jitter\n            x += np.random.randn() * 0.02\n            y += np.random.randn() * 0.02\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            centers.append([x, y])\n        \n        col += 1\n        if x > 0.9:\n            col = 0\n            row += 1\n    \n    return np.array(centers[:n_circles])\n\n\ndef generate_random_configuration(n_circles: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generates a random valid initial configuration.\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    radii = np.full(n_circles, 0.01)\n    \n    for i in range(n_circles):\n        radii[i] = compute_max_radius(centers, radii, i)\n    \n    return centers, radii\n\n\ndef compute_max_radius(centers: np.ndarray, radii: np.ndarray, circle_idx: int) -> float:\n    \"\"\"\n    Computes the maximum valid radius for a given circle.\n    \"\"\"\n    cx, cy = centers[circle_idx]\n    n_circles = len(centers)\n    \n    # Constraints from boundaries\n    max_r = min(cx, cy, 1 - cx, 1 - cy)\n    \n    # Constraints from other circles\n    for j in range(n_circles):\n        if j == circle_idx:\n            continue\n        \n        dist = np.linalg.norm(centers[circle_idx] - centers[j])\n        max_r_from_j = dist - radii[j]\n        \n        if max_r_from_j < max_r:\n            max_r = max_r_from_j\n    \n    return max(max_r, 0.001)\n\n\ndef perturb_configuration(centers: np.ndarray, radii: np.ndarray, step_size: float, iteration: int) -> Tuple[np.ndarray, np.ndarray, str, int]:\n    \"\"\"\n    Applies a random perturbation to the configuration with adaptive strategies.\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Choose perturbation type with adaptive probabilities\n    if iteration % 20 == 0:\n        # Periodically try squeeze operation\n        perturb_type = 'squeeze'\n    else:\n        perturb_type = random.choices(\n            ['move', 'grow', 'swap', 'move_multiple', 'targeted_move'],\n            weights=[0.35, 0.25, 0.15, 0.15, 0.10]\n        )[0]\n    \n    if perturb_type == 'move':\n        # Move a random circle\n        idx = random.randint(0, n_circles - 1)\n        \n        new_center = centers[idx] + np.random.randn(2) * step_size\n        new_center = np.clip(new_center, 0, 1)\n        \n        centers[idx] = new_center\n        \n        # Recompute radius for moved circle\n        radii[idx] = compute_max_radius(centers, radii, idx)\n        \n        # Recompute radii for nearby circles\n        for j in range(n_circles):\n            if j != idx:\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                if dist < radii[idx] + radii[j] + 0.15:\n                    radii[j] = compute_max_radius(centers, radii, j)\n        \n        return centers, radii, 'move', idx\n    \n    elif perturb_type == 'grow':\n        # Try to grow a random circle\n        idx = random.randint(0, n_circles - 1)\n        new_radius = compute_max_radius(centers, radii, idx)\n        radii[idx] = new_radius\n        \n        return centers, radii, 'grow', idx\n    \n    elif perturb_type == 'swap':\n        # Swap positions of two circles\n        idx1 = random.randint(0, n_circles - 1)\n        idx2 = random.randint(0, n_circles - 1)\n        \n        centers[[idx1, idx2]] = centers[[idx2, idx1]]\n        \n        # Recompute radii for both\n        radii[idx1] = compute_max_radius(centers, radii, idx1)\n        radii[idx2] = compute_max_radius(centers, radii, idx2)\n        \n        return centers, radii, 'swap', idx1\n    \n    elif perturb_type == 'move_multiple':\n        # Move multiple circles simultaneously\n        n_to_move = random.randint(2, min(5, n_circles))\n        indices = random.sample(range(n_circles), n_to_move)\n        \n        for idx in indices:\n            new_center = centers[idx] + np.random.randn(2) * step_size * 0.5\n            new_center = np.clip(new_center, 0, 1)\n            centers[idx] = new_center\n        \n        # Recompute all radii\n        for i in range(n_circles):\n            radii[i] = compute_max_radius(centers, radii, i)\n        \n        return centers, radii, 'move_multiple', indices[0]\n    \n    elif perturb_type == 'targeted_move':\n        # Move the smallest circle to a potentially better location\n        idx = np.argmin(radii)\n        \n        # Try to move it to a less crowded area\n        best_new_center = centers[idx].copy()\n        best_new_radius = radii[idx]\n        \n        for _ in range(10):\n            trial_center = np.random.rand(2)\n            trial_radii = radii.copy()\n            trial_centers = centers.copy()\n            trial_centers[idx] = trial_center\n            trial_radii[idx] = compute_max_radius(trial_centers, trial_radii, idx)\n            \n            if trial_radii[idx] > best_new_radius:\n                best_new_radius = trial_radii[idx]\n                best_new_center = trial_center\n        \n        centers[idx] = best_new_center\n        radii[idx] = compute_max_radius(centers, radii, idx)\n        \n        # Recompute nearby radii\n        for j in range(n_circles):\n            if j != idx:\n                radii[j] = compute_max_radius(centers, radii, j)\n        \n        return centers, radii, 'targeted_move', idx\n    \n    else:  # squeeze\n        # Try to grow all radii uniformly\n        for i in range(n_circles):\n            radii[i] = compute_max_radius(centers, radii, i)\n        \n        return centers, radii, 'squeeze', -1\n\n\ndef scipy_optimize(centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Final optimization phase using scipy's minimize.\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Flatten centers for optimization\n    x0 = centers.flatten()\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (we minimize)\"\"\"\n        trial_centers = x.reshape(n_circles, 2)\n        trial_radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            trial_radii[i] = compute_max_radius(trial_centers, trial_radii, i)\n        \n        return -np.sum(trial_radii)\n    \n    # Bounds: all centers must be in [0, 1]\n    bounds = [(0, 1) for _ in range(2 * n_circles)]\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 500, 'ftol': 1e-8}\n    )\n    \n    # Extract optimized configuration\n    optimized_centers = result.x.reshape(n_circles, 2)\n    optimized_radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        optimized_radii[i] = compute_max_radius(optimized_centers, optimized_radii, i)\n    \n    optimized_sum = np.sum(optimized_radii)\n    \n    return optimized_centers, optimized_radii, optimized_sum\n\n\ndef is_valid_configuration(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a configuration is valid (no overlaps, within bounds).\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n_circles):\n        cx, cy = centers[i]\n        r = radii[i]\n        \n        if cx - r < -1e-6 or cx + r > 1 + 1e-6:\n            return False\n        if cy - r < -1e-6 or cy + r > 1 + 1e-6:\n            return False\n    \n    # Check circle-circle constraints\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for running the circle packing algorithm.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"\\n{'='*50}\")\n    print(f\"Final sum of radii: {sum_radii:.6f}\")\n    print(f\"Configuration valid: {is_valid_configuration(centers, radii)}\")\n    print(f\"{'='*50}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Print detailed statistics\n    print(f\"\\nNumber of circles: {len(centers)}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max",
  "reasoning": "Here's an improved version with all the requested enhancements:\n\n```python\nimport numpy as np\nfrom typing import Tuple, List\nimport random\nfrom scipy.optimize import minimize\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Constructs a circle packing using random restart hill climbing with multiple strategies.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    n_restarts = 60\n    \n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    for restart in range(n_restarts):\n        # Use different initialization strategies\n        if restart < 10:\n            init_type = 'grid'\n        elif restart < 20:\n            init_type = 'hexagonal'\n        else:\n            init_type = 'random'\n        \n        centers, radii, sum_radii = hill_climbing(n_circles, init_type=init_type)\n        \n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n            print(f\"Restart {restart}: New best = {sum_radii:.6f}\")\n    \n    # Final optimization phase using scipy\n    print(\"\\nApplying final scipy optimization...\")\n    best_centers, best_radii, best_sum = scipy_optimize(best_centers, best_radii)\n    print(f\"After scipy optimization: {best_sum:.6f}\")\n    \n    return best_centers, best_radii, best_sum\n\ndef hill_climbing(n_circles: int, max_iterations: int = 2000, init_type: str = 'random') -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Performs hill climbing to optimize circle packing with adaptive step sizes.\n    \"\"\"\n    # Generate initial configuration\n    centers, radii = generate_initial_configuration(n_circles, init_type)\n    current_sum = np.sum(radii)\n    \n    # Hill climbing loop with adaptive parameters\n    no_improvement_count = 0\n    max_no_improvement = 150\n    \n    for iteration in range(max_iterations):\n        if no_improvement_count >= max_no_improvement:\n            break\n        \n        # Adaptive step size (decreases over time)\n        progress = iteration / max_iterations\n        step_size = 0.1 * (1 - 0.8 * progress)  # Decreases from 0.1 to 0.02\n        \n        # Try a perturbation\n        new_centers, new_radii, perturbation_type, perturb_idx = perturb_configuration(\n            centers.copy(), radii.copy(), step_size, iteration\n        )\n        \n        new_sum = np.sum(new_radii)\n        \n        # Accept if improvement\n        if new_sum > current_sum:\n            centers = new_centers\n            radii = new_radii\n            current_sum = new_sum\n            no_improvement_count = 0\n        else:\n            no_improvement_count += 1\n    \n    return centers, radii, current_sum\n\ndef generate_initial_configuration(n_circles: int, init_type: str = 'random') -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generates initial configuration using different strategies.\n    \"\"\"\n    if init_type == 'grid':\n        centers = generate_grid_configuration(n_circles)\n    elif init_type == 'hexagonal':\n        centers = generate_hexagonal_configuration(n_circles)\n    else:\n        centers = np.random.rand(n_circles, 2)\n    \n    # Start with small radii\n    radii = np.full(n_circles, 0.01)\n    \n    # Try to grow each radius\n    for i in range(n_circles):\n        radii[i] = compute_max_radius(centers, radii, i)\n    \n    return centers, radii\n\ndef generate_grid_configuration(n_circles: int) -> np.ndarray:\n    \"\"\"\n    Generates a grid-based initial configuration.\n    \"\"\"\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = []\n    \n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        \n        # Add small random jitter\n        x = (col + 0.5 + np.random.randn() * 0.05) / grid_size\n        y = (row + 0.5 + np.random.randn() * 0.05) / grid_size\n        \n        x = np.clip(x, 0.05, 0.95)\n        y = np.clip(y, 0.05, 0.95)\n        \n        centers.append([x, y])\n    \n    return np.array(centers)\n\ndef generate_hexagonal_configuration(n_circles: int) -> np.ndarray:\n    \"\"\"\n    Generates a hexagonal packing initial configuration.\n    \"\"\"\n    centers = []\n    row = 0\n    col = 0\n    \n    dx = 0.15\n    dy = 0.15 * np.sqrt(3) / 2\n    \n    while len(centers) < n_circles:\n        x = col * dx + (row % 2) * dx / 2 + 0.1\n        y = row * dy + 0.1\n        \n        if x <= 0.9 and y <= 0.9:\n            # Add small random jitter\n            x += np.random.randn() * 0.02\n            y += np.random.randn() * 0.02\n            x = np.clip(x, 0.05, 0.95)\n            y = np.clip(y, 0.05, 0.95)\n            centers.append([x, y])\n        \n        col += 1\n        if x > 0.9:\n            col = 0\n            row += 1\n    \n    return np.array(centers[:n_circles])\n\ndef generate_random_configuration(n_circles: int) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generates a random valid initial configuration.\n    \"\"\"\n    centers = np.random.rand(n_circles, 2)\n    radii = np.full(n_circles, 0.01)\n    \n    for i in range(n_circles):\n        radii[i] = compute_max_radius(centers, radii, i)\n    \n    return centers, radii\n\ndef compute_max_radius(centers: np.ndarray, radii: np.ndarray, circle_idx: int) -> float:\n    \"\"\"\n    Computes the maximum valid radius for a given circle.\n    \"\"\"\n    cx, cy = centers[circle_idx]\n    n_circles = len(centers)\n    \n    # Constraints from boundaries\n    max_r = min(cx, cy, 1 - cx, 1 - cy)\n    \n    # Constraints from other circles\n    for j in range(n_circles):\n        if j == circle_idx:\n            continue\n        \n        dist = np.linalg.norm(centers[circle_idx] - centers[j])\n        max_r_from_j = dist - radii[j]\n        \n        if max_r_from_j < max_r:\n            max_r = max_r_from_j\n    \n    return max(max_r, 0.001)\n\ndef perturb_configuration(centers: np.ndarray, radii: np.ndarray, step_size: float, iteration: int) -> Tuple[np.ndarray, np.ndarray, str, int]:\n    \"\"\"\n    Applies a random perturbation to the configuration with adaptive strategies.\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Choose perturbation type with adaptive probabilities\n    if iteration % 20 == 0:\n        # Periodically try squeeze operation\n        perturb_type = 'squeeze'\n    else:\n        perturb_type = random.choices(\n            ['move', 'grow', 'swap', 'move_multiple', 'targeted_move'],\n            weights=[0.35, 0.25, 0.15, 0.15, 0.10]\n        )[0]\n    \n    if perturb_type == 'move':\n        # Move a random circle\n        idx = random.randint(0, n_circles - 1)\n        \n        new_center = centers[idx] + np.random.randn(2) * step_size\n        new_center = np.clip(new_center, 0, 1)\n        \n        centers[idx] = new_center\n        \n        # Recompute radius for moved circle\n        radii[idx] = compute_max_radius(centers, radii, idx)\n        \n        # Recompute radii for nearby circles\n        for j in range(n_circles):\n            if j != idx:\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                if dist < radii[idx] + radii[j] + 0.15:\n                    radii[j] = compute_max_radius(centers, radii, j)\n        \n        return centers, radii, 'move', idx\n    \n    elif perturb_type == 'grow':\n        # Try to grow a random circle\n        idx = random.randint(0, n_circles - 1)\n        new_radius = compute_max_radius(centers, radii, idx)\n        radii[idx] = new_radius\n        \n        return centers, radii, 'grow', idx\n    \n    elif perturb_type == 'swap':\n        # Swap positions of two circles\n        idx1 = random.randint(0, n_circles - 1)\n        idx2 = random.randint(0, n_circles - 1)\n        \n        centers[[idx1, idx2]] = centers[[idx2, idx1]]\n        \n        # Recompute radii for both\n        radii[idx1] = compute_max_radius(centers, radii, idx1)\n        radii[idx2] = compute_max_radius(centers, radii, idx2)\n        \n        return centers, radii, 'swap', idx1\n    \n    elif perturb_type == 'move_multiple':\n        # Move multiple circles simultaneously\n        n_to_move = random.randint(2, min(5, n_circles))\n        indices = random.sample(range(n_circles), n_to_move)\n        \n        for idx in indices:\n            new_center = centers[idx] + np.random.randn(2) * step_size * 0.5\n            new_center = np.clip(new_center, 0, 1)\n            centers[idx] = new_center\n        \n        # Recompute all radii\n        for i in range(n_circles):\n            radii[i] = compute_max_radius(centers, radii, i)\n        \n        return centers, radii, 'move_multiple', indices[0]\n    \n    elif perturb_type == 'targeted_move':\n        # Move the smallest circle to a potentially better location\n        idx = np.argmin(radii)\n        \n        # Try to move it to a less crowded area\n        best_new_center = centers[idx].copy()\n        best_new_radius = radii[idx]\n        \n        for _ in range(10):\n            trial_center = np.random.rand(2)\n            trial_radii = radii.copy()\n            trial_centers = centers.copy()\n            trial_centers[idx] = trial_center\n            trial_radii[idx] = compute_max_radius(trial_centers, trial_radii, idx)\n            \n            if trial_radii[idx] > best_new_radius:\n                best_new_radius = trial_radii[idx]\n                best_new_center = trial_center\n        \n        centers[idx] = best_new_center\n        radii[idx] = compute_max_radius(centers, radii, idx)\n        \n        # Recompute nearby radii\n        for j in range(n_circles):\n            if j != idx:\n                radii[j] = compute_max_radius(centers, radii, j)\n        \n        return centers, radii, 'targeted_move', idx\n    \n    else:  # squeeze\n        # Try to grow all radii uniformly\n        for i in range(n_circles):\n            radii[i] = compute_max_radius(centers, radii, i)\n        \n        return centers, radii, 'squeeze', -1\n\ndef scipy_optimize(centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Final optimization phase using scipy's minimize.\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Flatten centers for optimization\n    x0 = centers.flatten()\n    \n    def objective(x):\n        \"\"\"Negative sum of radii (we minimize)\"\"\"\n        trial_centers = x.reshape(n_circles, 2)\n        trial_radii = np.zeros(n_circles)\n        \n        for i in range(n_circles):\n            trial_radii[i] = compute_max_radius(trial_centers, trial_radii, i)\n        \n        return -np.sum(trial_radii)\n    \n    # Bounds: all centers must be in [0, 1]\n    bounds = [(0, 1) for _ in range(2 * n_circles)]\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 500, 'ftol': 1e-8}\n    )\n    \n    # Extract optimized configuration\n    optimized_centers = result.x.reshape(n_circles, 2)\n    optimized_radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        optimized_radii[i] = compute_max_radius(optimized_centers, optimized_radii, i)\n    \n    optimized_sum = np.sum(optimized_radii)\n    \n    return optimized_centers, optimized_radii, optimized_sum\n\ndef is_valid_configuration(centers: np.ndarray, radii: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a configuration is valid (no overlaps, within bounds).\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n_circles):\n        cx, cy = centers[i]\n        r = radii[i]\n        \n        if cx - r < -1e-6 or cx + r > 1 + 1e-6:\n            return False\n        if cy - r < -1e-6 or cy + r > 1 + 1e-6:\n            return False\n    \n    # Check circle-circle constraints\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                return False\n    \n    return True\n\ndef run_packing():\n    \"\"\"\n    Entry point for running the circle packing algorithm.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"\\n{'='*50}\")\n    print(f\"Final sum of radii: {sum_radii:.6f}\")\n    print(f\"Configuration valid: {is_valid_configuration(centers, radii)}\")\n    print(f\"{'='*50}\")\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Print detailed statistics\n    print(f\"\\nNumber of circles: {len(centers)}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max",
  "timestamp": "2025-12-08T15:55:29.948806",
  "cost_data": null
}