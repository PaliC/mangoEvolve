{
  "trial_id": "trial_1_13",
  "generation": 1,
  "parent_id": "trial_0_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom collections import deque\n\ndef construct_packing():\n    \"\"\"\n    Density-based adaptive packing using quadtree subdivision.\n    Places circles adaptively based on local density.\n    \"\"\"\n    np.random.seed(42)\n    \n    centers = []\n    radii = []\n    \n    # Phase 1: Place initial large circles strategically\n    initial_positions = [\n        (0.25, 0.25, 0.18),\n        (0.75, 0.25, 0.18),\n        (0.25, 0.75, 0.18),\n        (0.75, 0.75, 0.18),\n        (0.5, 0.5, 0.16),\n    ]\n    \n    for x, y, r in initial_positions:\n        if is_valid_circle(x, y, r, centers, radii):\n            centers.append([x, y])\n            radii.append(r)\n    \n    # Phase 2: Quadtree-based adaptive subdivision\n    quadtree_packing(centers, radii, max_depth=5)\n    \n    # Phase 3: Fill remaining gaps with density-aware placement\n    density_aware_filling(centers, radii, n_attempts=500)\n    \n    # Phase 4: Optimize configuration\n    centers, radii = optimize_packing(centers, radii)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef is_valid_circle(x, y, r, centers, radii, margin=1e-6):\n    \"\"\"Check if circle is valid (within bounds and non-overlapping).\"\"\"\n    # Check boundaries\n    if x - r < -margin or x + r > 1 + margin:\n        return False\n    if y - r < -margin or y + r > 1 + margin:\n        return False\n    \n    # Check overlaps with existing circles\n    for (cx, cy), cr in zip(centers, radii):\n        dist = np.sqrt((x - cx)**2 + (y - cy)**2)\n        if dist < r + cr - margin:\n            return False\n    \n    return True\n\ndef estimate_local_density(x, y, centers, radii, radius=0.2):\n    \"\"\"Estimate local circle density in a region around (x, y).\"\"\"\n    if len(centers) == 0:\n        return 0.0\n    \n    centers_arr = np.array(centers)\n    radii_arr = np.array(radii)\n    \n    # Calculate distances to all centers\n    distances = np.sqrt((centers_arr[:, 0] - x)**2 + (centers_arr[:, 1] - y)**2)\n    \n    # Count circles within the radius (weighted by their size)\n    mask = distances < radius\n    density = np.sum(radii_arr[mask]**2)  # Weight by area\n    \n    return density\n\ndef quadtree_packing(centers, radii, max_depth=5):\n    \"\"\"Recursively subdivide space and place circles based on density.\"\"\"\n    \n    class QuadNode:\n        def __init__(self, x_min, x_max, y_min, y_max, depth):\n            self.x_min = x_min\n            self.x_max = x_max\n            self.y_min = y_min\n            self.y_max = y_max\n            self.depth = depth\n            self.cx = (x_min + x_max) / 2\n            self.cy = (y_min + y_max) / 2\n            self.width = x_max - x_min\n            self.height = y_max - y_min\n    \n    queue = deque([QuadNode(0, 1, 0, 1, 0)])\n    \n    while queue:\n        node = queue.popleft()\n        \n        if node.depth >= max_depth:\n            continue\n        \n        # Estimate density at node center\n        density = estimate_local_density(node.cx, node.cy, centers, radii, radius=0.3)\n        \n        # Adaptive radius based on depth and density\n        base_radius = 0.15 * (0.7 ** node.depth)\n        density_factor = max(0.5, 1.0 - density * 0.5)\n        target_radius = base_radius * density_factor\n        \n        # Try to place circle at center of region\n        placed = False\n        for r_scale in [1.0, 0.9, 0.8, 0.7, 0.6, 0.5]:\n            r = target_radius * r_scale\n            if r < 0.02:  # Minimum radius threshold\n                break\n            \n            if is_valid_circle(node.cx, node.cy, r, centers, radii):\n                centers.append([node.cx, node.cy])\n                radii.append(r)\n                placed = True\n                break\n        \n        # Subdivide if density is low or no circle was placed\n        if density < 0.3 or not placed:\n            if node.depth < max_depth - 1:\n                # Create 4 child nodes\n                mid_x = node.cx\n                mid_y = node.cy\n                \n                children = [\n                    QuadNode(node.x_min, mid_x, node.y_min, mid_y, node.depth + 1),\n                    QuadNode(mid_x, node.x_max, node.y_min, mid_y, node.depth + 1),\n                    QuadNode(node.x_min, mid_x, mid_y, node.y_max, node.depth + 1),\n                    QuadNode(mid_x, node.x_max, mid_y, node.y_max, node.depth + 1),\n                ]\n                \n                queue.extend(children)\n\ndef density_aware_filling(centers, radii, n_attempts=500):\n    \"\"\"Fill remaining space with circles, prioritizing low-density regions.\"\"\"\n    \n    # Create a grid for density estimation\n    grid_size = 20\n    x_grid = np.linspace(0.05, 0.95, grid_size)\n    y_grid = np.linspace(0.05, 0.95, grid_size)\n    \n    for attempt in range(n_attempts):\n        # Compute density map\n        densities = []\n        positions = []\n        \n        for x in x_grid:\n            for y in y_grid:\n                density = estimate_local_density(x, y, centers, radii, radius=0.15)\n                densities.append(density)\n                positions.append((x, y))\n        \n        densities = np.array(densities)\n        \n        # Convert to probabilities (lower density = higher probability)\n        if len(densities) > 0 and np.max(densities) > 0:\n            inv_densities = np.max(densities) - densities + 0.1\n            probs = inv_densities / np.sum(inv_densities)\n        else:\n            probs = np.ones(len(positions)) / len(positions)\n        \n        # Sample position based on inverse density\n        idx = np.random.choice(len(positions), p=probs)\n        x, y = positions[idx]\n        \n        # Add small random offset\n        x += np.random.uniform(-0.03, 0.03)\n        y += np.random.uniform(-0.03, 0.03)\n        x = np.clip(x, 0, 1)\n        y = np.clip(y, 0, 1)\n        \n        # Try to place circle with adaptive radius\n        max_r = min(x, 1-x, y, 1-y) * 0.95\n        \n        for r in np.linspace(max_r, 0.015, 20):\n            if is_valid_circle(x, y, r, centers, radii):\n                centers.append([x, y])\n                radii.append(r)\n                break\n\ndef optimize_packing(centers, radii, max_iter=200):\n    \"\"\"Optimize circle positions and radii using scipy.\"\"\"\n    \n    if len(centers) == 0:\n        return centers, radii\n    \n    n = len(centers)\n    \n    # Initial parameters: [x1, y1, r1, x2, y2, r2, ...]\n    x0 = []\n    for (cx, cy), r in zip(centers, radii):\n        x0.extend([cx, cy, r])\n    x0 = np.array(x0)\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum).\"\"\"\n        radii_opt = x[2::3]\n        return -np.sum(radii_opt)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Ensure no circles overlap.\"\"\"\n        constraints = []\n        for i in range(n):\n            xi, yi, ri = x[3*i], x[3*i+1], x[3*i+2]\n            for j in range(i+1, n):\n                xj, yj, rj = x[3*j], x[3*j+1], x[3*j+2]\n                dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n                constraints.append(dist - ri - rj)\n        return np.array(constraints)\n    \n    def constraint_boundaries(x):\n        \"\"\"Ensure circles stay within boundaries.\"\"\"\n        constraints = []\n        for i in range(n):\n            xi, yi, ri = x[3*i], x[3*i+1], x[3*i+2]\n            constraints.extend([xi - ri, 1 - xi - ri, yi - ri, 1 - yi - ri])\n        return np.array(constraints)\n    \n    # Bounds for variables\n    bounds = []\n    for i in range(n):\n        bounds.extend([(0, 1), (0, 1), (0.01, 0.3)])\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_boundaries}\n    ]\n    \n    # Optimize\n    result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                     constraints=constraints, options={'maxiter': max_iter, 'ftol': 1e-6})\n    \n    if result.success or True:  # Use result even if not fully converged\n        x_opt = result.x\n        centers_opt = [[x_opt[3*i], x_opt[3*i+1]] for i in range(n)]\n        radii_opt = [x_opt[3*i+2] for i in range(n)]\n        return centers_opt, radii_opt\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    return construct_packing()\n\n# Test the implementation\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Target achieved: {sum_radii > 2.0}\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 33.08055925369263,
    "error": "Invalid centers shape: (84, 2), expected (26, 2)"
  },
  "prompt": "Create a density-based adaptive packing:\n\nStrategy:\n1. Divide [0,1]x[0,1] into regions and estimate local density\n2. Place more circles in low-density regions\n3. Use quadtree-like subdivision for adaptive placement\n4. Start with 4-6 large circles in strategic positions\n5. Recursively fill regions with smaller circles\n6. Optimize final configuration with scipy\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Target sum_radii > 2.0",
  "response": "I'll create a density-based adaptive packing algorithm using quadtree subdivision and local density estimation.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom collections import deque\n\ndef construct_packing():\n    \"\"\"\n    Density-based adaptive packing using quadtree subdivision.\n    Places circles adaptively based on local density.\n    \"\"\"\n    np.random.seed(42)\n    \n    centers = []\n    radii = []\n    \n    # Phase 1: Place initial large circles strategically\n    initial_positions = [\n        (0.25, 0.25, 0.18),\n        (0.75, 0.25, 0.18),\n        (0.25, 0.75, 0.18),\n        (0.75, 0.75, 0.18),\n        (0.5, 0.5, 0.16),\n    ]\n    \n    for x, y, r in initial_positions:\n        if is_valid_circle(x, y, r, centers, radii):\n            centers.append([x, y])\n            radii.append(r)\n    \n    # Phase 2: Quadtree-based adaptive subdivision\n    quadtree_packing(centers, radii, max_depth=5)\n    \n    # Phase 3: Fill remaining gaps with density-aware placement\n    density_aware_filling(centers, radii, n_attempts=500)\n    \n    # Phase 4: Optimize configuration\n    centers, radii = optimize_packing(centers, radii)\n    \n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef is_valid_circle(x, y, r, centers, radii, margin=1e-6):\n    \"\"\"Check if circle is valid (within bounds and non-overlapping).\"\"\"\n    # Check boundaries\n    if x - r < -margin or x + r > 1 + margin:\n        return False\n    if y - r < -margin or y + r > 1 + margin:\n        return False\n    \n    # Check overlaps with existing circles\n    for (cx, cy), cr in zip(centers, radii):\n        dist = np.sqrt((x - cx)**2 + (y - cy)**2)\n        if dist < r + cr - margin:\n            return False\n    \n    return True\n\ndef estimate_local_density(x, y, centers, radii, radius=0.2):\n    \"\"\"Estimate local circle density in a region around (x, y).\"\"\"\n    if len(centers) == 0:\n        return 0.0\n    \n    centers_arr = np.array(centers)\n    radii_arr = np.array(radii)\n    \n    # Calculate distances to all centers\n    distances = np.sqrt((centers_arr[:, 0] - x)**2 + (centers_arr[:, 1] - y)**2)\n    \n    # Count circles within the radius (weighted by their size)\n    mask = distances < radius\n    density = np.sum(radii_arr[mask]**2)  # Weight by area\n    \n    return density\n\ndef quadtree_packing(centers, radii, max_depth=5):\n    \"\"\"Recursively subdivide space and place circles based on density.\"\"\"\n    \n    class QuadNode:\n        def __init__(self, x_min, x_max, y_min, y_max, depth):\n            self.x_min = x_min\n            self.x_max = x_max\n            self.y_min = y_min\n            self.y_max = y_max\n            self.depth = depth\n            self.cx = (x_min + x_max) / 2\n            self.cy = (y_min + y_max) / 2\n            self.width = x_max - x_min\n            self.height = y_max - y_min\n    \n    queue = deque([QuadNode(0, 1, 0, 1, 0)])\n    \n    while queue:\n        node = queue.popleft()\n        \n        if node.depth >= max_depth:\n            continue\n        \n        # Estimate density at node center\n        density = estimate_local_density(node.cx, node.cy, centers, radii, radius=0.3)\n        \n        # Adaptive radius based on depth and density\n        base_radius = 0.15 * (0.7 ** node.depth)\n        density_factor = max(0.5, 1.0 - density * 0.5)\n        target_radius = base_radius * density_factor\n        \n        # Try to place circle at center of region\n        placed = False\n        for r_scale in [1.0, 0.9, 0.8, 0.7, 0.6, 0.5]:\n            r = target_radius * r_scale\n            if r < 0.02:  # Minimum radius threshold\n                break\n            \n            if is_valid_circle(node.cx, node.cy, r, centers, radii):\n                centers.append([node.cx, node.cy])\n                radii.append(r)\n                placed = True\n                break\n        \n        # Subdivide if density is low or no circle was placed\n        if density < 0.3 or not placed:\n            if node.depth < max_depth - 1:\n                # Create 4 child nodes\n                mid_x = node.cx\n                mid_y = node.cy\n                \n                children = [\n                    QuadNode(node.x_min, mid_x, node.y_min, mid_y, node.depth + 1),\n                    QuadNode(mid_x, node.x_max, node.y_min, mid_y, node.depth + 1),\n                    QuadNode(node.x_min, mid_x, mid_y, node.y_max, node.depth + 1),\n                    QuadNode(mid_x, node.x_max, mid_y, node.y_max, node.depth + 1),\n                ]\n                \n                queue.extend(children)\n\ndef density_aware_filling(centers, radii, n_attempts=500):\n    \"\"\"Fill remaining space with circles, prioritizing low-density regions.\"\"\"\n    \n    # Create a grid for density estimation\n    grid_size = 20\n    x_grid = np.linspace(0.05, 0.95, grid_size)\n    y_grid = np.linspace(0.05, 0.95, grid_size)\n    \n    for attempt in range(n_attempts):\n        # Compute density map\n        densities = []\n        positions = []\n        \n        for x in x_grid:\n            for y in y_grid:\n                density = estimate_local_density(x, y, centers, radii, radius=0.15)\n                densities.append(density)\n                positions.append((x, y))\n        \n        densities = np.array(densities)\n        \n        # Convert to probabilities (lower density = higher probability)\n        if len(densities) > 0 and np.max(densities) > 0:\n            inv_densities = np.max(densities) - densities + 0.1\n            probs = inv_densities / np.sum(inv_densities)\n        else:\n            probs = np.ones(len(positions)) / len(positions)\n        \n        # Sample position based on inverse density\n        idx = np.random.choice(len(positions), p=probs)\n        x, y = positions[idx]\n        \n        # Add small random offset\n        x += np.random.uniform(-0.03, 0.03)\n        y += np.random.uniform(-0.03, 0.03)\n        x = np.clip(x, 0, 1)\n        y = np.clip(y, 0, 1)\n        \n        # Try to place circle with adaptive radius\n        max_r = min(x, 1-x, y, 1-y) * 0.95\n        \n        for r in np.linspace(max_r, 0.015, 20):\n            if is_valid_circle(x, y, r, centers, radii):\n                centers.append([x, y])\n                radii.append(r)\n                break\n\ndef optimize_packing(centers, radii, max_iter=200):\n    \"\"\"Optimize circle positions and radii using scipy.\"\"\"\n    \n    if len(centers) == 0:\n        return centers, radii\n    \n    n = len(centers)\n    \n    # Initial parameters: [x1, y1, r1, x2, y2, r2, ...]\n    x0 = []\n    for (cx, cy), r in zip(centers, radii):\n        x0.extend([cx, cy, r])\n    x0 = np.array(x0)\n    \n    def objective(x):\n        \"\"\"Maximize sum of radii (minimize negative sum).\"\"\"\n        radii_opt = x[2::3]\n        return -np.sum(radii_opt)\n    \n    def constraint_no_overlap(x):\n        \"\"\"Ensure no circles overlap.\"\"\"\n        constraints = []\n        for i in range(n):\n            xi, yi, ri = x[3*i], x[3*i+1], x[3*i+2]\n            for j in range(i+1, n):\n                xj, yj, rj = x[3*j], x[3*j+1], x[3*j+2]\n                dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n                constraints.append(dist - ri - rj)\n        return np.array(constraints)\n    \n    def constraint_boundaries(x):\n        \"\"\"Ensure circles stay within boundaries.\"\"\"\n        constraints = []\n        for i in range(n):\n            xi, yi, ri = x[3*i], x[3*i+1], x[3*i+2]\n            constraints.extend([xi - ri, 1 - xi - ri, yi - ri, 1 - yi - ri])\n        return np.array(constraints)\n    \n    # Bounds for variables\n    bounds = []\n    for i in range(n):\n        bounds.extend([(0, 1), (0, 1), (0.01, 0.3)])\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_no_overlap},\n        {'type': 'ineq', 'fun': constraint_boundaries}\n    ]\n    \n    # Optimize\n    result = minimize(objective, x0, method='SLSQP', bounds=bounds,\n                     constraints=constraints, options={'maxiter': max_iter, 'ftol': 1e-6})\n    \n    if result.success or True:  # Use result even if not fully converged\n        x_opt = result.x\n        centers_opt = [[x_opt[3*i], x_opt[3*i+1]] for i in range(n)]\n        radii_opt = [x_opt[3*i+2] for i in range(n)]\n        return centers_opt, radii_opt\n    \n    return centers, radii\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    return construct_packing()\n\n# Test the implementation\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Target achieved: {sum_radii > 2.0}\")\n```\n\nThis implementation features:\n\n1. **Quadtree Subdivision**: Recursively divides space into regions and places circles based on local density\n2. **Density Estimation**: Calculates local circle density to identify sparse regions\n3. **Adaptive Sizing**: Adjusts circle sizes based on available space and local density\n4. **Strategic Initial Placement**: Starts with large circles in corners and center\n5. **Density-Aware Filling**: Uses probability sampling to preferentially fill low-density areas\n6. **Optimization**: Uses scipy to fine-tune positions and maximize radii sum\n\nThe algorithm targets sum_radii > 2.0 by intelligently distributing circles where space is available.",
  "reasoning": "I'll create a density-based adaptive packing algorithm using quadtree subdivision and local density estimation.\n\nThis implementation features:\n\n1. **Quadtree Subdivision**: Recursively divides space into regions and places circles based on local density\n2. **Density Estimation**: Calculates local circle density to identify sparse regions\n3. **Adaptive Sizing**: Adjusts circle sizes based on available space and local density\n4. **Strategic Initial Placement**: Starts with large circles in corners and center\n5. **Density-Aware Filling**: Uses probability sampling to preferentially fill low-density areas\n6. **Optimization**: Uses scipy to fine-tune positions and maximize radii sum\n\nThe algorithm targets sum_radii > 2.0 by intelligently distributing circles where space is available.",
  "timestamp": "2025-12-08T15:56:01.203468",
  "cost_data": null
}