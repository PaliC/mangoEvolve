{
  "trial_id": "trial_1_6",
  "generation": 1,
  "parent_id": "trial_0_7",
  "code": "",
  "metrics": {},
  "prompt": "Improve genetic algorithm with better operators and larger population:\n\nimport numpy as np\nfrom typing import Tuple, List\nimport copy\n\ndef construct_packing(genome: np.ndarray) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Convert genome to circle packing representation.\n    \n    Args:\n        genome: Array of shape (26*3,) containing [x1,y1,r1, x2,y2,r2, ...]\n    \n    Returns:\n        centers: Array of shape (26, 2) with circle centers\n        radii: Array of shape (26,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    genome = genome.reshape(26, 3)\n    centers = genome[:, :2]\n    radii = genome[:, 2]\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef check_constraints(centers: np.ndarray, radii: np.ndarray) -> Tuple[float, bool]:\n    \"\"\"\n    Check constraint violations and return penalty.\n    \n    Returns:\n        penalty: Total constraint violation penalty\n        is_valid: True if no violations\n    \"\"\"\n    penalty = 0.0\n    n = len(radii)\n    \n    # Check boundaries [0,1] x [0,1]\n    for i in range(n):\n        x, y, r = centers[i, 0], centers[i, 1], radii[i]\n        \n        # Out of bounds penalties\n        if x - r < 0:\n            penalty += abs(x - r)\n        if x + r > 1:\n            penalty += (x + r - 1)\n        if y - r < 0:\n            penalty += abs(y - r)\n        if y + r > 1:\n            penalty += (y + r - 1)\n    \n    # Check circle overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist:\n                penalty += (min_dist - dist)\n    \n    is_valid = (penalty < 1e-6)\n    return penalty, is_valid\n\n\ndef fitness(genome: np.ndarray) -> float:\n    \"\"\"\n    Calculate fitness: sum of radii minus penalties.\n    Higher is better.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing(genome)\n    penalty, _ = check_constraints(centers, radii)\n    \n    # Heavy penalty for constraint violations\n    return sum_radii - 100 * penalty\n\n\ndef repair_genome(genome: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Repair invalid solutions by adjusting positions and radii.\n    \"\"\"\n    genome = genome.copy().reshape(26, 3)\n    \n    # Clip positions to [0, 1]\n    genome[:, 0] = np.clip(genome[:, 0], 0, 1)\n    genome[:, 1] = np.clip(genome[:, 1], 0, 1)\n    \n    # Clip radii to reasonable range\n    genome[:, 2] = np.clip(genome[:, 2], 0.001, 0.3)\n    \n    # Adjust radii to fit within boundaries\n    for i in range(26):\n        x, y, r = genome[i]\n        max_r = min(x, 1-x, y, 1-y)\n        if r > max_r:\n            genome[i, 2] = max(max_r * 0.95, 0.001)\n    \n    # Try to resolve overlaps by shrinking radii\n    max_iterations = 10\n    for _ in range(max_iterations):\n        overlap_found = False\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(genome[i, :2] - genome[j, :2])\n                min_dist = genome[i, 2] + genome[j, 2]\n                if dist < min_dist and dist > 0:\n                    # Shrink both circles proportionally\n                    shrink_factor = 0.95 * dist / min_dist\n                    genome[i, 2] *= shrink_factor\n                    genome[j, 2] *= shrink_factor\n                    overlap_found = True\n        \n        if not overlap_found:\n            break\n    \n    return genome.flatten()\n\n\ndef initialize_population(pop_size: int) -> List[np.ndarray]:\n    \"\"\"Initialize population with random valid configurations.\"\"\"\n    population = []\n    \n    for _ in range(pop_size):\n        genome = np.zeros(26 * 3)\n        \n        # Random positions\n        genome[0::3] = np.random.uniform(0, 1, 26)  # x coordinates\n        genome[1::3] = np.random.uniform(0, 1, 26)  # y coordinates\n        genome[2::3] = np.random.uniform(0.01, 0.1, 26)  # radii\n        \n        # Repair to make valid\n        genome = repair_genome(genome)\n        population.append(genome)\n    \n    return population\n\n\ndef tournament_selection(population: List[np.ndarray], fitnesses: np.ndarray, \n                        tournament_size: int = 3) -> np.ndarray:\n    \"\"\"Select individual using tournament selection.\"\"\"\n    indices = np.random.choice(len(population), tournament_size, replace=False)\n    tournament_fitnesses = fitnesses[indices]\n    winner_idx = indices[np.argmax(tournament_fitnesses)]\n    return population[winner_idx].copy()\n\n\ndef crossover(parent1: np.ndarray, parent2: np.ndarray, alpha: float = 0.5) -> np.ndarray:\n    \"\"\"Blend crossover between two parents.\"\"\"\n    # Blend with some randomness\n    beta = np.random.uniform(alpha - 0.2, alpha + 0.2)\n    beta = np.clip(beta, 0, 1)\n    child = beta * parent1 + (1 - beta) * parent2\n    return child\n\n\ndef mutate(genome: np.ndarray, mutation_rate: float = 0.1, \n          mutation_strength: float = 0.05) -> np.ndarray:\n    \"\"\"Apply random mutations to genome.\"\"\"\n    genome = genome.copy()\n    \n    for i in range(len(genome)):\n        if np.random.random() < mutation_rate:\n            # Add Gaussian noise\n            noise = np.random.normal(0, mutation_strength)\n            genome[i] += noise\n    \n    return genome\n\n\ndef run_packing(pop_size: int = 80, generations: int = 150, \n                verbose: bool = True) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Run genetic algorithm for circle packing.\n    \n    Args:\n        pop_size: Population size\n        generations: Number of generations\n        verbose: Print progress\n    \n    Returns:\n        centers: Best circle centers found\n        radii: Best circle radii found\n        sum_radii: Sum of radii for best solution\n    \"\"\"\n    # Initialize\n    population = initialize_population(pop_size)\n    best_genome = None\n    best_fitness = -np.inf\n    \n    for gen in range(generations):\n        # Evaluate fitness\n        fitnesses = np.array([fitness(ind) for ind in population])\n        \n        # Track best\n        gen_best_idx = np.argmax(fitnesses)\n        gen_best_fitness = fitnesses[gen_best_idx]\n        \n        if gen_best_fitness > best_fitness:\n            best_fitness = gen_best_fitness\n            best_genome = population[gen_best_idx].copy()\n        \n        if verbose and gen % 20 == 0:\n            centers, radii, sum_radii = construct_packing(best_genome)\n            penalty, is_valid = check_constraints(centers, radii)\n            print(f\"Gen {gen}: Best sum_radii = {sum_radii:.4f}, \"\n                  f\"Penalty = {penalty:.6f}, Valid = {is_valid}\")\n        \n        # Create next generation\n        new_population = []\n        \n        # Elitism: keep best individuals\n        elite_size = max(2, pop_size // 20)\n        elite_indices = np.argsort(fitnesses)[-elite_size:]\n        for idx in elite_indices:\n            new_population.append(population[idx].copy())\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            # Selection\n            parent1 = tournament_selection(population, fitnesses)\n            parent2 = tournament_selection(population, fitnesses)\n            \n            # Crossover\n            child = crossover(parent1, parent2)\n            \n            # Mutation\n            child = mutate(child, mutation_rate=0.15, mutation_strength=0.03)\n            \n            # Repair\n            child = repair_genome(child)\n            \n            new_population.append(child)\n        \n        population = new_population[:pop_size]\n    \n    # Final evaluation\n    centers, radii, sum_radii = construct_packing(best_genome)\n    penalty, is_valid = check_constraints(centers, radii)\n    \n    if verbose:\n        print(f\"\\nFinal: sum_radii = {sum_radii:.4f}, \"\n              f\"Penalty = {penalty:.6f}, Valid = {is_valid}\")\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Run the genetic algorithm\n    centers, radii, total_radius = run_packing(pop_size=80, generations=150)\n    \n    print(f\"\\nBest packing found:\")\n    print(f\"Total radius sum: {total_radius:.4f}\")\n    print(f\"Average radius: {np.mean(radii):.4f}\")\n    print(f\"Min radius: {np.min(radii):.4f}\")\n    print(f\"Max radius: {np.max(radii):.4f}\")\n    \n    # Verify constraints\n    penalty, is_valid = check_constraints(centers, radii)\n    print(f\"Solution valid: {is_valid}\")\n    \n    # Optional: Visualize if matplotlib is available\n    try:\n        import matplotlib.pyplot as plt\n        from matplotlib.patches import Circle\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        ax.set_title(f'Circle Packing: 26 circles, sum of radii = {total_radius:.4f}')\n        \n        for i in range(26):\n            circle = Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n            ax.add_patch(circle)\n        \n        plt.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('circle_packing.png', dpi=150)\n        print(\"\\nVisualization saved as 'circle_packing.png'\")\n    except ImportError:\n        print(\"\\nMatplotlib not available for visualization\")\n\nEnhancements:\n1. Increase population size to 150\n2. Increase generations to 250\n3. Add a \"local search\" mutation that uses hill climbing\n4. Implement better crossover: blend top 3 parents instead of 2\n5. Add elitism: keep top 10% of population\n6. Use tournament size of 5 for stronger selection pressure\n7. Adaptive mutation rate: start high (0.2), decrease over time\n\nTarget: exceed sum_radii=1.70.",
  "response": "Here's an improved genetic algorithm with all the requested enhancements:\n\n```python\nimport numpy as np\nfrom typing import Tuple, List\nimport copy\n\ndef construct_packing(genome: np.ndarray) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Convert genome to circle packing representation.\n    \n    Args:\n        genome: Array of shape (26*3,) containing [x1,y1,r1, x2,y2,r2, ...]\n    \n    Returns:\n        centers: Array of shape (26, 2) with circle centers\n        radii: Array of shape (26,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    genome = genome.reshape(26, 3)\n    centers = genome[:, :2]\n    radii = genome[:, 2]\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\n\ndef check_constraints(centers: np.ndarray, radii: np.ndarray) -> Tuple[float, bool]:\n    \"\"\"\n    Check constraint violations and return penalty.\n    \n    Returns:\n        penalty: Total constraint violation penalty\n        is_valid: True if no violations\n    \"\"\"\n    penalty = 0.0\n    n = len(radii)\n    \n    # Check boundaries [0,1] x [0,1]\n    for i in range(n):\n        x, y, r = centers[i, 0], centers[i, 1], radii[i]\n        \n        # Out of bounds penalties\n        if x - r < 0:\n            penalty += abs(x - r)\n        if x + r > 1:\n            penalty += (x + r - 1)\n        if y - r < 0:\n            penalty += abs(y - r)\n        if y + r > 1:\n            penalty += (y + r - 1)\n    \n    # Check circle overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist:\n                penalty += (min_dist - dist)\n    \n    is_valid = (penalty < 1e-6)\n    return penalty, is_valid\n\n\ndef fitness(genome: np.ndarray) -> float:\n    \"\"\"\n    Calculate fitness: sum of radii minus penalties.\n    Higher is better.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing(genome)\n    penalty, _ = check_constraints(centers, radii)\n    \n    # Heavy penalty for constraint violations\n    return sum_radii - 100 * penalty\n\n\ndef repair_genome(genome: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Repair invalid solutions by adjusting positions and radii.\n    \"\"\"\n    genome = genome.copy().reshape(26, 3)\n    \n    # Clip positions to [0, 1]\n    genome[:, 0] = np.clip(genome[:, 0], 0, 1)\n    genome[:, 1] = np.clip(genome[:, 1], 0, 1)\n    \n    # Clip radii to reasonable range\n    genome[:, 2] = np.clip(genome[:, 2], 0.001, 0.35)\n    \n    # Adjust radii to fit within boundaries\n    for i in range(26):\n        x, y, r = genome[i]\n        max_r = min(x, 1-x, y, 1-y)\n        if r > max_r:\n            genome[i, 2] = max(max_r * 0.95, 0.001)\n    \n    # Try to resolve overlaps by shrinking radii\n    max_iterations = 15\n    for _ in range(max_iterations):\n        overlap_found = False\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(genome[i, :2] - genome[j, :2])\n                min_dist = genome[i, 2] + genome[j, 2]\n                if dist < min_dist and dist > 0:\n                    # Shrink both circles proportionally\n                    shrink_factor = 0.95 * dist / min_dist\n                    genome[i, 2] *= shrink_factor\n                    genome[j, 2] *= shrink_factor\n                    overlap_found = True\n        \n        if not overlap_found:\n            break\n    \n    return genome.flatten()\n\n\ndef initialize_population(pop_size: int) -> List[np.ndarray]:\n    \"\"\"Initialize population with diverse random valid configurations.\"\"\"\n    population = []\n    \n    # Strategy 1: Uniform random (40% of population)\n    for _ in range(int(pop_size * 0.4)):\n        genome = np.zeros(26 * 3)\n        genome[0::3] = np.random.uniform(0, 1, 26)  # x coordinates\n        genome[1::3] = np.random.uniform(0, 1, 26)  # y coordinates\n        genome[2::3] = np.random.uniform(0.01, 0.12, 26)  # radii\n        genome = repair_genome(genome)\n        population.append(genome)\n    \n    # Strategy 2: Grid-based initialization (30% of population)\n    for _ in range(int(pop_size * 0.3)):\n        genome = np.zeros(26 * 3)\n        # Place circles on a perturbed grid\n        grid_size = 6  # 6x6 grid (we'll use 26 of 36 positions)\n        positions = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                x = (i + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                y = (j + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                positions.append([x, y])\n        \n        # Randomly select 26 positions\n        selected = np.random.choice(len(positions), 26, replace=False)\n        for idx, pos_idx in enumerate(selected):\n            genome[idx*3] = positions[pos_idx][0]\n            genome[idx*3 + 1] = positions[pos_idx][1]\n            genome[idx*3 + 2] = np.random.uniform(0.02, 0.10, 1)[0]\n        \n        genome = repair_genome(genome)\n        population.append(genome)\n    \n    # Strategy 3: Corner and edge bias (30% of population)\n    for _ in range(pop_size - len(population)):\n        genome = np.zeros(26 * 3)\n        # Bias towards corners and edges\n        for i in range(26):\n            if np.random.random() < 0.3:  # 30% near edges\n                if np.random.random() < 0.5:\n                    genome[i*3] = np.random.choice([np.random.uniform(0, 0.2), \n                                                    np.random.uniform(0.8, 1)])\n                    genome[i*3 + 1] = np.random.uniform(0, 1)\n                else:\n                    genome[i*3] = np.random.uniform(0, 1)\n                    genome[i*3 + 1] = np.random.choice([np.random.uniform(0, 0.2), \n                                                        np.random.uniform(0.8, 1)])\n            else:\n                genome[i*3] = np.random.uniform(0, 1)\n                genome[i*3 + 1] = np.random.uniform(0, 1)\n            \n            genome[i*3 + 2] = np.random.uniform(0.01, 0.12, 1)[0]\n        \n        genome = repair_genome(genome)\n        population.append(genome)\n    \n    return population\n\n\ndef tournament_selection(population: List[np.ndarray], fitnesses: np.ndarray, \n                        tournament_size: int = 5) -> np.ndarray:\n    \"\"\"Select individual using tournament selection with size 5.\"\"\"\n    indices = np.random.choice(len(population), tournament_size, replace=False)\n    tournament_fitnesses = fitnesses[indices]\n    winner_idx = indices[np.argmax(tournament_fitnesses)]\n    return population[winner_idx].copy()\n\n\ndef multi_parent_crossover(parents: List[np.ndarray]) -> np.ndarray:\n    \"\"\"Blend crossover between top 3 parents.\"\"\"\n    # Weighted blend: best parent gets more weight\n    weights = np.array([0.5, 0.3, 0.2])  # Favor the best parent\n    weights += np.random.uniform(-0.1, 0.1, 3)  # Add randomness\n    weights = np.clip(weights, 0, 1)\n    weights /= weights.sum()  # Normalize\n    \n    child = np.zeros_like(parents[0])\n    for i, parent in enumerate(parents):\n        child += weights[i] * parent\n    \n    return child\n\n\ndef mutate(genome: np.ndarray, mutation_rate: float = 0.1, \n          mutation_strength: float = 0.05) -> np.ndarray:\n    \"\"\"Apply random mutations to genome.\"\"\"\n    genome = genome.copy()\n    \n    for i in range(len(genome)):\n        if np.random.random() < mutation_rate:\n            # Add Gaussian noise\n            noise = np.random.normal(0, mutation_strength)\n            genome[i] += noise\n    \n    return genome\n\n\ndef local_search_mutation(genome: np.ndarray, iterations: int = 5) -> np.ndarray:\n    \"\"\"\n    Apply hill climbing local search to improve the genome.\n    Try small perturbations and keep improvements.\n    \"\"\"\n    current_genome = genome.copy()\n    current_fitness = fitness(current_genome)\n    \n    for _ in range(iterations):\n        # Try multiple random perturbations\n        best_neighbor = current_genome\n        best_neighbor_fitness = current_fitness\n        \n        for _ in range(10):  # Try 10 neighbors\n            # Create neighbor by perturbing a random subset of genes\n            neighbor = current_genome.copy()\n            num_perturb = np.random.randint(1, 6)  # Perturb 1-5 genes\n            indices = np.random.choice(len(neighbor), num_perturb, replace=False)\n            \n            for idx in indices:\n                # Small perturbation\n                if idx % 3 == 2:  # Radius\n                    neighbor[idx] += np.random.normal(0, 0.01)\n                else:  # Position\n                    neighbor[idx] += np.random.normal(0, 0.02)\n            \n            neighbor = repair_genome(neighbor)\n            neighbor_fitness = fitness(neighbor)\n            \n            if neighbor_fitness > best_neighbor_fitness:\n                best_neighbor = neighbor\n                best_neighbor_fitness = neighbor_fitness\n        \n        # Move to best neighbor if it's better\n        if best_neighbor_fitness > current_fitness:\n            current_genome = best_neighbor\n            current_fitness = best_neighbor_fitness\n        else:\n            break  # No improvement found\n    \n    return current_genome\n\n\ndef adaptive_mutation_rate(generation: int, max_generations: int, \n                          start_rate: float = 0.2, end_rate: float = 0.05) -> float:\n    \"\"\"Calculate adaptive mutation rate that decreases over time.\"\"\"\n    progress = generation / max_generations\n    return start_rate - (start_rate - end_rate) * progress\n\n\ndef run_packing(pop_size: int = 150, generations: int = 250, \n                verbose: bool = True) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Run enhanced genetic algorithm for circle packing.\n    \n    Args:\n        pop_size: Population size (default: 150)\n        generations: Number of generations (default: 250)\n        verbose: Print progress\n    \n    Returns:\n        centers: Best circle centers found\n        radii: Best circle radii found\n        sum_radii: Sum of radii for best solution\n    \"\"\"\n    # Initialize\n    population = initialize_population(pop_size)\n    best_genome = None\n    best_fitness = -np.inf\n    stagnation_counter = 0\n    \n    for gen in range(generations):\n        # Evaluate fitness\n        fitnesses = np.array([fitness(ind) for ind in population])\n        \n        # Track best\n        gen_best_idx = np.argmax(fitnesses)\n        gen_best_fitness = fitnesses[gen_best_idx]\n        \n        prev_best_fitness = best_fitness\n        if gen_best_fitness > best_fitness:\n            best_fitness = gen_best_fitness\n            best_genome = population[gen_best_idx].copy()\n            stagnation_counter = 0\n        else:\n            stagnation_counter += 1\n        \n        if verbose and gen % 20 == 0:\n            centers, radii, sum_radii = construct_packing(best_genome)\n            penalty, is_valid = check_constraints(centers, radii)\n            print(f\"Gen {gen}: Best sum_radii = {sum_radii:.4f}, \"\n                  f\"Penalty = {penalty:.6f}, Valid = {is_valid}, \"\n                  f\"Avg fitness = {np.mean(fitnesses):.4f}\")\n        \n        # Adaptive mutation rate\n        mut_rate = adaptive_mutation_rate(gen, generations)\n        \n        # Create next generation\n        new_population = []\n        \n        # Elitism: keep top 10% of population\n        elite_size = max(5, pop_size // 10)\n        elite_indices = np.argsort(fitnesses)[-elite_size:]\n        for idx in elite_indices:\n            new_population.append(population[idx].copy())\n        \n        # Apply local search to best individuals occasionally\n        if gen % 10 == 0:\n            for i in range(min(3, elite_size)):\n                idx = elite_indices[-(i+1)]\n                improved = local_search_mutation(population[idx], iterations=8)\n                new_population.append(improved)\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            # Select 3 parents using tournament selection\n            parents = []\n            for _ in range(3):\n                parent = tournament_selection(population, fitnesses, tournament_size=5)\n                parents.append(parent)\n            \n            # Multi-parent crossover\n            child = multi_parent_crossover(parents)\n            \n            # Mutation with adaptive rate\n            if np.random.random() < 0.7:  # 70% chance of standard mutation\n                child = mutate(child, mutation_rate=mut_rate, \n                             mutation_strength=0.03 * (1 - gen/generations))\n            \n            # Occasionally apply local search mutation (10% chance)\n            if np.random.random() < 0.1:\n                child = local_search_mutation(child, iterations=5)\n            \n            # Repair\n            child = repair_genome(child)\n            \n            new_population.append(child)\n        \n        population = new_population[:pop_size]\n        \n        # Diversity maintenance: if stagnation, introduce some random individuals\n        if stagnation_counter > 30:\n            num_random = pop_size // 10\n            if verbose:\n                print(f\"  Stagnation detected at gen {gen}, injecting {num_random} random individuals\")\n            for i in range(num_random):\n                population[i] = initialize_population(1)[0]\n            stagnation_counter = 0\n    \n    # Final local search on best solution\n    if verbose:\n        print(\"\\nApplying final local search optimization...\")\n    best_genome = local_search_mutation(best_genome, iterations=20)\n    \n    # Final evaluation\n    centers, radii, sum_radii = construct_packing(best_genome)\n    penalty, is_valid = check_constraints(centers, radii)\n    \n    if verbose:\n        print(f\"\\nFinal: sum_radii = {sum_radii:.4f}, \"",
  "reasoning": "Here's an improved genetic algorithm with all the requested enhancements:\n\n```python\nimport numpy as np\nfrom typing import Tuple, List\nimport copy\n\ndef construct_packing(genome: np.ndarray) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Convert genome to circle packing representation.\n    \n    Args:\n        genome: Array of shape (26*3,) containing [x1,y1,r1, x2,y2,r2, ...]\n    \n    Returns:\n        centers: Array of shape (26, 2) with circle centers\n        radii: Array of shape (26,) with circle radii\n        sum_radii: Sum of all radii\n    \"\"\"\n    genome = genome.reshape(26, 3)\n    centers = genome[:, :2]\n    radii = genome[:, 2]\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef check_constraints(centers: np.ndarray, radii: np.ndarray) -> Tuple[float, bool]:\n    \"\"\"\n    Check constraint violations and return penalty.\n    \n    Returns:\n        penalty: Total constraint violation penalty\n        is_valid: True if no violations\n    \"\"\"\n    penalty = 0.0\n    n = len(radii)\n    \n    # Check boundaries [0,1] x [0,1]\n    for i in range(n):\n        x, y, r = centers[i, 0], centers[i, 1], radii[i]\n        \n        # Out of bounds penalties\n        if x - r < 0:\n            penalty += abs(x - r)\n        if x + r > 1:\n            penalty += (x + r - 1)\n        if y - r < 0:\n            penalty += abs(y - r)\n        if y + r > 1:\n            penalty += (y + r - 1)\n    \n    # Check circle overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist:\n                penalty += (min_dist - dist)\n    \n    is_valid = (penalty < 1e-6)\n    return penalty, is_valid\n\ndef fitness(genome: np.ndarray) -> float:\n    \"\"\"\n    Calculate fitness: sum of radii minus penalties.\n    Higher is better.\n    \"\"\"\n    centers, radii, sum_radii = construct_packing(genome)\n    penalty, _ = check_constraints(centers, radii)\n    \n    # Heavy penalty for constraint violations\n    return sum_radii - 100 * penalty\n\ndef repair_genome(genome: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Repair invalid solutions by adjusting positions and radii.\n    \"\"\"\n    genome = genome.copy().reshape(26, 3)\n    \n    # Clip positions to [0, 1]\n    genome[:, 0] = np.clip(genome[:, 0], 0, 1)\n    genome[:, 1] = np.clip(genome[:, 1], 0, 1)\n    \n    # Clip radii to reasonable range\n    genome[:, 2] = np.clip(genome[:, 2], 0.001, 0.35)\n    \n    # Adjust radii to fit within boundaries\n    for i in range(26):\n        x, y, r = genome[i]\n        max_r = min(x, 1-x, y, 1-y)\n        if r > max_r:\n            genome[i, 2] = max(max_r * 0.95, 0.001)\n    \n    # Try to resolve overlaps by shrinking radii\n    max_iterations = 15\n    for _ in range(max_iterations):\n        overlap_found = False\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(genome[i, :2] - genome[j, :2])\n                min_dist = genome[i, 2] + genome[j, 2]\n                if dist < min_dist and dist > 0:\n                    # Shrink both circles proportionally\n                    shrink_factor = 0.95 * dist / min_dist\n                    genome[i, 2] *= shrink_factor\n                    genome[j, 2] *= shrink_factor\n                    overlap_found = True\n        \n        if not overlap_found:\n            break\n    \n    return genome.flatten()\n\ndef initialize_population(pop_size: int) -> List[np.ndarray]:\n    \"\"\"Initialize population with diverse random valid configurations.\"\"\"\n    population = []\n    \n    # Strategy 1: Uniform random (40% of population)\n    for _ in range(int(pop_size * 0.4)):\n        genome = np.zeros(26 * 3)\n        genome[0::3] = np.random.uniform(0, 1, 26)  # x coordinates\n        genome[1::3] = np.random.uniform(0, 1, 26)  # y coordinates\n        genome[2::3] = np.random.uniform(0.01, 0.12, 26)  # radii\n        genome = repair_genome(genome)\n        population.append(genome)\n    \n    # Strategy 2: Grid-based initialization (30% of population)\n    for _ in range(int(pop_size * 0.3)):\n        genome = np.zeros(26 * 3)\n        # Place circles on a perturbed grid\n        grid_size = 6  # 6x6 grid (we'll use 26 of 36 positions)\n        positions = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                x = (i + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                y = (j + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                positions.append([x, y])\n        \n        # Randomly select 26 positions\n        selected = np.random.choice(len(positions), 26, replace=False)\n        for idx, pos_idx in enumerate(selected):\n            genome[idx*3] = positions[pos_idx][0]\n            genome[idx*3 + 1] = positions[pos_idx][1]\n            genome[idx*3 + 2] = np.random.uniform(0.02, 0.10, 1)[0]\n        \n        genome = repair_genome(genome)\n        population.append(genome)\n    \n    # Strategy 3: Corner and edge bias (30% of population)\n    for _ in range(pop_size - len(population)):\n        genome = np.zeros(26 * 3)\n        # Bias towards corners and edges\n        for i in range(26):\n            if np.random.random() < 0.3:  # 30% near edges\n                if np.random.random() < 0.5:\n                    genome[i*3] = np.random.choice([np.random.uniform(0, 0.2), \n                                                    np.random.uniform(0.8, 1)])\n                    genome[i*3 + 1] = np.random.uniform(0, 1)\n                else:\n                    genome[i*3] = np.random.uniform(0, 1)\n                    genome[i*3 + 1] = np.random.choice([np.random.uniform(0, 0.2), \n                                                        np.random.uniform(0.8, 1)])\n            else:\n                genome[i*3] = np.random.uniform(0, 1)\n                genome[i*3 + 1] = np.random.uniform(0, 1)\n            \n            genome[i*3 + 2] = np.random.uniform(0.01, 0.12, 1)[0]\n        \n        genome = repair_genome(genome)\n        population.append(genome)\n    \n    return population\n\ndef tournament_selection(population: List[np.ndarray], fitnesses: np.ndarray, \n                        tournament_size: int = 5) -> np.ndarray:\n    \"\"\"Select individual using tournament selection with size 5.\"\"\"\n    indices = np.random.choice(len(population), tournament_size, replace=False)\n    tournament_fitnesses = fitnesses[indices]\n    winner_idx = indices[np.argmax(tournament_fitnesses)]\n    return population[winner_idx].copy()\n\ndef multi_parent_crossover(parents: List[np.ndarray]) -> np.ndarray:\n    \"\"\"Blend crossover between top 3 parents.\"\"\"\n    # Weighted blend: best parent gets more weight\n    weights = np.array([0.5, 0.3, 0.2])  # Favor the best parent\n    weights += np.random.uniform(-0.1, 0.1, 3)  # Add randomness\n    weights = np.clip(weights, 0, 1)\n    weights /= weights.sum()  # Normalize\n    \n    child = np.zeros_like(parents[0])\n    for i, parent in enumerate(parents):\n        child += weights[i] * parent\n    \n    return child\n\ndef mutate(genome: np.ndarray, mutation_rate: float = 0.1, \n          mutation_strength: float = 0.05) -> np.ndarray:\n    \"\"\"Apply random mutations to genome.\"\"\"\n    genome = genome.copy()\n    \n    for i in range(len(genome)):\n        if np.random.random() < mutation_rate:\n            # Add Gaussian noise\n            noise = np.random.normal(0, mutation_strength)\n            genome[i] += noise\n    \n    return genome\n\ndef local_search_mutation(genome: np.ndarray, iterations: int = 5) -> np.ndarray:\n    \"\"\"\n    Apply hill climbing local search to improve the genome.\n    Try small perturbations and keep improvements.\n    \"\"\"\n    current_genome = genome.copy()\n    current_fitness = fitness(current_genome)\n    \n    for _ in range(iterations):\n        # Try multiple random perturbations\n        best_neighbor = current_genome\n        best_neighbor_fitness = current_fitness\n        \n        for _ in range(10):  # Try 10 neighbors\n            # Create neighbor by perturbing a random subset of genes\n            neighbor = current_genome.copy()\n            num_perturb = np.random.randint(1, 6)  # Perturb 1-5 genes\n            indices = np.random.choice(len(neighbor), num_perturb, replace=False)\n            \n            for idx in indices:\n                # Small perturbation\n                if idx % 3 == 2:  # Radius\n                    neighbor[idx] += np.random.normal(0, 0.01)\n                else:  # Position\n                    neighbor[idx] += np.random.normal(0, 0.02)\n            \n            neighbor = repair_genome(neighbor)\n            neighbor_fitness = fitness(neighbor)\n            \n            if neighbor_fitness > best_neighbor_fitness:\n                best_neighbor = neighbor\n                best_neighbor_fitness = neighbor_fitness\n        \n        # Move to best neighbor if it's better\n        if best_neighbor_fitness > current_fitness:\n            current_genome = best_neighbor\n            current_fitness = best_neighbor_fitness\n        else:\n            break  # No improvement found\n    \n    return current_genome\n\ndef adaptive_mutation_rate(generation: int, max_generations: int, \n                          start_rate: float = 0.2, end_rate: float = 0.05) -> float:\n    \"\"\"Calculate adaptive mutation rate that decreases over time.\"\"\"\n    progress = generation / max_generations\n    return start_rate - (start_rate - end_rate) * progress\n\ndef run_packing(pop_size: int = 150, generations: int = 250, \n                verbose: bool = True) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Run enhanced genetic algorithm for circle packing.\n    \n    Args:\n        pop_size: Population size (default: 150)\n        generations: Number of generations (default: 250)\n        verbose: Print progress\n    \n    Returns:\n        centers: Best circle centers found\n        radii: Best circle radii found\n        sum_radii: Sum of radii for best solution\n    \"\"\"\n    # Initialize\n    population = initialize_population(pop_size)\n    best_genome = None\n    best_fitness = -np.inf\n    stagnation_counter = 0\n    \n    for gen in range(generations):\n        # Evaluate fitness\n        fitnesses = np.array([fitness(ind) for ind in population])\n        \n        # Track best\n        gen_best_idx = np.argmax(fitnesses)\n        gen_best_fitness = fitnesses[gen_best_idx]\n        \n        prev_best_fitness = best_fitness\n        if gen_best_fitness > best_fitness:\n            best_fitness = gen_best_fitness\n            best_genome = population[gen_best_idx].copy()\n            stagnation_counter = 0\n        else:\n            stagnation_counter += 1\n        \n        if verbose and gen % 20 == 0:\n            centers, radii, sum_radii = construct_packing(best_genome)\n            penalty, is_valid = check_constraints(centers, radii)\n            print(f\"Gen {gen}: Best sum_radii = {sum_radii:.4f}, \"\n                  f\"Penalty = {penalty:.6f}, Valid = {is_valid}, \"\n                  f\"Avg fitness = {np.mean(fitnesses):.4f}\")\n        \n        # Adaptive mutation rate\n        mut_rate = adaptive_mutation_rate(gen, generations)\n        \n        # Create next generation\n        new_population = []\n        \n        # Elitism: keep top 10% of population\n        elite_size = max(5, pop_size // 10)\n        elite_indices = np.argsort(fitnesses)[-elite_size:]\n        for idx in elite_indices:\n            new_population.append(population[idx].copy())\n        \n        # Apply local search to best individuals occasionally\n        if gen % 10 == 0:\n            for i in range(min(3, elite_size)):\n                idx = elite_indices[-(i+1)]\n                improved = local_search_mutation(population[idx], iterations=8)\n                new_population.append(improved)\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            # Select 3 parents using tournament selection\n            parents = []\n            for _ in range(3):\n                parent = tournament_selection(population, fitnesses, tournament_size=5)\n                parents.append(parent)\n            \n            # Multi-parent crossover\n            child = multi_parent_crossover(parents)\n            \n            # Mutation with adaptive rate\n            if np.random.random() < 0.7:  # 70% chance of standard mutation\n                child = mutate(child, mutation_rate=mut_rate, \n                             mutation_strength=0.03 * (1 - gen/generations))\n            \n            # Occasionally apply local search mutation (10% chance)\n            if np.random.random() < 0.1:\n                child = local_search_mutation(child, iterations=5)\n            \n            # Repair\n            child = repair_genome(child)\n            \n            new_population.append(child)\n        \n        population = new_population[:pop_size]\n        \n        # Diversity maintenance: if stagnation, introduce some random individuals\n        if stagnation_counter > 30:\n            num_random = pop_size // 10\n            if verbose:\n                print(f\"  Stagnation detected at gen {gen}, injecting {num_random} random individuals\")\n            for i in range(num_random):\n                population[i] = initialize_population(1)[0]\n            stagnation_counter = 0\n    \n    # Final local search on best solution\n    if verbose:\n        print(\"\\nApplying final local search optimization...\")\n    best_genome = local_search_mutation(best_genome, iterations=20)\n    \n    # Final evaluation\n    centers, radii, sum_radii = construct_packing(best_genome)\n    penalty, is_valid = check_constraints(centers, radii)\n    \n    if verbose:\n        print(f\"\\nFinal: sum_radii = {sum_radii:.4f}, \"",
  "timestamp": "2025-12-08T15:55:34.666861",
  "cost_data": null
}