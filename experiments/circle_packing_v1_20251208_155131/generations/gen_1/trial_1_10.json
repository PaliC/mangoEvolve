{
  "trial_id": "trial_1_10",
  "generation": 1,
  "parent_id": "trial_0_5",
  "code": "import numpy as np\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport heapq\n\n@dataclass\nclass PartialPacking:\n    centers: List[Tuple[float, float]]\n    radii: List[float]\n    sum_radii: float\n    score: float\n    \n    def __lt__(self, other):\n        return self.score > other.score  # Higher score is better\n\ndef calculate_max_radius(center: Tuple[float, float], \n                        existing_centers: List[Tuple[float, float]], \n                        existing_radii: List[float]) -> float:\n    \"\"\"Calculate maximum radius for a circle at given center.\"\"\"\n    x, y = center\n    \n    # Distance to boundaries\n    max_r = min(x, y, 1 - x, 1 - y)\n    \n    # Distance to existing circles\n    for (cx, cy), r in zip(existing_centers, existing_radii):\n        dist = np.sqrt((x - cx)**2 + (y - cy)**2)\n        max_r = min(max_r, dist - r)\n    \n    return max(0, max_r)\n\ndef estimate_future_potential(centers: List[Tuple[float, float]], \n                             radii: List[float], \n                             n_remaining: int) -> float:\n    \"\"\"Estimate potential sum of radii for remaining circles.\"\"\"\n    if n_remaining == 0:\n        return 0\n    \n    # Sample potential positions and estimate average achievable radius\n    n_samples = 50\n    sample_radii = []\n    \n    for _ in range(n_samples):\n        # Random position\n        x, y = np.random.uniform(0.1, 0.9, 2)\n        max_r = calculate_max_radius((x, y), centers, radii)\n        if max_r > 0:\n            sample_radii.append(max_r)\n    \n    if not sample_radii:\n        return 0\n    \n    # Conservative estimate: use median of samples, scaled down\n    avg_radius = np.median(sample_radii) * 0.7\n    return avg_radius * n_remaining\n\ndef generate_candidate_positions(packing: PartialPacking, \n                                n_candidates: int = 20) -> List[Tuple[float, float]]:\n    \"\"\"Generate candidate positions for next circle.\"\"\"\n    candidates = []\n    \n    if len(packing.centers) == 0:\n        # First circle: place at center\n        return [(0.5, 0.5)]\n    \n    # Strategy 1: Near existing circles (tangent positions)\n    for (cx, cy), r in zip(packing.centers, packing.radii):\n        for angle in np.linspace(0, 2*np.pi, 8, endpoint=False):\n            # Try positions at various distances\n            for dist_factor in [1.1, 1.3, 1.5]:\n                offset = r * dist_factor\n                x = cx + offset * np.cos(angle)\n                y = cy + offset * np.sin(angle)\n                if 0 < x < 1 and 0 < y < 1:\n                    candidates.append((x, y))\n    \n    # Strategy 2: Grid-based exploration of empty space\n    grid_size = 15\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = (i + 0.5) / grid_size\n            y = (j + 0.5) / grid_size\n            candidates.append((x, y))\n    \n    # Strategy 3: Random exploration\n    for _ in range(30):\n        x, y = np.random.uniform(0.05, 0.95, 2)\n        candidates.append((x, y))\n    \n    # Remove duplicates and limit\n    unique_candidates = []\n    seen = set()\n    for c in candidates:\n        key = (round(c[0], 4), round(c[1], 4))\n        if key not in seen:\n            seen.add(key)\n            unique_candidates.append(c)\n    \n    # Score candidates by immediate radius potential\n    scored = []\n    for pos in unique_candidates:\n        max_r = calculate_max_radius(pos, packing.centers, packing.radii)\n        if max_r > 1e-6:  # Only consider valid positions\n            scored.append((max_r, pos))\n    \n    # Return top candidates\n    scored.sort(reverse=True)\n    return [pos for _, pos in scored[:n_candidates]]\n\ndef construct_packing():\n    \"\"\"Main beam search packing algorithm.\"\"\"\n    n_circles = 26\n    beam_width = 10\n    n_candidates = 20\n    \n    # Initialize beam with empty packing\n    beam = [PartialPacking(centers=[], radii=[], sum_radii=0, score=0)]\n    \n    for step in range(n_circles):\n        new_beam = []\n        n_remaining = n_circles - step - 1\n        \n        # Expand each packing in current beam\n        for packing in beam:\n            candidates = generate_candidate_positions(packing, n_candidates)\n            \n            # Create new packings for each candidate\n            for pos in candidates:\n                max_r = calculate_max_radius(pos, packing.centers, packing.radii)\n                \n                if max_r > 1e-6:\n                    # Create new packing\n                    new_centers = packing.centers + [pos]\n                    new_radii = packing.radii + [max_r]\n                    new_sum = packing.sum_radii + max_r\n                    \n                    # Score: immediate gain + estimated future potential\n                    future_potential = estimate_future_potential(\n                        new_centers, new_radii, n_remaining\n                    )\n                    score = new_sum + future_potential\n                    \n                    new_packing = PartialPacking(\n                        centers=new_centers,\n                        radii=new_radii,\n                        sum_radii=new_sum,\n                        score=score\n                    )\n                    new_beam.append(new_packing)\n        \n        # Keep top K packings\n        if len(new_beam) > beam_width:\n            new_beam.sort()\n            beam = new_beam[:beam_width]\n        else:\n            beam = new_beam\n        \n        if not beam:\n            break\n        \n        # Print progress\n        best_score = beam[0].sum_radii\n        print(f\"Step {step + 1}/{n_circles}: Best sum_radii = {best_score:.4f}\")\n    \n    # Return best final packing\n    if not beam:\n        return [], [], 0\n    \n    best = beam[0]\n    return best.centers, best.radii, best.sum_radii\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    print(\"Starting beam search packing algorithm...\")\n    print(f\"Target: Pack 26 circles with sum_radii > 2.1\")\n    print()\n    \n    centers, radii, sum_radii = construct_packing()\n    \n    print()\n    print(\"=\" * 50)\n    print(f\"Final result: {len(radii)} circles packed\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Target achieved: {sum_radii > 2.1}\")\n    print(\"=\" * 50)\n    \n    # Verify packing validity\n    valid = True\n    for i, ((x, y), r) in enumerate(zip(centers, radii)):\n        # Check boundaries\n        if x - r < -1e-6 or x + r > 1 + 1e-6 or y - r < -1e-6 or y + r > 1 + 1e-6:\n            print(f\"Circle {i} violates boundary!\")\n            valid = False\n        \n        # Check overlaps\n        for j in range(i):\n            (x2, y2), r2 = centers[j], radii[j]\n            dist = np.sqrt((x - x2)**2 + (y - y2)**2)\n            if dist < r + r2 - 1e-6:\n                print(f\"Circles {i} and {j} overlap!\")\n                valid = False\n    \n    if valid:\n        print(\"Packing is valid!\")\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Visualize if matplotlib is available\n    try:\n        import matplotlib.pyplot as plt\n        from matplotlib.patches import Circle\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        ax.set_title(f'Beam Search Packing: {len(radii)} circles, sum_radii = {sum_radii:.4f}')\n        \n        for (x, y), r in zip(centers, radii):\n            circle = Circle((x, y), r, fill=False, edgecolor='blue', linewidth=1)\n            ax.add_patch(circle)\n        \n        ax.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('beam_search_packing.png', dpi=150, bbox_inches='tight')\n        print(\"Visualization saved as 'beam_search_packing.png'\")\n        plt.show()\n    except ImportError:\n        print(\"Matplotlib not available for visualization\")",
  "metrics": {
    "valid": true,
    "sum_radii": 1.4041074452943791,
    "target_ratio": 0.5328681006809789,
    "combined_score": 0.5328681006809789,
    "eval_time": 3.2429840564727783,
    "error": null
  },
  "prompt": "Implement a beam search packing algorithm:\n\nStrategy:\n1. Maintain top K=10 partial packings (beam)\n2. Start with empty packing\n3. At each step, for each partial packing, generate N=20 candidate positions for next circle\n4. Score each candidate by: immediate radius + estimated future potential\n5. Keep top K complete packings\n6. Return best final packing\n\nThis explores multiple promising paths simultaneously.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Pack 26 circles in [0,1]x[0,1]\n- Target sum_radii > 2.1",
  "response": "I'll implement a beam search packing algorithm that explores multiple promising paths simultaneously.\n\n```python\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport heapq\n\n@dataclass\nclass PartialPacking:\n    centers: List[Tuple[float, float]]\n    radii: List[float]\n    sum_radii: float\n    score: float\n    \n    def __lt__(self, other):\n        return self.score > other.score  # Higher score is better\n\ndef calculate_max_radius(center: Tuple[float, float], \n                        existing_centers: List[Tuple[float, float]], \n                        existing_radii: List[float]) -> float:\n    \"\"\"Calculate maximum radius for a circle at given center.\"\"\"\n    x, y = center\n    \n    # Distance to boundaries\n    max_r = min(x, y, 1 - x, 1 - y)\n    \n    # Distance to existing circles\n    for (cx, cy), r in zip(existing_centers, existing_radii):\n        dist = np.sqrt((x - cx)**2 + (y - cy)**2)\n        max_r = min(max_r, dist - r)\n    \n    return max(0, max_r)\n\ndef estimate_future_potential(centers: List[Tuple[float, float]], \n                             radii: List[float], \n                             n_remaining: int) -> float:\n    \"\"\"Estimate potential sum of radii for remaining circles.\"\"\"\n    if n_remaining == 0:\n        return 0\n    \n    # Sample potential positions and estimate average achievable radius\n    n_samples = 50\n    sample_radii = []\n    \n    for _ in range(n_samples):\n        # Random position\n        x, y = np.random.uniform(0.1, 0.9, 2)\n        max_r = calculate_max_radius((x, y), centers, radii)\n        if max_r > 0:\n            sample_radii.append(max_r)\n    \n    if not sample_radii:\n        return 0\n    \n    # Conservative estimate: use median of samples, scaled down\n    avg_radius = np.median(sample_radii) * 0.7\n    return avg_radius * n_remaining\n\ndef generate_candidate_positions(packing: PartialPacking, \n                                n_candidates: int = 20) -> List[Tuple[float, float]]:\n    \"\"\"Generate candidate positions for next circle.\"\"\"\n    candidates = []\n    \n    if len(packing.centers) == 0:\n        # First circle: place at center\n        return [(0.5, 0.5)]\n    \n    # Strategy 1: Near existing circles (tangent positions)\n    for (cx, cy), r in zip(packing.centers, packing.radii):\n        for angle in np.linspace(0, 2*np.pi, 8, endpoint=False):\n            # Try positions at various distances\n            for dist_factor in [1.1, 1.3, 1.5]:\n                offset = r * dist_factor\n                x = cx + offset * np.cos(angle)\n                y = cy + offset * np.sin(angle)\n                if 0 < x < 1 and 0 < y < 1:\n                    candidates.append((x, y))\n    \n    # Strategy 2: Grid-based exploration of empty space\n    grid_size = 15\n    for i in range(grid_size):\n        for j in range(grid_size):\n            x = (i + 0.5) / grid_size\n            y = (j + 0.5) / grid_size\n            candidates.append((x, y))\n    \n    # Strategy 3: Random exploration\n    for _ in range(30):\n        x, y = np.random.uniform(0.05, 0.95, 2)\n        candidates.append((x, y))\n    \n    # Remove duplicates and limit\n    unique_candidates = []\n    seen = set()\n    for c in candidates:\n        key = (round(c[0], 4), round(c[1], 4))\n        if key not in seen:\n            seen.add(key)\n            unique_candidates.append(c)\n    \n    # Score candidates by immediate radius potential\n    scored = []\n    for pos in unique_candidates:\n        max_r = calculate_max_radius(pos, packing.centers, packing.radii)\n        if max_r > 1e-6:  # Only consider valid positions\n            scored.append((max_r, pos))\n    \n    # Return top candidates\n    scored.sort(reverse=True)\n    return [pos for _, pos in scored[:n_candidates]]\n\ndef construct_packing():\n    \"\"\"Main beam search packing algorithm.\"\"\"\n    n_circles = 26\n    beam_width = 10\n    n_candidates = 20\n    \n    # Initialize beam with empty packing\n    beam = [PartialPacking(centers=[], radii=[], sum_radii=0, score=0)]\n    \n    for step in range(n_circles):\n        new_beam = []\n        n_remaining = n_circles - step - 1\n        \n        # Expand each packing in current beam\n        for packing in beam:\n            candidates = generate_candidate_positions(packing, n_candidates)\n            \n            # Create new packings for each candidate\n            for pos in candidates:\n                max_r = calculate_max_radius(pos, packing.centers, packing.radii)\n                \n                if max_r > 1e-6:\n                    # Create new packing\n                    new_centers = packing.centers + [pos]\n                    new_radii = packing.radii + [max_r]\n                    new_sum = packing.sum_radii + max_r\n                    \n                    # Score: immediate gain + estimated future potential\n                    future_potential = estimate_future_potential(\n                        new_centers, new_radii, n_remaining\n                    )\n                    score = new_sum + future_potential\n                    \n                    new_packing = PartialPacking(\n                        centers=new_centers,\n                        radii=new_radii,\n                        sum_radii=new_sum,\n                        score=score\n                    )\n                    new_beam.append(new_packing)\n        \n        # Keep top K packings\n        if len(new_beam) > beam_width:\n            new_beam.sort()\n            beam = new_beam[:beam_width]\n        else:\n            beam = new_beam\n        \n        if not beam:\n            break\n        \n        # Print progress\n        best_score = beam[0].sum_radii\n        print(f\"Step {step + 1}/{n_circles}: Best sum_radii = {best_score:.4f}\")\n    \n    # Return best final packing\n    if not beam:\n        return [], [], 0\n    \n    best = beam[0]\n    return best.centers, best.radii, best.sum_radii\n\ndef run_packing():\n    \"\"\"Entry point for the packing algorithm.\"\"\"\n    print(\"Starting beam search packing algorithm...\")\n    print(f\"Target: Pack 26 circles with sum_radii > 2.1\")\n    print()\n    \n    centers, radii, sum_radii = construct_packing()\n    \n    print()\n    print(\"=\" * 50)\n    print(f\"Final result: {len(radii)} circles packed\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Target achieved: {sum_radii > 2.1}\")\n    print(\"=\" * 50)\n    \n    # Verify packing validity\n    valid = True\n    for i, ((x, y), r) in enumerate(zip(centers, radii)):\n        # Check boundaries\n        if x - r < -1e-6 or x + r > 1 + 1e-6 or y - r < -1e-6 or y + r > 1 + 1e-6:\n            print(f\"Circle {i} violates boundary!\")\n            valid = False\n        \n        # Check overlaps\n        for j in range(i):\n            (x2, y2), r2 = centers[j], radii[j]\n            dist = np.sqrt((x - x2)**2 + (y - y2)**2)\n            if dist < r + r2 - 1e-6:\n                print(f\"Circles {i} and {j} overlap!\")\n                valid = False\n    \n    if valid:\n        print(\"Packing is valid!\")\n    \n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    # Visualize if matplotlib is available\n    try:\n        import matplotlib.pyplot as plt\n        from matplotlib.patches import Circle\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        ax.set_title(f'Beam Search Packing: {len(radii)} circles, sum_radii = {sum_radii:.4f}')\n        \n        for (x, y), r in zip(centers, radii):\n            circle = Circle((x, y), r, fill=False, edgecolor='blue', linewidth=1)\n            ax.add_patch(circle)\n        \n        ax.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('beam_search_packing.png', dpi=150, bbox_inches='tight')\n        print(\"Visualization saved as 'beam_search_packing.png'\")\n        plt.show()\n    except ImportError:\n        print(\"Matplotlib not available for visualization\")\n```\n\nThis implementation features:\n\n1. **Beam Search Strategy**: Maintains top K=10 partial packings and explores N=20 candidates per step\n\n2. **Smart Candidate Generation**:\n   - Tangent positions near existing circles\n   - Grid-based exploration of empty space\n   - Random exploration for diversity\n\n3. **Intelligent Scoring**: Combines immediate radius gain with estimated future potential using Monte Carlo sampling\n\n4. **Progressive Building**: Adds one circle at a time, keeping the most promising packings\n\n5. **Validation**: Checks boundary constraints and circle overlaps\n\nThe algorithm explores multiple promising paths simultaneously, avoiding local optima that greedy approaches might encounter. The beam width of 10 provides a good balance between exploration and computational efficiency.",
  "reasoning": "I'll implement a beam search packing algorithm that explores multiple promising paths simultaneously.\n\nThis implementation features:\n\n1. **Beam Search Strategy**: Maintains top K=10 partial packings and explores N=20 candidates per step\n\n2. **Smart Candidate Generation**:\n   - Tangent positions near existing circles\n   - Grid-based exploration of empty space\n   - Random exploration for diversity\n\n3. **Intelligent Scoring**: Combines immediate radius gain with estimated future potential using Monte Carlo sampling\n\n4. **Progressive Building**: Adds one circle at a time, keeping the most promising packings\n\n5. **Validation**: Checks boundary constraints and circle overlaps\n\nThe algorithm explores multiple promising paths simultaneously, avoiding local optima that greedy approaches might encounter. The beam width of 10 provides a good balance between exploration and computational efficiency.",
  "timestamp": "2025-12-08T15:55:25.506665",
  "cost_data": null
}