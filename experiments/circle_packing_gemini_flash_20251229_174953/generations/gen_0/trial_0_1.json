{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": "gen_0_start",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Finds a packing of 26 circles in a unit square to maximize the sum of radii.\n    Uses a multi-start strategy with SLSQP as requested.\n    \"\"\"\n    n_circles = 26\n    best_sum = 0\n    best_radii = None\n    best_centers = None\n\n    # Constraints for SLSQP\n    # Variables: [r0, ..., r25, x0, y0, ..., x25, y25]\n    def objective(x):\n        return -np.sum(x[:n_circles])\n\n    def constraint_bounds(x):\n        # Circle boundaries: r <= x <= 1-r and r <= y <= 1-r\n        r = x[:n_circles]\n        cx = x[n_circles:2*n_circles]\n        cy = x[2*n_circles:]\n        # Flattened constraints for efficiency\n        c1 = cx - r\n        c2 = (1 - r) - cx\n        c3 = cy - r\n        c4 = (1 - r) - cy\n        return np.concatenate([c1, c2, c3, c4])\n\n    def constraint_overlap(x):\n        r = x[:n_circles]\n        cx = x[n_circles:2*n_circles]\n        cy = x[2*n_circles:]\n        res = []\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist_sq = (cx[i] - cx[j])**2 + (cy[i] - cy[j])**2\n                sum_r = r[i] + r[j]\n                res.append(dist_sq - sum_r**2)\n        return np.array(res)\n\n    cons = [\n        {'type': 'ineq', 'fun': constraint_bounds},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n\n    # Bounds for the variables [radii, centers_x, centers_y]\n    bounds = [(0, 0.5)] * n_circles + [(0, 1)] * (2 * n_circles)\n\n    # Multi-start strategy\n    num_starts = 15\n    for _ in range(num_starts):\n        # Small initial radii as requested\n        init_r = np.full(n_circles, 0.01)\n        init_cx = np.random.uniform(0.1, 0.9, n_circles)\n        init_cy = np.random.uniform(0.1, 0.9, n_circles)\n        x0 = np.concatenate([init_r, init_cx, init_cy])\n\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            bounds=bounds, \n            constraints=cons,\n            options={'maxiter': 100, 'ftol': 1e-6}\n        )\n\n        if res.success:\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_radii = res.x[:n_circles]\n                best_centers = res.x[n_circles:].reshape(2, n_circles).T\n\n    # If SLSQP fails to find a good local optimum in few iterations, \n    # we return the best found or a fallback if none found.\n    # Note: SLSQP on 78 vars is sensitive to initialization.\n    \n    # Ensure values are returned as numpy arrays\n    return np.array(best_centers), np.array(best_radii), best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.607573194463723,
    "eval_time": 5.143057107925415,
    "error": null
  },
  "prompt": "Pack 26 circles in a unit square to maximize the sum of radii. Implement a multi-start strategy: run SLSQP 15 times with different random initial positions and small radii (e.g., 0.01). Return the best configuration found.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Finds a packing of 26 circles in a unit square to maximize the sum of radii.\n    Uses a multi-start strategy with SLSQP as requested.\n    \"\"\"\n    n_circles = 26\n    best_sum = 0\n    best_radii = None\n    best_centers = None\n\n    # Constraints for SLSQP\n    # Variables: [r0, ..., r25, x0, y0, ..., x25, y25]\n    def objective(x):\n        return -np.sum(x[:n_circles])\n\n    def constraint_bounds(x):\n        # Circle boundaries: r <= x <= 1-r and r <= y <= 1-r\n        r = x[:n_circles]\n        cx = x[n_circles:2*n_circles]\n        cy = x[2*n_circles:]\n        # Flattened constraints for efficiency\n        c1 = cx - r\n        c2 = (1 - r) - cx\n        c3 = cy - r\n        c4 = (1 - r) - cy\n        return np.concatenate([c1, c2, c3, c4])\n\n    def constraint_overlap(x):\n        r = x[:n_circles]\n        cx = x[n_circles:2*n_circles]\n        cy = x[2*n_circles:]\n        res = []\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist_sq = (cx[i] - cx[j])**2 + (cy[i] - cy[j])**2\n                sum_r = r[i] + r[j]\n                res.append(dist_sq - sum_r**2)\n        return np.array(res)\n\n    cons = [\n        {'type': 'ineq', 'fun': constraint_bounds},\n        {'type': 'ineq', 'fun': constraint_overlap}\n    ]\n\n    # Bounds for the variables [radii, centers_x, centers_y]\n    bounds = [(0, 0.5)] * n_circles + [(0, 1)] * (2 * n_circles)\n\n    # Multi-start strategy\n    num_starts = 15\n    for _ in range(num_starts):\n        # Small initial radii as requested\n        init_r = np.full(n_circles, 0.01)\n        init_cx = np.random.uniform(0.1, 0.9, n_circles)\n        init_cy = np.random.uniform(0.1, 0.9, n_circles)\n        x0 = np.concatenate([init_r, init_cx, init_cy])\n\n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            bounds=bounds, \n            constraints=cons,\n            options={'maxiter': 100, 'ftol': 1e-6}\n        )\n\n        if res.success:\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_radii = res.x[:n_circles]\n                best_centers = res.x[n_circles:].reshape(2, n_circles).T\n\n    # If SLSQP fails to find a good local optimum in few iterations, \n    # we return the best found or a fallback if none found.\n    # Note: SLSQP on 78 vars is sensitive to initialization.\n    \n    # Ensure values are returned as numpy arrays\n    return np.array(best_centers), np.array(best_radii), best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-29T17:50:46.865917",
  "cost_data": null
}