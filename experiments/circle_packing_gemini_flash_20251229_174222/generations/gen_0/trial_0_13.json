{
  "trial_id": "trial_0_13",
  "generation": 0,
  "parent_id": "gen_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    Strategy: Start with a 5x5 grid, replace one circle with two, \n    and optimize using SLSQP.\n    \"\"\"\n    n = 26\n    # 1. Initial configuration: 5x5 grid (25 circles) + 1 extra\n    # Grid spacing for 5x5\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    centers = []\n    for y in grid_coords:\n        for x in grid_coords:\n            centers.append([x, y])\n    \n    # Add the 26th circle near the center to create a \"seed\" for optimization\n    centers.append([0.52, 0.52])\n    centers = np.array(centers)\n    \n    # Initial radii guess\n    radii = np.full(n, 1.0 / (2 * 5.1)) # Slightly smaller than grid radius\n    \n    # Flatten for optimizer: [x1, y1, ..., xn, yn, r1, ..., rn]\n    initial_guess = np.concatenate([centers.flatten(), radii])\n\n    def objective(vars):\n        # Maximize sum of radii = Minimize -sum(radii)\n        return -np.sum(vars[2*n:])\n\n    def constraints(vars):\n        c = vars[:2*n].reshape((n, 2))\n        r = vars[2*n:]\n        cons = []\n        \n        # Boundary constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])          # x - r >= 0\n            cons.append(1.0 - c[i, 0] - r[i])    # x + r <= 1\n            cons.append(c[i, 1] - r[i])          # y - r >= 0\n            cons.append(1.0 - c[i, 1] - r[i])    # y + r <= 1\n            \n        # Non-overlapping constraints: dist(ci, cj) >= ri + rj\n        # To speed up, we use squared distances: dist^2 >= (ri + rj)^2\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_sq = np.sum((c[i] - c[j])**2)\n                cons.append(dist_sq - (r[i] + r[j])**2)\n        \n        return np.array(cons)\n\n    # Bounds for each variable\n    # x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    # Optimization using SLSQP\n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP', \n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 100, 'ftol': 1e-7}\n    )\n\n    # Extract results\n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    total_sum = np.sum(final_radii)\n\n    # Note: SLSQP on 26 circles is high-dimensional. \n    # To reach exactly 2.6359, multiple restarts or a basin-hopping approach \n    # is usually needed. This provides the framework and a strong local optimum.\n    \n    return final_centers, final_radii, total_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5828422597592,
    "eval_time": 0.8052060604095459,
    "error": null
  },
  "prompt": "Start with a 5x5 grid of circles. Remove one circle to create space, then attempt to place two circles in the resulting gap. Use SLSQP to optimize the positions and radii of all 26 circles to maximize their sum.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    Strategy: Start with a 5x5 grid, replace one circle with two, \n    and optimize using SLSQP.\n    \"\"\"\n    n = 26\n    # 1. Initial configuration: 5x5 grid (25 circles) + 1 extra\n    # Grid spacing for 5x5\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    centers = []\n    for y in grid_coords:\n        for x in grid_coords:\n            centers.append([x, y])\n    \n    # Add the 26th circle near the center to create a \"seed\" for optimization\n    centers.append([0.52, 0.52])\n    centers = np.array(centers)\n    \n    # Initial radii guess\n    radii = np.full(n, 1.0 / (2 * 5.1)) # Slightly smaller than grid radius\n    \n    # Flatten for optimizer: [x1, y1, ..., xn, yn, r1, ..., rn]\n    initial_guess = np.concatenate([centers.flatten(), radii])\n\n    def objective(vars):\n        # Maximize sum of radii = Minimize -sum(radii)\n        return -np.sum(vars[2*n:])\n\n    def constraints(vars):\n        c = vars[:2*n].reshape((n, 2))\n        r = vars[2*n:]\n        cons = []\n        \n        # Boundary constraints: r_i <= x_i <= 1-r_i and r_i <= y_i <= 1-r_i\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])          # x - r >= 0\n            cons.append(1.0 - c[i, 0] - r[i])    # x + r <= 1\n            cons.append(c[i, 1] - r[i])          # y - r >= 0\n            cons.append(1.0 - c[i, 1] - r[i])    # y + r <= 1\n            \n        # Non-overlapping constraints: dist(ci, cj) >= ri + rj\n        # To speed up, we use squared distances: dist^2 >= (ri + rj)^2\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_sq = np.sum((c[i] - c[j])**2)\n                cons.append(dist_sq - (r[i] + r[j])**2)\n        \n        return np.array(cons)\n\n    # Bounds for each variable\n    # x, y in [0, 1], r in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n\n    # Optimization using SLSQP\n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP', \n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 100, 'ftol': 1e-7}\n    )\n\n    # Extract results\n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    total_sum = np.sum(final_radii)\n\n    # Note: SLSQP on 26 circles is high-dimensional. \n    # To reach exactly 2.6359, multiple restarts or a basin-hopping approach \n    # is usually needed. This provides the framework and a strong local optimum.\n    \n    return final_centers, final_radii, total_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-29T17:43:36.916821",
  "cost_data": null
}