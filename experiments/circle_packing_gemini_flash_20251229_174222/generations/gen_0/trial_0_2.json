{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": "gen_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Solves the problem of packing 26 circles into a [0,1]x[0,1] square\n    to maximize the sum of radii using multi-start SLSQP.\n    \"\"\"\n    n_circles = 26\n    n_starts = 40\n    best_sum = -1\n    best_res = None\n\n    # Objective function: maximize sum(radii) -> minimize -sum(radii)\n    def objective(x):\n        return -np.sum(x[2 * n_circles:])\n\n    # Constraints\n    def constraints_func(x):\n        centers = x[:2 * n_circles].reshape((n_circles, 2))\n        radii = x[2 * n_circles:]\n        cons = []\n        \n        # 1. Non-overlapping constraints: dist(ci, cj) >= ri + rj\n        # Formulated as dist^2 - (ri + rj)^2 >= 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist_sq = np.sum((centers[i] - centers[j])**2)\n                r_sum_sq = (radii[i] + radii[j])**2\n                cons.append(dist_sq - r_sum_sq)\n        \n        # 2. Boundary constraints: ri <= xi <= 1-ri and ri <= yi <= 1-ri\n        # Formulated as xi - ri >= 0, 1 - ri - xi >= 0, etc.\n        for i in range(n_circles):\n            cons.append(centers[i, 0] - radii[i])\n            cons.append(1.0 - centers[i, 0] - radii[i])\n            cons.append(centers[i, 1] - radii[i])\n            cons.append(1.0 - centers[i, 1] - radii[i])\n            \n        return np.array(cons)\n\n    # Optimization bounds: centers in [0,1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n    \n    # Nonlinear constraints dictionary for SLSQP\n    cons = {'type': 'ineq', 'fun': constraints_func}\n\n    for _ in range(n_starts):\n        # Initial guess: random centers, small random radii\n        init_centers = np.random.rand(2 * n_circles)\n        init_radii = np.random.rand(n_circles) * 0.05\n        x0 = np.concatenate([init_centers, init_radii])\n        \n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            bounds=bounds, \n            constraints=cons,\n            options={'maxiter': 100, 'ftol': 1e-6}\n        )\n        \n        if res.success or res.fun < 0:\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_res = res.x\n\n    # Final extraction\n    centers = best_res[:2 * n_circles].reshape((n_circles, 2))\n    radii = best_res[2 * n_circles:]\n    \n    return centers, radii, best_sum\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 39.91774797439575,
    "error": "Circle 1 at (0.0, 0.0) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "Implement a multi-start optimization approach for packing 26 circles. Generate 40 random initial configurations of 26 circles. For each configuration, use scipy.optimize.minimize (SLSQP) to find a local maximum for the sum of radii. Return the best configuration found among all trials.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Solves the problem of packing 26 circles into a [0,1]x[0,1] square\n    to maximize the sum of radii using multi-start SLSQP.\n    \"\"\"\n    n_circles = 26\n    n_starts = 40\n    best_sum = -1\n    best_res = None\n\n    # Objective function: maximize sum(radii) -> minimize -sum(radii)\n    def objective(x):\n        return -np.sum(x[2 * n_circles:])\n\n    # Constraints\n    def constraints_func(x):\n        centers = x[:2 * n_circles].reshape((n_circles, 2))\n        radii = x[2 * n_circles:]\n        cons = []\n        \n        # 1. Non-overlapping constraints: dist(ci, cj) >= ri + rj\n        # Formulated as dist^2 - (ri + rj)^2 >= 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist_sq = np.sum((centers[i] - centers[j])**2)\n                r_sum_sq = (radii[i] + radii[j])**2\n                cons.append(dist_sq - r_sum_sq)\n        \n        # 2. Boundary constraints: ri <= xi <= 1-ri and ri <= yi <= 1-ri\n        # Formulated as xi - ri >= 0, 1 - ri - xi >= 0, etc.\n        for i in range(n_circles):\n            cons.append(centers[i, 0] - radii[i])\n            cons.append(1.0 - centers[i, 0] - radii[i])\n            cons.append(centers[i, 1] - radii[i])\n            cons.append(1.0 - centers[i, 1] - radii[i])\n            \n        return np.array(cons)\n\n    # Optimization bounds: centers in [0,1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n    \n    # Nonlinear constraints dictionary for SLSQP\n    cons = {'type': 'ineq', 'fun': constraints_func}\n\n    for _ in range(n_starts):\n        # Initial guess: random centers, small random radii\n        init_centers = np.random.rand(2 * n_circles)\n        init_radii = np.random.rand(n_circles) * 0.05\n        x0 = np.concatenate([init_centers, init_radii])\n        \n        res = minimize(\n            objective, \n            x0, \n            method='SLSQP', \n            bounds=bounds, \n            constraints=cons,\n            options={'maxiter': 100, 'ftol': 1e-6}\n        )\n        \n        if res.success or res.fun < 0:\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_res = res.x\n\n    # Final extraction\n    centers = best_res[:2 * n_circles].reshape((n_circles, 2))\n    radii = best_res[2 * n_circles:]\n    \n    return centers, radii, best_sum\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-29T17:44:07.799816",
  "cost_data": null
}