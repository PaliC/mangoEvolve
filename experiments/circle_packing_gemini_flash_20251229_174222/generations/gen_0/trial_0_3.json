{
  "trial_id": "trial_0_3",
  "generation": 0,
  "parent_id": "gen_0",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n_circles = 26\n    # Initial greedy placement\n    centers = []\n    radii = []\n    \n    # Grid sampling for greedy placement\n    sample_res = 40\n    grid_x, grid_y = np.meshgrid(np.linspace(0, 1, sample_res), np.linspace(0, 1, sample_res))\n    samples = np.vstack([grid_x.ravel(), grid_y.ravel()]).T\n\n    for i in range(n_circles):\n        best_r = -1\n        best_pos = np.array([0.5, 0.5])\n        \n        for pos in samples:\n            # Distance to boundaries\n            r_bound = min(pos[0], 1 - pos[0], pos[1], 1 - pos[1])\n            if r_bound <= 0: continue\n            \n            # Distance to existing circles\n            r_overlap = float('inf')\n            for j in range(len(centers)):\n                dist = np.linalg.norm(pos - centers[j])\n                r_overlap = min(r_overlap, dist - radii[j])\n            \n            current_r = min(r_bound, r_overlap)\n            if current_r > best_r:\n                best_r = current_r\n                best_pos = pos\n        \n        centers.append(best_pos)\n        radii.append(max(0.001, best_r))\n\n    # Optimization using SLSQP\n    # x = [x0, y0, ..., x25, y25, r0, ..., r25]\n    x0 = np.concatenate([np.array(centers).flatten(), np.array(radii)])\n    \n    def objective(x):\n        # Maximize sum of radii -> minimize negative sum\n        return -np.sum(x[2*n_circles:])\n\n    constraints = []\n    # Boundary constraints: x_i - r_i >= 0 => x_i - r_i >= 0\n    # Boundary constraints: x_i + r_i <= 1 => 1 - (x_i + r_i) >= 0\n    for i in range(n_circles):\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i] - x[2*n_circles + i]})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1.0 - (x[2*i] + x[2*n_circles + i])})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n_circles + i]})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1.0 - (x[2*i+1] + x[2*n_circles + i])})\n\n    # Non-overlap constraints: dist(c_i, c_j) >= r_i + r_j\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            def overlap_const(x, i=i, j=j):\n                dist = np.sqrt((x[2*i] - x[2*j])**2 + (x[2*i+1] - x[2*j+1])**2)\n                return dist - (x[2*n_circles + i] + x[2*n_circles + j])\n            constraints.append({'type': 'ineq', 'fun': overlap_const})\n\n    # Variable bounds\n    bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n\n    res = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints, \n                   options={'maxiter': 100, 'ftol': 1e-7})\n\n    final_centers = res.x[:2*n_circles].reshape((n_circles, 2))\n    final_radii = res.x[2*n_circles:]\n    sum_radii = np.sum(final_radii)\n\n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5095657320567866,
    "eval_time": 2.5250000953674316,
    "error": null
  },
  "prompt": "Implement a greedy insertion strategy for circle packing. Start with an empty unit square. Iteratively add 26 circles. For each circle, sample many potential center points and pick the one that allows the largest radius without overlapping existing circles or boundaries. After placing 26, use SLSQP to optimize all centers and radii simultaneously.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n_circles = 26\n    # Initial greedy placement\n    centers = []\n    radii = []\n    \n    # Grid sampling for greedy placement\n    sample_res = 40\n    grid_x, grid_y = np.meshgrid(np.linspace(0, 1, sample_res), np.linspace(0, 1, sample_res))\n    samples = np.vstack([grid_x.ravel(), grid_y.ravel()]).T\n\n    for i in range(n_circles):\n        best_r = -1\n        best_pos = np.array([0.5, 0.5])\n        \n        for pos in samples:\n            # Distance to boundaries\n            r_bound = min(pos[0], 1 - pos[0], pos[1], 1 - pos[1])\n            if r_bound <= 0: continue\n            \n            # Distance to existing circles\n            r_overlap = float('inf')\n            for j in range(len(centers)):\n                dist = np.linalg.norm(pos - centers[j])\n                r_overlap = min(r_overlap, dist - radii[j])\n            \n            current_r = min(r_bound, r_overlap)\n            if current_r > best_r:\n                best_r = current_r\n                best_pos = pos\n        \n        centers.append(best_pos)\n        radii.append(max(0.001, best_r))\n\n    # Optimization using SLSQP\n    # x = [x0, y0, ..., x25, y25, r0, ..., r25]\n    x0 = np.concatenate([np.array(centers).flatten(), np.array(radii)])\n    \n    def objective(x):\n        # Maximize sum of radii -> minimize negative sum\n        return -np.sum(x[2*n_circles:])\n\n    constraints = []\n    # Boundary constraints: x_i - r_i >= 0 => x_i - r_i >= 0\n    # Boundary constraints: x_i + r_i <= 1 => 1 - (x_i + r_i) >= 0\n    for i in range(n_circles):\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i] - x[2*n_circles + i]})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1.0 - (x[2*i] + x[2*n_circles + i])})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n_circles + i]})\n        constraints.append({'type': 'ineq', 'fun': lambda x, i=i: 1.0 - (x[2*i+1] + x[2*n_circles + i])})\n\n    # Non-overlap constraints: dist(c_i, c_j) >= r_i + r_j\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            def overlap_const(x, i=i, j=j):\n                dist = np.sqrt((x[2*i] - x[2*j])**2 + (x[2*i+1] - x[2*j+1])**2)\n                return dist - (x[2*n_circles + i] + x[2*n_circles + j])\n            constraints.append({'type': 'ineq', 'fun': overlap_const})\n\n    # Variable bounds\n    bounds = [(0, 1)] * (2 * n_circles) + [(0, 0.5)] * n_circles\n\n    res = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints, \n                   options={'maxiter': 100, 'ftol': 1e-7})\n\n    final_centers = res.x[:2*n_circles].reshape((n_circles, 2))\n    final_radii = res.x[2*n_circles:]\n    sum_radii = np.sum(final_radii)\n\n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-29T17:43:31.740355",
  "cost_data": null
}