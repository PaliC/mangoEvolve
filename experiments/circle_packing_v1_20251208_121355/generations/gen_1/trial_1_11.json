{
  "trial_id": "trial_1_11",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing using density-based approach.\n    \n    Returns:\n        tuple: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    np.random.seed(42)\n    \n    # Initialize 26 circles\n    n_circles = 26\n    \n    # Create initial grid-based positions with some randomness\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = np.zeros((n_circles, 2))\n    radii = np.ones(n_circles) * 0.1\n    \n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx < n_circles:\n                centers[idx] = [i / grid_size * 10, j / grid_size * 10]\n                idx += 1\n    \n    # Add random perturbation\n    centers += np.random.normal(0, 0.3, centers.shape)\n    \n    return centers, radii, float(np.sum(radii))\n\n\ndef run_packing():\n    \"\"\"\n    Run iterative circle packing optimization using density-based approach.\n    \n    Returns:\n        tuple: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    \n    # Initialize centers in grid pattern with perturbation\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = np.zeros((n_circles, 2))\n    \n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx < n_circles:\n                centers[idx] = [i / grid_size * 8, j / grid_size * 8]\n                idx += 1\n    \n    centers += np.random.normal(0, 0.2, centers.shape)\n    \n    # Initialize radii\n    radii = np.ones(n_circles) * 0.15\n    \n    # Optimization parameters\n    max_iterations = 100\n    learning_rate = 0.05\n    \n    # Bounding box\n    bounds = np.array([[0, 10], [0, 10]])\n    \n    for iteration in range(max_iterations):\n        # Calculate pairwise distances\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        # Identify high-density regions (where circles are close)\n        min_distances = np.min(distances, axis=1)\n        density = 1.0 / (min_distances + 0.1)\n        \n        # Normalize density\n        density = (density - density.min()) / (density.max() - density.min() + 1e-6)\n        \n        # Update radii based on density (higher density = smaller radius)\n        target_radii = 0.05 + (1.0 - density) * 0.2\n        radii = 0.9 * radii + 0.1 * target_radii\n        \n        # Repulsion forces between circles\n        for i in range(n_circles):\n            force = np.zeros(2)\n            \n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff) + 1e-6\n                    min_dist = radii[i] + radii[j]\n                    \n                    # Repulsion if overlapping\n                    if dist < min_dist:\n                        direction = diff / dist\n                        overlap = min_dist - dist\n                        force += direction * overlap * 0.5\n                    else:\n                        # Weak repulsion based on density\n                        direction = diff / dist\n                        force += direction * (1.0 - dist / 5.0) * 0.1\n            \n            # Apply force with boundary constraints\n            centers[i] += force * learning_rate\n            centers[i] = np.clip(centers[i], bounds[:, 0], bounds[:, 1])\n        \n        # Attraction to high-density regions (cluster centers)\n        if iteration % 10 == 0:\n            # Find natural clusters\n            density_threshold = np.percentile(density, 30)\n            cluster_mask = density > density_threshold\n            \n            if np.sum(cluster_mask) > 0:\n                cluster_center = np.mean(centers[cluster_mask], axis=0)\n                \n                for i in range(n_circles):\n                    direction = cluster_center - centers[i]\n                    dist = np.linalg.norm(direction) + 1e-6\n                    if dist > 0.1:\n                        direction = direction / dist\n                        centers[i] += direction * learning_rate * 0.1\n                        centers[i] = np.clip(centers[i], bounds[:, 0], bounds[:, 1])\n        \n        # Decay learning rate\n        if iteration % 20 == 0:\n            learning_rate *= 0.95\n    \n    # Final optimization: maximize total radius while avoiding overlaps\n    def objective(x):\n        c = x[:n_circles*2].reshape(n_circles, 2)\n        r = np.abs(x[n_circles*2:])\n        \n        # Penalty for overlaps\n        distances = cdist(c, c)\n        np.fill_diagonal(distances, np.inf)\n        \n        overlap_penalty = 0\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                min_dist = r[i] + r[j]\n                if distances[i, j] < min_dist:\n                    overlap_penalty += (min_dist - distances[i, j]) ** 2\n        \n        # Boundary penalty\n        boundary_penalty = np.sum(np.maximum(0, c[:, 0] - bounds[0, 1])) + \\\n                          np.sum(np.maximum(0, bounds[0, 0] - c[:, 0])) + \\\n                          np.sum(np.maximum(0, c[:, 1] - bounds[1, 1])) + \\\n                          np.sum(np.maximum(0, bounds[1, 0] - c[:, 1]))\n        \n        # Objective: maximize sum of radii (minimize negative sum)\n        return -np.sum(r) + overlap_penalty * 100 + boundary_penalty * 10\n    \n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    result = minimize(objective, x0, method='L-BFGS-B', \n                     options={'maxiter': 50, 'ftol': 1e-4})\n    \n    x_opt = result.x\n    centers = x_opt[:n_circles*2].reshape(n_circles, 2)\n    radii = np.abs(x_opt[n_circles*2:])\n    \n    # Ensure circles stay in bounds\n    centers = np.clip(centers, bounds[:, 0], bounds[:, 1])\n    \n    # Ensure minimum radius\n    radii = np.maximum(radii, 0.02)\n    \n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.9043881893157959,
    "error": "Circle 0 at (0.001558861745435755, 0.012863944900852695) with radius 0.6823144849265984 extends outside x-bounds"
  },
  "prompt": "Write COMPLETE Python code for circle packing.\n\nCode block ONLY. Functions: construct_packing(), run_packing().\nReturns: (centers (26,2), radii (26,), sum_radii float).\n\nSTRATEGY: Density-based approach\n- Identify high-density regions\n- Place circles at optimal density locations\n- Iteratively optimize positions and radii",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing using density-based approach.\n    \n    Returns:\n        tuple: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    np.random.seed(42)\n    \n    # Initialize 26 circles\n    n_circles = 26\n    \n    # Create initial grid-based positions with some randomness\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = np.zeros((n_circles, 2))\n    radii = np.ones(n_circles) * 0.1\n    \n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx < n_circles:\n                centers[idx] = [i / grid_size * 10, j / grid_size * 10]\n                idx += 1\n    \n    # Add random perturbation\n    centers += np.random.normal(0, 0.3, centers.shape)\n    \n    return centers, radii, float(np.sum(radii))\n\n\ndef run_packing():\n    \"\"\"\n    Run iterative circle packing optimization using density-based approach.\n    \n    Returns:\n        tuple: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    \n    # Initialize centers in grid pattern with perturbation\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = np.zeros((n_circles, 2))\n    \n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx < n_circles:\n                centers[idx] = [i / grid_size * 8, j / grid_size * 8]\n                idx += 1\n    \n    centers += np.random.normal(0, 0.2, centers.shape)\n    \n    # Initialize radii\n    radii = np.ones(n_circles) * 0.15\n    \n    # Optimization parameters\n    max_iterations = 100\n    learning_rate = 0.05\n    \n    # Bounding box\n    bounds = np.array([[0, 10], [0, 10]])\n    \n    for iteration in range(max_iterations):\n        # Calculate pairwise distances\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        # Identify high-density regions (where circles are close)\n        min_distances = np.min(distances, axis=1)\n        density = 1.0 / (min_distances + 0.1)\n        \n        # Normalize density\n        density = (density - density.min()) / (density.max() - density.min() + 1e-6)\n        \n        # Update radii based on density (higher density = smaller radius)\n        target_radii = 0.05 + (1.0 - density) * 0.2\n        radii = 0.9 * radii + 0.1 * target_radii\n        \n        # Repulsion forces between circles\n        for i in range(n_circles):\n            force = np.zeros(2)\n            \n            for j in range(n_circles):\n                if i != j:\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff) + 1e-6\n                    min_dist = radii[i] + radii[j]\n                    \n                    # Repulsion if overlapping\n                    if dist < min_dist:\n                        direction = diff / dist\n                        overlap = min_dist - dist\n                        force += direction * overlap * 0.5\n                    else:\n                        # Weak repulsion based on density\n                        direction = diff / dist\n                        force += direction * (1.0 - dist / 5.0) * 0.1\n            \n            # Apply force with boundary constraints\n            centers[i] += force * learning_rate\n            centers[i] = np.clip(centers[i], bounds[:, 0], bounds[:, 1])\n        \n        # Attraction to high-density regions (cluster centers)\n        if iteration % 10 == 0:\n            # Find natural clusters\n            density_threshold = np.percentile(density, 30)\n            cluster_mask = density > density_threshold\n            \n            if np.sum(cluster_mask) > 0:\n                cluster_center = np.mean(centers[cluster_mask], axis=0)\n                \n                for i in range(n_circles):\n                    direction = cluster_center - centers[i]\n                    dist = np.linalg.norm(direction) + 1e-6\n                    if dist > 0.1:\n                        direction = direction / dist\n                        centers[i] += direction * learning_rate * 0.1\n                        centers[i] = np.clip(centers[i], bounds[:, 0], bounds[:, 1])\n        \n        # Decay learning rate\n        if iteration % 20 == 0:\n            learning_rate *= 0.95\n    \n    # Final optimization: maximize total radius while avoiding overlaps\n    def objective(x):\n        c = x[:n_circles*2].reshape(n_circles, 2)\n        r = np.abs(x[n_circles*2:])\n        \n        # Penalty for overlaps\n        distances = cdist(c, c)\n        np.fill_diagonal(distances, np.inf)\n        \n        overlap_penalty = 0\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                min_dist = r[i] + r[j]\n                if distances[i, j] < min_dist:\n                    overlap_penalty += (min_dist - distances[i, j]) ** 2\n        \n        # Boundary penalty\n        boundary_penalty = np.sum(np.maximum(0, c[:, 0] - bounds[0, 1])) + \\\n                          np.sum(np.maximum(0, bounds[0, 0] - c[:, 0])) + \\\n                          np.sum(np.maximum(0, c[:, 1] - bounds[1, 1])) + \\\n                          np.sum(np.maximum(0, bounds[1, 0] - c[:, 1]))\n        \n        # Objective: maximize sum of radii (minimize negative sum)\n        return -np.sum(r) + overlap_penalty * 100 + boundary_penalty * 10\n    \n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    result = minimize(objective, x0, method='L-BFGS-B', \n                     options={'maxiter': 50, 'ftol': 1e-4})\n    \n    x_opt = result.x\n    centers = x_opt[:n_circles*2].reshape(n_circles, 2)\n    radii = np.abs(x_opt[n_circles*2:])\n    \n    # Ensure circles stay in bounds\n    centers = np.clip(centers, bounds[:, 0], bounds[:, 1])\n    \n    # Ensure minimum radius\n    radii = np.maximum(radii, 0.02)\n    \n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T12:16:33.610956",
  "cost_data": null
}