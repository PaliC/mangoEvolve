{
  "trial_id": "trial_1_13",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing using hybrid grid + local search strategy.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle centers\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize with grid-based placement\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = np.zeros((n_circles, 2))\n    \n    # Create initial grid configuration\n    spacing = 2.0\n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx < n_circles:\n                centers[idx] = np.array([i * spacing, j * spacing])\n                idx += 1\n    \n    # Initialize radii - start small\n    radii = np.ones(n_circles) * 0.3\n    \n    # Iteratively optimize positions and expand radii\n    for iteration in range(50):\n        # Optimize positions using local search\n        centers = optimize_positions(centers, radii)\n        \n        # Expand radii while maintaining no overlaps\n        radii = expand_radii(centers, radii)\n    \n    # Final position optimization\n    centers = optimize_positions(centers, radii)\n    \n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\n\ndef optimize_positions(centers, radii):\n    \"\"\"\n    Optimize circle positions to maximize packing efficiency.\n    Uses hill climbing with local search.\n    \"\"\"\n    n_circles = len(centers)\n    centers = centers.copy()\n    \n    for iteration in range(20):\n        improved = False\n        \n        for i in range(n_circles):\n            # Try moving each circle\n            best_centers = centers.copy()\n            best_score = calculate_score(centers, radii)\n            \n            # Random perturbations\n            for _ in range(10):\n                test_centers = centers.copy()\n                perturbation = np.random.randn(2) * 0.1\n                test_centers[i] += perturbation\n                \n                # Check validity\n                if is_valid_config(test_centers, radii):\n                    test_score = calculate_score(test_centers, radii)\n                    if test_score > best_score:\n                        best_score = test_score\n                        best_centers = test_centers.copy()\n                        improved = True\n            \n            centers = best_centers\n        \n        if not improved:\n            break\n    \n    return centers\n\n\ndef expand_radii(centers, radii):\n    \"\"\"\n    Expand radii while maintaining no overlaps between circles.\n    \"\"\"\n    radii = radii.copy()\n    n_circles = len(centers)\n    \n    for i in range(n_circles):\n        # Find maximum radius without overlap\n        max_radius = radii[i]\n        \n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_possible = dist - radii[j]\n                max_radius = min(max_radius, max_possible)\n        \n        # Expand radius with safety margin\n        max_radius = max(max_radius * 0.95, radii[i])\n        radii[i] = max_radius\n    \n    return radii\n\n\ndef is_valid_config(centers, radii):\n    \"\"\"\n    Check if configuration is valid (no overlaps, circles in bounds).\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check for overlaps\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist - 1e-6:\n                return False\n    \n    # Check bounds\n    for i in range(n_circles):\n        if centers[i, 0] - radii[i] < -10 or centers[i, 0] + radii[i] > 10:\n            return False\n        if centers[i, 1] - radii[i] < -10 or centers[i, 1] + radii[i] > 10:\n            return False\n    \n    return True\n\n\ndef calculate_score(centers, radii):\n    \"\"\"\n    Calculate packing score (sum of radii, penalized for overlaps).\n    \"\"\"\n    score = np.sum(radii)\n    n_circles = len(centers)\n    \n    # Penalty for overlaps\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist:\n                score -= (min_dist - dist) ** 2\n    \n    return score\n\n\ndef run_packing():\n    \"\"\"\n    Run the circle packing algorithm and return results.\n    \n    Returns:\n        tuple: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    \n    # Visualization\n    fig, ax = plt.subplots(figsize=(10, 10))\n    \n    for i in range(len(centers)):\n        circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n        ax.add_patch(circle)\n    \n    ax.scatter(centers[:, 0], centers[:, 1], c='red', s=10)\n    ax.set_xlim(-12, 12)\n    ax.set_ylim(-12, 12)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing (26 circles, sum_radii={sum_radii:.4f})')\n    plt.show()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 7.1316070556640625,
    "error": "Circle 0 at (0.0, 0.0) with radius 0.3 extends outside x-bounds"
  },
  "prompt": "Write COMPLETE Python code for circle packing.\n\nCode block ONLY. Functions: construct_packing(), run_packing().\nReturns: (centers (26,2), radii (26,), sum_radii float).\n\nSTRATEGY: Hybrid grid + local search\n- Start with optimal grid configuration\n- Use hill climbing for position optimization\n- Expand radii iteratively",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing using hybrid grid + local search strategy.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle centers\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize with grid-based placement\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = np.zeros((n_circles, 2))\n    \n    # Create initial grid configuration\n    spacing = 2.0\n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx < n_circles:\n                centers[idx] = np.array([i * spacing, j * spacing])\n                idx += 1\n    \n    # Initialize radii - start small\n    radii = np.ones(n_circles) * 0.3\n    \n    # Iteratively optimize positions and expand radii\n    for iteration in range(50):\n        # Optimize positions using local search\n        centers = optimize_positions(centers, radii)\n        \n        # Expand radii while maintaining no overlaps\n        radii = expand_radii(centers, radii)\n    \n    # Final position optimization\n    centers = optimize_positions(centers, radii)\n    \n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\n\ndef optimize_positions(centers, radii):\n    \"\"\"\n    Optimize circle positions to maximize packing efficiency.\n    Uses hill climbing with local search.\n    \"\"\"\n    n_circles = len(centers)\n    centers = centers.copy()\n    \n    for iteration in range(20):\n        improved = False\n        \n        for i in range(n_circles):\n            # Try moving each circle\n            best_centers = centers.copy()\n            best_score = calculate_score(centers, radii)\n            \n            # Random perturbations\n            for _ in range(10):\n                test_centers = centers.copy()\n                perturbation = np.random.randn(2) * 0.1\n                test_centers[i] += perturbation\n                \n                # Check validity\n                if is_valid_config(test_centers, radii):\n                    test_score = calculate_score(test_centers, radii)\n                    if test_score > best_score:\n                        best_score = test_score\n                        best_centers = test_centers.copy()\n                        improved = True\n            \n            centers = best_centers\n        \n        if not improved:\n            break\n    \n    return centers\n\n\ndef expand_radii(centers, radii):\n    \"\"\"\n    Expand radii while maintaining no overlaps between circles.\n    \"\"\"\n    radii = radii.copy()\n    n_circles = len(centers)\n    \n    for i in range(n_circles):\n        # Find maximum radius without overlap\n        max_radius = radii[i]\n        \n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_possible = dist - radii[j]\n                max_radius = min(max_radius, max_possible)\n        \n        # Expand radius with safety margin\n        max_radius = max(max_radius * 0.95, radii[i])\n        radii[i] = max_radius\n    \n    return radii\n\n\ndef is_valid_config(centers, radii):\n    \"\"\"\n    Check if configuration is valid (no overlaps, circles in bounds).\n    \"\"\"\n    n_circles = len(centers)\n    \n    # Check for overlaps\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist - 1e-6:\n                return False\n    \n    # Check bounds\n    for i in range(n_circles):\n        if centers[i, 0] - radii[i] < -10 or centers[i, 0] + radii[i] > 10:\n            return False\n        if centers[i, 1] - radii[i] < -10 or centers[i, 1] + radii[i] > 10:\n            return False\n    \n    return True\n\n\ndef calculate_score(centers, radii):\n    \"\"\"\n    Calculate packing score (sum of radii, penalized for overlaps).\n    \"\"\"\n    score = np.sum(radii)\n    n_circles = len(centers)\n    \n    # Penalty for overlaps\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist:\n                score -= (min_dist - dist) ** 2\n    \n    return score\n\n\ndef run_packing():\n    \"\"\"\n    Run the circle packing algorithm and return results.\n    \n    Returns:\n        tuple: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    \n    # Visualization\n    fig, ax = plt.subplots(figsize=(10, 10))\n    \n    for i in range(len(centers)):\n        circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n        ax.add_patch(circle)\n    \n    ax.scatter(centers[:, 0], centers[:, 1], c='red', s=10)\n    ax.set_xlim(-12, 12)\n    ax.set_ylim(-12, 12)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing (26 circles, sum_radii={sum_radii:.4f})')\n    plt.show()\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T12:16:40.175957",
  "cost_data": null
}