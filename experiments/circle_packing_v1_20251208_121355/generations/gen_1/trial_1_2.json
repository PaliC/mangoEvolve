{
  "trial_id": "trial_1_2",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Circle packing algorithm using random placement with local optimization.\n    Returns (centers, radii, sum_radii) for 26 circles.\n    \"\"\"\n    np.random.seed(42)\n    n_circles = 26\n    \n    # Initialize random centers in [0, 1] x [0, 1]\n    centers = np.random.uniform(0, 1, (n_circles, 2))\n    radii = np.full(n_circles, 0.02)\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n        r = x[n_circles*2:]\n        return -np.sum(r)\n    \n    def constraint_overlap(x):\n        \"\"\"Constraint: circles should not overlap\"\"\"\n        c = x[:n_circles*2].reshape(n_circles, 2)\n        r = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(c[i] - c[j])\n                # Distance between centers must be >= sum of radii\n                constraints.append(dist - (r[i] + r[j]))\n        \n        return np.array(constraints) if constraints else np.array([1.0])\n    \n    def constraint_bounds(x):\n        \"\"\"Constraint: circles should stay within [0,1]x[0,1]\"\"\"\n        c = x[:n_circles*2].reshape(n_circles, 2)\n        r = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            constraints.append(c[i, 0] - r[i])  # x - r >= 0\n            constraints.append(1 - c[i, 0] - r[i])  # x + r <= 1\n            constraints.append(c[i, 1] - r[i])  # y - r >= 0\n            constraints.append(1 - c[i, 1] - r[i])  # y + r <= 1\n        \n        return np.array(constraints)\n    \n    # Initial state vector: [x1, y1, x2, y2, ..., r1, r2, ...]\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for optimization\n    bounds = [(0, 1) for _ in range(n_circles*2)] + [(0.001, 0.3) for _ in range(n_circles)]\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_overlap},\n        {'type': 'ineq', 'fun': constraint_bounds}\n    ]\n    \n    # Local optimization\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 500, 'ftol': 1e-6}\n    )\n    \n    # Extract optimized centers and radii\n    x_opt = result.x\n    centers = x_opt[:n_circles*2].reshape(n_circles, 2)\n    radii = x_opt[n_circles*2:]\n    \n    # Ensure radii are positive\n    radii = np.maximum(radii, 0.001)\n    \n    # Clip centers to valid range\n    centers = np.clip(centers, 0, 1)\n    \n    # Adjust radii to respect boundaries\n    for i in range(n_circles):\n        max_r = min(\n            centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 0],\n            1 - centers[i, 1]\n        )\n        radii[i] = min(radii[i], max_r)\n    \n    # Check and resolve overlaps\n    for iteration in range(10):\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist and dist > 1e-6:\n                    # Separate circles\n                    direction = (centers[j] - centers[i]) / dist\n                    overlap = min_dist - dist\n                    centers[i] -= direction * overlap * 0.5\n                    centers[j] += direction * overlap * 0.5\n                    \n                    # Clip back to bounds\n                    centers[i] = np.clip(centers[i], 0, 1)\n                    centers[j] = np.clip(centers[j], 0, 1)\n    \n    # Final radius adjustment for boundary compliance\n    for i in range(n_circles):\n        max_r = min(\n            centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 0],\n            1 - centers[i, 1]\n        )\n        radii[i] = min(radii[i], max(max_r, 0.001))\n    \n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"Execute circle packing and return results.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Circle Packing Results:\")\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"\\nCenters shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"\\nFirst 5 circles:\")\n    for i in range(5):\n        print(f\"  Circle {i}: center=({centers[i,0]:.4f}, {centers[i,1]:.4f}), radius={radii[i]:.4f}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5807161511884797,
    "target_ratio": 0.9793989188571082,
    "combined_score": 0.9793989188571082,
    "eval_time": 0.7236878871917725,
    "error": null
  },
  "prompt": "Write a COMPLETE Python program for circle packing.\n\nREQUIREMENTS:\n- ONLY one code block (```python ... ```)\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() returning construct_packing()\n- centers: numpy array (26, 2)\n- radii: numpy array (26,)\n- sum_radii: float\n\nSTRATEGY: Random placement with local optimization\n- Random initial positions in [0,1]x[0,1]\n- Local search to adjust positions and radii\n- Maximize sum of radii while avoiding overlaps",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Circle packing algorithm using random placement with local optimization.\n    Returns (centers, radii, sum_radii) for 26 circles.\n    \"\"\"\n    np.random.seed(42)\n    n_circles = 26\n    \n    # Initialize random centers in [0, 1] x [0, 1]\n    centers = np.random.uniform(0, 1, (n_circles, 2))\n    radii = np.full(n_circles, 0.02)\n    \n    def objective(x):\n        \"\"\"Minimize negative sum of radii (maximize sum of radii)\"\"\"\n        r = x[n_circles*2:]\n        return -np.sum(r)\n    \n    def constraint_overlap(x):\n        \"\"\"Constraint: circles should not overlap\"\"\"\n        c = x[:n_circles*2].reshape(n_circles, 2)\n        r = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(c[i] - c[j])\n                # Distance between centers must be >= sum of radii\n                constraints.append(dist - (r[i] + r[j]))\n        \n        return np.array(constraints) if constraints else np.array([1.0])\n    \n    def constraint_bounds(x):\n        \"\"\"Constraint: circles should stay within [0,1]x[0,1]\"\"\"\n        c = x[:n_circles*2].reshape(n_circles, 2)\n        r = x[n_circles*2:]\n        \n        constraints = []\n        for i in range(n_circles):\n            constraints.append(c[i, 0] - r[i])  # x - r >= 0\n            constraints.append(1 - c[i, 0] - r[i])  # x + r <= 1\n            constraints.append(c[i, 1] - r[i])  # y - r >= 0\n            constraints.append(1 - c[i, 1] - r[i])  # y + r <= 1\n        \n        return np.array(constraints)\n    \n    # Initial state vector: [x1, y1, x2, y2, ..., r1, r2, ...]\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds for optimization\n    bounds = [(0, 1) for _ in range(n_circles*2)] + [(0.001, 0.3) for _ in range(n_circles)]\n    \n    # Constraints\n    constraints = [\n        {'type': 'ineq', 'fun': constraint_overlap},\n        {'type': 'ineq', 'fun': constraint_bounds}\n    ]\n    \n    # Local optimization\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={'maxiter': 500, 'ftol': 1e-6}\n    )\n    \n    # Extract optimized centers and radii\n    x_opt = result.x\n    centers = x_opt[:n_circles*2].reshape(n_circles, 2)\n    radii = x_opt[n_circles*2:]\n    \n    # Ensure radii are positive\n    radii = np.maximum(radii, 0.001)\n    \n    # Clip centers to valid range\n    centers = np.clip(centers, 0, 1)\n    \n    # Adjust radii to respect boundaries\n    for i in range(n_circles):\n        max_r = min(\n            centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 0],\n            1 - centers[i, 1]\n        )\n        radii[i] = min(radii[i], max_r)\n    \n    # Check and resolve overlaps\n    for iteration in range(10):\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist and dist > 1e-6:\n                    # Separate circles\n                    direction = (centers[j] - centers[i]) / dist\n                    overlap = min_dist - dist\n                    centers[i] -= direction * overlap * 0.5\n                    centers[j] += direction * overlap * 0.5\n                    \n                    # Clip back to bounds\n                    centers[i] = np.clip(centers[i], 0, 1)\n                    centers[j] = np.clip(centers[j], 0, 1)\n    \n    # Final radius adjustment for boundary compliance\n    for i in range(n_circles):\n        max_r = min(\n            centers[i, 0],\n            centers[i, 1],\n            1 - centers[i, 0],\n            1 - centers[i, 1]\n        )\n        radii[i] = min(radii[i], max(max_r, 0.001))\n    \n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"Execute circle packing and return results.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Circle Packing Results:\")\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"\\nCenters shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"\\nFirst 5 circles:\")\n    for i in range(5):\n        print(f\"  Circle {i}: center=({centers[i,0]:.4f}, {centers[i,1]:.4f}), radius={radii[i]:.4f}\")\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T12:16:24.984734",
  "cost_data": null
}