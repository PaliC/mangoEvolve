{
  "trial_id": "trial_1_14",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\nimport random\n\ndef construct_packing():\n    \"\"\"\n    Construct initial random circle packing.\n    Returns: centers (n, 2), radii (n,)\n    \"\"\"\n    n_circles = 26\n    centers = np.random.rand(n_circles, 2) * 10\n    radii = np.random.rand(n_circles) * 0.3 + 0.1\n    return centers, radii\n\ndef calculate_fitness(centers, radii):\n    \"\"\"\n    Calculate fitness: sum of radii (maximize) minus penalty for overlaps.\n    Higher fitness is better.\n    \"\"\"\n    sum_radii = np.sum(radii)\n    \n    # Penalty for circles going outside bounds [0, 10]\n    bounds_penalty = 0\n    for i in range(len(centers)):\n        if centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 10:\n            bounds_penalty += 100\n        if centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 10:\n            bounds_penalty += 100\n    \n    # Penalty for overlapping circles\n    overlap_penalty = 0\n    distances = cdist(centers, centers)\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            min_dist = radii[i] + radii[j]\n            actual_dist = distances[i, j]\n            if actual_dist < min_dist:\n                overlap_penalty += (min_dist - actual_dist) ** 2 * 50\n    \n    fitness = sum_radii - bounds_penalty - overlap_penalty\n    return fitness\n\ndef mutate_chromosome(centers, radii, mutation_rate=0.1):\n    \"\"\"\n    Mutate a chromosome by slightly adjusting centers and radii.\n    \"\"\"\n    new_centers = centers.copy()\n    new_radii = radii.copy()\n    \n    for i in range(len(centers)):\n        if random.random() < mutation_rate:\n            new_centers[i] += np.random.randn(2) * 0.3\n            new_centers[i] = np.clip(new_centers[i], 0, 10)\n        \n        if random.random() < mutation_rate:\n            new_radii[i] += np.random.randn() * 0.05\n            new_radii[i] = np.clip(new_radii[i], 0.05, 0.5)\n    \n    return new_centers, new_radii\n\ndef crossover(centers1, radii1, centers2, radii2):\n    \"\"\"\n    Crossover two chromosomes at random point.\n    \"\"\"\n    crossover_point = random.randint(1, len(centers1) - 1)\n    \n    new_centers = np.vstack([centers1[:crossover_point], centers2[crossover_point:]])\n    new_radii = np.hstack([radii1[:crossover_point], radii2[crossover_point:]])\n    \n    return new_centers, new_radii\n\ndef run_packing(generations=100, population_size=50):\n    \"\"\"\n    Run genetic algorithm for circle packing.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize population\n    population = []\n    for _ in range(population_size):\n        centers, radii = construct_packing()\n        population.append((centers, radii))\n    \n    best_solution = None\n    best_fitness = -float('inf')\n    \n    for generation in range(generations):\n        # Evaluate fitness for all individuals\n        fitness_scores = []\n        for centers, radii in population:\n            fitness = calculate_fitness(centers, radii)\n            fitness_scores.append(fitness)\n            \n            if fitness > best_fitness:\n                best_fitness = fitness\n                best_solution = (centers.copy(), radii.copy())\n        \n        # Selection: tournament selection\n        new_population = []\n        for _ in range(population_size):\n            tournament_indices = random.sample(range(population_size), k=5)\n            winner_idx = max(tournament_indices, key=lambda i: fitness_scores[i])\n            new_population.append((population[winner_idx][0].copy(), population[winner_idx][1].copy()))\n        \n        # Crossover and mutation\n        next_population = []\n        for i in range(0, population_size, 2):\n            parent1_centers, parent1_radii = new_population[i]\n            parent2_centers, parent2_radii = new_population[(i + 1) % population_size]\n            \n            # Crossover\n            child_centers, child_radii = crossover(parent1_centers, parent1_radii, \n                                                    parent2_centers, parent2_radii)\n            \n            # Mutation\n            child_centers, child_radii = mutate_chromosome(child_centers, child_radii, \n                                                           mutation_rate=0.15)\n            \n            next_population.append((child_centers, child_radii))\n            \n            if len(next_population) < population_size:\n                child_centers, child_radii = crossover(parent2_centers, parent2_radii,\n                                                        parent1_centers, parent1_radii)\n                child_centers, child_radii = mutate_chromosome(child_centers, child_radii,\n                                                               mutation_rate=0.15)\n                next_population.append((child_centers, child_radii))\n        \n        population = next_population[:population_size]\n    \n    centers, radii = best_solution\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.7036948204040527,
    "error": "Circle 0 at (2.465180783959687, 4.456362172109004) with radius 0.5 extends outside x-bounds"
  },
  "prompt": "Write COMPLETE Python code for circle packing.\n\nCode block ONLY. Functions: construct_packing(), run_packing().\nReturns: (centers (26,2), radii (26,), sum_radii float).\n\nSTRATEGY: Genetic algorithm approach\n- Represent solution as chromosome\n- Evolve population of packings\n- Select best solution",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nimport random\n\ndef construct_packing():\n    \"\"\"\n    Construct initial random circle packing.\n    Returns: centers (n, 2), radii (n,)\n    \"\"\"\n    n_circles = 26\n    centers = np.random.rand(n_circles, 2) * 10\n    radii = np.random.rand(n_circles) * 0.3 + 0.1\n    return centers, radii\n\ndef calculate_fitness(centers, radii):\n    \"\"\"\n    Calculate fitness: sum of radii (maximize) minus penalty for overlaps.\n    Higher fitness is better.\n    \"\"\"\n    sum_radii = np.sum(radii)\n    \n    # Penalty for circles going outside bounds [0, 10]\n    bounds_penalty = 0\n    for i in range(len(centers)):\n        if centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 10:\n            bounds_penalty += 100\n        if centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 10:\n            bounds_penalty += 100\n    \n    # Penalty for overlapping circles\n    overlap_penalty = 0\n    distances = cdist(centers, centers)\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            min_dist = radii[i] + radii[j]\n            actual_dist = distances[i, j]\n            if actual_dist < min_dist:\n                overlap_penalty += (min_dist - actual_dist) ** 2 * 50\n    \n    fitness = sum_radii - bounds_penalty - overlap_penalty\n    return fitness\n\ndef mutate_chromosome(centers, radii, mutation_rate=0.1):\n    \"\"\"\n    Mutate a chromosome by slightly adjusting centers and radii.\n    \"\"\"\n    new_centers = centers.copy()\n    new_radii = radii.copy()\n    \n    for i in range(len(centers)):\n        if random.random() < mutation_rate:\n            new_centers[i] += np.random.randn(2) * 0.3\n            new_centers[i] = np.clip(new_centers[i], 0, 10)\n        \n        if random.random() < mutation_rate:\n            new_radii[i] += np.random.randn() * 0.05\n            new_radii[i] = np.clip(new_radii[i], 0.05, 0.5)\n    \n    return new_centers, new_radii\n\ndef crossover(centers1, radii1, centers2, radii2):\n    \"\"\"\n    Crossover two chromosomes at random point.\n    \"\"\"\n    crossover_point = random.randint(1, len(centers1) - 1)\n    \n    new_centers = np.vstack([centers1[:crossover_point], centers2[crossover_point:]])\n    new_radii = np.hstack([radii1[:crossover_point], radii2[crossover_point:]])\n    \n    return new_centers, new_radii\n\ndef run_packing(generations=100, population_size=50):\n    \"\"\"\n    Run genetic algorithm for circle packing.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize population\n    population = []\n    for _ in range(population_size):\n        centers, radii = construct_packing()\n        population.append((centers, radii))\n    \n    best_solution = None\n    best_fitness = -float('inf')\n    \n    for generation in range(generations):\n        # Evaluate fitness for all individuals\n        fitness_scores = []\n        for centers, radii in population:\n            fitness = calculate_fitness(centers, radii)\n            fitness_scores.append(fitness)\n            \n            if fitness > best_fitness:\n                best_fitness = fitness\n                best_solution = (centers.copy(), radii.copy())\n        \n        # Selection: tournament selection\n        new_population = []\n        for _ in range(population_size):\n            tournament_indices = random.sample(range(population_size), k=5)\n            winner_idx = max(tournament_indices, key=lambda i: fitness_scores[i])\n            new_population.append((population[winner_idx][0].copy(), population[winner_idx][1].copy()))\n        \n        # Crossover and mutation\n        next_population = []\n        for i in range(0, population_size, 2):\n            parent1_centers, parent1_radii = new_population[i]\n            parent2_centers, parent2_radii = new_population[(i + 1) % population_size]\n            \n            # Crossover\n            child_centers, child_radii = crossover(parent1_centers, parent1_radii, \n                                                    parent2_centers, parent2_radii)\n            \n            # Mutation\n            child_centers, child_radii = mutate_chromosome(child_centers, child_radii, \n                                                           mutation_rate=0.15)\n            \n            next_population.append((child_centers, child_radii))\n            \n            if len(next_population) < population_size:\n                child_centers, child_radii = crossover(parent2_centers, parent2_radii,\n                                                        parent1_centers, parent1_radii)\n                child_centers, child_radii = mutate_chromosome(child_centers, child_radii,\n                                                               mutation_rate=0.15)\n                next_population.append((child_centers, child_radii))\n        \n        population = next_population[:population_size]\n    \n    centers, radii = best_solution\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T12:16:33.715935",
  "cost_data": null
}