{
  "trial_id": "trial_1_10",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing using divide-and-conquer strategy.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    \n    def distance(p1, p2):\n        return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n    \n    def check_collision(centers, radii, new_center, new_radius, margin=0.001):\n        \"\"\"Check if new circle collides with existing circles\"\"\"\n        for i, center in enumerate(centers):\n            dist = distance(center, new_center)\n            if dist < radii[i] + new_radius - margin:\n                return True\n        return False\n    \n    def pack_quadrant(bounds, target_count, existing_centers, existing_radii, depth=0, max_depth=3):\n        \"\"\"\n        Recursively pack circles in a quadrant.\n        bounds: (x_min, x_max, y_min, y_max)\n        \"\"\"\n        x_min, x_max, y_min, y_max = bounds\n        width = x_max - x_min\n        height = y_max - y_min\n        \n        centers = list(existing_centers)\n        radii = list(existing_radii)\n        \n        # Base case: if too small or too deep, try to place one circle\n        if depth >= max_depth or width < 0.05 or height < 0.05:\n            max_radius = min(width, height) / 2 * 0.9\n            center = np.array([x_min + width / 2, y_min + height / 2])\n            \n            if not check_collision(centers, radii, center, max_radius):\n                centers.append(center)\n                radii.append(max_radius)\n            \n            return centers, radii\n        \n        # Recursive case: divide into 4 quadrants\n        mid_x = (x_min + x_max) / 2\n        mid_y = (y_min + y_max) / 2\n        \n        quadrants = [\n            (x_min, mid_x, y_min, mid_y),  # Bottom-left\n            (mid_x, x_max, y_min, mid_y),  # Bottom-right\n            (x_min, mid_x, mid_y, y_max),  # Top-left\n            (mid_x, x_max, mid_y, y_max)   # Top-right\n        ]\n        \n        circles_per_quadrant = max(1, target_count // 4)\n        \n        for quad_bounds in quadrants:\n            centers, radii = pack_quadrant(\n                quad_bounds, \n                circles_per_quadrant, \n                centers, \n                radii, \n                depth + 1, \n                max_depth\n            )\n        \n        return centers, radii\n    \n    # Initial packing\n    bounds = (0, 1, 0, 1)\n    centers, radii = pack_quadrant(bounds, 26, [], [])\n    \n    # Ensure we have exactly 26 circles\n    while len(centers) < 26:\n        # Try to add more circles in remaining space\n        for _ in range(26 - len(centers)):\n            # Random placement with small radius\n            x = np.random.uniform(0.05, 0.95)\n            y = np.random.uniform(0.05, 0.95)\n            center = np.array([x, y])\n            radius = 0.02\n            \n            if not check_collision(centers, radii, center, radius):\n                centers.append(center)\n                radii.append(radius)\n            \n            if len(centers) >= 26:\n                break\n    \n    centers = np.array(centers[:26])\n    radii = np.array(radii[:26])\n    \n    return centers, radii, float(np.sum(radii))\n\n\ndef run_packing():\n    \"\"\"\n    Run the circle packing algorithm with optimization.\n    Returns: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    \n    centers, radii, _ = construct_packing()\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii while avoiding collisions\"\"\"\n        centers_flat = x[:52].reshape(26, 2)\n        radii_flat = np.abs(x[52:])\n        \n        # Penalize circles outside bounds\n        penalty = 0\n        for i, center in enumerate(centers_flat):\n            if center[0] - radii_flat[i] < 0 or center[0] + radii_flat[i] > 1:\n                penalty += 100\n            if center[1] - radii_flat[i] < 0 or center[1] + radii_flat[i] > 1:\n                penalty += 100\n        \n        # Penalize overlaps\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.sqrt((centers_flat[i, 0] - centers_flat[j, 0])**2 + \n                              (centers_flat[i, 1] - centers_flat[j, 1])**2)\n                min_dist = radii_flat[i] + radii_flat[j]\n                if dist < min_dist:\n                    penalty += (min_dist - dist) * 100\n        \n        # Objective: negative sum of radii (for minimization)\n        return -np.sum(radii_flat) + penalty\n    \n    # Optimize\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n    \n    # Extract optimized values\n    x_opt = result.x\n    centers = x_opt[:52].reshape(26, 2)\n    radii = np.abs(x_opt[52:])\n    \n    # Clip to bounds\n    centers = np.clip(centers, 0, 1)\n    radii = np.clip(radii, 0.001, 0.5)\n    \n    # Enforce boundary constraints\n    for i in range(26):\n        radii[i] = min(radii[i], \n                      centers[i, 0], \n                      1 - centers[i, 0], \n                      centers[i, 1], \n                      1 - centers[i, 1])\n    \n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Centers:\\n{centers}\")\n    print(f\"Radii:\\n{radii}\")\n    \n    # Visualization\n    fig, ax = plt.subplots(figsize=(8, 8))\n    for center, radius in zip(centers, radii):\n        circle = plt.Circle(center, radius, fill=False, edgecolor='blue', linewidth=1)\n        ax.add_patch(circle)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing (Sum of Radii: {sum_radii:.4f})')\n    plt.show()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.6249973634101282,
    "target_ratio": 0.616697291616747,
    "combined_score": 0.616697291616747,
    "eval_time": 2.029371738433838,
    "error": null
  },
  "prompt": "Write COMPLETE Python code for circle packing.\n\nCode block ONLY. Functions: construct_packing(), run_packing().\nReturns: (centers (26,2), radii (26,), sum_radii float).\n\nSTRATEGY: Divide-and-conquer\n- Divide square into quadrants\n- Pack circles recursively in each quadrant\n- Merge and optimize boundaries",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing using divide-and-conquer strategy.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    \n    def distance(p1, p2):\n        return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n    \n    def check_collision(centers, radii, new_center, new_radius, margin=0.001):\n        \"\"\"Check if new circle collides with existing circles\"\"\"\n        for i, center in enumerate(centers):\n            dist = distance(center, new_center)\n            if dist < radii[i] + new_radius - margin:\n                return True\n        return False\n    \n    def pack_quadrant(bounds, target_count, existing_centers, existing_radii, depth=0, max_depth=3):\n        \"\"\"\n        Recursively pack circles in a quadrant.\n        bounds: (x_min, x_max, y_min, y_max)\n        \"\"\"\n        x_min, x_max, y_min, y_max = bounds\n        width = x_max - x_min\n        height = y_max - y_min\n        \n        centers = list(existing_centers)\n        radii = list(existing_radii)\n        \n        # Base case: if too small or too deep, try to place one circle\n        if depth >= max_depth or width < 0.05 or height < 0.05:\n            max_radius = min(width, height) / 2 * 0.9\n            center = np.array([x_min + width / 2, y_min + height / 2])\n            \n            if not check_collision(centers, radii, center, max_radius):\n                centers.append(center)\n                radii.append(max_radius)\n            \n            return centers, radii\n        \n        # Recursive case: divide into 4 quadrants\n        mid_x = (x_min + x_max) / 2\n        mid_y = (y_min + y_max) / 2\n        \n        quadrants = [\n            (x_min, mid_x, y_min, mid_y),  # Bottom-left\n            (mid_x, x_max, y_min, mid_y),  # Bottom-right\n            (x_min, mid_x, mid_y, y_max),  # Top-left\n            (mid_x, x_max, mid_y, y_max)   # Top-right\n        ]\n        \n        circles_per_quadrant = max(1, target_count // 4)\n        \n        for quad_bounds in quadrants:\n            centers, radii = pack_quadrant(\n                quad_bounds, \n                circles_per_quadrant, \n                centers, \n                radii, \n                depth + 1, \n                max_depth\n            )\n        \n        return centers, radii\n    \n    # Initial packing\n    bounds = (0, 1, 0, 1)\n    centers, radii = pack_quadrant(bounds, 26, [], [])\n    \n    # Ensure we have exactly 26 circles\n    while len(centers) < 26:\n        # Try to add more circles in remaining space\n        for _ in range(26 - len(centers)):\n            # Random placement with small radius\n            x = np.random.uniform(0.05, 0.95)\n            y = np.random.uniform(0.05, 0.95)\n            center = np.array([x, y])\n            radius = 0.02\n            \n            if not check_collision(centers, radii, center, radius):\n                centers.append(center)\n                radii.append(radius)\n            \n            if len(centers) >= 26:\n                break\n    \n    centers = np.array(centers[:26])\n    radii = np.array(radii[:26])\n    \n    return centers, radii, float(np.sum(radii))\n\n\ndef run_packing():\n    \"\"\"\n    Run the circle packing algorithm with optimization.\n    Returns: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    \n    centers, radii, _ = construct_packing()\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii while avoiding collisions\"\"\"\n        centers_flat = x[:52].reshape(26, 2)\n        radii_flat = np.abs(x[52:])\n        \n        # Penalize circles outside bounds\n        penalty = 0\n        for i, center in enumerate(centers_flat):\n            if center[0] - radii_flat[i] < 0 or center[0] + radii_flat[i] > 1:\n                penalty += 100\n            if center[1] - radii_flat[i] < 0 or center[1] + radii_flat[i] > 1:\n                penalty += 100\n        \n        # Penalize overlaps\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.sqrt((centers_flat[i, 0] - centers_flat[j, 0])**2 + \n                              (centers_flat[i, 1] - centers_flat[j, 1])**2)\n                min_dist = radii_flat[i] + radii_flat[j]\n                if dist < min_dist:\n                    penalty += (min_dist - dist) * 100\n        \n        # Objective: negative sum of radii (for minimization)\n        return -np.sum(radii_flat) + penalty\n    \n    # Optimize\n    x0 = np.concatenate([centers.flatten(), radii])\n    \n    result = minimize(\n        objective,\n        x0,\n        method='L-BFGS-B',\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n    \n    # Extract optimized values\n    x_opt = result.x\n    centers = x_opt[:52].reshape(26, 2)\n    radii = np.abs(x_opt[52:])\n    \n    # Clip to bounds\n    centers = np.clip(centers, 0, 1)\n    radii = np.clip(radii, 0.001, 0.5)\n    \n    # Enforce boundary constraints\n    for i in range(26):\n        radii[i] = min(radii[i], \n                      centers[i, 0], \n                      1 - centers[i, 0], \n                      centers[i, 1], \n                      1 - centers[i, 1])\n    \n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Centers:\\n{centers}\")\n    print(f\"Radii:\\n{radii}\")\n    \n    # Visualization\n    fig, ax = plt.subplots(figsize=(8, 8))\n    for center, radius in zip(centers, radii):\n        circle = plt.Circle(center, radius, fill=False, edgecolor='blue', linewidth=1)\n        ax.add_patch(circle)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing (Sum of Radii: {sum_radii:.4f})')\n    plt.show()\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T12:16:28.597804",
  "cost_data": null
}