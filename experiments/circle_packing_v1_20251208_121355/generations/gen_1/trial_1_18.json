{
  "trial_id": "trial_1_18",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\nimport random\n\ndef construct_packing():\n    \"\"\"Initialize packing with grid configuration.\"\"\"\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    \n    # Create grid layout\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    spacing = 2.0\n    \n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx < n_circles:\n                centers[idx] = [i * spacing, j * spacing]\n                idx += 1\n    \n    # Initial radii - start with equal small radii\n    radii = np.ones(n_circles) * 0.3\n    \n    return centers, radii\n\ndef run_packing(max_iterations=5000, tabu_tenure=50):\n    \"\"\"\n    Run tabu search for circle packing optimization.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    centers, radii = construct_packing()\n    n_circles = len(centers)\n    \n    def get_min_distance(centers, i):\n        \"\"\"Get minimum distance from circle i to all others.\"\"\"\n        dists = cdist([centers[i]], centers)[0]\n        dists[i] = np.inf\n        return np.min(dists)\n    \n    def is_valid_packing(centers, radii):\n        \"\"\"Check if packing is valid (no overlaps).\"\"\"\n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist - 1e-6:\n                    return False\n        return True\n    \n    def calculate_objective(radii):\n        \"\"\"Objective: sum of radii.\"\"\"\n        return np.sum(radii)\n    \n    def check_constraints(centers, radii):\n        \"\"\"Check if configuration violates constraints.\"\"\"\n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist - 1e-6:\n                    return False\n        return True\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_objective = calculate_objective(best_radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_objective = best_objective\n    \n    tabu_list = set()\n    iteration = 0\n    no_improve_count = 0\n    \n    while iteration < max_iterations:\n        iteration += 1\n        no_improve_count += 1\n        \n        # Generate neighbors through radius adjustments\n        neighbors = []\n        \n        # Try increasing radii for each circle\n        for i in range(n_circles):\n            for delta in [0.01, 0.02, 0.05]:\n                new_radii = current_radii.copy()\n                new_radii[i] += delta\n                \n                # Check if valid\n                if check_constraints(current_centers, new_radii):\n                    neighbor_key = tuple(np.round(new_radii, 4))\n                    if neighbor_key not in tabu_list:\n                        obj = calculate_objective(new_radii)\n                        neighbors.append((obj, new_radii.copy(), neighbor_key))\n        \n        # Try small position adjustments\n        for i in range(min(5, n_circles)):\n            for dx, dy in [(0.1, 0), (-0.1, 0), (0, 0.1), (0, -0.1)]:\n                new_centers = current_centers.copy()\n                new_centers[i] += [dx, dy]\n                \n                if check_constraints(new_centers, current_radii):\n                    neighbor_key = tuple(np.round(new_centers[i], 4))\n                    if neighbor_key not in tabu_list:\n                        obj = calculate_objective(current_radii)\n                        neighbors.append((obj, current_radii.copy(), neighbor_key))\n                        current_centers = new_centers\n        \n        if not neighbors:\n            # Diversify: make random move\n            i = random.randint(0, n_circles - 1)\n            current_radii[i] = max(0.1, current_radii[i] + random.uniform(-0.05, 0.05))\n            current_objective = calculate_objective(current_radii)\n            iteration += 1\n            continue\n        \n        # Select best neighbor\n        neighbors.sort(reverse=True)\n        best_neighbor_obj, best_neighbor_radii, neighbor_key = neighbors[0]\n        \n        # Update current solution\n        current_radii = best_neighbor_radii\n        current_objective = best_neighbor_obj\n        \n        # Add to tabu list\n        tabu_list.add(neighbor_key)\n        if len(tabu_list) > tabu_tenure:\n            tabu_list.pop()\n        \n        # Update best solution\n        if current_objective > best_objective:\n            best_objective = current_objective\n            best_radii = current_radii.copy()\n            best_centers = current_centers.copy()\n            no_improve_count = 0\n        \n        # Early stopping\n        if no_improve_count > 500:\n            break\n    \n    return best_centers, best_radii, float(np.sum(best_radii))",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.2544741630554199,
    "error": "ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()"
  },
  "prompt": "Write COMPLETE Python code for circle packing.\n\nCode block ONLY. Functions: construct_packing(), run_packing().\nReturns: (centers (26,2), radii (26,), sum_radii float).\n\nSTRATEGY: Tabu search\n- Start from grid configuration\n- Use tabu search to escape local optima\n- Maximize sum of radii",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nimport random\n\ndef construct_packing():\n    \"\"\"Initialize packing with grid configuration.\"\"\"\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    \n    # Create grid layout\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    spacing = 2.0\n    \n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx < n_circles:\n                centers[idx] = [i * spacing, j * spacing]\n                idx += 1\n    \n    # Initial radii - start with equal small radii\n    radii = np.ones(n_circles) * 0.3\n    \n    return centers, radii\n\ndef run_packing(max_iterations=5000, tabu_tenure=50):\n    \"\"\"\n    Run tabu search for circle packing optimization.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    centers, radii = construct_packing()\n    n_circles = len(centers)\n    \n    def get_min_distance(centers, i):\n        \"\"\"Get minimum distance from circle i to all others.\"\"\"\n        dists = cdist([centers[i]], centers)[0]\n        dists[i] = np.inf\n        return np.min(dists)\n    \n    def is_valid_packing(centers, radii):\n        \"\"\"Check if packing is valid (no overlaps).\"\"\"\n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist - 1e-6:\n                    return False\n        return True\n    \n    def calculate_objective(radii):\n        \"\"\"Objective: sum of radii.\"\"\"\n        return np.sum(radii)\n    \n    def check_constraints(centers, radii):\n        \"\"\"Check if configuration violates constraints.\"\"\"\n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist - 1e-6:\n                    return False\n        return True\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_objective = calculate_objective(best_radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_objective = best_objective\n    \n    tabu_list = set()\n    iteration = 0\n    no_improve_count = 0\n    \n    while iteration < max_iterations:\n        iteration += 1\n        no_improve_count += 1\n        \n        # Generate neighbors through radius adjustments\n        neighbors = []\n        \n        # Try increasing radii for each circle\n        for i in range(n_circles):\n            for delta in [0.01, 0.02, 0.05]:\n                new_radii = current_radii.copy()\n                new_radii[i] += delta\n                \n                # Check if valid\n                if check_constraints(current_centers, new_radii):\n                    neighbor_key = tuple(np.round(new_radii, 4))\n                    if neighbor_key not in tabu_list:\n                        obj = calculate_objective(new_radii)\n                        neighbors.append((obj, new_radii.copy(), neighbor_key))\n        \n        # Try small position adjustments\n        for i in range(min(5, n_circles)):\n            for dx, dy in [(0.1, 0), (-0.1, 0), (0, 0.1), (0, -0.1)]:\n                new_centers = current_centers.copy()\n                new_centers[i] += [dx, dy]\n                \n                if check_constraints(new_centers, current_radii):\n                    neighbor_key = tuple(np.round(new_centers[i], 4))\n                    if neighbor_key not in tabu_list:\n                        obj = calculate_objective(current_radii)\n                        neighbors.append((obj, current_radii.copy(), neighbor_key))\n                        current_centers = new_centers\n        \n        if not neighbors:\n            # Diversify: make random move\n            i = random.randint(0, n_circles - 1)\n            current_radii[i] = max(0.1, current_radii[i] + random.uniform(-0.05, 0.05))\n            current_objective = calculate_objective(current_radii)\n            iteration += 1\n            continue\n        \n        # Select best neighbor\n        neighbors.sort(reverse=True)\n        best_neighbor_obj, best_neighbor_radii, neighbor_key = neighbors[0]\n        \n        # Update current solution\n        current_radii = best_neighbor_radii\n        current_objective = best_neighbor_obj\n        \n        # Add to tabu list\n        tabu_list.add(neighbor_key)\n        if len(tabu_list) > tabu_tenure:\n            tabu_list.pop()\n        \n        # Update best solution\n        if current_objective > best_objective:\n            best_objective = current_objective\n            best_radii = current_radii.copy()\n            best_centers = current_centers.copy()\n            no_improve_count = 0\n        \n        # Early stopping\n        if no_improve_count > 500:\n            break\n    \n    return best_centers, best_radii, float(np.sum(best_radii))\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T12:16:37.747372",
  "cost_data": null
}