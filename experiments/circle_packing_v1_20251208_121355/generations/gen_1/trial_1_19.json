{
  "trial_id": "trial_1_19",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    Construct initial circle packing using ant colony optimization.\n    Returns: centers (26,2), radii (26,), sum_radii float\n    \"\"\"\n    np.random.seed(42)\n    \n    # Initialize parameters\n    num_circles = 26\n    container_size = 10.0\n    max_iterations = 500\n    num_ants = 30\n    \n    # ACO parameters\n    evaporation_rate = 0.1\n    pheromone_deposit = 1.0\n    alpha = 1.0  # pheromone influence\n    beta = 2.0   # distance influence\n    \n    # Initialize pheromone matrix for positions (grid-based)\n    grid_size = 20\n    pheromone = np.ones((grid_size, grid_size)) * 0.1\n    \n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    for iteration in range(max_iterations):\n        ant_solutions = []\n        \n        # Each ant constructs a solution\n        for ant in range(num_ants):\n            centers = []\n            radii = []\n            \n            # Place circles one by one\n            for circle_idx in range(num_circles):\n                if len(centers) == 0:\n                    # First circle at center\n                    center = np.array([container_size / 2, container_size / 2])\n                    radius = 0.5\n                else:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Use pheromone to guide placement\n                    probabilities = np.zeros((grid_size, grid_size))\n                    \n                    for i in range(grid_size):\n                        for j in range(grid_size):\n                            x = (i + 0.5) * (container_size / grid_size)\n                            y = (j + 0.5) * (container_size / grid_size)\n                            \n                            # Calculate pheromone influence\n                            pheromone_val = pheromone[i, j] ** alpha\n                            \n                            # Calculate distance to nearest circle\n                            distances = np.linalg.norm(centers_array - np.array([x, y]), axis=1)\n                            min_dist = np.min(distances)\n                            \n                            # Distance heuristic: prefer positions far from existing circles\n                            distance_val = (min_dist + 0.1) ** beta\n                            \n                            # Check if position is valid (in bounds)\n                            if 0 <= x < container_size and 0 <= y < container_size:\n                                probabilities[i, j] = pheromone_val * distance_val\n                    \n                    # Normalize probabilities\n                    prob_sum = np.sum(probabilities)\n                    if prob_sum > 0:\n                        probabilities = probabilities / prob_sum\n                    else:\n                        probabilities = np.ones((grid_size, grid_size)) / (grid_size * grid_size)\n                    \n                    # Select position based on probabilities\n                    flat_idx = np.random.choice(grid_size * grid_size, p=probabilities.flatten())\n                    i, j = np.unravel_index(flat_idx, (grid_size, grid_size))\n                    center = np.array([(i + 0.5) * (container_size / grid_size),\n                                      (j + 0.5) * (container_size / grid_size)])\n                    \n                    # Calculate maximum radius\n                    distances = np.linalg.norm(centers_array - center, axis=1)\n                    min_distance = np.min(distances)\n                    \n                    # Distance to container boundaries\n                    dist_to_boundary = min(center[0], center[1],\n                                          container_size - center[0],\n                                          container_size - center[1])\n                    \n                    # Maximum radius considering existing circles and boundaries\n                    max_radius = min(dist_to_boundary, (min_distance - np.min(radii_array)) / 2 + np.min(radii_array))\n                    max_radius = max(0.01, max_radius)\n                    \n                    radius = min(0.3, max_radius * 0.9)\n                \n                centers.append(center)\n                radii.append(radius)\n            \n            centers = np.array(centers)\n            radii = np.array(radii)\n            \n            # Validate solution\n            valid = True\n            for i in range(len(centers)):\n                # Check boundaries\n                if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > container_size or\n                    centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > container_size):\n                    valid = False\n                    break\n                \n                # Check overlaps\n                for j in range(i + 1, len(centers)):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j] - 0.001:\n                        valid = False\n                        break\n                if not valid:\n                    break\n            \n            if valid:\n                sum_radii = np.sum(radii)\n                ant_solutions.append((centers, radii, sum_radii))\n                \n                # Update best solution\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n        \n        # Update pheromone based on best solutions\n        pheromone *= (1 - evaporation_rate)\n        \n        if ant_solutions:\n            # Deposit pheromone for best ant\n            best_ant = max(ant_solutions, key=lambda x: x[2])\n            centers_best = best_ant[0]\n            radii_best = best_ant[1]\n            \n            for center, radius in zip(centers_best, radii_best):\n                i = int((center[0] / container_size) * grid_size)\n                j = int((center[1] / container_size) * grid_size)\n                i = np.clip(i, 0, grid_size - 1)\n                j = np.clip(j, 0, grid_size - 1)\n                pheromone[i, j] += pheromone_deposit * radius\n    \n    if best_centers is None:\n        # Fallback: create simple packing\n        best_centers = np.random.rand(26, 2) * 8 + 1\n        best_radii = np.ones(26) * 0.2\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\n\ndef run_packing():\n    \"\"\"\n    Run circle packing algorithm and return results.\n    Returns: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"First 5 centers:\\n{centers[:5]}\")\n    print(f\"First 5 radii: {radii[:5]}\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 300.0182087421417,
    "error": "Timeout after 300s"
  },
  "prompt": "Write COMPLETE Python code for circle packing.\n\nCode block ONLY. Functions: construct_packing(), run_packing().\nReturns: (centers (26,2), radii (26,), sum_radii float).\n\nSTRATEGY: Ant colony optimization\n- Use pheromone trails to guide placement\n- Iteratively improve solution\n- Maximize total radius sum",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef construct_packing():\n    \"\"\"\n    Construct initial circle packing using ant colony optimization.\n    Returns: centers (26,2), radii (26,), sum_radii float\n    \"\"\"\n    np.random.seed(42)\n    \n    # Initialize parameters\n    num_circles = 26\n    container_size = 10.0\n    max_iterations = 500\n    num_ants = 30\n    \n    # ACO parameters\n    evaporation_rate = 0.1\n    pheromone_deposit = 1.0\n    alpha = 1.0  # pheromone influence\n    beta = 2.0   # distance influence\n    \n    # Initialize pheromone matrix for positions (grid-based)\n    grid_size = 20\n    pheromone = np.ones((grid_size, grid_size)) * 0.1\n    \n    best_centers = None\n    best_radii = None\n    best_sum = 0.0\n    \n    for iteration in range(max_iterations):\n        ant_solutions = []\n        \n        # Each ant constructs a solution\n        for ant in range(num_ants):\n            centers = []\n            radii = []\n            \n            # Place circles one by one\n            for circle_idx in range(num_circles):\n                if len(centers) == 0:\n                    # First circle at center\n                    center = np.array([container_size / 2, container_size / 2])\n                    radius = 0.5\n                else:\n                    centers_array = np.array(centers)\n                    radii_array = np.array(radii)\n                    \n                    # Use pheromone to guide placement\n                    probabilities = np.zeros((grid_size, grid_size))\n                    \n                    for i in range(grid_size):\n                        for j in range(grid_size):\n                            x = (i + 0.5) * (container_size / grid_size)\n                            y = (j + 0.5) * (container_size / grid_size)\n                            \n                            # Calculate pheromone influence\n                            pheromone_val = pheromone[i, j] ** alpha\n                            \n                            # Calculate distance to nearest circle\n                            distances = np.linalg.norm(centers_array - np.array([x, y]), axis=1)\n                            min_dist = np.min(distances)\n                            \n                            # Distance heuristic: prefer positions far from existing circles\n                            distance_val = (min_dist + 0.1) ** beta\n                            \n                            # Check if position is valid (in bounds)\n                            if 0 <= x < container_size and 0 <= y < container_size:\n                                probabilities[i, j] = pheromone_val * distance_val\n                    \n                    # Normalize probabilities\n                    prob_sum = np.sum(probabilities)\n                    if prob_sum > 0:\n                        probabilities = probabilities / prob_sum\n                    else:\n                        probabilities = np.ones((grid_size, grid_size)) / (grid_size * grid_size)\n                    \n                    # Select position based on probabilities\n                    flat_idx = np.random.choice(grid_size * grid_size, p=probabilities.flatten())\n                    i, j = np.unravel_index(flat_idx, (grid_size, grid_size))\n                    center = np.array([(i + 0.5) * (container_size / grid_size),\n                                      (j + 0.5) * (container_size / grid_size)])\n                    \n                    # Calculate maximum radius\n                    distances = np.linalg.norm(centers_array - center, axis=1)\n                    min_distance = np.min(distances)\n                    \n                    # Distance to container boundaries\n                    dist_to_boundary = min(center[0], center[1],\n                                          container_size - center[0],\n                                          container_size - center[1])\n                    \n                    # Maximum radius considering existing circles and boundaries\n                    max_radius = min(dist_to_boundary, (min_distance - np.min(radii_array)) / 2 + np.min(radii_array))\n                    max_radius = max(0.01, max_radius)\n                    \n                    radius = min(0.3, max_radius * 0.9)\n                \n                centers.append(center)\n                radii.append(radius)\n            \n            centers = np.array(centers)\n            radii = np.array(radii)\n            \n            # Validate solution\n            valid = True\n            for i in range(len(centers)):\n                # Check boundaries\n                if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > container_size or\n                    centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > container_size):\n                    valid = False\n                    break\n                \n                # Check overlaps\n                for j in range(i + 1, len(centers)):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    if dist < radii[i] + radii[j] - 0.001:\n                        valid = False\n                        break\n                if not valid:\n                    break\n            \n            if valid:\n                sum_radii = np.sum(radii)\n                ant_solutions.append((centers, radii, sum_radii))\n                \n                # Update best solution\n                if sum_radii > best_sum:\n                    best_sum = sum_radii\n                    best_centers = centers.copy()\n                    best_radii = radii.copy()\n        \n        # Update pheromone based on best solutions\n        pheromone *= (1 - evaporation_rate)\n        \n        if ant_solutions:\n            # Deposit pheromone for best ant\n            best_ant = max(ant_solutions, key=lambda x: x[2])\n            centers_best = best_ant[0]\n            radii_best = best_ant[1]\n            \n            for center, radius in zip(centers_best, radii_best):\n                i = int((center[0] / container_size) * grid_size)\n                j = int((center[1] / container_size) * grid_size)\n                i = np.clip(i, 0, grid_size - 1)\n                j = np.clip(j, 0, grid_size - 1)\n                pheromone[i, j] += pheromone_deposit * radius\n    \n    if best_centers is None:\n        # Fallback: create simple packing\n        best_centers = np.random.rand(26, 2) * 8 + 1\n        best_radii = np.ones(26) * 0.2\n        best_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, best_sum\n\n\ndef run_packing():\n    \"\"\"\n    Run circle packing algorithm and return results.\n    Returns: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"First 5 centers:\\n{centers[:5]}\")\n    print(f\"First 5 radii: {radii[:5]}\")\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T12:21:41.121889",
  "cost_data": null
}