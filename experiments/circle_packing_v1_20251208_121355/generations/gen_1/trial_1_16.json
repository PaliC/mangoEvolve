{
  "trial_id": "trial_1_16",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing with 26 circles using adaptive radius allocation.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle centers\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize with equal radii\n    initial_radii = np.ones(n_circles) * 0.1\n    initial_centers = np.random.rand(n_circles, 2) * 2.0\n    \n    # Optimize placement and radii\n    def objective(x):\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = np.abs(x[n_circles*2:])\n        \n        penalty = 0.0\n        \n        # Penalize circles outside bounds\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            r = radii[i]\n            if cx - r < 0 or cx + r > 2.0 or cy - r < 0 or cy + r > 2.0:\n                penalty += 1000.0\n        \n        # Penalize overlapping circles\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    penalty += (min_dist - dist) ** 2 * 100.0\n        \n        # Objective: maximize sum of radii (negative for minimization)\n        return penalty - np.sum(radii)\n    \n    # Combine initial state\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    # Optimize\n    result = minimize(objective, x0, method='L-BFGS-B', \n                     options={'maxiter': 1000, 'ftol': 1e-6})\n    \n    x_opt = result.x\n    centers = x_opt[:n_circles*2].reshape(n_circles, 2)\n    radii = np.abs(x_opt[n_circles*2:])\n    \n    return centers, radii, np.sum(radii)\n\n\ndef run_packing():\n    \"\"\"\n    Run circle packing and return results.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle centers\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    # Use adaptive approach: iteratively improve packing\n    best_centers = None\n    best_radii = None\n    best_sum = -np.inf\n    \n    n_circles = 26\n    \n    # Multiple optimization runs with different initializations\n    for trial in range(3):\n        # Initialize circles with better spacing\n        angles = np.linspace(0, 2*np.pi, n_circles, endpoint=False)\n        radius_dist = 0.8\n        centers = np.column_stack([\n            1.0 + radius_dist * np.cos(angles),\n            1.0 + radius_dist * np.sin(angles)\n        ])\n        \n        # Add some randomness\n        centers += np.random.randn(n_circles, 2) * 0.1\n        centers = np.clip(centers, 0.05, 1.95)\n        \n        radii = np.ones(n_circles) * 0.08\n        \n        # Iterative adaptive refinement\n        for iteration in range(20):\n            # Compute local available space for each circle\n            local_space = np.ones(n_circles) * 10.0\n            \n            for i in range(n_circles):\n                # Distance to boundaries\n                cx, cy = centers[i]\n                to_bounds = min(cx, cy, 2.0 - cx, 2.0 - cy)\n                local_space[i] = to_bounds\n                \n                # Distance to other circles\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        available = max(0, dist - radii[j])\n                        local_space[i] = min(local_space[i], available)\n            \n            # Normalize and apply adaptive radius update\n            local_space = np.clip(local_space, 0.01, None)\n            radii = local_space * 0.4 + radii * 0.6\n            \n            # Repulsion-based center adjustment\n            for i in range(n_circles):\n                force = np.zeros(2)\n                \n                # Repulsion from other circles\n                for j in range(n_circles):\n                    if i != j:\n                        diff = centers[i] - centers[j]\n                        dist = np.linalg.norm(diff)\n                        min_dist = radii[i] + radii[j]\n                        \n                        if dist < min_dist and dist > 1e-6:\n                            force += (diff / dist) * (min_dist - dist) * 0.01\n                \n                # Attraction to center of space\n                center_of_space = np.array([1.0, 1.0])\n                to_center = center_of_space - centers[i]\n                force += to_center * 0.001\n                \n                centers[i] += force\n                centers[i] = np.clip(centers[i], 0.05, 1.95)\n        \n        # Enforce non-overlapping constraint\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist and dist > 1e-6:\n                    overlap = min_dist - dist\n                    direction = (centers[j] - centers[i]) / dist\n                    centers[i] -= direction * overlap * 0.5\n                    centers[j] += direction * overlap * 0.5\n                    centers[i] = np.clip(centers[i], 0.05, 1.95)\n                    centers[j] = np.clip(centers[j], 0.05, 1.95)\n        \n        # Enforce boundary constraints on radii\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            max_radius = min(cx, cy, 2.0 - cx, 2.0 - cy)\n            radii[i] = min(radii[i], max_radius)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Visualization\n    fig, ax = plt.subplots(figsize=(8, 8))\n    \n    # Draw boundary\n    ax.add_patch(plt.Rectangle((0, 0), 2.0, 2.0, fill=False, edgecolor='black', linewidth=2))\n    \n    # Draw circles\n    colors = plt.cm.hsv(np.linspace(0, 1, 26))\n    for i in range(26):\n        circle = plt.Circle(centers[i], radii[i], color=colors[i], alpha=0.6, edgecolor='black', linewidth=0.5)\n        ax.add_patch(circle)\n    \n    ax.set_xlim(-0.1, 2.1)\n    ax.set_ylim(-0.1, 2.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing (26 circles, sum of radii = {sum_radii:.4f})')\n    plt.tight_layout()\n    plt.savefig('circle_packing.png', dpi=150, bbox_inches='tight')\n    plt.show()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.6004431247711182,
    "error": "Circle 0 at (1.6946490080668277, 0.9383182165391326) with radius 0.18216392830729589 extends outside x-bounds"
  },
  "prompt": "Write COMPLETE Python code for circle packing.\n\nCode block ONLY. Functions: construct_packing(), run_packing().\nReturns: (centers (26,2), radii (26,), sum_radii float).\n\nSTRATEGY: Adaptive radius allocation\n- Start with equal radii\n- Adaptively increase radii based on local space\n- Maximize total radius sum",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing with 26 circles using adaptive radius allocation.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle centers\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize with equal radii\n    initial_radii = np.ones(n_circles) * 0.1\n    initial_centers = np.random.rand(n_circles, 2) * 2.0\n    \n    # Optimize placement and radii\n    def objective(x):\n        centers = x[:n_circles*2].reshape(n_circles, 2)\n        radii = np.abs(x[n_circles*2:])\n        \n        penalty = 0.0\n        \n        # Penalize circles outside bounds\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            r = radii[i]\n            if cx - r < 0 or cx + r > 2.0 or cy - r < 0 or cy + r > 2.0:\n                penalty += 1000.0\n        \n        # Penalize overlapping circles\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    penalty += (min_dist - dist) ** 2 * 100.0\n        \n        # Objective: maximize sum of radii (negative for minimization)\n        return penalty - np.sum(radii)\n    \n    # Combine initial state\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    # Optimize\n    result = minimize(objective, x0, method='L-BFGS-B', \n                     options={'maxiter': 1000, 'ftol': 1e-6})\n    \n    x_opt = result.x\n    centers = x_opt[:n_circles*2].reshape(n_circles, 2)\n    radii = np.abs(x_opt[n_circles*2:])\n    \n    return centers, radii, np.sum(radii)\n\n\ndef run_packing():\n    \"\"\"\n    Run circle packing and return results.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle centers\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    # Use adaptive approach: iteratively improve packing\n    best_centers = None\n    best_radii = None\n    best_sum = -np.inf\n    \n    n_circles = 26\n    \n    # Multiple optimization runs with different initializations\n    for trial in range(3):\n        # Initialize circles with better spacing\n        angles = np.linspace(0, 2*np.pi, n_circles, endpoint=False)\n        radius_dist = 0.8\n        centers = np.column_stack([\n            1.0 + radius_dist * np.cos(angles),\n            1.0 + radius_dist * np.sin(angles)\n        ])\n        \n        # Add some randomness\n        centers += np.random.randn(n_circles, 2) * 0.1\n        centers = np.clip(centers, 0.05, 1.95)\n        \n        radii = np.ones(n_circles) * 0.08\n        \n        # Iterative adaptive refinement\n        for iteration in range(20):\n            # Compute local available space for each circle\n            local_space = np.ones(n_circles) * 10.0\n            \n            for i in range(n_circles):\n                # Distance to boundaries\n                cx, cy = centers[i]\n                to_bounds = min(cx, cy, 2.0 - cx, 2.0 - cy)\n                local_space[i] = to_bounds\n                \n                # Distance to other circles\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        available = max(0, dist - radii[j])\n                        local_space[i] = min(local_space[i], available)\n            \n            # Normalize and apply adaptive radius update\n            local_space = np.clip(local_space, 0.01, None)\n            radii = local_space * 0.4 + radii * 0.6\n            \n            # Repulsion-based center adjustment\n            for i in range(n_circles):\n                force = np.zeros(2)\n                \n                # Repulsion from other circles\n                for j in range(n_circles):\n                    if i != j:\n                        diff = centers[i] - centers[j]\n                        dist = np.linalg.norm(diff)\n                        min_dist = radii[i] + radii[j]\n                        \n                        if dist < min_dist and dist > 1e-6:\n                            force += (diff / dist) * (min_dist - dist) * 0.01\n                \n                # Attraction to center of space\n                center_of_space = np.array([1.0, 1.0])\n                to_center = center_of_space - centers[i]\n                force += to_center * 0.001\n                \n                centers[i] += force\n                centers[i] = np.clip(centers[i], 0.05, 1.95)\n        \n        # Enforce non-overlapping constraint\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist and dist > 1e-6:\n                    overlap = min_dist - dist\n                    direction = (centers[j] - centers[i]) / dist\n                    centers[i] -= direction * overlap * 0.5\n                    centers[j] += direction * overlap * 0.5\n                    centers[i] = np.clip(centers[i], 0.05, 1.95)\n                    centers[j] = np.clip(centers[j], 0.05, 1.95)\n        \n        # Enforce boundary constraints on radii\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            max_radius = min(cx, cy, 2.0 - cx, 2.0 - cy)\n            radii[i] = min(radii[i], max_radius)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n    \n    return best_centers, best_radii, best_sum\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Visualization\n    fig, ax = plt.subplots(figsize=(8, 8))\n    \n    # Draw boundary\n    ax.add_patch(plt.Rectangle((0, 0), 2.0, 2.0, fill=False, edgecolor='black', linewidth=2))\n    \n    # Draw circles\n    colors = plt.cm.hsv(np.linspace(0, 1, 26))\n    for i in range(26):\n        circle = plt.Circle(centers[i], radii[i], color=colors[i], alpha=0.6, edgecolor='black', linewidth=0.5)\n        ax.add_patch(circle)\n    \n    ax.set_xlim(-0.1, 2.1)\n    ax.set_ylim(-0.1, 2.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing (26 circles, sum of radii = {sum_radii:.4f})')\n    plt.tight_layout()\n    plt.savefig('circle_packing.png', dpi=150, bbox_inches='tight')\n    plt.show()\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T12:16:37.937123",
  "cost_data": null
}