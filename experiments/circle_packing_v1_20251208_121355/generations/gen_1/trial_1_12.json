{
  "trial_id": "trial_1_12",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing using multi-phase optimization.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle center coordinates\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    \n    # Phase 1: Grid initialization\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = np.zeros((n_circles, 2))\n    spacing = 2.0\n    \n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx < n_circles:\n                centers[idx] = np.array([i * spacing, j * spacing])\n                idx += 1\n    \n    # Normalize to [0, 1] range\n    centers_min = centers.min(axis=0)\n    centers_max = centers.max(axis=0)\n    centers = (centers - centers_min) / (centers_max - centers_min + 1e-6)\n    \n    radii = np.ones(n_circles) * 0.02\n    \n    # Phase 2: Radius expansion\n    def compute_min_distance(centers, radii):\n        \"\"\"Compute minimum pairwise distance minus sum of radii.\"\"\"\n        min_dist = np.inf\n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_separation = dist - radii[i] - radii[j]\n                min_dist = min(min_dist, min_separation)\n        return min_dist\n    \n    def expand_radii(radii, centers, max_radius=0.15):\n        \"\"\"Expand radii while maintaining non-overlap.\"\"\"\n        radii = radii.copy()\n        for iteration in range(100):\n            min_separation = compute_min_distance(centers, radii)\n            if min_separation <= 0:\n                break\n            \n            # Expand all radii proportionally\n            expansion_factor = 1.0 + (min_separation / (2 * radii.mean())) * 0.1\n            new_radii = radii * expansion_factor\n            new_radii = np.minimum(new_radii, max_radius)\n            \n            if np.allclose(new_radii, radii):\n                break\n            radii = new_radii\n        \n        return radii\n    \n    radii = expand_radii(radii, centers)\n    \n    # Phase 3: Position refinement\n    def objective_position(x_flat, centers_fixed, radii):\n        \"\"\"Objective: maximize minimum separation.\"\"\"\n        x = x_flat.reshape(-1, 2)\n        centers_opt = np.vstack([centers_fixed[:1], x])\n        \n        min_sep = np.inf\n        \n        # Distance to boundaries\n        margin = 0.05\n        for i in range(len(centers_opt)):\n            dist_left = centers_opt[i, 0] - radii[i] - margin\n            dist_right = 1 - margin - (centers_opt[i, 0] + radii[i])\n            dist_bottom = centers_opt[i, 1] - radii[i] - margin\n            dist_top = 1 - margin - (centers_opt[i, 1] + radii[i])\n            \n            min_sep = min(min_sep, dist_left, dist_right, dist_bottom, dist_top)\n        \n        # Pairwise distances\n        for i in range(len(centers_opt)):\n            for j in range(i + 1, len(centers_opt)):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                separation = dist - radii[i] - radii[j]\n                min_sep = min(min_sep, separation)\n        \n        return -min_sep\n    \n    # Optimize positions\n    x0 = centers[1:].flatten()\n    result = minimize(\n        objective_position,\n        x0,\n        args=(centers[:1], radii),\n        method='L-BFGS-B',\n        options={'maxiter': 200, 'ftol': 1e-6}\n    )\n    \n    centers[1:] = result.x.reshape(-1, 2)\n    \n    # Clip to valid range\n    margin = 0.05\n    for i in range(len(centers)):\n        centers[i, 0] = np.clip(centers[i, 0], radii[i] + margin, 1 - radii[i] - margin)\n        centers[i, 1] = np.clip(centers[i, 1], radii[i] + margin, 1 - radii[i] - margin)\n    \n    # Phase 4: Final optimization - joint position and radius optimization\n    def objective_final(x_flat, n_circles):\n        \"\"\"Joint optimization of positions and radii.\"\"\"\n        centers_opt = x_flat[:n_circles*2].reshape(-1, 2)\n        radii_opt = x_flat[n_circles*2:]\n        \n        # Constraint: radii must be positive\n        if np.any(radii_opt <= 0):\n            return 1e10\n        \n        penalty = 0\n        \n        # Boundary constraints\n        margin = 0.05\n        for i in range(n_circles):\n            dist_left = centers_opt[i, 0] - radii_opt[i] - margin\n            dist_right = 1 - margin - (centers_opt[i, 0] + radii_opt[i])\n            dist_bottom = centers_opt[i, 1] - radii_opt[i] - margin\n            dist_top = 1 - margin - (centers_opt[i, 1] + radii_opt[i])\n            \n            penalty += max(0, -dist_left)**2 + max(0, -dist_right)**2\n            penalty += max(0, -dist_bottom)**2 + max(0, -dist_top)**2\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                min_dist = radii_opt[i] + radii_opt[j]\n                if dist < min_dist:\n                    penalty += (min_dist - dist)**2\n        \n        # Objective: maximize sum of radii\n        return -radii_opt.sum() + 100 * penalty\n    \n    x0_final = np.concatenate([centers.flatten(), radii])\n    result_final = minimize(\n        objective_final,\n        x0_final,\n        args=(n_circles,),\n        method='L-BFGS-B',\n        bounds=[(0.02, 0.98)] * (n_circles * 2) + [(0.01, 0.2)] * n_circles,\n        options={'maxiter': 300, 'ftol': 1e-7}\n    )\n    \n    centers = result_final.x[:n_circles*2].reshape(-1, 2)\n    radii = result_final.x[n_circles*2:]\n    \n    sum_radii = float(radii.sum())\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Run circle packing and visualize results.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2)\n        radii: np.ndarray of shape (26,)\n        sum_radii: float\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Circle Packing Results:\")\n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {radii.mean():.6f}\")\n    print(f\"Max radius: {radii.max():.6f}\")\n    print(f\"Min radius: {radii.min():.6f}\")\n    \n    # Visualization\n    fig, ax = plt.subplots(figsize=(10, 10))\n    \n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = plt.Circle(center, radius, fill=False, edgecolor='blue', linewidth=1.5)\n        ax.add_patch(circle)\n        ax.plot(center[0], center[1], 'r.', markersize=3)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing: {len(centers)} circles, Sum of radii = {sum_radii:.4f}')\n    plt.tight_layout()\n    plt.savefig('circle_packing.png', dpi=150, bbox_inches='tight')\n    plt.show()\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 27.829969882965088,
    "error": "Circles 0 and 4 overlap: distance=0.156386, required=0.157278"
  },
  "prompt": "Write COMPLETE Python code for circle packing.\n\nCode block ONLY. Functions: construct_packing(), run_packing().\nReturns: (centers (26,2), radii (26,), sum_radii float).\n\nSTRATEGY: Multi-phase optimization\n- Phase 1: Grid initialization\n- Phase 2: Radius expansion\n- Phase 3: Position refinement\n- Phase 4: Final optimization",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing using multi-phase optimization.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle center coordinates\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    \n    # Phase 1: Grid initialization\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    centers = np.zeros((n_circles, 2))\n    spacing = 2.0\n    \n    idx = 0\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if idx < n_circles:\n                centers[idx] = np.array([i * spacing, j * spacing])\n                idx += 1\n    \n    # Normalize to [0, 1] range\n    centers_min = centers.min(axis=0)\n    centers_max = centers.max(axis=0)\n    centers = (centers - centers_min) / (centers_max - centers_min + 1e-6)\n    \n    radii = np.ones(n_circles) * 0.02\n    \n    # Phase 2: Radius expansion\n    def compute_min_distance(centers, radii):\n        \"\"\"Compute minimum pairwise distance minus sum of radii.\"\"\"\n        min_dist = np.inf\n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_separation = dist - radii[i] - radii[j]\n                min_dist = min(min_dist, min_separation)\n        return min_dist\n    \n    def expand_radii(radii, centers, max_radius=0.15):\n        \"\"\"Expand radii while maintaining non-overlap.\"\"\"\n        radii = radii.copy()\n        for iteration in range(100):\n            min_separation = compute_min_distance(centers, radii)\n            if min_separation <= 0:\n                break\n            \n            # Expand all radii proportionally\n            expansion_factor = 1.0 + (min_separation / (2 * radii.mean())) * 0.1\n            new_radii = radii * expansion_factor\n            new_radii = np.minimum(new_radii, max_radius)\n            \n            if np.allclose(new_radii, radii):\n                break\n            radii = new_radii\n        \n        return radii\n    \n    radii = expand_radii(radii, centers)\n    \n    # Phase 3: Position refinement\n    def objective_position(x_flat, centers_fixed, radii):\n        \"\"\"Objective: maximize minimum separation.\"\"\"\n        x = x_flat.reshape(-1, 2)\n        centers_opt = np.vstack([centers_fixed[:1], x])\n        \n        min_sep = np.inf\n        \n        # Distance to boundaries\n        margin = 0.05\n        for i in range(len(centers_opt)):\n            dist_left = centers_opt[i, 0] - radii[i] - margin\n            dist_right = 1 - margin - (centers_opt[i, 0] + radii[i])\n            dist_bottom = centers_opt[i, 1] - radii[i] - margin\n            dist_top = 1 - margin - (centers_opt[i, 1] + radii[i])\n            \n            min_sep = min(min_sep, dist_left, dist_right, dist_bottom, dist_top)\n        \n        # Pairwise distances\n        for i in range(len(centers_opt)):\n            for j in range(i + 1, len(centers_opt)):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                separation = dist - radii[i] - radii[j]\n                min_sep = min(min_sep, separation)\n        \n        return -min_sep\n    \n    # Optimize positions\n    x0 = centers[1:].flatten()\n    result = minimize(\n        objective_position,\n        x0,\n        args=(centers[:1], radii),\n        method='L-BFGS-B',\n        options={'maxiter': 200, 'ftol': 1e-6}\n    )\n    \n    centers[1:] = result.x.reshape(-1, 2)\n    \n    # Clip to valid range\n    margin = 0.05\n    for i in range(len(centers)):\n        centers[i, 0] = np.clip(centers[i, 0], radii[i] + margin, 1 - radii[i] - margin)\n        centers[i, 1] = np.clip(centers[i, 1], radii[i] + margin, 1 - radii[i] - margin)\n    \n    # Phase 4: Final optimization - joint position and radius optimization\n    def objective_final(x_flat, n_circles):\n        \"\"\"Joint optimization of positions and radii.\"\"\"\n        centers_opt = x_flat[:n_circles*2].reshape(-1, 2)\n        radii_opt = x_flat[n_circles*2:]\n        \n        # Constraint: radii must be positive\n        if np.any(radii_opt <= 0):\n            return 1e10\n        \n        penalty = 0\n        \n        # Boundary constraints\n        margin = 0.05\n        for i in range(n_circles):\n            dist_left = centers_opt[i, 0] - radii_opt[i] - margin\n            dist_right = 1 - margin - (centers_opt[i, 0] + radii_opt[i])\n            dist_bottom = centers_opt[i, 1] - radii_opt[i] - margin\n            dist_top = 1 - margin - (centers_opt[i, 1] + radii_opt[i])\n            \n            penalty += max(0, -dist_left)**2 + max(0, -dist_right)**2\n            penalty += max(0, -dist_bottom)**2 + max(0, -dist_top)**2\n        \n        # Non-overlap constraints\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                min_dist = radii_opt[i] + radii_opt[j]\n                if dist < min_dist:\n                    penalty += (min_dist - dist)**2\n        \n        # Objective: maximize sum of radii\n        return -radii_opt.sum() + 100 * penalty\n    \n    x0_final = np.concatenate([centers.flatten(), radii])\n    result_final = minimize(\n        objective_final,\n        x0_final,\n        args=(n_circles,),\n        method='L-BFGS-B',\n        bounds=[(0.02, 0.98)] * (n_circles * 2) + [(0.01, 0.2)] * n_circles,\n        options={'maxiter': 300, 'ftol': 1e-7}\n    )\n    \n    centers = result_final.x[:n_circles*2].reshape(-1, 2)\n    radii = result_final.x[n_circles*2:]\n    \n    sum_radii = float(radii.sum())\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Run circle packing and visualize results.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2)\n        radii: np.ndarray of shape (26,)\n        sum_radii: float\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    \n    print(f\"Circle Packing Results:\")\n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {radii.mean():.6f}\")\n    print(f\"Max radius: {radii.max():.6f}\")\n    print(f\"Min radius: {radii.min():.6f}\")\n    \n    # Visualization\n    fig, ax = plt.subplots(figsize=(10, 10))\n    \n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = plt.Circle(center, radius, fill=False, edgecolor='blue', linewidth=1.5)\n        ax.add_patch(circle)\n        ax.plot(center[0], center[1], 'r.', markersize=3)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing: {len(centers)} circles, Sum of radii = {sum_radii:.4f}')\n    plt.tight_layout()\n    plt.savefig('circle_packing.png', dpi=150, bbox_inches='tight')\n    plt.show()\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T12:17:04.632811",
  "cost_data": null
}