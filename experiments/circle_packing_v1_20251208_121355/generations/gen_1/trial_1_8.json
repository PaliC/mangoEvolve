{
  "trial_id": "trial_1_8",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing using particle swarm optimization.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    bounds = np.array([[0, 1], [0, 1]])\n    \n    # PSO parameters\n    n_particles = 50\n    n_iterations = 300\n    w = 0.7\n    c1 = 1.5\n    c2 = 1.5\n    \n    # Initialize particle positions and velocities\n    # Each particle represents a candidate solution: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n    dim = n_circles * 3\n    \n    positions = np.random.rand(n_particles, dim)\n    # Scale positions: x,y in [0,1], radii in [0, 0.1]\n    for i in range(n_particles):\n        for j in range(n_circles):\n            positions[i, 3*j:3*j+2] *= 1.0  # x, y in [0, 1]\n            positions[i, 3*j+2] *= 0.1      # r in [0, 0.1]\n    \n    velocities = np.random.randn(n_particles, dim) * 0.05\n    \n    best_positions = positions.copy()\n    best_fitness = np.full(n_particles, -np.inf)\n    \n    global_best_position = None\n    global_best_fitness = -np.inf\n    \n    def fitness_function(solution):\n        \"\"\"Evaluate fitness: maximize sum of radii while avoiding overlaps.\"\"\"\n        centers = solution[:n_circles*2].reshape(n_circles, 2)\n        radii = solution[n_circles*2:]\n        \n        # Penalize if out of bounds\n        if np.any(centers < 0) or np.any(centers > 1):\n            return -1e10\n        if np.any(radii < 0.001) or np.any(radii > 0.5):\n            return -1e10\n        \n        # Check for overlaps\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        min_distances = distances.min(axis=1)\n        required_distances = radii[:, np.newaxis] + radii[np.newaxis, :]\n        np.fill_diagonal(required_distances, np.inf)\n        min_required = required_distances.min(axis=1)\n        \n        # Penalty for overlaps\n        overlap_penalty = 0\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = distances[i, j]\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap_penalty += (min_dist - dist) ** 2\n        \n        # Penalize circles outside bounds\n        boundary_penalty = 0\n        for i in range(n_circles):\n            x, y = centers[i]\n            r = radii[i]\n            if x - r < 0:\n                boundary_penalty += (0 - (x - r)) ** 2\n            if x + r > 1:\n                boundary_penalty += ((x + r) - 1) ** 2\n            if y - r < 0:\n                boundary_penalty += (0 - (y - r)) ** 2\n            if y + r > 1:\n                boundary_penalty += ((y + r) - 1) ** 2\n        \n        fitness = np.sum(radii) - 100 * overlap_penalty - 100 * boundary_penalty\n        return fitness\n    \n    # PSO optimization loop\n    for iteration in range(n_iterations):\n        for i in range(n_particles):\n            # Evaluate fitness\n            current_fitness = fitness_function(positions[i])\n            \n            if current_fitness > best_fitness[i]:\n                best_fitness[i] = current_fitness\n                best_positions[i] = positions[i].copy()\n            \n            if current_fitness > global_best_fitness:\n                global_best_fitness = current_fitness\n                global_best_position = positions[i].copy()\n        \n        # Update velocities and positions\n        for i in range(n_particles):\n            r1 = np.random.rand(dim)\n            r2 = np.random.rand(dim)\n            \n            velocities[i] = (w * velocities[i] +\n                            c1 * r1 * (best_positions[i] - positions[i]) +\n                            c2 * r2 * (global_best_position - positions[i]))\n            \n            positions[i] += velocities[i]\n            \n            # Boundary handling\n            for j in range(n_circles):\n                positions[i, 3*j:3*j+2] = np.clip(positions[i, 3*j:3*j+2], 0, 1)\n                positions[i, 3*j+2] = np.clip(positions[i, 3*j+2], 0.001, 0.1)\n    \n    # Extract best solution\n    best_solution = global_best_position\n    centers = best_solution[:n_circles*2].reshape(n_circles, 2)\n    radii = best_solution[n_circles*2:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"\n    Run the circle packing algorithm.\n    Returns: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 1.5608198642730713,
    "error": "Circle 0 at (0.3745401188473625, 0.9507143064099162) with radius 0.9394989415641891 extends outside x-bounds"
  },
  "prompt": "Write COMPLETE Python code for circle packing.\n\nCode block ONLY. Functions: construct_packing(), run_packing().\nReturns: (centers (26,2), radii (26,), sum_radii float).\n\nSTRATEGY: Particle swarm optimization\n- Initialize 26 circles with PSO mechanics\n- Optimize positions and radii\n- Maximize total radius sum",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Construct circle packing using particle swarm optimization.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    np.random.seed(42)\n    \n    n_circles = 26\n    bounds = np.array([[0, 1], [0, 1]])\n    \n    # PSO parameters\n    n_particles = 50\n    n_iterations = 300\n    w = 0.7\n    c1 = 1.5\n    c2 = 1.5\n    \n    # Initialize particle positions and velocities\n    # Each particle represents a candidate solution: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n    dim = n_circles * 3\n    \n    positions = np.random.rand(n_particles, dim)\n    # Scale positions: x,y in [0,1], radii in [0, 0.1]\n    for i in range(n_particles):\n        for j in range(n_circles):\n            positions[i, 3*j:3*j+2] *= 1.0  # x, y in [0, 1]\n            positions[i, 3*j+2] *= 0.1      # r in [0, 0.1]\n    \n    velocities = np.random.randn(n_particles, dim) * 0.05\n    \n    best_positions = positions.copy()\n    best_fitness = np.full(n_particles, -np.inf)\n    \n    global_best_position = None\n    global_best_fitness = -np.inf\n    \n    def fitness_function(solution):\n        \"\"\"Evaluate fitness: maximize sum of radii while avoiding overlaps.\"\"\"\n        centers = solution[:n_circles*2].reshape(n_circles, 2)\n        radii = solution[n_circles*2:]\n        \n        # Penalize if out of bounds\n        if np.any(centers < 0) or np.any(centers > 1):\n            return -1e10\n        if np.any(radii < 0.001) or np.any(radii > 0.5):\n            return -1e10\n        \n        # Check for overlaps\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        min_distances = distances.min(axis=1)\n        required_distances = radii[:, np.newaxis] + radii[np.newaxis, :]\n        np.fill_diagonal(required_distances, np.inf)\n        min_required = required_distances.min(axis=1)\n        \n        # Penalty for overlaps\n        overlap_penalty = 0\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = distances[i, j]\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap_penalty += (min_dist - dist) ** 2\n        \n        # Penalize circles outside bounds\n        boundary_penalty = 0\n        for i in range(n_circles):\n            x, y = centers[i]\n            r = radii[i]\n            if x - r < 0:\n                boundary_penalty += (0 - (x - r)) ** 2\n            if x + r > 1:\n                boundary_penalty += ((x + r) - 1) ** 2\n            if y - r < 0:\n                boundary_penalty += (0 - (y - r)) ** 2\n            if y + r > 1:\n                boundary_penalty += ((y + r) - 1) ** 2\n        \n        fitness = np.sum(radii) - 100 * overlap_penalty - 100 * boundary_penalty\n        return fitness\n    \n    # PSO optimization loop\n    for iteration in range(n_iterations):\n        for i in range(n_particles):\n            # Evaluate fitness\n            current_fitness = fitness_function(positions[i])\n            \n            if current_fitness > best_fitness[i]:\n                best_fitness[i] = current_fitness\n                best_positions[i] = positions[i].copy()\n            \n            if current_fitness > global_best_fitness:\n                global_best_fitness = current_fitness\n                global_best_position = positions[i].copy()\n        \n        # Update velocities and positions\n        for i in range(n_particles):\n            r1 = np.random.rand(dim)\n            r2 = np.random.rand(dim)\n            \n            velocities[i] = (w * velocities[i] +\n                            c1 * r1 * (best_positions[i] - positions[i]) +\n                            c2 * r2 * (global_best_position - positions[i]))\n            \n            positions[i] += velocities[i]\n            \n            # Boundary handling\n            for j in range(n_circles):\n                positions[i, 3*j:3*j+2] = np.clip(positions[i, 3*j:3*j+2], 0, 1)\n                positions[i, 3*j+2] = np.clip(positions[i, 3*j+2], 0.001, 0.1)\n    \n    # Extract best solution\n    best_solution = global_best_position\n    centers = best_solution[:n_circles*2].reshape(n_circles, 2)\n    radii = best_solution[n_circles*2:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"\n    Run the circle packing algorithm.\n    Returns: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2025-12-08T12:16:25.512146",
  "cost_data": null
}