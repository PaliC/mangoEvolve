{
  "trial_id": "trial_0_14",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom typing import List, Tuple\nimport math\n\nclass CirclePacking:\n    \"\"\"\n    Circle packing algorithm using border-first approach.\n    Larger circles are placed near borders, smaller circles fill interior.\n    \"\"\"\n    \n    def __init__(self, container_size: float = 100.0, num_circles: int = 26):\n        \"\"\"\n        Initialize circle packing problem.\n        \n        Args:\n            container_size: Size of the square container (width/height)\n            num_circles: Number of circles to pack\n        \"\"\"\n        self.container_size = container_size\n        self.num_circles = num_circles\n        self.circles = []  # List of (x, y, radius) tuples\n        self.padding = 1.0  # Minimum padding from borders\n        \n    def generate_circle_sizes(self) -> List[float]:\n        \"\"\"\n        Generate circle radii in descending order.\n        Larger circles for border placement, smaller for interior.\n        \n        Returns:\n            List of radii sorted in descending order\n        \"\"\"\n        # Create radii that decrease non-linearly\n        # This ensures good space utilization\n        radii = []\n        for i in range(self.num_circles):\n            # Larger circles first, decreasing exponentially\n            radius = 3.0 * math.exp(-0.08 * i)\n            radii.append(radius)\n        \n        return sorted(radii, reverse=True)\n    \n    def check_collision(self, x: float, y: float, radius: float) -> bool:\n        \"\"\"\n        Check if a circle at (x, y) with given radius collides with existing circles\n        or container boundaries.\n        \n        Args:\n            x: X coordinate of circle center\n            y: Y coordinate of circle center\n            radius: Radius of circle\n            \n        Returns:\n            True if collision detected, False otherwise\n        \"\"\"\n        # Check container boundaries\n        if x - radius < self.padding or x + radius > self.container_size - self.padding:\n            return True\n        if y - radius < self.padding or y + radius > self.container_size - self.padding:\n            return True\n        \n        # Check collision with existing circles\n        for cx, cy, cr in self.circles:\n            distance = math.sqrt((x - cx) ** 2 + (y - cy) ** 2)\n            if distance < radius + cr:\n                return True\n        \n        return False\n    \n    def place_on_border(self, radius: float, border: str, position: float) -> Tuple[float, float, bool]:\n        \"\"\"\n        Try to place a circle on a specific border.\n        \n        Args:\n            radius: Radius of circle\n            border: 'top', 'bottom', 'left', or 'right'\n            position: Position along the border (0 to container_size)\n            \n        Returns:\n            Tuple of (x, y, success) where success indicates placement\n        \"\"\"\n        padding = self.padding + radius\n        \n        if border == 'top':\n            x, y = position, padding\n        elif border == 'bottom':\n            x, y = position, self.container_size - padding\n        elif border == 'left':\n            x, y = padding, position\n        elif border == 'right':\n            x, y = self.container_size - padding, position\n        else:\n            return 0, 0, False\n        \n        # Clamp coordinates to valid range\n        x = max(padding, min(x, self.container_size - padding))\n        y = max(padding, min(y, self.container_size - padding))\n        \n        if not self.check_collision(x, y, radius):\n            return x, y, True\n        \n        return x, y, False\n    \n    def place_on_borders(self, radii: List[float]) -> List[Tuple[float, float, float]]:\n        \"\"\"\n        Place larger circles on the borders of the container.\n        \n        Args:\n            radii: List of radii to place on borders\n            \n        Returns:\n            List of successfully placed circles (x, y, radius)\n        \"\"\"\n        placed = []\n        borders = ['top', 'bottom', 'left', 'right']\n        border_idx = 0\n        \n        for radius in radii:\n            placed_successfully = False\n            \n            # Try each border with multiple positions\n            for _ in range(4):  # Try all 4 borders\n                border = borders[border_idx % 4]\n                \n                # Try multiple positions along the border\n                num_positions = max(3, int(self.container_size / (4 * radius)))\n                for pos_idx in range(num_positions):\n                    position = (pos_idx + 0.5) * self.container_size / num_positions\n                    x, y, success = self.place_on_border(radius, border, position)\n                    \n                    if success:\n                        self.circles.append((x, y, radius))\n                        placed.append((x, y, radius))\n                        placed_successfully = True\n                        break\n                \n                if placed_successfully:\n                    break\n                \n                border_idx += 1\n            \n            if not placed_successfully:\n                # If can't place on border, move to interior placement\n                break\n        \n        return placed\n    \n    def place_in_interior(self, radii: List[float], start_idx: int) -> List[Tuple[float, float, float]]:\n        \"\"\"\n        Place remaining circles in the interior using grid-based search.\n        \n        Args:\n            radii: List of all radii\n            start_idx: Index to start from in radii list\n            \n        Returns:\n            List of successfully placed circles\n        \"\"\"\n        placed = []\n        grid_resolution = 50\n        \n        for idx in range(start_idx, len(radii)):\n            radius = radii[idx]\n            placed_successfully = False\n            \n            # Create a grid of candidate positions\n            step = (self.container_size - 2 * self.padding) / grid_resolution\n            \n            # Randomize grid search for better distribution\n            candidates = []\n            for i in range(grid_resolution):\n                for j in range(grid_resolution):\n                    x = self.padding + (i + 0.5) * step + np.random.uniform(-step/3, step/3)\n                    y = self.padding + (j + 0.5) * step + np.random.uniform(-step/3, step/3)\n                    candidates.append((x, y))\n            \n            # Sort candidates by distance from center (interior preference)\n            center = self.container_size / 2\n            candidates.sort(key=lambda p: math.sqrt((p[0] - center) ** 2 + (p[1] - center) ** 2))\n            \n            # Try to place at each candidate position\n            for x, y in candidates:\n                if not self.check_collision(x, y, radius):\n                    self.circles.append((x, y, radius))\n                    placed.append((x, y, radius))\n                    placed_successfully = True\n                    break\n            \n            if not placed_successfully:\n                # Try random placement as fallback\n                for _ in range(100):\n                    x = np.random.uniform(self.padding + radius, \n                                        self.container_size - self.padding - radius)\n                    y = np.random.uniform(self.padding + radius, \n                                        self.container_size - self.padding - radius)\n                    \n                    if not self.check_collision(x, y, radius):\n                        self.circles.append((x, y, radius))\n                        placed.append((x, y, radius))\n                        placed_successfully = True\n                        break\n        \n        return placed\n    \n    def construct_packing(self) -> bool:\n        \"\"\"\n        Construct the circle packing using border-first approach.\n        \n        Returns:\n            True if all circles were successfully packed, False otherwise\n        \"\"\"\n        self.circles = []\n        \n        # Generate circle sizes\n        radii = self.generate_circle_sizes()\n        print(f\"Generated {len(radii)} circles with radii:\")\n        print(f\"  Min: {min(radii):.3f}, Max: {max(radii):.3f}\")\n        \n        # Phase 1: Place larger circles on borders\n        print(\"\\nPhase 1: Placing circles on borders...\")\n        border_placed = self.place_on_borders(radii[:self.num_circles // 2])\n        print(f\"  Successfully placed {len(border_placed)} circles on borders\")\n        \n        # Phase 2: Fill interior with remaining circles\n        print(\"\\nPhase 2: Filling interior with smaller circles...\")\n        interior_placed = self.place_in_interior(radii, len(border_placed))\n        print(f\"  Successfully placed {len(interior_placed)} circles in interior\")\n        \n        total_placed = len(self.circles)\n        print(f\"\\nTotal circles packed: {total_placed}/{self.num_circles}\")\n        \n        return total_placed == self.num_circles\n    \n    def calculate_statistics(self) -> dict:\n        \"\"\"\n        Calculate packing statistics.\n        \n        Returns:\n            Dictionary containing packing metrics\n        \"\"\"\n        if not self.circles:\n            return {}\n        \n        total_circle_area = sum(math.pi * r ** 2 for _, _, r in self.circles)\n        container_area = self.container_size ** 2\n        packing_efficiency = (total_circle_area / container_area) * 100\n        \n        return {\n            'num_circles': len(self.circles),\n            'total_circle_area': total_circle_area,\n            'container_area': container_area,\n            'packing_efficiency': packing_efficiency,\n            'avg_radius': np.mean([r for _, _, r in self.circles]),\n            'max_radius': max([r for _, _, r in self.circles]),\n            'min_radius': min([r for _, _, r in self.circles]),\n        }\n    \n    def visualize(self, save_path: str = None) -> None:\n        \"\"\"\n        Visualize the circle packing.\n        \n        Args:\n            save_path: Optional path to save the figure\n        \"\"\"\n        if not self.circles:\n            print(\"No circles to visualize. Run construct_packing() first.\")\n            return\n        \n        fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n        \n        # Draw container\n        container = plt.Rectangle((self.padding, self.padding), \n                                 self.container_size - 2 * self.padding,\n                                 self.container_size - 2 * self.padding,\n                                 fill=False, edgecolor='black', linewidth=2)\n        ax.add_patch(container)\n        \n        # Draw circles with color gradient based on radius\n        radii = [r for _, _, r in self.circles]\n        max_radius = max(radii)\n        \n        for x, y, radius in self.circles:\n            # Color based on radius (larger = darker)\n            color_intensity = radius / max_radius\n            circle = Circle((x, y), radius, \n                          fill=True, \n                          facecolor=(1 - color_intensity * 0.7, \n                                   0.5, \n                                   color_intensity),\n                          edgecolor='black', \n                          linewidth=0.5, \n                          alpha=0.7)\n            ax.add_patch(circle)\n            \n            # Add radius label for larger circles\n            if radius > 1.0:\n                ax.text(x, y, f'{radius:.1f}', ha='center', va='center', \n                       fontsize=6, fontweight='bold')\n        \n        # Set axis properties\n        ax.set_xlim(0, self.container_size)\n        ax.set_ylim(0, self.container_size)\n        ax.set_aspect('equal')\n        ax.invert_yaxis()\n        ax.set_title(f'Circle Packing: {len(self.circles)}/{self.num_circles} circles', \n                    fontsize=14, fontweight='bold')\n        \n        # Add statistics to plot\n        stats = self.calculate_statistics()\n        stats_text = f\"Packing Efficiency: {stats['packing_efficiency']:.1f}%\\n\"\n        stats_text += f\"Avg Radius: {stats['avg_radius']:.2f}\"\n        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, \n               verticalalignment='top', bbox=dict(boxstyle='round', \n               facecolor='wheat', alpha=0.8), fontsize=10)\n        \n        plt.tight_layout()\n        \n        if save_path:\n            plt.savefig(save_path, dpi=150, bbox_inches='tight')\n            print(f\"Figure saved to {save_path}\")\n        \n        plt.show()\n\n\ndef construct_packing(container_size: float = 100.0, \n                     num_circles: int = 26) -> CirclePacking:\n    \"\"\"\n    Construct a circle packing solution.\n    \n    Args:\n        container_size: Size of the square container\n        num_circles: Number of circles to pack\n        \n    Returns:\n        CirclePacking object with packed circles\n    \"\"\"\n    packing = CirclePacking(container_size, num_circles)\n    packing.construct_packing()\n    return packing\n\n\ndef run_packing(container_size: float = 100.0, \n               num_circles: int = 26,\n               visualize: bool = True,\n               save_path: str = None) -> dict:\n    \"\"\"\n    Run the complete circle packing algorithm and return results.\n    \n    Args:\n        container_size: Size of the square container\n        num_circles: Number of circles to pack\n        visualize: Whether to display the visualization\n        save_path: Optional path to save the figure\n        \n    Returns:\n        Dictionary containing packing results and statistics\n    \"\"\"\n    print(\"=\" * 60)\n    print(f\"Circle Packing Algorithm (Border-First Approach)\")\n    print(f\"Container Size: {container_size}x{container_size}\")\n    print(f\"Target Circles: {num_circles}\")\n    print(\"=\" * 60)\n    \n    # Construct packing\n    packing = construct_packing(container_size, num_circles)\n    \n    # Get statistics\n    stats = packing.calculate_statistics()\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"RESULTS\")\n    print(\"=\" * 60)\n    print(f\"Circles Packed: {stats['num_circles']}/{num_circles}\")\n    print(f\"Packing Efficiency: {stats['packing_efficiency']:.2f}%\")\n    print(f\"Total Circle Area: {stats['total_circle_area']:.2f}\")\n    print(f\"Container Area: {stats['container_area']:.2f}\")\n    print(f\"Average Radius: {stats['avg_radius']:.3f}\")\n    print(f\"Radius Range: [{stats['min_radius']:.3f}, {stats['max_radius']:.3f}]\")\n    print(\"=\" * 60)\n    \n    # Visualize\n    if visualize:\n        packing.visualize(save_path)\n    \n    return {\n        'packing': packing,\n        'circles': packing.circles,\n        'statistics': stats\n    }\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Run the packing algorithm\n    results = run_packing(\n        container_size=100.0,\n        num_circles=26,\n        visualize=True,\n        save_path=\"circle_packing.png\"\n    )\n    \n    # Access individual circles\n    print(\"\\nFirst 5 circles (x, y, radius):\")\n    for i, (x, y, r) in enumerate(results['circles'][:5]):\n        print(f\"  Circle {i+1}: ({x:.2f}, {y:.2f}, {r:.2f})\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 4.9758501052856445,
    "error": "ValueError: could not convert string to float: 'statistics'"
  },
  "prompt": "Write a circle packing algorithm for 26 circles using a border-first approach. Place larger circles near the borders of the square to utilize space efficiently, then fill interior with smaller circles. Include construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom typing import List, Tuple\nimport math\n\nclass CirclePacking:\n    \"\"\"\n    Circle packing algorithm using border-first approach.\n    Larger circles are placed near borders, smaller circles fill interior.\n    \"\"\"\n    \n    def __init__(self, container_size: float = 100.0, num_circles: int = 26):\n        \"\"\"\n        Initialize circle packing problem.\n        \n        Args:\n            container_size: Size of the square container (width/height)\n            num_circles: Number of circles to pack\n        \"\"\"\n        self.container_size = container_size\n        self.num_circles = num_circles\n        self.circles = []  # List of (x, y, radius) tuples\n        self.padding = 1.0  # Minimum padding from borders\n        \n    def generate_circle_sizes(self) -> List[float]:\n        \"\"\"\n        Generate circle radii in descending order.\n        Larger circles for border placement, smaller for interior.\n        \n        Returns:\n            List of radii sorted in descending order\n        \"\"\"\n        # Create radii that decrease non-linearly\n        # This ensures good space utilization\n        radii = []\n        for i in range(self.num_circles):\n            # Larger circles first, decreasing exponentially\n            radius = 3.0 * math.exp(-0.08 * i)\n            radii.append(radius)\n        \n        return sorted(radii, reverse=True)\n    \n    def check_collision(self, x: float, y: float, radius: float) -> bool:\n        \"\"\"\n        Check if a circle at (x, y) with given radius collides with existing circles\n        or container boundaries.\n        \n        Args:\n            x: X coordinate of circle center\n            y: Y coordinate of circle center\n            radius: Radius of circle\n            \n        Returns:\n            True if collision detected, False otherwise\n        \"\"\"\n        # Check container boundaries\n        if x - radius < self.padding or x + radius > self.container_size - self.padding:\n            return True\n        if y - radius < self.padding or y + radius > self.container_size - self.padding:\n            return True\n        \n        # Check collision with existing circles\n        for cx, cy, cr in self.circles:\n            distance = math.sqrt((x - cx) ** 2 + (y - cy) ** 2)\n            if distance < radius + cr:\n                return True\n        \n        return False\n    \n    def place_on_border(self, radius: float, border: str, position: float) -> Tuple[float, float, bool]:\n        \"\"\"\n        Try to place a circle on a specific border.\n        \n        Args:\n            radius: Radius of circle\n            border: 'top', 'bottom', 'left', or 'right'\n            position: Position along the border (0 to container_size)\n            \n        Returns:\n            Tuple of (x, y, success) where success indicates placement\n        \"\"\"\n        padding = self.padding + radius\n        \n        if border == 'top':\n            x, y = position, padding\n        elif border == 'bottom':\n            x, y = position, self.container_size - padding\n        elif border == 'left':\n            x, y = padding, position\n        elif border == 'right':\n            x, y = self.container_size - padding, position\n        else:\n            return 0, 0, False\n        \n        # Clamp coordinates to valid range\n        x = max(padding, min(x, self.container_size - padding))\n        y = max(padding, min(y, self.container_size - padding))\n        \n        if not self.check_collision(x, y, radius):\n            return x, y, True\n        \n        return x, y, False\n    \n    def place_on_borders(self, radii: List[float]) -> List[Tuple[float, float, float]]:\n        \"\"\"\n        Place larger circles on the borders of the container.\n        \n        Args:\n            radii: List of radii to place on borders\n            \n        Returns:\n            List of successfully placed circles (x, y, radius)\n        \"\"\"\n        placed = []\n        borders = ['top', 'bottom', 'left', 'right']\n        border_idx = 0\n        \n        for radius in radii:\n            placed_successfully = False\n            \n            # Try each border with multiple positions\n            for _ in range(4):  # Try all 4 borders\n                border = borders[border_idx % 4]\n                \n                # Try multiple positions along the border\n                num_positions = max(3, int(self.container_size / (4 * radius)))\n                for pos_idx in range(num_positions):\n                    position = (pos_idx + 0.5) * self.container_size / num_positions\n                    x, y, success = self.place_on_border(radius, border, position)\n                    \n                    if success:\n                        self.circles.append((x, y, radius))\n                        placed.append((x, y, radius))\n                        placed_successfully = True\n                        break\n                \n                if placed_successfully:\n                    break\n                \n                border_idx += 1\n            \n            if not placed_successfully:\n                # If can't place on border, move to interior placement\n                break\n        \n        return placed\n    \n    def place_in_interior(self, radii: List[float], start_idx: int) -> List[Tuple[float, float, float]]:\n        \"\"\"\n        Place remaining circles in the interior using grid-based search.\n        \n        Args:\n            radii: List of all radii\n            start_idx: Index to start from in radii list\n            \n        Returns:\n            List of successfully placed circles\n        \"\"\"\n        placed = []\n        grid_resolution = 50\n        \n        for idx in range(start_idx, len(radii)):\n            radius = radii[idx]\n            placed_successfully = False\n            \n            # Create a grid of candidate positions\n            step = (self.container_size - 2 * self.padding) / grid_resolution\n            \n            # Randomize grid search for better distribution\n            candidates = []\n            for i in range(grid_resolution):\n                for j in range(grid_resolution):\n                    x = self.padding + (i + 0.5) * step + np.random.uniform(-step/3, step/3)\n                    y = self.padding + (j + 0.5) * step + np.random.uniform(-step/3, step/3)\n                    candidates.append((x, y))\n            \n            # Sort candidates by distance from center (interior preference)\n            center = self.container_size / 2\n            candidates.sort(key=lambda p: math.sqrt((p[0] - center) ** 2 + (p[1] - center) ** 2))\n            \n            # Try to place at each candidate position\n            for x, y in candidates:\n                if not self.check_collision(x, y, radius):\n                    self.circles.append((x, y, radius))\n                    placed.append((x, y, radius))\n                    placed_successfully = True\n                    break\n            \n            if not placed_successfully:\n                # Try random placement as fallback\n                for _ in range(100):\n                    x = np.random.uniform(self.padding + radius, \n                                        self.container_size - self.padding - radius)\n                    y = np.random.uniform(self.padding + radius, \n                                        self.container_size - self.padding - radius)\n                    \n                    if not self.check_collision(x, y, radius):\n                        self.circles.append((x, y, radius))\n                        placed.append((x, y, radius))\n                        placed_successfully = True\n                        break\n        \n        return placed\n    \n    def construct_packing(self) -> bool:\n        \"\"\"\n        Construct the circle packing using border-first approach.\n        \n        Returns:\n            True if all circles were successfully packed, False otherwise\n        \"\"\"\n        self.circles = []\n        \n        # Generate circle sizes\n        radii = self.generate_circle_sizes()\n        print(f\"Generated {len(radii)} circles with radii:\")\n        print(f\"  Min: {min(radii):.3f}, Max: {max(radii):.3f}\")\n        \n        # Phase 1: Place larger circles on borders\n        print(\"\\nPhase 1: Placing circles on borders...\")\n        border_placed = self.place_on_borders(radii[:self.num_circles // 2])\n        print(f\"  Successfully placed {len(border_placed)} circles on borders\")\n        \n        # Phase 2: Fill interior with remaining circles\n        print(\"\\nPhase 2: Filling interior with smaller circles...\")\n        interior_placed = self.place_in_interior(radii, len(border_placed))\n        print(f\"  Successfully placed {len(interior_placed)} circles in interior\")\n        \n        total_placed = len(self.circles)\n        print(f\"\\nTotal circles packed: {total_placed}/{self.num_circles}\")\n        \n        return total_placed == self.num_circles\n    \n    def calculate_statistics(self) -> dict:\n        \"\"\"\n        Calculate packing statistics.\n        \n        Returns:\n            Dictionary containing packing metrics\n        \"\"\"\n        if not self.circles:\n            return {}\n        \n        total_circle_area = sum(math.pi * r ** 2 for _, _, r in self.circles)\n        container_area = self.container_size ** 2\n        packing_efficiency = (total_circle_area / container_area) * 100\n        \n        return {\n            'num_circles': len(self.circles),\n            'total_circle_area': total_circle_area,\n            'container_area': container_area,\n            'packing_efficiency': packing_efficiency,\n            'avg_radius': np.mean([r for _, _, r in self.circles]),\n            'max_radius': max([r for _, _, r in self.circles]),\n            'min_radius': min([r for _, _, r in self.circles]),\n        }\n    \n    def visualize(self, save_path: str = None) -> None:\n        \"\"\"\n        Visualize the circle packing.\n        \n        Args:\n            save_path: Optional path to save the figure\n        \"\"\"\n        if not self.circles:\n            print(\"No circles to visualize. Run construct_packing() first.\")\n            return\n        \n        fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n        \n        # Draw container\n        container = plt.Rectangle((self.padding, self.padding), \n                                 self.container_size - 2 * self.padding,\n                                 self.container_size - 2 * self.padding,\n                                 fill=False, edgecolor='black', linewidth=2)\n        ax.add_patch(container)\n        \n        # Draw circles with color gradient based on radius\n        radii = [r for _, _, r in self.circles]\n        max_radius = max(radii)\n        \n        for x, y, radius in self.circles:\n            # Color based on radius (larger = darker)\n            color_intensity = radius / max_radius\n            circle = Circle((x, y), radius, \n                          fill=True, \n                          facecolor=(1 - color_intensity * 0.7, \n                                   0.5, \n                                   color_intensity),\n                          edgecolor='black', \n                          linewidth=0.5, \n                          alpha=0.7)\n            ax.add_patch(circle)\n            \n            # Add radius label for larger circles\n            if radius > 1.0:\n                ax.text(x, y, f'{radius:.1f}', ha='center', va='center', \n                       fontsize=6, fontweight='bold')\n        \n        # Set axis properties\n        ax.set_xlim(0, self.container_size)\n        ax.set_ylim(0, self.container_size)\n        ax.set_aspect('equal')\n        ax.invert_yaxis()\n        ax.set_title(f'Circle Packing: {len(self.circles)}/{self.num_circles} circles', \n                    fontsize=14, fontweight='bold')\n        \n        # Add statistics to plot\n        stats = self.calculate_statistics()\n        stats_text = f\"Packing Efficiency: {stats['packing_efficiency']:.1f}%\\n\"\n        stats_text += f\"Avg Radius: {stats['avg_radius']:.2f}\"\n        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, \n               verticalalignment='top', bbox=dict(boxstyle='round', \n               facecolor='wheat', alpha=0.8), fontsize=10)\n        \n        plt.tight_layout()\n        \n        if save_path:\n            plt.savefig(save_path, dpi=150, bbox_inches='tight')\n            print(f\"Figure saved to {save_path}\")\n        \n        plt.show()\n\n\ndef construct_packing(container_size: float = 100.0, \n                     num_circles: int = 26) -> CirclePacking:\n    \"\"\"\n    Construct a circle packing solution.\n    \n    Args:\n        container_size: Size of the square container\n        num_circles: Number of circles to pack\n        \n    Returns:\n        CirclePacking object with packed circles\n    \"\"\"\n    packing = CirclePacking(container_size, num_circles)\n    packing.construct_packing()\n    return packing\n\n\ndef run_packing(container_size: float = 100.0, \n               num_circles: int = 26,\n               visualize: bool = True,\n               save_path: str = None) -> dict:\n    \"\"\"\n    Run the complete circle packing algorithm and return results.\n    \n    Args:\n        container_size: Size of the square container\n        num_circles: Number of circles to pack\n        visualize: Whether to display the visualization\n        save_path: Optional path to save the figure\n        \n    Returns:\n        Dictionary containing packing results and statistics\n    \"\"\"\n    print(\"=\" * 60)\n    print(f\"Circle Packing Algorithm (Border-First Approach)\")\n    print(f\"Container Size: {container_size}x{container_size}\")\n    print(f\"Target Circles: {num_circles}\")\n    print(\"=\" * 60)\n    \n    # Construct packing\n    packing = construct_packing(container_size, num_circles)\n    \n    # Get statistics\n    stats = packing.calculate_statistics()\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"RESULTS\")\n    print(\"=\" * 60)\n    print(f\"Circles Packed: {stats['num_circles']}/{num_circles}\")\n    print(f\"Packing Efficiency: {stats['packing_efficiency']:.2f}%\")\n    print(f\"Total Circle Area: {stats['total_circle_area']:.2f}\")\n    print(f\"Container Area: {stats['container_area']:.2f}\")\n    print(f\"Average Radius: {stats['avg_radius']:.3f}\")\n    print(f\"Radius Range: [{stats['min_radius']:.3f}, {stats['max_radius']:.3f}]\")\n    print(\"=\" * 60)\n    \n    # Visualize\n    if visualize:\n        packing.visualize(save_path)\n    \n    return {\n        'packing': packing,\n        'circles': packing.circles,\n        'statistics': stats\n    }\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Run the packing algorithm\n    results = run_packing(\n        container_size=100.0,\n        num_circles=26,\n        visualize=True,\n        save_path=\"circle_packing.png\"\n    )\n    \n    # Access individual circles\n    print(\"\\nFirst 5 circles (x, y, radius):\")\n    for i, (x, y, r) in enumerate(results['circles'][:5]):\n        print(f\"  Circle {i+1}: ({x:.2f}, {y:.2f}, {r:.2f})\")\n```\n\nThis implementation provides:\n\n**Key Features:**\n\n1. **Border-First Placement**: Larger circles are placed on container borders first\n2. **Interior Filling**: Smaller circles fill the interior using grid-based search\n3. **Collision Detection**: Ensures no overlapping circles\n4. **Flexible Sizing**: Exponentially decreasing circle radii for realistic p",
  "reasoning": "This implementation provides:\n\n**Key Features:**\n\n1. **Border-First Placement**: Larger circles are placed on container borders first\n2. **Interior Filling**: Smaller circles fill the interior using grid-based search\n3. **Collision Detection**: Ensures no overlapping circles\n4. **Flexible Sizing**: Exponentially decreasing circle radii for realistic p",
  "timestamp": "2025-12-08T12:15:40.035360",
  "cost_data": null
}