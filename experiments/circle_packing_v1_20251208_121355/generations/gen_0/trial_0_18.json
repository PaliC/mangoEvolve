{
  "trial_id": "trial_0_18",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a circle packing algorithm for 26 circles using a hybrid approach combining grid placement with local optimization. Place circles in an optimal grid configuration, then use local search (hill climbing or simulated annealing) to refine positions and maximize radii. Include construct_packing() and run_packing() functions.",
  "response": "# Circle Packing Algorithm with Hybrid Approach\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial.distance import cdist\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport math\nimport random\nfrom copy import deepcopy\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with position and radius\"\"\"\n    x: float\n    y: float\n    radius: float\n    \n    def distance_to(self, other: 'Circle') -> float:\n        \"\"\"Calculate distance between circle centers\"\"\"\n        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n    \n    def overlaps_with(self, other: 'Circle', tolerance: float = 1e-6) -> bool:\n        \"\"\"Check if this circle overlaps with another\"\"\"\n        min_distance = self.radius + other.radius - tolerance\n        return self.distance_to(other) < min_distance\n    \n    def copy(self) -> 'Circle':\n        \"\"\"Create a deep copy of the circle\"\"\"\n        return Circle(self.x, self.y, self.radius)\n\n\nclass CirclePacking:\n    \"\"\"Circle packing solver using hybrid grid + local optimization approach\"\"\"\n    \n    def __init__(self, num_circles: int = 26, container_size: float = 100.0):\n        \"\"\"\n        Initialize circle packing problem\n        \n        Args:\n            num_circles: Number of circles to pack\n            container_size: Size of the square container\n        \"\"\"\n        self.num_circles = num_circles\n        self.container_size = container_size\n        self.circles: List[Circle] = []\n        self.best_circles: List[Circle] = []\n        self.best_fitness = -float('inf')\n        self.history = []\n        \n    def construct_packing(self) -> List[Circle]:\n        \"\"\"\n        Construct initial packing using grid-based placement\n        \n        Returns:\n            List of Circle objects in grid configuration\n        \"\"\"\n        circles = []\n        \n        # Calculate grid dimensions\n        grid_size = math.ceil(math.sqrt(self.num_circles))\n        \n        # Initial radius based on grid\n        cell_size = self.container_size / grid_size\n        initial_radius = cell_size * 0.4\n        \n        # Place circles in grid pattern\n        circle_index = 0\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if circle_index >= self.num_circles:\n                    break\n                \n                # Add slight randomization to grid positions\n                x = (i + 0.5) * cell_size + random.uniform(-cell_size * 0.1, cell_size * 0.1)\n                y = (j + 0.5) * cell_size + random.uniform(-cell_size * 0.1, cell_size * 0.1)\n                \n                # Clamp to container\n                x = np.clip(x, initial_radius, self.container_size - initial_radius)\n                y = np.clip(y, initial_radius, self.container_size - initial_radius)\n                \n                circles.append(Circle(x, y, initial_radius))\n                circle_index += 1\n        \n        self.circles = circles\n        return circles\n    \n    def calculate_fitness(self, circles: List[Circle]) -> float:\n        \"\"\"\n        Calculate fitness score (sum of radii - penalty for overlaps)\n        \n        Args:\n            circles: List of circles to evaluate\n            \n        Returns:\n            Fitness score (higher is better)\n        \"\"\"\n        # Base fitness: sum of radii\n        fitness = sum(circle.radius for circle in circles)\n        \n        # Penalty for overlaps\n        overlap_penalty = 0.0\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                if circles[i].overlaps_with(circles[j]):\n                    dist = circles[i].distance_to(circles[j])\n                    overlap = circles[i].radius + circles[j].radius - dist\n                    overlap_penalty += overlap ** 2\n        \n        # Penalty for circles outside container\n        boundary_penalty = 0.0\n        for circle in circles:\n            if circle.x - circle.radius < 0:\n                boundary_penalty += (circle.radius - circle.x) ** 2\n            if circle.x + circle.radius > self.container_size:\n                boundary_penalty += (circle.x + circle.radius - self.container_size) ** 2\n            if circle.y - circle.radius < 0:\n                boundary_penalty += (circle.radius - circle.y) ** 2\n            if circle.y + circle.radius > self.container_size:\n                boundary_penalty += (circle.y + circle.radius - self.container_size) ** 2\n        \n        return fitness - 10.0 * overlap_penalty - 5.0 * boundary_penalty\n    \n    def expand_circles(self, circles: List[Circle]) -> List[Circle]:\n        \"\"\"\n        Expand circles to maximum non-overlapping radius\n        \n        Args:\n            circles: List of circles to expand\n            \n        Returns:\n            List of expanded circles\n        \"\"\"\n        expanded = [circle.copy() for circle in circles]\n        \n        for circle in expanded:\n            # Find maximum radius without overlapping\n            max_radius = self.container_size\n            \n            # Constraint from container boundaries\n            max_radius = min(\n                max_radius,\n                circle.x,\n                circle.y,\n                self.container_size - circle.x,\n                self.container_size - circle.y\n            )\n            \n            # Constraint from other circles\n            for other in expanded:\n                if other is circle:\n                    continue\n                dist = circle.distance_to(other)\n                max_radius = min(max_radius, dist - other.radius)\n            \n            circle.radius = max(circle.radius, max_radius * 0.95)\n        \n        return expanded\n    \n    def local_search_hill_climbing(self, circles: List[Circle], \n                                   max_iterations: int = 1000,\n                                   step_size: float = 2.0) -> List[Circle]:\n        \"\"\"\n        Optimize circle positions and radii using hill climbing\n        \n        Args:\n            circles: Initial circle configuration\n            max_iterations: Maximum number of iterations\n            step_size: Initial step size for position adjustments\n            \n        Returns:\n            Optimized circle configuration\n        \"\"\"\n        current = [circle.copy() for circle in circles]\n        current_fitness = self.calculate_fitness(current)\n        \n        for iteration in range(max_iterations):\n            improved = False\n            \n            # Try adjusting each circle\n            for i, circle in enumerate(current):\n                best_neighbor = circle.copy()\n                best_neighbor_fitness = current_fitness\n                \n                # Try different moves\n                moves = [\n                    (step_size, 0, 0),      # Move right\n                    (-step_size, 0, 0),     # Move left\n                    (0, step_size, 0),      # Move up\n                    (0, -step_size, 0),     # Move down\n                    (0, 0, step_size * 0.5),    # Increase radius\n                    (0, 0, -step_size * 0.5),   # Decrease radius\n                ]\n                \n                for dx, dy, dr in moves:\n                    neighbor = circle.copy()\n                    neighbor.x += dx\n                    neighbor.y += dy\n                    neighbor.radius += dr\n                    \n                    # Ensure circle stays in bounds and has positive radius\n                    neighbor.x = np.clip(neighbor.x, neighbor.radius, \n                                        self.container_size - neighbor.radius)\n                    neighbor.y = np.clip(neighbor.y, neighbor.radius, \n                                        self.container_size - neighbor.radius)\n                    neighbor.radius = max(0.1, neighbor.radius)\n                    \n                    # Evaluate neighbor\n                    test_circles = current.copy()\n                    test_circles[i] = neighbor\n                    neighbor_fitness = self.calculate_fitness(test_circles)\n                    \n                    if neighbor_fitness > best_neighbor_fitness:\n                        best_neighbor = neighbor\n                        best_neighbor_fitness = neighbor_fitness\n                        improved = True\n                \n                if improved:\n                    current[i] = best_neighbor\n                    current_fitness = best_neighbor_fitness\n            \n            # Reduce step size over time\n            step_size *= 0.98\n            \n            # Expand circles periodically\n            if iteration % 100 == 0:\n                current = self.expand_circles(current)\n                current_fitness = self.calculate_fitness(current)\n            \n            self.history.append(current_fitness)\n            \n            if not improved or iteration % 200 == 0:\n                if current_fitness > self.best_fitness:\n                    self.best_fitness = current_fitness\n                    self.best_circles = [circle.copy() for circle in current]\n        \n        return current\n    \n    def local_search_simulated_annealing(self, circles: List[Circle],\n                                        max_iterations: int = 2000,\n                                        initial_temp: float = 50.0,\n                                        cooling_rate: float = 0.995) -> List[Circle]:\n        \"\"\"\n        Optimize circle positions and radii using simulated annealing\n        \n        Args:\n            circles: Initial circle configuration\n            max_iterations: Maximum number of iterations\n            initial_temp: Initial temperature\n            cooling_rate: Temperature cooling rate\n            \n        Returns:\n            Optimized circle configuration\n        \"\"\"\n        current = [circle.copy() for circle in circles]\n        current_fitness = self.calculate_fitness(current)\n        \n        best = [circle.copy() for circle in current]\n        best_fitness = current_fitness\n        \n        temperature = initial_temp\n        \n        for iteration in range(max_iterations):\n            # Select random circle to modify\n            i = random.randint(0, len(current) - 1)\n            circle = current[i]\n            \n            # Generate neighbor solution\n            neighbor = circle.copy()\n            \n            # Random move type\n            move_type = random.choice(['position', 'radius'])\n            \n            if move_type == 'position':\n                step_size = temperature * 0.5\n                neighbor.x += random.uniform(-step_size, step_size)\n                neighbor.y += random.uniform(-step_size, step_size)\n            else:\n                step_size = temperature * 0.1\n                neighbor.radius += random.uniform(-step_size, step_size)\n            \n            # Enforce constraints\n            neighbor.x = np.clip(neighbor.x, neighbor.radius, \n                                self.container_size - neighbor.radius)\n            neighbor.y = np.clip(neighbor.y, neighbor.radius, \n                                self.container_size - neighbor.radius)\n            neighbor.radius = max(0.1, neighbor.radius)\n            \n            # Evaluate neighbor\n            test_circles = current.copy()\n            test_circles[i] = neighbor\n            neighbor_fitness = self.calculate_fitness(test_circles)\n            \n            # Acceptance probability\n            delta = neighbor_fitness - current_fitness\n            if delta > 0 or random.random() < math.exp(delta / (temperature + 1e-10)):\n                current[i] = neighbor\n                current_fitness = neighbor_fitness\n                \n                if current_fitness > best_fitness:\n                    best = [circle.copy() for circle in current]\n                    best_fitness = current_fitness\n            \n            # Cool down\n            temperature *= cooling_rate\n            \n            # Expand circles periodically\n            if iteration % 100 == 0:\n                current = self.expand_circles(current)\n                current_fitness = self.calculate_fitness(current)\n            \n            self.history.append(current_fitness)\n        \n        self.best_circles = best\n        self.best_fitness = best_fitness\n        \n        return best\n    \n    def run_packing(self, method: str = 'hybrid', \n                   max_iterations: int = 2000) -> List[Circle]:\n        \"\"\"\n        Run the complete circle packing algorithm\n        \n        Args:\n            method: 'hill_climbing', 'simulated_annealing', or 'hybrid'\n            max_iterations: Maximum iterations for optimization\n            \n        Returns:\n            List of optimally packed circles\n        \"\"\"\n        print(f\"Starting circle packing with {self.num_circles} circles...\")\n        print(f\"Container size: {self.container_size}x{self.container_size}\")\n        \n        # Step 1: Construct initial grid packing\n        print(\"\\n1. Constructing initial grid packing...\")\n        self.construct_packing()\n        initial_fitness = self.calculate_fitness(self.circles)\n        print(f\"   Initial fitness: {initial_fitness:.2f}\")\n        \n        # Step 2: Expand circles\n        print(\"\\n2. Expanding circles to maximum non-overlapping size...\")\n        self.circles = self.expand_circles(self.circles)\n        expanded_fitness = self.calculate_fitness(self.circles)\n        print(f\"   Fitness after expansion: {expanded_fitness:.2f}\")\n        \n        # Step 3: Local optimization\n        print(f\"\\n3. Running local optimization ({method})...\")\n        if method == 'hill_climbing':\n            self.circles = self.local_search_hill_climbing(self.circles, max_iterations)\n        elif method == 'simulated_annealing':\n            self.circles = self.local_search_simulated_annealing(self.circles, max_iterations)\n        elif method == 'hybrid':\n            # Combine both methods\n            print(\"   Phase 1: Hill climbing...\")\n            self.circles = self.local_search_hill_climbing(self.circles, max_iterations // 2)\n            print(\"   Phase 2: Simulated annealing...\")\n            self.circles = self.local_search_simulated_annealing(self.circles, max_iterations // 2)\n        \n        print(f\"\\n   Final fitness: {self.best_fitness:.2f}\")\n        print(f\"   Total radius sum: {sum(c.radius for c in self.best_circles):.2f}\")\n        \n        return self.best_circles\n    \n    def visualize(self, title: str = \"Circle Packing Solution\", figsize: Tuple[int, int] = (12, 5)):\n        \"\"\"\n        Visualize the circle packing solution\n        \n        Args:\n            title: Title for the plot\n            figsize: Figure size (width, height)\n        \"\"\"\n        fig, axes = plt.subplots(1, 2, figsize=figsize)\n        \n        # Plot 1: Circle packing\n        ax = axes[0]\n        ax.set_xlim(-5, self.container_size + 5)\n        ax.set_ylim(-5, self.container_size + 5)\n        ax.set_aspect('equal')\n        ax.set_title(f'{title}\\n(Total Radius: {sum(c.radius for c in self.best_circles):.2f})')\n        \n        # Draw container\n        rect = plt.Rectangle((0, 0), self.container_size, self.container_size, \n                            fill=False, edgecolor='black', linewidth=2)\n        ax.add_patch(rect)\n        \n        # Draw circles\n        colors = plt.cm.hsv(np.linspace(0, 1, len(self.best_circles)))\n        for i, circle in enumerate(self.best_circles):\n            circle_patch = plt.Circle((circle.x, circle.y), circle.radius, \n                                     color=colors[i], alpha=0.6, edgecolor='black', linewidth=1)\n            ax.add_patch(circle_patch)\n            ax.text(circle.x, circle.y, str(i+1), ha='center', va='center', \n                   fontsize=8, fontweight='bold')\n        \n        ax.grid(True, alpha=0.3)\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        \n        # Plot 2: Fitness history\n        ax = axes[1]\n        ax.plot(self.history, linewidth=2)\n        ax.set_title('Optimization Progress')\n        ax.set_xlabel('Iteration')\n        ax.set_ylabel('Fitness Score')\n        ax.grid(True, alpha=0.3)\n        \n        plt.tight_layout()\n        return fig",
  "reasoning": "# Circle Packing Algorithm with Hybrid Approach\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial.distance import cdist\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport math\nimport random\nfrom copy import deepcopy\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with position and radius\"\"\"\n    x: float\n    y: float\n    radius: float\n    \n    def distance_to(self, other: 'Circle') -> float:\n        \"\"\"Calculate distance between circle centers\"\"\"\n        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n    \n    def overlaps_with(self, other: 'Circle', tolerance: float = 1e-6) -> bool:\n        \"\"\"Check if this circle overlaps with another\"\"\"\n        min_distance = self.radius + other.radius - tolerance\n        return self.distance_to(other) < min_distance\n    \n    def copy(self) -> 'Circle':\n        \"\"\"Create a deep copy of the circle\"\"\"\n        return Circle(self.x, self.y, self.radius)\n\nclass CirclePacking:\n    \"\"\"Circle packing solver using hybrid grid + local optimization approach\"\"\"\n    \n    def __init__(self, num_circles: int = 26, container_size: float = 100.0):\n        \"\"\"\n        Initialize circle packing problem\n        \n        Args:\n            num_circles: Number of circles to pack\n            container_size: Size of the square container\n        \"\"\"\n        self.num_circles = num_circles\n        self.container_size = container_size\n        self.circles: List[Circle] = []\n        self.best_circles: List[Circle] = []\n        self.best_fitness = -float('inf')\n        self.history = []\n        \n    def construct_packing(self) -> List[Circle]:\n        \"\"\"\n        Construct initial packing using grid-based placement\n        \n        Returns:\n            List of Circle objects in grid configuration\n        \"\"\"\n        circles = []\n        \n        # Calculate grid dimensions\n        grid_size = math.ceil(math.sqrt(self.num_circles))\n        \n        # Initial radius based on grid\n        cell_size = self.container_size / grid_size\n        initial_radius = cell_size * 0.4\n        \n        # Place circles in grid pattern\n        circle_index = 0\n        for i in range(grid_size):\n            for j in range(grid_size):\n                if circle_index >= self.num_circles:\n                    break\n                \n                # Add slight randomization to grid positions\n                x = (i + 0.5) * cell_size + random.uniform(-cell_size * 0.1, cell_size * 0.1)\n                y = (j + 0.5) * cell_size + random.uniform(-cell_size * 0.1, cell_size * 0.1)\n                \n                # Clamp to container\n                x = np.clip(x, initial_radius, self.container_size - initial_radius)\n                y = np.clip(y, initial_radius, self.container_size - initial_radius)\n                \n                circles.append(Circle(x, y, initial_radius))\n                circle_index += 1\n        \n        self.circles = circles\n        return circles\n    \n    def calculate_fitness(self, circles: List[Circle]) -> float:\n        \"\"\"\n        Calculate fitness score (sum of radii - penalty for overlaps)\n        \n        Args:\n            circles: List of circles to evaluate\n            \n        Returns:\n            Fitness score (higher is better)\n        \"\"\"\n        # Base fitness: sum of radii\n        fitness = sum(circle.radius for circle in circles)\n        \n        # Penalty for overlaps\n        overlap_penalty = 0.0\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                if circles[i].overlaps_with(circles[j]):\n                    dist = circles[i].distance_to(circles[j])\n                    overlap = circles[i].radius + circles[j].radius - dist\n                    overlap_penalty += overlap ** 2\n        \n        # Penalty for circles outside container\n        boundary_penalty = 0.0\n        for circle in circles:\n            if circle.x - circle.radius < 0:\n                boundary_penalty += (circle.radius - circle.x) ** 2\n            if circle.x + circle.radius > self.container_size:\n                boundary_penalty += (circle.x + circle.radius - self.container_size) ** 2\n            if circle.y - circle.radius < 0:\n                boundary_penalty += (circle.radius - circle.y) ** 2\n            if circle.y + circle.radius > self.container_size:\n                boundary_penalty += (circle.y + circle.radius - self.container_size) ** 2\n        \n        return fitness - 10.0 * overlap_penalty - 5.0 * boundary_penalty\n    \n    def expand_circles(self, circles: List[Circle]) -> List[Circle]:\n        \"\"\"\n        Expand circles to maximum non-overlapping radius\n        \n        Args:\n            circles: List of circles to expand\n            \n        Returns:\n            List of expanded circles\n        \"\"\"\n        expanded = [circle.copy() for circle in circles]\n        \n        for circle in expanded:\n            # Find maximum radius without overlapping\n            max_radius = self.container_size\n            \n            # Constraint from container boundaries\n            max_radius = min(\n                max_radius,\n                circle.x,\n                circle.y,\n                self.container_size - circle.x,\n                self.container_size - circle.y\n            )\n            \n            # Constraint from other circles\n            for other in expanded:\n                if other is circle:\n                    continue\n                dist = circle.distance_to(other)\n                max_radius = min(max_radius, dist - other.radius)\n            \n            circle.radius = max(circle.radius, max_radius * 0.95)\n        \n        return expanded\n    \n    def local_search_hill_climbing(self, circles: List[Circle], \n                                   max_iterations: int = 1000,\n                                   step_size: float = 2.0) -> List[Circle]:\n        \"\"\"\n        Optimize circle positions and radii using hill climbing\n        \n        Args:\n            circles: Initial circle configuration\n            max_iterations: Maximum number of iterations\n            step_size: Initial step size for position adjustments\n            \n        Returns:\n            Optimized circle configuration\n        \"\"\"\n        current = [circle.copy() for circle in circles]\n        current_fitness = self.calculate_fitness(current)\n        \n        for iteration in range(max_iterations):\n            improved = False\n            \n            # Try adjusting each circle\n            for i, circle in enumerate(current):\n                best_neighbor = circle.copy()\n                best_neighbor_fitness = current_fitness\n                \n                # Try different moves\n                moves = [\n                    (step_size, 0, 0),      # Move right\n                    (-step_size, 0, 0),     # Move left\n                    (0, step_size, 0),      # Move up\n                    (0, -step_size, 0),     # Move down\n                    (0, 0, step_size * 0.5),    # Increase radius\n                    (0, 0, -step_size * 0.5),   # Decrease radius\n                ]\n                \n                for dx, dy, dr in moves:\n                    neighbor = circle.copy()\n                    neighbor.x += dx\n                    neighbor.y += dy\n                    neighbor.radius += dr\n                    \n                    # Ensure circle stays in bounds and has positive radius\n                    neighbor.x = np.clip(neighbor.x, neighbor.radius, \n                                        self.container_size - neighbor.radius)\n                    neighbor.y = np.clip(neighbor.y, neighbor.radius, \n                                        self.container_size - neighbor.radius)\n                    neighbor.radius = max(0.1, neighbor.radius)\n                    \n                    # Evaluate neighbor\n                    test_circles = current.copy()\n                    test_circles[i] = neighbor\n                    neighbor_fitness = self.calculate_fitness(test_circles)\n                    \n                    if neighbor_fitness > best_neighbor_fitness:\n                        best_neighbor = neighbor\n                        best_neighbor_fitness = neighbor_fitness\n                        improved = True\n                \n                if improved:\n                    current[i] = best_neighbor\n                    current_fitness = best_neighbor_fitness\n            \n            # Reduce step size over time\n            step_size *= 0.98\n            \n            # Expand circles periodically\n            if iteration % 100 == 0:\n                current = self.expand_circles(current)\n                current_fitness = self.calculate_fitness(current)\n            \n            self.history.append(current_fitness)\n            \n            if not improved or iteration % 200 == 0:\n                if current_fitness > self.best_fitness:\n                    self.best_fitness = current_fitness\n                    self.best_circles = [circle.copy() for circle in current]\n        \n        return current\n    \n    def local_search_simulated_annealing(self, circles: List[Circle],\n                                        max_iterations: int = 2000,\n                                        initial_temp: float = 50.0,\n                                        cooling_rate: float = 0.995) -> List[Circle]:\n        \"\"\"\n        Optimize circle positions and radii using simulated annealing\n        \n        Args:\n            circles: Initial circle configuration\n            max_iterations: Maximum number of iterations\n            initial_temp: Initial temperature\n            cooling_rate: Temperature cooling rate\n            \n        Returns:\n            Optimized circle configuration\n        \"\"\"\n        current = [circle.copy() for circle in circles]\n        current_fitness = self.calculate_fitness(current)\n        \n        best = [circle.copy() for circle in current]\n        best_fitness = current_fitness\n        \n        temperature = initial_temp\n        \n        for iteration in range(max_iterations):\n            # Select random circle to modify\n            i = random.randint(0, len(current) - 1)\n            circle = current[i]\n            \n            # Generate neighbor solution\n            neighbor = circle.copy()\n            \n            # Random move type\n            move_type = random.choice(['position', 'radius'])\n            \n            if move_type == 'position':\n                step_size = temperature * 0.5\n                neighbor.x += random.uniform(-step_size, step_size)\n                neighbor.y += random.uniform(-step_size, step_size)\n            else:\n                step_size = temperature * 0.1\n                neighbor.radius += random.uniform(-step_size, step_size)\n            \n            # Enforce constraints\n            neighbor.x = np.clip(neighbor.x, neighbor.radius, \n                                self.container_size - neighbor.radius)\n            neighbor.y = np.clip(neighbor.y, neighbor.radius, \n                                self.container_size - neighbor.radius)\n            neighbor.radius = max(0.1, neighbor.radius)\n            \n            # Evaluate neighbor\n            test_circles = current.copy()\n            test_circles[i] = neighbor\n            neighbor_fitness = self.calculate_fitness(test_circles)\n            \n            # Acceptance probability\n            delta = neighbor_fitness - current_fitness\n            if delta > 0 or random.random() < math.exp(delta / (temperature + 1e-10)):\n                current[i] = neighbor\n                current_fitness = neighbor_fitness\n                \n                if current_fitness > best_fitness:\n                    best = [circle.copy() for circle in current]\n                    best_fitness = current_fitness\n            \n            # Cool down\n            temperature *= cooling_rate\n            \n            # Expand circles periodically\n            if iteration % 100 == 0:\n                current = self.expand_circles(current)\n                current_fitness = self.calculate_fitness(current)\n            \n            self.history.append(current_fitness)\n        \n        self.best_circles = best\n        self.best_fitness = best_fitness\n        \n        return best\n    \n    def run_packing(self, method: str = 'hybrid', \n                   max_iterations: int = 2000) -> List[Circle]:\n        \"\"\"\n        Run the complete circle packing algorithm\n        \n        Args:\n            method: 'hill_climbing', 'simulated_annealing', or 'hybrid'\n            max_iterations: Maximum iterations for optimization\n            \n        Returns:\n            List of optimally packed circles\n        \"\"\"\n        print(f\"Starting circle packing with {self.num_circles} circles...\")\n        print(f\"Container size: {self.container_size}x{self.container_size}\")\n        \n        # Step 1: Construct initial grid packing\n        print(\"\\n1. Constructing initial grid packing...\")\n        self.construct_packing()\n        initial_fitness = self.calculate_fitness(self.circles)\n        print(f\"   Initial fitness: {initial_fitness:.2f}\")\n        \n        # Step 2: Expand circles\n        print(\"\\n2. Expanding circles to maximum non-overlapping size...\")\n        self.circles = self.expand_circles(self.circles)\n        expanded_fitness = self.calculate_fitness(self.circles)\n        print(f\"   Fitness after expansion: {expanded_fitness:.2f}\")\n        \n        # Step 3: Local optimization\n        print(f\"\\n3. Running local optimization ({method})...\")\n        if method == 'hill_climbing':\n            self.circles = self.local_search_hill_climbing(self.circles, max_iterations)\n        elif method == 'simulated_annealing':\n            self.circles = self.local_search_simulated_annealing(self.circles, max_iterations)\n        elif method == 'hybrid':\n            # Combine both methods\n            print(\"   Phase 1: Hill climbing...\")\n            self.circles = self.local_search_hill_climbing(self.circles, max_iterations // 2)\n            print(\"   Phase 2: Simulated annealing...\")\n            self.circles = self.local_search_simulated_annealing(self.circles, max_iterations // 2)\n        \n        print(f\"\\n   Final fitness: {self.best_fitness:.2f}\")\n        print(f\"   Total radius sum: {sum(c.radius for c in self.best_circles):.2f}\")\n        \n        return self.best_circles\n    \n    def visualize(self, title: str = \"Circle Packing Solution\", figsize: Tuple[int, int] = (12, 5)):\n        \"\"\"\n        Visualize the circle packing solution\n        \n        Args:\n            title: Title for the plot\n            figsize: Figure size (width, height)\n        \"\"\"\n        fig, axes = plt.subplots(1, 2, figsize=figsize)\n        \n        # Plot 1: Circle packing\n        ax = axes[0]\n        ax.set_xlim(-5, self.container_size + 5)\n        ax.set_ylim(-5, self.container_size + 5)\n        ax.set_aspect('equal')\n        ax.set_title(f'{title}\\n(Total Radius: {sum(c.radius for c in self.best_circles):.2f})')\n        \n        # Draw container\n        rect = plt.Rectangle((0, 0), self.container_size, self.container_size, \n                            fill=False, edgecolor='black', linewidth=2)\n        ax.add_patch(rect)\n        \n        # Draw circles\n        colors = plt.cm.hsv(np.linspace(0, 1, len(self.best_circles)))\n        for i, circle in enumerate(self.best_circles):\n            circle_patch = plt.Circle((circle.x, circle.y), circle.radius, \n                                     color=colors[i], alpha=0.6, edgecolor='black', linewidth=1)\n            ax.add_patch(circle_patch)\n            ax.text(circle.x, circle.y, str(i+1), ha='center', va='center', \n                   fontsize=8, fontweight='bold')\n        \n        ax.grid(True, alpha=0.3)\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        \n        # Plot 2: Fitness history\n        ax = axes[1]\n        ax.plot(self.history, linewidth=2)\n        ax.set_title('Optimization Progress')\n        ax.set_xlabel('Iteration')\n        ax.set_ylabel('Fitness Score')\n        ax.grid(True, alpha=0.3)\n        \n        plt.tight_layout()\n        return fig",
  "timestamp": "2025-12-08T12:15:35.313178",
  "cost_data": null
}