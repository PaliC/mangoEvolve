{
  "trial_id": "trial_0_9",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a circle packing algorithm for 26 circles using a genetic algorithm. Represent circle positions and radii as a chromosome, evolve a population over generations, and select the best packing. Include construct_packing() and run_packing() functions.",
  "response": "# Circle Packing Algorithm using Genetic Algorithm\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\nimport random\nfrom copy import deepcopy\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with position and radius\"\"\"\n    x: float\n    y: float\n    radius: float\n    \n    def distance_to(self, other: 'Circle') -> float:\n        \"\"\"Calculate distance between circle centers\"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n    \n    def overlaps_with(self, other: 'Circle') -> bool:\n        \"\"\"Check if this circle overlaps with another\"\"\"\n        return self.distance_to(other) < (self.radius + other.radius)\n    \n    def is_inside_bounds(self, width: float, height: float) -> bool:\n        \"\"\"Check if circle is completely inside bounds\"\"\"\n        return (self.x - self.radius >= 0 and \n                self.x + self.radius <= width and\n                self.y - self.radius >= 0 and \n                self.y + self.radius <= height)\n\n\nclass CirclePackingGA:\n    \"\"\"Genetic Algorithm for circle packing problem\"\"\"\n    \n    def __init__(self, \n                 num_circles: int = 26,\n                 width: float = 100.0,\n                 height: float = 100.0,\n                 population_size: int = 50,\n                 generations: int = 500,\n                 mutation_rate: float = 0.1,\n                 crossover_rate: float = 0.8):\n        \"\"\"\n        Initialize the circle packing GA\n        \n        Args:\n            num_circles: Number of circles to pack\n            width: Container width\n            height: Container height\n            population_size: Population size for GA\n            generations: Number of generations to evolve\n            mutation_rate: Probability of mutation per gene\n            crossover_rate: Probability of crossover\n        \"\"\"\n        self.num_circles = num_circles\n        self.width = width\n        self.height = height\n        self.population_size = population_size\n        self.generations = generations\n        self.mutation_rate = mutation_rate\n        self.crossover_rate = crossover_rate\n        \n        # Chromosome: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n        self.chromosome_length = num_circles * 3\n        \n        self.best_fitness_history = []\n        self.avg_fitness_history = []\n        self.best_individual = None\n        self.best_fitness = float('-inf')\n    \n    def create_individual(self) -> np.ndarray:\n        \"\"\"Create a random individual (chromosome)\"\"\"\n        chromosome = np.zeros(self.chromosome_length)\n        \n        for i in range(self.num_circles):\n            # Random position within bounds\n            chromosome[i*3] = np.random.uniform(5, self.width - 5)      # x\n            chromosome[i*3 + 1] = np.random.uniform(5, self.height - 5) # y\n            # Random radius between 2 and 8\n            chromosome[i*3 + 2] = np.random.uniform(2, 8)               # radius\n        \n        return chromosome\n    \n    def create_population(self) -> List[np.ndarray]:\n        \"\"\"Create initial population\"\"\"\n        return [self.create_individual() for _ in range(self.population_size)]\n    \n    def chromosome_to_circles(self, chromosome: np.ndarray) -> List[Circle]:\n        \"\"\"Convert chromosome to list of circles\"\"\"\n        circles = []\n        for i in range(self.num_circles):\n            x = chromosome[i*3]\n            y = chromosome[i*3 + 1]\n            r = abs(chromosome[i*3 + 2])  # Ensure positive radius\n            circles.append(Circle(x, y, r))\n        return circles\n    \n    def calculate_fitness(self, chromosome: np.ndarray) -> float:\n        \"\"\"\n        Calculate fitness score for a chromosome\n        Higher score is better\n        Fitness = total_area - penalty_overlap - penalty_out_of_bounds\n        \"\"\"\n        circles = self.chromosome_to_circles(chromosome)\n        \n        # Calculate total area covered\n        total_area = sum(np.pi * circle.radius**2 for circle in circles)\n        \n        # Penalty for overlaps\n        overlap_penalty = 0.0\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                if circles[i].overlaps_with(circles[j]):\n                    # Penalty proportional to overlap severity\n                    dist = circles[i].distance_to(circles[j])\n                    min_dist = circles[i].radius + circles[j].radius\n                    overlap = min_dist - dist\n                    overlap_penalty += overlap ** 2\n        \n        # Penalty for circles outside bounds\n        bounds_penalty = 0.0\n        for circle in circles:\n            if not circle.is_inside_bounds(self.width, self.height):\n                # Penalty for how far outside\n                penalty = 0.0\n                if circle.x - circle.radius < 0:\n                    penalty += (circle.radius - circle.x) ** 2\n                if circle.x + circle.radius > self.width:\n                    penalty += (circle.x + circle.radius - self.width) ** 2\n                if circle.y - circle.radius < 0:\n                    penalty += (circle.radius - circle.y) ** 2\n                if circle.y + circle.radius > self.height:\n                    penalty += (circle.y + circle.radius - self.height) ** 2\n                bounds_penalty += penalty\n        \n        # Fitness function: maximize area, minimize penalties\n        fitness = total_area - 10 * overlap_penalty - 5 * bounds_penalty\n        \n        return fitness\n    \n    def tournament_selection(self, population: List[np.ndarray], \n                            fitness_scores: List[float], \n                            tournament_size: int = 3) -> np.ndarray:\n        \"\"\"Select individual using tournament selection\"\"\"\n        indices = np.random.choice(len(population), tournament_size, replace=False)\n        best_idx = indices[np.argmax([fitness_scores[i] for i in indices])]\n        return population[best_idx].copy()\n    \n    def crossover(self, parent1: np.ndarray, parent2: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Single-point crossover\"\"\"\n        if np.random.random() > self.crossover_rate:\n            return parent1.copy(), parent2.copy()\n        \n        crossover_point = np.random.randint(1, len(parent1))\n        child1 = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        child2 = np.concatenate([parent2[:crossover_point], parent1[crossover_point:]])\n        \n        return child1, child2\n    \n    def mutate(self, chromosome: np.ndarray) -> np.ndarray:\n        \"\"\"Mutate chromosome\"\"\"\n        mutated = chromosome.copy()\n        \n        for i in range(len(mutated)):\n            if np.random.random() < self.mutation_rate:\n                if i % 3 == 0:  # x coordinate\n                    mutated[i] = np.random.uniform(5, self.width - 5)\n                elif i % 3 == 1:  # y coordinate\n                    mutated[i] = np.random.uniform(5, self.height - 5)\n                else:  # radius\n                    mutated[i] = np.random.uniform(2, 8)\n        \n        return mutated\n    \n    def evolve(self) -> Tuple[np.ndarray, List[float]]:\n        \"\"\"Run the genetic algorithm evolution\"\"\"\n        population = self.create_population()\n        \n        for generation in range(self.generations):\n            # Calculate fitness for all individuals\n            fitness_scores = [self.calculate_fitness(ind) for ind in population]\n            \n            # Track best individual\n            best_idx = np.argmax(fitness_scores)\n            best_fitness = fitness_scores[best_idx]\n            \n            if best_fitness > self.best_fitness:\n                self.best_fitness = best_fitness\n                self.best_individual = population[best_idx].copy()\n            \n            # Record statistics\n            self.best_fitness_history.append(best_fitness)\n            self.avg_fitness_history.append(np.mean(fitness_scores))\n            \n            if (generation + 1) % 50 == 0:\n                print(f\"Generation {generation + 1}/{self.generations} - \"\n                      f\"Best Fitness: {best_fitness:.2f}, \"\n                      f\"Avg Fitness: {np.mean(fitness_scores):.2f}\")\n            \n            # Create new population\n            new_population = []\n            \n            # Elitism: keep best individual\n            new_population.append(self.best_individual.copy())\n            \n            # Generate rest of population\n            while len(new_population) < self.population_size:\n                # Selection\n                parent1 = self.tournament_selection(population, fitness_scores)\n                parent2 = self.tournament_selection(population, fitness_scores)\n                \n                # Crossover\n                child1, child2 = self.crossover(parent1, parent2)\n                \n                # Mutation\n                child1 = self.mutate(child1)\n                child2 = self.mutate(child2)\n                \n                new_population.extend([child1, child2])\n            \n            # Trim to population size\n            population = new_population[:self.population_size]\n        \n        return self.best_individual, self.best_fitness_history\n    \n    def construct_packing(self, chromosome: np.ndarray = None) -> List[Circle]:\n        \"\"\"\n        Construct the final circle packing from best chromosome\n        \n        Args:\n            chromosome: Chromosome to convert. If None, uses best individual\n            \n        Returns:\n            List of Circle objects representing the packing\n        \"\"\"\n        if chromosome is None:\n            chromosome = self.best_individual\n        \n        if chromosome is None:\n            raise ValueError(\"No chromosome available. Run evolve() first.\")\n        \n        circles = self.chromosome_to_circles(chromosome)\n        return circles\n    \n    def visualize_packing(self, circles: List[Circle] = None, \n                         title: str = \"Circle Packing Result\"):\n        \"\"\"Visualize the circle packing\"\"\"\n        if circles is None:\n            circles = self.construct_packing()\n        \n        fig, ax = plt.subplots(figsize=(10, 10))\n        \n        # Draw container\n        ax.add_patch(plt.Rectangle((0, 0), self.width, self.height, \n                                   fill=False, edgecolor='black', linewidth=2))\n        \n        # Draw circles\n        colors = plt.cm.tab20(np.linspace(0, 1, len(circles)))\n        for i, circle in enumerate(circles):\n            ax.add_patch(plt.Circle((circle.x, circle.y), circle.radius, \n                                   color=colors[i], alpha=0.6, edgecolor='black'))\n            ax.text(circle.x, circle.y, str(i+1), ha='center', va='center', fontsize=8)\n        \n        # Calculate statistics\n        total_area = sum(np.pi * c.radius**2 for c in circles)\n        container_area = self.width * self.height\n        utilization = (total_area / container_area) * 100\n        \n        # Count overlaps\n        overlaps = 0\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                if circles[i].overlaps_with(circles[j]):\n                    overlaps += 1\n        \n        # Count out of bounds\n        out_of_bounds = sum(1 for c in circles if not c.is_inside_bounds(self.width, self.height))\n        \n        ax.set_xlim(-5, self.width + 5)\n        ax.set_ylim(-5, self.height + 5)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        \n        stats_text = f\"{title}\\n\"\n        stats_text += f\"Utilization: {utilization:.2f}%\\n\"\n        stats_text += f\"Overlaps: {overlaps}\\n\"\n        stats_text += f\"Out of Bounds: {out_of_bounds}\\n\"\n        stats_text += f\"Fitness: {self.best_fitness:.2f}\"\n        \n        ax.set_title(stats_text)\n        \n        return fig, ax\n    \n    def plot_fitness_history(self):\n        \"\"\"Plot fitness history over generations\"\"\"\n        fig, ax = plt.subplots(figsize=(12, 6))\n        \n        ax.plot(self.best_fitness_history, label='Best Fitness', linewidth=2)\n        ax.plot(self.avg_fitness_history, label='Average Fitness', linewidth=2, alpha=0.7)\n        \n        ax.set_xlabel('Generation')\n        ax.set_ylabel('Fitness')\n        ax.set_title('Fitness Evolution Over Generations')\n        ax.legend()\n        ax.grid(True, alpha=0.3)\n        \n        return fig, ax\n\n\ndef construct_packing(width: float = 100.0, \n                     height: float = 100.0,\n                     num_circles: int = 26,\n                     generations: int = 500) -> Tuple[List[Circle], CirclePackingGA]:\n    \"\"\"\n    Construct a circle packing solution\n    \n    Args:\n        width: Container width\n        height: Container height\n        num_circles: Number of circles to pack\n        generations: Number of GA generations\n        \n    Returns:\n        Tuple of (circles, ga_instance)\n    \"\"\"\n    ga = CirclePackingGA(num_circles=num_circles,\n                        width=width,\n                        height=height,\n                        generations=generations)\n    \n    print(f\"Starting Circle Packing GA...\")\n    print(f\"Container: {width}x{height}\")\n    print(f\"Circles: {num_circles}\")\n    print(f\"Generations: {generations}\\n\")\n    \n    ga.evolve()\n    circles = ga.construct_packing()\n    \n    return circles, ga\n\n\ndef run_packing(width: float = 100.0,\n               height: float = 100.0,\n               num_circles: int = 26,\n               generations: int = 500,\n               visualize: bool = True) -> CirclePackingGA:\n    \"\"\"\n    Run the complete circle packing algorithm\n    \n    Args:\n        width: Container width\n        height: Container height\n        num_circles: Number of circles to pack\n        generations: Number of GA generations\n        visualize: Whether to display results\n        \n    Returns:\n        CirclePackingGA instance with results\n    \"\"\"\n    circles, ga = construct_packing(width, height, num_circles, generations)\n    \n    print(f\"\\n{'='*50}\")\n    print(\"RESULTS\")\n    print(f\"{'='*50}\")\n    print(f\"Best Fitness: {ga.best_fitness:.2f}\")\n    print(f\"Number of Circles: {len(circles)}\")\n    \n    # Calculate statistics\n    total_area = sum(np.pi * c.radius**2 for c in circles)\n    container_area = width * height\n    utilization = (total_area / container_area) * 100\n    \n    overlaps = 0\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            if circles[i].overlaps_with(circles[j]):\n                overlaps += 1\n    \n    out_of_bounds = sum(1 for c in circles if not c.is_inside_bounds(width, height))\n    \n    print(f\"Space Utilization: {utilization:.2f}%\")\n    print(f\"Overlapping Circles: {overlaps}\")\n    print(f\"Circles Out of Bounds: {out_of_bounds}\")\n    ",
  "reasoning": "# Circle Packing Algorithm using Genetic Algorithm\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\nimport random\nfrom copy import deepcopy\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with position and radius\"\"\"\n    x: float\n    y: float\n    radius: float\n    \n    def distance_to(self, other: 'Circle') -> float:\n        \"\"\"Calculate distance between circle centers\"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n    \n    def overlaps_with(self, other: 'Circle') -> bool:\n        \"\"\"Check if this circle overlaps with another\"\"\"\n        return self.distance_to(other) < (self.radius + other.radius)\n    \n    def is_inside_bounds(self, width: float, height: float) -> bool:\n        \"\"\"Check if circle is completely inside bounds\"\"\"\n        return (self.x - self.radius >= 0 and \n                self.x + self.radius <= width and\n                self.y - self.radius >= 0 and \n                self.y + self.radius <= height)\n\nclass CirclePackingGA:\n    \"\"\"Genetic Algorithm for circle packing problem\"\"\"\n    \n    def __init__(self, \n                 num_circles: int = 26,\n                 width: float = 100.0,\n                 height: float = 100.0,\n                 population_size: int = 50,\n                 generations: int = 500,\n                 mutation_rate: float = 0.1,\n                 crossover_rate: float = 0.8):\n        \"\"\"\n        Initialize the circle packing GA\n        \n        Args:\n            num_circles: Number of circles to pack\n            width: Container width\n            height: Container height\n            population_size: Population size for GA\n            generations: Number of generations to evolve\n            mutation_rate: Probability of mutation per gene\n            crossover_rate: Probability of crossover\n        \"\"\"\n        self.num_circles = num_circles\n        self.width = width\n        self.height = height\n        self.population_size = population_size\n        self.generations = generations\n        self.mutation_rate = mutation_rate\n        self.crossover_rate = crossover_rate\n        \n        # Chromosome: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n        self.chromosome_length = num_circles * 3\n        \n        self.best_fitness_history = []\n        self.avg_fitness_history = []\n        self.best_individual = None\n        self.best_fitness = float('-inf')\n    \n    def create_individual(self) -> np.ndarray:\n        \"\"\"Create a random individual (chromosome)\"\"\"\n        chromosome = np.zeros(self.chromosome_length)\n        \n        for i in range(self.num_circles):\n            # Random position within bounds\n            chromosome[i*3] = np.random.uniform(5, self.width - 5)      # x\n            chromosome[i*3 + 1] = np.random.uniform(5, self.height - 5) # y\n            # Random radius between 2 and 8\n            chromosome[i*3 + 2] = np.random.uniform(2, 8)               # radius\n        \n        return chromosome\n    \n    def create_population(self) -> List[np.ndarray]:\n        \"\"\"Create initial population\"\"\"\n        return [self.create_individual() for _ in range(self.population_size)]\n    \n    def chromosome_to_circles(self, chromosome: np.ndarray) -> List[Circle]:\n        \"\"\"Convert chromosome to list of circles\"\"\"\n        circles = []\n        for i in range(self.num_circles):\n            x = chromosome[i*3]\n            y = chromosome[i*3 + 1]\n            r = abs(chromosome[i*3 + 2])  # Ensure positive radius\n            circles.append(Circle(x, y, r))\n        return circles\n    \n    def calculate_fitness(self, chromosome: np.ndarray) -> float:\n        \"\"\"\n        Calculate fitness score for a chromosome\n        Higher score is better\n        Fitness = total_area - penalty_overlap - penalty_out_of_bounds\n        \"\"\"\n        circles = self.chromosome_to_circles(chromosome)\n        \n        # Calculate total area covered\n        total_area = sum(np.pi * circle.radius**2 for circle in circles)\n        \n        # Penalty for overlaps\n        overlap_penalty = 0.0\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                if circles[i].overlaps_with(circles[j]):\n                    # Penalty proportional to overlap severity\n                    dist = circles[i].distance_to(circles[j])\n                    min_dist = circles[i].radius + circles[j].radius\n                    overlap = min_dist - dist\n                    overlap_penalty += overlap ** 2\n        \n        # Penalty for circles outside bounds\n        bounds_penalty = 0.0\n        for circle in circles:\n            if not circle.is_inside_bounds(self.width, self.height):\n                # Penalty for how far outside\n                penalty = 0.0\n                if circle.x - circle.radius < 0:\n                    penalty += (circle.radius - circle.x) ** 2\n                if circle.x + circle.radius > self.width:\n                    penalty += (circle.x + circle.radius - self.width) ** 2\n                if circle.y - circle.radius < 0:\n                    penalty += (circle.radius - circle.y) ** 2\n                if circle.y + circle.radius > self.height:\n                    penalty += (circle.y + circle.radius - self.height) ** 2\n                bounds_penalty += penalty\n        \n        # Fitness function: maximize area, minimize penalties\n        fitness = total_area - 10 * overlap_penalty - 5 * bounds_penalty\n        \n        return fitness\n    \n    def tournament_selection(self, population: List[np.ndarray], \n                            fitness_scores: List[float], \n                            tournament_size: int = 3) -> np.ndarray:\n        \"\"\"Select individual using tournament selection\"\"\"\n        indices = np.random.choice(len(population), tournament_size, replace=False)\n        best_idx = indices[np.argmax([fitness_scores[i] for i in indices])]\n        return population[best_idx].copy()\n    \n    def crossover(self, parent1: np.ndarray, parent2: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Single-point crossover\"\"\"\n        if np.random.random() > self.crossover_rate:\n            return parent1.copy(), parent2.copy()\n        \n        crossover_point = np.random.randint(1, len(parent1))\n        child1 = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        child2 = np.concatenate([parent2[:crossover_point], parent1[crossover_point:]])\n        \n        return child1, child2\n    \n    def mutate(self, chromosome: np.ndarray) -> np.ndarray:\n        \"\"\"Mutate chromosome\"\"\"\n        mutated = chromosome.copy()\n        \n        for i in range(len(mutated)):\n            if np.random.random() < self.mutation_rate:\n                if i % 3 == 0:  # x coordinate\n                    mutated[i] = np.random.uniform(5, self.width - 5)\n                elif i % 3 == 1:  # y coordinate\n                    mutated[i] = np.random.uniform(5, self.height - 5)\n                else:  # radius\n                    mutated[i] = np.random.uniform(2, 8)\n        \n        return mutated\n    \n    def evolve(self) -> Tuple[np.ndarray, List[float]]:\n        \"\"\"Run the genetic algorithm evolution\"\"\"\n        population = self.create_population()\n        \n        for generation in range(self.generations):\n            # Calculate fitness for all individuals\n            fitness_scores = [self.calculate_fitness(ind) for ind in population]\n            \n            # Track best individual\n            best_idx = np.argmax(fitness_scores)\n            best_fitness = fitness_scores[best_idx]\n            \n            if best_fitness > self.best_fitness:\n                self.best_fitness = best_fitness\n                self.best_individual = population[best_idx].copy()\n            \n            # Record statistics\n            self.best_fitness_history.append(best_fitness)\n            self.avg_fitness_history.append(np.mean(fitness_scores))\n            \n            if (generation + 1) % 50 == 0:\n                print(f\"Generation {generation + 1}/{self.generations} - \"\n                      f\"Best Fitness: {best_fitness:.2f}, \"\n                      f\"Avg Fitness: {np.mean(fitness_scores):.2f}\")\n            \n            # Create new population\n            new_population = []\n            \n            # Elitism: keep best individual\n            new_population.append(self.best_individual.copy())\n            \n            # Generate rest of population\n            while len(new_population) < self.population_size:\n                # Selection\n                parent1 = self.tournament_selection(population, fitness_scores)\n                parent2 = self.tournament_selection(population, fitness_scores)\n                \n                # Crossover\n                child1, child2 = self.crossover(parent1, parent2)\n                \n                # Mutation\n                child1 = self.mutate(child1)\n                child2 = self.mutate(child2)\n                \n                new_population.extend([child1, child2])\n            \n            # Trim to population size\n            population = new_population[:self.population_size]\n        \n        return self.best_individual, self.best_fitness_history\n    \n    def construct_packing(self, chromosome: np.ndarray = None) -> List[Circle]:\n        \"\"\"\n        Construct the final circle packing from best chromosome\n        \n        Args:\n            chromosome: Chromosome to convert. If None, uses best individual\n            \n        Returns:\n            List of Circle objects representing the packing\n        \"\"\"\n        if chromosome is None:\n            chromosome = self.best_individual\n        \n        if chromosome is None:\n            raise ValueError(\"No chromosome available. Run evolve() first.\")\n        \n        circles = self.chromosome_to_circles(chromosome)\n        return circles\n    \n    def visualize_packing(self, circles: List[Circle] = None, \n                         title: str = \"Circle Packing Result\"):\n        \"\"\"Visualize the circle packing\"\"\"\n        if circles is None:\n            circles = self.construct_packing()\n        \n        fig, ax = plt.subplots(figsize=(10, 10))\n        \n        # Draw container\n        ax.add_patch(plt.Rectangle((0, 0), self.width, self.height, \n                                   fill=False, edgecolor='black', linewidth=2))\n        \n        # Draw circles\n        colors = plt.cm.tab20(np.linspace(0, 1, len(circles)))\n        for i, circle in enumerate(circles):\n            ax.add_patch(plt.Circle((circle.x, circle.y), circle.radius, \n                                   color=colors[i], alpha=0.6, edgecolor='black'))\n            ax.text(circle.x, circle.y, str(i+1), ha='center', va='center', fontsize=8)\n        \n        # Calculate statistics\n        total_area = sum(np.pi * c.radius**2 for c in circles)\n        container_area = self.width * self.height\n        utilization = (total_area / container_area) * 100\n        \n        # Count overlaps\n        overlaps = 0\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                if circles[i].overlaps_with(circles[j]):\n                    overlaps += 1\n        \n        # Count out of bounds\n        out_of_bounds = sum(1 for c in circles if not c.is_inside_bounds(self.width, self.height))\n        \n        ax.set_xlim(-5, self.width + 5)\n        ax.set_ylim(-5, self.height + 5)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        \n        stats_text = f\"{title}\\n\"\n        stats_text += f\"Utilization: {utilization:.2f}%\\n\"\n        stats_text += f\"Overlaps: {overlaps}\\n\"\n        stats_text += f\"Out of Bounds: {out_of_bounds}\\n\"\n        stats_text += f\"Fitness: {self.best_fitness:.2f}\"\n        \n        ax.set_title(stats_text)\n        \n        return fig, ax\n    \n    def plot_fitness_history(self):\n        \"\"\"Plot fitness history over generations\"\"\"\n        fig, ax = plt.subplots(figsize=(12, 6))\n        \n        ax.plot(self.best_fitness_history, label='Best Fitness', linewidth=2)\n        ax.plot(self.avg_fitness_history, label='Average Fitness', linewidth=2, alpha=0.7)\n        \n        ax.set_xlabel('Generation')\n        ax.set_ylabel('Fitness')\n        ax.set_title('Fitness Evolution Over Generations')\n        ax.legend()\n        ax.grid(True, alpha=0.3)\n        \n        return fig, ax\n\ndef construct_packing(width: float = 100.0, \n                     height: float = 100.0,\n                     num_circles: int = 26,\n                     generations: int = 500) -> Tuple[List[Circle], CirclePackingGA]:\n    \"\"\"\n    Construct a circle packing solution\n    \n    Args:\n        width: Container width\n        height: Container height\n        num_circles: Number of circles to pack\n        generations: Number of GA generations\n        \n    Returns:\n        Tuple of (circles, ga_instance)\n    \"\"\"\n    ga = CirclePackingGA(num_circles=num_circles,\n                        width=width,\n                        height=height,\n                        generations=generations)\n    \n    print(f\"Starting Circle Packing GA...\")\n    print(f\"Container: {width}x{height}\")\n    print(f\"Circles: {num_circles}\")\n    print(f\"Generations: {generations}\\n\")\n    \n    ga.evolve()\n    circles = ga.construct_packing()\n    \n    return circles, ga\n\ndef run_packing(width: float = 100.0,\n               height: float = 100.0,\n               num_circles: int = 26,\n               generations: int = 500,\n               visualize: bool = True) -> CirclePackingGA:\n    \"\"\"\n    Run the complete circle packing algorithm\n    \n    Args:\n        width: Container width\n        height: Container height\n        num_circles: Number of circles to pack\n        generations: Number of GA generations\n        visualize: Whether to display results\n        \n    Returns:\n        CirclePackingGA instance with results\n    \"\"\"\n    circles, ga = construct_packing(width, height, num_circles, generations)\n    \n    print(f\"\\n{'='*50}\")\n    print(\"RESULTS\")\n    print(f\"{'='*50}\")\n    print(f\"Best Fitness: {ga.best_fitness:.2f}\")\n    print(f\"Number of Circles: {len(circles)}\")\n    \n    # Calculate statistics\n    total_area = sum(np.pi * c.radius**2 for c in circles)\n    container_area = width * height\n    utilization = (total_area / container_area) * 100\n    \n    overlaps = 0\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            if circles[i].overlaps_with(circles[j]):\n                overlaps += 1\n    \n    out_of_bounds = sum(1 for c in circles if not c.is_inside_bounds(width, height))\n    \n    print(f\"Space Utilization: {utilization:.2f}%\")\n    print(f\"Overlapping Circles: {overlaps}\")\n    print(f\"Circles Out of Bounds: {out_of_bounds}\")",
  "timestamp": "2025-12-08T12:15:13.469650",
  "cost_data": null
}