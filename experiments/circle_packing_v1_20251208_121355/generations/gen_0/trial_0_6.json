{
  "trial_id": "trial_0_6",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a circle packing algorithm for 26 circles using a simulated annealing approach. Start with random positions and radii, then use simulated annealing to optimize the configuration while avoiding overlaps. Include construct_packing() and run_packing() functions.",
  "response": "# Circle Packing Algorithm using Simulated Annealing\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom typing import Tuple, List\nimport math\n\nclass CirclePacking:\n    \"\"\"\n    Circle packing optimizer using simulated annealing.\n    Packs 26 circles (representing letters A-Z) into a minimal area.\n    \"\"\"\n    \n    def __init__(self, num_circles: int = 26, container_size: float = 100.0):\n        \"\"\"\n        Initialize circle packing problem.\n        \n        Args:\n            num_circles: Number of circles to pack\n            container_size: Size of the bounding container\n        \"\"\"\n        self.num_circles = num_circles\n        self.container_size = container_size\n        self.min_radius = 1.0\n        self.max_radius = 5.0\n        \n        # State: [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n        self.state = None\n        self.best_state = None\n        self.best_energy = float('inf')\n        \n    def construct_packing(self) -> np.ndarray:\n        \"\"\"\n        Construct initial random circle packing configuration.\n        \n        Returns:\n            Initial state array with random positions and radii\n        \"\"\"\n        state = np.zeros(self.num_circles * 3)\n        \n        for i in range(self.num_circles):\n            # Random position within container\n            state[i * 3] = np.random.uniform(\n                self.min_radius, \n                self.container_size - self.min_radius\n            )\n            state[i * 3 + 1] = np.random.uniform(\n                self.min_radius, \n                self.container_size - self.min_radius\n            )\n            # Random radius\n            state[i * 3 + 2] = np.random.uniform(\n                self.min_radius, \n                self.max_radius\n            )\n        \n        self.state = state.copy()\n        self.best_state = state.copy()\n        return state\n    \n    def get_circle(self, idx: int) -> Tuple[float, float, float]:\n        \"\"\"\n        Extract circle parameters from state.\n        \n        Args:\n            idx: Circle index (0 to num_circles-1)\n            \n        Returns:\n            Tuple of (x, y, radius)\n        \"\"\"\n        base_idx = idx * 3\n        return (self.state[base_idx], self.state[base_idx + 1], \n                self.state[base_idx + 2])\n    \n    def set_circle(self, idx: int, x: float, y: float, r: float):\n        \"\"\"\n        Update circle parameters in state.\n        \n        Args:\n            idx: Circle index\n            x, y: Center coordinates\n            r: Radius\n        \"\"\"\n        base_idx = idx * 3\n        self.state[base_idx] = x\n        self.state[base_idx + 1] = y\n        self.state[base_idx + 2] = r\n    \n    def distance_between_circles(self, idx1: int, idx2: int) -> float:\n        \"\"\"\n        Calculate distance between two circle centers.\n        \n        Args:\n            idx1, idx2: Circle indices\n            \n        Returns:\n            Distance between centers\n        \"\"\"\n        x1, y1, _ = self.get_circle(idx1)\n        x2, y2, _ = self.get_circle(idx2)\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    \n    def check_overlap(self, idx1: int, idx2: int, \n                     min_distance: float = 0.01) -> float:\n        \"\"\"\n        Calculate overlap penalty between two circles.\n        \n        Args:\n            idx1, idx2: Circle indices\n            min_distance: Minimum allowed distance between surfaces\n            \n        Returns:\n            Overlap penalty (0 if no overlap)\n        \"\"\"\n        _, _, r1 = self.get_circle(idx1)\n        _, _, r2 = self.get_circle(idx2)\n        distance = self.distance_between_circles(idx1, idx2)\n        min_dist = r1 + r2 + min_distance\n        \n        if distance < min_dist:\n            return (min_dist - distance) ** 2\n        return 0.0\n    \n    def check_boundary(self, idx: int) -> float:\n        \"\"\"\n        Calculate penalty for circles outside container.\n        \n        Args:\n            idx: Circle index\n            \n        Returns:\n            Boundary violation penalty\n        \"\"\"\n        x, y, r = self.get_circle(idx)\n        penalty = 0.0\n        \n        # Check left and right boundaries\n        if x - r < 0:\n            penalty += (r - x) ** 2\n        if x + r > self.container_size:\n            penalty += (x + r - self.container_size) ** 2\n        \n        # Check top and bottom boundaries\n        if y - r < 0:\n            penalty += (r - y) ** 2\n        if y + r > self.container_size:\n            penalty += (y + r - self.container_size) ** 2\n        \n        return penalty\n    \n    def calculate_energy(self) -> float:\n        \"\"\"\n        Calculate total energy (objective function to minimize).\n        \n        Energy consists of:\n        1. Overlap penalties\n        2. Boundary violation penalties\n        3. Bounding box size (to minimize total area)\n        \n        Returns:\n            Total energy value\n        \"\"\"\n        energy = 0.0\n        \n        # Overlap penalties\n        for i in range(self.num_circles):\n            for j in range(i + 1, self.num_circles):\n                energy += self.check_overlap(i, j)\n        \n        # Boundary penalties\n        for i in range(self.num_circles):\n            energy += self.check_boundary(i)\n        \n        # Bounding box size penalty (encourage compact packing)\n        min_x = min_y = float('inf')\n        max_x = max_y = float('-inf')\n        \n        for i in range(self.num_circles):\n            x, y, r = self.get_circle(i)\n            min_x = min(min_x, x - r)\n            min_y = min(min_y, y - r)\n            max_x = max(max_x, x + r)\n            max_y = max(max_y, y + r)\n        \n        if min_x != float('inf'):\n            width = max(0, max_x - min_x)\n            height = max(0, max_y - min_y)\n            bounding_area = width * height\n            energy += 0.1 * bounding_area / (self.container_size ** 2)\n        \n        return energy\n    \n    def get_neighbor_state(self, temperature: float) -> np.ndarray:\n        \"\"\"\n        Generate neighboring state using random perturbation.\n        \n        Args:\n            temperature: Current temperature (controls perturbation magnitude)\n            \n        Returns:\n            Perturbed state\n        \"\"\"\n        neighbor_state = self.state.copy()\n        \n        # Randomly select a circle to modify\n        circle_idx = np.random.randint(0, self.num_circles)\n        x, y, r = self.get_circle(circle_idx)\n        \n        # Perturbation magnitude decreases with temperature\n        perturbation = temperature / 10.0\n        \n        # Random choice: move position or change radius\n        choice = np.random.random()\n        \n        if choice < 0.7:  # Move position\n            x += np.random.normal(0, perturbation)\n            y += np.random.normal(0, perturbation)\n        else:  # Change radius\n            r += np.random.normal(0, perturbation * 0.5)\n            r = np.clip(r, self.min_radius, self.max_radius)\n        \n        # Ensure position stays within bounds\n        x = np.clip(x, self.min_radius, self.container_size - self.min_radius)\n        y = np.clip(y, self.min_radius, self.container_size - self.min_radius)\n        \n        # Update neighbor state\n        base_idx = circle_idx * 3\n        neighbor_state[base_idx] = x\n        neighbor_state[base_idx + 1] = y\n        neighbor_state[base_idx + 2] = r\n        \n        return neighbor_state\n    \n    def run_packing(self, initial_temperature: float = 50.0,\n                   cooling_rate: float = 0.995,\n                   iterations_per_temp: int = 100,\n                   min_temperature: float = 0.1) -> dict:\n        \"\"\"\n        Run simulated annealing optimization.\n        \n        Args:\n            initial_temperature: Starting temperature\n            cooling_rate: Temperature reduction factor (0 < rate < 1)\n            iterations_per_temp: Iterations at each temperature\n            min_temperature: Stopping temperature threshold\n            \n        Returns:\n            Dictionary with optimization results\n        \"\"\"\n        temperature = initial_temperature\n        current_energy = self.calculate_energy()\n        self.best_energy = current_energy\n        self.best_state = self.state.copy()\n        \n        iteration = 0\n        temperature_step = 0\n        energy_history = []\n        temperature_history = []\n        \n        print(f\"Starting Simulated Annealing\")\n        print(f\"Initial Energy: {current_energy:.4f}\")\n        print(\"-\" * 60)\n        \n        while temperature > min_temperature:\n            for _ in range(iterations_per_temp):\n                # Generate neighbor solution\n                neighbor_state = self.get_neighbor_state(temperature)\n                old_state = self.state.copy()\n                self.state = neighbor_state\n                \n                # Calculate neighbor energy\n                neighbor_energy = self.calculate_energy()\n                \n                # Metropolis acceptance criterion\n                energy_diff = neighbor_energy - current_energy\n                \n                if energy_diff < 0:  # Better solution\n                    current_energy = neighbor_energy\n                    if current_energy < self.best_energy:\n                        self.best_energy = current_energy\n                        self.best_state = self.state.copy()\n                else:  # Worse solution\n                    acceptance_prob = np.exp(-energy_diff / temperature)\n                    if np.random.random() < acceptance_prob:\n                        current_energy = neighbor_energy\n                    else:\n                        self.state = old_state\n                \n                iteration += 1\n                energy_history.append(self.best_energy)\n                temperature_history.append(temperature)\n            \n            # Cool down\n            temperature *= cooling_rate\n            temperature_step += 1\n            \n            if temperature_step % 10 == 0:\n                print(f\"Step {temperature_step:3d} | \"\n                      f\"Temp: {temperature:7.4f} | \"\n                      f\"Best Energy: {self.best_energy:10.4f} | \"\n                      f\"Iterations: {iteration:6d}\")\n        \n        # Restore best state\n        self.state = self.best_state.copy()\n        \n        print(\"-\" * 60)\n        print(f\"Optimization Complete!\")\n        print(f\"Final Best Energy: {self.best_energy:.4f}\")\n        print(f\"Total Iterations: {iteration}\")\n        \n        return {\n            'best_energy': self.best_energy,\n            'best_state': self.best_state.copy(),\n            'energy_history': energy_history,\n            'temperature_history': temperature_history,\n            'iterations': iteration\n        }\n    \n    def visualize(self, title: str = \"Circle Packing Solution\"):\n        \"\"\"\n        Visualize the circle packing solution.\n        \n        Args:\n            title: Plot title\n        \"\"\"\n        fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n        \n        # Draw container\n        container = plt.Rectangle(\n            (0, 0), \n            self.container_size, \n            self.container_size,\n            fill=False, \n            edgecolor='black', \n            linewidth=2\n        )\n        ax.add_patch(container)\n        \n        # Draw circles\n        colors = plt.cm.tab20c(np.linspace(0, 1, self.num_circles))\n        \n        for i in range(self.num_circles):\n            x, y, r = self.get_circle(i)\n            circle = Circle(\n                (x, y), \n                r, \n                fill=True, \n                facecolor=colors[i], \n                edgecolor='black',\n                linewidth=1.5, \n                alpha=0.7\n            )\n            ax.add_patch(circle)\n            \n            # Add circle label (A-Z)\n            label = chr(ord('A') + i)\n            ax.text(x, y, label, ha='center', va='center', \n                   fontsize=8, fontweight='bold')\n        \n        ax.set_xlim(-5, self.container_size + 5)\n        ax.set_ylim(-5, self.container_size + 5)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_title(f\"{title}\\nEnergy: {self.best_energy:.4f}\")\n        \n        plt.tight_layout()\n        return fig, ax\n    \n    def plot_convergence(self, energy_history: List[float], \n                        temperature_history: List[float]):\n        \"\"\"\n        Plot convergence and temperature schedule.\n        \n        Args:\n            energy_history: List of energy values over iterations\n            temperature_history: List of temperature values over iterations\n        \"\"\"\n        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))\n        \n        # Energy convergence\n        ax1.plot(energy_history, linewidth=0.5, color='blue')\n        ax1.set_xlabel('Iteration')\n        ax1.set_ylabel('Best Energy')\n        ax1.set_title('Energy Convergence')\n        ax1.grid(True, alpha=0.3)\n        \n        # Temperature schedule\n        ax2.plot(temperature_history, linewidth=0.5, color='red')\n        ax2.set_xlabel('Iteration')\n        ax2.set_ylabel('Temperature')\n        ax2.set_title('Temperature Schedule')\n        ax2.grid(True, alpha=0.3)\n        \n        plt.tight_layout()\n        return fig, (ax1, ax2)\n    \n    def get_statistics(self) -> dict:\n        \"\"\"\n        Calculate packing statistics.\n        \n        Returns:\n            Dictionary with packing metrics\n        \"\"\"\n        total_area = 0.0\n        min_x = min_y = float('inf')\n        max_x = max_y = float('-inf')\n        \n        for i in range(self.num_circles):\n            x, y, r = self.get_circle(i)\n            total_area += np.pi * r ** 2\n            min_x = min(min_x, x - r)\n            min_y = min(min_y, y - r)\n            max_x = max(max_x, x + r)\n            max_y = max(max_y, y + r)\n        \n        bounding_width = max_x - min_x\n        bounding_height = max_y - min_y\n        bounding_area = bounding_width * bounding_height\n        packing_efficiency = (total_area / bounding_area) * 100 if bounding_area > 0 else 0\n        \n        # Check for overlaps\n        overlap_count = 0\n        for i in range(self.num_circles):\n            for j in range(i + 1, self.num_circles):\n                if self.check_overlap(i, j) > 0.01:\n                    overlap_count += 1\n        \n        return {\n            'total_circle_area': total_area,\n            'bounding_box_area': bounding_area,\n            'bounding_width': bounding_width,",
  "reasoning": "# Circle Packing Algorithm using Simulated Annealing\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom typing import Tuple, List\nimport math\n\nclass CirclePacking:\n    \"\"\"\n    Circle packing optimizer using simulated annealing.\n    Packs 26 circles (representing letters A-Z) into a minimal area.\n    \"\"\"\n    \n    def __init__(self, num_circles: int = 26, container_size: float = 100.0):\n        \"\"\"\n        Initialize circle packing problem.\n        \n        Args:\n            num_circles: Number of circles to pack\n            container_size: Size of the bounding container\n        \"\"\"\n        self.num_circles = num_circles\n        self.container_size = container_size\n        self.min_radius = 1.0\n        self.max_radius = 5.0\n        \n        # State: [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n        self.state = None\n        self.best_state = None\n        self.best_energy = float('inf')\n        \n    def construct_packing(self) -> np.ndarray:\n        \"\"\"\n        Construct initial random circle packing configuration.\n        \n        Returns:\n            Initial state array with random positions and radii\n        \"\"\"\n        state = np.zeros(self.num_circles * 3)\n        \n        for i in range(self.num_circles):\n            # Random position within container\n            state[i * 3] = np.random.uniform(\n                self.min_radius, \n                self.container_size - self.min_radius\n            )\n            state[i * 3 + 1] = np.random.uniform(\n                self.min_radius, \n                self.container_size - self.min_radius\n            )\n            # Random radius\n            state[i * 3 + 2] = np.random.uniform(\n                self.min_radius, \n                self.max_radius\n            )\n        \n        self.state = state.copy()\n        self.best_state = state.copy()\n        return state\n    \n    def get_circle(self, idx: int) -> Tuple[float, float, float]:\n        \"\"\"\n        Extract circle parameters from state.\n        \n        Args:\n            idx: Circle index (0 to num_circles-1)\n            \n        Returns:\n            Tuple of (x, y, radius)\n        \"\"\"\n        base_idx = idx * 3\n        return (self.state[base_idx], self.state[base_idx + 1], \n                self.state[base_idx + 2])\n    \n    def set_circle(self, idx: int, x: float, y: float, r: float):\n        \"\"\"\n        Update circle parameters in state.\n        \n        Args:\n            idx: Circle index\n            x, y: Center coordinates\n            r: Radius\n        \"\"\"\n        base_idx = idx * 3\n        self.state[base_idx] = x\n        self.state[base_idx + 1] = y\n        self.state[base_idx + 2] = r\n    \n    def distance_between_circles(self, idx1: int, idx2: int) -> float:\n        \"\"\"\n        Calculate distance between two circle centers.\n        \n        Args:\n            idx1, idx2: Circle indices\n            \n        Returns:\n            Distance between centers\n        \"\"\"\n        x1, y1, _ = self.get_circle(idx1)\n        x2, y2, _ = self.get_circle(idx2)\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    \n    def check_overlap(self, idx1: int, idx2: int, \n                     min_distance: float = 0.01) -> float:\n        \"\"\"\n        Calculate overlap penalty between two circles.\n        \n        Args:\n            idx1, idx2: Circle indices\n            min_distance: Minimum allowed distance between surfaces\n            \n        Returns:\n            Overlap penalty (0 if no overlap)\n        \"\"\"\n        _, _, r1 = self.get_circle(idx1)\n        _, _, r2 = self.get_circle(idx2)\n        distance = self.distance_between_circles(idx1, idx2)\n        min_dist = r1 + r2 + min_distance\n        \n        if distance < min_dist:\n            return (min_dist - distance) ** 2\n        return 0.0\n    \n    def check_boundary(self, idx: int) -> float:\n        \"\"\"\n        Calculate penalty for circles outside container.\n        \n        Args:\n            idx: Circle index\n            \n        Returns:\n            Boundary violation penalty\n        \"\"\"\n        x, y, r = self.get_circle(idx)\n        penalty = 0.0\n        \n        # Check left and right boundaries\n        if x - r < 0:\n            penalty += (r - x) ** 2\n        if x + r > self.container_size:\n            penalty += (x + r - self.container_size) ** 2\n        \n        # Check top and bottom boundaries\n        if y - r < 0:\n            penalty += (r - y) ** 2\n        if y + r > self.container_size:\n            penalty += (y + r - self.container_size) ** 2\n        \n        return penalty\n    \n    def calculate_energy(self) -> float:\n        \"\"\"\n        Calculate total energy (objective function to minimize).\n        \n        Energy consists of:\n        1. Overlap penalties\n        2. Boundary violation penalties\n        3. Bounding box size (to minimize total area)\n        \n        Returns:\n            Total energy value\n        \"\"\"\n        energy = 0.0\n        \n        # Overlap penalties\n        for i in range(self.num_circles):\n            for j in range(i + 1, self.num_circles):\n                energy += self.check_overlap(i, j)\n        \n        # Boundary penalties\n        for i in range(self.num_circles):\n            energy += self.check_boundary(i)\n        \n        # Bounding box size penalty (encourage compact packing)\n        min_x = min_y = float('inf')\n        max_x = max_y = float('-inf')\n        \n        for i in range(self.num_circles):\n            x, y, r = self.get_circle(i)\n            min_x = min(min_x, x - r)\n            min_y = min(min_y, y - r)\n            max_x = max(max_x, x + r)\n            max_y = max(max_y, y + r)\n        \n        if min_x != float('inf'):\n            width = max(0, max_x - min_x)\n            height = max(0, max_y - min_y)\n            bounding_area = width * height\n            energy += 0.1 * bounding_area / (self.container_size ** 2)\n        \n        return energy\n    \n    def get_neighbor_state(self, temperature: float) -> np.ndarray:\n        \"\"\"\n        Generate neighboring state using random perturbation.\n        \n        Args:\n            temperature: Current temperature (controls perturbation magnitude)\n            \n        Returns:\n            Perturbed state\n        \"\"\"\n        neighbor_state = self.state.copy()\n        \n        # Randomly select a circle to modify\n        circle_idx = np.random.randint(0, self.num_circles)\n        x, y, r = self.get_circle(circle_idx)\n        \n        # Perturbation magnitude decreases with temperature\n        perturbation = temperature / 10.0\n        \n        # Random choice: move position or change radius\n        choice = np.random.random()\n        \n        if choice < 0.7:  # Move position\n            x += np.random.normal(0, perturbation)\n            y += np.random.normal(0, perturbation)\n        else:  # Change radius\n            r += np.random.normal(0, perturbation * 0.5)\n            r = np.clip(r, self.min_radius, self.max_radius)\n        \n        # Ensure position stays within bounds\n        x = np.clip(x, self.min_radius, self.container_size - self.min_radius)\n        y = np.clip(y, self.min_radius, self.container_size - self.min_radius)\n        \n        # Update neighbor state\n        base_idx = circle_idx * 3\n        neighbor_state[base_idx] = x\n        neighbor_state[base_idx + 1] = y\n        neighbor_state[base_idx + 2] = r\n        \n        return neighbor_state\n    \n    def run_packing(self, initial_temperature: float = 50.0,\n                   cooling_rate: float = 0.995,\n                   iterations_per_temp: int = 100,\n                   min_temperature: float = 0.1) -> dict:\n        \"\"\"\n        Run simulated annealing optimization.\n        \n        Args:\n            initial_temperature: Starting temperature\n            cooling_rate: Temperature reduction factor (0 < rate < 1)\n            iterations_per_temp: Iterations at each temperature\n            min_temperature: Stopping temperature threshold\n            \n        Returns:\n            Dictionary with optimization results\n        \"\"\"\n        temperature = initial_temperature\n        current_energy = self.calculate_energy()\n        self.best_energy = current_energy\n        self.best_state = self.state.copy()\n        \n        iteration = 0\n        temperature_step = 0\n        energy_history = []\n        temperature_history = []\n        \n        print(f\"Starting Simulated Annealing\")\n        print(f\"Initial Energy: {current_energy:.4f}\")\n        print(\"-\" * 60)\n        \n        while temperature > min_temperature:\n            for _ in range(iterations_per_temp):\n                # Generate neighbor solution\n                neighbor_state = self.get_neighbor_state(temperature)\n                old_state = self.state.copy()\n                self.state = neighbor_state\n                \n                # Calculate neighbor energy\n                neighbor_energy = self.calculate_energy()\n                \n                # Metropolis acceptance criterion\n                energy_diff = neighbor_energy - current_energy\n                \n                if energy_diff < 0:  # Better solution\n                    current_energy = neighbor_energy\n                    if current_energy < self.best_energy:\n                        self.best_energy = current_energy\n                        self.best_state = self.state.copy()\n                else:  # Worse solution\n                    acceptance_prob = np.exp(-energy_diff / temperature)\n                    if np.random.random() < acceptance_prob:\n                        current_energy = neighbor_energy\n                    else:\n                        self.state = old_state\n                \n                iteration += 1\n                energy_history.append(self.best_energy)\n                temperature_history.append(temperature)\n            \n            # Cool down\n            temperature *= cooling_rate\n            temperature_step += 1\n            \n            if temperature_step % 10 == 0:\n                print(f\"Step {temperature_step:3d} | \"\n                      f\"Temp: {temperature:7.4f} | \"\n                      f\"Best Energy: {self.best_energy:10.4f} | \"\n                      f\"Iterations: {iteration:6d}\")\n        \n        # Restore best state\n        self.state = self.best_state.copy()\n        \n        print(\"-\" * 60)\n        print(f\"Optimization Complete!\")\n        print(f\"Final Best Energy: {self.best_energy:.4f}\")\n        print(f\"Total Iterations: {iteration}\")\n        \n        return {\n            'best_energy': self.best_energy,\n            'best_state': self.best_state.copy(),\n            'energy_history': energy_history,\n            'temperature_history': temperature_history,\n            'iterations': iteration\n        }\n    \n    def visualize(self, title: str = \"Circle Packing Solution\"):\n        \"\"\"\n        Visualize the circle packing solution.\n        \n        Args:\n            title: Plot title\n        \"\"\"\n        fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n        \n        # Draw container\n        container = plt.Rectangle(\n            (0, 0), \n            self.container_size, \n            self.container_size,\n            fill=False, \n            edgecolor='black', \n            linewidth=2\n        )\n        ax.add_patch(container)\n        \n        # Draw circles\n        colors = plt.cm.tab20c(np.linspace(0, 1, self.num_circles))\n        \n        for i in range(self.num_circles):\n            x, y, r = self.get_circle(i)\n            circle = Circle(\n                (x, y), \n                r, \n                fill=True, \n                facecolor=colors[i], \n                edgecolor='black',\n                linewidth=1.5, \n                alpha=0.7\n            )\n            ax.add_patch(circle)\n            \n            # Add circle label (A-Z)\n            label = chr(ord('A') + i)\n            ax.text(x, y, label, ha='center', va='center', \n                   fontsize=8, fontweight='bold')\n        \n        ax.set_xlim(-5, self.container_size + 5)\n        ax.set_ylim(-5, self.container_size + 5)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_title(f\"{title}\\nEnergy: {self.best_energy:.4f}\")\n        \n        plt.tight_layout()\n        return fig, ax\n    \n    def plot_convergence(self, energy_history: List[float], \n                        temperature_history: List[float]):\n        \"\"\"\n        Plot convergence and temperature schedule.\n        \n        Args:\n            energy_history: List of energy values over iterations\n            temperature_history: List of temperature values over iterations\n        \"\"\"\n        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))\n        \n        # Energy convergence\n        ax1.plot(energy_history, linewidth=0.5, color='blue')\n        ax1.set_xlabel('Iteration')\n        ax1.set_ylabel('Best Energy')\n        ax1.set_title('Energy Convergence')\n        ax1.grid(True, alpha=0.3)\n        \n        # Temperature schedule\n        ax2.plot(temperature_history, linewidth=0.5, color='red')\n        ax2.set_xlabel('Iteration')\n        ax2.set_ylabel('Temperature')\n        ax2.set_title('Temperature Schedule')\n        ax2.grid(True, alpha=0.3)\n        \n        plt.tight_layout()\n        return fig, (ax1, ax2)\n    \n    def get_statistics(self) -> dict:\n        \"\"\"\n        Calculate packing statistics.\n        \n        Returns:\n            Dictionary with packing metrics\n        \"\"\"\n        total_area = 0.0\n        min_x = min_y = float('inf')\n        max_x = max_y = float('-inf')\n        \n        for i in range(self.num_circles):\n            x, y, r = self.get_circle(i)\n            total_area += np.pi * r ** 2\n            min_x = min(min_x, x - r)\n            min_y = min(min_y, y - r)\n            max_x = max(max_x, x + r)\n            max_y = max(max_y, y + r)\n        \n        bounding_width = max_x - min_x\n        bounding_height = max_y - min_y\n        bounding_area = bounding_width * bounding_height\n        packing_efficiency = (total_area / bounding_area) * 100 if bounding_area > 0 else 0\n        \n        # Check for overlaps\n        overlap_count = 0\n        for i in range(self.num_circles):\n            for j in range(i + 1, self.num_circles):\n                if self.check_overlap(i, j) > 0.01:\n                    overlap_count += 1\n        \n        return {\n            'total_circle_area': total_area,\n            'bounding_box_area': bounding_area,\n            'bounding_width': bounding_width,",
  "timestamp": "2025-12-08T12:15:13.873568",
  "cost_data": null
}