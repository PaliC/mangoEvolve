{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a circle packing algorithm for 26 circles using a space-filling curve approach. Place circles along a Hilbert curve or similar space-filling pattern, then optimize radii. Include construct_packing() and run_packing() functions.",
  "response": "# Circle Packing Algorithm Using Space-Filling Curves\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom scipy.optimize import minimize\nfrom typing import List, Tuple, Optional\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\n\nclass HilbertCurve:\n    \"\"\"Generate 2D Hilbert curve coordinates.\"\"\"\n    \n    def __init__(self, order: int):\n        \"\"\"\n        Initialize Hilbert curve generator.\n        \n        Args:\n            order: Hilbert curve order (determines resolution)\n        \"\"\"\n        self.order = order\n        self.size = 2 ** order\n    \n    def xy2d(self, x: int, y: int) -> int:\n        \"\"\"Convert (x,y) coordinates to Hilbert curve distance.\"\"\"\n        d = 0\n        s = self.size // 2\n        while s > 0:\n            rx = 1 if (x & s) > 0 else 0\n            ry = 1 if (y & s) > 0 else 0\n            d += s * s * ((3 * rx) ^ ry)\n            x, y = self._rotate(s, x, y, rx, ry)\n            s //= 2\n        return d\n    \n    def d2xy(self, d: int) -> Tuple[float, float]:\n        \"\"\"Convert Hilbert curve distance to (x,y) coordinates.\"\"\"\n        x = y = 0\n        s = 1\n        while s < self.size:\n            rx = 1 & (d >> 1)\n            ry = 1 & (d ^ rx)\n            x, y = self._rotate(s, x, y, rx, ry)\n            x += s * rx\n            y += s * ry\n            d >>= 2\n            s <<= 1\n        return float(x), float(y)\n    \n    @staticmethod\n    def _rotate(n: int, x: int, y: int, rx: int, ry: int) -> Tuple[int, int]:\n        \"\"\"Rotate/flip a quadrant appropriately.\"\"\"\n        if ry == 0:\n            if rx == 1:\n                x = n - 1 - x\n                y = n - 1 - y\n            x, y = y, x\n        return x, y\n    \n    def get_points(self, num_points: int, \n                   bounds: Tuple[float, float, float, float] = (0, 0, 100, 100)\n                   ) -> np.ndarray:\n        \"\"\"\n        Get points along Hilbert curve.\n        \n        Args:\n            num_points: Number of points to generate\n            bounds: (x_min, y_min, x_max, y_max)\n        \n        Returns:\n            Array of shape (num_points, 2) with (x, y) coordinates\n        \"\"\"\n        x_min, y_min, x_max, y_max = bounds\n        points = []\n        \n        for i in range(num_points):\n            # Map point index to Hilbert curve distance\n            d = int((i / num_points) * (self.size * self.size - 1))\n            x, y = self.d2xy(d)\n            \n            # Normalize to bounds\n            x_norm = x_min + (x / self.size) * (x_max - x_min)\n            y_norm = y_min + (y / self.size) * (y_max - y_min)\n            points.append([x_norm, y_norm])\n        \n        return np.array(points)\n\n\nclass CirclePacking:\n    \"\"\"Circle packing using space-filling curves.\"\"\"\n    \n    def __init__(self, num_circles: int = 26, \n                 bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n                 initial_radius: float = 3.0):\n        \"\"\"\n        Initialize circle packing.\n        \n        Args:\n            num_circles: Number of circles to pack\n            bounds: (x_min, y_min, x_max, y_max)\n            initial_radius: Initial radius for all circles\n        \"\"\"\n        self.num_circles = num_circles\n        self.bounds = bounds\n        self.initial_radius = initial_radius\n        \n        self.centers: Optional[np.ndarray] = None\n        self.radii: Optional[np.ndarray] = None\n        self.history: List[float] = []\n    \n    def construct_packing(self, \n                         hilbert_order: int = 4,\n                         use_jitter: bool = True,\n                         jitter_scale: float = 0.1) -> None:\n        \"\"\"\n        Construct initial circle packing using Hilbert curve.\n        \n        Args:\n            hilbert_order: Order of Hilbert curve\n            use_jitter: Add random jitter to positions\n            jitter_scale: Scale of jitter relative to spacing\n        \"\"\"\n        # Generate Hilbert curve points\n        hilbert = HilbertCurve(hilbert_order)\n        self.centers = hilbert.get_points(self.num_circles, self.bounds)\n        \n        # Add jitter for better spacing\n        if use_jitter:\n            x_min, y_min, x_max, y_max = self.bounds\n            spacing_x = (x_max - x_min) / np.sqrt(self.num_circles)\n            spacing_y = (y_max - y_min) / np.sqrt(self.num_circles)\n            \n            jitter = np.random.normal(\n                0, \n                jitter_scale * min(spacing_x, spacing_y),\n                self.centers.shape\n            )\n            self.centers = np.clip(\n                self.centers + jitter,\n                [x_min, y_min],\n                [x_max, y_max]\n            )\n        \n        # Initialize radii\n        self.radii = np.full(self.num_circles, self.initial_radius)\n        \n        print(f\"\u2713 Initial packing constructed with {self.num_circles} circles\")\n        print(f\"  Centers shape: {self.centers.shape}\")\n        print(f\"  Radii shape: {self.radii.shape}\")\n    \n    def _check_bounds(self, centers: np.ndarray, radii: np.ndarray) -> float:\n        \"\"\"\n        Calculate penalty for circles outside bounds.\n        \n        Returns:\n            Penalty value\n        \"\"\"\n        x_min, y_min, x_max, y_max = self.bounds\n        penalty = 0.0\n        \n        for i in range(len(centers)):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Penalty for exceeding bounds\n            if x - r < x_min:\n                penalty += (x_min - (x - r)) ** 2\n            if x + r > x_max:\n                penalty += ((x + r) - x_max) ** 2\n            if y - r < y_min:\n                penalty += (y_min - (y - r)) ** 2\n            if y + r > y_max:\n                penalty += ((y + r) - y_max) ** 2\n        \n        return penalty\n    \n    def _check_overlaps(self, centers: np.ndarray, radii: np.ndarray) -> float:\n        \"\"\"\n        Calculate penalty for overlapping circles.\n        \n        Returns:\n            Penalty value\n        \"\"\"\n        penalty = 0.0\n        \n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx**2 + dy**2)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    penalty += overlap ** 2\n        \n        return penalty\n    \n    def _objective(self, radii_flat: np.ndarray) -> float:\n        \"\"\"\n        Objective function to minimize: maximize packing efficiency.\n        \n        Args:\n            radii_flat: Flattened radii array\n        \n        Returns:\n            Objective value (negative total area + penalties)\n        \"\"\"\n        radii = radii_flat.reshape(-1, 1).flatten()\n        \n        # Ensure non-negative radii\n        radii = np.maximum(radii, 0.01)\n        \n        # Total area (we want to maximize, so negate)\n        total_area = -np.sum(np.pi * radii ** 2)\n        \n        # Penalties\n        overlap_penalty = 1000 * self._check_overlaps(self.centers, radii)\n        bounds_penalty = 1000 * self._check_bounds(self.centers, radii)\n        \n        return total_area + overlap_penalty + bounds_penalty\n    \n    def _objective_with_centers(self, params: np.ndarray) -> float:\n        \"\"\"\n        Objective function with both centers and radii as variables.\n        \n        Args:\n            params: Flattened array [x1, y1, x2, y2, ..., r1, r2, ...]\n        \n        Returns:\n            Objective value\n        \"\"\"\n        centers = params[:self.num_circles * 2].reshape(-1, 2)\n        radii = params[self.num_circles * 2:]\n        \n        # Ensure non-negative radii\n        radii = np.maximum(radii, 0.01)\n        \n        # Total area\n        total_area = -np.sum(np.pi * radii ** 2)\n        \n        # Penalties\n        overlap_penalty = 1000 * self._check_overlaps(centers, radii)\n        bounds_penalty = 1000 * self._check_bounds(centers, radii)\n        \n        return total_area + overlap_penalty + bounds_penalty\n    \n    def run_packing(self, \n                   max_iterations: int = 1000,\n                   optimize_centers: bool = False,\n                   verbose: bool = True) -> None:\n        \"\"\"\n        Run circle packing optimization.\n        \n        Args:\n            max_iterations: Maximum optimization iterations\n            optimize_centers: Whether to optimize center positions\n            verbose: Print progress information\n        \"\"\"\n        if self.centers is None:\n            raise ValueError(\"Must call construct_packing() first\")\n        \n        # Phase 1: Optimize radii only\n        if verbose:\n            print(\"\\n\" + \"=\"*60)\n            print(\"PHASE 1: Optimizing radii (fixed centers)\")\n            print(\"=\"*60)\n        \n        result = minimize(\n            self._objective,\n            self.radii.flatten(),\n            method='L-BFGS-B',\n            bounds=[(0.01, None) for _ in range(self.num_circles)],\n            options={'maxiter': max_iterations, 'ftol': 1e-6},\n            callback=lambda x: self._callback_phase1(x, verbose)\n        )\n        \n        self.radii = result.x\n        \n        if verbose:\n            print(f\"\\n\u2713 Phase 1 complete\")\n            print(f\"  Final objective: {result.fun:.4f}\")\n            print(f\"  Total area: {np.sum(np.pi * self.radii ** 2):.4f}\")\n        \n        # Phase 2: Joint optimization (optional)\n        if optimize_centers:\n            if verbose:\n                print(\"\\n\" + \"=\"*60)\n                print(\"PHASE 2: Joint optimization (centers + radii)\")\n                print(\"=\"*60)\n            \n            params = np.concatenate([self.centers.flatten(), self.radii.flatten()])\n            \n            result = minimize(\n                self._objective_with_centers,\n                params,\n                method='L-BFGS-B',\n                options={'maxiter': max_iterations // 2, 'ftol': 1e-6},\n                callback=lambda x: self._callback_phase2(x, verbose)\n            )\n            \n            self.centers = result.x[:self.num_circles * 2].reshape(-1, 2)\n            self.radii = result.x[self.num_circles * 2:]\n            self.radii = np.maximum(self.radii, 0.01)\n            \n            if verbose:\n                print(f\"\\n\u2713 Phase 2 complete\")\n                print(f\"  Final objective: {result.fun:.4f}\")\n                print(f\"  Total area: {np.sum(np.pi * self.radii ** 2):.4f}\")\n    \n    def _callback_phase1(self, x: np.ndarray, verbose: bool) -> None:\n        \"\"\"Callback for phase 1 optimization.\"\"\"\n        obj = self._objective(x)\n        self.history.append(obj)\n        \n        if verbose and len(self.history) % 50 == 0:\n            print(f\"  Iteration {len(self.history):4d}: objective = {obj:10.4f}\")\n    \n    def _callback_phase2(self, x: np.ndarray, verbose: bool) -> None:\n        \"\"\"Callback for phase 2 optimization.\"\"\"\n        obj = self._objective_with_centers(x)\n        self.history.append(obj)\n        \n        if verbose and len(self.history) % 50 == 0:\n            print(f\"  Iteration {len(self.history):4d}: objective = {obj:10.4f}\")\n    \n    def get_statistics(self) -> dict:\n        \"\"\"\n        Get packing statistics.\n        \n        Returns:\n            Dictionary with statistics\n        \"\"\"\n        if self.radii is None:\n            return {}\n        \n        total_area = np.sum(np.pi * self.radii ** 2)\n        x_min, y_min, x_max, y_max = self.bounds\n        container_area = (x_max - x_min) * (y_max - y_min)\n        efficiency = 100 * total_area / container_area\n        \n        overlap_penalty = self._check_overlaps(self.centers, self.radii)\n        bounds_penalty = self._check_bounds(self.centers, self.radii)\n        \n        return {\n            'num_circles': self.num_circles,\n            'total_area': total_area,\n            'container_area': container_area,\n            'packing_efficiency': efficiency,\n            'mean_radius': np.mean(self.radii),\n            'std_radius': np.std(self.radii),\n            'min_radius': np.min(self.radii),\n            'max_radius': np.max(self.radii),\n            'overlap_penalty': overlap_penalty,\n            'bounds_penalty': bounds_penalty,\n        }\n    \n    def visualize(self, figsize: Tuple[int, int] = (12, 10),\n                 show_hilbert: bool = True) -> None:\n        \"\"\"\n        Visualize the circle packing.\n        \n        Args:\n            figsize: Figure size\n            show_hilbert: Whether to show Hilbert curve\n        \"\"\"\n        if self.centers is None or self.radii is None:\n            raise ValueError(\"Must run packing first\")\n        \n        fig, axes = plt.subplots(1, 2, figsize=figsize)\n        \n        # Left plot: Circle packing\n        ax = axes[0]\n        x_min, y_min, x_max, y_max = self.bounds\n        \n        # Draw boundary\n        rect = plt.Rectangle((x_min, y_min), x_max - x_min, y_max - y_min,\n                            fill=False, edgecolor='black', linewidth=2)\n        ax.add_patch(rect)\n        \n        # Draw circles\n        for i, (center, radius) in enumerate(zip(self.centers, self.radii)):\n            circle = Circle(center, radius, fill=False, edgecolor='blue', \n                          linewidth=1.5, alpha=0.7)\n            ax.add_patch(circle)\n            \n            # Add circle number\n            ax.text(center[0], center[1], str(i+1), \n                   ha='center', va='center', fontsize=8, fontweight='bold')\n        \n        ax.set_xlim(x_min - 5, x_max",
  "reasoning": "# Circle Packing Algorithm Using Space-Filling Curves\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom scipy.optimize import minimize\nfrom typing import List, Tuple, Optional\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\nclass HilbertCurve:\n    \"\"\"Generate 2D Hilbert curve coordinates.\"\"\"\n    \n    def __init__(self, order: int):\n        \"\"\"\n        Initialize Hilbert curve generator.\n        \n        Args:\n            order: Hilbert curve order (determines resolution)\n        \"\"\"\n        self.order = order\n        self.size = 2 ** order\n    \n    def xy2d(self, x: int, y: int) -> int:\n        \"\"\"Convert (x,y) coordinates to Hilbert curve distance.\"\"\"\n        d = 0\n        s = self.size // 2\n        while s > 0:\n            rx = 1 if (x & s) > 0 else 0\n            ry = 1 if (y & s) > 0 else 0\n            d += s * s * ((3 * rx) ^ ry)\n            x, y = self._rotate(s, x, y, rx, ry)\n            s //= 2\n        return d\n    \n    def d2xy(self, d: int) -> Tuple[float, float]:\n        \"\"\"Convert Hilbert curve distance to (x,y) coordinates.\"\"\"\n        x = y = 0\n        s = 1\n        while s < self.size:\n            rx = 1 & (d >> 1)\n            ry = 1 & (d ^ rx)\n            x, y = self._rotate(s, x, y, rx, ry)\n            x += s * rx\n            y += s * ry\n            d >>= 2\n            s <<= 1\n        return float(x), float(y)\n    \n    @staticmethod\n    def _rotate(n: int, x: int, y: int, rx: int, ry: int) -> Tuple[int, int]:\n        \"\"\"Rotate/flip a quadrant appropriately.\"\"\"\n        if ry == 0:\n            if rx == 1:\n                x = n - 1 - x\n                y = n - 1 - y\n            x, y = y, x\n        return x, y\n    \n    def get_points(self, num_points: int, \n                   bounds: Tuple[float, float, float, float] = (0, 0, 100, 100)\n                   ) -> np.ndarray:\n        \"\"\"\n        Get points along Hilbert curve.\n        \n        Args:\n            num_points: Number of points to generate\n            bounds: (x_min, y_min, x_max, y_max)\n        \n        Returns:\n            Array of shape (num_points, 2) with (x, y) coordinates\n        \"\"\"\n        x_min, y_min, x_max, y_max = bounds\n        points = []\n        \n        for i in range(num_points):\n            # Map point index to Hilbert curve distance\n            d = int((i / num_points) * (self.size * self.size - 1))\n            x, y = self.d2xy(d)\n            \n            # Normalize to bounds\n            x_norm = x_min + (x / self.size) * (x_max - x_min)\n            y_norm = y_min + (y / self.size) * (y_max - y_min)\n            points.append([x_norm, y_norm])\n        \n        return np.array(points)\n\nclass CirclePacking:\n    \"\"\"Circle packing using space-filling curves.\"\"\"\n    \n    def __init__(self, num_circles: int = 26, \n                 bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n                 initial_radius: float = 3.0):\n        \"\"\"\n        Initialize circle packing.\n        \n        Args:\n            num_circles: Number of circles to pack\n            bounds: (x_min, y_min, x_max, y_max)\n            initial_radius: Initial radius for all circles\n        \"\"\"\n        self.num_circles = num_circles\n        self.bounds = bounds\n        self.initial_radius = initial_radius\n        \n        self.centers: Optional[np.ndarray] = None\n        self.radii: Optional[np.ndarray] = None\n        self.history: List[float] = []\n    \n    def construct_packing(self, \n                         hilbert_order: int = 4,\n                         use_jitter: bool = True,\n                         jitter_scale: float = 0.1) -> None:\n        \"\"\"\n        Construct initial circle packing using Hilbert curve.\n        \n        Args:\n            hilbert_order: Order of Hilbert curve\n            use_jitter: Add random jitter to positions\n            jitter_scale: Scale of jitter relative to spacing\n        \"\"\"\n        # Generate Hilbert curve points\n        hilbert = HilbertCurve(hilbert_order)\n        self.centers = hilbert.get_points(self.num_circles, self.bounds)\n        \n        # Add jitter for better spacing\n        if use_jitter:\n            x_min, y_min, x_max, y_max = self.bounds\n            spacing_x = (x_max - x_min) / np.sqrt(self.num_circles)\n            spacing_y = (y_max - y_min) / np.sqrt(self.num_circles)\n            \n            jitter = np.random.normal(\n                0, \n                jitter_scale * min(spacing_x, spacing_y),\n                self.centers.shape\n            )\n            self.centers = np.clip(\n                self.centers + jitter,\n                [x_min, y_min],\n                [x_max, y_max]\n            )\n        \n        # Initialize radii\n        self.radii = np.full(self.num_circles, self.initial_radius)\n        \n        print(f\"\u2713 Initial packing constructed with {self.num_circles} circles\")\n        print(f\"  Centers shape: {self.centers.shape}\")\n        print(f\"  Radii shape: {self.radii.shape}\")\n    \n    def _check_bounds(self, centers: np.ndarray, radii: np.ndarray) -> float:\n        \"\"\"\n        Calculate penalty for circles outside bounds.\n        \n        Returns:\n            Penalty value\n        \"\"\"\n        x_min, y_min, x_max, y_max = self.bounds\n        penalty = 0.0\n        \n        for i in range(len(centers)):\n            x, y = centers[i]\n            r = radii[i]\n            \n            # Penalty for exceeding bounds\n            if x - r < x_min:\n                penalty += (x_min - (x - r)) ** 2\n            if x + r > x_max:\n                penalty += ((x + r) - x_max) ** 2\n            if y - r < y_min:\n                penalty += (y_min - (y - r)) ** 2\n            if y + r > y_max:\n                penalty += ((y + r) - y_max) ** 2\n        \n        return penalty\n    \n    def _check_overlaps(self, centers: np.ndarray, radii: np.ndarray) -> float:\n        \"\"\"\n        Calculate penalty for overlapping circles.\n        \n        Returns:\n            Penalty value\n        \"\"\"\n        penalty = 0.0\n        \n        for i in range(len(centers)):\n            for j in range(i + 1, len(centers)):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = np.sqrt(dx**2 + dy**2)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    penalty += overlap ** 2\n        \n        return penalty\n    \n    def _objective(self, radii_flat: np.ndarray) -> float:\n        \"\"\"\n        Objective function to minimize: maximize packing efficiency.\n        \n        Args:\n            radii_flat: Flattened radii array\n        \n        Returns:\n            Objective value (negative total area + penalties)\n        \"\"\"\n        radii = radii_flat.reshape(-1, 1).flatten()\n        \n        # Ensure non-negative radii\n        radii = np.maximum(radii, 0.01)\n        \n        # Total area (we want to maximize, so negate)\n        total_area = -np.sum(np.pi * radii ** 2)\n        \n        # Penalties\n        overlap_penalty = 1000 * self._check_overlaps(self.centers, radii)\n        bounds_penalty = 1000 * self._check_bounds(self.centers, radii)\n        \n        return total_area + overlap_penalty + bounds_penalty\n    \n    def _objective_with_centers(self, params: np.ndarray) -> float:\n        \"\"\"\n        Objective function with both centers and radii as variables.\n        \n        Args:\n            params: Flattened array [x1, y1, x2, y2, ..., r1, r2, ...]\n        \n        Returns:\n            Objective value\n        \"\"\"\n        centers = params[:self.num_circles * 2].reshape(-1, 2)\n        radii = params[self.num_circles * 2:]\n        \n        # Ensure non-negative radii\n        radii = np.maximum(radii, 0.01)\n        \n        # Total area\n        total_area = -np.sum(np.pi * radii ** 2)\n        \n        # Penalties\n        overlap_penalty = 1000 * self._check_overlaps(centers, radii)\n        bounds_penalty = 1000 * self._check_bounds(centers, radii)\n        \n        return total_area + overlap_penalty + bounds_penalty\n    \n    def run_packing(self, \n                   max_iterations: int = 1000,\n                   optimize_centers: bool = False,\n                   verbose: bool = True) -> None:\n        \"\"\"\n        Run circle packing optimization.\n        \n        Args:\n            max_iterations: Maximum optimization iterations\n            optimize_centers: Whether to optimize center positions\n            verbose: Print progress information\n        \"\"\"\n        if self.centers is None:\n            raise ValueError(\"Must call construct_packing() first\")\n        \n        # Phase 1: Optimize radii only\n        if verbose:\n            print(\"\\n\" + \"=\"*60)\n            print(\"PHASE 1: Optimizing radii (fixed centers)\")\n            print(\"=\"*60)\n        \n        result = minimize(\n            self._objective,\n            self.radii.flatten(),\n            method='L-BFGS-B',\n            bounds=[(0.01, None) for _ in range(self.num_circles)],\n            options={'maxiter': max_iterations, 'ftol': 1e-6},\n            callback=lambda x: self._callback_phase1(x, verbose)\n        )\n        \n        self.radii = result.x\n        \n        if verbose:\n            print(f\"\\n\u2713 Phase 1 complete\")\n            print(f\"  Final objective: {result.fun:.4f}\")\n            print(f\"  Total area: {np.sum(np.pi * self.radii ** 2):.4f}\")\n        \n        # Phase 2: Joint optimization (optional)\n        if optimize_centers:\n            if verbose:\n                print(\"\\n\" + \"=\"*60)\n                print(\"PHASE 2: Joint optimization (centers + radii)\")\n                print(\"=\"*60)\n            \n            params = np.concatenate([self.centers.flatten(), self.radii.flatten()])\n            \n            result = minimize(\n                self._objective_with_centers,\n                params,\n                method='L-BFGS-B',\n                options={'maxiter': max_iterations // 2, 'ftol': 1e-6},\n                callback=lambda x: self._callback_phase2(x, verbose)\n            )\n            \n            self.centers = result.x[:self.num_circles * 2].reshape(-1, 2)\n            self.radii = result.x[self.num_circles * 2:]\n            self.radii = np.maximum(self.radii, 0.01)\n            \n            if verbose:\n                print(f\"\\n\u2713 Phase 2 complete\")\n                print(f\"  Final objective: {result.fun:.4f}\")\n                print(f\"  Total area: {np.sum(np.pi * self.radii ** 2):.4f}\")\n    \n    def _callback_phase1(self, x: np.ndarray, verbose: bool) -> None:\n        \"\"\"Callback for phase 1 optimization.\"\"\"\n        obj = self._objective(x)\n        self.history.append(obj)\n        \n        if verbose and len(self.history) % 50 == 0:\n            print(f\"  Iteration {len(self.history):4d}: objective = {obj:10.4f}\")\n    \n    def _callback_phase2(self, x: np.ndarray, verbose: bool) -> None:\n        \"\"\"Callback for phase 2 optimization.\"\"\"\n        obj = self._objective_with_centers(x)\n        self.history.append(obj)\n        \n        if verbose and len(self.history) % 50 == 0:\n            print(f\"  Iteration {len(self.history):4d}: objective = {obj:10.4f}\")\n    \n    def get_statistics(self) -> dict:\n        \"\"\"\n        Get packing statistics.\n        \n        Returns:\n            Dictionary with statistics\n        \"\"\"\n        if self.radii is None:\n            return {}\n        \n        total_area = np.sum(np.pi * self.radii ** 2)\n        x_min, y_min, x_max, y_max = self.bounds\n        container_area = (x_max - x_min) * (y_max - y_min)\n        efficiency = 100 * total_area / container_area\n        \n        overlap_penalty = self._check_overlaps(self.centers, self.radii)\n        bounds_penalty = self._check_bounds(self.centers, self.radii)\n        \n        return {\n            'num_circles': self.num_circles,\n            'total_area': total_area,\n            'container_area': container_area,\n            'packing_efficiency': efficiency,\n            'mean_radius': np.mean(self.radii),\n            'std_radius': np.std(self.radii),\n            'min_radius': np.min(self.radii),\n            'max_radius': np.max(self.radii),\n            'overlap_penalty': overlap_penalty,\n            'bounds_penalty': bounds_penalty,\n        }\n    \n    def visualize(self, figsize: Tuple[int, int] = (12, 10),\n                 show_hilbert: bool = True) -> None:\n        \"\"\"\n        Visualize the circle packing.\n        \n        Args:\n            figsize: Figure size\n            show_hilbert: Whether to show Hilbert curve\n        \"\"\"\n        if self.centers is None or self.radii is None:\n            raise ValueError(\"Must run packing first\")\n        \n        fig, axes = plt.subplots(1, 2, figsize=figsize)\n        \n        # Left plot: Circle packing\n        ax = axes[0]\n        x_min, y_min, x_max, y_max = self.bounds\n        \n        # Draw boundary\n        rect = plt.Rectangle((x_min, y_min), x_max - x_min, y_max - y_min,\n                            fill=False, edgecolor='black', linewidth=2)\n        ax.add_patch(rect)\n        \n        # Draw circles\n        for i, (center, radius) in enumerate(zip(self.centers, self.radii)):\n            circle = Circle(center, radius, fill=False, edgecolor='blue', \n                          linewidth=1.5, alpha=0.7)\n            ax.add_patch(circle)\n            \n            # Add circle number\n            ax.text(center[0], center[1], str(i+1), \n                   ha='center', va='center', fontsize=8, fontweight='bold')\n        \n        ax.set_xlim(x_min - 5, x_max",
  "timestamp": "2025-12-08T12:15:14.002490",
  "cost_data": null
}