{
  "trial_id": "trial_0_17",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a circle packing algorithm for 26 circles using a multi-phase optimization. Start with a coarse grid placement, then progressively refine positions and radii using multiple optimization passes with increasing precision. Include construct_packing() and run_packing() functions.",
  "response": "# Circle Packing Algorithm with Multi-Phase Optimization\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize\nfrom dataclasses import dataclass\nfrom typing import List, Tuple, Optional\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with position and radius\"\"\"\n    x: float\n    y: float\n    radius: float\n    label: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.radius <= 0:\n            raise ValueError(\"Radius must be positive\")\n    \n    @property\n    def position(self) -> np.ndarray:\n        return np.array([self.x, self.y])\n    \n    def distance_to(self, other: 'Circle') -> float:\n        \"\"\"Calculate distance between circle centers\"\"\"\n        return np.linalg.norm(self.position - other.position)\n    \n    def overlaps_with(self, other: 'Circle') -> bool:\n        \"\"\"Check if circles overlap\"\"\"\n        return self.distance_to(other) < (self.radius + other.radius)\n    \n    def __repr__(self) -> str:\n        return f\"Circle(x={self.x:.2f}, y={self.y:.2f}, r={self.radius:.2f})\"\n\n\nclass CirclePackingOptimizer:\n    \"\"\"Multi-phase circle packing optimizer\"\"\"\n    \n    def __init__(self, num_circles: int = 26, container_size: float = 100.0,\n                 target_radius: float = 2.0, seed: int = 42):\n        \"\"\"\n        Initialize the optimizer.\n        \n        Args:\n            num_circles: Number of circles to pack\n            container_size: Size of the square container\n            target_radius: Target radius for each circle\n            seed: Random seed for reproducibility\n        \"\"\"\n        self.num_circles = num_circles\n        self.container_size = container_size\n        self.target_radius = target_radius\n        self.seed = seed\n        np.random.seed(seed)\n        \n        self.circles: List[Circle] = []\n        self.optimization_history = []\n        \n    def construct_packing(self) -> List[Circle]:\n        \"\"\"\n        Phase 1: Coarse grid placement\n        Initialize circles on a regular grid with some randomization\n        \"\"\"\n        print(\"=\" * 60)\n        print(\"PHASE 1: COARSE GRID PLACEMENT\")\n        print(\"=\" * 60)\n        \n        circles = []\n        grid_size = int(np.ceil(np.sqrt(self.num_circles)))\n        cell_size = self.container_size / grid_size\n        \n        for i in range(self.num_circles):\n            row = i // grid_size\n            col = i % grid_size\n            \n            # Grid position with random jitter\n            x = col * cell_size + cell_size / 2 + np.random.uniform(-cell_size * 0.2, cell_size * 0.2)\n            y = row * cell_size + cell_size / 2 + np.random.uniform(-cell_size * 0.2, cell_size * 0.2)\n            \n            # Clamp to container\n            x = np.clip(x, self.target_radius, self.container_size - self.target_radius)\n            y = np.clip(y, self.target_radius, self.container_size - self.target_radius)\n            \n            circle = Circle(x, y, self.target_radius, label=chr(65 + i % 26))\n            circles.append(circle)\n        \n        self.circles = circles\n        initial_cost = self._calculate_packing_cost(circles)\n        print(f\"Initial grid placement cost: {initial_cost:.4f}\")\n        print(f\"Placed {len(circles)} circles on {grid_size}x{grid_size} grid\")\n        \n        return circles\n    \n    def run_packing(self) -> List[Circle]:\n        \"\"\"\n        Execute multi-phase optimization:\n        - Phase 1: Coarse grid placement\n        - Phase 2: Radius expansion with position refinement\n        - Phase 3: Fine position optimization\n        - Phase 4: Radius fine-tuning\n        - Phase 5: Final polishing\n        \"\"\"\n        # Phase 1: Initial placement\n        self.construct_packing()\n        \n        # Phase 2: Radius expansion\n        print(\"\\n\" + \"=\" * 60)\n        print(\"PHASE 2: RADIUS EXPANSION WITH POSITION REFINEMENT\")\n        print(\"=\" * 60)\n        self._phase_radius_expansion()\n        \n        # Phase 3: Fine position optimization\n        print(\"\\n\" + \"=\" * 60)\n        print(\"PHASE 3: FINE POSITION OPTIMIZATION\")\n        print(\"=\" * 60)\n        self._phase_position_refinement()\n        \n        # Phase 4: Radius fine-tuning\n        print(\"\\n\" + \"=\" * 60)\n        print(\"PHASE 4: RADIUS FINE-TUNING\")\n        print(\"=\" * 60)\n        self._phase_radius_finetuning()\n        \n        # Phase 5: Final polishing\n        print(\"\\n\" + \"=\" * 60)\n        print(\"PHASE 5: FINAL POLISHING\")\n        print(\"=\" * 60)\n        self._phase_final_polish()\n        \n        return self.circles\n    \n    def _phase_radius_expansion(self):\n        \"\"\"Phase 2: Expand radii while maintaining non-overlap\"\"\"\n        max_iterations = 50\n        tolerance = 1e-4\n        \n        for iteration in range(max_iterations):\n            # Try to expand each circle\n            expanded = False\n            \n            for i, circle in enumerate(self.circles):\n                # Find maximum radius without overlapping\n                max_radius = self.target_radius * 3\n                \n                for j, other in enumerate(self.circles):\n                    if i != j:\n                        dist = circle.distance_to(other)\n                        max_r = dist - other.radius - 1e-6\n                        max_radius = min(max_radius, max_r)\n                \n                # Boundary constraint\n                max_radius = min(max_radius,\n                               circle.x - 1e-6,\n                               circle.y - 1e-6,\n                               self.container_size - circle.x - 1e-6,\n                               self.container_size - circle.y - 1e-6)\n                \n                if max_radius > circle.radius + tolerance:\n                    circle.radius = max_radius * 0.95  # 95% to maintain safety margin\n                    expanded = True\n            \n            if not expanded:\n                break\n            \n            if iteration % 10 == 0:\n                cost = self._calculate_packing_cost(self.circles)\n                print(f\"Iteration {iteration}: Cost = {cost:.4f}, \"\n                      f\"Avg radius = {np.mean([c.radius for c in self.circles]):.4f}\")\n        \n        final_cost = self._calculate_packing_cost(self.circles)\n        print(f\"Phase 2 complete. Final cost: {final_cost:.4f}\")\n    \n    def _phase_position_refinement(self):\n        \"\"\"Phase 3: Optimize positions using gradient-based method\"\"\"\n        def objective(x_flat):\n            # Reshape positions\n            positions = x_flat.reshape(-1, 2)\n            for i, circle in enumerate(self.circles):\n                circle.x, circle.y = positions[i]\n            \n            cost = self._calculate_packing_cost(self.circles)\n            return cost\n        \n        # Initial flat array\n        x0 = np.array([[c.x, c.y] for c in self.circles]).flatten()\n        \n        # Optimize with constraints\n        bounds = [(self.target_radius, self.container_size - self.target_radius)\n                 for _ in range(self.num_circles * 2)]\n        \n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 200, 'ftol': 1e-5}\n        )\n        \n        # Apply optimized positions\n        positions = result.x.reshape(-1, 2)\n        for i, circle in enumerate(self.circles):\n            circle.x, circle.y = positions[i]\n        \n        print(f\"Phase 3 complete. Final cost: {result.fun:.4f}\")\n        print(f\"Optimization iterations: {result.nit}\")\n    \n    def _phase_radius_finetuning(self):\n        \"\"\"Phase 4: Fine-tune radii for maximum packing density\"\"\"\n        def objective(radii):\n            for i, circle in enumerate(self.circles):\n                circle.radius = radii[i]\n            \n            # Penalize overlaps heavily\n            cost = 0\n            for i, c1 in enumerate(self.circles):\n                for j, c2 in enumerate(self.circles):\n                    if i < j:\n                        dist = c1.distance_to(c2)\n                        min_dist = c1.radius + c2.radius\n                        if dist < min_dist:\n                            cost += (min_dist - dist) ** 2\n            \n            # Penalize circles outside bounds\n            for circle in self.circles:\n                if circle.x - circle.radius < 0:\n                    cost += (circle.radius - circle.x) ** 2\n                if circle.y - circle.radius < 0:\n                    cost += (circle.radius - circle.y) ** 2\n                if circle.x + circle.radius > self.container_size:\n                    cost += (circle.x + circle.radius - self.container_size) ** 2\n                if circle.y + circle.radius > self.container_size:\n                    cost += (circle.y + circle.radius - self.container_size) ** 2\n            \n            # Maximize coverage (minimize negative total area)\n            total_area = np.sum([np.pi * r**2 for r in radii])\n            cost -= 0.01 * total_area\n            \n            return cost\n        \n        r0 = np.array([c.radius for c in self.circles])\n        \n        # Bounds for radii\n        bounds = [(0.1, self.target_radius * 3) for _ in range(self.num_circles)]\n        \n        result = minimize(\n            objective,\n            r0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 150}\n        )\n        \n        # Apply optimized radii\n        for i, circle in enumerate(self.circles):\n            circle.radius = result.x[i]\n        \n        print(f\"Phase 4 complete. Final cost: {result.fun:.4f}\")\n    \n    def _phase_final_polish(self):\n        \"\"\"Phase 5: Joint optimization of positions and radii\"\"\"\n        def objective(x_flat):\n            # First half: positions, second half: radii\n            positions = x_flat[:self.num_circles * 2].reshape(-1, 2)\n            radii = x_flat[self.num_circles * 2:]\n            \n            for i, circle in enumerate(self.circles):\n                circle.x, circle.y = positions[i]\n                circle.radius = radii[i]\n            \n            cost = self._calculate_packing_cost(self.circles)\n            return cost\n        \n        x0 = np.concatenate([\n            np.array([[c.x, c.y] for c in self.circles]).flatten(),\n            np.array([c.radius for c in self.circles])\n        ])\n        \n        bounds = ([(self.target_radius, self.container_size - self.target_radius)\n                  for _ in range(self.num_circles * 2)] +\n                 [(0.1, self.target_radius * 3) for _ in range(self.num_circles)])\n        \n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 300, 'ftol': 1e-6}\n        )\n        \n        # Apply final optimized values\n        positions = result.x[:self.num_circles * 2].reshape(-1, 2)\n        radii = result.x[self.num_circles * 2:]\n        \n        for i, circle in enumerate(self.circles):\n            circle.x, circle.y = positions[i]\n            circle.radius = radii[i]\n        \n        print(f\"Phase 5 complete. Final cost: {result.fun:.4f}\")\n        print(f\"Total optimization iterations: {result.nit}\")\n    \n    def _calculate_packing_cost(self, circles: List[Circle]) -> float:\n        \"\"\"\n        Calculate packing cost:\n        - Penalize overlaps\n        - Penalize circles outside bounds\n        - Reward large radii\n        \"\"\"\n        cost = 0.0\n        \n        # Penalty for overlaps\n        for i, c1 in enumerate(circles):\n            for j, c2 in enumerate(circles):\n                if i < j:\n                    dist = c1.distance_to(c2)\n                    min_dist = c1.radius + c2.radius\n                    if dist < min_dist:\n                        cost += (min_dist - dist) ** 2 * 100\n        \n        # Penalty for boundary violations\n        for circle in circles:\n            margin = 0.01\n            if circle.x - circle.radius < margin:\n                cost += (margin - (circle.x - circle.radius)) ** 2 * 50\n            if circle.y - circle.radius < margin:\n                cost += (margin - (circle.y - circle.radius)) ** 2 * 50\n            if circle.x + circle.radius > self.container_size - margin:\n                cost += (circle.x + circle.radius - (self.container_size - margin)) ** 2 * 50\n            if circle.y + circle.radius > self.container_size - margin:\n                cost += (circle.y + circle.radius - (self.container_size - margin)) ** 2 * 50\n        \n        # Reward for coverage (negative cost)\n        total_area = sum(np.pi * c.radius ** 2 for c in circles)\n        container_area = self.container_size ** 2\n        coverage = total_area / container_area\n        cost -= coverage * 10\n        \n        return cost\n    \n    def get_packing_metrics(self) -> dict:\n        \"\"\"Calculate packing quality metrics\"\"\"\n        total_area = sum(np.pi * c.radius ** 2 for c in self.circles)\n        container_area = self.container_size ** 2\n        coverage = total_area / container_area\n        \n        # Check overlaps\n        overlaps = 0\n        max_overlap = 0\n        for i, c1 in enumerate(self.circles):\n            for j, c2 in enumerate(self.circles):\n                if i < j:\n                    dist = c1.distance_to(c2)\n                    overlap = c1.radius + c2.radius - dist\n                    if overlap > 0:\n                        overlaps += 1\n                        max_overlap = max(max_overlap, overlap)\n        \n        # Check boundary violations\n        boundary_violations = 0\n        max_violation = 0\n        for circle in self.circles:\n            if circle.x - circle.radius < 0:\n                violation = -(circle.x - circle.radius)\n                boundary_violations += 1\n                max_violation = max(max_violation, violation)\n            if circle.y - circle.radius < 0:\n                violation = -(circle.y - circle.radius)\n                boundary_violations += 1\n                max_violation = max(max_violation, violation)\n            if circle.x + circle.radius > self.container_size:\n                violation = circle.x + circle.radius - self.container_size\n                boundary_violations += 1\n                max_violation = max(max_violation, violation)\n            if circle.y + circle.radius > self.container_size:\n                violation = circle.y + circle.radius - self.container_size\n                boundary_violations += 1\n                max_violation = max(max_violation, violation)\n        \n        return {\n            'total_area': total_area,\n            'container_area': container_area,\n            'coverage': coverage,\n            'average_radius':",
  "reasoning": "# Circle Packing Algorithm with Multi-Phase Optimization\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize\nfrom dataclasses import dataclass\nfrom typing import List, Tuple, Optional\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with position and radius\"\"\"\n    x: float\n    y: float\n    radius: float\n    label: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.radius <= 0:\n            raise ValueError(\"Radius must be positive\")\n    \n    @property\n    def position(self) -> np.ndarray:\n        return np.array([self.x, self.y])\n    \n    def distance_to(self, other: 'Circle') -> float:\n        \"\"\"Calculate distance between circle centers\"\"\"\n        return np.linalg.norm(self.position - other.position)\n    \n    def overlaps_with(self, other: 'Circle') -> bool:\n        \"\"\"Check if circles overlap\"\"\"\n        return self.distance_to(other) < (self.radius + other.radius)\n    \n    def __repr__(self) -> str:\n        return f\"Circle(x={self.x:.2f}, y={self.y:.2f}, r={self.radius:.2f})\"\n\nclass CirclePackingOptimizer:\n    \"\"\"Multi-phase circle packing optimizer\"\"\"\n    \n    def __init__(self, num_circles: int = 26, container_size: float = 100.0,\n                 target_radius: float = 2.0, seed: int = 42):\n        \"\"\"\n        Initialize the optimizer.\n        \n        Args:\n            num_circles: Number of circles to pack\n            container_size: Size of the square container\n            target_radius: Target radius for each circle\n            seed: Random seed for reproducibility\n        \"\"\"\n        self.num_circles = num_circles\n        self.container_size = container_size\n        self.target_radius = target_radius\n        self.seed = seed\n        np.random.seed(seed)\n        \n        self.circles: List[Circle] = []\n        self.optimization_history = []\n        \n    def construct_packing(self) -> List[Circle]:\n        \"\"\"\n        Phase 1: Coarse grid placement\n        Initialize circles on a regular grid with some randomization\n        \"\"\"\n        print(\"=\" * 60)\n        print(\"PHASE 1: COARSE GRID PLACEMENT\")\n        print(\"=\" * 60)\n        \n        circles = []\n        grid_size = int(np.ceil(np.sqrt(self.num_circles)))\n        cell_size = self.container_size / grid_size\n        \n        for i in range(self.num_circles):\n            row = i // grid_size\n            col = i % grid_size\n            \n            # Grid position with random jitter\n            x = col * cell_size + cell_size / 2 + np.random.uniform(-cell_size * 0.2, cell_size * 0.2)\n            y = row * cell_size + cell_size / 2 + np.random.uniform(-cell_size * 0.2, cell_size * 0.2)\n            \n            # Clamp to container\n            x = np.clip(x, self.target_radius, self.container_size - self.target_radius)\n            y = np.clip(y, self.target_radius, self.container_size - self.target_radius)\n            \n            circle = Circle(x, y, self.target_radius, label=chr(65 + i % 26))\n            circles.append(circle)\n        \n        self.circles = circles\n        initial_cost = self._calculate_packing_cost(circles)\n        print(f\"Initial grid placement cost: {initial_cost:.4f}\")\n        print(f\"Placed {len(circles)} circles on {grid_size}x{grid_size} grid\")\n        \n        return circles\n    \n    def run_packing(self) -> List[Circle]:\n        \"\"\"\n        Execute multi-phase optimization:\n        - Phase 1: Coarse grid placement\n        - Phase 2: Radius expansion with position refinement\n        - Phase 3: Fine position optimization\n        - Phase 4: Radius fine-tuning\n        - Phase 5: Final polishing\n        \"\"\"\n        # Phase 1: Initial placement\n        self.construct_packing()\n        \n        # Phase 2: Radius expansion\n        print(\"\\n\" + \"=\" * 60)\n        print(\"PHASE 2: RADIUS EXPANSION WITH POSITION REFINEMENT\")\n        print(\"=\" * 60)\n        self._phase_radius_expansion()\n        \n        # Phase 3: Fine position optimization\n        print(\"\\n\" + \"=\" * 60)\n        print(\"PHASE 3: FINE POSITION OPTIMIZATION\")\n        print(\"=\" * 60)\n        self._phase_position_refinement()\n        \n        # Phase 4: Radius fine-tuning\n        print(\"\\n\" + \"=\" * 60)\n        print(\"PHASE 4: RADIUS FINE-TUNING\")\n        print(\"=\" * 60)\n        self._phase_radius_finetuning()\n        \n        # Phase 5: Final polishing\n        print(\"\\n\" + \"=\" * 60)\n        print(\"PHASE 5: FINAL POLISHING\")\n        print(\"=\" * 60)\n        self._phase_final_polish()\n        \n        return self.circles\n    \n    def _phase_radius_expansion(self):\n        \"\"\"Phase 2: Expand radii while maintaining non-overlap\"\"\"\n        max_iterations = 50\n        tolerance = 1e-4\n        \n        for iteration in range(max_iterations):\n            # Try to expand each circle\n            expanded = False\n            \n            for i, circle in enumerate(self.circles):\n                # Find maximum radius without overlapping\n                max_radius = self.target_radius * 3\n                \n                for j, other in enumerate(self.circles):\n                    if i != j:\n                        dist = circle.distance_to(other)\n                        max_r = dist - other.radius - 1e-6\n                        max_radius = min(max_radius, max_r)\n                \n                # Boundary constraint\n                max_radius = min(max_radius,\n                               circle.x - 1e-6,\n                               circle.y - 1e-6,\n                               self.container_size - circle.x - 1e-6,\n                               self.container_size - circle.y - 1e-6)\n                \n                if max_radius > circle.radius + tolerance:\n                    circle.radius = max_radius * 0.95  # 95% to maintain safety margin\n                    expanded = True\n            \n            if not expanded:\n                break\n            \n            if iteration % 10 == 0:\n                cost = self._calculate_packing_cost(self.circles)\n                print(f\"Iteration {iteration}: Cost = {cost:.4f}, \"\n                      f\"Avg radius = {np.mean([c.radius for c in self.circles]):.4f}\")\n        \n        final_cost = self._calculate_packing_cost(self.circles)\n        print(f\"Phase 2 complete. Final cost: {final_cost:.4f}\")\n    \n    def _phase_position_refinement(self):\n        \"\"\"Phase 3: Optimize positions using gradient-based method\"\"\"\n        def objective(x_flat):\n            # Reshape positions\n            positions = x_flat.reshape(-1, 2)\n            for i, circle in enumerate(self.circles):\n                circle.x, circle.y = positions[i]\n            \n            cost = self._calculate_packing_cost(self.circles)\n            return cost\n        \n        # Initial flat array\n        x0 = np.array([[c.x, c.y] for c in self.circles]).flatten()\n        \n        # Optimize with constraints\n        bounds = [(self.target_radius, self.container_size - self.target_radius)\n                 for _ in range(self.num_circles * 2)]\n        \n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 200, 'ftol': 1e-5}\n        )\n        \n        # Apply optimized positions\n        positions = result.x.reshape(-1, 2)\n        for i, circle in enumerate(self.circles):\n            circle.x, circle.y = positions[i]\n        \n        print(f\"Phase 3 complete. Final cost: {result.fun:.4f}\")\n        print(f\"Optimization iterations: {result.nit}\")\n    \n    def _phase_radius_finetuning(self):\n        \"\"\"Phase 4: Fine-tune radii for maximum packing density\"\"\"\n        def objective(radii):\n            for i, circle in enumerate(self.circles):\n                circle.radius = radii[i]\n            \n            # Penalize overlaps heavily\n            cost = 0\n            for i, c1 in enumerate(self.circles):\n                for j, c2 in enumerate(self.circles):\n                    if i < j:\n                        dist = c1.distance_to(c2)\n                        min_dist = c1.radius + c2.radius\n                        if dist < min_dist:\n                            cost += (min_dist - dist) ** 2\n            \n            # Penalize circles outside bounds\n            for circle in self.circles:\n                if circle.x - circle.radius < 0:\n                    cost += (circle.radius - circle.x) ** 2\n                if circle.y - circle.radius < 0:\n                    cost += (circle.radius - circle.y) ** 2\n                if circle.x + circle.radius > self.container_size:\n                    cost += (circle.x + circle.radius - self.container_size) ** 2\n                if circle.y + circle.radius > self.container_size:\n                    cost += (circle.y + circle.radius - self.container_size) ** 2\n            \n            # Maximize coverage (minimize negative total area)\n            total_area = np.sum([np.pi * r**2 for r in radii])\n            cost -= 0.01 * total_area\n            \n            return cost\n        \n        r0 = np.array([c.radius for c in self.circles])\n        \n        # Bounds for radii\n        bounds = [(0.1, self.target_radius * 3) for _ in range(self.num_circles)]\n        \n        result = minimize(\n            objective,\n            r0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 150}\n        )\n        \n        # Apply optimized radii\n        for i, circle in enumerate(self.circles):\n            circle.radius = result.x[i]\n        \n        print(f\"Phase 4 complete. Final cost: {result.fun:.4f}\")\n    \n    def _phase_final_polish(self):\n        \"\"\"Phase 5: Joint optimization of positions and radii\"\"\"\n        def objective(x_flat):\n            # First half: positions, second half: radii\n            positions = x_flat[:self.num_circles * 2].reshape(-1, 2)\n            radii = x_flat[self.num_circles * 2:]\n            \n            for i, circle in enumerate(self.circles):\n                circle.x, circle.y = positions[i]\n                circle.radius = radii[i]\n            \n            cost = self._calculate_packing_cost(self.circles)\n            return cost\n        \n        x0 = np.concatenate([\n            np.array([[c.x, c.y] for c in self.circles]).flatten(),\n            np.array([c.radius for c in self.circles])\n        ])\n        \n        bounds = ([(self.target_radius, self.container_size - self.target_radius)\n                  for _ in range(self.num_circles * 2)] +\n                 [(0.1, self.target_radius * 3) for _ in range(self.num_circles)])\n        \n        result = minimize(\n            objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 300, 'ftol': 1e-6}\n        )\n        \n        # Apply final optimized values\n        positions = result.x[:self.num_circles * 2].reshape(-1, 2)\n        radii = result.x[self.num_circles * 2:]\n        \n        for i, circle in enumerate(self.circles):\n            circle.x, circle.y = positions[i]\n            circle.radius = radii[i]\n        \n        print(f\"Phase 5 complete. Final cost: {result.fun:.4f}\")\n        print(f\"Total optimization iterations: {result.nit}\")\n    \n    def _calculate_packing_cost(self, circles: List[Circle]) -> float:\n        \"\"\"\n        Calculate packing cost:\n        - Penalize overlaps\n        - Penalize circles outside bounds\n        - Reward large radii\n        \"\"\"\n        cost = 0.0\n        \n        # Penalty for overlaps\n        for i, c1 in enumerate(circles):\n            for j, c2 in enumerate(circles):\n                if i < j:\n                    dist = c1.distance_to(c2)\n                    min_dist = c1.radius + c2.radius\n                    if dist < min_dist:\n                        cost += (min_dist - dist) ** 2 * 100\n        \n        # Penalty for boundary violations\n        for circle in circles:\n            margin = 0.01\n            if circle.x - circle.radius < margin:\n                cost += (margin - (circle.x - circle.radius)) ** 2 * 50\n            if circle.y - circle.radius < margin:\n                cost += (margin - (circle.y - circle.radius)) ** 2 * 50\n            if circle.x + circle.radius > self.container_size - margin:\n                cost += (circle.x + circle.radius - (self.container_size - margin)) ** 2 * 50\n            if circle.y + circle.radius > self.container_size - margin:\n                cost += (circle.y + circle.radius - (self.container_size - margin)) ** 2 * 50\n        \n        # Reward for coverage (negative cost)\n        total_area = sum(np.pi * c.radius ** 2 for c in circles)\n        container_area = self.container_size ** 2\n        coverage = total_area / container_area\n        cost -= coverage * 10\n        \n        return cost\n    \n    def get_packing_metrics(self) -> dict:\n        \"\"\"Calculate packing quality metrics\"\"\"\n        total_area = sum(np.pi * c.radius ** 2 for c in self.circles)\n        container_area = self.container_size ** 2\n        coverage = total_area / container_area\n        \n        # Check overlaps\n        overlaps = 0\n        max_overlap = 0\n        for i, c1 in enumerate(self.circles):\n            for j, c2 in enumerate(self.circles):\n                if i < j:\n                    dist = c1.distance_to(c2)\n                    overlap = c1.radius + c2.radius - dist\n                    if overlap > 0:\n                        overlaps += 1\n                        max_overlap = max(max_overlap, overlap)\n        \n        # Check boundary violations\n        boundary_violations = 0\n        max_violation = 0\n        for circle in self.circles:\n            if circle.x - circle.radius < 0:\n                violation = -(circle.x - circle.radius)\n                boundary_violations += 1\n                max_violation = max(max_violation, violation)\n            if circle.y - circle.radius < 0:\n                violation = -(circle.y - circle.radius)\n                boundary_violations += 1\n                max_violation = max(max_violation, violation)\n            if circle.x + circle.radius > self.container_size:\n                violation = circle.x + circle.radius - self.container_size\n                boundary_violations += 1\n                max_violation = max(max_violation, violation)\n            if circle.y + circle.radius > self.container_size:\n                violation = circle.y + circle.radius - self.container_size\n                boundary_violations += 1\n                max_violation = max(max_violation, violation)\n        \n        return {\n            'total_area': total_area,\n            'container_area': container_area,\n            'coverage': coverage,\n            'average_radius':",
  "timestamp": "2025-12-08T12:15:34.544889",
  "cost_data": null
}