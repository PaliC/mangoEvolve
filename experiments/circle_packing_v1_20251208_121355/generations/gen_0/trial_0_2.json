{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "\"\"\"\nCircle Packing Algorithm for 26 Circles in a Unit Square\nUses scipy.optimize to maximize the sum of radii while maintaining non-overlap constraints.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle as CirclePatch\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\n\ndef construct_packing(n_circles=26):\n    \"\"\"\n    Construct initial packing configuration with circle centers and radii.\n    \n    Parameters:\n    -----------\n    n_circles : int\n        Number of circles to pack (default: 26)\n    \n    Returns:\n    --------\n    x0 : ndarray\n        Initial configuration vector [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n    \"\"\"\n    # Initialize with grid-based placement for better starting point\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    spacing = 1.0 / (grid_size + 1)\n    \n    x0 = []\n    circle_idx = 0\n    \n    for i in range(grid_size):\n        for j in range(grid_size):\n            if circle_idx >= n_circles:\n                break\n            \n            x = (i + 1) * spacing\n            y = (j + 1) * spacing\n            r = spacing * 0.3  # Initial radius\n            \n            x0.extend([x, y, r])\n            circle_idx += 1\n        \n        if circle_idx >= n_circles:\n            break\n    \n    return np.array(x0)\n\n\ndef extract_circles(x, n_circles):\n    \"\"\"\n    Extract circle centers and radii from configuration vector.\n    \n    Parameters:\n    -----------\n    x : ndarray\n        Configuration vector [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n    n_circles : int\n        Number of circles\n    \n    Returns:\n    --------\n    centers : ndarray\n        Circle centers, shape (n_circles, 2)\n    radii : ndarray\n        Circle radii, shape (n_circles,)\n    \"\"\"\n    centers = []\n    radii = []\n    \n    for i in range(n_circles):\n        idx = i * 3\n        centers.append([x[idx], x[idx + 1]])\n        radii.append(x[idx + 2])\n    \n    return np.array(centers), np.array(radii)\n\n\ndef objective(x, n_circles):\n    \"\"\"\n    Objective function: maximize sum of radii (minimize negative sum).\n    \n    Parameters:\n    -----------\n    x : ndarray\n        Configuration vector\n    n_circles : int\n        Number of circles\n    \n    Returns:\n    --------\n    float\n        Negative sum of radii (for minimization)\n    \"\"\"\n    _, radii = extract_circles(x, n_circles)\n    return -np.sum(radii)  # Negative because we minimize\n\n\ndef boundary_constraints(x, n_circles):\n    \"\"\"\n    Constraint: circles must be within unit square [0, 1] x [0, 1].\n    \n    Parameters:\n    -----------\n    x : ndarray\n        Configuration vector\n    n_circles : int\n        Number of circles\n    \n    Returns:\n    --------\n    constraints : ndarray\n        Array of constraint values (should be >= 0)\n    \"\"\"\n    centers, radii = extract_circles(x, n_circles)\n    \n    constraints = []\n    \n    for i in range(n_circles):\n        # x - r >= 0\n        constraints.append(centers[i, 0] - radii[i])\n        # y - r >= 0\n        constraints.append(centers[i, 1] - radii[i])\n        # 1 - (x + r) >= 0\n        constraints.append(1.0 - (centers[i, 0] + radii[i]))\n        # 1 - (y + r) >= 0\n        constraints.append(1.0 - (centers[i, 1] + radii[i]))\n    \n    return np.array(constraints)\n\n\ndef non_overlap_constraints(x, n_circles):\n    \"\"\"\n    Constraint: circles must not overlap.\n    Distance between centers >= sum of radii.\n    \n    Parameters:\n    -----------\n    x : ndarray\n        Configuration vector\n    n_circles : int\n        Number of circles\n    \n    Returns:\n    --------\n    constraints : ndarray\n        Array of constraint values (should be >= 0)\n    \"\"\"\n    centers, radii = extract_circles(x, n_circles)\n    \n    constraints = []\n    \n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            # Distance between centers\n            dist = np.linalg.norm(centers[i] - centers[j])\n            # Constraint: dist - (r_i + r_j) >= 0\n            constraints.append(dist - (radii[i] + radii[j]))\n    \n    return np.array(constraints)\n\n\ndef radius_constraints(x, n_circles):\n    \"\"\"\n    Constraint: all radii must be positive.\n    \n    Parameters:\n    -----------\n    x : ndarray\n        Configuration vector\n    n_circles : int\n        Number of circles\n    \n    Returns:\n    --------\n    constraints : ndarray\n        Array of constraint values (should be >= 0)\n    \"\"\"\n    _, radii = extract_circles(x, n_circles)\n    return radii.copy()\n\n\ndef run_packing(n_circles=26, max_iterations=1000, verbose=True):\n    \"\"\"\n    Run the circle packing optimization algorithm.\n    \n    Parameters:\n    -----------\n    n_circles : int\n        Number of circles to pack (default: 26)\n    max_iterations : int\n        Maximum number of optimization iterations\n    verbose : bool\n        Print optimization progress\n    \n    Returns:\n    --------\n    result : scipy.optimize.OptimizeResult\n        Optimization result object\n    centers : ndarray\n        Optimized circle centers\n    radii : ndarray\n        Optimized circle radii\n    \"\"\"\n    \n    if verbose:\n        print(f\"Starting circle packing optimization for {n_circles} circles...\")\n        print(f\"Maximum iterations: {max_iterations}\\n\")\n    \n    # Construct initial solution\n    x0 = construct_packing(n_circles)\n    \n    # Define constraints\n    constraints = [\n        NonlinearConstraint(\n            lambda x: boundary_constraints(x, n_circles),\n            0, np.inf,\n            jac='2-point'\n        ),\n        NonlinearConstraint(\n            lambda x: non_overlap_constraints(x, n_circles),\n            0, np.inf,\n            jac='2-point'\n        ),\n        NonlinearConstraint(\n            lambda x: radius_constraints(x, n_circles),\n            0, np.inf,\n            jac='2-point'\n        )\n    ]\n    \n    # Define bounds: centers in [0, 1], radii in (0, 0.5]\n    bounds = []\n    for i in range(n_circles):\n        bounds.append((0.0, 1.0))      # x coordinate\n        bounds.append((0.0, 1.0))      # y coordinate\n        bounds.append((1e-6, 0.5))     # radius\n    \n    # Callback for progress tracking\n    iteration_count = [0]\n    \n    def callback(xk):\n        iteration_count[0] += 1\n        if verbose and iteration_count[0] % 50 == 0:\n            _, radii = extract_circles(xk, n_circles)\n            total_area = np.sum(np.pi * radii**2)\n            print(f\"Iteration {iteration_count[0]}: Total area = {total_area:.6f}, \"\n                  f\"Sum of radii = {np.sum(radii):.6f}\")\n    \n    # Run optimization\n    result = minimize(\n        fun=objective,\n        x0=x0,\n        args=(n_circles,),\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={\n            'maxiter': max_iterations,\n            'ftol': 1e-9,\n            'disp': verbose\n        },\n        callback=callback\n    )\n    \n    # Extract final solution\n    centers, radii = extract_circles(result.x, n_circles)\n    \n    if verbose:\n        print(f\"\\n{'='*60}\")\n        print(f\"Optimization completed!\")\n        print(f\"Success: {result.success}\")\n        print(f\"Message: {result.message}\")\n        print(f\"Iterations: {result.nit}\")\n        print(f\"Function evaluations: {result.nfev}\")\n        print(f\"\\nResults:\")\n        print(f\"  Sum of radii: {np.sum(radii):.6f}\")\n        print(f\"  Total area: {np.sum(np.pi * radii**2):.6f}\")\n        print(f\"  Average radius: {np.mean(radii):.6f}\")\n        print(f\"  Min radius: {np.min(radii):.6f}\")\n        print(f\"  Max radius: {np.max(radii):.6f}\")\n        print(f\"{'='*60}\\n\")\n    \n    return result, centers, radii\n\n\ndef visualize_packing(centers, radii, title=\"Circle Packing Optimization\"):\n    \"\"\"\n    Visualize the circle packing solution.\n    \n    Parameters:\n    -----------\n    centers : ndarray\n        Circle centers, shape (n_circles, 2)\n    radii : ndarray\n        Circle radii, shape (n_circles,)\n    title : str\n        Plot title\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(10, 10))\n    \n    # Draw unit square\n    ax.add_patch(plt.Rectangle((0, 0), 1, 1, fill=False, \n                               edgecolor='black', linewidth=2))\n    \n    # Draw circles\n    n_circles = len(centers)\n    colors = plt.cm.hsv(np.linspace(0, 1, n_circles))\n    \n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = CirclePatch(\n            center, radius,\n            color=colors[i],\n            alpha=0.6,\n            edgecolor='black',\n            linewidth=1.5\n        )\n        ax.add_patch(circle)\n        \n        # Add circle number\n        ax.text(center[0], center[1], str(i+1),\n               ha='center', va='center',\n               fontsize=8, fontweight='bold')\n    \n    ax.set_xlim(-0.05, 1.05)\n    ax.set_ylim(-0.05, 1.05)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_xlabel('X', fontsize=12)\n    ax.set_ylabel('Y', fontsize=12)\n    ax.set_title(title, fontsize=14, fontweight='bold')\n    \n    plt.tight_layout()\n    return fig, ax\n\n\ndef check_solution_validity(centers, radii, tolerance=1e-6):\n    \"\"\"\n    Verify that the solution satisfies all constraints.\n    \n    Parameters:\n    -----------\n    centers : ndarray\n        Circle centers\n    radii : ndarray\n        Circle radii\n    tolerance : float\n        Tolerance for constraint violations\n    \n    Returns:\n    --------\n    is_valid : bool\n        Whether solution is valid\n    violations : dict\n        Dictionary of constraint violations\n    \"\"\"\n    violations = {\n        'boundary': [],\n        'overlap': [],\n        'negative_radius': []\n    }\n    \n    n_circles = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n_circles):\n        if centers[i, 0] - radii[i] < -tolerance:\n            violations['boundary'].append(f\"Circle {i}: left boundary violated\")\n        if centers[i, 1] - radii[i] < -tolerance:\n            violations['boundary'].append(f\"Circle {i}: bottom boundary violated\")\n        if centers[i, 0] + radii[i] > 1 + tolerance:\n            violations['boundary'].append(f\"Circle {i}: right boundary violated\")\n        if centers[i, 1] + radii[i] > 1 + tolerance:\n            violations['boundary'].append(f\"Circle {i}: top boundary violated\")\n    \n    # Check non-overlap constraints\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist - tolerance:\n                violations['overlap'].append(\n                    f\"Circles {i} and {j} overlap: \"\n                    f\"distance={dist:.6f}, min_distance={min_dist:.6f}\"\n                )\n    \n    # Check radius constraints\n    for i in range(n_circles):\n        if radii[i] < -tolerance:\n            violations['negative_radius'].append(f\"Circle {i}: negative radius\")\n    \n    is_valid = all(len(v) == 0 for v in violations.values())\n    \n    return is_valid, violations\n\n\nif __name__ == \"__main__\":\n    # Run the packing algorithm\n    result, centers, radii = run_packing(n_circles=26, max_iterations=2000, verbose=True)\n    \n    # Check solution validity\n    is_valid, violations = check_solution_validity(centers, radii)\n    \n    print(\"\\nSolution Validity Check:\")\n    print(f\"Valid: {is_valid}\")\n    if not is_valid:\n        print(\"Violations:\")\n        for violation_type, issues in violations.items():\n            if issues:\n                print(f\"  {violation_type}:\")\n                for issue in issues:\n                    print(f\"    - {issue}\")\n    else:\n        print(\"All constraints satisfied!\")\n    \n    # Visualize the solution\n    fig, ax = visualize_packing(\n        centers, radii,\n        title=f\"Circle Packing: 26 Circles (Sum of Radii = {np.sum(radii):.4f})\"\n    )\n    plt.show()\n    \n    # Print detailed statistics\n    print(\"\\n\" + \"=\"*60)\n    print(\"Circle Statistics:\")\n    print(\"=\"*60)\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        print(f\"Circle {i+1:2d}: center=({center[0]:.4f}, {center[1]:.4f}), \"\n              f\"radius={radius:.6f}, area={np.pi*radius**2:.6f}\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.7776260375976562,
    "error": "TypeError: only length-1 arrays can be converted to Python scalars"
  },
  "prompt": "Write a circle packing algorithm for 26 circles using scipy.optimize. Place 26 circle centers in a unit square and optimize their positions and radii to maximize the sum of radii while satisfying non-overlap constraints. Use scipy.optimize.minimize with constraints. Include construct_packing() and run_packing() functions.",
  "response": "```python\n\"\"\"\nCircle Packing Algorithm for 26 Circles in a Unit Square\nUses scipy.optimize to maximize the sum of radii while maintaining non-overlap constraints.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle as CirclePatch\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\n\ndef construct_packing(n_circles=26):\n    \"\"\"\n    Construct initial packing configuration with circle centers and radii.\n    \n    Parameters:\n    -----------\n    n_circles : int\n        Number of circles to pack (default: 26)\n    \n    Returns:\n    --------\n    x0 : ndarray\n        Initial configuration vector [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n    \"\"\"\n    # Initialize with grid-based placement for better starting point\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    spacing = 1.0 / (grid_size + 1)\n    \n    x0 = []\n    circle_idx = 0\n    \n    for i in range(grid_size):\n        for j in range(grid_size):\n            if circle_idx >= n_circles:\n                break\n            \n            x = (i + 1) * spacing\n            y = (j + 1) * spacing\n            r = spacing * 0.3  # Initial radius\n            \n            x0.extend([x, y, r])\n            circle_idx += 1\n        \n        if circle_idx >= n_circles:\n            break\n    \n    return np.array(x0)\n\n\ndef extract_circles(x, n_circles):\n    \"\"\"\n    Extract circle centers and radii from configuration vector.\n    \n    Parameters:\n    -----------\n    x : ndarray\n        Configuration vector [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n    n_circles : int\n        Number of circles\n    \n    Returns:\n    --------\n    centers : ndarray\n        Circle centers, shape (n_circles, 2)\n    radii : ndarray\n        Circle radii, shape (n_circles,)\n    \"\"\"\n    centers = []\n    radii = []\n    \n    for i in range(n_circles):\n        idx = i * 3\n        centers.append([x[idx], x[idx + 1]])\n        radii.append(x[idx + 2])\n    \n    return np.array(centers), np.array(radii)\n\n\ndef objective(x, n_circles):\n    \"\"\"\n    Objective function: maximize sum of radii (minimize negative sum).\n    \n    Parameters:\n    -----------\n    x : ndarray\n        Configuration vector\n    n_circles : int\n        Number of circles\n    \n    Returns:\n    --------\n    float\n        Negative sum of radii (for minimization)\n    \"\"\"\n    _, radii = extract_circles(x, n_circles)\n    return -np.sum(radii)  # Negative because we minimize\n\n\ndef boundary_constraints(x, n_circles):\n    \"\"\"\n    Constraint: circles must be within unit square [0, 1] x [0, 1].\n    \n    Parameters:\n    -----------\n    x : ndarray\n        Configuration vector\n    n_circles : int\n        Number of circles\n    \n    Returns:\n    --------\n    constraints : ndarray\n        Array of constraint values (should be >= 0)\n    \"\"\"\n    centers, radii = extract_circles(x, n_circles)\n    \n    constraints = []\n    \n    for i in range(n_circles):\n        # x - r >= 0\n        constraints.append(centers[i, 0] - radii[i])\n        # y - r >= 0\n        constraints.append(centers[i, 1] - radii[i])\n        # 1 - (x + r) >= 0\n        constraints.append(1.0 - (centers[i, 0] + radii[i]))\n        # 1 - (y + r) >= 0\n        constraints.append(1.0 - (centers[i, 1] + radii[i]))\n    \n    return np.array(constraints)\n\n\ndef non_overlap_constraints(x, n_circles):\n    \"\"\"\n    Constraint: circles must not overlap.\n    Distance between centers >= sum of radii.\n    \n    Parameters:\n    -----------\n    x : ndarray\n        Configuration vector\n    n_circles : int\n        Number of circles\n    \n    Returns:\n    --------\n    constraints : ndarray\n        Array of constraint values (should be >= 0)\n    \"\"\"\n    centers, radii = extract_circles(x, n_circles)\n    \n    constraints = []\n    \n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            # Distance between centers\n            dist = np.linalg.norm(centers[i] - centers[j])\n            # Constraint: dist - (r_i + r_j) >= 0\n            constraints.append(dist - (radii[i] + radii[j]))\n    \n    return np.array(constraints)\n\n\ndef radius_constraints(x, n_circles):\n    \"\"\"\n    Constraint: all radii must be positive.\n    \n    Parameters:\n    -----------\n    x : ndarray\n        Configuration vector\n    n_circles : int\n        Number of circles\n    \n    Returns:\n    --------\n    constraints : ndarray\n        Array of constraint values (should be >= 0)\n    \"\"\"\n    _, radii = extract_circles(x, n_circles)\n    return radii.copy()\n\n\ndef run_packing(n_circles=26, max_iterations=1000, verbose=True):\n    \"\"\"\n    Run the circle packing optimization algorithm.\n    \n    Parameters:\n    -----------\n    n_circles : int\n        Number of circles to pack (default: 26)\n    max_iterations : int\n        Maximum number of optimization iterations\n    verbose : bool\n        Print optimization progress\n    \n    Returns:\n    --------\n    result : scipy.optimize.OptimizeResult\n        Optimization result object\n    centers : ndarray\n        Optimized circle centers\n    radii : ndarray\n        Optimized circle radii\n    \"\"\"\n    \n    if verbose:\n        print(f\"Starting circle packing optimization for {n_circles} circles...\")\n        print(f\"Maximum iterations: {max_iterations}\\n\")\n    \n    # Construct initial solution\n    x0 = construct_packing(n_circles)\n    \n    # Define constraints\n    constraints = [\n        NonlinearConstraint(\n            lambda x: boundary_constraints(x, n_circles),\n            0, np.inf,\n            jac='2-point'\n        ),\n        NonlinearConstraint(\n            lambda x: non_overlap_constraints(x, n_circles),\n            0, np.inf,\n            jac='2-point'\n        ),\n        NonlinearConstraint(\n            lambda x: radius_constraints(x, n_circles),\n            0, np.inf,\n            jac='2-point'\n        )\n    ]\n    \n    # Define bounds: centers in [0, 1], radii in (0, 0.5]\n    bounds = []\n    for i in range(n_circles):\n        bounds.append((0.0, 1.0))      # x coordinate\n        bounds.append((0.0, 1.0))      # y coordinate\n        bounds.append((1e-6, 0.5))     # radius\n    \n    # Callback for progress tracking\n    iteration_count = [0]\n    \n    def callback(xk):\n        iteration_count[0] += 1\n        if verbose and iteration_count[0] % 50 == 0:\n            _, radii = extract_circles(xk, n_circles)\n            total_area = np.sum(np.pi * radii**2)\n            print(f\"Iteration {iteration_count[0]}: Total area = {total_area:.6f}, \"\n                  f\"Sum of radii = {np.sum(radii):.6f}\")\n    \n    # Run optimization\n    result = minimize(\n        fun=objective,\n        x0=x0,\n        args=(n_circles,),\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints,\n        options={\n            'maxiter': max_iterations,\n            'ftol': 1e-9,\n            'disp': verbose\n        },\n        callback=callback\n    )\n    \n    # Extract final solution\n    centers, radii = extract_circles(result.x, n_circles)\n    \n    if verbose:\n        print(f\"\\n{'='*60}\")\n        print(f\"Optimization completed!\")\n        print(f\"Success: {result.success}\")\n        print(f\"Message: {result.message}\")\n        print(f\"Iterations: {result.nit}\")\n        print(f\"Function evaluations: {result.nfev}\")\n        print(f\"\\nResults:\")\n        print(f\"  Sum of radii: {np.sum(radii):.6f}\")\n        print(f\"  Total area: {np.sum(np.pi * radii**2):.6f}\")\n        print(f\"  Average radius: {np.mean(radii):.6f}\")\n        print(f\"  Min radius: {np.min(radii):.6f}\")\n        print(f\"  Max radius: {np.max(radii):.6f}\")\n        print(f\"{'='*60}\\n\")\n    \n    return result, centers, radii\n\n\ndef visualize_packing(centers, radii, title=\"Circle Packing Optimization\"):\n    \"\"\"\n    Visualize the circle packing solution.\n    \n    Parameters:\n    -----------\n    centers : ndarray\n        Circle centers, shape (n_circles, 2)\n    radii : ndarray\n        Circle radii, shape (n_circles,)\n    title : str\n        Plot title\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(10, 10))\n    \n    # Draw unit square\n    ax.add_patch(plt.Rectangle((0, 0), 1, 1, fill=False, \n                               edgecolor='black', linewidth=2))\n    \n    # Draw circles\n    n_circles = len(centers)\n    colors = plt.cm.hsv(np.linspace(0, 1, n_circles))\n    \n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = CirclePatch(\n            center, radius,\n            color=colors[i],\n            alpha=0.6,\n            edgecolor='black',\n            linewidth=1.5\n        )\n        ax.add_patch(circle)\n        \n        # Add circle number\n        ax.text(center[0], center[1], str(i+1),\n               ha='center', va='center',\n               fontsize=8, fontweight='bold')\n    \n    ax.set_xlim(-0.05, 1.05)\n    ax.set_ylim(-0.05, 1.05)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_xlabel('X', fontsize=12)\n    ax.set_ylabel('Y', fontsize=12)\n    ax.set_title(title, fontsize=14, fontweight='bold')\n    \n    plt.tight_layout()\n    return fig, ax\n\n\ndef check_solution_validity(centers, radii, tolerance=1e-6):\n    \"\"\"\n    Verify that the solution satisfies all constraints.\n    \n    Parameters:\n    -----------\n    centers : ndarray\n        Circle centers\n    radii : ndarray\n        Circle radii\n    tolerance : float\n        Tolerance for constraint violations\n    \n    Returns:\n    --------\n    is_valid : bool\n        Whether solution is valid\n    violations : dict\n        Dictionary of constraint violations\n    \"\"\"\n    violations = {\n        'boundary': [],\n        'overlap': [],\n        'negative_radius': []\n    }\n    \n    n_circles = len(centers)\n    \n    # Check boundary constraints\n    for i in range(n_circles):\n        if centers[i, 0] - radii[i] < -tolerance:\n            violations['boundary'].append(f\"Circle {i}: left boundary violated\")\n        if centers[i, 1] - radii[i] < -tolerance:\n            violations['boundary'].append(f\"Circle {i}: bottom boundary violated\")\n        if centers[i, 0] + radii[i] > 1 + tolerance:\n            violations['boundary'].append(f\"Circle {i}: right boundary violated\")\n        if centers[i, 1] + radii[i] > 1 + tolerance:\n            violations['boundary'].append(f\"Circle {i}: top boundary violated\")\n    \n    # Check non-overlap constraints\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if dist < min_dist - tolerance:\n                violations['overlap'].append(\n                    f\"Circles {i} and {j} overlap: \"\n                    f\"distance={dist:.6f}, min_distance={min_dist:.6f}\"\n                )\n    \n    # Check radius constraints\n    for i in range(n_circles):\n        if radii[i] < -tolerance:\n            violations['negative_radius'].append(f\"Circle {i}: negative radius\")\n    \n    is_valid = all(len(v) == 0 for v in violations.values())\n    \n    return is_valid, violations\n\n\nif __name__ == \"__main__\":\n    # Run the packing algorithm\n    result, centers, radii = run_packing(n_circles=26, max_iterations=2000, verbose=True)\n    \n    # Check solution validity\n    is_valid, violations = check_solution_validity(centers, radii)\n    \n    print(\"\\nSolution Validity Check:\")\n    print(f\"Valid: {is_valid}\")\n    if not is_valid:\n        print(\"Violations:\")\n        for violation_type, issues in violations.items():\n            if issues:\n                print(f\"  {violation_type}:\")\n                for issue in issues:\n                    print(f\"    - {issue}\")\n    else:\n        print(\"All constraints satisfied!\")\n    \n    # Visualize the solution\n    fig, ax = visualize_packing(\n        centers, radii,\n        title=f\"Circle Packing: 26 Circles (Sum of Radii = {np.sum(radii):.4f})\"\n    )\n    plt.show()\n    \n    # Print detailed statistics\n    print(\"\\n\" + \"=\"*60)\n    print(\"Circle Statistics:\")\n    print(\"=\"*60)\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        print(f\"Circle {i+1:2d}: center=({center[0]:.4f}, {center[1]:.4f}), \"\n              f\"radius={radius:.6f}, area={np.pi*radius**2:.6f}\")\n```\n\nThis comprehensive circle packing implementation includes:\n\n## Key Features:\n\n1. **`construct_packing()`**: Creates initial grid-based configuration for better convergence\n\n2. **`run_packing()`**: Main optimization function using `scipy.optimize.minimize` with:\n   - SLSQP method (handles nonlinear constraints)\n   - NonlinearConstraint for boundary, non-overlap, and radius constraints\n   - Progress tracking and detailed output\n\n3. **Constraint Functions**:\n   - `boundary_constraints()`: Keeps circles inside unit square\n   - `non_overlap_constraints()`: Prevents circle overlap\n   - `radius_constraints()`: Ensures positive radii\n\n4. **Utilities**:\n   - `extract_circles()`: Parses solution vector\n   - `visualize_packing()`: Plots the solution with colors and labels\n   - `check_solution_validity()`: Verifies constraint satisfaction\n\n5. **Output**: Detailed statistics, validation checks, and visualization\n\nThe algorithm typically achieves good packing efficiency with 26 circles in the unit square!",
  "reasoning": "This comprehensive circle packing implementation includes:\n\n## Key Features:\n\n1. **`construct_packing()`**: Creates initial grid-based configuration for better convergence\n\n2. **`run_packing()`**: Main optimization function using `scipy.optimize.minimize` with:\n   - SLSQP method (handles nonlinear constraints)\n   - NonlinearConstraint for boundary, non-overlap, and radius constraints\n   - Progress tracking and detailed output\n\n3. **Constraint Functions**:\n   - `boundary_constraints()`: Keeps circles inside unit square\n   - `non_overlap_constraints()`: Prevents circle overlap\n   - `radius_constraints()`: Ensures positive radii\n\n4. **Utilities**:\n   - `extract_circles()`: Parses solution vector\n   - `visualize_packing()`: Plots the solution with colors and labels\n   - `check_solution_validity()`: Verifies constraint satisfaction\n\n5. **Output**: Detailed statistics, validation checks, and visualization\n\nThe algorithm typically achieves good packing efficiency with 26 circles in the unit square!",
  "timestamp": "2025-12-08T12:15:14.824355",
  "cost_data": null
}