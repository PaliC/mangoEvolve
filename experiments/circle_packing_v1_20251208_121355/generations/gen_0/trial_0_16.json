{
  "trial_id": "trial_0_16",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a circle packing algorithm for 26 circles using a constraint satisfaction approach. Define constraints for non-overlap and boundaries, use backtracking with constraint propagation to find valid packings, then optimize radii. Include construct_packing() and run_packing() functions.",
  "response": "# Circle Packing Algorithm with Constraint Satisfaction\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom dataclasses import dataclass\nfrom typing import List, Tuple, Optional\nimport heapq\nfrom scipy.optimize import minimize\nimport copy\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with position and radius\"\"\"\n    id: int\n    x: float\n    y: float\n    radius: float\n    \n    def __repr__(self):\n        return f\"Circle({self.id}, x={self.x:.2f}, y={self.y:.2f}, r={self.radius:.2f})\"\n\nclass CirclePackingCSP:\n    \"\"\"Constraint Satisfaction Problem solver for circle packing\"\"\"\n    \n    def __init__(self, num_circles: int = 26, width: float = 100.0, height: float = 100.0):\n        \"\"\"\n        Initialize the circle packing CSP\n        \n        Args:\n            num_circles: Number of circles to pack\n            width: Container width\n            height: Container height\n        \"\"\"\n        self.num_circles = num_circles\n        self.width = width\n        self.height = height\n        self.circles: List[Circle] = []\n        self.min_radius = 1.0\n        self.max_radius = 5.0\n        \n    def add_circle(self, circle_id: int, x: float, y: float, radius: float) -> None:\n        \"\"\"Add a circle to the packing\"\"\"\n        self.circles.append(Circle(circle_id, x, y, radius))\n    \n    def check_overlap(self, c1: Circle, c2: Circle) -> bool:\n        \"\"\"\n        Check if two circles overlap\n        \n        Returns:\n            True if circles overlap, False otherwise\n        \"\"\"\n        distance = np.sqrt((c1.x - c2.x)**2 + (c1.y - c2.y)**2)\n        min_distance = c1.radius + c2.radius\n        return distance < min_distance - 1e-6\n    \n    def check_boundary(self, circle: Circle) -> bool:\n        \"\"\"\n        Check if circle violates boundary constraints\n        \n        Returns:\n            True if circle is within bounds, False otherwise\n        \"\"\"\n        return (circle.x - circle.radius >= 0 and\n                circle.x + circle.radius <= self.width and\n                circle.y - circle.radius >= 0 and\n                circle.y + circle.radius <= self.height)\n    \n    def get_overlap_distance(self, c1: Circle, c2: Circle) -> float:\n        \"\"\"Calculate how much two circles overlap (positive if overlapping)\"\"\"\n        distance = np.sqrt((c1.x - c2.x)**2 + (c1.y - c2.y)**2)\n        min_distance = c1.radius + c2.radius\n        return max(0, min_distance - distance)\n    \n    def get_boundary_violation(self, circle: Circle) -> float:\n        \"\"\"Calculate boundary violation amount\"\"\"\n        violation = 0\n        if circle.x - circle.radius < 0:\n            violation += abs(circle.x - circle.radius)\n        if circle.x + circle.radius > self.width:\n            violation += circle.x + circle.radius - self.width\n        if circle.y - circle.radius < 0:\n            violation += abs(circle.y - circle.radius)\n        if circle.y + circle.radius > self.height:\n            violation += circle.y + circle.radius - self.height\n        return violation\n    \n    def is_valid_placement(self, circle: Circle, placed_circles: List[Circle]) -> bool:\n        \"\"\"\n        Check if a circle placement is valid\n        \n        Args:\n            circle: Circle to place\n            placed_circles: List of already placed circles\n            \n        Returns:\n            True if placement is valid, False otherwise\n        \"\"\"\n        # Check boundary constraint\n        if not self.check_boundary(circle):\n            return False\n        \n        # Check non-overlap constraint with all placed circles\n        for placed in placed_circles:\n            if self.check_overlap(circle, placed):\n                return False\n        \n        return True\n    \n    def propagate_constraints(self, circle_idx: int, \n                             placed_circles: List[Circle]) -> Optional[Tuple[float, float, float, float]]:\n        \"\"\"\n        Propagate constraints to reduce domain of next circle\n        \n        Args:\n            circle_idx: Index of circle being placed\n            placed_circles: List of already placed circles\n            \n        Returns:\n            Tuple of (min_x, max_x, min_y, max_y) or None if no valid domain\n        \"\"\"\n        min_x = self.min_radius\n        max_x = self.width - self.min_radius\n        min_y = self.min_radius\n        max_y = self.height - self.min_radius\n        \n        # Propagate constraints from placed circles\n        for placed in placed_circles:\n            # Circles must be at least (r1 + r2) apart\n            min_dist = placed.radius + self.min_radius\n            \n            # Calculate forbidden region around placed circle\n            # This is a circular region where new circle center cannot be\n            # We approximate with rectangular bounds\n            forbidden_radius = min_dist\n            \n            # For now, we just use this for heuristic ordering\n            # More sophisticated propagation could be added\n        \n        if min_x >= max_x or min_y >= max_y:\n            return None\n        \n        return (min_x, max_x, min_y, max_y)\n    \n    def select_next_variable(self, placed_circles: List[Circle]) -> Optional[int]:\n        \"\"\"\n        Select next variable using MRV (Minimum Remaining Values) heuristic\n        \n        Returns:\n            Index of next circle to place, or None if all placed\n        \"\"\"\n        if len(placed_circles) >= self.num_circles:\n            return None\n        return len(placed_circles)\n    \n    def order_domain_values(self, circle_idx: int, \n                           placed_circles: List[Circle]) -> List[Tuple[float, float, float]]:\n        \"\"\"\n        Order possible values for a circle using least constraining value heuristic\n        \n        Returns:\n            List of (x, y, radius) tuples ordered by likelihood of success\n        \"\"\"\n        values = []\n        \n        # Generate candidate positions\n        num_candidates = 15\n        \n        for radius in np.linspace(self.min_radius, self.max_radius, 3):\n            for _ in range(num_candidates):\n                x = np.random.uniform(radius, self.width - radius)\n                y = np.random.uniform(radius, self.height - radius)\n                values.append((x, y, radius))\n        \n        # Also try grid-based positions\n        grid_size = 4\n        for i in range(grid_size):\n            for j in range(grid_size):\n                x = (i + 0.5) * self.width / grid_size\n                y = (j + 0.5) * self.height / grid_size\n                for radius in [self.min_radius, (self.min_radius + self.max_radius) / 2, self.max_radius]:\n                    values.append((x, y, radius))\n        \n        return values\n    \n    def backtrack(self, placed_circles: List[Circle], depth: int = 0, \n                  max_depth: Optional[int] = None) -> bool:\n        \"\"\"\n        Backtracking search with constraint propagation\n        \n        Args:\n            placed_circles: List of circles placed so far\n            depth: Current recursion depth\n            max_depth: Maximum recursion depth\n            \n        Returns:\n            True if valid packing found, False otherwise\n        \"\"\"\n        max_depth = max_depth or self.num_circles * 50\n        \n        # Check if complete assignment\n        if len(placed_circles) == self.num_circles:\n            self.circles = copy.deepcopy(placed_circles)\n            return True\n        \n        if depth > max_depth:\n            return False\n        \n        # Select next variable\n        circle_idx = self.select_next_variable(placed_circles)\n        if circle_idx is None:\n            return True\n        \n        # Propagate constraints\n        domain = self.propagate_constraints(circle_idx, placed_circles)\n        if domain is None:\n            return False\n        \n        # Order domain values\n        values = self.order_domain_values(circle_idx, placed_circles)\n        \n        # Try each value\n        for x, y, radius in values:\n            circle = Circle(circle_idx, x, y, radius)\n            \n            if self.is_valid_placement(circle, placed_circles):\n                placed_circles.append(circle)\n                \n                if self.backtrack(placed_circles, depth + 1, max_depth):\n                    return True\n                \n                placed_circles.pop()\n        \n        return False\n    \n    def optimize_radii(self, learning_rate: float = 0.01, \n                      iterations: int = 100) -> float:\n        \"\"\"\n        Optimize circle radii to maximize total area while maintaining constraints\n        \n        Args:\n            learning_rate: Learning rate for optimization\n            iterations: Number of optimization iterations\n            \n        Returns:\n            Final objective value (total area)\n        \"\"\"\n        def objective(radii):\n            \"\"\"Objective: maximize total area\"\"\"\n            return -np.sum(radii**2 * np.pi)  # Negative because we minimize\n        \n        def constraint_overlap(radii):\n            \"\"\"Constraint: no overlaps\"\"\"\n            violations = 0\n            for i in range(len(self.circles)):\n                for j in range(i + 1, len(self.circles)):\n                    c1 = self.circles[i]\n                    c2 = self.circles[j]\n                    distance = np.sqrt((c1.x - c2.x)**2 + (c1.y - c2.y)**2)\n                    min_distance = radii[i] + radii[j]\n                    if distance < min_distance:\n                        violations += (min_distance - distance)**2\n            return violations\n        \n        def constraint_boundary(radii):\n            \"\"\"Constraint: circles within bounds\"\"\"\n            violations = 0\n            for i, circle in enumerate(self.circles):\n                r = radii[i]\n                if circle.x - r < 0:\n                    violations += (-(circle.x - r))**2\n                if circle.x + r > self.width:\n                    violations += ((circle.x + r) - self.width)**2\n                if circle.y - r < 0:\n                    violations += (-(circle.y - r))**2\n                if circle.y + r > self.height:\n                    violations += ((circle.y + r) - self.height)**2\n            return violations\n        \n        def penalty_objective(radii):\n            \"\"\"Combined objective with penalties\"\"\"\n            # Ensure radii within bounds\n            radii = np.clip(radii, self.min_radius, self.max_radius)\n            \n            # Objective: negative area (we want to maximize)\n            obj = objective(radii)\n            \n            # Penalties\n            overlap_penalty = constraint_overlap(radii)\n            boundary_penalty = constraint_boundary(radii)\n            \n            return obj + 100 * overlap_penalty + 100 * boundary_penalty\n        \n        # Initial radii\n        x0 = np.array([c.radius for c in self.circles])\n        \n        # Optimize using scipy\n        bounds = [(self.min_radius, self.max_radius) for _ in range(len(self.circles))]\n        \n        result = minimize(\n            penalty_objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': iterations}\n        )\n        \n        # Update circle radii\n        optimal_radii = result.x\n        for i, circle in enumerate(self.circles):\n            circle.radius = optimal_radii[i]\n        \n        return -result.fun\n    \n    def visualize(self, title: str = \"Circle Packing\", figsize: Tuple[int, int] = (10, 10)):\n        \"\"\"Visualize the circle packing\"\"\"\n        fig, ax = plt.subplots(figsize=figsize)\n        \n        # Draw container\n        rect = plt.Rectangle((0, 0), self.width, self.height, \n                             fill=False, edgecolor='black', linewidth=2)\n        ax.add_patch(rect)\n        \n        # Draw circles\n        colors = plt.cm.tab20(np.linspace(0, 1, len(self.circles)))\n        for i, circle in enumerate(self.circles):\n            circ = plt.Circle((circle.x, circle.y), circle.radius, \n                             color=colors[i], alpha=0.6, edgecolor='black', linewidth=1.5)\n            ax.add_patch(circ)\n            ax.text(circle.x, circle.y, str(circle.id), \n                   ha='center', va='center', fontsize=8, fontweight='bold')\n        \n        # Set axis properties\n        ax.set_xlim(-5, self.width + 5)\n        ax.set_ylim(-5, self.height + 5)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_title(title)\n        \n        # Calculate statistics\n        total_area = sum(np.pi * c.radius**2 for c in self.circles)\n        container_area = self.width * self.height\n        utilization = (total_area / container_area) * 100\n        \n        stats_text = f\"Circles: {len(self.circles)}\\n\"\n        stats_text += f\"Container: {self.width}\u00d7{self.height}\\n\"\n        stats_text += f\"Total Area: {total_area:.2f}\\n\"\n        stats_text += f\"Utilization: {utilization:.2f}%\"\n        \n        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes,\n               verticalalignment='top', bbox=dict(boxstyle='round', \n               facecolor='wheat', alpha=0.8), fontsize=10)\n        \n        plt.tight_layout()\n        return fig, ax\n    \n    def get_statistics(self) -> dict:\n        \"\"\"Get packing statistics\"\"\"\n        total_area = sum(np.pi * c.radius**2 for c in self.circles)\n        container_area = self.width * self.height\n        \n        # Check for overlaps\n        overlaps = 0\n        for i in range(len(self.circles)):\n            for j in range(i + 1, len(self.circles)):\n                if self.check_overlap(self.circles[i], self.circles[j]):\n                    overlaps += 1\n        \n        # Check boundary violations\n        boundary_violations = sum(\n            1 for c in self.circles if not self.check_boundary(c)\n        )\n        \n        return {\n            'num_circles': len(self.circles),\n            'total_area': total_area,\n            'container_area': container_area,\n            'utilization': (total_area / container_area) * 100,\n            'overlaps': overlaps,\n            'boundary_violations': boundary_violations,\n            'avg_radius': np.mean([c.radius for c in self.circles]),\n            'min_radius': min(c.radius for c in self.circles),\n            'max_radius': max(c.radius for c in self.circles),\n        }\n\n\ndef construct_packing(num_circles: int = 26, width: float = 100.0, \n                      height: float = 100.0, seed: int = 42) -> CirclePackingCSP:\n    \"\"\"\n    Construct a circle packing using CSP with backtracking\n    \n    Args:\n        num_circles: Number of circles to pack\n        width: Container width\n        height: Container height\n        seed: Random seed for reproducibility\n        \n    Returns:\n        CirclePackingCSP instance with solved packing\n    \"\"\"\n    np.random.seed(seed)\n    \n    csp = CirclePackingCSP(num_circles, width, height)\n    \n    print(f\"Constructing packing for {num_circles} circles...\")\n    print(f\"Container: {width}\u00d7{height}\")\n    \n    # Run back",
  "reasoning": "# Circle Packing Algorithm with Constraint Satisfaction\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom dataclasses import dataclass\nfrom typing import List, Tuple, Optional\nimport heapq\nfrom scipy.optimize import minimize\nimport copy\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with position and radius\"\"\"\n    id: int\n    x: float\n    y: float\n    radius: float\n    \n    def __repr__(self):\n        return f\"Circle({self.id}, x={self.x:.2f}, y={self.y:.2f}, r={self.radius:.2f})\"\n\nclass CirclePackingCSP:\n    \"\"\"Constraint Satisfaction Problem solver for circle packing\"\"\"\n    \n    def __init__(self, num_circles: int = 26, width: float = 100.0, height: float = 100.0):\n        \"\"\"\n        Initialize the circle packing CSP\n        \n        Args:\n            num_circles: Number of circles to pack\n            width: Container width\n            height: Container height\n        \"\"\"\n        self.num_circles = num_circles\n        self.width = width\n        self.height = height\n        self.circles: List[Circle] = []\n        self.min_radius = 1.0\n        self.max_radius = 5.0\n        \n    def add_circle(self, circle_id: int, x: float, y: float, radius: float) -> None:\n        \"\"\"Add a circle to the packing\"\"\"\n        self.circles.append(Circle(circle_id, x, y, radius))\n    \n    def check_overlap(self, c1: Circle, c2: Circle) -> bool:\n        \"\"\"\n        Check if two circles overlap\n        \n        Returns:\n            True if circles overlap, False otherwise\n        \"\"\"\n        distance = np.sqrt((c1.x - c2.x)**2 + (c1.y - c2.y)**2)\n        min_distance = c1.radius + c2.radius\n        return distance < min_distance - 1e-6\n    \n    def check_boundary(self, circle: Circle) -> bool:\n        \"\"\"\n        Check if circle violates boundary constraints\n        \n        Returns:\n            True if circle is within bounds, False otherwise\n        \"\"\"\n        return (circle.x - circle.radius >= 0 and\n                circle.x + circle.radius <= self.width and\n                circle.y - circle.radius >= 0 and\n                circle.y + circle.radius <= self.height)\n    \n    def get_overlap_distance(self, c1: Circle, c2: Circle) -> float:\n        \"\"\"Calculate how much two circles overlap (positive if overlapping)\"\"\"\n        distance = np.sqrt((c1.x - c2.x)**2 + (c1.y - c2.y)**2)\n        min_distance = c1.radius + c2.radius\n        return max(0, min_distance - distance)\n    \n    def get_boundary_violation(self, circle: Circle) -> float:\n        \"\"\"Calculate boundary violation amount\"\"\"\n        violation = 0\n        if circle.x - circle.radius < 0:\n            violation += abs(circle.x - circle.radius)\n        if circle.x + circle.radius > self.width:\n            violation += circle.x + circle.radius - self.width\n        if circle.y - circle.radius < 0:\n            violation += abs(circle.y - circle.radius)\n        if circle.y + circle.radius > self.height:\n            violation += circle.y + circle.radius - self.height\n        return violation\n    \n    def is_valid_placement(self, circle: Circle, placed_circles: List[Circle]) -> bool:\n        \"\"\"\n        Check if a circle placement is valid\n        \n        Args:\n            circle: Circle to place\n            placed_circles: List of already placed circles\n            \n        Returns:\n            True if placement is valid, False otherwise\n        \"\"\"\n        # Check boundary constraint\n        if not self.check_boundary(circle):\n            return False\n        \n        # Check non-overlap constraint with all placed circles\n        for placed in placed_circles:\n            if self.check_overlap(circle, placed):\n                return False\n        \n        return True\n    \n    def propagate_constraints(self, circle_idx: int, \n                             placed_circles: List[Circle]) -> Optional[Tuple[float, float, float, float]]:\n        \"\"\"\n        Propagate constraints to reduce domain of next circle\n        \n        Args:\n            circle_idx: Index of circle being placed\n            placed_circles: List of already placed circles\n            \n        Returns:\n            Tuple of (min_x, max_x, min_y, max_y) or None if no valid domain\n        \"\"\"\n        min_x = self.min_radius\n        max_x = self.width - self.min_radius\n        min_y = self.min_radius\n        max_y = self.height - self.min_radius\n        \n        # Propagate constraints from placed circles\n        for placed in placed_circles:\n            # Circles must be at least (r1 + r2) apart\n            min_dist = placed.radius + self.min_radius\n            \n            # Calculate forbidden region around placed circle\n            # This is a circular region where new circle center cannot be\n            # We approximate with rectangular bounds\n            forbidden_radius = min_dist\n            \n            # For now, we just use this for heuristic ordering\n            # More sophisticated propagation could be added\n        \n        if min_x >= max_x or min_y >= max_y:\n            return None\n        \n        return (min_x, max_x, min_y, max_y)\n    \n    def select_next_variable(self, placed_circles: List[Circle]) -> Optional[int]:\n        \"\"\"\n        Select next variable using MRV (Minimum Remaining Values) heuristic\n        \n        Returns:\n            Index of next circle to place, or None if all placed\n        \"\"\"\n        if len(placed_circles) >= self.num_circles:\n            return None\n        return len(placed_circles)\n    \n    def order_domain_values(self, circle_idx: int, \n                           placed_circles: List[Circle]) -> List[Tuple[float, float, float]]:\n        \"\"\"\n        Order possible values for a circle using least constraining value heuristic\n        \n        Returns:\n            List of (x, y, radius) tuples ordered by likelihood of success\n        \"\"\"\n        values = []\n        \n        # Generate candidate positions\n        num_candidates = 15\n        \n        for radius in np.linspace(self.min_radius, self.max_radius, 3):\n            for _ in range(num_candidates):\n                x = np.random.uniform(radius, self.width - radius)\n                y = np.random.uniform(radius, self.height - radius)\n                values.append((x, y, radius))\n        \n        # Also try grid-based positions\n        grid_size = 4\n        for i in range(grid_size):\n            for j in range(grid_size):\n                x = (i + 0.5) * self.width / grid_size\n                y = (j + 0.5) * self.height / grid_size\n                for radius in [self.min_radius, (self.min_radius + self.max_radius) / 2, self.max_radius]:\n                    values.append((x, y, radius))\n        \n        return values\n    \n    def backtrack(self, placed_circles: List[Circle], depth: int = 0, \n                  max_depth: Optional[int] = None) -> bool:\n        \"\"\"\n        Backtracking search with constraint propagation\n        \n        Args:\n            placed_circles: List of circles placed so far\n            depth: Current recursion depth\n            max_depth: Maximum recursion depth\n            \n        Returns:\n            True if valid packing found, False otherwise\n        \"\"\"\n        max_depth = max_depth or self.num_circles * 50\n        \n        # Check if complete assignment\n        if len(placed_circles) == self.num_circles:\n            self.circles = copy.deepcopy(placed_circles)\n            return True\n        \n        if depth > max_depth:\n            return False\n        \n        # Select next variable\n        circle_idx = self.select_next_variable(placed_circles)\n        if circle_idx is None:\n            return True\n        \n        # Propagate constraints\n        domain = self.propagate_constraints(circle_idx, placed_circles)\n        if domain is None:\n            return False\n        \n        # Order domain values\n        values = self.order_domain_values(circle_idx, placed_circles)\n        \n        # Try each value\n        for x, y, radius in values:\n            circle = Circle(circle_idx, x, y, radius)\n            \n            if self.is_valid_placement(circle, placed_circles):\n                placed_circles.append(circle)\n                \n                if self.backtrack(placed_circles, depth + 1, max_depth):\n                    return True\n                \n                placed_circles.pop()\n        \n        return False\n    \n    def optimize_radii(self, learning_rate: float = 0.01, \n                      iterations: int = 100) -> float:\n        \"\"\"\n        Optimize circle radii to maximize total area while maintaining constraints\n        \n        Args:\n            learning_rate: Learning rate for optimization\n            iterations: Number of optimization iterations\n            \n        Returns:\n            Final objective value (total area)\n        \"\"\"\n        def objective(radii):\n            \"\"\"Objective: maximize total area\"\"\"\n            return -np.sum(radii**2 * np.pi)  # Negative because we minimize\n        \n        def constraint_overlap(radii):\n            \"\"\"Constraint: no overlaps\"\"\"\n            violations = 0\n            for i in range(len(self.circles)):\n                for j in range(i + 1, len(self.circles)):\n                    c1 = self.circles[i]\n                    c2 = self.circles[j]\n                    distance = np.sqrt((c1.x - c2.x)**2 + (c1.y - c2.y)**2)\n                    min_distance = radii[i] + radii[j]\n                    if distance < min_distance:\n                        violations += (min_distance - distance)**2\n            return violations\n        \n        def constraint_boundary(radii):\n            \"\"\"Constraint: circles within bounds\"\"\"\n            violations = 0\n            for i, circle in enumerate(self.circles):\n                r = radii[i]\n                if circle.x - r < 0:\n                    violations += (-(circle.x - r))**2\n                if circle.x + r > self.width:\n                    violations += ((circle.x + r) - self.width)**2\n                if circle.y - r < 0:\n                    violations += (-(circle.y - r))**2\n                if circle.y + r > self.height:\n                    violations += ((circle.y + r) - self.height)**2\n            return violations\n        \n        def penalty_objective(radii):\n            \"\"\"Combined objective with penalties\"\"\"\n            # Ensure radii within bounds\n            radii = np.clip(radii, self.min_radius, self.max_radius)\n            \n            # Objective: negative area (we want to maximize)\n            obj = objective(radii)\n            \n            # Penalties\n            overlap_penalty = constraint_overlap(radii)\n            boundary_penalty = constraint_boundary(radii)\n            \n            return obj + 100 * overlap_penalty + 100 * boundary_penalty\n        \n        # Initial radii\n        x0 = np.array([c.radius for c in self.circles])\n        \n        # Optimize using scipy\n        bounds = [(self.min_radius, self.max_radius) for _ in range(len(self.circles))]\n        \n        result = minimize(\n            penalty_objective,\n            x0,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': iterations}\n        )\n        \n        # Update circle radii\n        optimal_radii = result.x\n        for i, circle in enumerate(self.circles):\n            circle.radius = optimal_radii[i]\n        \n        return -result.fun\n    \n    def visualize(self, title: str = \"Circle Packing\", figsize: Tuple[int, int] = (10, 10)):\n        \"\"\"Visualize the circle packing\"\"\"\n        fig, ax = plt.subplots(figsize=figsize)\n        \n        # Draw container\n        rect = plt.Rectangle((0, 0), self.width, self.height, \n                             fill=False, edgecolor='black', linewidth=2)\n        ax.add_patch(rect)\n        \n        # Draw circles\n        colors = plt.cm.tab20(np.linspace(0, 1, len(self.circles)))\n        for i, circle in enumerate(self.circles):\n            circ = plt.Circle((circle.x, circle.y), circle.radius, \n                             color=colors[i], alpha=0.6, edgecolor='black', linewidth=1.5)\n            ax.add_patch(circ)\n            ax.text(circle.x, circle.y, str(circle.id), \n                   ha='center', va='center', fontsize=8, fontweight='bold')\n        \n        # Set axis properties\n        ax.set_xlim(-5, self.width + 5)\n        ax.set_ylim(-5, self.height + 5)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.set_title(title)\n        \n        # Calculate statistics\n        total_area = sum(np.pi * c.radius**2 for c in self.circles)\n        container_area = self.width * self.height\n        utilization = (total_area / container_area) * 100\n        \n        stats_text = f\"Circles: {len(self.circles)}\\n\"\n        stats_text += f\"Container: {self.width}\u00d7{self.height}\\n\"\n        stats_text += f\"Total Area: {total_area:.2f}\\n\"\n        stats_text += f\"Utilization: {utilization:.2f}%\"\n        \n        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes,\n               verticalalignment='top', bbox=dict(boxstyle='round', \n               facecolor='wheat', alpha=0.8), fontsize=10)\n        \n        plt.tight_layout()\n        return fig, ax\n    \n    def get_statistics(self) -> dict:\n        \"\"\"Get packing statistics\"\"\"\n        total_area = sum(np.pi * c.radius**2 for c in self.circles)\n        container_area = self.width * self.height\n        \n        # Check for overlaps\n        overlaps = 0\n        for i in range(len(self.circles)):\n            for j in range(i + 1, len(self.circles)):\n                if self.check_overlap(self.circles[i], self.circles[j]):\n                    overlaps += 1\n        \n        # Check boundary violations\n        boundary_violations = sum(\n            1 for c in self.circles if not self.check_boundary(c)\n        )\n        \n        return {\n            'num_circles': len(self.circles),\n            'total_area': total_area,\n            'container_area': container_area,\n            'utilization': (total_area / container_area) * 100,\n            'overlaps': overlaps,\n            'boundary_violations': boundary_violations,\n            'avg_radius': np.mean([c.radius for c in self.circles]),\n            'min_radius': min(c.radius for c in self.circles),\n            'max_radius': max(c.radius for c in self.circles),\n        }\n\ndef construct_packing(num_circles: int = 26, width: float = 100.0, \n                      height: float = 100.0, seed: int = 42) -> CirclePackingCSP:\n    \"\"\"\n    Construct a circle packing using CSP with backtracking\n    \n    Args:\n        num_circles: Number of circles to pack\n        width: Container width\n        height: Container height\n        seed: Random seed for reproducibility\n        \n    Returns:\n        CirclePackingCSP instance with solved packing\n    \"\"\"\n    np.random.seed(seed)\n    \n    csp = CirclePackingCSP(num_circles, width, height)\n    \n    print(f\"Constructing packing for {num_circles} circles...\")\n    print(f\"Container: {width}\u00d7{height}\")\n    \n    # Run back",
  "timestamp": "2025-12-08T12:15:35.128750",
  "cost_data": null
}