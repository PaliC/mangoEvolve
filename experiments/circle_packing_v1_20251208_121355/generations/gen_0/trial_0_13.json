{
  "trial_id": "trial_0_13",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a circle packing algorithm for 26 circles using a particle swarm optimization approach. Initialize circles randomly, apply PSO mechanics to find optimal positions and radii. Include construct_packing() and run_packing() functions.",
  "response": "# Circle Packing using Particle Swarm Optimization\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom typing import List, Tuple, Optional\nfrom dataclasses import dataclass\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with position and radius\"\"\"\n    x: float\n    y: float\n    radius: float\n    \n    def distance_to(self, other: 'Circle') -> float:\n        \"\"\"Calculate distance between circle centers\"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n    \n    def overlaps_with(self, other: 'Circle') -> float:\n        \"\"\"Calculate overlap amount (positive if overlapping)\"\"\"\n        dist = self.distance_to(other)\n        min_dist = self.radius + other.radius\n        return max(0, min_dist - dist)\n    \n    def outside_bounds(self, bounds: Tuple[float, float, float, float]) -> float:\n        \"\"\"Calculate how much circle extends outside bounds\"\"\"\n        x_min, y_min, x_max, y_max = bounds\n        penalty = 0.0\n        \n        if self.x - self.radius < x_min:\n            penalty += (x_min - (self.x - self.radius))\n        if self.x + self.radius > x_max:\n            penalty += ((self.x + self.radius) - x_max)\n        if self.y - self.radius < y_min:\n            penalty += (y_min - (self.y - self.radius))\n        if self.y + self.radius > y_max:\n            penalty += ((self.y + self.radius) - y_max)\n        \n        return penalty\n\n\nclass CirclePackingPSO:\n    \"\"\"\n    Particle Swarm Optimization for circle packing problem\n    \n    Each particle represents a potential solution (positions and radii of all circles)\n    Objective: Maximize total area while minimizing overlaps and boundary violations\n    \"\"\"\n    \n    def __init__(\n        self,\n        num_circles: int = 26,\n        bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n        num_particles: int = 30,\n        max_iterations: int = 500,\n        min_radius: float = 1.0,\n        max_radius: float = 10.0,\n        seed: Optional[int] = None\n    ):\n        \"\"\"\n        Initialize PSO for circle packing\n        \n        Args:\n            num_circles: Number of circles to pack\n            bounds: (x_min, y_min, x_max, y_max)\n            num_particles: Number of particles in swarm\n            max_iterations: Maximum PSO iterations\n            min_radius: Minimum circle radius\n            max_radius: Maximum circle radius\n            seed: Random seed for reproducibility\n        \"\"\"\n        self.num_circles = num_circles\n        self.bounds = bounds\n        self.num_particles = num_particles\n        self.max_iterations = max_iterations\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        \n        if seed is not None:\n            np.random.seed(seed)\n        \n        # PSO parameters\n        self.w = 0.7          # Inertia weight\n        self.c1 = 1.5         # Cognitive parameter\n        self.c2 = 1.5         # Social parameter\n        \n        # Penalty weights for fitness function\n        self.overlap_penalty = 100.0\n        self.boundary_penalty = 50.0\n        \n        # Initialize swarm\n        self.particles = []\n        self.velocities = []\n        self.best_positions = []\n        self.best_fitness = []\n        self.global_best_position = None\n        self.global_best_fitness = -np.inf\n        \n        self.fitness_history = []\n        \n        self._initialize_swarm()\n    \n    def _initialize_swarm(self) -> None:\n        \"\"\"Initialize particles with random positions and radii\"\"\"\n        x_min, y_min, x_max, y_max = self.bounds\n        \n        for _ in range(self.num_particles):\n            # Each particle has: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n            # Total dimensions: 26 * 3 = 78\n            particle = []\n            \n            for _ in range(self.num_circles):\n                x = np.random.uniform(x_min, x_max)\n                y = np.random.uniform(y_min, y_max)\n                r = np.random.uniform(self.min_radius, self.max_radius)\n                particle.extend([x, y, r])\n            \n            particle = np.array(particle)\n            self.particles.append(particle)\n            \n            # Initialize velocity\n            velocity = np.random.uniform(-1, 1, len(particle))\n            self.velocities.append(velocity)\n            \n            # Evaluate fitness\n            fitness = self._evaluate_fitness(particle)\n            self.best_positions.append(particle.copy())\n            self.best_fitness.append(fitness)\n            \n            # Update global best\n            if fitness > self.global_best_fitness:\n                self.global_best_fitness = fitness\n                self.global_best_position = particle.copy()\n    \n    def _particle_to_circles(self, particle: np.ndarray) -> List[Circle]:\n        \"\"\"Convert particle array to list of Circle objects\"\"\"\n        circles = []\n        for i in range(self.num_circles):\n            idx = i * 3\n            x = particle[idx]\n            y = particle[idx + 1]\n            r = np.clip(particle[idx + 2], self.min_radius, self.max_radius)\n            circles.append(Circle(x, y, r))\n        return circles\n    \n    def _evaluate_fitness(self, particle: np.ndarray) -> float:\n        \"\"\"\n        Evaluate fitness of a particle\n        \n        Objective: Maximize total area while minimizing overlaps and violations\n        \"\"\"\n        circles = self._particle_to_circles(particle)\n        \n        # Calculate total area\n        total_area = sum(np.pi * c.radius**2 for c in circles)\n        \n        # Calculate overlap penalty\n        overlap_penalty = 0.0\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                overlap = circles[i].overlaps_with(circles[j])\n                overlap_penalty += overlap**2\n        \n        # Calculate boundary violation penalty\n        boundary_penalty = 0.0\n        for circle in circles:\n            violation = circle.outside_bounds(self.bounds)\n            boundary_penalty += violation**2\n        \n        # Fitness: maximize area, minimize penalties\n        fitness = (\n            total_area\n            - self.overlap_penalty * overlap_penalty\n            - self.boundary_penalty * boundary_penalty\n        )\n        \n        return fitness\n    \n    def _update_velocity_and_position(self, particle_idx: int) -> None:\n        \"\"\"Update velocity and position of a particle using PSO equations\"\"\"\n        particle = self.particles[particle_idx]\n        velocity = self.velocities[particle_idx]\n        best_pos = self.best_positions[particle_idx]\n        \n        x_min, y_min, x_max, y_max = self.bounds\n        \n        # PSO update equations\n        r1 = np.random.random(len(particle))\n        r2 = np.random.random(len(particle))\n        \n        velocity = (\n            self.w * velocity +\n            self.c1 * r1 * (best_pos - particle) +\n            self.c2 * r2 * (self.global_best_position - particle)\n        )\n        \n        # Limit velocity\n        velocity = np.clip(velocity, -5, 5)\n        \n        # Update position\n        particle = particle + velocity\n        \n        # Enforce bounds for positions\n        for i in range(self.num_circles):\n            idx = i * 3\n            particle[idx] = np.clip(particle[idx], x_min, x_max)      # x\n            particle[idx + 1] = np.clip(particle[idx + 1], y_min, y_max)  # y\n            particle[idx + 2] = np.clip(particle[idx + 2], \n                                       self.min_radius, self.max_radius)  # r\n        \n        self.particles[particle_idx] = particle\n        self.velocities[particle_idx] = velocity\n    \n    def optimize(self) -> Tuple[List[Circle], List[float]]:\n        \"\"\"\n        Run PSO optimization\n        \n        Returns:\n            Tuple of (best_circles, fitness_history)\n        \"\"\"\n        for iteration in range(self.max_iterations):\n            for particle_idx in range(self.num_particles):\n                # Evaluate current position\n                fitness = self._evaluate_fitness(self.particles[particle_idx])\n                \n                # Update personal best\n                if fitness > self.best_fitness[particle_idx]:\n                    self.best_fitness[particle_idx] = fitness\n                    self.best_positions[particle_idx] = self.particles[particle_idx].copy()\n                \n                # Update global best\n                if fitness > self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best_position = self.particles[particle_idx].copy()\n                \n                # Update velocity and position\n                self._update_velocity_and_position(particle_idx)\n            \n            # Decay inertia weight\n            self.w *= 0.995\n            \n            self.fitness_history.append(self.global_best_fitness)\n            \n            if (iteration + 1) % 50 == 0:\n                print(f\"Iteration {iteration + 1}/{self.max_iterations}, \"\n                      f\"Best Fitness: {self.global_best_fitness:.4f}\")\n        \n        best_circles = self._particle_to_circles(self.global_best_position)\n        return best_circles, self.fitness_history\n\n\ndef construct_packing(\n    num_circles: int = 26,\n    bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n    num_particles: int = 30,\n    max_iterations: int = 500,\n    seed: Optional[int] = None\n) -> Tuple[List[Circle], CirclePackingPSO]:\n    \"\"\"\n    Construct circle packing using PSO\n    \n    Args:\n        num_circles: Number of circles to pack\n        bounds: Boundary box (x_min, y_min, x_max, y_max)\n        num_particles: Number of PSO particles\n        max_iterations: Maximum PSO iterations\n        seed: Random seed\n    \n    Returns:\n        Tuple of (circles, pso_optimizer)\n    \"\"\"\n    print(f\"\\n{'='*60}\")\n    print(f\"Circle Packing with PSO\")\n    print(f\"{'='*60}\")\n    print(f\"Number of circles: {num_circles}\")\n    print(f\"Bounds: {bounds}\")\n    print(f\"Particles: {num_particles}\")\n    print(f\"Max iterations: {max_iterations}\")\n    print(f\"{'='*60}\\n\")\n    \n    pso = CirclePackingPSO(\n        num_circles=num_circles,\n        bounds=bounds,\n        num_particles=num_particles,\n        max_iterations=max_iterations,\n        seed=seed\n    )\n    \n    circles, _ = pso.optimize()\n    \n    return circles, pso\n\n\ndef run_packing(\n    num_circles: int = 26,\n    bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n    num_particles: int = 30,\n    max_iterations: int = 500,\n    seed: Optional[int] = 42,\n    visualize: bool = True\n) -> Tuple[List[Circle], CirclePackingPSO]:\n    \"\"\"\n    Run complete circle packing pipeline with visualization\n    \n    Args:\n        num_circles: Number of circles to pack\n        bounds: Boundary box\n        num_particles: Number of PSO particles\n        max_iterations: Maximum iterations\n        seed: Random seed\n        visualize: Whether to plot results\n    \n    Returns:\n        Tuple of (circles, pso_optimizer)\n    \"\"\"\n    circles, pso = construct_packing(\n        num_circles=num_circles,\n        bounds=bounds,\n        num_particles=num_particles,\n        max_iterations=max_iterations,\n        seed=seed\n    )\n    \n    # Calculate statistics\n    total_area = sum(np.pi * c.radius**2 for c in circles)\n    \n    # Count overlaps\n    num_overlaps = 0\n    total_overlap = 0.0\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            overlap = circles[i].overlaps_with(circles[j])\n            if overlap > 0:\n                num_overlaps += 1\n                total_overlap += overlap\n    \n    # Count boundary violations\n    num_violations = 0\n    for circle in circles:\n        if circle.outside_bounds(bounds) > 0.01:\n            num_violations += 1\n    \n    print(f\"\\n{'='*60}\")\n    print(f\"Results Summary\")\n    print(f\"{'='*60}\")\n    print(f\"Total packing area: {total_area:.2f}\")\n    print(f\"Number of overlapping pairs: {num_overlaps}\")\n    print(f\"Total overlap amount: {total_overlap:.4f}\")\n    print(f\"Circles violating bounds: {num_violations}\")\n    print(f\"Final fitness score: {pso.global_best_fitness:.4f}\")\n    print(f\"{'='*60}\\n\")\n    \n    if visualize:\n        visualize_packing(circles, pso, bounds)\n    \n    return circles, pso\n\n\ndef visualize_packing(\n    circles: List[Circle],\n    pso: CirclePackingPSO,\n    bounds: Tuple[float, float, float, float]\n) -> None:\n    \"\"\"Visualize circle packing results\"\"\"\n    fig, axes = plt.subplots(1, 2, figsize=(16, 7))\n    \n    # Plot 1: Circle packing\n    ax = axes[0]\n    x_min, y_min, x_max, y_max = bounds\n    \n    # Draw boundary\n    rect = patches.Rectangle(\n        (x_min, y_min), x_max - x_min, y_max - y_min,\n        linewidth=2, edgecolor='black', facecolor='none'\n    )\n    ax.add_patch(rect)\n    \n    # Draw circles with colors based on radius\n    colors = plt.cm.viridis(np.linspace(0, 1, len(circles)))\n    \n    for circle, color in zip(circles, colors):\n        circle_patch = patches.Circle(\n            (circle.x, circle.y), circle.radius,\n            linewidth=1.5, edgecolor='black', facecolor=color, alpha=0.7\n        )\n        ax.add_patch(circle_patch)\n        \n        # Add circle index\n        ax.text(circle.x, circle.y, str(circles.index(circle)),\n               ha='center', va='center', fontsize=8, fontweight='bold')\n    \n    ax.set_xlim(x_min - 5, x_max + 5)\n    ax.set_ylim(y_min - 5, y_max + 5)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_xlabel('X', fontsize=11)\n    ax.set_ylabel('Y', fontsize=11)\n    ax.set_title('Circle Packing Result', fontsize=13, fontweight='bold')\n    \n    # Plot 2: Fitness convergence\n    ax = axes[1]\n    ax.plot(pso.fitness_history, linewidth=2, color='blue')\n    ax.fill_between(range(len(pso.fitness_history)), pso.fitness_history,\n                     alpha=0.3, color='blue')\n    ax.set_xlabel",
  "reasoning": "# Circle Packing using Particle Swarm Optimization\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom typing import List, Tuple, Optional\nfrom dataclasses import dataclass\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with position and radius\"\"\"\n    x: float\n    y: float\n    radius: float\n    \n    def distance_to(self, other: 'Circle') -> float:\n        \"\"\"Calculate distance between circle centers\"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n    \n    def overlaps_with(self, other: 'Circle') -> float:\n        \"\"\"Calculate overlap amount (positive if overlapping)\"\"\"\n        dist = self.distance_to(other)\n        min_dist = self.radius + other.radius\n        return max(0, min_dist - dist)\n    \n    def outside_bounds(self, bounds: Tuple[float, float, float, float]) -> float:\n        \"\"\"Calculate how much circle extends outside bounds\"\"\"\n        x_min, y_min, x_max, y_max = bounds\n        penalty = 0.0\n        \n        if self.x - self.radius < x_min:\n            penalty += (x_min - (self.x - self.radius))\n        if self.x + self.radius > x_max:\n            penalty += ((self.x + self.radius) - x_max)\n        if self.y - self.radius < y_min:\n            penalty += (y_min - (self.y - self.radius))\n        if self.y + self.radius > y_max:\n            penalty += ((self.y + self.radius) - y_max)\n        \n        return penalty\n\nclass CirclePackingPSO:\n    \"\"\"\n    Particle Swarm Optimization for circle packing problem\n    \n    Each particle represents a potential solution (positions and radii of all circles)\n    Objective: Maximize total area while minimizing overlaps and boundary violations\n    \"\"\"\n    \n    def __init__(\n        self,\n        num_circles: int = 26,\n        bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n        num_particles: int = 30,\n        max_iterations: int = 500,\n        min_radius: float = 1.0,\n        max_radius: float = 10.0,\n        seed: Optional[int] = None\n    ):\n        \"\"\"\n        Initialize PSO for circle packing\n        \n        Args:\n            num_circles: Number of circles to pack\n            bounds: (x_min, y_min, x_max, y_max)\n            num_particles: Number of particles in swarm\n            max_iterations: Maximum PSO iterations\n            min_radius: Minimum circle radius\n            max_radius: Maximum circle radius\n            seed: Random seed for reproducibility\n        \"\"\"\n        self.num_circles = num_circles\n        self.bounds = bounds\n        self.num_particles = num_particles\n        self.max_iterations = max_iterations\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        \n        if seed is not None:\n            np.random.seed(seed)\n        \n        # PSO parameters\n        self.w = 0.7          # Inertia weight\n        self.c1 = 1.5         # Cognitive parameter\n        self.c2 = 1.5         # Social parameter\n        \n        # Penalty weights for fitness function\n        self.overlap_penalty = 100.0\n        self.boundary_penalty = 50.0\n        \n        # Initialize swarm\n        self.particles = []\n        self.velocities = []\n        self.best_positions = []\n        self.best_fitness = []\n        self.global_best_position = None\n        self.global_best_fitness = -np.inf\n        \n        self.fitness_history = []\n        \n        self._initialize_swarm()\n    \n    def _initialize_swarm(self) -> None:\n        \"\"\"Initialize particles with random positions and radii\"\"\"\n        x_min, y_min, x_max, y_max = self.bounds\n        \n        for _ in range(self.num_particles):\n            # Each particle has: [x1, y1, r1, x2, y2, r2, ..., x26, y26, r26]\n            # Total dimensions: 26 * 3 = 78\n            particle = []\n            \n            for _ in range(self.num_circles):\n                x = np.random.uniform(x_min, x_max)\n                y = np.random.uniform(y_min, y_max)\n                r = np.random.uniform(self.min_radius, self.max_radius)\n                particle.extend([x, y, r])\n            \n            particle = np.array(particle)\n            self.particles.append(particle)\n            \n            # Initialize velocity\n            velocity = np.random.uniform(-1, 1, len(particle))\n            self.velocities.append(velocity)\n            \n            # Evaluate fitness\n            fitness = self._evaluate_fitness(particle)\n            self.best_positions.append(particle.copy())\n            self.best_fitness.append(fitness)\n            \n            # Update global best\n            if fitness > self.global_best_fitness:\n                self.global_best_fitness = fitness\n                self.global_best_position = particle.copy()\n    \n    def _particle_to_circles(self, particle: np.ndarray) -> List[Circle]:\n        \"\"\"Convert particle array to list of Circle objects\"\"\"\n        circles = []\n        for i in range(self.num_circles):\n            idx = i * 3\n            x = particle[idx]\n            y = particle[idx + 1]\n            r = np.clip(particle[idx + 2], self.min_radius, self.max_radius)\n            circles.append(Circle(x, y, r))\n        return circles\n    \n    def _evaluate_fitness(self, particle: np.ndarray) -> float:\n        \"\"\"\n        Evaluate fitness of a particle\n        \n        Objective: Maximize total area while minimizing overlaps and violations\n        \"\"\"\n        circles = self._particle_to_circles(particle)\n        \n        # Calculate total area\n        total_area = sum(np.pi * c.radius**2 for c in circles)\n        \n        # Calculate overlap penalty\n        overlap_penalty = 0.0\n        for i in range(len(circles)):\n            for j in range(i + 1, len(circles)):\n                overlap = circles[i].overlaps_with(circles[j])\n                overlap_penalty += overlap**2\n        \n        # Calculate boundary violation penalty\n        boundary_penalty = 0.0\n        for circle in circles:\n            violation = circle.outside_bounds(self.bounds)\n            boundary_penalty += violation**2\n        \n        # Fitness: maximize area, minimize penalties\n        fitness = (\n            total_area\n            - self.overlap_penalty * overlap_penalty\n            - self.boundary_penalty * boundary_penalty\n        )\n        \n        return fitness\n    \n    def _update_velocity_and_position(self, particle_idx: int) -> None:\n        \"\"\"Update velocity and position of a particle using PSO equations\"\"\"\n        particle = self.particles[particle_idx]\n        velocity = self.velocities[particle_idx]\n        best_pos = self.best_positions[particle_idx]\n        \n        x_min, y_min, x_max, y_max = self.bounds\n        \n        # PSO update equations\n        r1 = np.random.random(len(particle))\n        r2 = np.random.random(len(particle))\n        \n        velocity = (\n            self.w * velocity +\n            self.c1 * r1 * (best_pos - particle) +\n            self.c2 * r2 * (self.global_best_position - particle)\n        )\n        \n        # Limit velocity\n        velocity = np.clip(velocity, -5, 5)\n        \n        # Update position\n        particle = particle + velocity\n        \n        # Enforce bounds for positions\n        for i in range(self.num_circles):\n            idx = i * 3\n            particle[idx] = np.clip(particle[idx], x_min, x_max)      # x\n            particle[idx + 1] = np.clip(particle[idx + 1], y_min, y_max)  # y\n            particle[idx + 2] = np.clip(particle[idx + 2], \n                                       self.min_radius, self.max_radius)  # r\n        \n        self.particles[particle_idx] = particle\n        self.velocities[particle_idx] = velocity\n    \n    def optimize(self) -> Tuple[List[Circle], List[float]]:\n        \"\"\"\n        Run PSO optimization\n        \n        Returns:\n            Tuple of (best_circles, fitness_history)\n        \"\"\"\n        for iteration in range(self.max_iterations):\n            for particle_idx in range(self.num_particles):\n                # Evaluate current position\n                fitness = self._evaluate_fitness(self.particles[particle_idx])\n                \n                # Update personal best\n                if fitness > self.best_fitness[particle_idx]:\n                    self.best_fitness[particle_idx] = fitness\n                    self.best_positions[particle_idx] = self.particles[particle_idx].copy()\n                \n                # Update global best\n                if fitness > self.global_best_fitness:\n                    self.global_best_fitness = fitness\n                    self.global_best_position = self.particles[particle_idx].copy()\n                \n                # Update velocity and position\n                self._update_velocity_and_position(particle_idx)\n            \n            # Decay inertia weight\n            self.w *= 0.995\n            \n            self.fitness_history.append(self.global_best_fitness)\n            \n            if (iteration + 1) % 50 == 0:\n                print(f\"Iteration {iteration + 1}/{self.max_iterations}, \"\n                      f\"Best Fitness: {self.global_best_fitness:.4f}\")\n        \n        best_circles = self._particle_to_circles(self.global_best_position)\n        return best_circles, self.fitness_history\n\ndef construct_packing(\n    num_circles: int = 26,\n    bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n    num_particles: int = 30,\n    max_iterations: int = 500,\n    seed: Optional[int] = None\n) -> Tuple[List[Circle], CirclePackingPSO]:\n    \"\"\"\n    Construct circle packing using PSO\n    \n    Args:\n        num_circles: Number of circles to pack\n        bounds: Boundary box (x_min, y_min, x_max, y_max)\n        num_particles: Number of PSO particles\n        max_iterations: Maximum PSO iterations\n        seed: Random seed\n    \n    Returns:\n        Tuple of (circles, pso_optimizer)\n    \"\"\"\n    print(f\"\\n{'='*60}\")\n    print(f\"Circle Packing with PSO\")\n    print(f\"{'='*60}\")\n    print(f\"Number of circles: {num_circles}\")\n    print(f\"Bounds: {bounds}\")\n    print(f\"Particles: {num_particles}\")\n    print(f\"Max iterations: {max_iterations}\")\n    print(f\"{'='*60}\\n\")\n    \n    pso = CirclePackingPSO(\n        num_circles=num_circles,\n        bounds=bounds,\n        num_particles=num_particles,\n        max_iterations=max_iterations,\n        seed=seed\n    )\n    \n    circles, _ = pso.optimize()\n    \n    return circles, pso\n\ndef run_packing(\n    num_circles: int = 26,\n    bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n    num_particles: int = 30,\n    max_iterations: int = 500,\n    seed: Optional[int] = 42,\n    visualize: bool = True\n) -> Tuple[List[Circle], CirclePackingPSO]:\n    \"\"\"\n    Run complete circle packing pipeline with visualization\n    \n    Args:\n        num_circles: Number of circles to pack\n        bounds: Boundary box\n        num_particles: Number of PSO particles\n        max_iterations: Maximum iterations\n        seed: Random seed\n        visualize: Whether to plot results\n    \n    Returns:\n        Tuple of (circles, pso_optimizer)\n    \"\"\"\n    circles, pso = construct_packing(\n        num_circles=num_circles,\n        bounds=bounds,\n        num_particles=num_particles,\n        max_iterations=max_iterations,\n        seed=seed\n    )\n    \n    # Calculate statistics\n    total_area = sum(np.pi * c.radius**2 for c in circles)\n    \n    # Count overlaps\n    num_overlaps = 0\n    total_overlap = 0.0\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            overlap = circles[i].overlaps_with(circles[j])\n            if overlap > 0:\n                num_overlaps += 1\n                total_overlap += overlap\n    \n    # Count boundary violations\n    num_violations = 0\n    for circle in circles:\n        if circle.outside_bounds(bounds) > 0.01:\n            num_violations += 1\n    \n    print(f\"\\n{'='*60}\")\n    print(f\"Results Summary\")\n    print(f\"{'='*60}\")\n    print(f\"Total packing area: {total_area:.2f}\")\n    print(f\"Number of overlapping pairs: {num_overlaps}\")\n    print(f\"Total overlap amount: {total_overlap:.4f}\")\n    print(f\"Circles violating bounds: {num_violations}\")\n    print(f\"Final fitness score: {pso.global_best_fitness:.4f}\")\n    print(f\"{'='*60}\\n\")\n    \n    if visualize:\n        visualize_packing(circles, pso, bounds)\n    \n    return circles, pso\n\ndef visualize_packing(\n    circles: List[Circle],\n    pso: CirclePackingPSO,\n    bounds: Tuple[float, float, float, float]\n) -> None:\n    \"\"\"Visualize circle packing results\"\"\"\n    fig, axes = plt.subplots(1, 2, figsize=(16, 7))\n    \n    # Plot 1: Circle packing\n    ax = axes[0]\n    x_min, y_min, x_max, y_max = bounds\n    \n    # Draw boundary\n    rect = patches.Rectangle(\n        (x_min, y_min), x_max - x_min, y_max - y_min,\n        linewidth=2, edgecolor='black', facecolor='none'\n    )\n    ax.add_patch(rect)\n    \n    # Draw circles with colors based on radius\n    colors = plt.cm.viridis(np.linspace(0, 1, len(circles)))\n    \n    for circle, color in zip(circles, colors):\n        circle_patch = patches.Circle(\n            (circle.x, circle.y), circle.radius,\n            linewidth=1.5, edgecolor='black', facecolor=color, alpha=0.7\n        )\n        ax.add_patch(circle_patch)\n        \n        # Add circle index\n        ax.text(circle.x, circle.y, str(circles.index(circle)),\n               ha='center', va='center', fontsize=8, fontweight='bold')\n    \n    ax.set_xlim(x_min - 5, x_max + 5)\n    ax.set_ylim(y_min - 5, y_max + 5)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_xlabel('X', fontsize=11)\n    ax.set_ylabel('Y', fontsize=11)\n    ax.set_title('Circle Packing Result', fontsize=13, fontweight='bold')\n    \n    # Plot 2: Fitness convergence\n    ax = axes[1]\n    ax.plot(pso.fitness_history, linewidth=2, color='blue')\n    ax.fill_between(range(len(pso.fitness_history)), pso.fitness_history,\n                     alpha=0.3, color='blue')\n    ax.set_xlabel",
  "timestamp": "2025-12-08T12:15:33.413710",
  "cost_data": null
}