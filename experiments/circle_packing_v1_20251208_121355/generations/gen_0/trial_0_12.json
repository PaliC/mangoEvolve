{
  "trial_id": "trial_0_12",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize\nfrom matplotlib.patches import Circle\nimport warnings\nwarnings.filterwarnings('ignore')\n\nclass CirclePacking:\n    \"\"\"\n    Circle packing algorithm for 26 circles in a rectangular container.\n    Uses grid initialization followed by optimization.\n    \"\"\"\n    \n    def __init__(self, width=10.0, height=12.0, num_circles=26, grid_shape=(5, 6)):\n        \"\"\"\n        Initialize circle packing problem.\n        \n        Args:\n            width: Container width\n            height: Container height\n            num_circles: Number of circles to pack (should be 26)\n            grid_shape: Initial grid layout (rows, cols)\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.num_circles = num_circles\n        self.grid_shape = grid_shape\n        \n        assert grid_shape[0] * grid_shape[1] >= num_circles, \\\n            f\"Grid {grid_shape} cannot fit {num_circles} circles\"\n        \n        self.circles = []  # List of [x, y, radius]\n        self.optimization_history = []\n        \n    def construct_packing(self):\n        \"\"\"\n        Construct initial circle packing using rectangular grid layout.\n        Distributes circles evenly across the container.\n        \"\"\"\n        rows, cols = self.grid_shape\n        \n        # Calculate initial spacing\n        cell_width = self.width / cols\n        cell_height = self.height / rows\n        \n        # Initial radius (fit within grid cells with padding)\n        padding = 0.05\n        initial_radius = min(cell_width, cell_height) * (0.5 - padding)\n        \n        self.circles = []\n        circle_idx = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if circle_idx >= self.num_circles:\n                    break\n                \n                # Center position in grid cell\n                x = (j + 0.5) * cell_width\n                y = (i + 0.5) * cell_height\n                \n                self.circles.append([x, y, initial_radius])\n                circle_idx += 1\n            \n            if circle_idx >= self.num_circles:\n                break\n        \n        self.circles = np.array(self.circles, dtype=np.float64)\n        print(f\"\u2713 Initial grid packing constructed: {len(self.circles)} circles\")\n        print(f\"  Grid: {self.grid_shape[0]}x{self.grid_shape[1]}\")\n        print(f\"  Initial radius: {initial_radius:.4f}\")\n        \n        return self.circles\n    \n    def _get_state_vector(self):\n        \"\"\"Convert circle data to optimization state vector.\"\"\"\n        return self.circles.flatten()\n    \n    def _set_state_vector(self, state):\n        \"\"\"Restore circle data from optimization state vector.\"\"\"\n        self.circles = state.reshape(-1, 3).copy()\n    \n    def _check_container_constraints(self, circles):\n        \"\"\"Check if circles are within container bounds.\"\"\"\n        for circle in circles:\n            x, y, r = circle\n            if x - r < 0 or x + r > self.width:\n                return False\n            if y - r < 0 or y + r > self.height:\n                return False\n        return True\n    \n    def _check_overlap_constraints(self, circles, tolerance=1e-6):\n        \"\"\"Check if any circles overlap.\"\"\"\n        n = len(circles)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1, r1 = circles[i]\n                x2, y2, r2 = circles[j]\n                dist = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n                if dist < r1 + r2 - tolerance:\n                    return False\n        return True\n    \n    def _objective_function(self, state):\n        \"\"\"\n        Objective: Maximize total circle area (sum of radii squared).\n        Returns negative value for minimization.\n        \"\"\"\n        circles = state.reshape(-1, 3)\n        total_area = np.sum(circles[:, 2]**2)\n        return -total_area\n    \n    def _constraint_container(self, state):\n        \"\"\"\n        Constraint: All circles must be within container.\n        Returns array where all values >= 0 for feasibility.\n        \"\"\"\n        circles = state.reshape(-1, 3)\n        constraints = []\n        \n        for x, y, r in circles:\n            constraints.append(x - r)      # Left boundary\n            constraints.append(self.width - x - r)   # Right boundary\n            constraints.append(y - r)      # Bottom boundary\n            constraints.append(self.height - y - r)  # Top boundary\n        \n        return np.array(constraints)\n    \n    def _constraint_no_overlap(self, state):\n        \"\"\"\n        Constraint: No circles should overlap.\n        Returns array where all values >= 0 for feasibility.\n        \"\"\"\n        circles = state.reshape(-1, 3)\n        n = len(circles)\n        constraints = []\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1, r1 = circles[i]\n                x2, y2, r2 = circles[j]\n                dist = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n                # Distance should be >= sum of radii\n                constraints.append(dist - r1 - r2)\n        \n        return np.array(constraints)\n    \n    def run_packing(self, method='SLSQP', max_iterations=500, \n                   tolerance=1e-6, verbose=True):\n        \"\"\"\n        Run optimization to improve circle packing.\n        \n        Args:\n            method: Optimization method ('SLSQP', 'trust-constr', etc.)\n            max_iterations: Maximum optimization iterations\n            tolerance: Convergence tolerance\n            verbose: Print progress information\n            \n        Returns:\n            Optimization result object\n        \"\"\"\n        if len(self.circles) == 0:\n            self.construct_packing()\n        \n        initial_state = self._get_state_vector()\n        \n        # Define constraints\n        constraints = [\n            {'type': 'ineq', 'fun': self._constraint_container},\n            {'type': 'ineq', 'fun': self._constraint_no_overlap}\n        ]\n        \n        # Bounds: positions within container, radii > 0\n        bounds = []\n        for x, y, r in self.circles:\n            bounds.append((0.1, self.width - 0.1))    # x bounds\n            bounds.append((0.1, self.height - 0.1))   # y bounds\n            bounds.append((0.01, min(self.width, self.height) * 0.4))  # r bounds\n        \n        if verbose:\n            print(\"\\n\" + \"=\"*60)\n            print(\"OPTIMIZATION PHASE\")\n            print(\"=\"*60)\n            print(f\"Method: {method}\")\n            print(f\"Initial objective: {-self._objective_function(initial_state):.6f}\")\n            print(f\"Constraints: Container + No-overlap\")\n        \n        # Callback for tracking progress\n        iteration = [0]\n        \n        def callback(xk):\n            iteration[0] += 1\n            if iteration[0] % 50 == 0:\n                obj = -self._objective_function(xk)\n                self.optimization_history.append(obj)\n                if verbose:\n                    print(f\"  Iteration {iteration[0]}: Objective = {obj:.6f}\")\n        \n        # Run optimization\n        result = minimize(\n            self._objective_function,\n            initial_state,\n            method=method,\n            bounds=bounds,\n            constraints=constraints,\n            options={\n                'maxiter': max_iterations,\n                'ftol': tolerance,\n                'disp': verbose\n            },\n            callback=callback\n        )\n        \n        # Update circles with optimized state\n        self._set_state_vector(result.x)\n        \n        if verbose:\n            print(\"\\n\" + \"-\"*60)\n            print(\"OPTIMIZATION RESULTS\")\n            print(\"-\"*60)\n            print(f\"Success: {result.success}\")\n            print(f\"Message: {result.message}\")\n            print(f\"Iterations: {result.nit}\")\n            print(f\"Final objective: {-result.fun:.6f}\")\n            print(f\"Constraint satisfaction: {self._check_container_constraints(self.circles)}\")\n            print(f\"No overlaps: {self._check_overlap_constraints(self.circles)}\")\n        \n        return result\n    \n    def get_statistics(self):\n        \"\"\"Calculate and return packing statistics.\"\"\"\n        if len(self.circles) == 0:\n            return None\n        \n        radii = self.circles[:, 2]\n        total_area = np.sum(np.pi * radii**2)\n        container_area = self.width * self.height\n        packing_efficiency = (total_area / container_area) * 100\n        \n        stats = {\n            'num_circles': len(self.circles),\n            'total_circle_area': total_area,\n            'container_area': container_area,\n            'packing_efficiency': packing_efficiency,\n            'avg_radius': np.mean(radii),\n            'max_radius': np.max(radii),\n            'min_radius': np.min(radii),\n            'radius_std': np.std(radii),\n        }\n        \n        return stats\n    \n    def visualize(self, title=\"Circle Packing Optimization\", figsize=(14, 8)):\n        \"\"\"Visualize the circle packing result.\"\"\"\n        if len(self.circles) == 0:\n            print(\"No circles to visualize. Run construct_packing() first.\")\n            return\n        \n        fig, axes = plt.subplots(1, 2, figsize=figsize)\n        \n        # Left plot: Circle packing\n        ax1 = axes[0]\n        ax1.set_xlim(-0.5, self.width + 0.5)\n        ax1.set_ylim(-0.5, self.height + 0.5)\n        ax1.set_aspect('equal')\n        ax1.grid(True, alpha=0.3)\n        ax1.set_xlabel('X', fontsize=11)\n        ax1.set_ylabel('Y', fontsize=11)\n        \n        # Draw container\n        rect = plt.Rectangle((0, 0), self.width, self.height, \n                             fill=False, edgecolor='black', linewidth=2)\n        ax1.add_patch(rect)\n        \n        # Draw circles with color gradient based on radius\n        radii = self.circles[:, 2]\n        norm_radii = (radii - radii.min()) / (radii.max() - radii.min() + 1e-6)\n        \n        for i, (x, y, r) in enumerate(self.circles):\n            color = plt.cm.viridis(norm_radii[i])\n            circle = Circle((x, y), r, color=color, alpha=0.7, edgecolor='black', linewidth=1)\n            ax1.add_patch(circle)\n            ax1.text(x, y, str(i+1), ha='center', va='center', fontsize=8, fontweight='bold')\n        \n        ax1.set_title(f'{title}\\n({self.grid_shape[0]}x{self.grid_shape[1]} Grid)', \n                     fontsize=12, fontweight='bold')\n        \n        # Right plot: Optimization history\n        ax2 = axes[1]\n        if self.optimization_history:\n            ax2.plot(self.optimization_history, 'b-', linewidth=2, marker='o', markersize=4)\n            ax2.set_xlabel('Iteration (x50)', fontsize=11)\n            ax2.set_ylabel('Total Circle Area', fontsize=11)\n            ax2.set_title('Optimization Progress', fontsize=12, fontweight='bold')\n            ax2.grid(True, alpha=0.3)\n        else:\n            ax2.text(0.5, 0.5, 'No optimization history', \n                    ha='center', va='center', transform=ax2.transAxes)\n        \n        plt.tight_layout()\n        return fig\n    \n    def print_summary(self):\n        \"\"\"Print comprehensive summary of packing results.\"\"\"\n        stats = self.get_statistics()\n        \n        print(\"\\n\" + \"=\"*60)\n        print(\"CIRCLE PACKING SUMMARY\")\n        print(\"=\"*60)\n        print(f\"Container: {self.width} \u00d7 {self.height}\")\n        print(f\"Number of circles: {stats['num_circles']}\")\n        print(f\"\\nRadius Statistics:\")\n        print(f\"  Average: {stats['avg_radius']:.4f}\")\n        print(f\"  Maximum: {stats['max_radius']:.4f}\")\n        print(f\"  Minimum: {stats['min_radius']:.4f}\")\n        print(f\"  Std Dev: {stats['radius_std']:.4f}\")\n        print(f\"\\nArea Statistics:\")\n        print(f\"  Total circle area: {stats['total_circle_area']:.4f}\")\n        print(f\"  Container area: {stats['container_area']:.4f}\")\n        print(f\"  Packing efficiency: {stats['packing_efficiency']:.2f}%\")\n        print(\"=\"*60 + \"\\n\")\n\n\ndef main():\n    \"\"\"Main execution function.\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"CIRCLE PACKING ALGORITHM - 26 CIRCLES\")\n    print(\"=\"*60)\n    \n    # Create packing problem\n    packing = CirclePacking(width=10.0, height=12.0, num_circles=26, grid_shape=(5, 6))\n    \n    # Construct initial packing\n    print(\"\\nPHASE 1: GRID CONSTRUCTION\")\n    print(\"-\"*60)\n    packing.construct_packing()\n    \n    # Run optimization\n    print(\"\\nPHASE 2: OPTIMIZATION\")\n    print(\"-\"*60)\n    result = packing.run_packing(method='SLSQP', max_iterations=1000, verbose=True)\n    \n    # Print summary\n    packing.print_summary()\n    \n    # Visualize\n    print(\"Generating visualization...\")\n    fig = packing.visualize()\n    plt.show()\n    \n    return packing, result\n\n\nif __name__ == \"__main__\":\n    packing, result = main()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.362842321395874,
    "error": "ValueError: Code must define run_packing() or construct_packing()"
  },
  "prompt": "Write a circle packing algorithm for 26 circles using a rectangular grid with optimization. Place circles in a 5x6 or 6x5 grid (26 circles), then use optimization to adjust positions and radii while respecting constraints. Include construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize\nfrom matplotlib.patches import Circle\nimport warnings\nwarnings.filterwarnings('ignore')\n\nclass CirclePacking:\n    \"\"\"\n    Circle packing algorithm for 26 circles in a rectangular container.\n    Uses grid initialization followed by optimization.\n    \"\"\"\n    \n    def __init__(self, width=10.0, height=12.0, num_circles=26, grid_shape=(5, 6)):\n        \"\"\"\n        Initialize circle packing problem.\n        \n        Args:\n            width: Container width\n            height: Container height\n            num_circles: Number of circles to pack (should be 26)\n            grid_shape: Initial grid layout (rows, cols)\n        \"\"\"\n        self.width = width\n        self.height = height\n        self.num_circles = num_circles\n        self.grid_shape = grid_shape\n        \n        assert grid_shape[0] * grid_shape[1] >= num_circles, \\\n            f\"Grid {grid_shape} cannot fit {num_circles} circles\"\n        \n        self.circles = []  # List of [x, y, radius]\n        self.optimization_history = []\n        \n    def construct_packing(self):\n        \"\"\"\n        Construct initial circle packing using rectangular grid layout.\n        Distributes circles evenly across the container.\n        \"\"\"\n        rows, cols = self.grid_shape\n        \n        # Calculate initial spacing\n        cell_width = self.width / cols\n        cell_height = self.height / rows\n        \n        # Initial radius (fit within grid cells with padding)\n        padding = 0.05\n        initial_radius = min(cell_width, cell_height) * (0.5 - padding)\n        \n        self.circles = []\n        circle_idx = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if circle_idx >= self.num_circles:\n                    break\n                \n                # Center position in grid cell\n                x = (j + 0.5) * cell_width\n                y = (i + 0.5) * cell_height\n                \n                self.circles.append([x, y, initial_radius])\n                circle_idx += 1\n            \n            if circle_idx >= self.num_circles:\n                break\n        \n        self.circles = np.array(self.circles, dtype=np.float64)\n        print(f\"\u2713 Initial grid packing constructed: {len(self.circles)} circles\")\n        print(f\"  Grid: {self.grid_shape[0]}x{self.grid_shape[1]}\")\n        print(f\"  Initial radius: {initial_radius:.4f}\")\n        \n        return self.circles\n    \n    def _get_state_vector(self):\n        \"\"\"Convert circle data to optimization state vector.\"\"\"\n        return self.circles.flatten()\n    \n    def _set_state_vector(self, state):\n        \"\"\"Restore circle data from optimization state vector.\"\"\"\n        self.circles = state.reshape(-1, 3).copy()\n    \n    def _check_container_constraints(self, circles):\n        \"\"\"Check if circles are within container bounds.\"\"\"\n        for circle in circles:\n            x, y, r = circle\n            if x - r < 0 or x + r > self.width:\n                return False\n            if y - r < 0 or y + r > self.height:\n                return False\n        return True\n    \n    def _check_overlap_constraints(self, circles, tolerance=1e-6):\n        \"\"\"Check if any circles overlap.\"\"\"\n        n = len(circles)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1, r1 = circles[i]\n                x2, y2, r2 = circles[j]\n                dist = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n                if dist < r1 + r2 - tolerance:\n                    return False\n        return True\n    \n    def _objective_function(self, state):\n        \"\"\"\n        Objective: Maximize total circle area (sum of radii squared).\n        Returns negative value for minimization.\n        \"\"\"\n        circles = state.reshape(-1, 3)\n        total_area = np.sum(circles[:, 2]**2)\n        return -total_area\n    \n    def _constraint_container(self, state):\n        \"\"\"\n        Constraint: All circles must be within container.\n        Returns array where all values >= 0 for feasibility.\n        \"\"\"\n        circles = state.reshape(-1, 3)\n        constraints = []\n        \n        for x, y, r in circles:\n            constraints.append(x - r)      # Left boundary\n            constraints.append(self.width - x - r)   # Right boundary\n            constraints.append(y - r)      # Bottom boundary\n            constraints.append(self.height - y - r)  # Top boundary\n        \n        return np.array(constraints)\n    \n    def _constraint_no_overlap(self, state):\n        \"\"\"\n        Constraint: No circles should overlap.\n        Returns array where all values >= 0 for feasibility.\n        \"\"\"\n        circles = state.reshape(-1, 3)\n        n = len(circles)\n        constraints = []\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1, r1 = circles[i]\n                x2, y2, r2 = circles[j]\n                dist = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n                # Distance should be >= sum of radii\n                constraints.append(dist - r1 - r2)\n        \n        return np.array(constraints)\n    \n    def run_packing(self, method='SLSQP', max_iterations=500, \n                   tolerance=1e-6, verbose=True):\n        \"\"\"\n        Run optimization to improve circle packing.\n        \n        Args:\n            method: Optimization method ('SLSQP', 'trust-constr', etc.)\n            max_iterations: Maximum optimization iterations\n            tolerance: Convergence tolerance\n            verbose: Print progress information\n            \n        Returns:\n            Optimization result object\n        \"\"\"\n        if len(self.circles) == 0:\n            self.construct_packing()\n        \n        initial_state = self._get_state_vector()\n        \n        # Define constraints\n        constraints = [\n            {'type': 'ineq', 'fun': self._constraint_container},\n            {'type': 'ineq', 'fun': self._constraint_no_overlap}\n        ]\n        \n        # Bounds: positions within container, radii > 0\n        bounds = []\n        for x, y, r in self.circles:\n            bounds.append((0.1, self.width - 0.1))    # x bounds\n            bounds.append((0.1, self.height - 0.1))   # y bounds\n            bounds.append((0.01, min(self.width, self.height) * 0.4))  # r bounds\n        \n        if verbose:\n            print(\"\\n\" + \"=\"*60)\n            print(\"OPTIMIZATION PHASE\")\n            print(\"=\"*60)\n            print(f\"Method: {method}\")\n            print(f\"Initial objective: {-self._objective_function(initial_state):.6f}\")\n            print(f\"Constraints: Container + No-overlap\")\n        \n        # Callback for tracking progress\n        iteration = [0]\n        \n        def callback(xk):\n            iteration[0] += 1\n            if iteration[0] % 50 == 0:\n                obj = -self._objective_function(xk)\n                self.optimization_history.append(obj)\n                if verbose:\n                    print(f\"  Iteration {iteration[0]}: Objective = {obj:.6f}\")\n        \n        # Run optimization\n        result = minimize(\n            self._objective_function,\n            initial_state,\n            method=method,\n            bounds=bounds,\n            constraints=constraints,\n            options={\n                'maxiter': max_iterations,\n                'ftol': tolerance,\n                'disp': verbose\n            },\n            callback=callback\n        )\n        \n        # Update circles with optimized state\n        self._set_state_vector(result.x)\n        \n        if verbose:\n            print(\"\\n\" + \"-\"*60)\n            print(\"OPTIMIZATION RESULTS\")\n            print(\"-\"*60)\n            print(f\"Success: {result.success}\")\n            print(f\"Message: {result.message}\")\n            print(f\"Iterations: {result.nit}\")\n            print(f\"Final objective: {-result.fun:.6f}\")\n            print(f\"Constraint satisfaction: {self._check_container_constraints(self.circles)}\")\n            print(f\"No overlaps: {self._check_overlap_constraints(self.circles)}\")\n        \n        return result\n    \n    def get_statistics(self):\n        \"\"\"Calculate and return packing statistics.\"\"\"\n        if len(self.circles) == 0:\n            return None\n        \n        radii = self.circles[:, 2]\n        total_area = np.sum(np.pi * radii**2)\n        container_area = self.width * self.height\n        packing_efficiency = (total_area / container_area) * 100\n        \n        stats = {\n            'num_circles': len(self.circles),\n            'total_circle_area': total_area,\n            'container_area': container_area,\n            'packing_efficiency': packing_efficiency,\n            'avg_radius': np.mean(radii),\n            'max_radius': np.max(radii),\n            'min_radius': np.min(radii),\n            'radius_std': np.std(radii),\n        }\n        \n        return stats\n    \n    def visualize(self, title=\"Circle Packing Optimization\", figsize=(14, 8)):\n        \"\"\"Visualize the circle packing result.\"\"\"\n        if len(self.circles) == 0:\n            print(\"No circles to visualize. Run construct_packing() first.\")\n            return\n        \n        fig, axes = plt.subplots(1, 2, figsize=figsize)\n        \n        # Left plot: Circle packing\n        ax1 = axes[0]\n        ax1.set_xlim(-0.5, self.width + 0.5)\n        ax1.set_ylim(-0.5, self.height + 0.5)\n        ax1.set_aspect('equal')\n        ax1.grid(True, alpha=0.3)\n        ax1.set_xlabel('X', fontsize=11)\n        ax1.set_ylabel('Y', fontsize=11)\n        \n        # Draw container\n        rect = plt.Rectangle((0, 0), self.width, self.height, \n                             fill=False, edgecolor='black', linewidth=2)\n        ax1.add_patch(rect)\n        \n        # Draw circles with color gradient based on radius\n        radii = self.circles[:, 2]\n        norm_radii = (radii - radii.min()) / (radii.max() - radii.min() + 1e-6)\n        \n        for i, (x, y, r) in enumerate(self.circles):\n            color = plt.cm.viridis(norm_radii[i])\n            circle = Circle((x, y), r, color=color, alpha=0.7, edgecolor='black', linewidth=1)\n            ax1.add_patch(circle)\n            ax1.text(x, y, str(i+1), ha='center', va='center', fontsize=8, fontweight='bold')\n        \n        ax1.set_title(f'{title}\\n({self.grid_shape[0]}x{self.grid_shape[1]} Grid)', \n                     fontsize=12, fontweight='bold')\n        \n        # Right plot: Optimization history\n        ax2 = axes[1]\n        if self.optimization_history:\n            ax2.plot(self.optimization_history, 'b-', linewidth=2, marker='o', markersize=4)\n            ax2.set_xlabel('Iteration (x50)', fontsize=11)\n            ax2.set_ylabel('Total Circle Area', fontsize=11)\n            ax2.set_title('Optimization Progress', fontsize=12, fontweight='bold')\n            ax2.grid(True, alpha=0.3)\n        else:\n            ax2.text(0.5, 0.5, 'No optimization history', \n                    ha='center', va='center', transform=ax2.transAxes)\n        \n        plt.tight_layout()\n        return fig\n    \n    def print_summary(self):\n        \"\"\"Print comprehensive summary of packing results.\"\"\"\n        stats = self.get_statistics()\n        \n        print(\"\\n\" + \"=\"*60)\n        print(\"CIRCLE PACKING SUMMARY\")\n        print(\"=\"*60)\n        print(f\"Container: {self.width} \u00d7 {self.height}\")\n        print(f\"Number of circles: {stats['num_circles']}\")\n        print(f\"\\nRadius Statistics:\")\n        print(f\"  Average: {stats['avg_radius']:.4f}\")\n        print(f\"  Maximum: {stats['max_radius']:.4f}\")\n        print(f\"  Minimum: {stats['min_radius']:.4f}\")\n        print(f\"  Std Dev: {stats['radius_std']:.4f}\")\n        print(f\"\\nArea Statistics:\")\n        print(f\"  Total circle area: {stats['total_circle_area']:.4f}\")\n        print(f\"  Container area: {stats['container_area']:.4f}\")\n        print(f\"  Packing efficiency: {stats['packing_efficiency']:.2f}%\")\n        print(\"=\"*60 + \"\\n\")\n\n\ndef main():\n    \"\"\"Main execution function.\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"CIRCLE PACKING ALGORITHM - 26 CIRCLES\")\n    print(\"=\"*60)\n    \n    # Create packing problem\n    packing = CirclePacking(width=10.0, height=12.0, num_circles=26, grid_shape=(5, 6))\n    \n    # Construct initial packing\n    print(\"\\nPHASE 1: GRID CONSTRUCTION\")\n    print(\"-\"*60)\n    packing.construct_packing()\n    \n    # Run optimization\n    print(\"\\nPHASE 2: OPTIMIZATION\")\n    print(\"-\"*60)\n    result = packing.run_packing(method='SLSQP', max_iterations=1000, verbose=True)\n    \n    # Print summary\n    packing.print_summary()\n    \n    # Visualize\n    print(\"Generating visualization...\")\n    fig = packing.visualize()\n    plt.show()\n    \n    return packing, result\n\n\nif __name__ == \"__main__\":\n    packing, result = main()\n```\n\n## Usage Example\n\n```python\n# Basic usage\npacking = CirclePacking(width=10.0, height=12.0, num_circles=26, grid_shape=(5, 6))\npacking.construct_packing()\npacking.run_packing(method='SLSQP', max_iterations=1000)\npacking.visualize()\npacking.print_summary()\n\n# Advanced: Different grid layout (6x5 instead of 5x6)\npacking2 = CirclePacking(width=12.0, height=10.0, num_circles=26, grid_shape=(6, 5))\npacking2.construct_packing()\npacking2.run_packing(method='SLSQP', max_iterations=1500)\npacking2.print_summary()\n```\n\n## Key Features\n\n1. **Grid Initialization** (`construct_packing`):\n   - Distributes 26 circles in 5\u00d76 or 6\u00d75 grid\n   - Equal spacing with padding\n   - Uniform initial radii\n\n2. **Optimization** (`run_packing`):\n   - Maximizes total circle area\n   - Respects container boundaries\n   - Prevents circle overlaps\n   - Uses SLSQP or trust-constr methods\n\n3. **Constraints**:\n   - All circles within container\n   - No circle-circle overlaps\n   - Radii positive and bounded\n\n4. **Visualization**:\n   - Circle packing layout with color gradient\n   - Optimization convergence history\n   - Circle numbering\n\n5. **Statistics**:\n   - Packing efficiency\n   - Radius distribution",
  "reasoning": "## Usage Example\n\n## Key Features\n\n1. **Grid Initialization** (`construct_packing`):\n   - Distributes 26 circles in 5\u00d76 or 6\u00d75 grid\n   - Equal spacing with padding\n   - Uniform initial radii\n\n2. **Optimization** (`run_packing`):\n   - Maximizes total circle area\n   - Respects container boundaries\n   - Prevents circle overlaps\n   - Uses SLSQP or trust-constr methods\n\n3. **Constraints**:\n   - All circles within container\n   - No circle-circle overlaps\n   - Radii positive and bounded\n\n4. **Visualization**:\n   - Circle packing layout with color gradient\n   - Optimization convergence history\n   - Circle numbering\n\n5. **Statistics**:\n   - Packing efficiency\n   - Radius distribution",
  "timestamp": "2025-12-08T12:15:35.378194",
  "cost_data": null
}