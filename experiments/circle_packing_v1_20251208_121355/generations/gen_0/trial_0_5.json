{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a circle packing algorithm for 26 circles using a concentric ring pattern. Place circles in concentric rings around the center of the square, adjusting the number of circles per ring and their radii to maximize the sum. Include construct_packing() and run_packing() functions.",
  "response": "```python\nimport math\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with its position and radius\"\"\"\n    x: float\n    y: float\n    radius: float\n    ring: int\n    position_in_ring: int\n    \n    def __repr__(self):\n        return f\"Circle(x={self.x:.2f}, y={self.y:.2f}, r={self.radius:.2f})\"\n\nclass ConcentricRingPacking:\n    \"\"\"\n    Circle packing algorithm using concentric rings pattern.\n    Packs 26 circles in a square container.\n    \"\"\"\n    \n    def __init__(self, container_size: float = 100.0):\n        \"\"\"\n        Initialize the packing algorithm.\n        \n        Args:\n            container_size: Size of the square container\n        \"\"\"\n        self.container_size = container_size\n        self.center = container_size / 2\n        self.circles: List[Circle] = []\n        self.total_area = 0.0\n        \n    def calculate_ring_parameters(self, num_circles: int) -> List[Tuple[int, float]]:\n        \"\"\"\n        Calculate the number of circles and radius for each ring.\n        \n        Args:\n            num_circles: Total number of circles to pack\n            \n        Returns:\n            List of tuples (circles_in_ring, ring_radius)\n        \"\"\"\n        # Strategy: Create rings with increasing number of circles\n        # Ring 1: 1 circle (center)\n        # Ring 2: 6 circles\n        # Ring 3: 12 circles\n        # Ring 4: 7 circles (remaining)\n        \n        rings = []\n        remaining = num_circles\n        ring_num = 1\n        \n        # Ring 1: Center circle\n        circles_in_ring = 1\n        rings.append((circles_in_ring, ring_num))\n        remaining -= circles_in_ring\n        ring_num += 1\n        \n        # Subsequent rings: approximately 6*ring_number circles\n        while remaining > 0:\n            circles_in_ring = min(6 * ring_num, remaining)\n            rings.append((circles_in_ring, ring_num))\n            remaining -= circles_in_ring\n            ring_num += 1\n        \n        return rings\n    \n    def calculate_radii(self, ring_config: List[Tuple[int, float]]) -> List[float]:\n        \"\"\"\n        Calculate optimal radius for each ring to maximize packing.\n        \n        Args:\n            ring_config: List of (circles_in_ring, ring_number) tuples\n            \n        Returns:\n            List of radii for each ring\n        \"\"\"\n        radii = []\n        max_radius = self.container_size / 2 - 1  # Safety margin\n        \n        for circles_in_ring, ring_num in ring_config:\n            if ring_num == 1:\n                # Center circle: relatively large\n                radius = max_radius * 0.15\n            else:\n                # Calculate radius based on ring number and number of circles\n                # Ensure circles don't overlap and fit in container\n                \n                # Distance from center to ring\n                ring_distance = max_radius * (ring_num / len(ring_config))\n                \n                # Angle between circles in this ring\n                angle_between = 2 * math.pi / circles_in_ring\n                \n                # Maximum radius for circle in this ring (chord constraint)\n                # Using: r_max = ring_distance * sin(angle_between / 2)\n                max_r_in_ring = ring_distance * math.sin(angle_between / 2) * 0.9\n                \n                # Also constrain by distance from center\n                max_r_by_distance = (max_radius - ring_distance) * 0.8\n                \n                radius = min(max_r_in_ring, max_r_by_distance, max_radius / (ring_num + 1))\n            \n            radii.append(radius)\n        \n        return radii\n    \n    def construct_packing(self) -> List[Circle]:\n        \"\"\"\n        Construct the circle packing using concentric rings.\n        \n        Returns:\n            List of Circle objects\n        \"\"\"\n        self.circles = []\n        self.total_area = 0.0\n        \n        # Get ring configuration\n        ring_config = self.calculate_ring_parameters(26)\n        radii = self.calculate_radii(ring_config)\n        \n        print(f\"Ring Configuration:\")\n        print(f\"{'Ring':<6} {'Circles':<10} {'Radius':<10}\")\n        print(\"-\" * 26)\n        \n        for ring_idx, ((circles_in_ring, ring_num), radius) in enumerate(\n            zip(ring_config, radii)\n        ):\n            print(f\"{ring_num:<6} {circles_in_ring:<10} {radius:<10.2f}\")\n            \n            if circles_in_ring == 1:\n                # Center circle\n                circle = Circle(\n                    x=self.center,\n                    y=self.center,\n                    radius=radius,\n                    ring=ring_num,\n                    position_in_ring=0\n                )\n                self.circles.append(circle)\n                self.total_area += math.pi * radius ** 2\n            else:\n                # Circles arranged in a ring\n                ring_distance = (self.container_size / 2 - radius - 2)\n                \n                # Adjust ring distance based on ring number\n                ring_distance = (self.container_size / 2) * (ring_num / len(ring_config))\n                \n                for pos in range(circles_in_ring):\n                    angle = (2 * math.pi * pos) / circles_in_ring\n                    \n                    x = self.center + ring_distance * math.cos(angle)\n                    y = self.center + ring_distance * math.sin(angle)\n                    \n                    # Clamp to container bounds\n                    x = max(radius, min(self.container_size - radius, x))\n                    y = max(radius, min(self.container_size - radius, y))\n                    \n                    circle = Circle(\n                        x=x,\n                        y=y,\n                        radius=radius,\n                        ring=ring_num,\n                        position_in_ring=pos\n                    )\n                    self.circles.append(circle)\n                    self.total_area += math.pi * radius ** 2\n        \n        return self.circles\n    \n    def check_overlaps(self) -> List[Tuple[int, int, float]]:\n        \"\"\"\n        Check for overlapping circles.\n        \n        Returns:\n            List of (circle_i, circle_j, overlap_distance) tuples\n        \"\"\"\n        overlaps = []\n        \n        for i in range(len(self.circles)):\n            for j in range(i + 1, len(self.circles)):\n                c1, c2 = self.circles[i], self.circles[j]\n                \n                distance = math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2)\n                min_distance = c1.radius + c2.radius\n                \n                if distance < min_distance:\n                    overlap = min_distance - distance\n                    overlaps.append((i, j, overlap))\n        \n        return overlaps\n    \n    def check_container_bounds(self) -> List[Tuple[int, float]]:\n        \"\"\"\n        Check which circles exceed container bounds.\n        \n        Returns:\n            List of (circle_index, excess_distance) tuples\n        \"\"\"\n        violations = []\n        \n        for i, circle in enumerate(self.circles):\n            # Check all four boundaries\n            left_excess = max(0, circle.radius - circle.x)\n            right_excess = max(0, circle.x + circle.radius - self.container_size)\n            top_excess = max(0, circle.radius - circle.y)\n            bottom_excess = max(0, circle.y + circle.radius - self.container_size)\n            \n            max_excess = max(left_excess, right_excess, top_excess, bottom_excess)\n            \n            if max_excess > 0:\n                violations.append((i, max_excess))\n        \n        return violations\n    \n    def get_packing_efficiency(self) -> float:\n        \"\"\"\n        Calculate packing efficiency as ratio of circle area to container area.\n        \n        Returns:\n            Packing efficiency (0 to 1)\n        \"\"\"\n        container_area = self.container_size ** 2\n        return self.total_area / container_area\n    \n    def get_statistics(self) -> dict:\n        \"\"\"\n        Get detailed statistics about the packing.\n        \n        Returns:\n            Dictionary with packing statistics\n        \"\"\"\n        overlaps = self.check_overlaps()\n        bound_violations = self.check_container_bounds()\n        \n        radii = [c.radius for c in self.circles]\n        \n        stats = {\n            'total_circles': len(self.circles),\n            'total_area': self.total_area,\n            'container_area': self.container_size ** 2,\n            'packing_efficiency': self.get_packing_efficiency(),\n            'num_overlaps': len(overlaps),\n            'num_bound_violations': len(bound_violations),\n            'avg_radius': np.mean(radii),\n            'min_radius': np.min(radii),\n            'max_radius': np.max(radii),\n            'std_radius': np.std(radii),\n        }\n        \n        return stats\n\ndef construct_packing(container_size: float = 100.0) -> Tuple[ConcentricRingPacking, List[Circle]]:\n    \"\"\"\n    Construct a concentric ring circle packing.\n    \n    Args:\n        container_size: Size of the square container\n        \n    Returns:\n        Tuple of (packing_object, circles_list)\n    \"\"\"\n    packing = ConcentricRingPacking(container_size)\n    circles = packing.construct_packing()\n    return packing, circles\n\ndef run_packing(container_size: float = 100.0, verbose: bool = True) -> dict:\n    \"\"\"\n    Run the complete circle packing algorithm and return results.\n    \n    Args:\n        container_size: Size of the square container\n        verbose: Whether to print detailed output\n        \n    Returns:\n        Dictionary with packing results and statistics\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"CONCENTRIC RING CIRCLE PACKING ALGORITHM\")\n    print(\"=\" * 60)\n    print(f\"\\nContainer Size: {container_size} x {container_size}\")\n    print(f\"Target Circles: 26\\n\")\n    \n    # Construct packing\n    packing, circles = construct_packing(container_size)\n    \n    # Get statistics\n    stats = packing.get_statistics()\n    \n    if verbose:\n        print(\"\\n\" + \"=\" * 60)\n        print(\"PACKING STATISTICS\")\n        print(\"=\" * 60)\n        print(f\"Total Circles: {stats['total_circles']}\")\n        print(f\"Total Circle Area: {stats['total_area']:.2f}\")\n        print(f\"Container Area: {stats['container_area']:.2f}\")\n        print(f\"Packing Efficiency: {stats['packing_efficiency']:.2%}\")\n        print(f\"\\nRadius Statistics:\")\n        print(f\"  Average: {stats['avg_radius']:.2f}\")\n        print(f\"  Minimum: {stats['min_radius']:.2f}\")\n        print(f\"  Maximum: {stats['max_radius']:.2f}\")\n        print(f\"  Std Dev: {stats['std_radius']:.2f}\")\n        \n        # Check for overlaps\n        overlaps = packing.check_overlaps()\n        print(f\"\\nOverlap Check:\")\n        print(f\"  Number of overlaps: {len(overlaps)}\")\n        if overlaps and len(overlaps) <= 5:\n            for i, j, overlap in overlaps:\n                print(f\"    Circles {i} and {j}: {overlap:.4f} units\")\n        \n        # Check bounds\n        violations = packing.check_container_bounds()\n        print(f\"\\nBounds Check:\")\n        print(f\"  Number of violations: {len(violations)}\")\n        if violations and len(violations) <= 5:\n            for i, excess in violations:\n                print(f\"    Circle {i}: {excess:.4f} units out of bounds\")\n        \n        # Print circle details\n        print(f\"\\n\" + \"=\" * 60)\n        print(\"CIRCLE DETAILS\")\n        print(\"=\" * 60)\n        print(f\"{'ID':<4} {'Ring':<6} {'Pos':<5} {'X':<8} {'Y':<8} {'Radius':<8}\")\n        print(\"-\" * 40)\n        for i, circle in enumerate(circles):\n            print(f\"{i:<4} {circle.ring:<6} {circle.position_in_ring:<5} \"\n                  f\"{circle.x:<8.2f} {circle.y:<8.2f} {circle.radius:<8.2f}\")\n    \n    return {\n        'packing': packing,\n        'circles': circles,\n        'statistics': stats,\n        'overlaps': packing.check_overlaps(),\n        'bound_violations': packing.check_container_bounds()\n    }\n\ndef visualize_packing(packing: ConcentricRingPacking, filename: str = \"circle_packing.png\"):\n    \"\"\"\n    Visualize the circle packing (requires matplotlib).\n    \n    Args:\n        packing: ConcentricRingPacking object\n        filename: Output filename for the visualization\n    \"\"\"\n    try:\n        import matplotlib.pyplot as plt\n        import matplotlib.patches as patches\n    except ImportError:\n        print(\"Matplotlib not available. Skipping visualization.\")\n        return\n    \n    fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n    \n    # Draw container\n    container = patches.Rectangle(\n        (0, 0), packing.container_size, packing.container_size,\n        linewidth=2, edgecolor='black', facecolor='white'\n    )\n    ax.add_patch(container)\n    \n    # Color map for rings\n    colors = plt.cm.tab20(np.linspace(0, 1, 10))\n    \n    # Draw circles\n    for i, circle in enumerate(packing.circles):\n        color_idx = (circle.ring - 1) % len(colors)\n        circle_patch = patches.Circle(\n            (circle.x, circle.y), circle.radius,\n            linewidth=1.5, edgecolor='black',\n            facecolor=colors[color_idx], alpha=0.7\n        )\n        ax.add_patch(circle_patch)\n        \n        # Add circle label\n        ax.text(circle.x, circle.y, str(i), ha='center', va='center',\n                fontsize=8, fontweight='bold')\n    \n    # Draw center point\n    ax.plot(packing.center, packing.center, 'r+', markersize=10, markeredgewidth=2)\n    \n    ax.set_xlim(-5, packing.container_size + 5)\n    ax.set_ylim(-5, packing.container_size + 5)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_title(f'Concentric Ring Circle Packing\\n'\n                 f'Efficiency: {packing.get_packing_efficiency():.2%}')\n    \n    plt.tight_layout()\n    plt.savefig(filename, dpi=150, bbox_inches='tight')\n    print(f\"\\nVisualization saved to: {filename}\")\n    plt.close()\n\nif __name__ == \"__main__\":\n    # Run the packing algorithm\n    results = run_packing(container_size=100.0, verbose=True)\n    \n    # Visualize the result\n    visualize_packing(results['packing'])\n    \n    # Additional analysis\n    print(\"\\n\" + \"=\" * 60)\n    print(\"SUMMARY\")\n    print(\"=\" * 60)\n    stats = results['statistics",
  "reasoning": "```python\nimport math\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\n\n@dataclass\nclass Circle:\n    \"\"\"Represents a circle with its position and radius\"\"\"\n    x: float\n    y: float\n    radius: float\n    ring: int\n    position_in_ring: int\n    \n    def __repr__(self):\n        return f\"Circle(x={self.x:.2f}, y={self.y:.2f}, r={self.radius:.2f})\"\n\nclass ConcentricRingPacking:\n    \"\"\"\n    Circle packing algorithm using concentric rings pattern.\n    Packs 26 circles in a square container.\n    \"\"\"\n    \n    def __init__(self, container_size: float = 100.0):\n        \"\"\"\n        Initialize the packing algorithm.\n        \n        Args:\n            container_size: Size of the square container\n        \"\"\"\n        self.container_size = container_size\n        self.center = container_size / 2\n        self.circles: List[Circle] = []\n        self.total_area = 0.0\n        \n    def calculate_ring_parameters(self, num_circles: int) -> List[Tuple[int, float]]:\n        \"\"\"\n        Calculate the number of circles and radius for each ring.\n        \n        Args:\n            num_circles: Total number of circles to pack\n            \n        Returns:\n            List of tuples (circles_in_ring, ring_radius)\n        \"\"\"\n        # Strategy: Create rings with increasing number of circles\n        # Ring 1: 1 circle (center)\n        # Ring 2: 6 circles\n        # Ring 3: 12 circles\n        # Ring 4: 7 circles (remaining)\n        \n        rings = []\n        remaining = num_circles\n        ring_num = 1\n        \n        # Ring 1: Center circle\n        circles_in_ring = 1\n        rings.append((circles_in_ring, ring_num))\n        remaining -= circles_in_ring\n        ring_num += 1\n        \n        # Subsequent rings: approximately 6*ring_number circles\n        while remaining > 0:\n            circles_in_ring = min(6 * ring_num, remaining)\n            rings.append((circles_in_ring, ring_num))\n            remaining -= circles_in_ring\n            ring_num += 1\n        \n        return rings\n    \n    def calculate_radii(self, ring_config: List[Tuple[int, float]]) -> List[float]:\n        \"\"\"\n        Calculate optimal radius for each ring to maximize packing.\n        \n        Args:\n            ring_config: List of (circles_in_ring, ring_number) tuples\n            \n        Returns:\n            List of radii for each ring\n        \"\"\"\n        radii = []\n        max_radius = self.container_size / 2 - 1  # Safety margin\n        \n        for circles_in_ring, ring_num in ring_config:\n            if ring_num == 1:\n                # Center circle: relatively large\n                radius = max_radius * 0.15\n            else:\n                # Calculate radius based on ring number and number of circles\n                # Ensure circles don't overlap and fit in container\n                \n                # Distance from center to ring\n                ring_distance = max_radius * (ring_num / len(ring_config))\n                \n                # Angle between circles in this ring\n                angle_between = 2 * math.pi / circles_in_ring\n                \n                # Maximum radius for circle in this ring (chord constraint)\n                # Using: r_max = ring_distance * sin(angle_between / 2)\n                max_r_in_ring = ring_distance * math.sin(angle_between / 2) * 0.9\n                \n                # Also constrain by distance from center\n                max_r_by_distance = (max_radius - ring_distance) * 0.8\n                \n                radius = min(max_r_in_ring, max_r_by_distance, max_radius / (ring_num + 1))\n            \n            radii.append(radius)\n        \n        return radii\n    \n    def construct_packing(self) -> List[Circle]:\n        \"\"\"\n        Construct the circle packing using concentric rings.\n        \n        Returns:\n            List of Circle objects\n        \"\"\"\n        self.circles = []\n        self.total_area = 0.0\n        \n        # Get ring configuration\n        ring_config = self.calculate_ring_parameters(26)\n        radii = self.calculate_radii(ring_config)\n        \n        print(f\"Ring Configuration:\")\n        print(f\"{'Ring':<6} {'Circles':<10} {'Radius':<10}\")\n        print(\"-\" * 26)\n        \n        for ring_idx, ((circles_in_ring, ring_num), radius) in enumerate(\n            zip(ring_config, radii)\n        ):\n            print(f\"{ring_num:<6} {circles_in_ring:<10} {radius:<10.2f}\")\n            \n            if circles_in_ring == 1:\n                # Center circle\n                circle = Circle(\n                    x=self.center,\n                    y=self.center,\n                    radius=radius,\n                    ring=ring_num,\n                    position_in_ring=0\n                )\n                self.circles.append(circle)\n                self.total_area += math.pi * radius ** 2\n            else:\n                # Circles arranged in a ring\n                ring_distance = (self.container_size / 2 - radius - 2)\n                \n                # Adjust ring distance based on ring number\n                ring_distance = (self.container_size / 2) * (ring_num / len(ring_config))\n                \n                for pos in range(circles_in_ring):\n                    angle = (2 * math.pi * pos) / circles_in_ring\n                    \n                    x = self.center + ring_distance * math.cos(angle)\n                    y = self.center + ring_distance * math.sin(angle)\n                    \n                    # Clamp to container bounds\n                    x = max(radius, min(self.container_size - radius, x))\n                    y = max(radius, min(self.container_size - radius, y))\n                    \n                    circle = Circle(\n                        x=x,\n                        y=y,\n                        radius=radius,\n                        ring=ring_num,\n                        position_in_ring=pos\n                    )\n                    self.circles.append(circle)\n                    self.total_area += math.pi * radius ** 2\n        \n        return self.circles\n    \n    def check_overlaps(self) -> List[Tuple[int, int, float]]:\n        \"\"\"\n        Check for overlapping circles.\n        \n        Returns:\n            List of (circle_i, circle_j, overlap_distance) tuples\n        \"\"\"\n        overlaps = []\n        \n        for i in range(len(self.circles)):\n            for j in range(i + 1, len(self.circles)):\n                c1, c2 = self.circles[i], self.circles[j]\n                \n                distance = math.sqrt((c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2)\n                min_distance = c1.radius + c2.radius\n                \n                if distance < min_distance:\n                    overlap = min_distance - distance\n                    overlaps.append((i, j, overlap))\n        \n        return overlaps\n    \n    def check_container_bounds(self) -> List[Tuple[int, float]]:\n        \"\"\"\n        Check which circles exceed container bounds.\n        \n        Returns:\n            List of (circle_index, excess_distance) tuples\n        \"\"\"\n        violations = []\n        \n        for i, circle in enumerate(self.circles):\n            # Check all four boundaries\n            left_excess = max(0, circle.radius - circle.x)\n            right_excess = max(0, circle.x + circle.radius - self.container_size)\n            top_excess = max(0, circle.radius - circle.y)\n            bottom_excess = max(0, circle.y + circle.radius - self.container_size)\n            \n            max_excess = max(left_excess, right_excess, top_excess, bottom_excess)\n            \n            if max_excess > 0:\n                violations.append((i, max_excess))\n        \n        return violations\n    \n    def get_packing_efficiency(self) -> float:\n        \"\"\"\n        Calculate packing efficiency as ratio of circle area to container area.\n        \n        Returns:\n            Packing efficiency (0 to 1)\n        \"\"\"\n        container_area = self.container_size ** 2\n        return self.total_area / container_area\n    \n    def get_statistics(self) -> dict:\n        \"\"\"\n        Get detailed statistics about the packing.\n        \n        Returns:\n            Dictionary with packing statistics\n        \"\"\"\n        overlaps = self.check_overlaps()\n        bound_violations = self.check_container_bounds()\n        \n        radii = [c.radius for c in self.circles]\n        \n        stats = {\n            'total_circles': len(self.circles),\n            'total_area': self.total_area,\n            'container_area': self.container_size ** 2,\n            'packing_efficiency': self.get_packing_efficiency(),\n            'num_overlaps': len(overlaps),\n            'num_bound_violations': len(bound_violations),\n            'avg_radius': np.mean(radii),\n            'min_radius': np.min(radii),\n            'max_radius': np.max(radii),\n            'std_radius': np.std(radii),\n        }\n        \n        return stats\n\ndef construct_packing(container_size: float = 100.0) -> Tuple[ConcentricRingPacking, List[Circle]]:\n    \"\"\"\n    Construct a concentric ring circle packing.\n    \n    Args:\n        container_size: Size of the square container\n        \n    Returns:\n        Tuple of (packing_object, circles_list)\n    \"\"\"\n    packing = ConcentricRingPacking(container_size)\n    circles = packing.construct_packing()\n    return packing, circles\n\ndef run_packing(container_size: float = 100.0, verbose: bool = True) -> dict:\n    \"\"\"\n    Run the complete circle packing algorithm and return results.\n    \n    Args:\n        container_size: Size of the square container\n        verbose: Whether to print detailed output\n        \n    Returns:\n        Dictionary with packing results and statistics\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"CONCENTRIC RING CIRCLE PACKING ALGORITHM\")\n    print(\"=\" * 60)\n    print(f\"\\nContainer Size: {container_size} x {container_size}\")\n    print(f\"Target Circles: 26\\n\")\n    \n    # Construct packing\n    packing, circles = construct_packing(container_size)\n    \n    # Get statistics\n    stats = packing.get_statistics()\n    \n    if verbose:\n        print(\"\\n\" + \"=\" * 60)\n        print(\"PACKING STATISTICS\")\n        print(\"=\" * 60)\n        print(f\"Total Circles: {stats['total_circles']}\")\n        print(f\"Total Circle Area: {stats['total_area']:.2f}\")\n        print(f\"Container Area: {stats['container_area']:.2f}\")\n        print(f\"Packing Efficiency: {stats['packing_efficiency']:.2%}\")\n        print(f\"\\nRadius Statistics:\")\n        print(f\"  Average: {stats['avg_radius']:.2f}\")\n        print(f\"  Minimum: {stats['min_radius']:.2f}\")\n        print(f\"  Maximum: {stats['max_radius']:.2f}\")\n        print(f\"  Std Dev: {stats['std_radius']:.2f}\")\n        \n        # Check for overlaps\n        overlaps = packing.check_overlaps()\n        print(f\"\\nOverlap Check:\")\n        print(f\"  Number of overlaps: {len(overlaps)}\")\n        if overlaps and len(overlaps) <= 5:\n            for i, j, overlap in overlaps:\n                print(f\"    Circles {i} and {j}: {overlap:.4f} units\")\n        \n        # Check bounds\n        violations = packing.check_container_bounds()\n        print(f\"\\nBounds Check:\")\n        print(f\"  Number of violations: {len(violations)}\")\n        if violations and len(violations) <= 5:\n            for i, excess in violations:\n                print(f\"    Circle {i}: {excess:.4f} units out of bounds\")\n        \n        # Print circle details\n        print(f\"\\n\" + \"=\" * 60)\n        print(\"CIRCLE DETAILS\")\n        print(\"=\" * 60)\n        print(f\"{'ID':<4} {'Ring':<6} {'Pos':<5} {'X':<8} {'Y':<8} {'Radius':<8}\")\n        print(\"-\" * 40)\n        for i, circle in enumerate(circles):\n            print(f\"{i:<4} {circle.ring:<6} {circle.position_in_ring:<5} \"\n                  f\"{circle.x:<8.2f} {circle.y:<8.2f} {circle.radius:<8.2f}\")\n    \n    return {\n        'packing': packing,\n        'circles': circles,\n        'statistics': stats,\n        'overlaps': packing.check_overlaps(),\n        'bound_violations': packing.check_container_bounds()\n    }\n\ndef visualize_packing(packing: ConcentricRingPacking, filename: str = \"circle_packing.png\"):\n    \"\"\"\n    Visualize the circle packing (requires matplotlib).\n    \n    Args:\n        packing: ConcentricRingPacking object\n        filename: Output filename for the visualization\n    \"\"\"\n    try:\n        import matplotlib.pyplot as plt\n        import matplotlib.patches as patches\n    except ImportError:\n        print(\"Matplotlib not available. Skipping visualization.\")\n        return\n    \n    fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n    \n    # Draw container\n    container = patches.Rectangle(\n        (0, 0), packing.container_size, packing.container_size,\n        linewidth=2, edgecolor='black', facecolor='white'\n    )\n    ax.add_patch(container)\n    \n    # Color map for rings\n    colors = plt.cm.tab20(np.linspace(0, 1, 10))\n    \n    # Draw circles\n    for i, circle in enumerate(packing.circles):\n        color_idx = (circle.ring - 1) % len(colors)\n        circle_patch = patches.Circle(\n            (circle.x, circle.y), circle.radius,\n            linewidth=1.5, edgecolor='black',\n            facecolor=colors[color_idx], alpha=0.7\n        )\n        ax.add_patch(circle_patch)\n        \n        # Add circle label\n        ax.text(circle.x, circle.y, str(i), ha='center', va='center',\n                fontsize=8, fontweight='bold')\n    \n    # Draw center point\n    ax.plot(packing.center, packing.center, 'r+', markersize=10, markeredgewidth=2)\n    \n    ax.set_xlim(-5, packing.container_size + 5)\n    ax.set_ylim(-5, packing.container_size + 5)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_title(f'Concentric Ring Circle Packing\\n'\n                 f'Efficiency: {packing.get_packing_efficiency():.2%}')\n    \n    plt.tight_layout()\n    plt.savefig(filename, dpi=150, bbox_inches='tight')\n    print(f\"\\nVisualization saved to: {filename}\")\n    plt.close()\n\nif __name__ == \"__main__\":\n    # Run the packing algorithm\n    results = run_packing(container_size=100.0, verbose=True)\n    \n    # Visualize the result\n    visualize_packing(results['packing'])\n    \n    # Additional analysis\n    print(\"\\n\" + \"=\" * 60)\n    print(\"SUMMARY\")\n    print(\"=\" * 60)\n    stats = results['statistics",
  "timestamp": "2025-12-08T12:15:14.485874",
  "cost_data": null
}