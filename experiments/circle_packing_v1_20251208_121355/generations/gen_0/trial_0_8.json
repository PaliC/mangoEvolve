{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom typing import List, Tuple\nimport matplotlib.patches as mpatches\n\nclass CircleNode:\n    \"\"\"Represents a circle in the packing.\"\"\"\n    \n    def __init__(self, x: float, y: float, radius: float, label: str):\n        self.x = x\n        self.y = y\n        self.radius = radius\n        self.label = label\n        self.vx = 0.0  # velocity x\n        self.vy = 0.0  # velocity y\n        self.fx = 0.0  # force x\n        self.fy = 0.0  # force y\n    \n    def distance_to(self, other: 'CircleNode') -> float:\n        \"\"\"Calculate Euclidean distance to another circle.\"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n    \n    def __repr__(self) -> str:\n        return f\"Circle({self.label}, x={self.x:.2f}, y={self.y:.2f}, r={self.radius:.2f})\"\n\n\nclass CirclePackingSolver:\n    \"\"\"Force-directed circle packing solver.\"\"\"\n    \n    def __init__(self, square_size: float = 100.0, num_circles: int = 26):\n        self.square_size = square_size\n        self.num_circles = num_circles\n        self.circles: List[CircleNode] = []\n        \n        # Physics parameters\n        self.repulsion_strength = 50.0\n        self.damping = 0.85\n        self.dt = 0.01  # time step\n        self.velocity_threshold = 0.001\n        self.boundary_force = 100.0\n        \n        # Optimization parameters\n        self.min_radius = 0.5\n        self.max_radius = 5.0\n        self.radius_iterations = 50\n        self.radius_step = 0.1\n    \n    def construct_packing(self) -> None:\n        \"\"\"Initialize circles with random positions and equal radii.\"\"\"\n        print(\"Constructing initial circle packing...\")\n        \n        # Create 26 circles (A-Z)\n        labels = [chr(65 + i) for i in range(26)]\n        \n        # Initialize with small equal radii\n        initial_radius = 2.0\n        \n        for i, label in enumerate(labels):\n            # Random position within square\n            x = np.random.uniform(initial_radius, self.square_size - initial_radius)\n            y = np.random.uniform(initial_radius, self.square_size - initial_radius)\n            \n            circle = CircleNode(x, y, initial_radius, label)\n            self.circles.append(circle)\n        \n        print(f\"Created {len(self.circles)} circles\")\n    \n    def calculate_repulsion_force(self, circle1: CircleNode, circle2: CircleNode) -> Tuple[float, float]:\n        \"\"\"Calculate repulsive force between two circles.\"\"\"\n        dx = circle1.x - circle2.x\n        dy = circle1.y - circle2.y\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        # Avoid division by zero\n        if dist < 0.1:\n            dist = 0.1\n        \n        # Minimum separation distance\n        min_dist = circle1.radius + circle2.radius\n        \n        # Repulsive force (stronger when circles overlap)\n        if dist < min_dist:\n            force_magnitude = self.repulsion_strength * (min_dist - dist)\n        else:\n            # Weaker repulsion at distance\n            force_magnitude = self.repulsion_strength * (min_dist - dist) * 0.1\n        \n        # Normalize direction\n        fx = (dx / dist) * force_magnitude\n        fy = (dy / dist) * force_magnitude\n        \n        return fx, fy\n    \n    def apply_boundary_forces(self, circle: CircleNode) -> None:\n        \"\"\"Apply forces to keep circles within boundaries.\"\"\"\n        # Left boundary\n        if circle.x - circle.radius < 0:\n            circle.fx += self.boundary_force * (circle.radius - circle.x)\n        \n        # Right boundary\n        if circle.x + circle.radius > self.square_size:\n            circle.fx -= self.boundary_force * (circle.x + circle.radius - self.square_size)\n        \n        # Bottom boundary\n        if circle.y - circle.radius < 0:\n            circle.fy += self.boundary_force * (circle.radius - circle.y)\n        \n        # Top boundary\n        if circle.y + circle.radius > self.square_size:\n            circle.fy -= self.boundary_force * (circle.y + circle.radius - self.square_size)\n    \n    def update_forces(self) -> None:\n        \"\"\"Calculate all forces on circles.\"\"\"\n        # Reset forces\n        for circle in self.circles:\n            circle.fx = 0.0\n            circle.fy = 0.0\n        \n        # Repulsive forces between circles\n        for i, circle1 in enumerate(self.circles):\n            for circle2 in self.circles[i+1:]:\n                fx, fy = self.calculate_repulsion_force(circle1, circle2)\n                circle1.fx += fx\n                circle1.fy += fy\n                circle2.fx -= fx\n                circle2.fy -= fy\n        \n        # Boundary forces\n        for circle in self.circles:\n            self.apply_boundary_forces(circle)\n    \n    def update_velocities_and_positions(self) -> float:\n        \"\"\"Update velocities and positions using Verlet integration.\"\"\"\n        max_velocity = 0.0\n        \n        for circle in self.circles:\n            # Update velocity with damping\n            circle.vx = (circle.vx + circle.fx * self.dt) * self.damping\n            circle.vy = (circle.vy + circle.fy * self.dt) * self.damping\n            \n            # Update position\n            circle.x += circle.vx * self.dt\n            circle.y += circle.vy * self.dt\n            \n            # Track maximum velocity\n            velocity = np.sqrt(circle.vx**2 + circle.vy**2)\n            max_velocity = max(max_velocity, velocity)\n        \n        return max_velocity\n    \n    def settle_circles(self, max_iterations: int = 1000, convergence_threshold: float = 0.01) -> int:\n        \"\"\"Let circles settle into equilibrium using force-directed simulation.\"\"\"\n        print(\"\\nSettling circles into equilibrium...\")\n        \n        iteration = 0\n        for iteration in range(max_iterations):\n            self.update_forces()\n            max_velocity = self.update_velocities_and_positions()\n            \n            if (iteration + 1) % 100 == 0:\n                print(f\"  Iteration {iteration + 1}: max velocity = {max_velocity:.6f}\")\n            \n            # Check for convergence\n            if max_velocity < convergence_threshold:\n                print(f\"Converged at iteration {iteration + 1}\")\n                break\n        \n        return iteration + 1\n    \n    def calculate_packing_efficiency(self) -> float:\n        \"\"\"Calculate the packing efficiency (packed area / total area).\"\"\"\n        total_circle_area = sum(np.pi * circle.radius**2 for circle in self.circles)\n        total_area = self.square_size ** 2\n        return total_circle_area / total_area\n    \n    def check_overlaps(self) -> List[Tuple[str, str, float]]:\n        \"\"\"Check for overlapping circles and return overlap information.\"\"\"\n        overlaps = []\n        \n        for i, circle1 in enumerate(self.circles):\n            for circle2 in self.circles[i+1:]:\n                dist = circle1.distance_to(circle2)\n                min_dist = circle1.radius + circle2.radius\n                \n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    overlaps.append((circle1.label, circle2.label, overlap))\n        \n        return overlaps\n    \n    def optimize_radii(self) -> None:\n        \"\"\"Optimize circle radii to maximize packing efficiency.\"\"\"\n        print(\"\\nOptimizing radii...\")\n        \n        for iteration in range(self.radius_iterations):\n            # Try to increase radius of each circle\n            for circle in self.circles:\n                old_radius = circle.radius\n                \n                # Try increasing radius\n                circle.radius += self.radius_step\n                \n                # Check if it causes overlaps\n                overlaps = self.check_overlaps()\n                \n                if overlaps:\n                    # Revert if overlaps occur\n                    circle.radius = old_radius\n                else:\n                    # Keep the increase\n                    pass\n            \n            if (iteration + 1) % 10 == 0:\n                efficiency = self.calculate_packing_efficiency()\n                print(f\"  Iteration {iteration + 1}: efficiency = {efficiency:.4f}\")\n        \n        print(\"Radius optimization complete\")\n    \n    def get_statistics(self) -> dict:\n        \"\"\"Get packing statistics.\"\"\"\n        radii = [circle.radius for circle in self.circles]\n        \n        stats = {\n            'num_circles': len(self.circles),\n            'mean_radius': np.mean(radii),\n            'min_radius': np.min(radii),\n            'max_radius': np.max(radii),\n            'total_area': np.sum([np.pi * r**2 for r in radii]),\n            'square_area': self.square_size ** 2,\n            'efficiency': self.calculate_packing_efficiency(),\n            'num_overlaps': len(self.check_overlaps())\n        }\n        \n        return stats\n    \n    def visualize(self, title: str = \"Circle Packing\", figsize: Tuple[int, int] = (10, 10)) -> None:\n        \"\"\"Visualize the circle packing.\"\"\"\n        fig, ax = plt.subplots(figsize=figsize)\n        \n        # Draw square boundary\n        boundary = mpatches.Rectangle((0, 0), self.square_size, self.square_size,\n                                     linewidth=2, edgecolor='black', facecolor='lightgray', alpha=0.3)\n        ax.add_patch(boundary)\n        \n        # Draw circles\n        colors = plt.cm.tab20c(np.linspace(0, 1, self.num_circles))\n        \n        for circle, color in zip(self.circles, colors):\n            patch = Circle((circle.x, circle.y), circle.radius, \n                          edgecolor='black', facecolor=color, linewidth=1.5, alpha=0.7)\n            ax.add_patch(patch)\n            \n            # Add label\n            ax.text(circle.x, circle.y, circle.label, \n                   ha='center', va='center', fontsize=8, fontweight='bold')\n        \n        # Set axis properties\n        ax.set_xlim(-2, self.square_size + 2)\n        ax.set_ylim(-2, self.square_size + 2)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        \n        # Add statistics\n        stats = self.get_statistics()\n        stats_text = (\n            f\"Circles: {stats['num_circles']}\\n\"\n            f\"Efficiency: {stats['efficiency']:.2%}\\n\"\n            f\"Mean radius: {stats['mean_radius']:.2f}\\n\"\n            f\"Overlaps: {stats['num_overlaps']}\"\n        )\n        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes,\n               fontsize=10, verticalalignment='top',\n               bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n        \n        ax.set_title(title, fontsize=14, fontweight='bold')\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        \n        plt.tight_layout()\n        return fig, ax\n\n\ndef construct_packing() -> CirclePackingSolver:\n    \"\"\"Factory function to construct a circle packing solver.\"\"\"\n    solver = CirclePackingSolver(square_size=100.0, num_circles=26)\n    solver.construct_packing()\n    return solver\n\n\ndef run_packing(solver: CirclePackingSolver, visualize: bool = True) -> CirclePackingSolver:\n    \"\"\"Run the complete packing algorithm.\"\"\"\n    print(\"=\" * 60)\n    print(\"CIRCLE PACKING ALGORITHM (Force-Directed Approach)\")\n    print(\"=\" * 60)\n    \n    # Phase 1: Settle circles\n    iterations = solver.settle_circles(max_iterations=1000, convergence_threshold=0.01)\n    print(f\"Settlement complete in {iterations} iterations\")\n    \n    # Phase 2: Optimize radii\n    solver.optimize_radii()\n    \n    # Phase 3: Fine-tune positions with larger radii\n    print(\"\\nFine-tuning positions...\")\n    iterations = solver.settle_circles(max_iterations=500, convergence_threshold=0.005)\n    print(f\"Fine-tuning complete in {iterations} iterations\")\n    \n    # Print final statistics\n    stats = solver.get_statistics()\n    print(\"\\n\" + \"=\" * 60)\n    print(\"FINAL STATISTICS\")\n    print(\"=\" * 60)\n    print(f\"Number of circles: {stats['num_circles']}\")\n    print(f\"Packing efficiency: {stats['efficiency']:.2%}\")\n    print(f\"Mean radius: {stats['mean_radius']:.3f}\")\n    print(f\"Radius range: [{stats['min_radius']:.3f}, {stats['max_radius']:.3f}]\")\n    print(f\"Total circle area: {stats['total_area']:.2f}\")\n    print(f\"Square area: {stats['square_area']:.2f}\")\n    print(f\"Overlapping pairs: {stats['num_overlaps']}\")\n    \n    # Check for overlaps\n    overlaps = solver.check_overlaps()\n    if overlaps:\n        print(f\"\\nWarning: {len(overlaps)} overlapping pairs found:\")\n        for label1, label2, overlap in overlaps[:5]:\n            print(f\"  {label1}-{label2}: {overlap:.3f}\")\n        if len(overlaps) > 5:\n            print(f\"  ... and {len(overlaps) - 5} more\")\n    else:\n        print(\"\\n\u2713 No overlaps detected!\")\n    \n    print(\"=\" * 60)\n    \n    # Visualization\n    if visualize:\n        fig, ax = solver.visualize(title=\"Circle Packing - 26 Circles (Force-Directed)\")\n        plt.show()\n    \n    return solver\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create and run the packing algorithm\n    solver = construct_packing()\n    solver = run_packing(solver, visualize=True)\n    \n    # Optional: Print circle details\n    print(\"\\nCircle Details:\")\n    print(\"-\" * 60)\n    for circle in sorted(solver.circles, key=lambda c: c.label):\n        print(f\"{circle.label}: pos=({circle.x:6.2f}, {circle.y:6.2f}), r={circle.radius:.3f}\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.2239391803741455,
    "error": "TypeError: run_packing() missing 1 required positional argument: 'solver'"
  },
  "prompt": "Write a circle packing algorithm for 26 circles using a force-directed graph approach. Treat circles as nodes with repulsive forces, place them in the square, and let them settle into an equilibrium. Then optimize radii. Include construct_packing() and run_packing() functions.",
  "response": "```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom typing import List, Tuple\nimport matplotlib.patches as mpatches\n\nclass CircleNode:\n    \"\"\"Represents a circle in the packing.\"\"\"\n    \n    def __init__(self, x: float, y: float, radius: float, label: str):\n        self.x = x\n        self.y = y\n        self.radius = radius\n        self.label = label\n        self.vx = 0.0  # velocity x\n        self.vy = 0.0  # velocity y\n        self.fx = 0.0  # force x\n        self.fy = 0.0  # force y\n    \n    def distance_to(self, other: 'CircleNode') -> float:\n        \"\"\"Calculate Euclidean distance to another circle.\"\"\"\n        return np.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n    \n    def __repr__(self) -> str:\n        return f\"Circle({self.label}, x={self.x:.2f}, y={self.y:.2f}, r={self.radius:.2f})\"\n\n\nclass CirclePackingSolver:\n    \"\"\"Force-directed circle packing solver.\"\"\"\n    \n    def __init__(self, square_size: float = 100.0, num_circles: int = 26):\n        self.square_size = square_size\n        self.num_circles = num_circles\n        self.circles: List[CircleNode] = []\n        \n        # Physics parameters\n        self.repulsion_strength = 50.0\n        self.damping = 0.85\n        self.dt = 0.01  # time step\n        self.velocity_threshold = 0.001\n        self.boundary_force = 100.0\n        \n        # Optimization parameters\n        self.min_radius = 0.5\n        self.max_radius = 5.0\n        self.radius_iterations = 50\n        self.radius_step = 0.1\n    \n    def construct_packing(self) -> None:\n        \"\"\"Initialize circles with random positions and equal radii.\"\"\"\n        print(\"Constructing initial circle packing...\")\n        \n        # Create 26 circles (A-Z)\n        labels = [chr(65 + i) for i in range(26)]\n        \n        # Initialize with small equal radii\n        initial_radius = 2.0\n        \n        for i, label in enumerate(labels):\n            # Random position within square\n            x = np.random.uniform(initial_radius, self.square_size - initial_radius)\n            y = np.random.uniform(initial_radius, self.square_size - initial_radius)\n            \n            circle = CircleNode(x, y, initial_radius, label)\n            self.circles.append(circle)\n        \n        print(f\"Created {len(self.circles)} circles\")\n    \n    def calculate_repulsion_force(self, circle1: CircleNode, circle2: CircleNode) -> Tuple[float, float]:\n        \"\"\"Calculate repulsive force between two circles.\"\"\"\n        dx = circle1.x - circle2.x\n        dy = circle1.y - circle2.y\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        # Avoid division by zero\n        if dist < 0.1:\n            dist = 0.1\n        \n        # Minimum separation distance\n        min_dist = circle1.radius + circle2.radius\n        \n        # Repulsive force (stronger when circles overlap)\n        if dist < min_dist:\n            force_magnitude = self.repulsion_strength * (min_dist - dist)\n        else:\n            # Weaker repulsion at distance\n            force_magnitude = self.repulsion_strength * (min_dist - dist) * 0.1\n        \n        # Normalize direction\n        fx = (dx / dist) * force_magnitude\n        fy = (dy / dist) * force_magnitude\n        \n        return fx, fy\n    \n    def apply_boundary_forces(self, circle: CircleNode) -> None:\n        \"\"\"Apply forces to keep circles within boundaries.\"\"\"\n        # Left boundary\n        if circle.x - circle.radius < 0:\n            circle.fx += self.boundary_force * (circle.radius - circle.x)\n        \n        # Right boundary\n        if circle.x + circle.radius > self.square_size:\n            circle.fx -= self.boundary_force * (circle.x + circle.radius - self.square_size)\n        \n        # Bottom boundary\n        if circle.y - circle.radius < 0:\n            circle.fy += self.boundary_force * (circle.radius - circle.y)\n        \n        # Top boundary\n        if circle.y + circle.radius > self.square_size:\n            circle.fy -= self.boundary_force * (circle.y + circle.radius - self.square_size)\n    \n    def update_forces(self) -> None:\n        \"\"\"Calculate all forces on circles.\"\"\"\n        # Reset forces\n        for circle in self.circles:\n            circle.fx = 0.0\n            circle.fy = 0.0\n        \n        # Repulsive forces between circles\n        for i, circle1 in enumerate(self.circles):\n            for circle2 in self.circles[i+1:]:\n                fx, fy = self.calculate_repulsion_force(circle1, circle2)\n                circle1.fx += fx\n                circle1.fy += fy\n                circle2.fx -= fx\n                circle2.fy -= fy\n        \n        # Boundary forces\n        for circle in self.circles:\n            self.apply_boundary_forces(circle)\n    \n    def update_velocities_and_positions(self) -> float:\n        \"\"\"Update velocities and positions using Verlet integration.\"\"\"\n        max_velocity = 0.0\n        \n        for circle in self.circles:\n            # Update velocity with damping\n            circle.vx = (circle.vx + circle.fx * self.dt) * self.damping\n            circle.vy = (circle.vy + circle.fy * self.dt) * self.damping\n            \n            # Update position\n            circle.x += circle.vx * self.dt\n            circle.y += circle.vy * self.dt\n            \n            # Track maximum velocity\n            velocity = np.sqrt(circle.vx**2 + circle.vy**2)\n            max_velocity = max(max_velocity, velocity)\n        \n        return max_velocity\n    \n    def settle_circles(self, max_iterations: int = 1000, convergence_threshold: float = 0.01) -> int:\n        \"\"\"Let circles settle into equilibrium using force-directed simulation.\"\"\"\n        print(\"\\nSettling circles into equilibrium...\")\n        \n        iteration = 0\n        for iteration in range(max_iterations):\n            self.update_forces()\n            max_velocity = self.update_velocities_and_positions()\n            \n            if (iteration + 1) % 100 == 0:\n                print(f\"  Iteration {iteration + 1}: max velocity = {max_velocity:.6f}\")\n            \n            # Check for convergence\n            if max_velocity < convergence_threshold:\n                print(f\"Converged at iteration {iteration + 1}\")\n                break\n        \n        return iteration + 1\n    \n    def calculate_packing_efficiency(self) -> float:\n        \"\"\"Calculate the packing efficiency (packed area / total area).\"\"\"\n        total_circle_area = sum(np.pi * circle.radius**2 for circle in self.circles)\n        total_area = self.square_size ** 2\n        return total_circle_area / total_area\n    \n    def check_overlaps(self) -> List[Tuple[str, str, float]]:\n        \"\"\"Check for overlapping circles and return overlap information.\"\"\"\n        overlaps = []\n        \n        for i, circle1 in enumerate(self.circles):\n            for circle2 in self.circles[i+1:]:\n                dist = circle1.distance_to(circle2)\n                min_dist = circle1.radius + circle2.radius\n                \n                if dist < min_dist:\n                    overlap = min_dist - dist\n                    overlaps.append((circle1.label, circle2.label, overlap))\n        \n        return overlaps\n    \n    def optimize_radii(self) -> None:\n        \"\"\"Optimize circle radii to maximize packing efficiency.\"\"\"\n        print(\"\\nOptimizing radii...\")\n        \n        for iteration in range(self.radius_iterations):\n            # Try to increase radius of each circle\n            for circle in self.circles:\n                old_radius = circle.radius\n                \n                # Try increasing radius\n                circle.radius += self.radius_step\n                \n                # Check if it causes overlaps\n                overlaps = self.check_overlaps()\n                \n                if overlaps:\n                    # Revert if overlaps occur\n                    circle.radius = old_radius\n                else:\n                    # Keep the increase\n                    pass\n            \n            if (iteration + 1) % 10 == 0:\n                efficiency = self.calculate_packing_efficiency()\n                print(f\"  Iteration {iteration + 1}: efficiency = {efficiency:.4f}\")\n        \n        print(\"Radius optimization complete\")\n    \n    def get_statistics(self) -> dict:\n        \"\"\"Get packing statistics.\"\"\"\n        radii = [circle.radius for circle in self.circles]\n        \n        stats = {\n            'num_circles': len(self.circles),\n            'mean_radius': np.mean(radii),\n            'min_radius': np.min(radii),\n            'max_radius': np.max(radii),\n            'total_area': np.sum([np.pi * r**2 for r in radii]),\n            'square_area': self.square_size ** 2,\n            'efficiency': self.calculate_packing_efficiency(),\n            'num_overlaps': len(self.check_overlaps())\n        }\n        \n        return stats\n    \n    def visualize(self, title: str = \"Circle Packing\", figsize: Tuple[int, int] = (10, 10)) -> None:\n        \"\"\"Visualize the circle packing.\"\"\"\n        fig, ax = plt.subplots(figsize=figsize)\n        \n        # Draw square boundary\n        boundary = mpatches.Rectangle((0, 0), self.square_size, self.square_size,\n                                     linewidth=2, edgecolor='black', facecolor='lightgray', alpha=0.3)\n        ax.add_patch(boundary)\n        \n        # Draw circles\n        colors = plt.cm.tab20c(np.linspace(0, 1, self.num_circles))\n        \n        for circle, color in zip(self.circles, colors):\n            patch = Circle((circle.x, circle.y), circle.radius, \n                          edgecolor='black', facecolor=color, linewidth=1.5, alpha=0.7)\n            ax.add_patch(patch)\n            \n            # Add label\n            ax.text(circle.x, circle.y, circle.label, \n                   ha='center', va='center', fontsize=8, fontweight='bold')\n        \n        # Set axis properties\n        ax.set_xlim(-2, self.square_size + 2)\n        ax.set_ylim(-2, self.square_size + 2)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        \n        # Add statistics\n        stats = self.get_statistics()\n        stats_text = (\n            f\"Circles: {stats['num_circles']}\\n\"\n            f\"Efficiency: {stats['efficiency']:.2%}\\n\"\n            f\"Mean radius: {stats['mean_radius']:.2f}\\n\"\n            f\"Overlaps: {stats['num_overlaps']}\"\n        )\n        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes,\n               fontsize=10, verticalalignment='top',\n               bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n        \n        ax.set_title(title, fontsize=14, fontweight='bold')\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        \n        plt.tight_layout()\n        return fig, ax\n\n\ndef construct_packing() -> CirclePackingSolver:\n    \"\"\"Factory function to construct a circle packing solver.\"\"\"\n    solver = CirclePackingSolver(square_size=100.0, num_circles=26)\n    solver.construct_packing()\n    return solver\n\n\ndef run_packing(solver: CirclePackingSolver, visualize: bool = True) -> CirclePackingSolver:\n    \"\"\"Run the complete packing algorithm.\"\"\"\n    print(\"=\" * 60)\n    print(\"CIRCLE PACKING ALGORITHM (Force-Directed Approach)\")\n    print(\"=\" * 60)\n    \n    # Phase 1: Settle circles\n    iterations = solver.settle_circles(max_iterations=1000, convergence_threshold=0.01)\n    print(f\"Settlement complete in {iterations} iterations\")\n    \n    # Phase 2: Optimize radii\n    solver.optimize_radii()\n    \n    # Phase 3: Fine-tune positions with larger radii\n    print(\"\\nFine-tuning positions...\")\n    iterations = solver.settle_circles(max_iterations=500, convergence_threshold=0.005)\n    print(f\"Fine-tuning complete in {iterations} iterations\")\n    \n    # Print final statistics\n    stats = solver.get_statistics()\n    print(\"\\n\" + \"=\" * 60)\n    print(\"FINAL STATISTICS\")\n    print(\"=\" * 60)\n    print(f\"Number of circles: {stats['num_circles']}\")\n    print(f\"Packing efficiency: {stats['efficiency']:.2%}\")\n    print(f\"Mean radius: {stats['mean_radius']:.3f}\")\n    print(f\"Radius range: [{stats['min_radius']:.3f}, {stats['max_radius']:.3f}]\")\n    print(f\"Total circle area: {stats['total_area']:.2f}\")\n    print(f\"Square area: {stats['square_area']:.2f}\")\n    print(f\"Overlapping pairs: {stats['num_overlaps']}\")\n    \n    # Check for overlaps\n    overlaps = solver.check_overlaps()\n    if overlaps:\n        print(f\"\\nWarning: {len(overlaps)} overlapping pairs found:\")\n        for label1, label2, overlap in overlaps[:5]:\n            print(f\"  {label1}-{label2}: {overlap:.3f}\")\n        if len(overlaps) > 5:\n            print(f\"  ... and {len(overlaps) - 5} more\")\n    else:\n        print(\"\\n\u2713 No overlaps detected!\")\n    \n    print(\"=\" * 60)\n    \n    # Visualization\n    if visualize:\n        fig, ax = solver.visualize(title=\"Circle Packing - 26 Circles (Force-Directed)\")\n        plt.show()\n    \n    return solver\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create and run the packing algorithm\n    solver = construct_packing()\n    solver = run_packing(solver, visualize=True)\n    \n    # Optional: Print circle details\n    print(\"\\nCircle Details:\")\n    print(\"-\" * 60)\n    for circle in sorted(solver.circles, key=lambda c: c.label):\n        print(f\"{circle.label}: pos=({circle.x:6.2f}, {circle.y:6.2f}), r={circle.radius:.3f}\")\n```\n\nThis implementation includes:\n\n## Key Features:\n\n1. **CircleNode Class**: Represents individual circles with position, radius, velocity, and forces\n\n2. **Force-Directed Physics**:\n   - Repulsive forces between overlapping circles\n   - Boundary forces to keep circles in the square\n   - Velocity damping for stability\n   - Verlet integration for position updates\n\n3. **construct_packing()**: \n   - Initializes 26 circles (A-Z) with random positions\n   - Sets equal initial radii\n\n4. **run_packing()**: \n   - Settles circles into equilibrium\n   - Optimizes radii to maximize packing\n   - Fine-tunes positions\n   - Reports statistics and visualizes results\n\n5. **Optimization Features**:\n   - Packing efficiency calculation\n   - Overlap detection\n   - Radius optimization\n   - Convergence detection\n\n6. **Visualization**: \n   - Shows circles with labels\n   - Displays packing efficiency",
  "reasoning": "This implementation includes:\n\n## Key Features:\n\n1. **CircleNode Class**: Represents individual circles with position, radius, velocity, and forces\n\n2. **Force-Directed Physics**:\n   - Repulsive forces between overlapping circles\n   - Boundary forces to keep circles in the square\n   - Velocity damping for stability\n   - Verlet integration for position updates\n\n3. **construct_packing()**: \n   - Initializes 26 circles (A-Z) with random positions\n   - Sets equal initial radii\n\n4. **run_packing()**: \n   - Settles circles into equilibrium\n   - Optimizes radii to maximize packing\n   - Fine-tunes positions\n   - Reports statistics and visualizes results\n\n5. **Optimization Features**:\n   - Packing efficiency calculation\n   - Overlap detection\n   - Radius optimization\n   - Convergence detection\n\n6. **Visualization**: \n   - Shows circles with labels\n   - Displays packing efficiency",
  "timestamp": "2025-12-08T12:15:14.687271",
  "cost_data": null
}