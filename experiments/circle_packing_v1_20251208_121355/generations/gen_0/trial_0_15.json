{
  "trial_id": "trial_0_15",
  "generation": 0,
  "parent_id": null,
  "code": "",
  "metrics": {},
  "prompt": "Write a circle packing algorithm for 26 circles using a divide-and-conquer approach. Divide the square into quadrants, solve the packing problem for each quadrant recursively, then merge solutions. Include construct_packing() and run_packing() functions.",
  "response": "# Circle Packing Algorithm using Divide-and-Conquer\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom typing import List, Tuple\nimport math\n\nclass Circle:\n    \"\"\"Represents a circle with position and radius.\"\"\"\n    def __init__(self, x: float, y: float, radius: float, id: int = 0):\n        self.x = x\n        self.y = y\n        self.radius = radius\n        self.id = id\n    \n    def __repr__(self):\n        return f\"Circle(id={self.id}, x={self.x:.2f}, y={self.y:.2f}, r={self.radius:.2f})\"\n    \n    def distance_to(self, other: 'Circle') -> float:\n        \"\"\"Calculate distance between circle centers.\"\"\"\n        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n    \n    def overlaps_with(self, other: 'Circle', tolerance: float = 1e-6) -> bool:\n        \"\"\"Check if this circle overlaps with another.\"\"\"\n        min_distance = self.radius + other.radius - tolerance\n        return self.distance_to(other) < min_distance\n    \n    def is_inside_bounds(self, x_min: float, y_min: float, \n                         x_max: float, y_max: float) -> bool:\n        \"\"\"Check if circle is completely within bounds.\"\"\"\n        return (x_min + self.radius <= self.x and \n                self.x <= x_max - self.radius and\n                y_min + self.radius <= self.y and \n                self.y <= y_max - self.radius)\n\n\nclass CirclePackingSolver:\n    \"\"\"Divide-and-conquer circle packing solver.\"\"\"\n    \n    def __init__(self, num_circles: int = 26, bounds: Tuple[float, float, float, float] = (0, 0, 100, 100)):\n        \"\"\"\n        Initialize the solver.\n        \n        Args:\n            num_circles: Number of circles to pack\n            bounds: (x_min, y_min, x_max, y_max) of the packing region\n        \"\"\"\n        self.num_circles = num_circles\n        self.bounds = bounds\n        self.circles: List[Circle] = []\n        self.max_iterations = 1000\n        self.min_radius = 0.5\n        \n    def construct_packing(self) -> List[Circle]:\n        \"\"\"\n        Construct initial circle packing using divide-and-conquer approach.\n        \n        Returns:\n            List of packed circles\n        \"\"\"\n        self.circles = []\n        \n        # Generate circles with decreasing radii\n        radii = self._generate_radii()\n        \n        # Divide-and-conquer packing\n        self.circles = self._divide_and_conquer_pack(\n            list(range(self.num_circles)),\n            radii,\n            self.bounds\n        )\n        \n        return self.circles\n    \n    def _generate_radii(self) -> List[float]:\n        \"\"\"Generate radii for circles (decreasing sizes).\"\"\"\n        radii = []\n        for i in range(self.num_circles):\n            # Larger circles first, decreasing exponentially\n            radius = 5.0 * (0.85 ** (i / 5))\n            radius = max(radius, self.min_radius)\n            radii.append(radius)\n        return radii\n    \n    def _divide_and_conquer_pack(self, indices: List[int], radii: List[float],\n                                  bounds: Tuple[float, float, float, float]) -> List[Circle]:\n        \"\"\"\n        Recursively pack circles using divide-and-conquer.\n        \n        Args:\n            indices: Circle indices to pack\n            radii: Radii of circles\n            bounds: Bounding box (x_min, y_min, x_max, y_max)\n        \n        Returns:\n            List of packed circles\n        \"\"\"\n        if len(indices) == 0:\n            return []\n        \n        if len(indices) == 1:\n            # Base case: single circle\n            idx = indices[0]\n            x_min, y_min, x_max, y_max = bounds\n            x = (x_min + x_max) / 2\n            y = (y_min + y_max) / 2\n            return [Circle(x, y, radii[idx], id=idx)]\n        \n        if len(indices) <= 4:\n            # Small number of circles: use simple placement\n            return self._pack_small_group(indices, radii, bounds)\n        \n        # Divide into quadrants\n        x_min, y_min, x_max, y_max = bounds\n        x_mid = (x_min + x_max) / 2\n        y_mid = (y_min + y_max) / 2\n        \n        # Split circles by size and distribute to quadrants\n        sorted_indices = sorted(indices, key=lambda i: radii[i], reverse=True)\n        \n        quadrants = [[], [], [], []]\n        quadrant_bounds = [\n            (x_min, y_min, x_mid, y_mid),      # Bottom-left\n            (x_mid, y_min, x_max, y_mid),      # Bottom-right\n            (x_min, y_mid, x_mid, y_max),      # Top-left\n            (x_mid, y_mid, x_max, y_max),      # Top-right\n        ]\n        \n        # Distribute circles to quadrants (round-robin with largest first)\n        for i, idx in enumerate(sorted_indices):\n            quadrants[i % 4].append(idx)\n        \n        # Recursively pack each quadrant\n        packed_circles = []\n        for quad_indices, quad_bounds in zip(quadrants, quadrant_bounds):\n            if quad_indices:\n                packed_circles.extend(\n                    self._divide_and_conquer_pack(quad_indices, radii, quad_bounds)\n                )\n        \n        return packed_circles\n    \n    def _pack_small_group(self, indices: List[int], radii: List[float],\n                         bounds: Tuple[float, float, float, float]) -> List[Circle]:\n        \"\"\"Pack a small group of circles (\u2264 4) within bounds.\"\"\"\n        circles = []\n        x_min, y_min, x_max, y_max = bounds\n        width = x_max - x_min\n        height = y_max - y_min\n        \n        # Sort by size (largest first)\n        sorted_data = sorted([(i, radii[i]) for i in indices], \n                            key=lambda x: x[1], reverse=True)\n        \n        positions = []\n        \n        for position_idx, (idx, radius) in enumerate(sorted_data):\n            placed = False\n            \n            # Try predefined positions for small groups\n            if len(sorted_data) == 1:\n                x = x_min + width / 2\n                y = y_min + height / 2\n                positions.append((x, y))\n                placed = True\n            elif len(sorted_data) == 2:\n                if position_idx == 0:\n                    x = x_min + width / 3\n                else:\n                    x = x_min + 2 * width / 3\n                y = y_min + height / 2\n                positions.append((x, y))\n                placed = True\n            elif len(sorted_data) == 3:\n                if position_idx == 0:\n                    x = x_min + width / 2\n                    y = y_min + height / 3\n                elif position_idx == 1:\n                    x = x_min + width / 4\n                    y = y_min + 2 * height / 3\n                else:\n                    x = x_min + 3 * width / 4\n                    y = y_min + 2 * height / 3\n                positions.append((x, y))\n                placed = True\n            elif len(sorted_data) == 4:\n                quad = position_idx\n                x = x_min + (quad % 2 + 0.5) * width / 2\n                y = y_min + (quad // 2 + 0.5) * height / 2\n                positions.append((x, y))\n                placed = True\n            \n            if placed:\n                x, y = positions[-1]\n                # Clamp position to bounds\n                x = max(x_min + radius, min(x_max - radius, x))\n                y = max(y_min + radius, min(y_max - radius, y))\n                circles.append(Circle(x, y, radius, id=idx))\n        \n        return circles\n    \n    def run_packing(self, optimize: bool = True, verbose: bool = True) -> List[Circle]:\n        \"\"\"\n        Run the complete packing algorithm with optional optimization.\n        \n        Args:\n            optimize: Whether to apply local optimization\n            verbose: Whether to print progress information\n        \n        Returns:\n            List of packed circles\n        \"\"\"\n        if verbose:\n            print(f\"Starting circle packing for {self.num_circles} circles...\")\n        \n        # Initial packing\n        self.circles = self.construct_packing()\n        \n        if verbose:\n            print(f\"Initial packing complete: {len(self.circles)} circles placed\")\n            self._print_statistics()\n        \n        # Optimize placement\n        if optimize:\n            if verbose:\n                print(\"\\nOptimizing placement...\")\n            self._optimize_placement(verbose)\n        \n        if verbose:\n            print(\"\\nFinal packing statistics:\")\n            self._print_statistics()\n        \n        return self.circles\n    \n    def _optimize_placement(self, verbose: bool = False):\n        \"\"\"Optimize circle placement using local adjustments.\"\"\"\n        for iteration in range(self.max_iterations):\n            max_adjustment = 0.0\n            \n            for i, circle in enumerate(self.circles):\n                # Calculate repulsion from other circles\n                fx, fy = 0.0, 0.0\n                \n                for j, other in enumerate(self.circles):\n                    if i == j:\n                        continue\n                    \n                    dist = circle.distance_to(other)\n                    min_dist = circle.radius + other.radius\n                    \n                    if dist < min_dist:\n                        # Repulsion force\n                        if dist > 1e-6:\n                            ratio = (min_dist - dist) / dist\n                            fx += (other.x - circle.x) * ratio * 0.5\n                            fy += (other.y - circle.y) * ratio * 0.5\n                \n                # Calculate attraction to center of bounds\n                x_min, y_min, x_max, y_max = self.bounds\n                center_x = (x_min + x_max) / 2\n                center_y = (y_min + y_max) / 2\n                \n                dist_to_center = math.sqrt((circle.x - center_x)**2 + \n                                          (circle.y - center_y)**2)\n                if dist_to_center > 1e-6:\n                    fx += (center_x - circle.x) * 0.01\n                    fy += (center_y - circle.y) * 0.01\n                \n                # Apply adjustment\n                adjustment = math.sqrt(fx**2 + fy**2)\n                max_adjustment = max(max_adjustment, adjustment)\n                \n                # Move circle\n                step_size = 0.1\n                circle.x += fx * step_size\n                circle.y += fy * step_size\n                \n                # Keep within bounds\n                x_min, y_min, x_max, y_max = self.bounds\n                circle.x = max(x_min + circle.radius, \n                              min(x_max - circle.radius, circle.x))\n                circle.y = max(y_min + circle.radius, \n                              min(y_max - circle.radius, circle.y))\n            \n            if verbose and iteration % 100 == 0:\n                print(f\"  Iteration {iteration}: max adjustment = {max_adjustment:.6f}\")\n            \n            if max_adjustment < 1e-4:\n                if verbose:\n                    print(f\"  Converged at iteration {iteration}\")\n                break\n    \n    def _print_statistics(self):\n        \"\"\"Print packing statistics.\"\"\"\n        if not self.circles:\n            return\n        \n        # Check for overlaps\n        overlaps = 0\n        for i, circle in enumerate(self.circles):\n            for j, other in enumerate(self.circles):\n                if i < j and circle.overlaps_with(other):\n                    overlaps += 1\n        \n        # Check bounds violations\n        violations = 0\n        x_min, y_min, x_max, y_max = self.bounds\n        for circle in self.circles:\n            if not circle.is_inside_bounds(x_min, y_min, x_max, y_max):\n                violations += 1\n        \n        total_area = sum(math.pi * c.radius**2 for c in self.circles)\n        bounds_area = (x_max - x_min) * (y_max - y_min)\n        packing_efficiency = (total_area / bounds_area) * 100\n        \n        print(f\"  Circles placed: {len(self.circles)}\")\n        print(f\"  Overlaps: {overlaps}\")\n        print(f\"  Bounds violations: {violations}\")\n        print(f\"  Packing efficiency: {packing_efficiency:.2f}%\")\n        print(f\"  Total circle area: {total_area:.2f}\")\n        print(f\"  Bounds area: {bounds_area:.2f}\")\n    \n    def visualize(self, title: str = \"Circle Packing (Divide-and-Conquer)\"):\n        \"\"\"Visualize the packed circles.\"\"\"\n        fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n        \n        x_min, y_min, x_max, y_max = self.bounds\n        \n        # Draw bounds\n        ax.add_patch(plt.Rectangle((x_min, y_min), x_max - x_min, y_max - y_min,\n                                   fill=False, edgecolor='black', linewidth=2))\n        \n        # Draw circles\n        colors = plt.cm.hsv(np.linspace(0, 1, self.num_circles))\n        \n        for circle in self.circles:\n            circle_patch = plt.Circle((circle.x, circle.y), circle.radius,\n                                     color=colors[circle.id], alpha=0.6,\n                                     edgecolor='black', linewidth=1)\n            ax.add_patch(circle_patch)\n            \n            # Add circle ID\n            ax.text(circle.x, circle.y, str(circle.id), \n                   ha='center', va='center', fontsize=8, fontweight='bold')\n        \n        ax.set_xlim(x_min - 5, x_max + 5)\n        ax.set_ylim(y_min - 5, y_max + 5)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.set_title(title, fontsize=14, fontweight='bold')\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        \n        plt.tight_layout()\n        return fig, ax\n\n\ndef construct_packing(num_circles: int = 26, \n                     bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n                     optimize: bool = True) -> List[Circle]:\n    \"\"\"\n    Construct a circle packing using divide-and-conquer approach.\n    \n    Args:\n        num_circles: Number of circles to pack\n        bounds: Bounding box (x_min, y_min, x_max, y_max)\n        optimize: Whether to optimize the packing\n    \n    Returns:\n        List of packed circles\n    \"\"\"\n    solver = CirclePackingSolver(num_circles, bounds)\n    return solver.run_packing(optimize=optimize, verbose=False)\n\n\ndef run_packing(num_circles: int = 26,\n               bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n               optimize: bool = True,\n               visualize: bool = True) -> Tuple",
  "reasoning": "# Circle Packing Algorithm using Divide-and-Conquer\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom typing import List, Tuple\nimport math\n\nclass Circle:\n    \"\"\"Represents a circle with position and radius.\"\"\"\n    def __init__(self, x: float, y: float, radius: float, id: int = 0):\n        self.x = x\n        self.y = y\n        self.radius = radius\n        self.id = id\n    \n    def __repr__(self):\n        return f\"Circle(id={self.id}, x={self.x:.2f}, y={self.y:.2f}, r={self.radius:.2f})\"\n    \n    def distance_to(self, other: 'Circle') -> float:\n        \"\"\"Calculate distance between circle centers.\"\"\"\n        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)\n    \n    def overlaps_with(self, other: 'Circle', tolerance: float = 1e-6) -> bool:\n        \"\"\"Check if this circle overlaps with another.\"\"\"\n        min_distance = self.radius + other.radius - tolerance\n        return self.distance_to(other) < min_distance\n    \n    def is_inside_bounds(self, x_min: float, y_min: float, \n                         x_max: float, y_max: float) -> bool:\n        \"\"\"Check if circle is completely within bounds.\"\"\"\n        return (x_min + self.radius <= self.x and \n                self.x <= x_max - self.radius and\n                y_min + self.radius <= self.y and \n                self.y <= y_max - self.radius)\n\nclass CirclePackingSolver:\n    \"\"\"Divide-and-conquer circle packing solver.\"\"\"\n    \n    def __init__(self, num_circles: int = 26, bounds: Tuple[float, float, float, float] = (0, 0, 100, 100)):\n        \"\"\"\n        Initialize the solver.\n        \n        Args:\n            num_circles: Number of circles to pack\n            bounds: (x_min, y_min, x_max, y_max) of the packing region\n        \"\"\"\n        self.num_circles = num_circles\n        self.bounds = bounds\n        self.circles: List[Circle] = []\n        self.max_iterations = 1000\n        self.min_radius = 0.5\n        \n    def construct_packing(self) -> List[Circle]:\n        \"\"\"\n        Construct initial circle packing using divide-and-conquer approach.\n        \n        Returns:\n            List of packed circles\n        \"\"\"\n        self.circles = []\n        \n        # Generate circles with decreasing radii\n        radii = self._generate_radii()\n        \n        # Divide-and-conquer packing\n        self.circles = self._divide_and_conquer_pack(\n            list(range(self.num_circles)),\n            radii,\n            self.bounds\n        )\n        \n        return self.circles\n    \n    def _generate_radii(self) -> List[float]:\n        \"\"\"Generate radii for circles (decreasing sizes).\"\"\"\n        radii = []\n        for i in range(self.num_circles):\n            # Larger circles first, decreasing exponentially\n            radius = 5.0 * (0.85 ** (i / 5))\n            radius = max(radius, self.min_radius)\n            radii.append(radius)\n        return radii\n    \n    def _divide_and_conquer_pack(self, indices: List[int], radii: List[float],\n                                  bounds: Tuple[float, float, float, float]) -> List[Circle]:\n        \"\"\"\n        Recursively pack circles using divide-and-conquer.\n        \n        Args:\n            indices: Circle indices to pack\n            radii: Radii of circles\n            bounds: Bounding box (x_min, y_min, x_max, y_max)\n        \n        Returns:\n            List of packed circles\n        \"\"\"\n        if len(indices) == 0:\n            return []\n        \n        if len(indices) == 1:\n            # Base case: single circle\n            idx = indices[0]\n            x_min, y_min, x_max, y_max = bounds\n            x = (x_min + x_max) / 2\n            y = (y_min + y_max) / 2\n            return [Circle(x, y, radii[idx], id=idx)]\n        \n        if len(indices) <= 4:\n            # Small number of circles: use simple placement\n            return self._pack_small_group(indices, radii, bounds)\n        \n        # Divide into quadrants\n        x_min, y_min, x_max, y_max = bounds\n        x_mid = (x_min + x_max) / 2\n        y_mid = (y_min + y_max) / 2\n        \n        # Split circles by size and distribute to quadrants\n        sorted_indices = sorted(indices, key=lambda i: radii[i], reverse=True)\n        \n        quadrants = [[], [], [], []]\n        quadrant_bounds = [\n            (x_min, y_min, x_mid, y_mid),      # Bottom-left\n            (x_mid, y_min, x_max, y_mid),      # Bottom-right\n            (x_min, y_mid, x_mid, y_max),      # Top-left\n            (x_mid, y_mid, x_max, y_max),      # Top-right\n        ]\n        \n        # Distribute circles to quadrants (round-robin with largest first)\n        for i, idx in enumerate(sorted_indices):\n            quadrants[i % 4].append(idx)\n        \n        # Recursively pack each quadrant\n        packed_circles = []\n        for quad_indices, quad_bounds in zip(quadrants, quadrant_bounds):\n            if quad_indices:\n                packed_circles.extend(\n                    self._divide_and_conquer_pack(quad_indices, radii, quad_bounds)\n                )\n        \n        return packed_circles\n    \n    def _pack_small_group(self, indices: List[int], radii: List[float],\n                         bounds: Tuple[float, float, float, float]) -> List[Circle]:\n        \"\"\"Pack a small group of circles (\u2264 4) within bounds.\"\"\"\n        circles = []\n        x_min, y_min, x_max, y_max = bounds\n        width = x_max - x_min\n        height = y_max - y_min\n        \n        # Sort by size (largest first)\n        sorted_data = sorted([(i, radii[i]) for i in indices], \n                            key=lambda x: x[1], reverse=True)\n        \n        positions = []\n        \n        for position_idx, (idx, radius) in enumerate(sorted_data):\n            placed = False\n            \n            # Try predefined positions for small groups\n            if len(sorted_data) == 1:\n                x = x_min + width / 2\n                y = y_min + height / 2\n                positions.append((x, y))\n                placed = True\n            elif len(sorted_data) == 2:\n                if position_idx == 0:\n                    x = x_min + width / 3\n                else:\n                    x = x_min + 2 * width / 3\n                y = y_min + height / 2\n                positions.append((x, y))\n                placed = True\n            elif len(sorted_data) == 3:\n                if position_idx == 0:\n                    x = x_min + width / 2\n                    y = y_min + height / 3\n                elif position_idx == 1:\n                    x = x_min + width / 4\n                    y = y_min + 2 * height / 3\n                else:\n                    x = x_min + 3 * width / 4\n                    y = y_min + 2 * height / 3\n                positions.append((x, y))\n                placed = True\n            elif len(sorted_data) == 4:\n                quad = position_idx\n                x = x_min + (quad % 2 + 0.5) * width / 2\n                y = y_min + (quad // 2 + 0.5) * height / 2\n                positions.append((x, y))\n                placed = True\n            \n            if placed:\n                x, y = positions[-1]\n                # Clamp position to bounds\n                x = max(x_min + radius, min(x_max - radius, x))\n                y = max(y_min + radius, min(y_max - radius, y))\n                circles.append(Circle(x, y, radius, id=idx))\n        \n        return circles\n    \n    def run_packing(self, optimize: bool = True, verbose: bool = True) -> List[Circle]:\n        \"\"\"\n        Run the complete packing algorithm with optional optimization.\n        \n        Args:\n            optimize: Whether to apply local optimization\n            verbose: Whether to print progress information\n        \n        Returns:\n            List of packed circles\n        \"\"\"\n        if verbose:\n            print(f\"Starting circle packing for {self.num_circles} circles...\")\n        \n        # Initial packing\n        self.circles = self.construct_packing()\n        \n        if verbose:\n            print(f\"Initial packing complete: {len(self.circles)} circles placed\")\n            self._print_statistics()\n        \n        # Optimize placement\n        if optimize:\n            if verbose:\n                print(\"\\nOptimizing placement...\")\n            self._optimize_placement(verbose)\n        \n        if verbose:\n            print(\"\\nFinal packing statistics:\")\n            self._print_statistics()\n        \n        return self.circles\n    \n    def _optimize_placement(self, verbose: bool = False):\n        \"\"\"Optimize circle placement using local adjustments.\"\"\"\n        for iteration in range(self.max_iterations):\n            max_adjustment = 0.0\n            \n            for i, circle in enumerate(self.circles):\n                # Calculate repulsion from other circles\n                fx, fy = 0.0, 0.0\n                \n                for j, other in enumerate(self.circles):\n                    if i == j:\n                        continue\n                    \n                    dist = circle.distance_to(other)\n                    min_dist = circle.radius + other.radius\n                    \n                    if dist < min_dist:\n                        # Repulsion force\n                        if dist > 1e-6:\n                            ratio = (min_dist - dist) / dist\n                            fx += (other.x - circle.x) * ratio * 0.5\n                            fy += (other.y - circle.y) * ratio * 0.5\n                \n                # Calculate attraction to center of bounds\n                x_min, y_min, x_max, y_max = self.bounds\n                center_x = (x_min + x_max) / 2\n                center_y = (y_min + y_max) / 2\n                \n                dist_to_center = math.sqrt((circle.x - center_x)**2 + \n                                          (circle.y - center_y)**2)\n                if dist_to_center > 1e-6:\n                    fx += (center_x - circle.x) * 0.01\n                    fy += (center_y - circle.y) * 0.01\n                \n                # Apply adjustment\n                adjustment = math.sqrt(fx**2 + fy**2)\n                max_adjustment = max(max_adjustment, adjustment)\n                \n                # Move circle\n                step_size = 0.1\n                circle.x += fx * step_size\n                circle.y += fy * step_size\n                \n                # Keep within bounds\n                x_min, y_min, x_max, y_max = self.bounds\n                circle.x = max(x_min + circle.radius, \n                              min(x_max - circle.radius, circle.x))\n                circle.y = max(y_min + circle.radius, \n                              min(y_max - circle.radius, circle.y))\n            \n            if verbose and iteration % 100 == 0:\n                print(f\"  Iteration {iteration}: max adjustment = {max_adjustment:.6f}\")\n            \n            if max_adjustment < 1e-4:\n                if verbose:\n                    print(f\"  Converged at iteration {iteration}\")\n                break\n    \n    def _print_statistics(self):\n        \"\"\"Print packing statistics.\"\"\"\n        if not self.circles:\n            return\n        \n        # Check for overlaps\n        overlaps = 0\n        for i, circle in enumerate(self.circles):\n            for j, other in enumerate(self.circles):\n                if i < j and circle.overlaps_with(other):\n                    overlaps += 1\n        \n        # Check bounds violations\n        violations = 0\n        x_min, y_min, x_max, y_max = self.bounds\n        for circle in self.circles:\n            if not circle.is_inside_bounds(x_min, y_min, x_max, y_max):\n                violations += 1\n        \n        total_area = sum(math.pi * c.radius**2 for c in self.circles)\n        bounds_area = (x_max - x_min) * (y_max - y_min)\n        packing_efficiency = (total_area / bounds_area) * 100\n        \n        print(f\"  Circles placed: {len(self.circles)}\")\n        print(f\"  Overlaps: {overlaps}\")\n        print(f\"  Bounds violations: {violations}\")\n        print(f\"  Packing efficiency: {packing_efficiency:.2f}%\")\n        print(f\"  Total circle area: {total_area:.2f}\")\n        print(f\"  Bounds area: {bounds_area:.2f}\")\n    \n    def visualize(self, title: str = \"Circle Packing (Divide-and-Conquer)\"):\n        \"\"\"Visualize the packed circles.\"\"\"\n        fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n        \n        x_min, y_min, x_max, y_max = self.bounds\n        \n        # Draw bounds\n        ax.add_patch(plt.Rectangle((x_min, y_min), x_max - x_min, y_max - y_min,\n                                   fill=False, edgecolor='black', linewidth=2))\n        \n        # Draw circles\n        colors = plt.cm.hsv(np.linspace(0, 1, self.num_circles))\n        \n        for circle in self.circles:\n            circle_patch = plt.Circle((circle.x, circle.y), circle.radius,\n                                     color=colors[circle.id], alpha=0.6,\n                                     edgecolor='black', linewidth=1)\n            ax.add_patch(circle_patch)\n            \n            # Add circle ID\n            ax.text(circle.x, circle.y, str(circle.id), \n                   ha='center', va='center', fontsize=8, fontweight='bold')\n        \n        ax.set_xlim(x_min - 5, x_max + 5)\n        ax.set_ylim(y_min - 5, y_max + 5)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.set_title(title, fontsize=14, fontweight='bold')\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        \n        plt.tight_layout()\n        return fig, ax\n\ndef construct_packing(num_circles: int = 26, \n                     bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n                     optimize: bool = True) -> List[Circle]:\n    \"\"\"\n    Construct a circle packing using divide-and-conquer approach.\n    \n    Args:\n        num_circles: Number of circles to pack\n        bounds: Bounding box (x_min, y_min, x_max, y_max)\n        optimize: Whether to optimize the packing\n    \n    Returns:\n        List of packed circles\n    \"\"\"\n    solver = CirclePackingSolver(num_circles, bounds)\n    return solver.run_packing(optimize=optimize, verbose=False)\n\ndef run_packing(num_circles: int = 26,\n               bounds: Tuple[float, float, float, float] = (0, 0, 100, 100),\n               optimize: bool = True,\n               visualize: bool = True) -> Tuple",
  "timestamp": "2025-12-08T12:15:35.362138",
  "cost_data": null
}