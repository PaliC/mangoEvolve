{
  "trial_id": "trial_2_8",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, LinearConstraint, Bounds\nfrom scipy.spatial.distance import pdist, squareform\n\ndef optimize_circles_better_placement():\n    \"\"\"\n    Optimize circle packing with BETTER INITIAL PLACEMENT strategy.\n    \n    Returns:\n        tuple: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    \n    # =========================================================================\n    # PHASE 0: OPTIMAL 5x6 GRID INITIAL PLACEMENT\n    # =========================================================================\n    \n    # Create 5x6 grid with optimal spacing for unit square\n    cols, rows = 6, 5\n    grid_x = np.linspace(0.1, 0.9, cols)\n    grid_y = np.linspace(0.1, 0.9, rows)\n    \n    centers = []\n    for i, y in enumerate(grid_y):\n        for j, x in enumerate(grid_x):\n            centers.append([x, y])\n    \n    centers = np.array(centers)  # Shape: (30, 2)\n    \n    # Select best 26 positions (remove corners which are less optimal)\n    # Keep interior and edge positions, remove 4 corners\n    distances_to_center = np.linalg.norm(centers - 0.5, axis=1)\n    indices = np.argsort(distances_to_center)[:26]\n    centers = centers[indices]\n    \n    # Small initial radii\n    radii = np.full(26, 0.01)\n    \n    # =========================================================================\n    # PHASE 1: AGGRESSIVE POSITION OPTIMIZATION (fixed small radii)\n    # =========================================================================\n    \n    def objective_positions(x):\n        \"\"\"Maximize minimum distance between centers.\"\"\"\n        c = x.reshape(26, 2)\n        distances = pdist(c)\n        return -np.min(distances) if len(distances) > 0 else 0\n    \n    def constraint_bounds(x):\n        \"\"\"Keep centers in [0,1]x[0,1].\"\"\"\n        c = x.reshape(26, 2)\n        return np.concatenate([\n            c.flatten(),\n            1 - c.flatten()\n        ])\n    \n    # Bounds: 0 <= x,y <= 1\n    bounds_pos = Bounds(\n        lb=np.tile([0, 0], 26),\n        ub=np.tile([1, 1], 26)\n    )\n    \n    # Constraint: all coordinates in [0,1]\n    constraint_pos = LinearConstraint(\n        np.eye(52),\n        lb=0,\n        ub=1\n    )\n    \n    result_pos = minimize(\n        objective_positions,\n        centers.flatten(),\n        method='SLSQP',\n        bounds=bounds_pos,\n        options={'ftol': 1e-8, 'maxiter': 500}\n    )\n    \n    centers = result_pos.x.reshape(26, 2)\n    \n    # =========================================================================\n    # PHASE 2: RADIUS EXPANSION (positions fixed, grow radii)\n    # =========================================================================\n    \n    def objective_radii(r):\n        \"\"\"Maximize sum of radii subject to non-overlap.\"\"\"\n        return -np.sum(r)\n    \n    def constraint_non_overlap(r):\n        \"\"\"Minimum distance constraints: d_ij >= r_i + r_j.\"\"\"\n        distances = squareform(pdist(centers))\n        np.fill_diagonal(distances, np.inf)\n        \n        constraints = []\n        for i in range(26):\n            for j in range(i + 1, 26):\n                # d_ij - r_i - r_j >= 0\n                constraints.append(distances[i, j] - r[i] - r[j])\n        \n        return np.array(constraints) if constraints else np.array([1.0])\n    \n    def constraint_boundary(r):\n        \"\"\"Circles must fit in unit square: center + radius <= 1.\"\"\"\n        constraints = []\n        for i in range(26):\n            # x_i + r_i <= 1\n            constraints.append(1 - centers[i, 0] - r[i])\n            # y_i + r_i <= 1\n            constraints.append(1 - centers[i, 1] - r[i])\n            # x_i - r_i >= 0\n            constraints.append(centers[i, 0] - r[i])\n            # y_i - r_i >= 0\n            constraints.append(centers[i, 1] - r[i])\n        \n        return np.array(constraints)\n    \n    from scipy.optimize import NonlinearConstraint\n    \n    bounds_radii = Bounds(lb=np.full(26, 0.001), ub=np.full(26, 0.5))\n    \n    constraint_overlap = NonlinearConstraint(\n        constraint_non_overlap,\n        lb=0,\n        ub=np.inf\n    )\n    \n    constraint_box = NonlinearConstraint(\n        constraint_boundary,\n        lb=0,\n        ub=np.inf\n    )\n    \n    result_radii = minimize(\n        objective_radii,\n        radii,\n        method='SLSQP',\n        bounds=bounds_radii,\n        constraints=[constraint_overlap, constraint_box],\n        options={'ftol': 1e-8, 'maxiter': 1000}\n    )\n    \n    radii = result_radii.x\n    \n    # =========================================================================\n    # PHASE 3: FINAL LOCAL SEARCH (joint optimization)\n    # =========================================================================\n    \n    def objective_joint(x):\n        \"\"\"Minimize: -sum(radii) + penalty for overlaps.\"\"\"\n        c = x[:52].reshape(26, 2)\n        r = x[52:]\n        \n        # Boundary penalty\n        penalty = 0\n        for i in range(26):\n            penalty += max(0, r[i] - (1 - c[i, 0])) ** 2\n            penalty += max(0, r[i] - (1 - c[i, 1])) ** 2\n            penalty += max(0, -c[i, 0] + r[i]) ** 2\n            penalty += max(0, -c[i, 1] + r[i]) ** 2\n        \n        # Overlap penalty\n        distances = squareform(pdist(c))\n        np.fill_diagonal(distances, np.inf)\n        for i in range(26):\n            for j in range(i + 1, 26):\n                overlap = r[i] + r[j] - distances[i, j]\n                if overlap > 0:\n                    penalty += 100 * overlap ** 2\n        \n        return -np.sum(r) + 10 * penalty\n    \n    x0 = np.concatenate([centers.flatten(), radii])\n    bounds_joint = Bounds(\n        lb=np.concatenate([np.tile([0, 0], 26), np.full(26, 0.001)]),\n        ub=np.concatenate([np.tile([1, 1], 26), np.full(26, 0.5)])\n    )\n    \n    result_joint = minimize(\n        objective_joint,\n        x0,\n        method='SLSQP',\n        bounds=bounds_joint,\n        options={'ftol': 1e-9, 'maxiter': 500}\n    )\n    \n    centers = result_joint.x[:52].reshape(26, 2)\n    radii = result_joint.x[52:]\n    \n    # Ensure non-negative radii\n    radii = np.maximum(radii, 0)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = optimize_circles_better_placement()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"\\nFirst 5 circles:\")\n    for i in range(5):\n        print(f\"  Circle {i}: center=({centers[i,0]:.4f}, {centers[i,1]:.4f}), radius={radii[i]:.4f}\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.1767721176147461,
    "error": "ValueError: Code must define run_packing() or construct_packing()"
  },
  "prompt": "Create optimization with BETTER INITIAL PLACEMENT.\n\nStrategy:\n1. Use OPTIMAL 5x6 grid spacing\n2. Small initial radii (0.01)\n3. SLSQP with aggressive optimization\n4. Radius expansion in separate phase\n5. Final local search\n\nReturn (centers (26,2), radii (26,), sum_radii float).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, LinearConstraint, Bounds\nfrom scipy.spatial.distance import pdist, squareform\n\ndef optimize_circles_better_placement():\n    \"\"\"\n    Optimize circle packing with BETTER INITIAL PLACEMENT strategy.\n    \n    Returns:\n        tuple: (centers (26,2), radii (26,), sum_radii float)\n    \"\"\"\n    \n    # =========================================================================\n    # PHASE 0: OPTIMAL 5x6 GRID INITIAL PLACEMENT\n    # =========================================================================\n    \n    # Create 5x6 grid with optimal spacing for unit square\n    cols, rows = 6, 5\n    grid_x = np.linspace(0.1, 0.9, cols)\n    grid_y = np.linspace(0.1, 0.9, rows)\n    \n    centers = []\n    for i, y in enumerate(grid_y):\n        for j, x in enumerate(grid_x):\n            centers.append([x, y])\n    \n    centers = np.array(centers)  # Shape: (30, 2)\n    \n    # Select best 26 positions (remove corners which are less optimal)\n    # Keep interior and edge positions, remove 4 corners\n    distances_to_center = np.linalg.norm(centers - 0.5, axis=1)\n    indices = np.argsort(distances_to_center)[:26]\n    centers = centers[indices]\n    \n    # Small initial radii\n    radii = np.full(26, 0.01)\n    \n    # =========================================================================\n    # PHASE 1: AGGRESSIVE POSITION OPTIMIZATION (fixed small radii)\n    # =========================================================================\n    \n    def objective_positions(x):\n        \"\"\"Maximize minimum distance between centers.\"\"\"\n        c = x.reshape(26, 2)\n        distances = pdist(c)\n        return -np.min(distances) if len(distances) > 0 else 0\n    \n    def constraint_bounds(x):\n        \"\"\"Keep centers in [0,1]x[0,1].\"\"\"\n        c = x.reshape(26, 2)\n        return np.concatenate([\n            c.flatten(),\n            1 - c.flatten()\n        ])\n    \n    # Bounds: 0 <= x,y <= 1\n    bounds_pos = Bounds(\n        lb=np.tile([0, 0], 26),\n        ub=np.tile([1, 1], 26)\n    )\n    \n    # Constraint: all coordinates in [0,1]\n    constraint_pos = LinearConstraint(\n        np.eye(52),\n        lb=0,\n        ub=1\n    )\n    \n    result_pos = minimize(\n        objective_positions,\n        centers.flatten(),\n        method='SLSQP',\n        bounds=bounds_pos,\n        options={'ftol': 1e-8, 'maxiter': 500}\n    )\n    \n    centers = result_pos.x.reshape(26, 2)\n    \n    # =========================================================================\n    # PHASE 2: RADIUS EXPANSION (positions fixed, grow radii)\n    # =========================================================================\n    \n    def objective_radii(r):\n        \"\"\"Maximize sum of radii subject to non-overlap.\"\"\"\n        return -np.sum(r)\n    \n    def constraint_non_overlap(r):\n        \"\"\"Minimum distance constraints: d_ij >= r_i + r_j.\"\"\"\n        distances = squareform(pdist(centers))\n        np.fill_diagonal(distances, np.inf)\n        \n        constraints = []\n        for i in range(26):\n            for j in range(i + 1, 26):\n                # d_ij - r_i - r_j >= 0\n                constraints.append(distances[i, j] - r[i] - r[j])\n        \n        return np.array(constraints) if constraints else np.array([1.0])\n    \n    def constraint_boundary(r):\n        \"\"\"Circles must fit in unit square: center + radius <= 1.\"\"\"\n        constraints = []\n        for i in range(26):\n            # x_i + r_i <= 1\n            constraints.append(1 - centers[i, 0] - r[i])\n            # y_i + r_i <= 1\n            constraints.append(1 - centers[i, 1] - r[i])\n            # x_i - r_i >= 0\n            constraints.append(centers[i, 0] - r[i])\n            # y_i - r_i >= 0\n            constraints.append(centers[i, 1] - r[i])\n        \n        return np.array(constraints)\n    \n    from scipy.optimize import NonlinearConstraint\n    \n    bounds_radii = Bounds(lb=np.full(26, 0.001), ub=np.full(26, 0.5))\n    \n    constraint_overlap = NonlinearConstraint(\n        constraint_non_overlap,\n        lb=0,\n        ub=np.inf\n    )\n    \n    constraint_box = NonlinearConstraint(\n        constraint_boundary,\n        lb=0,\n        ub=np.inf\n    )\n    \n    result_radii = minimize(\n        objective_radii,\n        radii,\n        method='SLSQP',\n        bounds=bounds_radii,\n        constraints=[constraint_overlap, constraint_box],\n        options={'ftol': 1e-8, 'maxiter': 1000}\n    )\n    \n    radii = result_radii.x\n    \n    # =========================================================================\n    # PHASE 3: FINAL LOCAL SEARCH (joint optimization)\n    # =========================================================================\n    \n    def objective_joint(x):\n        \"\"\"Minimize: -sum(radii) + penalty for overlaps.\"\"\"\n        c = x[:52].reshape(26, 2)\n        r = x[52:]\n        \n        # Boundary penalty\n        penalty = 0\n        for i in range(26):\n            penalty += max(0, r[i] - (1 - c[i, 0])) ** 2\n            penalty += max(0, r[i] - (1 - c[i, 1])) ** 2\n            penalty += max(0, -c[i, 0] + r[i]) ** 2\n            penalty += max(0, -c[i, 1] + r[i]) ** 2\n        \n        # Overlap penalty\n        distances = squareform(pdist(c))\n        np.fill_diagonal(distances, np.inf)\n        for i in range(26):\n            for j in range(i + 1, 26):\n                overlap = r[i] + r[j] - distances[i, j]\n                if overlap > 0:\n                    penalty += 100 * overlap ** 2\n        \n        return -np.sum(r) + 10 * penalty\n    \n    x0 = np.concatenate([centers.flatten(), radii])\n    bounds_joint = Bounds(\n        lb=np.concatenate([np.tile([0, 0], 26), np.full(26, 0.001)]),\n        ub=np.concatenate([np.tile([1, 1], 26), np.full(26, 0.5)])\n    )\n    \n    result_joint = minimize(\n        objective_joint,\n        x0,\n        method='SLSQP',\n        bounds=bounds_joint,\n        options={'ftol': 1e-9, 'maxiter': 500}\n    )\n    \n    centers = result_joint.x[:52].reshape(26, 2)\n    radii = result_joint.x[52:]\n    \n    # Ensure non-negative radii\n    radii = np.maximum(radii, 0)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = optimize_circles_better_placement()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Centers shape: {centers.shape}\")\n    print(f\"Radii shape: {radii.shape}\")\n    print(f\"\\nFirst 5 circles:\")\n    for i in range(5):\n        print(f\"  Circle {i}: center=({centers[i,0]:.4f}, {centers[i,1]:.4f}), radius={radii[i]:.4f}\")\n```\n\n**Key Improvements:**\n\n1. **Better Initial Placement**: 5\u00d76 grid with optimal spacing, selecting 26 best-positioned points\n2. **3-Phase Optimization**:\n   - Phase 1: Position optimization (maximize minimum distance)\n   - Phase 2: Radius expansion (maximize sum with non-overlap constraints)\n   - Phase 3: Joint refinement (fine-tune both positions and radii)\n3. **Aggressive SLSQP**: High precision tolerance (1e-8 to 1e-9)\n4. **Proper Constraints**: Boundary and non-overlap constraints\n5. **Expected Result**: ~0.50-0.55 sum of radii",
  "reasoning": "**Key Improvements:**\n\n1. **Better Initial Placement**: 5\u00d76 grid with optimal spacing, selecting 26 best-positioned points\n2. **3-Phase Optimization**:\n   - Phase 1: Position optimization (maximize minimum distance)\n   - Phase 2: Radius expansion (maximize sum with non-overlap constraints)\n   - Phase 3: Joint refinement (fine-tune both positions and radii)\n3. **Aggressive SLSQP**: High precision tolerance (1e-8 to 1e-9)\n4. **Proper Constraints**: Boundary and non-overlap constraints\n5. **Expected Result**: ~0.50-0.55 sum of radii",
  "timestamp": "2025-12-08T12:22:48.867131",
  "cost_data": null
}