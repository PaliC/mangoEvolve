{
  "trial_id": "trial_2_2",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, LinearConstraint, Bounds\nfrom scipy.spatial.distance import cdist\n\ndef improve_hexagonal_grid():\n    \"\"\"Improved hexagonal grid approach with better spacing and optimization.\"\"\"\n    \n    # 1. BETTER HEXAGONAL SPACING CALCULATION\n    # Create optimal hexagonal packing for 26 circles\n    # Arrange in hexagonal pattern: 1 + 6 + 12 + 7 = 26\n    centers = []\n    \n    # Center circle\n    centers.append([0.0, 0.0])\n    \n    # First ring: 6 circles\n    for i in range(6):\n        angle = i * np.pi / 3\n        centers.append([np.cos(angle), np.sin(angle)])\n    \n    # Second ring: 12 circles\n    for i in range(12):\n        angle = i * np.pi / 6\n        radius = 2.0\n        centers.append([radius * np.cos(angle), radius * np.sin(angle)])\n    \n    # Third ring: 7 circles (partial ring)\n    for i in range(7):\n        angle = i * np.pi / 3\n        radius = 3.0 * np.sqrt(3) / 2\n        centers.append([radius * np.cos(angle), radius * np.sin(angle)])\n    \n    centers = np.array(centers, dtype=float)\n    n = len(centers)\n    \n    # Initial radii - equal distribution\n    initial_radii = np.ones(n) * 0.3\n    \n    # 2. OPTIMIZE CENTER POSITIONS FIRST\n    def position_objective(x):\n        \"\"\"Minimize overlap while keeping centers in reasonable bounds.\"\"\"\n        centers_flat = x.reshape(n, 2)\n        distances = cdist(centers_flat, centers_flat)\n        np.fill_diagonal(distances, np.inf)\n        \n        # Penalize centers that are too close\n        min_distances = np.min(distances, axis=1)\n        overlap_penalty = np.sum(np.maximum(0, 2.0 - min_distances) ** 2)\n        \n        # Keep centers in [-5, 5] range\n        boundary_penalty = np.sum(np.maximum(0, np.abs(centers_flat) - 5.0) ** 2)\n        \n        return overlap_penalty + 0.1 * boundary_penalty\n    \n    # Optimize positions\n    bounds_pos = Bounds([-5]*2*n, [5]*2*n)\n    result_pos = minimize(\n        position_objective,\n        centers.flatten(),\n        method='L-BFGS-B',\n        bounds=bounds_pos,\n        options={'ftol': 1e-6, 'maxiter': 200}\n    )\n    centers = result_pos.x.reshape(n, 2)\n    \n    # 3. AGGRESSIVE OVERLAP RESOLUTION LOOP\n    max_iterations = 50\n    for iteration in range(max_iterations):\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        # Find overlapping pairs\n        overlaps = distances < 2.0\n        overlapping_pairs = np.argwhere(overlaps)\n        \n        if len(overlapping_pairs) == 0:\n            break\n        \n        # Push overlapping circles apart\n        for i, j in overlapping_pairs:\n            if i < j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < 1e-6:\n                    dist = 1e-6\n                \n                direction = (centers[j] - centers[i]) / dist\n                push_distance = (2.0 - dist) / 2 + 0.01\n                \n                centers[i] -= direction * push_distance\n                centers[j] += direction * push_distance\n    \n    # 4. RADIUS OPTIMIZATION WITH CONSTRAINTS\n    def radius_objective(radii):\n        \"\"\"Maximize sum of radii while maintaining non-overlap.\"\"\"\n        return -np.sum(radii)  # Negative because we minimize\n    \n    def constraint_non_overlap(radii):\n        \"\"\"Ensure circles don't overlap: dist >= r_i + r_j.\"\"\"\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                # dist[i,j] >= radii[i] + radii[j]\n                # -> radii[i] + radii[j] <= dist[i,j]\n                constraints.append(distances[i, j] - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    from scipy.optimize import NonlinearConstraint\n    \n    # Initial radii\n    radii = initial_radii.copy()\n    \n    # Optimize radii with non-overlap constraints\n    bounds_radii = Bounds([0.01]*n, [3.0]*n)\n    \n    constraint = NonlinearConstraint(constraint_non_overlap, 0, np.inf)\n    \n    result_radii = minimize(\n        radius_objective,\n        radii,\n        method='SLSQP',\n        bounds=bounds_radii,\n        constraints=constraint,\n        options={'ftol': 1e-7, 'maxiter': 300}\n    )\n    \n    radii = result_radii.x\n    \n    # 5. RADIUS EXPANSION PHASE\n    # Try to expand radii further without creating overlaps\n    for _ in range(10):\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        # For each circle, find maximum safe radius\n        for i in range(n):\n            min_available = np.min(distances[i, :]) / 2\n            max_safe_radius = min_available - np.mean([radii[j] for j in range(n) if j != i]) / n\n            \n            radii[i] = min(radii[i] * 1.01, max_safe_radius * 0.99)\n        \n        radii = np.maximum(radii, 0.01)\n    \n    # Final constraint satisfaction check\n    distances = cdist(centers, centers)\n    for i in range(n):\n        for j in range(i+1, n):\n            max_sum = distances[i, j] - 1e-6\n            current_sum = radii[i] + radii[j]\n            if current_sum > max_sum:\n                scale = max_sum / current_sum\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    radii = np.maximum(radii, 0.01)\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.2599630355834961,
    "error": "ValueError: Code must define run_packing() or construct_packing()"
  },
  "prompt": "Improve trial_1_0's hexagonal grid approach. Achieved 1.8423.\n\nCurrent approach:\n- Hexagonal grid centers\n- scipy.optimize with constraints\n- Overlap reduction loop\n\nIMPROVEMENTS:\n1. Better hexagonal spacing calculation\n2. Optimize center positions before radii optimization\n3. Use more aggressive overlap resolution\n4. Add radius expansion phase after position optimization\n5. Implement better constraint formulation\n\nReturn (centers (26,2), radii (26,), sum_radii float).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, LinearConstraint, Bounds\nfrom scipy.spatial.distance import cdist\n\ndef improve_hexagonal_grid():\n    \"\"\"Improved hexagonal grid approach with better spacing and optimization.\"\"\"\n    \n    # 1. BETTER HEXAGONAL SPACING CALCULATION\n    # Create optimal hexagonal packing for 26 circles\n    # Arrange in hexagonal pattern: 1 + 6 + 12 + 7 = 26\n    centers = []\n    \n    # Center circle\n    centers.append([0.0, 0.0])\n    \n    # First ring: 6 circles\n    for i in range(6):\n        angle = i * np.pi / 3\n        centers.append([np.cos(angle), np.sin(angle)])\n    \n    # Second ring: 12 circles\n    for i in range(12):\n        angle = i * np.pi / 6\n        radius = 2.0\n        centers.append([radius * np.cos(angle), radius * np.sin(angle)])\n    \n    # Third ring: 7 circles (partial ring)\n    for i in range(7):\n        angle = i * np.pi / 3\n        radius = 3.0 * np.sqrt(3) / 2\n        centers.append([radius * np.cos(angle), radius * np.sin(angle)])\n    \n    centers = np.array(centers, dtype=float)\n    n = len(centers)\n    \n    # Initial radii - equal distribution\n    initial_radii = np.ones(n) * 0.3\n    \n    # 2. OPTIMIZE CENTER POSITIONS FIRST\n    def position_objective(x):\n        \"\"\"Minimize overlap while keeping centers in reasonable bounds.\"\"\"\n        centers_flat = x.reshape(n, 2)\n        distances = cdist(centers_flat, centers_flat)\n        np.fill_diagonal(distances, np.inf)\n        \n        # Penalize centers that are too close\n        min_distances = np.min(distances, axis=1)\n        overlap_penalty = np.sum(np.maximum(0, 2.0 - min_distances) ** 2)\n        \n        # Keep centers in [-5, 5] range\n        boundary_penalty = np.sum(np.maximum(0, np.abs(centers_flat) - 5.0) ** 2)\n        \n        return overlap_penalty + 0.1 * boundary_penalty\n    \n    # Optimize positions\n    bounds_pos = Bounds([-5]*2*n, [5]*2*n)\n    result_pos = minimize(\n        position_objective,\n        centers.flatten(),\n        method='L-BFGS-B',\n        bounds=bounds_pos,\n        options={'ftol': 1e-6, 'maxiter': 200}\n    )\n    centers = result_pos.x.reshape(n, 2)\n    \n    # 3. AGGRESSIVE OVERLAP RESOLUTION LOOP\n    max_iterations = 50\n    for iteration in range(max_iterations):\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        # Find overlapping pairs\n        overlaps = distances < 2.0\n        overlapping_pairs = np.argwhere(overlaps)\n        \n        if len(overlapping_pairs) == 0:\n            break\n        \n        # Push overlapping circles apart\n        for i, j in overlapping_pairs:\n            if i < j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < 1e-6:\n                    dist = 1e-6\n                \n                direction = (centers[j] - centers[i]) / dist\n                push_distance = (2.0 - dist) / 2 + 0.01\n                \n                centers[i] -= direction * push_distance\n                centers[j] += direction * push_distance\n    \n    # 4. RADIUS OPTIMIZATION WITH CONSTRAINTS\n    def radius_objective(radii):\n        \"\"\"Maximize sum of radii while maintaining non-overlap.\"\"\"\n        return -np.sum(radii)  # Negative because we minimize\n    \n    def constraint_non_overlap(radii):\n        \"\"\"Ensure circles don't overlap: dist >= r_i + r_j.\"\"\"\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i+1, n):\n                # dist[i,j] >= radii[i] + radii[j]\n                # -> radii[i] + radii[j] <= dist[i,j]\n                constraints.append(distances[i, j] - radii[i] - radii[j])\n        \n        return np.array(constraints)\n    \n    from scipy.optimize import NonlinearConstraint\n    \n    # Initial radii\n    radii = initial_radii.copy()\n    \n    # Optimize radii with non-overlap constraints\n    bounds_radii = Bounds([0.01]*n, [3.0]*n)\n    \n    constraint = NonlinearConstraint(constraint_non_overlap, 0, np.inf)\n    \n    result_radii = minimize(\n        radius_objective,\n        radii,\n        method='SLSQP',\n        bounds=bounds_radii,\n        constraints=constraint,\n        options={'ftol': 1e-7, 'maxiter': 300}\n    )\n    \n    radii = result_radii.x\n    \n    # 5. RADIUS EXPANSION PHASE\n    # Try to expand radii further without creating overlaps\n    for _ in range(10):\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        \n        # For each circle, find maximum safe radius\n        for i in range(n):\n            min_available = np.min(distances[i, :]) / 2\n            max_safe_radius = min_available - np.mean([radii[j] for j in range(n) if j != i]) / n\n            \n            radii[i] = min(radii[i] * 1.01, max_safe_radius * 0.99)\n        \n        radii = np.maximum(radii, 0.01)\n    \n    # Final constraint satisfaction check\n    distances = cdist(centers, centers)\n    for i in range(n):\n        for j in range(i+1, n):\n            max_sum = distances[i, j] - 1e-6\n            current_sum = radii[i] + radii[j]\n            if current_sum > max_sum:\n                scale = max_sum / current_sum\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    radii = np.maximum(radii, 0.01)\n    sum_radii = float(np.sum(radii))\n    \n    return centers, radii, sum_radii\n```\n\n**Key improvements:**\n\n1. **Better hexagonal spacing**: Proper 1-6-12-7 arrangement based on hexagonal geometry\n2. **Two-phase optimization**: Position optimization first (removes overlap), then radius optimization\n3. **Aggressive overlap resolution**: Iterative pushing of overlapping circles with safety margin\n4. **NonlinearConstraint**: Proper constraint formulation ensuring non-overlap during radius optimization\n5. **Expansion phase**: Incremental radius growth after optimization to capture remaining capacity\n6. **Constraint satisfaction**: Final pass to ensure all constraints are met\n\nExpected improvement: **1.8423 \u2192 ~2.1-2.3** depending on hexagonal arrangement quality.",
  "reasoning": "**Key improvements:**\n\n1. **Better hexagonal spacing**: Proper 1-6-12-7 arrangement based on hexagonal geometry\n2. **Two-phase optimization**: Position optimization first (removes overlap), then radius optimization\n3. **Aggressive overlap resolution**: Iterative pushing of overlapping circles with safety margin\n4. **NonlinearConstraint**: Proper constraint formulation ensuring non-overlap during radius optimization\n5. **Expansion phase**: Incremental radius growth after optimization to capture remaining capacity\n6. **Constraint satisfaction**: Final pass to ensure all constraints are met\n\nExpected improvement: **1.8423 \u2192 ~2.1-2.3** depending on hexagonal arrangement quality.",
  "timestamp": "2025-12-08T12:22:48.291896",
  "cost_data": null
}