{
  "trial_id": "trial_1_2",
  "generation": 1,
  "parent_id": "trial_0_8",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # 1. Force-directed relaxation (Repulsion logic) \n    # To find a well-distributed initial configuration\n    side = 5\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n    # Add 26th point\n    centers = np.vstack([centers, [0.5, 0.5]])\n    \n    # Simple repulsion simulation\n    iters = 150\n    dt = 0.05\n    for _ in range(iters):\n        forces = np.zeros_like(centers)\n        for i in range(n):\n            # Repulsion from other points\n            for j in range(n):\n                if i == j: continue\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff) + 1e-9\n                if dist < 0.25:\n                    forces[i] += (diff / dist) * (0.25 - dist)\n            \n            # Repulsion from boundaries\n            forces[i, 0] += 1.0 / (centers[i, 0] + 1e-2) - 1.0 / (1.0 - centers[i, 0] + 1e-2)\n            forces[i, 1] += 1.0 / (centers[i, 1] + 1e-2) - 1.0 / (1.0 - centers[i, 1] + 1e-2)\n            \n        centers += forces * dt\n        centers = np.clip(centers, 0.05, 0.95)\n\n    # 2. Optimization: Maximize sum of radii\n    # Variables: [x1, y1, ..., xn, yn, r1, r2, ..., rn]\n    initial_r = np.full(n, 0.09)\n    initial_guess = np.concatenate([centers.flatten(), initial_r])\n\n    def objective(vars):\n        # Maximize sum(r) -> minimize -sum(r)\n        return -np.sum(vars[2*n:])\n\n    def constraints(vars):\n        pts = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        \n        # Pre-allocate constraints for efficiency\n        # Overlaps: n*(n-1)/2, Boundaries: 4*n, Positivity: n\n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(num_overlap + 5 * n)\n        \n        idx = 0\n        # Overlap constraints: dist - (ri + rj) >= 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((pts[i] - pts[j])**2))\n                cons[idx] = dist - (radii[i] + radii[j])\n                idx += 1\n        \n        # Boundary and positivity constraints\n        for i in range(n):\n            cons[idx] = pts[i, 0] - radii[i]           # x >= r\n            cons[idx+1] = 1.0 - pts[i, 0] - radii[i]  # x <= 1-r\n            cons[idx+2] = pts[i, 1] - radii[i]           # y >= r\n            cons[idx+3] = 1.0 - pts[i, 1] - radii[i]  # y <= 1-r\n            cons[idx+4] = radii[i]                       # r >= 0\n            idx += 5\n            \n        return cons\n\n    # Optimize using SLSQP\n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 250, 'ftol': 1e-8}\n    )\n\n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    sum_radii = np.sum(final_radii)\n\n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.567284124374028,
    "eval_time": 2.661916971206665,
    "error": null
  },
  "prompt": "Take the force-directed logic from import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    # 1. Initial configuration: Grid-like start in a slightly larger space\n    # to avoid immediate overlap singularities.\n    side = int(np.ceil(np.sqrt(n)))\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.flatten()[:n], yv.flatten()[:n]], axis=1)\n    \n    # 2. Force-directed relaxation (Shrinking Boundaries logic)\n    # We simulate repulsion to spread circles evenly.\n    iters = 100\n    dt = 0.02\n    for _ in range(iters):\n        forces = np.zeros_like(centers)\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist_sq = np.sum(diff**2)\n                dist = np.sqrt(dist_sq) + 1e-9\n                if dist < 0.2: # Interaction radius\n                    f = (diff / dist) * (0.2 - dist)\n                    forces[i] += f\n                    forces[j] -= f\n        centers += forces * dt\n        # Constrain to [0.05, 0.95] to leave room for radii\n        centers = np.clip(centers, 0.05, 0.95)\n\n    # 3. Optimization: Maximize sum of radii\n    # Variables: [x1, y1, ..., xn, yn, r1, r2, ..., rn]\n    initial_r = np.full(n, 0.1)\n    initial_guess = np.concatenate([centers.flatten(), initial_r])\n\n    def objective(vars):\n        # We want to maximize sum(r), so minimize -sum(r)\n        return -np.sum(vars[2*n:])\n\n    def constraints(vars):\n        c_pts = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        cons = []\n        # No overlap: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c_pts[i] - c_pts[j])**2))\n                cons.append(dist - (radii[i] + radii[j]))\n            # Within boundaries: ri <= xi <= 1-ri and ri <= yi <= 1-ri\n            cons.append(c_pts[i, 0] - radii[i])\n            cons.append(1.0 - radii[i] - c_pts[i, 0])\n            cons.append(c_pts[i, 1] - radii[i])\n            cons.append(1.0 - radii[i] - c_pts[i, 1])\n            # Positive radii\n            cons.append(radii[i])\n        return np.array(cons)\n\n    # Using SLSQP for constrained optimization\n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n\n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    sum_radii = np.sum(final_radii)\n\n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing() and combine it with the staged optimization of import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # Stage 1: Find a good initial configuration for equal radii\n    # We use a known approximate layout for n=26 (roughly 5x5 + 1)\n    # Target r for equal packing is ~0.0926\n    grid_size = 5\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.vstack([xv.ravel(), yv.ravel()])\n    # Add the 26th point near a corner\n    centers = np.hstack([centers, [[0.95], [0.95]]]).T \n    \n    # Stage 2: Maximize global r\n    def objective_r(params):\n        return -params[-1] # maximize r\n\n    def constraints_r(params):\n        pts = params[:-1].reshape((n, 2))\n        r = params[-1]\n        cons = []\n        # Boundary constraints\n        cons.extend((pts - r).flatten())\n        cons.extend((1 - r - pts).flatten())\n        # Non-overlap\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(pts[i] - pts[j])\n                cons.append(dist - 2*r)\n        return np.array(cons)\n\n    init_r = 0.08\n    init_params = np.hstack([centers.flatten(), init_r])\n    \n    res_r = minimize(objective_r, init_params, method='SLSQP', \n                     constraints={'type': 'ineq', 'fun': constraints_r},\n                     options={'maxiter': 100})\n    \n    # Stage 3: Maximize sum of individual radii\n    # Start from the best equal-radius configuration found\n    refined_pts = res_r.x[:-1].reshape((n, 2))\n    refined_r = np.full(n, res_r.x[-1])\n    \n    def objective_sum(params):\n        r_indiv = params[2*n:]\n        return -np.sum(r_indiv)\n\n    def constraints_sum(params):\n        pts = params[:2*n].reshape((n, 2))\n        r_indiv = params[2*n:]\n        cons = []\n        # Boundary\n        for i in range(n):\n            cons.append(pts[i, 0] - r_indiv[i])\n            cons.append(pts[i, 1] - r_indiv[i])\n            cons.append(1.0 - pts[i, 0] - r_indiv[i])\n            cons.append(1.0 - pts[i, 1] - r_indiv[i])\n        # Non-overlap\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(pts[i] - pts[j])\n                cons.append(dist - (r_indiv[i] + r_indiv[j]))\n        return np.array(cons)\n\n    init_params_sum = np.hstack([refined_pts.flatten(), refined_r])\n    \n    # Use SLSQP to allow radii to grow into gaps\n    res_sum = minimize(objective_sum, init_params_sum, method='SLSQP',\n                       constraints={'type': 'ineq', 'fun': constraints_sum},\n                       options={'maxiter': 200, 'ftol': 1e-7})\n\n    final_params = res_sum.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n    total_sum = np.sum(final_radii)\n\n    return final_centers, final_radii, total_sum\n\ndef run_packing():\n    return construct_packing(). Use the shrinking boundary/repulsion simulation to find a good layout, then pass that layout to a solver that maximizes the sum of radii. Ensure radii constraints are r >= 0.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    n = 26\n    \n    # 1. Force-directed relaxation (Repulsion logic) \n    # To find a well-distributed initial configuration\n    side = 5\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.flatten(), yv.flatten()], axis=1)\n    # Add 26th point\n    centers = np.vstack([centers, [0.5, 0.5]])\n    \n    # Simple repulsion simulation\n    iters = 150\n    dt = 0.05\n    for _ in range(iters):\n        forces = np.zeros_like(centers)\n        for i in range(n):\n            # Repulsion from other points\n            for j in range(n):\n                if i == j: continue\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff) + 1e-9\n                if dist < 0.25:\n                    forces[i] += (diff / dist) * (0.25 - dist)\n            \n            # Repulsion from boundaries\n            forces[i, 0] += 1.0 / (centers[i, 0] + 1e-2) - 1.0 / (1.0 - centers[i, 0] + 1e-2)\n            forces[i, 1] += 1.0 / (centers[i, 1] + 1e-2) - 1.0 / (1.0 - centers[i, 1] + 1e-2)\n            \n        centers += forces * dt\n        centers = np.clip(centers, 0.05, 0.95)\n\n    # 2. Optimization: Maximize sum of radii\n    # Variables: [x1, y1, ..., xn, yn, r1, r2, ..., rn]\n    initial_r = np.full(n, 0.09)\n    initial_guess = np.concatenate([centers.flatten(), initial_r])\n\n    def objective(vars):\n        # Maximize sum(r) -> minimize -sum(r)\n        return -np.sum(vars[2*n:])\n\n    def constraints(vars):\n        pts = vars[:2*n].reshape((n, 2))\n        radii = vars[2*n:]\n        \n        # Pre-allocate constraints for efficiency\n        # Overlaps: n*(n-1)/2, Boundaries: 4*n, Positivity: n\n        num_overlap = n * (n - 1) // 2\n        cons = np.zeros(num_overlap + 5 * n)\n        \n        idx = 0\n        # Overlap constraints: dist - (ri + rj) >= 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((pts[i] - pts[j])**2))\n                cons[idx] = dist - (radii[i] + radii[j])\n                idx += 1\n        \n        # Boundary and positivity constraints\n        for i in range(n):\n            cons[idx] = pts[i, 0] - radii[i]           # x >= r\n            cons[idx+1] = 1.0 - pts[i, 0] - radii[i]  # x <= 1-r\n            cons[idx+2] = pts[i, 1] - radii[i]           # y >= r\n            cons[idx+3] = 1.0 - pts[i, 1] - radii[i]  # y <= 1-r\n            cons[idx+4] = radii[i]                       # r >= 0\n            idx += 5\n            \n        return cons\n\n    # Optimize using SLSQP\n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 250, 'ftol': 1e-8}\n    )\n\n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    sum_radii = np.sum(final_radii)\n\n    return final_centers, final_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-29T16:49:39.760340",
  "cost_data": null
}