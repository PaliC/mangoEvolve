{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Initialize positions in a grid pattern with some randomness\n    grid_size = int(np.ceil(np.sqrt(n)))\n    positions = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n        y = (row + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n        positions.append([x, y])\n    \n    centers = np.array(positions)\n    radii = np.full(n, 0.02)  # Start with small radii\n    \n    # Physics simulation parameters\n    dt = 0.01\n    damping = 0.9\n    velocities = np.zeros((n, 2))\n    \n    # Force weights\n    repulsion_strength = 0.5\n    boundary_strength = 1.0\n    expansion_rate = 0.0002\n    \n    max_iterations = 10000\n    \n    for iteration in range(max_iterations):\n        forces = np.zeros((n, 2))\n        radius_forces = np.zeros(n)\n        \n        # 1. Repulsive forces between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist + 0.01:  # Add small buffer\n                    if dist > 1e-6:\n                        overlap = min_dist - dist\n                        direction = diff / dist\n                        force = repulsion_strength * overlap * direction\n                        forces[i] += force\n                        forces[j] -= force\n                        \n                        # Also apply radius reduction force when overlapping\n                        radius_forces[i] -= overlap * 0.1\n                        radius_forces[j] -= overlap * 0.1\n        \n        # 2. Boundary forces (keep circles inside [0,1]x[0,1])\n        for i in range(n):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 0]\n                forces[i, 0] += boundary_strength * penetration\n                radius_forces[i] -= penetration * 0.2\n            \n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                penetration = centers[i, 0] + radii[i] - 1\n                forces[i, 0] -= boundary_strength * penetration\n                radius_forces[i] -= penetration * 0.2\n            \n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 1]\n                forces[i, 1] += boundary_strength * penetration\n                radius_forces[i] -= penetration * 0.2\n            \n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                penetration = centers[i, 1] + radii[i] - 1\n                forces[i, 1] -= boundary_strength * penetration\n                radius_forces[i] -= penetration * 0.2\n        \n        # 3. Expansion pressure (try to increase radii)\n        radius_forces += expansion_rate\n        \n        # Update velocities and positions\n        velocities += forces * dt\n        velocities *= damping\n        centers += velocities * dt\n        \n        # Update radii\n        radii += radius_forces * dt\n        radii = np.maximum(radii, 0.001)  # Minimum radius\n        \n        # Clamp positions to be well within bounds\n        for i in range(n):\n            centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n            centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n        \n        # Check for equilibrium every 100 iterations\n        if iteration % 100 == 0:\n            max_force = np.max(np.abs(forces))\n            max_radius_force = np.max(np.abs(radius_forces))\n            \n            if max_force < 1e-4 and max_radius_force < 1e-5:\n                break\n    \n    # Final validation and adjustment\n    for _ in range(100):\n        adjusted = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    # Shrink both radii slightly\n                    shrink = (min_dist - dist) / 2 + 0.0001\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n                    adjusted = True\n            \n            # Check boundaries\n            if centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1:\n                radii[i] = min(centers[i, 0], 1 - centers[i, 0]) - 0.0001\n                adjusted = True\n            if centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1:\n                radii[i] = min(centers[i, 1], 1 - centers[i, 1]) - 0.0001\n                adjusted = True\n        \n        if not adjusted:\n            break\n    \n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.0400000000000127,
    "target_ratio": 0.3946869070208777,
    "combined_score": 0.3946869070208777,
    "eval_time": 5.470780849456787,
    "error": null
  },
  "prompt": "Write a force-directed circle packing using physics simulation for 26 circles in [0,1]x[0,1].\n\nProblem: Pack 26 circles to maximize sum of radii.\nConstraints: All circles inside [0,1]x[0,1], no overlaps, non-negative radii.\n\nStrategy: Simulate physical forces:\n- Initialize circles with some radii and positions\n- Apply repulsive forces between overlapping circles\n- Apply forces from boundaries to keep circles inside\n- Apply forces to increase radii (expansion pressure)\n- Iterate until equilibrium\n- Balance between maximizing radii and preventing overlaps\n\nRequired functions:\n```python\nimport numpy as np\n\ndef construct_packing():\n    # Initialize positions and radii\n    # Simulate forces iteratively:\n    #   - Repulsion between overlapping circles\n    #   - Boundary repulsion\n    #   - Radius expansion pressure\n    # Return equilibrium centers, radii, sum_radii\n    pass\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Initialize positions in a grid pattern with some randomness\n    grid_size = int(np.ceil(np.sqrt(n)))\n    positions = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n        y = (row + 0.5) / grid_size + np.random.uniform(-0.05, 0.05)\n        positions.append([x, y])\n    \n    centers = np.array(positions)\n    radii = np.full(n, 0.02)  # Start with small radii\n    \n    # Physics simulation parameters\n    dt = 0.01\n    damping = 0.9\n    velocities = np.zeros((n, 2))\n    \n    # Force weights\n    repulsion_strength = 0.5\n    boundary_strength = 1.0\n    expansion_rate = 0.0002\n    \n    max_iterations = 10000\n    \n    for iteration in range(max_iterations):\n        forces = np.zeros((n, 2))\n        radius_forces = np.zeros(n)\n        \n        # 1. Repulsive forces between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                min_dist = radii[i] + radii[j]\n                \n                if dist < min_dist + 0.01:  # Add small buffer\n                    if dist > 1e-6:\n                        overlap = min_dist - dist\n                        direction = diff / dist\n                        force = repulsion_strength * overlap * direction\n                        forces[i] += force\n                        forces[j] -= force\n                        \n                        # Also apply radius reduction force when overlapping\n                        radius_forces[i] -= overlap * 0.1\n                        radius_forces[j] -= overlap * 0.1\n        \n        # 2. Boundary forces (keep circles inside [0,1]x[0,1])\n        for i in range(n):\n            # Left boundary\n            if centers[i, 0] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 0]\n                forces[i, 0] += boundary_strength * penetration\n                radius_forces[i] -= penetration * 0.2\n            \n            # Right boundary\n            if centers[i, 0] + radii[i] > 1:\n                penetration = centers[i, 0] + radii[i] - 1\n                forces[i, 0] -= boundary_strength * penetration\n                radius_forces[i] -= penetration * 0.2\n            \n            # Bottom boundary\n            if centers[i, 1] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 1]\n                forces[i, 1] += boundary_strength * penetration\n                radius_forces[i] -= penetration * 0.2\n            \n            # Top boundary\n            if centers[i, 1] + radii[i] > 1:\n                penetration = centers[i, 1] + radii[i] - 1\n                forces[i, 1] -= boundary_strength * penetration\n                radius_forces[i] -= penetration * 0.2\n        \n        # 3. Expansion pressure (try to increase radii)\n        radius_forces += expansion_rate\n        \n        # Update velocities and positions\n        velocities += forces * dt\n        velocities *= damping\n        centers += velocities * dt\n        \n        # Update radii\n        radii += radius_forces * dt\n        radii = np.maximum(radii, 0.001)  # Minimum radius\n        \n        # Clamp positions to be well within bounds\n        for i in range(n):\n            centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n            centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n        \n        # Check for equilibrium every 100 iterations\n        if iteration % 100 == 0:\n            max_force = np.max(np.abs(forces))\n            max_radius_force = np.max(np.abs(radius_forces))\n            \n            if max_force < 1e-4 and max_radius_force < 1e-5:\n                break\n    \n    # Final validation and adjustment\n    for _ in range(100):\n        adjusted = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    # Shrink both radii slightly\n                    shrink = (min_dist - dist) / 2 + 0.0001\n                    radii[i] -= shrink\n                    radii[j] -= shrink\n                    adjusted = True\n            \n            # Check boundaries\n            if centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1:\n                radii[i] = min(centers[i, 0], 1 - centers[i, 0]) - 0.0001\n                adjusted = True\n            if centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1:\n                radii[i] = min(centers[i, 1], 1 - centers[i, 1]) - 0.0001\n                adjusted = True\n        \n        if not adjusted:\n            break\n    \n    radii = np.maximum(radii, 0)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T14:22:10.213409",
  "cost_data": null
}