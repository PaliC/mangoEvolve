{
  "trial_id": "trial_1_8",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.spatial import Voronoi\nimport math\n\ndef multi_strategy_hybrid_packing():\n    \"\"\"\n    Multi-strategy approach combining 5 different initializations\n    with LP optimization followed by gradient refinement.\n    \"\"\"\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid (no overlaps, within container)\"\"\"\n        n = len(centers)\n        # Check container constraints\n        for i in range(n):\n            if np.sqrt(centers[i, 0]**2 + centers[i, 1]**2) + radii[i] > 2.0 + 1e-6:\n                return False\n        # Check circle separation\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        return True\n    \n    def optimize_radii_lp(centers, min_radius=0.01):\n        \"\"\"Optimize radii using Linear Programming\"\"\"\n        n = len(centers)\n        \n        # Objective: maximize sum of radii (minimize negative sum)\n        c = -np.ones(n)\n        \n        # Inequality constraints: A_ub @ r <= b_ub\n        constraints = []\n        \n        # Container constraints: r_i <= 2 - ||c_i||\n        for i in range(n):\n            dist_to_origin = np.sqrt(centers[i, 0]**2 + centers[i, 1]**2)\n            a = np.zeros(n)\n            a[i] = 1\n            constraints.append((a, 2.0 - dist_to_origin))\n        \n        # Separation constraints: r_i + r_j <= ||c_i - c_j||\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                a = np.zeros(n)\n                a[i] = 1\n                a[j] = 1\n                constraints.append((a, dist))\n        \n        A_ub = np.array([c[0] for c in constraints])\n        b_ub = np.array([c[1] for c in constraints])\n        \n        # Bounds: r_i >= min_radius\n        bounds = [(min_radius, None) for _ in range(n)]\n        \n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if result.success:\n            return result.x\n        return np.full(n, min_radius)\n    \n    def gradient_optimize(centers_init, radii_init, max_iter=1000):\n        \"\"\"Refine using gradient-based optimization\"\"\"\n        n = len(centers_init)\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        def objective(x):\n            radii = x[2*n:]\n            return -np.sum(radii)\n        \n        def constraint_container(x):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return np.array([2.0 - np.sqrt(centers[i, 0]**2 + centers[i, 1]**2) - radii[i] \n                           for i in range(n)])\n        \n        def constraint_separation(x):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            constraints = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                 (centers[i, 1] - centers[j, 1])**2)\n                    constraints.append(dist - radii[i] - radii[j])\n            return np.array(constraints)\n        \n        cons = [\n            {'type': 'ineq', 'fun': constraint_container},\n            {'type': 'ineq', 'fun': constraint_separation}\n        ]\n        \n        bounds = [(-2, 2)] * (2*n) + [(0.01, 2)] * n\n        \n        result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                         constraints=cons, options={'maxiter': max_iter, 'ftol': 1e-9})\n        \n        if result.success:\n            centers = result.x[:2*n].reshape(n, 2)\n            radii = result.x[2*n:]\n            if is_valid(centers, radii):\n                return centers, radii\n        \n        return centers_init, radii_init\n    \n    # Strategy 1: Regular Grid (5x6)\n    def strategy_regular_grid():\n        centers = []\n        rows, cols = 5, 6\n        spacing = 0.6\n        offset_x = -spacing * (cols - 1) / 2\n        offset_y = -spacing * (rows - 1) / 2\n        \n        for i in range(rows):\n            for j in range(cols):\n                x = offset_x + j * spacing\n                y = offset_y + i * spacing\n                if x**2 + y**2 < 3.5:  # Within reasonable bounds\n                    centers.append([x, y])\n        \n        return np.array(centers[:30])\n    \n    # Strategy 2: Hexagonal Lattice\n    def strategy_hexagonal():\n        centers = []\n        spacing = 0.55\n        rows = 7\n        \n        for row in range(rows):\n            y = (row - rows/2) * spacing * np.sqrt(3)/2\n            cols = 8 if row % 2 == 0 else 7\n            for col in range(cols):\n                offset = spacing/2 if row % 2 == 1 else 0\n                x = (col - cols/2) * spacing + offset\n                if x**2 + y**2 < 3.5:\n                    centers.append([x, y])\n        \n        return np.array(centers[:30])\n    \n    # Strategy 3: Random with Repulsion\n    def strategy_random_repulsion():\n        np.random.seed(42)\n        n = 30\n        centers = np.random.randn(n, 2) * 1.2\n        \n        # Apply repulsion forces\n        for _ in range(100):\n            forces = np.zeros_like(centers)\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        diff = centers[i] - centers[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.8 and dist > 0:\n                            forces[i] += diff / dist**2 * 0.01\n            centers += forces\n            # Keep within bounds\n            for i in range(n):\n                norm = np.linalg.norm(centers[i])\n                if norm > 1.7:\n                    centers[i] = centers[i] / norm * 1.7\n        \n        return centers\n    \n    # Strategy 4: Boundary-First Placement\n    def strategy_boundary_first():\n        centers = []\n        # Place circles on boundary\n        n_boundary = 15\n        for i in range(n_boundary):\n            angle = 2 * np.pi * i / n_boundary\n            r = 1.6\n            centers.append([r * np.cos(angle), r * np.sin(angle)])\n        \n        # Place circles in middle ring\n        n_middle = 10\n        for i in range(n_middle):\n            angle = 2 * np.pi * i / n_middle + np.pi/n_middle\n            r = 0.9\n            centers.append([r * np.cos(angle), r * np.sin(angle)])\n        \n        # Place circles in center\n        n_center = 5\n        for i in range(n_center):\n            angle = 2 * np.pi * i / n_center\n            r = 0.3\n            centers.append([r * np.cos(angle), r * np.sin(angle)])\n        \n        return np.array(centers[:30])\n    \n    # Strategy 5: Voronoi-Based\n    def strategy_voronoi():\n        np.random.seed(123)\n        # Start with random points\n        n = 30\n        centers = np.random.randn(n, 2) * 1.3\n        \n        # Clip to circle\n        for i in range(n):\n            norm = np.linalg.norm(centers[i])\n            if norm > 1.7:\n                centers[i] = centers[i] / norm * 1.7\n        \n        # Lloyd's algorithm for better distribution\n        for _ in range(10):\n            # Add boundary points for proper Voronoi\n            boundary_pts = []\n            for angle in np.linspace(0, 2*np.pi, 20, endpoint=False):\n                boundary_pts.append([2.5 * np.cos(angle), 2.5 * np.sin(angle)])\n            \n            all_pts = np.vstack([centers, boundary_pts])\n            vor = Voronoi(all_pts)\n            \n            # Move to centroids\n            new_centers = []\n            for i in range(n):\n                region_idx = vor.point_region[i]\n                region = vor.regions[region_idx]\n                if -1 not in region and len(region) > 0:\n                    vertices = vor.vertices[region]\n                    centroid = vertices.mean(axis=0)\n                    # Keep within bounds\n                    norm = np.linalg.norm(centroid)\n                    if norm > 1.7:\n                        centroid = centroid / norm * 1.7\n                    new_centers.append(centroid)\n                else:\n                    new_centers.append(centers[i])\n            centers = np.array(new_centers)\n        \n        return centers\n    \n    # Run all strategies\n    strategies = [\n        (\"Regular Grid\", strategy_regular_grid),\n        (\"Hexagonal\", strategy_hexagonal),\n        (\"Random Repulsion\", strategy_random_repulsion),\n        (\"Boundary First\", strategy_boundary_first),\n        (\"Voronoi\", strategy_voronoi)\n    ]\n    \n    best_result = None\n    best_sum = 0\n    \n    for name, strategy_func in strategies:\n        print(f\"\\nTrying strategy: {name}\")\n        \n        try:\n            # Generate initial configuration\n            centers_init = strategy_func()\n            \n            if len(centers_init) < 30:\n                print(f\"  Warning: Only {len(centers_init)} circles generated\")\n                continue\n            \n            # Step 1: LP optimization for radii\n            radii_lp = optimize_radii_lp(centers_init)\n            sum_lp = np.sum(radii_lp)\n            print(f\"  After LP: sum_radii = {sum_lp:.6f}\")\n            \n            if is_valid(centers_init, radii_lp):\n                if sum_lp > best_sum:\n                    best_sum = sum_lp\n                    best_result = (centers_init.copy(), radii_lp.copy())\n            \n            # Step 2: Gradient refinement\n            centers_opt, radii_opt = gradient_optimize(centers_init, radii_lp)\n            sum_opt = np.sum(radii_opt)\n            print(f\"  After Gradient: sum_radii = {sum_opt:.6f}\")\n            \n            if is_valid(centers_opt, radii_opt):\n                if sum_opt > best_sum:\n                    best_sum = sum_opt\n                    best_result = (centers_opt.copy(), radii_opt.copy())\n            \n        except Exception as e:\n            print(f\"  Error in strategy {name}: {e}\")\n            continue\n    \n    if best_result is not None:\n        centers, radii = best_result\n        print(f\"\\n{'='*50}\")\n        print(f\"Best result: sum_radii = {np.sum(radii):.6f}\")\n        print(f\"Valid: {is_valid(centers, radii)}\")\n        return centers.tolist(), radii.tolist()\n    \n    # Fallback\n    print(\"\\nAll strategies failed, using fallback\")\n    centers = strategy_hexagonal()\n    radii = optimize_radii_lp(centers)\n    return centers.tolist(), radii.tolist()\n\n# Run the multi-strategy optimization\nresult = multi_strategy_hybrid_packing()\nprint(f\"\\nFinal sum of radii: {sum(result[1]):.6f}\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 3.51200270652771,
    "error": "ValueError: Code must define run_packing() or construct_packing()"
  },
  "prompt": "Create a multi-strategy hybrid packing algorithm:\n\n1. Generate 5 different initial configurations:\n   - Regular grid (5x6)\n   - Hexagonal lattice\n   - Random with repulsion\n   - Boundary-first placement\n   - Voronoi-based\n\n2. For each configuration:\n   - Use LP to optimize radii (like trial_0_14)\n   - Then refine with gradient optimization (like trial_0_2)\n\n3. Return the best result among all 5 attempts\n\nTarget: sum_radii > 2.58.",
  "response": "I'll create a comprehensive multi-strategy hybrid packing algorithm that combines different initialization methods with LP and gradient optimization.\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nfrom scipy.spatial import Voronoi\nimport math\n\ndef multi_strategy_hybrid_packing():\n    \"\"\"\n    Multi-strategy approach combining 5 different initializations\n    with LP optimization followed by gradient refinement.\n    \"\"\"\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if configuration is valid (no overlaps, within container)\"\"\"\n        n = len(centers)\n        # Check container constraints\n        for i in range(n):\n            if np.sqrt(centers[i, 0]**2 + centers[i, 1]**2) + radii[i] > 2.0 + 1e-6:\n                return False\n        # Check circle separation\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        return True\n    \n    def optimize_radii_lp(centers, min_radius=0.01):\n        \"\"\"Optimize radii using Linear Programming\"\"\"\n        n = len(centers)\n        \n        # Objective: maximize sum of radii (minimize negative sum)\n        c = -np.ones(n)\n        \n        # Inequality constraints: A_ub @ r <= b_ub\n        constraints = []\n        \n        # Container constraints: r_i <= 2 - ||c_i||\n        for i in range(n):\n            dist_to_origin = np.sqrt(centers[i, 0]**2 + centers[i, 1]**2)\n            a = np.zeros(n)\n            a[i] = 1\n            constraints.append((a, 2.0 - dist_to_origin))\n        \n        # Separation constraints: r_i + r_j <= ||c_i - c_j||\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                             (centers[i, 1] - centers[j, 1])**2)\n                a = np.zeros(n)\n                a[i] = 1\n                a[j] = 1\n                constraints.append((a, dist))\n        \n        A_ub = np.array([c[0] for c in constraints])\n        b_ub = np.array([c[1] for c in constraints])\n        \n        # Bounds: r_i >= min_radius\n        bounds = [(min_radius, None) for _ in range(n)]\n        \n        result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if result.success:\n            return result.x\n        return np.full(n, min_radius)\n    \n    def gradient_optimize(centers_init, radii_init, max_iter=1000):\n        \"\"\"Refine using gradient-based optimization\"\"\"\n        n = len(centers_init)\n        x0 = np.concatenate([centers_init.flatten(), radii_init])\n        \n        def objective(x):\n            radii = x[2*n:]\n            return -np.sum(radii)\n        \n        def constraint_container(x):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            return np.array([2.0 - np.sqrt(centers[i, 0]**2 + centers[i, 1]**2) - radii[i] \n                           for i in range(n)])\n        \n        def constraint_separation(x):\n            centers = x[:2*n].reshape(n, 2)\n            radii = x[2*n:]\n            constraints = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.sqrt((centers[i, 0] - centers[j, 0])**2 + \n                                 (centers[i, 1] - centers[j, 1])**2)\n                    constraints.append(dist - radii[i] - radii[j])\n            return np.array(constraints)\n        \n        cons = [\n            {'type': 'ineq', 'fun': constraint_container},\n            {'type': 'ineq', 'fun': constraint_separation}\n        ]\n        \n        bounds = [(-2, 2)] * (2*n) + [(0.01, 2)] * n\n        \n        result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                         constraints=cons, options={'maxiter': max_iter, 'ftol': 1e-9})\n        \n        if result.success:\n            centers = result.x[:2*n].reshape(n, 2)\n            radii = result.x[2*n:]\n            if is_valid(centers, radii):\n                return centers, radii\n        \n        return centers_init, radii_init\n    \n    # Strategy 1: Regular Grid (5x6)\n    def strategy_regular_grid():\n        centers = []\n        rows, cols = 5, 6\n        spacing = 0.6\n        offset_x = -spacing * (cols - 1) / 2\n        offset_y = -spacing * (rows - 1) / 2\n        \n        for i in range(rows):\n            for j in range(cols):\n                x = offset_x + j * spacing\n                y = offset_y + i * spacing\n                if x**2 + y**2 < 3.5:  # Within reasonable bounds\n                    centers.append([x, y])\n        \n        return np.array(centers[:30])\n    \n    # Strategy 2: Hexagonal Lattice\n    def strategy_hexagonal():\n        centers = []\n        spacing = 0.55\n        rows = 7\n        \n        for row in range(rows):\n            y = (row - rows/2) * spacing * np.sqrt(3)/2\n            cols = 8 if row % 2 == 0 else 7\n            for col in range(cols):\n                offset = spacing/2 if row % 2 == 1 else 0\n                x = (col - cols/2) * spacing + offset\n                if x**2 + y**2 < 3.5:\n                    centers.append([x, y])\n        \n        return np.array(centers[:30])\n    \n    # Strategy 3: Random with Repulsion\n    def strategy_random_repulsion():\n        np.random.seed(42)\n        n = 30\n        centers = np.random.randn(n, 2) * 1.2\n        \n        # Apply repulsion forces\n        for _ in range(100):\n            forces = np.zeros_like(centers)\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        diff = centers[i] - centers[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.8 and dist > 0:\n                            forces[i] += diff / dist**2 * 0.01\n            centers += forces\n            # Keep within bounds\n            for i in range(n):\n                norm = np.linalg.norm(centers[i])\n                if norm > 1.7:\n                    centers[i] = centers[i] / norm * 1.7\n        \n        return centers\n    \n    # Strategy 4: Boundary-First Placement\n    def strategy_boundary_first():\n        centers = []\n        # Place circles on boundary\n        n_boundary = 15\n        for i in range(n_boundary):\n            angle = 2 * np.pi * i / n_boundary\n            r = 1.6\n            centers.append([r * np.cos(angle), r * np.sin(angle)])\n        \n        # Place circles in middle ring\n        n_middle = 10\n        for i in range(n_middle):\n            angle = 2 * np.pi * i / n_middle + np.pi/n_middle\n            r = 0.9\n            centers.append([r * np.cos(angle), r * np.sin(angle)])\n        \n        # Place circles in center\n        n_center = 5\n        for i in range(n_center):\n            angle = 2 * np.pi * i / n_center\n            r = 0.3\n            centers.append([r * np.cos(angle), r * np.sin(angle)])\n        \n        return np.array(centers[:30])\n    \n    # Strategy 5: Voronoi-Based\n    def strategy_voronoi():\n        np.random.seed(123)\n        # Start with random points\n        n = 30\n        centers = np.random.randn(n, 2) * 1.3\n        \n        # Clip to circle\n        for i in range(n):\n            norm = np.linalg.norm(centers[i])\n            if norm > 1.7:\n                centers[i] = centers[i] / norm * 1.7\n        \n        # Lloyd's algorithm for better distribution\n        for _ in range(10):\n            # Add boundary points for proper Voronoi\n            boundary_pts = []\n            for angle in np.linspace(0, 2*np.pi, 20, endpoint=False):\n                boundary_pts.append([2.5 * np.cos(angle), 2.5 * np.sin(angle)])\n            \n            all_pts = np.vstack([centers, boundary_pts])\n            vor = Voronoi(all_pts)\n            \n            # Move to centroids\n            new_centers = []\n            for i in range(n):\n                region_idx = vor.point_region[i]\n                region = vor.regions[region_idx]\n                if -1 not in region and len(region) > 0:\n                    vertices = vor.vertices[region]\n                    centroid = vertices.mean(axis=0)\n                    # Keep within bounds\n                    norm = np.linalg.norm(centroid)\n                    if norm > 1.7:\n                        centroid = centroid / norm * 1.7\n                    new_centers.append(centroid)\n                else:\n                    new_centers.append(centers[i])\n            centers = np.array(new_centers)\n        \n        return centers\n    \n    # Run all strategies\n    strategies = [\n        (\"Regular Grid\", strategy_regular_grid),\n        (\"Hexagonal\", strategy_hexagonal),\n        (\"Random Repulsion\", strategy_random_repulsion),\n        (\"Boundary First\", strategy_boundary_first),\n        (\"Voronoi\", strategy_voronoi)\n    ]\n    \n    best_result = None\n    best_sum = 0\n    \n    for name, strategy_func in strategies:\n        print(f\"\\nTrying strategy: {name}\")\n        \n        try:\n            # Generate initial configuration\n            centers_init = strategy_func()\n            \n            if len(centers_init) < 30:\n                print(f\"  Warning: Only {len(centers_init)} circles generated\")\n                continue\n            \n            # Step 1: LP optimization for radii\n            radii_lp = optimize_radii_lp(centers_init)\n            sum_lp = np.sum(radii_lp)\n            print(f\"  After LP: sum_radii = {sum_lp:.6f}\")\n            \n            if is_valid(centers_init, radii_lp):\n                if sum_lp > best_sum:\n                    best_sum = sum_lp\n                    best_result = (centers_init.copy(), radii_lp.copy())\n            \n            # Step 2: Gradient refinement\n            centers_opt, radii_opt = gradient_optimize(centers_init, radii_lp)\n            sum_opt = np.sum(radii_opt)\n            print(f\"  After Gradient: sum_radii = {sum_opt:.6f}\")\n            \n            if is_valid(centers_opt, radii_opt):\n                if sum_opt > best_sum:\n                    best_sum = sum_opt\n                    best_result = (centers_opt.copy(), radii_opt.copy())\n            \n        except Exception as e:\n            print(f\"  Error in strategy {name}: {e}\")\n            continue\n    \n    if best_result is not None:\n        centers, radii = best_result\n        print(f\"\\n{'='*50}\")\n        print(f\"Best result: sum_radii = {np.sum(radii):.6f}\")\n        print(f\"Valid: {is_valid(centers, radii)}\")\n        return centers.tolist(), radii.tolist()\n    \n    # Fallback\n    print(\"\\nAll strategies failed, using fallback\")\n    centers = strategy_hexagonal()\n    radii = optimize_radii_lp(centers)\n    return centers.tolist(), radii.tolist()\n\n# Run the multi-strategy optimization\nresult = multi_strategy_hybrid_packing()\nprint(f\"\\nFinal sum of radii: {sum(result[1]):.6f}\")\n```\n\nThis algorithm:\n\n1. **Implements 5 diverse initialization strategies**:\n   - Regular grid with optimal spacing\n   - Hexagonal lattice (known to be efficient)\n   - Random with repulsion forces\n   - Boundary-first (fills from outside in)\n   - Voronoi-based (Lloyd's algorithm for uniform distribution)\n\n2. **For each strategy**:\n   - Uses LP to find optimal radii given fixed centers\n   - Applies gradient optimization to refine both centers and radii\n   - Tracks the best valid solution\n\n3. **Returns the best result** across all attempts\n\nThe target of sum_radii > 2.58 should be achievable, especially with the hexagonal and Voronoi strategies which are known to produce efficient packings.",
  "reasoning": "I'll create a comprehensive multi-strategy hybrid packing algorithm that combines different initialization methods with LP and gradient optimization.\n\nThis algorithm:\n\n1. **Implements 5 diverse initialization strategies**:\n   - Regular grid with optimal spacing\n   - Hexagonal lattice (known to be efficient)\n   - Random with repulsion forces\n   - Boundary-first (fills from outside in)\n   - Voronoi-based (Lloyd's algorithm for uniform distribution)\n\n2. **For each strategy**:\n   - Uses LP to find optimal radii given fixed centers\n   - Applies gradient optimization to refine both centers and radii\n   - Tracks the best valid solution\n\n3. **Returns the best result** across all attempts\n\nThe target of sum_radii > 2.58 should be achievable, especially with the hexagonal and Voronoi strategies which are known to produce efficient packings.",
  "timestamp": "2025-12-05T16:53:11.906166",
  "cost_data": null
}