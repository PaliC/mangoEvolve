{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for 26 circles in [0,1]x[0,1] using\n    random initialization followed by local search optimization.\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    np.random.seed(42)\n    \n    # Random initialization\n    centers = np.random.rand(n_circles, 2)\n    radii = np.random.rand(n_circles) * 0.05 + 0.01  # Small initial radii\n    \n    # Ensure initial validity\n    for i in range(n_circles):\n        radii[i] = min(radii[i], \n                      centers[i, 0], \n                      1 - centers[i, 0],\n                      centers[i, 1], \n                      1 - centers[i, 1])\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if packing is valid (no overlaps, within bounds)\"\"\"\n        # Check boundary constraints\n        if np.any(centers[:, 0] - radii < 0) or np.any(centers[:, 0] + radii > 1):\n            return False\n        if np.any(centers[:, 1] - radii < 0) or np.any(centers[:, 1] + radii > 1):\n            return False\n        \n        # Check circle overlaps\n        for i in range(len(radii)):\n            for j in range(i + 1, len(radii)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-9:  # Small tolerance\n                    return False\n        return True\n    \n    # Local search parameters\n    n_iterations = 50000\n    step_size_pos = 0.01\n    step_size_rad = 0.005\n    temperature = 0.1\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for iteration in range(n_iterations):\n        # Adaptive step size\n        progress = iteration / n_iterations\n        current_step_pos = step_size_pos * (1 - 0.8 * progress)\n        current_step_rad = step_size_rad * (1 - 0.8 * progress)\n        \n        # Choose random circle to modify\n        idx = np.random.randint(n_circles)\n        \n        # Save old state\n        old_center = centers[idx].copy()\n        old_radius = radii[idx]\n        \n        # Try different types of moves\n        move_type = np.random.rand()\n        \n        if move_type < 0.4:\n            # Move center\n            centers[idx] += np.random.randn(2) * current_step_pos\n        elif move_type < 0.7:\n            # Increase radius\n            radii[idx] += np.random.rand() * current_step_rad\n        elif move_type < 0.85:\n            # Move center and increase radius\n            centers[idx] += np.random.randn(2) * current_step_pos\n            radii[idx] += np.random.rand() * current_step_rad\n        else:\n            # Larger random repositioning (exploration)\n            centers[idx] = np.random.rand(2)\n            radii[idx] = np.random.rand() * 0.05\n        \n        # Check validity\n        if is_valid(centers, radii):\n            new_sum = np.sum(radii)\n            # Accept if improvement or with some probability (simulated annealing)\n            if new_sum > best_sum or np.random.rand() < np.exp((new_sum - best_sum) / temperature):\n                best_sum = new_sum\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            else:\n                # Revert\n                centers[idx] = old_center\n                radii[idx] = old_radius\n        else:\n            # Revert invalid move\n            centers[idx] = old_center\n            radii[idx] = old_radius\n        \n        # Occasionally try to expand all circles slightly\n        if iteration % 500 == 0 and iteration > 0:\n            temp_radii = radii.copy()\n            radii += 0.001\n            if not is_valid(centers, radii):\n                radii = temp_radii\n            else:\n                best_sum = np.sum(radii)\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"Entry point for circle packing optimization.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 3.944615125656128,
    "error": "Circles 2 and 7 overlap: distance=0.037647, required=0.066161"
  },
  "prompt": "Write a random initialization + local search circle packing for 26 circles in [0,1]x[0,1].\n\nStart with random positions and radii, then use local search to improve by small perturbations.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Random initial positions\n- Iteratively try small moves/radius changes that increase sum\n- Accept changes that maintain validity\n- Do not print or plot anything\n\nStrategy: Stochastic local search from random start.",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for 26 circles in [0,1]x[0,1] using\n    random initialization followed by local search optimization.\n    \n    Returns:\n        centers: numpy array of shape (26, 2) with circle centers\n        radii: numpy array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    np.random.seed(42)\n    \n    # Random initialization\n    centers = np.random.rand(n_circles, 2)\n    radii = np.random.rand(n_circles) * 0.05 + 0.01  # Small initial radii\n    \n    # Ensure initial validity\n    for i in range(n_circles):\n        radii[i] = min(radii[i], \n                      centers[i, 0], \n                      1 - centers[i, 0],\n                      centers[i, 1], \n                      1 - centers[i, 1])\n    \n    def is_valid(centers, radii):\n        \"\"\"Check if packing is valid (no overlaps, within bounds)\"\"\"\n        # Check boundary constraints\n        if np.any(centers[:, 0] - radii < 0) or np.any(centers[:, 0] + radii > 1):\n            return False\n        if np.any(centers[:, 1] - radii < 0) or np.any(centers[:, 1] + radii > 1):\n            return False\n        \n        # Check circle overlaps\n        for i in range(len(radii)):\n            for j in range(i + 1, len(radii)):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-9:  # Small tolerance\n                    return False\n        return True\n    \n    # Local search parameters\n    n_iterations = 50000\n    step_size_pos = 0.01\n    step_size_rad = 0.005\n    temperature = 0.1\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for iteration in range(n_iterations):\n        # Adaptive step size\n        progress = iteration / n_iterations\n        current_step_pos = step_size_pos * (1 - 0.8 * progress)\n        current_step_rad = step_size_rad * (1 - 0.8 * progress)\n        \n        # Choose random circle to modify\n        idx = np.random.randint(n_circles)\n        \n        # Save old state\n        old_center = centers[idx].copy()\n        old_radius = radii[idx]\n        \n        # Try different types of moves\n        move_type = np.random.rand()\n        \n        if move_type < 0.4:\n            # Move center\n            centers[idx] += np.random.randn(2) * current_step_pos\n        elif move_type < 0.7:\n            # Increase radius\n            radii[idx] += np.random.rand() * current_step_rad\n        elif move_type < 0.85:\n            # Move center and increase radius\n            centers[idx] += np.random.randn(2) * current_step_pos\n            radii[idx] += np.random.rand() * current_step_rad\n        else:\n            # Larger random repositioning (exploration)\n            centers[idx] = np.random.rand(2)\n            radii[idx] = np.random.rand() * 0.05\n        \n        # Check validity\n        if is_valid(centers, radii):\n            new_sum = np.sum(radii)\n            # Accept if improvement or with some probability (simulated annealing)\n            if new_sum > best_sum or np.random.rand() < np.exp((new_sum - best_sum) / temperature):\n                best_sum = new_sum\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n            else:\n                # Revert\n                centers[idx] = old_center\n                radii[idx] = old_radius\n        else:\n            # Revert invalid move\n            centers[idx] = old_center\n            radii[idx] = old_radius\n        \n        # Occasionally try to expand all circles slightly\n        if iteration % 500 == 0 and iteration > 0:\n            temp_radii = radii.copy()\n            radii += 0.001\n            if not is_valid(centers, radii):\n                radii = temp_radii\n            else:\n                best_sum = np.sum(radii)\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"Entry point for circle packing optimization.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:46:22.483923",
  "cost_data": null
}