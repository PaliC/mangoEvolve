{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a divide-and-conquer circle packing for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Divide the unit square recursively\n    # Strategy: Split into regions and pack circles in each\n    \n    # Level 1: Split into 4 quadrants (2x2)\n    # Top-left: 7 circles, Top-right: 7 circles\n    # Bottom-left: 6 circles, Bottom-right: 6 circles\n    \n    def pack_region(x_min: float, x_max: float, y_min: float, y_max: float, \n                    n_circles: int) -> Tuple[List, List]:\n        \"\"\"Pack n_circles in a rectangular region.\"\"\"\n        region_centers = []\n        region_radii = []\n        \n        width = x_max - x_min\n        height = y_max - y_min\n        \n        if n_circles == 0:\n            return region_centers, region_radii\n        \n        if n_circles <= 4:\n            # Base case: arrange in a grid\n            if n_circles == 1:\n                grid_rows, grid_cols = 1, 1\n            elif n_circles == 2:\n                grid_rows, grid_cols = (1, 2) if width >= height else (2, 1)\n            elif n_circles == 3:\n                grid_rows, grid_cols = 1, 3 if width >= height else 3, 1\n            else:  # n_circles == 4\n                grid_rows, grid_cols = 2, 2\n            \n            radius = min(width / (2 * grid_cols), height / (2 * grid_rows)) * 0.9\n            \n            for i in range(n_circles):\n                row = i // grid_cols\n                col = i % grid_cols\n                cx = x_min + (col + 0.5) * width / grid_cols\n                cy = y_min + (row + 0.5) * height / grid_rows\n                region_centers.append([cx, cy])\n                region_radii.append(radius)\n        \n        elif n_circles <= 9:\n            # Arrange in 3x3 grid\n            grid_rows = int(np.ceil(np.sqrt(n_circles)))\n            grid_cols = int(np.ceil(n_circles / grid_rows))\n            \n            if width >= height:\n                grid_rows, grid_cols = grid_cols, grid_rows\n            \n            radius = min(width / (2 * grid_cols), height / (2 * grid_rows)) * 0.85\n            \n            for i in range(n_circles):\n                row = i // grid_cols\n                col = i % grid_cols\n                cx = x_min + (col + 0.5) * width / grid_cols\n                cy = y_min + (row + 0.5) * height / grid_rows\n                region_centers.append([cx, cy])\n                region_radii.append(radius)\n        \n        else:\n            # Recursive case: split the region\n            if width >= height:\n                # Split vertically\n                mid_x = (x_min + x_max) / 2\n                n_left = n_circles // 2\n                n_right = n_circles - n_left\n                \n                left_centers, left_radii = pack_region(x_min, mid_x, y_min, y_max, n_left)\n                right_centers, right_radii = pack_region(mid_x, x_max, y_min, y_max, n_right)\n                \n                region_centers.extend(left_centers)\n                region_centers.extend(right_centers)\n                region_radii.extend(left_radii)\n                region_radii.extend(right_radii)\n            else:\n                # Split horizontally\n                mid_y = (y_min + y_max) / 2\n                n_bottom = n_circles // 2\n                n_top = n_circles - n_bottom\n                \n                bottom_centers, bottom_radii = pack_region(x_min, x_max, y_min, mid_y, n_bottom)\n                top_centers, top_radii = pack_region(x_min, x_max, mid_y, y_max, n_top)\n                \n                region_centers.extend(bottom_centers)\n                region_centers.extend(top_centers)\n                region_radii.extend(bottom_radii)\n                region_radii.extend(top_radii)\n        \n        return region_centers, region_radii\n    \n    # Start packing with the full unit square\n    centers_list, radii_list = pack_region(0.0, 1.0, 0.0, 1.0, 26)\n    \n    centers = np.array(centers_list)\n    radii = np.array(radii_list)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Entry point for circle packing.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.8416666666666666,
    "target_ratio": 0.6989247311827957,
    "combined_score": 0.6989247311827957,
    "eval_time": 0.06361603736877441,
    "error": null
  },
  "prompt": "Write a divide-and-conquer circle packing for 26 circles in [0,1]x[0,1].\n\nRecursively divide the square into regions and pack circles in each region.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Divide square into sub-regions\n- Pack circles in each region\n- Balance circle distribution across regions\n- Do not print or plot anything\n\nStrategy: Recursive space partitioning.",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a divide-and-conquer circle packing for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    # Divide the unit square recursively\n    # Strategy: Split into regions and pack circles in each\n    \n    # Level 1: Split into 4 quadrants (2x2)\n    # Top-left: 7 circles, Top-right: 7 circles\n    # Bottom-left: 6 circles, Bottom-right: 6 circles\n    \n    def pack_region(x_min: float, x_max: float, y_min: float, y_max: float, \n                    n_circles: int) -> Tuple[List, List]:\n        \"\"\"Pack n_circles in a rectangular region.\"\"\"\n        region_centers = []\n        region_radii = []\n        \n        width = x_max - x_min\n        height = y_max - y_min\n        \n        if n_circles == 0:\n            return region_centers, region_radii\n        \n        if n_circles <= 4:\n            # Base case: arrange in a grid\n            if n_circles == 1:\n                grid_rows, grid_cols = 1, 1\n            elif n_circles == 2:\n                grid_rows, grid_cols = (1, 2) if width >= height else (2, 1)\n            elif n_circles == 3:\n                grid_rows, grid_cols = 1, 3 if width >= height else 3, 1\n            else:  # n_circles == 4\n                grid_rows, grid_cols = 2, 2\n            \n            radius = min(width / (2 * grid_cols), height / (2 * grid_rows)) * 0.9\n            \n            for i in range(n_circles):\n                row = i // grid_cols\n                col = i % grid_cols\n                cx = x_min + (col + 0.5) * width / grid_cols\n                cy = y_min + (row + 0.5) * height / grid_rows\n                region_centers.append([cx, cy])\n                region_radii.append(radius)\n        \n        elif n_circles <= 9:\n            # Arrange in 3x3 grid\n            grid_rows = int(np.ceil(np.sqrt(n_circles)))\n            grid_cols = int(np.ceil(n_circles / grid_rows))\n            \n            if width >= height:\n                grid_rows, grid_cols = grid_cols, grid_rows\n            \n            radius = min(width / (2 * grid_cols), height / (2 * grid_rows)) * 0.85\n            \n            for i in range(n_circles):\n                row = i // grid_cols\n                col = i % grid_cols\n                cx = x_min + (col + 0.5) * width / grid_cols\n                cy = y_min + (row + 0.5) * height / grid_rows\n                region_centers.append([cx, cy])\n                region_radii.append(radius)\n        \n        else:\n            # Recursive case: split the region\n            if width >= height:\n                # Split vertically\n                mid_x = (x_min + x_max) / 2\n                n_left = n_circles // 2\n                n_right = n_circles - n_left\n                \n                left_centers, left_radii = pack_region(x_min, mid_x, y_min, y_max, n_left)\n                right_centers, right_radii = pack_region(mid_x, x_max, y_min, y_max, n_right)\n                \n                region_centers.extend(left_centers)\n                region_centers.extend(right_centers)\n                region_radii.extend(left_radii)\n                region_radii.extend(right_radii)\n            else:\n                # Split horizontally\n                mid_y = (y_min + y_max) / 2\n                n_bottom = n_circles // 2\n                n_top = n_circles - n_bottom\n                \n                bottom_centers, bottom_radii = pack_region(x_min, x_max, y_min, mid_y, n_bottom)\n                top_centers, top_radii = pack_region(x_min, x_max, mid_y, y_max, n_top)\n                \n                region_centers.extend(bottom_centers)\n                region_centers.extend(top_centers)\n                region_radii.extend(bottom_radii)\n                region_radii.extend(top_radii)\n        \n        return region_centers, region_radii\n    \n    # Start packing with the full unit square\n    centers_list, radii_list = pack_region(0.0, 1.0, 0.0, 1.0, 26)\n    \n    centers = np.array(centers_list)\n    radii = np.array(radii_list)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Entry point for circle packing.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:46:19.264015",
  "cost_data": null
}