{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef construct_packing():\n    \"\"\"\n    Optimize circle packing for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: array of shape (26, 2) with circle centers\n        radii: array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Variables: [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n    n_vars = 3 * n_circles\n    \n    # Initial guess: place circles on a grid\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_positions = []\n    initial_radius = 0.5 / grid_size  # Conservative initial radius\n    \n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_positions.extend([x, y, initial_radius])\n    \n    x0 = np.array(initial_positions)\n    \n    # Objective: maximize sum of radii = minimize negative sum of radii\n    def objective(x):\n        radii = x[2::3]\n        return -np.sum(radii)\n    \n    # Gradient of objective\n    def objective_grad(x):\n        grad = np.zeros_like(x)\n        grad[2::3] = -1.0\n        return grad\n    \n    # Constraint functions\n    def bounds_constraints(x):\n        \"\"\"Ensure circles stay within [0,1]x[0,1]\"\"\"\n        constraints = []\n        for i in range(n_circles):\n            xi = x[3*i]\n            yi = x[3*i + 1]\n            ri = x[3*i + 2]\n            # xi - ri >= 0, xi + ri <= 1, yi - ri >= 0, yi + ri <= 1\n            constraints.extend([\n                xi - ri,           # left bound\n                1.0 - xi - ri,     # right bound\n                yi - ri,           # bottom bound\n                1.0 - yi - ri      # top bound\n            ])\n        return np.array(constraints)\n    \n    def overlap_constraints(x):\n        \"\"\"Ensure no circles overlap\"\"\"\n        constraints = []\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                xi, yi, ri = x[3*i], x[3*i + 1], x[3*i + 2]\n                xj, yj, rj = x[3*j], x[3*j + 1], x[3*j + 2]\n                \n                # Distance between centers minus sum of radii should be >= 0\n                dist_sq = (xi - xj)**2 + (yi - yj)**2\n                dist = np.sqrt(dist_sq)\n                constraints.append(dist - ri - rj)\n        \n        return np.array(constraints)\n    \n    def bounds_constraints_jac(x):\n        \"\"\"Jacobian of bounds constraints\"\"\"\n        n_bound_constraints = 4 * n_circles\n        jac = np.zeros((n_bound_constraints, n_vars))\n        \n        for i in range(n_circles):\n            base_row = 4 * i\n            base_col = 3 * i\n            \n            # xi - ri >= 0\n            jac[base_row, base_col] = 1.0      # dx_i\n            jac[base_row, base_col + 2] = -1.0 # dr_i\n            \n            # 1 - xi - ri >= 0\n            jac[base_row + 1, base_col] = -1.0     # dx_i\n            jac[base_row + 1, base_col + 2] = -1.0 # dr_i\n            \n            # yi - ri >= 0\n            jac[base_row + 2, base_col + 1] = 1.0  # dy_i\n            jac[base_row + 2, base_col + 2] = -1.0 # dr_i\n            \n            # 1 - yi - ri >= 0\n            jac[base_row + 3, base_col + 1] = -1.0 # dy_i\n            jac[base_row + 3, base_col + 2] = -1.0 # dr_i\n        \n        return jac\n    \n    def overlap_constraints_jac(x):\n        \"\"\"Jacobian of overlap constraints\"\"\"\n        n_overlap_constraints = n_circles * (n_circles - 1) // 2\n        jac = np.zeros((n_overlap_constraints, n_vars))\n        \n        constraint_idx = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                xi, yi, ri = x[3*i], x[3*i + 1], x[3*i + 2]\n                xj, yj, rj = x[3*j], x[3*j + 1], x[3*j + 2]\n                \n                dist_sq = (xi - xj)**2 + (yi - yj)**2\n                dist = np.sqrt(dist_sq + 1e-10)  # Add small epsilon for numerical stability\n                \n                # d/dx_i: (xi - xj) / dist\n                jac[constraint_idx, 3*i] = (xi - xj) / dist\n                # d/dy_i: (yi - yj) / dist\n                jac[constraint_idx, 3*i + 1] = (yi - yj) / dist\n                # d/dr_i: -1\n                jac[constraint_idx, 3*i + 2] = -1.0\n                \n                # d/dx_j: -(xi - xj) / dist\n                jac[constraint_idx, 3*j] = -(xi - xj) / dist\n                # d/dy_j: -(yi - yj) / dist\n                jac[constraint_idx, 3*j + 1] = -(yi - yj) / dist\n                # d/dr_j: -1\n                jac[constraint_idx, 3*j + 2] = -1.0\n                \n                constraint_idx += 1\n        \n        return jac\n    \n    # Set up constraints\n    bounds_constr = NonlinearConstraint(\n        bounds_constraints, \n        0.0, \n        np.inf,\n        jac=bounds_constraints_jac\n    )\n    \n    overlap_constr = NonlinearConstraint(\n        overlap_constraints, \n        0.0, \n        np.inf,\n        jac=overlap_constraints_jac\n    )\n    \n    # Bounds on variables: x, y in [0, 1], r in [0, 0.5]\n    bounds = []\n    for i in range(n_circles):\n        bounds.extend([(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)])\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        jac=objective_grad,\n        constraints=[bounds_constr, overlap_constr],\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-6}\n    )\n    \n    # Extract results\n    x_opt = result.x\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        centers[i, 0] = x_opt[3*i]\n        centers[i, 1] = x_opt[3*i + 1]\n        radii[i] = x_opt[3*i + 2]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"Entry point for circle packing optimization.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5160617588617904,
    "target_ratio": 0.9548621475756321,
    "combined_score": 0.9548621475756321,
    "eval_time": 0.23812603950500488,
    "error": null
  },
  "prompt": "Write an optimization-based circle packing using scipy.optimize for 26 circles in [0,1]x[0,1].\n\nUse scipy.optimize.minimize to find optimal positions and radii that maximize sum of radii subject to constraints.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use scipy.optimize with constraint functions for no overlap and bounds\n- Start from a reasonable initial guess (e.g., grid)\n- Do not print or plot anything\n\nStrategy: Formulate as constrained optimization problem.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint\n\ndef construct_packing():\n    \"\"\"\n    Optimize circle packing for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: array of shape (26, 2) with circle centers\n        radii: array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Variables: [x1, y1, r1, x2, y2, r2, ..., xn, yn, rn]\n    n_vars = 3 * n_circles\n    \n    # Initial guess: place circles on a grid\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_positions = []\n    initial_radius = 0.5 / grid_size  # Conservative initial radius\n    \n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_positions.extend([x, y, initial_radius])\n    \n    x0 = np.array(initial_positions)\n    \n    # Objective: maximize sum of radii = minimize negative sum of radii\n    def objective(x):\n        radii = x[2::3]\n        return -np.sum(radii)\n    \n    # Gradient of objective\n    def objective_grad(x):\n        grad = np.zeros_like(x)\n        grad[2::3] = -1.0\n        return grad\n    \n    # Constraint functions\n    def bounds_constraints(x):\n        \"\"\"Ensure circles stay within [0,1]x[0,1]\"\"\"\n        constraints = []\n        for i in range(n_circles):\n            xi = x[3*i]\n            yi = x[3*i + 1]\n            ri = x[3*i + 2]\n            # xi - ri >= 0, xi + ri <= 1, yi - ri >= 0, yi + ri <= 1\n            constraints.extend([\n                xi - ri,           # left bound\n                1.0 - xi - ri,     # right bound\n                yi - ri,           # bottom bound\n                1.0 - yi - ri      # top bound\n            ])\n        return np.array(constraints)\n    \n    def overlap_constraints(x):\n        \"\"\"Ensure no circles overlap\"\"\"\n        constraints = []\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                xi, yi, ri = x[3*i], x[3*i + 1], x[3*i + 2]\n                xj, yj, rj = x[3*j], x[3*j + 1], x[3*j + 2]\n                \n                # Distance between centers minus sum of radii should be >= 0\n                dist_sq = (xi - xj)**2 + (yi - yj)**2\n                dist = np.sqrt(dist_sq)\n                constraints.append(dist - ri - rj)\n        \n        return np.array(constraints)\n    \n    def bounds_constraints_jac(x):\n        \"\"\"Jacobian of bounds constraints\"\"\"\n        n_bound_constraints = 4 * n_circles\n        jac = np.zeros((n_bound_constraints, n_vars))\n        \n        for i in range(n_circles):\n            base_row = 4 * i\n            base_col = 3 * i\n            \n            # xi - ri >= 0\n            jac[base_row, base_col] = 1.0      # dx_i\n            jac[base_row, base_col + 2] = -1.0 # dr_i\n            \n            # 1 - xi - ri >= 0\n            jac[base_row + 1, base_col] = -1.0     # dx_i\n            jac[base_row + 1, base_col + 2] = -1.0 # dr_i\n            \n            # yi - ri >= 0\n            jac[base_row + 2, base_col + 1] = 1.0  # dy_i\n            jac[base_row + 2, base_col + 2] = -1.0 # dr_i\n            \n            # 1 - yi - ri >= 0\n            jac[base_row + 3, base_col + 1] = -1.0 # dy_i\n            jac[base_row + 3, base_col + 2] = -1.0 # dr_i\n        \n        return jac\n    \n    def overlap_constraints_jac(x):\n        \"\"\"Jacobian of overlap constraints\"\"\"\n        n_overlap_constraints = n_circles * (n_circles - 1) // 2\n        jac = np.zeros((n_overlap_constraints, n_vars))\n        \n        constraint_idx = 0\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                xi, yi, ri = x[3*i], x[3*i + 1], x[3*i + 2]\n                xj, yj, rj = x[3*j], x[3*j + 1], x[3*j + 2]\n                \n                dist_sq = (xi - xj)**2 + (yi - yj)**2\n                dist = np.sqrt(dist_sq + 1e-10)  # Add small epsilon for numerical stability\n                \n                # d/dx_i: (xi - xj) / dist\n                jac[constraint_idx, 3*i] = (xi - xj) / dist\n                # d/dy_i: (yi - yj) / dist\n                jac[constraint_idx, 3*i + 1] = (yi - yj) / dist\n                # d/dr_i: -1\n                jac[constraint_idx, 3*i + 2] = -1.0\n                \n                # d/dx_j: -(xi - xj) / dist\n                jac[constraint_idx, 3*j] = -(xi - xj) / dist\n                # d/dy_j: -(yi - yj) / dist\n                jac[constraint_idx, 3*j + 1] = -(yi - yj) / dist\n                # d/dr_j: -1\n                jac[constraint_idx, 3*j + 2] = -1.0\n                \n                constraint_idx += 1\n        \n        return jac\n    \n    # Set up constraints\n    bounds_constr = NonlinearConstraint(\n        bounds_constraints, \n        0.0, \n        np.inf,\n        jac=bounds_constraints_jac\n    )\n    \n    overlap_constr = NonlinearConstraint(\n        overlap_constraints, \n        0.0, \n        np.inf,\n        jac=overlap_constraints_jac\n    )\n    \n    # Bounds on variables: x, y in [0, 1], r in [0, 0.5]\n    bounds = []\n    for i in range(n_circles):\n        bounds.extend([(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)])\n    \n    # Optimize\n    result = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        jac=objective_grad,\n        constraints=[bounds_constr, overlap_constr],\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-6}\n    )\n    \n    # Extract results\n    x_opt = result.x\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        centers[i, 0] = x_opt[3*i]\n        centers[i, 1] = x_opt[3*i + 1]\n        radii[i] = x_opt[3*i + 2]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"Entry point for circle packing optimization.\"\"\"\n    return construct_packing()\n\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:46:25.813909",
  "cost_data": null
}