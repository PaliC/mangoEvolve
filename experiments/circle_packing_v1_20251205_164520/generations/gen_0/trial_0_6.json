{
  "trial_id": "trial_0_6",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing(centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a valid packing by adjusting radii to avoid overlaps and boundary violations.\n    \n    Args:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of initial radii\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of adjusted radii\n        sum_radii: sum of all radii\n    \"\"\"\n    n = len(centers)\n    adjusted_radii = radii.copy()\n    \n    for i in range(n):\n        # Check boundary constraints\n        max_radius = min(\n            centers[i, 0],  # distance to left edge\n            1 - centers[i, 0],  # distance to right edge\n            centers[i, 1],  # distance to bottom edge\n            1 - centers[i, 1]  # distance to top edge\n        )\n        \n        # Check overlap constraints with other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_radius = min(max_radius, max(0, dist - adjusted_radii[j]))\n        \n        adjusted_radii[i] = min(adjusted_radii[i], max(0, max_radius))\n    \n    return centers, adjusted_radii, np.sum(adjusted_radii)\n\n\ndef initialize_population(pop_size: int, n_circles: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"Initialize population with random packings.\"\"\"\n    population = []\n    for _ in range(pop_size):\n        centers = np.random.uniform(0, 1, (n_circles, 2))\n        radii = np.random.uniform(0.01, 0.1, n_circles)\n        population.append((centers, radii))\n    return population\n\n\ndef evaluate_fitness(centers: np.ndarray, radii: np.ndarray) -> float:\n    \"\"\"Evaluate fitness of a packing (sum of radii).\"\"\"\n    _, adjusted_radii, sum_radii = construct_packing(centers, radii)\n    return sum_radii\n\n\ndef tournament_selection(population: List[Tuple[np.ndarray, np.ndarray]], \n                        fitnesses: np.ndarray, \n                        tournament_size: int = 3) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Select individual using tournament selection.\"\"\"\n    indices = np.random.choice(len(population), tournament_size, replace=False)\n    best_idx = indices[np.argmax(fitnesses[indices])]\n    centers, radii = population[best_idx]\n    return centers.copy(), radii.copy()\n\n\ndef crossover(parent1_centers: np.ndarray, parent1_radii: np.ndarray,\n              parent2_centers: np.ndarray, parent2_radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Perform crossover between two parents.\"\"\"\n    n = len(parent1_centers)\n    \n    # Random crossover point\n    crossover_point = np.random.randint(1, n)\n    \n    # Create offspring by combining parents\n    child_centers = np.vstack([\n        parent1_centers[:crossover_point],\n        parent2_centers[crossover_point:]\n    ])\n    \n    child_radii = np.concatenate([\n        parent1_radii[:crossover_point],\n        parent2_radii[crossover_point:]\n    ])\n    \n    return child_centers, child_radii\n\n\ndef mutate(centers: np.ndarray, radii: np.ndarray, \n           mutation_rate: float = 0.2, \n           mutation_strength: float = 0.1) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Mutate a packing.\"\"\"\n    n = len(centers)\n    mutated_centers = centers.copy()\n    mutated_radii = radii.copy()\n    \n    # Mutate centers\n    center_mask = np.random.random((n, 2)) < mutation_rate\n    mutations = np.random.normal(0, mutation_strength, (n, 2))\n    mutated_centers += center_mask * mutations\n    mutated_centers = np.clip(mutated_centers, 0, 1)\n    \n    # Mutate radii\n    radii_mask = np.random.random(n) < mutation_rate\n    radii_mutations = np.random.normal(0, mutation_strength * 0.5, n)\n    mutated_radii += radii_mask * radii_mutations\n    mutated_radii = np.clip(mutated_radii, 0.001, 0.2)\n    \n    return mutated_centers, mutated_radii\n\n\ndef optimize_local(centers: np.ndarray, radii: np.ndarray, iterations: int = 5) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Local optimization to improve packing.\"\"\"\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_fitness = evaluate_fitness(best_centers, best_radii)\n    \n    for _ in range(iterations):\n        # Try small random perturbations\n        new_centers = best_centers + np.random.normal(0, 0.02, best_centers.shape)\n        new_centers = np.clip(new_centers, 0, 1)\n        new_radii = best_radii + np.random.normal(0, 0.01, best_radii.shape)\n        new_radii = np.clip(new_radii, 0.001, 0.2)\n        \n        fitness = evaluate_fitness(new_centers, new_radii)\n        if fitness > best_fitness:\n            best_centers = new_centers\n            best_radii = new_radii\n            best_fitness = fitness\n    \n    return best_centers, best_radii\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Run genetic algorithm for circle packing.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    n_circles = 26\n    pop_size = 100\n    n_generations = 200\n    elite_size = 5\n    \n    # Initialize population\n    population = initialize_population(pop_size, n_circles)\n    \n    for generation in range(n_generations):\n        # Evaluate fitness\n        fitnesses = np.array([evaluate_fitness(centers, radii) for centers, radii in population])\n        \n        # Sort by fitness\n        sorted_indices = np.argsort(fitnesses)[::-1]\n        population = [population[i] for i in sorted_indices]\n        fitnesses = fitnesses[sorted_indices]\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism: keep best individuals\n        for i in range(elite_size):\n            new_population.append((population[i][0].copy(), population[i][1].copy()))\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            # Selection\n            parent1_centers, parent1_radii = tournament_selection(population, fitnesses)\n            parent2_centers, parent2_radii = tournament_selection(population, fitnesses)\n            \n            # Crossover\n            if np.random.random() < 0.8:\n                child_centers, child_radii = crossover(parent1_centers, parent1_radii,\n                                                       parent2_centers, parent2_radii)\n            else:\n                child_centers, child_radii = parent1_centers, parent1_radii\n            \n            # Mutation\n            child_centers, child_radii = mutate(child_centers, child_radii)\n            \n            # Local optimization for some individuals\n            if np.random.random() < 0.1:\n                child_centers, child_radii = optimize_local(child_centers, child_radii)\n            \n            new_population.append((child_centers, child_radii))\n        \n        population = new_population\n    \n    # Final evaluation\n    fitnesses = np.array([evaluate_fitness(centers, radii) for centers, radii in population])\n    best_idx = np.argmax(fitnesses)\n    best_centers, best_radii = population[best_idx]\n    \n    # Construct final packing\n    final_centers, final_radii, sum_radii = construct_packing(best_centers, best_radii)\n    \n    return final_centers, final_radii, sum_radii",
  "metrics": {
    "valid": true,
    "sum_radii": 1.623486593717287,
    "target_ratio": 0.616123944484739,
    "combined_score": 0.616123944484739,
    "eval_time": 26.700064182281494,
    "error": null
  },
  "prompt": "Write a genetic algorithm for circle packing with 26 circles in [0,1]x[0,1].\n\nUse a population of packings, crossover, mutation, and selection to evolve better solutions.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Population of packings\n- Crossover and mutation operators\n- Selection based on sum of radii\n- Do not print or plot anything\n\nStrategy: Evolutionary algorithm approach.",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing(centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a valid packing by adjusting radii to avoid overlaps and boundary violations.\n    \n    Args:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of initial radii\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of adjusted radii\n        sum_radii: sum of all radii\n    \"\"\"\n    n = len(centers)\n    adjusted_radii = radii.copy()\n    \n    for i in range(n):\n        # Check boundary constraints\n        max_radius = min(\n            centers[i, 0],  # distance to left edge\n            1 - centers[i, 0],  # distance to right edge\n            centers[i, 1],  # distance to bottom edge\n            1 - centers[i, 1]  # distance to top edge\n        )\n        \n        # Check overlap constraints with other circles\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                max_radius = min(max_radius, max(0, dist - adjusted_radii[j]))\n        \n        adjusted_radii[i] = min(adjusted_radii[i], max(0, max_radius))\n    \n    return centers, adjusted_radii, np.sum(adjusted_radii)\n\n\ndef initialize_population(pop_size: int, n_circles: int) -> List[Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"Initialize population with random packings.\"\"\"\n    population = []\n    for _ in range(pop_size):\n        centers = np.random.uniform(0, 1, (n_circles, 2))\n        radii = np.random.uniform(0.01, 0.1, n_circles)\n        population.append((centers, radii))\n    return population\n\n\ndef evaluate_fitness(centers: np.ndarray, radii: np.ndarray) -> float:\n    \"\"\"Evaluate fitness of a packing (sum of radii).\"\"\"\n    _, adjusted_radii, sum_radii = construct_packing(centers, radii)\n    return sum_radii\n\n\ndef tournament_selection(population: List[Tuple[np.ndarray, np.ndarray]], \n                        fitnesses: np.ndarray, \n                        tournament_size: int = 3) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Select individual using tournament selection.\"\"\"\n    indices = np.random.choice(len(population), tournament_size, replace=False)\n    best_idx = indices[np.argmax(fitnesses[indices])]\n    centers, radii = population[best_idx]\n    return centers.copy(), radii.copy()\n\n\ndef crossover(parent1_centers: np.ndarray, parent1_radii: np.ndarray,\n              parent2_centers: np.ndarray, parent2_radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Perform crossover between two parents.\"\"\"\n    n = len(parent1_centers)\n    \n    # Random crossover point\n    crossover_point = np.random.randint(1, n)\n    \n    # Create offspring by combining parents\n    child_centers = np.vstack([\n        parent1_centers[:crossover_point],\n        parent2_centers[crossover_point:]\n    ])\n    \n    child_radii = np.concatenate([\n        parent1_radii[:crossover_point],\n        parent2_radii[crossover_point:]\n    ])\n    \n    return child_centers, child_radii\n\n\ndef mutate(centers: np.ndarray, radii: np.ndarray, \n           mutation_rate: float = 0.2, \n           mutation_strength: float = 0.1) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Mutate a packing.\"\"\"\n    n = len(centers)\n    mutated_centers = centers.copy()\n    mutated_radii = radii.copy()\n    \n    # Mutate centers\n    center_mask = np.random.random((n, 2)) < mutation_rate\n    mutations = np.random.normal(0, mutation_strength, (n, 2))\n    mutated_centers += center_mask * mutations\n    mutated_centers = np.clip(mutated_centers, 0, 1)\n    \n    # Mutate radii\n    radii_mask = np.random.random(n) < mutation_rate\n    radii_mutations = np.random.normal(0, mutation_strength * 0.5, n)\n    mutated_radii += radii_mask * radii_mutations\n    mutated_radii = np.clip(mutated_radii, 0.001, 0.2)\n    \n    return mutated_centers, mutated_radii\n\n\ndef optimize_local(centers: np.ndarray, radii: np.ndarray, iterations: int = 5) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Local optimization to improve packing.\"\"\"\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_fitness = evaluate_fitness(best_centers, best_radii)\n    \n    for _ in range(iterations):\n        # Try small random perturbations\n        new_centers = best_centers + np.random.normal(0, 0.02, best_centers.shape)\n        new_centers = np.clip(new_centers, 0, 1)\n        new_radii = best_radii + np.random.normal(0, 0.01, best_radii.shape)\n        new_radii = np.clip(new_radii, 0.001, 0.2)\n        \n        fitness = evaluate_fitness(new_centers, new_radii)\n        if fitness > best_fitness:\n            best_centers = new_centers\n            best_radii = new_radii\n            best_fitness = fitness\n    \n    return best_centers, best_radii\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Run genetic algorithm for circle packing.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    n_circles = 26\n    pop_size = 100\n    n_generations = 200\n    elite_size = 5\n    \n    # Initialize population\n    population = initialize_population(pop_size, n_circles)\n    \n    for generation in range(n_generations):\n        # Evaluate fitness\n        fitnesses = np.array([evaluate_fitness(centers, radii) for centers, radii in population])\n        \n        # Sort by fitness\n        sorted_indices = np.argsort(fitnesses)[::-1]\n        population = [population[i] for i in sorted_indices]\n        fitnesses = fitnesses[sorted_indices]\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism: keep best individuals\n        for i in range(elite_size):\n            new_population.append((population[i][0].copy(), population[i][1].copy()))\n        \n        # Generate offspring\n        while len(new_population) < pop_size:\n            # Selection\n            parent1_centers, parent1_radii = tournament_selection(population, fitnesses)\n            parent2_centers, parent2_radii = tournament_selection(population, fitnesses)\n            \n            # Crossover\n            if np.random.random() < 0.8:\n                child_centers, child_radii = crossover(parent1_centers, parent1_radii,\n                                                       parent2_centers, parent2_radii)\n            else:\n                child_centers, child_radii = parent1_centers, parent1_radii\n            \n            # Mutation\n            child_centers, child_radii = mutate(child_centers, child_radii)\n            \n            # Local optimization for some individuals\n            if np.random.random() < 0.1:\n                child_centers, child_radii = optimize_local(child_centers, child_radii)\n            \n            new_population.append((child_centers, child_radii))\n        \n        population = new_population\n    \n    # Final evaluation\n    fitnesses = np.array([evaluate_fitness(centers, radii) for centers, radii in population])\n    best_idx = np.argmax(fitnesses)\n    best_centers, best_radii = population[best_idx]\n    \n    # Construct final packing\n    final_centers, final_radii, sum_radii = construct_packing(best_centers, best_radii)\n    \n    return final_centers, final_radii, sum_radii\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:46:53.173128",
  "cost_data": null
}