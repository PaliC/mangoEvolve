{
  "trial_id": "trial_0_13",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial import Voronoi, distance\nfrom scipy.spatial import voronoi_plot_2d\n\ndef construct_packing():\n    \"\"\"\n    Construct a Voronoi-based circle packing for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle centers\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    # Generate 26 random points in [0,1]x[0,1]\n    points = np.random.rand(26, 2)\n    \n    # Add mirror points to handle boundary conditions\n    # This helps create proper Voronoi cells near boundaries\n    mirror_points = []\n    for point in points:\n        # Mirror across each edge\n        mirror_points.append([point[0], point[1] - 1])  # bottom\n        mirror_points.append([point[0], point[1] + 1])  # top\n        mirror_points.append([point[0] - 1, point[1]])  # left\n        mirror_points.append([point[0] + 1, point[1]])  # right\n        # Mirror across corners\n        mirror_points.append([point[0] - 1, point[1] - 1])\n        mirror_points.append([point[0] + 1, point[1] - 1])\n        mirror_points.append([point[0] - 1, point[1] + 1])\n        mirror_points.append([point[0] + 1, point[1] + 1])\n    \n    all_points = np.vstack([points, mirror_points])\n    \n    # Compute Voronoi diagram\n    vor = Voronoi(all_points)\n    \n    centers = np.zeros((26, 2))\n    radii = np.zeros(26)\n    \n    # Process each of the original 26 points\n    for i in range(26):\n        # Get the Voronoi region for this point\n        region_index = vor.point_region[i]\n        region = vor.regions[region_index]\n        \n        if -1 in region or len(region) == 0:\n            # Unbounded region or empty - use the original point\n            centers[i] = points[i]\n            # Compute radius as distance to nearest boundary\n            radii[i] = min(points[i][0], points[i][1], \n                          1 - points[i][0], 1 - points[i][1])\n        else:\n            # Get vertices of the Voronoi cell\n            vertices = vor.vertices[region]\n            \n            # Clip vertices to [0,1]x[0,1]\n            vertices = np.clip(vertices, 0, 1)\n            \n            # Compute centroid of the clipped cell\n            centroid = np.mean(vertices, axis=0)\n            centers[i] = centroid\n            \n            # Compute radius as minimum distance to:\n            # 1. Voronoi cell vertices\n            # 2. Boundaries [0,1]x[0,1]\n            # 3. Other circle centers\n            \n            # Distance to vertices\n            dist_to_vertices = np.min(distance.cdist([centroid], vertices))\n            \n            # Distance to boundaries\n            dist_to_boundaries = min(\n                centroid[0],           # left boundary\n                centroid[1],           # bottom boundary\n                1 - centroid[0],       # right boundary\n                1 - centroid[1]        # top boundary\n            )\n            \n            # Distance to other centers (approximate, will be refined)\n            other_centers = points[np.arange(26) != i]\n            if len(other_centers) > 0:\n                dist_to_others = np.min(distance.cdist([centroid], other_centers))\n                dist_to_others *= 0.5  # Half the distance to avoid overlap\n            else:\n                dist_to_others = np.inf\n            \n            # Take minimum of all distances\n            radii[i] = min(dist_to_vertices, dist_to_boundaries, dist_to_others)\n    \n    # Ensure circles don't overlap by iteratively reducing radii\n    max_iterations = 100\n    for iteration in range(max_iterations):\n        overlaps = False\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    # Reduce both radii proportionally\n                    overlap = (radii[i] + radii[j] - dist) / 2\n                    radii[i] -= overlap * 0.55\n                    radii[j] -= overlap * 0.55\n                    overlaps = True\n        \n        if not overlaps:\n            break\n    \n    # Ensure all radii are positive and circles stay within bounds\n    for i in range(26):\n        max_radius = min(\n            centers[i][0],\n            centers[i][1],\n            1 - centers[i][0],\n            1 - centers[i][1]\n        )\n        radii[i] = max(0.001, min(radii[i], max_radius))\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the Voronoi-based circle packing.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle centers\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.5941969706805665,
    "target_ratio": 0.6050083380191904,
    "combined_score": 0.6050083380191904,
    "eval_time": 0.1860182285308838,
    "error": null
  },
  "prompt": "Write a Voronoi-based circle packing for 26 circles in [0,1]x[0,1].\n\nGenerate 26 points, compute Voronoi diagram, and place circles at cell centers with radii based on cell size.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Use scipy.spatial.Voronoi\n- Place circles at Voronoi cell centers\n- Set radius based on distance to nearest boundary\n- Do not print or plot anything\n\nStrategy: Voronoi tessellation approach.",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial import Voronoi, distance\nfrom scipy.spatial import voronoi_plot_2d\n\ndef construct_packing():\n    \"\"\"\n    Construct a Voronoi-based circle packing for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle centers\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    np.random.seed(42)\n    \n    # Generate 26 random points in [0,1]x[0,1]\n    points = np.random.rand(26, 2)\n    \n    # Add mirror points to handle boundary conditions\n    # This helps create proper Voronoi cells near boundaries\n    mirror_points = []\n    for point in points:\n        # Mirror across each edge\n        mirror_points.append([point[0], point[1] - 1])  # bottom\n        mirror_points.append([point[0], point[1] + 1])  # top\n        mirror_points.append([point[0] - 1, point[1]])  # left\n        mirror_points.append([point[0] + 1, point[1]])  # right\n        # Mirror across corners\n        mirror_points.append([point[0] - 1, point[1] - 1])\n        mirror_points.append([point[0] + 1, point[1] - 1])\n        mirror_points.append([point[0] - 1, point[1] + 1])\n        mirror_points.append([point[0] + 1, point[1] + 1])\n    \n    all_points = np.vstack([points, mirror_points])\n    \n    # Compute Voronoi diagram\n    vor = Voronoi(all_points)\n    \n    centers = np.zeros((26, 2))\n    radii = np.zeros(26)\n    \n    # Process each of the original 26 points\n    for i in range(26):\n        # Get the Voronoi region for this point\n        region_index = vor.point_region[i]\n        region = vor.regions[region_index]\n        \n        if -1 in region or len(region) == 0:\n            # Unbounded region or empty - use the original point\n            centers[i] = points[i]\n            # Compute radius as distance to nearest boundary\n            radii[i] = min(points[i][0], points[i][1], \n                          1 - points[i][0], 1 - points[i][1])\n        else:\n            # Get vertices of the Voronoi cell\n            vertices = vor.vertices[region]\n            \n            # Clip vertices to [0,1]x[0,1]\n            vertices = np.clip(vertices, 0, 1)\n            \n            # Compute centroid of the clipped cell\n            centroid = np.mean(vertices, axis=0)\n            centers[i] = centroid\n            \n            # Compute radius as minimum distance to:\n            # 1. Voronoi cell vertices\n            # 2. Boundaries [0,1]x[0,1]\n            # 3. Other circle centers\n            \n            # Distance to vertices\n            dist_to_vertices = np.min(distance.cdist([centroid], vertices))\n            \n            # Distance to boundaries\n            dist_to_boundaries = min(\n                centroid[0],           # left boundary\n                centroid[1],           # bottom boundary\n                1 - centroid[0],       # right boundary\n                1 - centroid[1]        # top boundary\n            )\n            \n            # Distance to other centers (approximate, will be refined)\n            other_centers = points[np.arange(26) != i]\n            if len(other_centers) > 0:\n                dist_to_others = np.min(distance.cdist([centroid], other_centers))\n                dist_to_others *= 0.5  # Half the distance to avoid overlap\n            else:\n                dist_to_others = np.inf\n            \n            # Take minimum of all distances\n            radii[i] = min(dist_to_vertices, dist_to_boundaries, dist_to_others)\n    \n    # Ensure circles don't overlap by iteratively reducing radii\n    max_iterations = 100\n    for iteration in range(max_iterations):\n        overlaps = False\n        for i in range(26):\n            for j in range(i + 1, 26):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    # Reduce both radii proportionally\n                    overlap = (radii[i] + radii[j] - dist) / 2\n                    radii[i] -= overlap * 0.55\n                    radii[j] -= overlap * 0.55\n                    overlaps = True\n        \n        if not overlaps:\n            break\n    \n    # Ensure all radii are positive and circles stay within bounds\n    for i in range(26):\n        max_radius = min(\n            centers[i][0],\n            centers[i][1],\n            1 - centers[i][0],\n            1 - centers[i][1]\n        )\n        radii[i] = max(0.001, min(radii[i], max_radius))\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the Voronoi-based circle packing.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) - circle centers\n        radii: np.ndarray of shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:46:20.459963",
  "cost_data": null
}