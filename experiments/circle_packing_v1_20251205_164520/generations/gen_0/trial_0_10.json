{
  "trial_id": "trial_0_10",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a greedy packing of 26 circles in [0,1]x[0,1].\n    At each step, place a circle at the position that allows the maximum radius.\n    \n    Returns:\n        centers: list of (x, y) tuples\n        radii: list of radii\n        sum_radii: sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    n_circles = 26\n    \n    for i in range(n_circles):\n        best_center, best_radius = find_best_position(centers, radii)\n        centers.append(best_center)\n        radii.append(best_radius)\n    \n    sum_radii = sum(radii)\n    return centers, radii, sum_radii\n\n\ndef find_best_position(existing_centers, existing_radii):\n    \"\"\"\n    Find the position that allows the largest radius circle.\n    \n    Args:\n        existing_centers: list of (x, y) tuples for already placed circles\n        existing_radii: list of radii for already placed circles\n    \n    Returns:\n        best_center: (x, y) tuple for new circle\n        best_radius: radius of new circle\n    \"\"\"\n    if len(existing_centers) == 0:\n        # First circle: place at center with maximum radius\n        return (0.5, 0.5), 0.5\n    \n    # Use differential evolution for global optimization\n    def objective(pos):\n        x, y = pos\n        r = compute_max_radius(x, y, existing_centers, existing_radii)\n        return -r  # Negative because we want to maximize\n    \n    # Try multiple starting points on a grid for robustness\n    grid_size = 20\n    best_radius = 0\n    best_center = None\n    \n    for gx in np.linspace(0, 1, grid_size):\n        for gy in np.linspace(0, 1, grid_size):\n            r = compute_max_radius(gx, gy, existing_centers, existing_radii)\n            if r > best_radius:\n                best_radius = r\n                best_center = (gx, gy)\n    \n    # Refine with optimization\n    result = differential_evolution(\n        objective,\n        bounds=[(0, 1), (0, 1)],\n        seed=42,\n        maxiter=300,\n        popsize=15,\n        atol=1e-6,\n        tol=1e-6\n    )\n    \n    refined_center = tuple(result.x)\n    refined_radius = compute_max_radius(refined_center[0], refined_center[1], \n                                       existing_centers, existing_radii)\n    \n    if refined_radius > best_radius:\n        return refined_center, refined_radius\n    else:\n        return best_center, best_radius\n\n\ndef compute_max_radius(x, y, existing_centers, existing_radii):\n    \"\"\"\n    Compute the maximum radius for a circle at (x, y) given existing circles.\n    \n    Args:\n        x, y: coordinates of candidate circle center\n        existing_centers: list of (cx, cy) tuples\n        existing_radii: list of radii\n    \n    Returns:\n        max_radius: maximum allowed radius\n    \"\"\"\n    # Distance to boundaries\n    dist_to_left = x\n    dist_to_right = 1 - x\n    dist_to_bottom = y\n    dist_to_top = 1 - y\n    \n    max_radius = min(dist_to_left, dist_to_right, dist_to_bottom, dist_to_top)\n    \n    # Distance to existing circles\n    for (cx, cy), r in zip(existing_centers, existing_radii):\n        dist_centers = np.sqrt((x - cx)**2 + (y - cy)**2)\n        max_radius_from_circle = dist_centers - r\n        max_radius = min(max_radius, max_radius_from_circle)\n    \n    return max(0, max_radius)\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the packing algorithm.\n    \n    Returns:\n        centers: list of (x, y) tuples\n        radii: list of radii\n        sum_radii: sum of all radii\n    \"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.431968142204757,
    "target_ratio": 0.5434414201915587,
    "combined_score": 0.5434414201915587,
    "eval_time": 0.9781248569488525,
    "error": null
  },
  "prompt": "Write a maximal radius greedy packing for 26 circles in [0,1]x[0,1].\n\nPlace circles by always choosing the globally maximum possible radius at each step.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- At each step, find position that allows largest radius\n- Search over grid of candidate positions\n- Do not print or plot anything\n\nStrategy: Greedy by maximum radius.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\ndef construct_packing():\n    \"\"\"\n    Construct a greedy packing of 26 circles in [0,1]x[0,1].\n    At each step, place a circle at the position that allows the maximum radius.\n    \n    Returns:\n        centers: list of (x, y) tuples\n        radii: list of radii\n        sum_radii: sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    n_circles = 26\n    \n    for i in range(n_circles):\n        best_center, best_radius = find_best_position(centers, radii)\n        centers.append(best_center)\n        radii.append(best_radius)\n    \n    sum_radii = sum(radii)\n    return centers, radii, sum_radii\n\n\ndef find_best_position(existing_centers, existing_radii):\n    \"\"\"\n    Find the position that allows the largest radius circle.\n    \n    Args:\n        existing_centers: list of (x, y) tuples for already placed circles\n        existing_radii: list of radii for already placed circles\n    \n    Returns:\n        best_center: (x, y) tuple for new circle\n        best_radius: radius of new circle\n    \"\"\"\n    if len(existing_centers) == 0:\n        # First circle: place at center with maximum radius\n        return (0.5, 0.5), 0.5\n    \n    # Use differential evolution for global optimization\n    def objective(pos):\n        x, y = pos\n        r = compute_max_radius(x, y, existing_centers, existing_radii)\n        return -r  # Negative because we want to maximize\n    \n    # Try multiple starting points on a grid for robustness\n    grid_size = 20\n    best_radius = 0\n    best_center = None\n    \n    for gx in np.linspace(0, 1, grid_size):\n        for gy in np.linspace(0, 1, grid_size):\n            r = compute_max_radius(gx, gy, existing_centers, existing_radii)\n            if r > best_radius:\n                best_radius = r\n                best_center = (gx, gy)\n    \n    # Refine with optimization\n    result = differential_evolution(\n        objective,\n        bounds=[(0, 1), (0, 1)],\n        seed=42,\n        maxiter=300,\n        popsize=15,\n        atol=1e-6,\n        tol=1e-6\n    )\n    \n    refined_center = tuple(result.x)\n    refined_radius = compute_max_radius(refined_center[0], refined_center[1], \n                                       existing_centers, existing_radii)\n    \n    if refined_radius > best_radius:\n        return refined_center, refined_radius\n    else:\n        return best_center, best_radius\n\n\ndef compute_max_radius(x, y, existing_centers, existing_radii):\n    \"\"\"\n    Compute the maximum radius for a circle at (x, y) given existing circles.\n    \n    Args:\n        x, y: coordinates of candidate circle center\n        existing_centers: list of (cx, cy) tuples\n        existing_radii: list of radii\n    \n    Returns:\n        max_radius: maximum allowed radius\n    \"\"\"\n    # Distance to boundaries\n    dist_to_left = x\n    dist_to_right = 1 - x\n    dist_to_bottom = y\n    dist_to_top = 1 - y\n    \n    max_radius = min(dist_to_left, dist_to_right, dist_to_bottom, dist_to_top)\n    \n    # Distance to existing circles\n    for (cx, cy), r in zip(existing_centers, existing_radii):\n        dist_centers = np.sqrt((x - cx)**2 + (y - cy)**2)\n        max_radius_from_circle = dist_centers - r\n        max_radius = min(max_radius, max_radius_from_circle)\n    \n    return max(0, max_radius)\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the packing algorithm.\n    \n    Returns:\n        centers: list of (x, y) tuples\n        radii: list of radii\n        sum_radii: sum of all radii\n    \"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:46:16.360900",
  "cost_data": null
}