{
  "trial_id": "trial_0_14",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Two-phase optimization for packing 26 circles in [0,1]x[0,1].\n    \n    Phase 1: Find valid packing with reasonable radii using a grid layout.\n    Phase 2: Fix positions and optimize radii to maximize sum using linear programming.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Phase 1: Generate initial positions using a grid\n    # For 26 circles, use a 5x6 grid (30 positions, use 26)\n    grid_rows = 5\n    grid_cols = 6\n    \n    # Create grid with margins\n    margin = 0.1\n    x_coords = np.linspace(margin, 1 - margin, grid_cols)\n    y_coords = np.linspace(margin, 1 - margin, grid_rows)\n    \n    # Generate all grid positions\n    grid_positions = []\n    for y in y_coords:\n        for x in x_coords:\n            grid_positions.append([x, y])\n    \n    # Take first 26 positions\n    centers = np.array(grid_positions[:n_circles])\n    \n    # Phase 2: Optimize radii given fixed positions\n    # This is a linear programming problem:\n    # maximize: sum(r_i)\n    # subject to:\n    #   r_i + r_j <= dist(c_i, c_j) for all i < j (non-overlap)\n    #   r_i <= min(c_i[0], 1-c_i[0], c_i[1], 1-c_i[1]) (boundary constraints)\n    #   r_i >= 0\n    \n    # Compute pairwise distances\n    distances = cdist(centers, centers)\n    \n    # Set up linear programming problem\n    # Variables: r_0, r_1, ..., r_25\n    # Objective: minimize -sum(r_i) (equivalent to maximizing sum(r_i))\n    c = -np.ones(n_circles)\n    \n    # Inequality constraints: A_ub @ r <= b_ub\n    A_ub = []\n    b_ub = []\n    \n    # Non-overlap constraints: r_i + r_j <= dist(i,j) for all i < j\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            constraint = np.zeros(n_circles)\n            constraint[i] = 1\n            constraint[j] = 1\n            A_ub.append(constraint)\n            b_ub.append(distances[i, j])\n    \n    # Boundary constraints for each circle\n    for i in range(n_circles):\n        cx, cy = centers[i]\n        \n        # r_i <= cx (left boundary)\n        constraint = np.zeros(n_circles)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(cx)\n        \n        # r_i <= 1 - cx (right boundary)\n        constraint = np.zeros(n_circles)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(1 - cx)\n        \n        # r_i <= cy (bottom boundary)\n        constraint = np.zeros(n_circles)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(cy)\n        \n        # r_i <= 1 - cy (top boundary)\n        constraint = np.zeros(n_circles)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(1 - cy)\n    \n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n    \n    # Bounds: r_i >= 0\n    bounds = [(0, None) for _ in range(n_circles)]\n    \n    # Solve linear program\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    \n    if result.success:\n        radii = result.x\n        sum_radii = np.sum(radii)\n    else:\n        # Fallback: use conservative radii\n        radii = np.zeros(n_circles)\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            # Maximum radius respecting boundaries\n            max_r_boundary = min(cx, 1 - cx, cy, 1 - cy)\n            # Maximum radius respecting other circles\n            max_r_circles = np.inf\n            for j in range(n_circles):\n                if i != j:\n                    max_r_circles = min(max_r_circles, distances[i, j] / 2)\n            radii[i] = min(max_r_boundary, max_r_circles)\n        sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the two-phase circle packing optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.08,
    "target_ratio": 0.7893738140417458,
    "combined_score": 0.7893738140417458,
    "eval_time": 0.23140192031860352,
    "error": null
  },
  "prompt": "Write a two-phase optimization circle packing for 26 circles in [0,1]x[0,1].\n\nPhase 1: Find valid packing with reasonable radii.\nPhase 2: Fix positions and optimize only radii to maximize sum.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Phase 1: Get valid positions (e.g., grid or random)\n- Phase 2: Optimize radii given fixed positions using linear programming or similar\n- Do not print or plot anything\n\nStrategy: Separate position and radius optimization.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"\n    Two-phase optimization for packing 26 circles in [0,1]x[0,1].\n    \n    Phase 1: Find valid packing with reasonable radii using a grid layout.\n    Phase 2: Fix positions and optimize radii to maximize sum using linear programming.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Phase 1: Generate initial positions using a grid\n    # For 26 circles, use a 5x6 grid (30 positions, use 26)\n    grid_rows = 5\n    grid_cols = 6\n    \n    # Create grid with margins\n    margin = 0.1\n    x_coords = np.linspace(margin, 1 - margin, grid_cols)\n    y_coords = np.linspace(margin, 1 - margin, grid_rows)\n    \n    # Generate all grid positions\n    grid_positions = []\n    for y in y_coords:\n        for x in x_coords:\n            grid_positions.append([x, y])\n    \n    # Take first 26 positions\n    centers = np.array(grid_positions[:n_circles])\n    \n    # Phase 2: Optimize radii given fixed positions\n    # This is a linear programming problem:\n    # maximize: sum(r_i)\n    # subject to:\n    #   r_i + r_j <= dist(c_i, c_j) for all i < j (non-overlap)\n    #   r_i <= min(c_i[0], 1-c_i[0], c_i[1], 1-c_i[1]) (boundary constraints)\n    #   r_i >= 0\n    \n    # Compute pairwise distances\n    distances = cdist(centers, centers)\n    \n    # Set up linear programming problem\n    # Variables: r_0, r_1, ..., r_25\n    # Objective: minimize -sum(r_i) (equivalent to maximizing sum(r_i))\n    c = -np.ones(n_circles)\n    \n    # Inequality constraints: A_ub @ r <= b_ub\n    A_ub = []\n    b_ub = []\n    \n    # Non-overlap constraints: r_i + r_j <= dist(i,j) for all i < j\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            constraint = np.zeros(n_circles)\n            constraint[i] = 1\n            constraint[j] = 1\n            A_ub.append(constraint)\n            b_ub.append(distances[i, j])\n    \n    # Boundary constraints for each circle\n    for i in range(n_circles):\n        cx, cy = centers[i]\n        \n        # r_i <= cx (left boundary)\n        constraint = np.zeros(n_circles)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(cx)\n        \n        # r_i <= 1 - cx (right boundary)\n        constraint = np.zeros(n_circles)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(1 - cx)\n        \n        # r_i <= cy (bottom boundary)\n        constraint = np.zeros(n_circles)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(cy)\n        \n        # r_i <= 1 - cy (top boundary)\n        constraint = np.zeros(n_circles)\n        constraint[i] = 1\n        A_ub.append(constraint)\n        b_ub.append(1 - cy)\n    \n    A_ub = np.array(A_ub)\n    b_ub = np.array(b_ub)\n    \n    # Bounds: r_i >= 0\n    bounds = [(0, None) for _ in range(n_circles)]\n    \n    # Solve linear program\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    \n    if result.success:\n        radii = result.x\n        sum_radii = np.sum(radii)\n    else:\n        # Fallback: use conservative radii\n        radii = np.zeros(n_circles)\n        for i in range(n_circles):\n            cx, cy = centers[i]\n            # Maximum radius respecting boundaries\n            max_r_boundary = min(cx, 1 - cx, cy, 1 - cy)\n            # Maximum radius respecting other circles\n            max_r_circles = np.inf\n            for j in range(n_circles):\n                if i != j:\n                    max_r_circles = min(max_r_circles, distances[i, j] / 2)\n            radii[i] = min(max_r_boundary, max_r_circles)\n        sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the two-phase circle packing optimization.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:46:20.491476",
  "cost_data": null
}