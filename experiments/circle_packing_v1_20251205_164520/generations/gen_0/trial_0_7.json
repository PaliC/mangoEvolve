{
  "trial_id": "trial_0_7",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing using physics-based repulsion forces.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize circles randomly in the domain\n    np.random.seed(42)\n    centers = np.random.uniform(0.1, 0.9, size=(n_circles, 2))\n    velocities = np.zeros((n_circles, 2))\n    \n    # Physics parameters\n    dt = 0.01\n    damping = 0.95\n    repulsion_strength = 0.01\n    boundary_strength = 0.1\n    n_iterations = 5000\n    \n    # Run physics simulation\n    for iteration in range(n_iterations):\n        forces = np.zeros((n_circles, 2))\n        \n        # Circle-circle repulsion forces\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist < 0.001:\n                    dist = 0.001\n                    diff = np.random.randn(2)\n                    diff /= np.linalg.norm(diff)\n                \n                # Repulsion force inversely proportional to distance\n                force_magnitude = repulsion_strength / (dist ** 2)\n                force = force_magnitude * diff / dist\n                \n                forces[i] += force\n                forces[j] -= force\n        \n        # Boundary forces (keep circles inside [0,1]x[0,1])\n        for i in range(n_circles):\n            # Left boundary\n            if centers[i, 0] < 0.1:\n                forces[i, 0] += boundary_strength * (0.1 - centers[i, 0])\n            # Right boundary\n            if centers[i, 0] > 0.9:\n                forces[i, 0] += boundary_strength * (0.9 - centers[i, 0])\n            # Bottom boundary\n            if centers[i, 1] < 0.1:\n                forces[i, 1] += boundary_strength * (0.1 - centers[i, 1])\n            # Top boundary\n            if centers[i, 1] > 0.9:\n                forces[i, 1] += boundary_strength * (0.9 - centers[i, 1])\n        \n        # Update velocities and positions\n        velocities += forces * dt\n        velocities *= damping\n        centers += velocities * dt\n        \n        # Hard boundary constraints\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    # Compute maximum radii for each circle\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Distance to boundaries\n        min_radius = min(\n            centers[i, 0],\n            1.0 - centers[i, 0],\n            centers[i, 1],\n            1.0 - centers[i, 1]\n        )\n        \n        # Distance to other circles\n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_radius = min(min_radius, dist / 2.0)\n        \n        radii[i] = min_radius\n    \n    # Iteratively grow radii to maximize packing\n    growth_iterations = 100\n    for _ in range(growth_iterations):\n        max_growth = np.full(n_circles, float('inf'))\n        \n        for i in range(n_circles):\n            # Check boundary constraints\n            max_growth[i] = min(\n                max_growth[i],\n                centers[i, 0] - radii[i],\n                1.0 - centers[i, 0] - radii[i],\n                centers[i, 1] - radii[i],\n                1.0 - centers[i, 1] - radii[i]\n            )\n            \n            # Check circle-circle constraints\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    available = dist - radii[i] - radii[j]\n                    max_growth[i] = min(max_growth[i], available)\n        \n        # Grow radii uniformly\n        growth = np.maximum(max_growth, 0.0)\n        growth_amount = np.min(growth) * 0.5\n        \n        if growth_amount < 1e-6:\n            break\n        \n        radii += growth_amount\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the circle packing algorithm.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.6898844419154613,
    "target_ratio": 0.6413223688483725,
    "combined_score": 0.6413223688483725,
    "eval_time": 5.123591899871826,
    "error": null
  },
  "prompt": "Write a physics-based circle packing using repulsion forces for 26 circles in [0,1]x[0,1].\n\nSimulate circles as particles with repulsion forces, let them settle into a stable configuration, then maximize radii.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Simulate repulsion between overlapping circles\n- Simulate boundary forces to keep circles inside\n- Iterate until stable, then compute radii\n- Do not print or plot anything\n\nStrategy: Physics simulation approach.",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing using physics-based repulsion forces.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize circles randomly in the domain\n    np.random.seed(42)\n    centers = np.random.uniform(0.1, 0.9, size=(n_circles, 2))\n    velocities = np.zeros((n_circles, 2))\n    \n    # Physics parameters\n    dt = 0.01\n    damping = 0.95\n    repulsion_strength = 0.01\n    boundary_strength = 0.1\n    n_iterations = 5000\n    \n    # Run physics simulation\n    for iteration in range(n_iterations):\n        forces = np.zeros((n_circles, 2))\n        \n        # Circle-circle repulsion forces\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist < 0.001:\n                    dist = 0.001\n                    diff = np.random.randn(2)\n                    diff /= np.linalg.norm(diff)\n                \n                # Repulsion force inversely proportional to distance\n                force_magnitude = repulsion_strength / (dist ** 2)\n                force = force_magnitude * diff / dist\n                \n                forces[i] += force\n                forces[j] -= force\n        \n        # Boundary forces (keep circles inside [0,1]x[0,1])\n        for i in range(n_circles):\n            # Left boundary\n            if centers[i, 0] < 0.1:\n                forces[i, 0] += boundary_strength * (0.1 - centers[i, 0])\n            # Right boundary\n            if centers[i, 0] > 0.9:\n                forces[i, 0] += boundary_strength * (0.9 - centers[i, 0])\n            # Bottom boundary\n            if centers[i, 1] < 0.1:\n                forces[i, 1] += boundary_strength * (0.1 - centers[i, 1])\n            # Top boundary\n            if centers[i, 1] > 0.9:\n                forces[i, 1] += boundary_strength * (0.9 - centers[i, 1])\n        \n        # Update velocities and positions\n        velocities += forces * dt\n        velocities *= damping\n        centers += velocities * dt\n        \n        # Hard boundary constraints\n        centers = np.clip(centers, 0.05, 0.95)\n    \n    # Compute maximum radii for each circle\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Distance to boundaries\n        min_radius = min(\n            centers[i, 0],\n            1.0 - centers[i, 0],\n            centers[i, 1],\n            1.0 - centers[i, 1]\n        )\n        \n        # Distance to other circles\n        for j in range(n_circles):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_radius = min(min_radius, dist / 2.0)\n        \n        radii[i] = min_radius\n    \n    # Iteratively grow radii to maximize packing\n    growth_iterations = 100\n    for _ in range(growth_iterations):\n        max_growth = np.full(n_circles, float('inf'))\n        \n        for i in range(n_circles):\n            # Check boundary constraints\n            max_growth[i] = min(\n                max_growth[i],\n                centers[i, 0] - radii[i],\n                1.0 - centers[i, 0] - radii[i],\n                centers[i, 1] - radii[i],\n                1.0 - centers[i, 1] - radii[i]\n            )\n            \n            # Check circle-circle constraints\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    available = dist - radii[i] - radii[j]\n                    max_growth[i] = min(max_growth[i], available)\n        \n        # Grow radii uniformly\n        growth = np.maximum(max_growth, 0.0)\n        growth_amount = np.min(growth) * 0.5\n        \n        if growth_amount < 1e-6:\n            break\n        \n        radii += growth_amount\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Entry point for the circle packing algorithm.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with circle centers\n        radii: np.array of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:46:23.282109",
  "cost_data": null
}