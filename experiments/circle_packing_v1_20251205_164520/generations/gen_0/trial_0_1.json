{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Greedy circle packing algorithm for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: np.array shape (26, 2) - circle centers\n        radii: np.array shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    \n    def max_radius_at_position(x, y, placed_centers, placed_radii, n_placed):\n        \"\"\"Calculate maximum radius for a circle at position (x, y)\"\"\"\n        # Distance to boundaries\n        r_max = min(x, y, 1 - x, 1 - y)\n        \n        # Distance to other circles\n        for i in range(n_placed):\n            dist = np.sqrt((x - placed_centers[i, 0])**2 + (y - placed_centers[i, 1])**2)\n            r_max = min(r_max, dist - placed_radii[i])\n        \n        return max(0, r_max)\n    \n    def objective(pos, placed_centers, placed_radii, n_placed):\n        \"\"\"Negative radius (for minimization)\"\"\"\n        x, y = pos\n        return -max_radius_at_position(x, y, placed_centers, placed_radii, n_placed)\n    \n    # Place circles one by one\n    for i in range(n_circles):\n        best_pos = None\n        best_radius = 0\n        \n        # Try multiple random starting points and optimization\n        n_attempts = 50 if i > 0 else 1\n        \n        if i == 0:\n            # First circle: place at center\n            best_pos = np.array([0.5, 0.5])\n            best_radius = 0.5\n        else:\n            # For subsequent circles, search for best position\n            for _ in range(n_attempts):\n                # Random initial position\n                x0 = np.random.uniform(0.1, 0.9, 2)\n                \n                # Optimize to find position with maximum radius\n                result = minimize(\n                    objective,\n                    x0,\n                    args=(centers, radii, i),\n                    method='L-BFGS-B',\n                    bounds=[(0.01, 0.99), (0.01, 0.99)]\n                )\n                \n                if result.success:\n                    pos = result.x\n                    r = max_radius_at_position(pos[0], pos[1], centers, radii, i)\n                    if r > best_radius:\n                        best_radius = r\n                        best_pos = pos\n            \n            # Also try grid search for robustness\n            grid_size = 15\n            x_grid = np.linspace(0.05, 0.95, grid_size)\n            y_grid = np.linspace(0.05, 0.95, grid_size)\n            \n            for x in x_grid:\n                for y in y_grid:\n                    r = max_radius_at_position(x, y, centers, radii, i)\n                    if r > best_radius:\n                        best_radius = r\n                        best_pos = np.array([x, y])\n        \n        # Place the circle\n        if best_pos is not None and best_radius > 0:\n            centers[i] = best_pos\n            radii[i] = best_radius\n        else:\n            # Fallback: place very small circle at random valid position\n            for attempt in range(100):\n                pos = np.random.uniform(0.1, 0.9, 2)\n                r = max_radius_at_position(pos[0], pos[1], centers, radii, i)\n                if r > 0:\n                    centers[i] = pos\n                    radii[i] = r\n                    break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"Entry point for circle packing algorithm\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.275267311758171,
    "target_ratio": 0.4839724143294767,
    "combined_score": 0.4839724143294767,
    "eval_time": 0.5554671287536621,
    "error": null
  },
  "prompt": "Write a greedy circle packing algorithm for 26 circles in [0,1]x[0,1].\n\nPlace circles one at a time, each time choosing the position that allows the largest possible radius while avoiding overlaps and staying in bounds.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- centers: np.array shape (26, 2)\n- radii: np.array shape (26,)\n- Ensure no overlaps and all circles inside [0,1]x[0,1]\n- Do not print or plot anything\n\nStrategy: Iteratively place circles at positions that maximize individual radius.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Greedy circle packing algorithm for 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: np.array shape (26, 2) - circle centers\n        radii: np.array shape (26,) - circle radii\n        sum_radii: float - sum of all radii\n    \"\"\"\n    n_circles = 26\n    centers = np.zeros((n_circles, 2))\n    radii = np.zeros(n_circles)\n    \n    def max_radius_at_position(x, y, placed_centers, placed_radii, n_placed):\n        \"\"\"Calculate maximum radius for a circle at position (x, y)\"\"\"\n        # Distance to boundaries\n        r_max = min(x, y, 1 - x, 1 - y)\n        \n        # Distance to other circles\n        for i in range(n_placed):\n            dist = np.sqrt((x - placed_centers[i, 0])**2 + (y - placed_centers[i, 1])**2)\n            r_max = min(r_max, dist - placed_radii[i])\n        \n        return max(0, r_max)\n    \n    def objective(pos, placed_centers, placed_radii, n_placed):\n        \"\"\"Negative radius (for minimization)\"\"\"\n        x, y = pos\n        return -max_radius_at_position(x, y, placed_centers, placed_radii, n_placed)\n    \n    # Place circles one by one\n    for i in range(n_circles):\n        best_pos = None\n        best_radius = 0\n        \n        # Try multiple random starting points and optimization\n        n_attempts = 50 if i > 0 else 1\n        \n        if i == 0:\n            # First circle: place at center\n            best_pos = np.array([0.5, 0.5])\n            best_radius = 0.5\n        else:\n            # For subsequent circles, search for best position\n            for _ in range(n_attempts):\n                # Random initial position\n                x0 = np.random.uniform(0.1, 0.9, 2)\n                \n                # Optimize to find position with maximum radius\n                result = minimize(\n                    objective,\n                    x0,\n                    args=(centers, radii, i),\n                    method='L-BFGS-B',\n                    bounds=[(0.01, 0.99), (0.01, 0.99)]\n                )\n                \n                if result.success:\n                    pos = result.x\n                    r = max_radius_at_position(pos[0], pos[1], centers, radii, i)\n                    if r > best_radius:\n                        best_radius = r\n                        best_pos = pos\n            \n            # Also try grid search for robustness\n            grid_size = 15\n            x_grid = np.linspace(0.05, 0.95, grid_size)\n            y_grid = np.linspace(0.05, 0.95, grid_size)\n            \n            for x in x_grid:\n                for y in y_grid:\n                    r = max_radius_at_position(x, y, centers, radii, i)\n                    if r > best_radius:\n                        best_radius = r\n                        best_pos = np.array([x, y])\n        \n        # Place the circle\n        if best_pos is not None and best_radius > 0:\n            centers[i] = best_pos\n            radii[i] = best_radius\n        else:\n            # Fallback: place very small circle at random valid position\n            for attempt in range(100):\n                pos = np.random.uniform(0.1, 0.9, 2)\n                r = max_radius_at_position(pos[0], pos[1], centers, radii, i)\n                if r > 0:\n                    centers[i] = pos\n                    radii[i] = r\n                    break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"Entry point for circle packing algorithm\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:46:15.777933",
  "cost_data": null
}