{
  "trial_id": "trial_0_12",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a multi-scale circle packing with 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    def is_valid(x, y, r, existing_centers, existing_radii):\n        \"\"\"Check if a circle at (x, y) with radius r is valid.\"\"\"\n        # Check bounds\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n        \n        # Check overlap with existing circles\n        for (cx, cy), cr in zip(existing_centers, existing_radii):\n            dist = np.sqrt((x - cx)**2 + (y - cy)**2)\n            if dist < r + cr:\n                return False\n        \n        return True\n    \n    def add_circle(x, y, r):\n        \"\"\"Add a circle to the packing.\"\"\"\n        centers.append([x, y])\n        radii.append(r)\n    \n    # Level 1: Large circles (3 circles)\n    large_radius = 0.18\n    large_positions = [\n        (0.25, 0.25),\n        (0.75, 0.25),\n        (0.5, 0.7)\n    ]\n    \n    for x, y in large_positions:\n        if is_valid(x, y, large_radius, centers, radii):\n            add_circle(x, y, large_radius)\n    \n    # Level 2: Medium circles (6 circles)\n    medium_radius = 0.12\n    medium_positions = [\n        (0.15, 0.65),\n        (0.85, 0.65),\n        (0.5, 0.15),\n        (0.15, 0.88),\n        (0.85, 0.88),\n        (0.5, 0.45)\n    ]\n    \n    for x, y in medium_positions:\n        if is_valid(x, y, medium_radius, centers, radii):\n            add_circle(x, y, medium_radius)\n    \n    # Level 3: Small circles (8 circles)\n    small_radius = 0.075\n    small_positions = [\n        (0.12, 0.12),\n        (0.88, 0.12),\n        (0.35, 0.52),\n        (0.65, 0.52),\n        (0.30, 0.85),\n        (0.70, 0.85),\n        (0.65, 0.15),\n        (0.35, 0.15)\n    ]\n    \n    for x, y in small_positions:\n        if is_valid(x, y, small_radius, centers, radii):\n            add_circle(x, y, small_radius)\n    \n    # Level 4: Tiny circles to fill gaps (remaining circles to reach 26)\n    tiny_radius = 0.045\n    \n    # Grid search for remaining positions\n    grid_points = []\n    for i in np.linspace(0.05, 0.95, 20):\n        for j in np.linspace(0.05, 0.95, 20):\n            grid_points.append((i, j))\n    \n    # Shuffle for variety\n    np.random.seed(42)\n    np.random.shuffle(grid_points)\n    \n    for x, y in grid_points:\n        if len(centers) >= 26:\n            break\n        if is_valid(x, y, tiny_radius, centers, radii):\n            add_circle(x, y, tiny_radius)\n    \n    # If still need more circles, try even smaller radius\n    if len(centers) < 26:\n        extra_tiny_radius = 0.03\n        np.random.seed(43)\n        np.random.shuffle(grid_points)\n        \n        for x, y in grid_points:\n            if len(centers) >= 26:\n                break\n            if is_valid(x, y, extra_tiny_radius, centers, radii):\n                add_circle(x, y, extra_tiny_radius)\n    \n    centers_array = np.array(centers)\n    radii_array = np.array(radii)\n    sum_radii = np.sum(radii_array)\n    \n    return centers_array, radii_array, sum_radii\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Entry point for circle packing.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2)\n        radii: np.ndarray of shape (26,)\n        sum_radii: float\n    \"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.7249999999999996,
    "target_ratio": 0.6546489563567361,
    "combined_score": 0.6546489563567361,
    "eval_time": 0.07127594947814941,
    "error": null
  },
  "prompt": "Write a multi-scale circle packing for 26 circles in [0,1]x[0,1].\n\nUse circles of varying sizes - place larger circles first, then fill gaps with smaller ones.\n\nRequirements:\n- Define construct_packing() returning (centers, radii, sum_radii)\n- Define run_packing() as entry point\n- Start with a few large circles\n- Fill remaining space with progressively smaller circles\n- Total 26 circles\n- Do not print or plot anything\n\nStrategy: Hierarchical size-based packing.",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple, List\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct a multi-scale circle packing with 26 circles in [0,1]x[0,1].\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2) with circle centers\n        radii: np.ndarray of shape (26,) with circle radii\n        sum_radii: float, sum of all radii\n    \"\"\"\n    centers = []\n    radii = []\n    \n    def is_valid(x, y, r, existing_centers, existing_radii):\n        \"\"\"Check if a circle at (x, y) with radius r is valid.\"\"\"\n        # Check bounds\n        if x - r < 0 or x + r > 1 or y - r < 0 or y + r > 1:\n            return False\n        \n        # Check overlap with existing circles\n        for (cx, cy), cr in zip(existing_centers, existing_radii):\n            dist = np.sqrt((x - cx)**2 + (y - cy)**2)\n            if dist < r + cr:\n                return False\n        \n        return True\n    \n    def add_circle(x, y, r):\n        \"\"\"Add a circle to the packing.\"\"\"\n        centers.append([x, y])\n        radii.append(r)\n    \n    # Level 1: Large circles (3 circles)\n    large_radius = 0.18\n    large_positions = [\n        (0.25, 0.25),\n        (0.75, 0.25),\n        (0.5, 0.7)\n    ]\n    \n    for x, y in large_positions:\n        if is_valid(x, y, large_radius, centers, radii):\n            add_circle(x, y, large_radius)\n    \n    # Level 2: Medium circles (6 circles)\n    medium_radius = 0.12\n    medium_positions = [\n        (0.15, 0.65),\n        (0.85, 0.65),\n        (0.5, 0.15),\n        (0.15, 0.88),\n        (0.85, 0.88),\n        (0.5, 0.45)\n    ]\n    \n    for x, y in medium_positions:\n        if is_valid(x, y, medium_radius, centers, radii):\n            add_circle(x, y, medium_radius)\n    \n    # Level 3: Small circles (8 circles)\n    small_radius = 0.075\n    small_positions = [\n        (0.12, 0.12),\n        (0.88, 0.12),\n        (0.35, 0.52),\n        (0.65, 0.52),\n        (0.30, 0.85),\n        (0.70, 0.85),\n        (0.65, 0.15),\n        (0.35, 0.15)\n    ]\n    \n    for x, y in small_positions:\n        if is_valid(x, y, small_radius, centers, radii):\n            add_circle(x, y, small_radius)\n    \n    # Level 4: Tiny circles to fill gaps (remaining circles to reach 26)\n    tiny_radius = 0.045\n    \n    # Grid search for remaining positions\n    grid_points = []\n    for i in np.linspace(0.05, 0.95, 20):\n        for j in np.linspace(0.05, 0.95, 20):\n            grid_points.append((i, j))\n    \n    # Shuffle for variety\n    np.random.seed(42)\n    np.random.shuffle(grid_points)\n    \n    for x, y in grid_points:\n        if len(centers) >= 26:\n            break\n        if is_valid(x, y, tiny_radius, centers, radii):\n            add_circle(x, y, tiny_radius)\n    \n    # If still need more circles, try even smaller radius\n    if len(centers) < 26:\n        extra_tiny_radius = 0.03\n        np.random.seed(43)\n        np.random.shuffle(grid_points)\n        \n        for x, y in grid_points:\n            if len(centers) >= 26:\n                break\n            if is_valid(x, y, extra_tiny_radius, centers, radii):\n                add_circle(x, y, extra_tiny_radius)\n    \n    centers_array = np.array(centers)\n    radii_array = np.array(radii)\n    sum_radii = np.sum(radii_array)\n    \n    return centers_array, radii_array, sum_radii\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Entry point for circle packing.\n    \n    Returns:\n        centers: np.ndarray of shape (26, 2)\n        radii: np.ndarray of shape (26,)\n        sum_radii: float\n    \"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:46:16.548184",
  "cost_data": null
}