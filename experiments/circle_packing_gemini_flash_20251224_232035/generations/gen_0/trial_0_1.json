{
  "trial_id": "trial_0_1",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using \n    a greedy placement strategy. Each circle is placed to maximize its \n    radius given the existing circles and the square boundaries.\n    \"\"\"\n    n = 26\n    centers = []\n    radii = []\n    \n    # Grid for searching potential center locations\n    # A finer grid increases precision/radii sum but takes more time.\n    grid_res = 80 \n    x_grid = np.linspace(0, 1, grid_res)\n    y_grid = np.linspace(0, 1, grid_res)\n    xv, yv = np.meshgrid(x_grid, y_grid)\n    grid_points = np.vstack([xv.ravel(), yv.ravel()]).T\n\n    for i in range(n):\n        best_r = -1.0\n        best_pos = np.array([0.5, 0.5])\n        \n        # Candidate positions: grid points + some random jitter to escape local patterns\n        candidates = grid_points\n        \n        for pos in candidates:\n            # Distance to boundaries: r <= x, r <= 1-x, r <= y, r <= 1-y\n            r_bound = min(pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1])\n            \n            if r_bound <= 0:\n                continue\n                \n            # Distance to existing circles: dist(C_i, C_new) >= r_i + r_new\n            # => r_new <= dist(C_i, C_new) - r_i\n            r_circles = float('inf')\n            valid = True\n            for j in range(len(centers)):\n                dist = np.linalg.norm(pos - centers[j])\n                r_limit = dist - radii[j]\n                if r_limit <= 0:\n                    valid = False\n                    break\n                if r_limit < r_circles:\n                    r_circles = r_limit\n            \n            if not valid:\n                continue\n                \n            r_candidate = min(r_bound, r_circles)\n            \n            if r_candidate > best_r:\n                best_r = r_candidate\n                best_pos = pos\n        \n        # Final safety check and storage\n        if best_r <= 0:\n            # If no space, place a tiny circle at a corner\n            centers.append(np.array([0.0, 0.0]))\n            radii.append(0.0)\n        else:\n            centers.append(best_pos)\n            radii.append(best_r)\n\n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 1.424719278336163,
    "eval_time": 0.5151379108428955,
    "error": null
  },
  "prompt": "Implement a greedy circle packing algorithm for 26 circles. Place circles one by one at the position that allows for the largest possible radius given the existing circles and the unit square boundaries. Use a fine grid search for each placement.",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using \n    a greedy placement strategy. Each circle is placed to maximize its \n    radius given the existing circles and the square boundaries.\n    \"\"\"\n    n = 26\n    centers = []\n    radii = []\n    \n    # Grid for searching potential center locations\n    # A finer grid increases precision/radii sum but takes more time.\n    grid_res = 80 \n    x_grid = np.linspace(0, 1, grid_res)\n    y_grid = np.linspace(0, 1, grid_res)\n    xv, yv = np.meshgrid(x_grid, y_grid)\n    grid_points = np.vstack([xv.ravel(), yv.ravel()]).T\n\n    for i in range(n):\n        best_r = -1.0\n        best_pos = np.array([0.5, 0.5])\n        \n        # Candidate positions: grid points + some random jitter to escape local patterns\n        candidates = grid_points\n        \n        for pos in candidates:\n            # Distance to boundaries: r <= x, r <= 1-x, r <= y, r <= 1-y\n            r_bound = min(pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1])\n            \n            if r_bound <= 0:\n                continue\n                \n            # Distance to existing circles: dist(C_i, C_new) >= r_i + r_new\n            # => r_new <= dist(C_i, C_new) - r_i\n            r_circles = float('inf')\n            valid = True\n            for j in range(len(centers)):\n                dist = np.linalg.norm(pos - centers[j])\n                r_limit = dist - radii[j]\n                if r_limit <= 0:\n                    valid = False\n                    break\n                if r_limit < r_circles:\n                    r_circles = r_limit\n            \n            if not valid:\n                continue\n                \n            r_candidate = min(r_bound, r_circles)\n            \n            if r_candidate > best_r:\n                best_r = r_candidate\n                best_pos = pos\n        \n        # Final safety check and storage\n        if best_r <= 0:\n            # If no space, place a tiny circle at a corner\n            centers.append(np.array([0.0, 0.0]))\n            radii.append(0.0)\n        else:\n            centers.append(best_pos)\n            radii.append(best_r)\n\n    centers = np.array(centers)\n    radii = np.array(radii)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:20:51.466820",
  "cost_data": null
}