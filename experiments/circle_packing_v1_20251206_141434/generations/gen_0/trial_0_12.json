{
  "trial_id": "trial_0_12",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.spatial import Voronoi\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    np.random.seed(42)  # For reproducibility\n    \n    # Generate 26 random seed points in [0,1]x[0,1]\n    n_circles = 26\n    centers = np.random.rand(n_circles, 2)\n    \n    # Add boundary points to help with edge cases\n    # This ensures Voronoi cells near boundaries are properly bounded\n    boundary_points = np.array([\n        [-1, -1], [-1, 0], [-1, 1], [-1, 2],\n        [0, -1], [0, 2],\n        [1, -1], [1, 2],\n        [2, -1], [2, 0], [2, 1], [2, 2]\n    ])\n    \n    # Combine seed points with boundary points for Voronoi computation\n    all_points = np.vstack([centers, boundary_points])\n    \n    # Compute Voronoi diagram\n    vor = Voronoi(all_points)\n    \n    # Calculate radius for each circle based on its Voronoi cell\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Get the Voronoi region for this seed point\n        region_index = vor.point_region[i]\n        vertex_indices = vor.regions[region_index]\n        \n        # Skip if region is open (shouldn't happen with boundary points)\n        if -1 in vertex_indices or len(vertex_indices) == 0:\n            radii[i] = 0.01\n            continue\n        \n        # Get vertices of the Voronoi cell\n        vertices = vor.vertices[vertex_indices]\n        \n        # Clip vertices to [0,1]x[0,1] domain\n        vertices = np.clip(vertices, 0, 1)\n        \n        # Calculate minimum distance from seed to Voronoi cell edges\n        # This ensures the circle fits within its cell\n        min_dist = float('inf')\n        \n        # Check distance to each edge of the Voronoi cell\n        for j in range(len(vertices)):\n            v1 = vertices[j]\n            v2 = vertices[(j + 1) % len(vertices)]\n            \n            # Distance from point to line segment\n            dist = point_to_segment_distance(centers[i], v1, v2)\n            min_dist = min(min_dist, dist)\n        \n        # Also check distance to domain boundaries [0,1]x[0,1]\n        x, y = centers[i]\n        boundary_dists = [x, 1-x, y, 1-y]\n        min_dist = min(min_dist, min(boundary_dists))\n        \n        # Set radius to a fraction of the minimum distance to ensure non-overlap\n        # Using 0.95 to leave small gaps and ensure circles stay within bounds\n        radii[i] = max(0.01, min_dist * 0.95)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef point_to_segment_distance(point, seg_start, seg_end):\n    \"\"\"Calculate minimum distance from a point to a line segment\"\"\"\n    # Vector from seg_start to seg_end\n    segment = seg_end - seg_start\n    segment_length_sq = np.dot(segment, segment)\n    \n    if segment_length_sq == 0:\n        # Segment is a point\n        return np.linalg.norm(point - seg_start)\n    \n    # Project point onto the line, parameterized by t\n    t = np.dot(point - seg_start, segment) / segment_length_sq\n    t = np.clip(t, 0, 1)  # Clamp to segment\n    \n    # Find closest point on segment\n    closest_point = seg_start + t * segment\n    \n    return np.linalg.norm(point - closest_point)\n\n\ndef run_packing():\n    return construct_packing()\n\n\n# Example usage and visualization\nif __name__ == \"__main__\":\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n    \n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"Average radius: {np.mean(radii):.4f}\")\n    print(f\"Min radius: {np.min(radii):.4f}\")\n    print(f\"Max radius: {np.max(radii):.4f}\")\n    \n    # Visualize the packing\n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw circles\n    for center, radius in zip(centers, radii):\n        circle = Circle(center, radius, fill=False, edgecolor='blue', linewidth=1.5)\n        ax.add_patch(circle)\n        ax.plot(center[0], center[1], 'r.', markersize=4)\n    \n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Voronoi-based Circle Packing (26 circles, sum of radii: {sum_radii:.3f})')\n    ax.set_xlabel('x')\n    ax.set_ylabel('y')\n    \n    plt.tight_layout()\n    plt.savefig('voronoi_packing.png', dpi=150, bbox_inches='tight')\n    plt.show()",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 0.1331038475036621,
    "error": "Circles 8 and 23 overlap: distance=0.008818, required=0.019999"
  },
  "prompt": "Write a Voronoi-based circle packing for 26 circles in [0,1]x[0,1].\n\nGenerate 26 random seed points, compute Voronoi diagram, then place circles at seeds\nwith radii based on the size of their Voronoi cells.\n\nInclude these exact functions:\n```python\nimport numpy as np\nfrom scipy.spatial import Voronoi\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    pass\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.spatial import Voronoi\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    np.random.seed(42)  # For reproducibility\n    \n    # Generate 26 random seed points in [0,1]x[0,1]\n    n_circles = 26\n    centers = np.random.rand(n_circles, 2)\n    \n    # Add boundary points to help with edge cases\n    # This ensures Voronoi cells near boundaries are properly bounded\n    boundary_points = np.array([\n        [-1, -1], [-1, 0], [-1, 1], [-1, 2],\n        [0, -1], [0, 2],\n        [1, -1], [1, 2],\n        [2, -1], [2, 0], [2, 1], [2, 2]\n    ])\n    \n    # Combine seed points with boundary points for Voronoi computation\n    all_points = np.vstack([centers, boundary_points])\n    \n    # Compute Voronoi diagram\n    vor = Voronoi(all_points)\n    \n    # Calculate radius for each circle based on its Voronoi cell\n    radii = np.zeros(n_circles)\n    \n    for i in range(n_circles):\n        # Get the Voronoi region for this seed point\n        region_index = vor.point_region[i]\n        vertex_indices = vor.regions[region_index]\n        \n        # Skip if region is open (shouldn't happen with boundary points)\n        if -1 in vertex_indices or len(vertex_indices) == 0:\n            radii[i] = 0.01\n            continue\n        \n        # Get vertices of the Voronoi cell\n        vertices = vor.vertices[vertex_indices]\n        \n        # Clip vertices to [0,1]x[0,1] domain\n        vertices = np.clip(vertices, 0, 1)\n        \n        # Calculate minimum distance from seed to Voronoi cell edges\n        # This ensures the circle fits within its cell\n        min_dist = float('inf')\n        \n        # Check distance to each edge of the Voronoi cell\n        for j in range(len(vertices)):\n            v1 = vertices[j]\n            v2 = vertices[(j + 1) % len(vertices)]\n            \n            # Distance from point to line segment\n            dist = point_to_segment_distance(centers[i], v1, v2)\n            min_dist = min(min_dist, dist)\n        \n        # Also check distance to domain boundaries [0,1]x[0,1]\n        x, y = centers[i]\n        boundary_dists = [x, 1-x, y, 1-y]\n        min_dist = min(min_dist, min(boundary_dists))\n        \n        # Set radius to a fraction of the minimum distance to ensure non-overlap\n        # Using 0.95 to leave small gaps and ensure circles stay within bounds\n        radii[i] = max(0.01, min_dist * 0.95)\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef point_to_segment_distance(point, seg_start, seg_end):\n    \"\"\"Calculate minimum distance from a point to a line segment\"\"\"\n    # Vector from seg_start to seg_end\n    segment = seg_end - seg_start\n    segment_length_sq = np.dot(segment, segment)\n    \n    if segment_length_sq == 0:\n        # Segment is a point\n        return np.linalg.norm(point - seg_start)\n    \n    # Project point onto the line, parameterized by t\n    t = np.dot(point - seg_start, segment) / segment_length_sq\n    t = np.clip(t, 0, 1)  # Clamp to segment\n    \n    # Find closest point on segment\n    closest_point = seg_start + t * segment\n    \n    return np.linalg.norm(point - closest_point)\n\n\ndef run_packing():\n    return construct_packing()\n\n\n# Example usage and visualization\nif __name__ == \"__main__\":\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n    \n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Number of circles: {len(centers)}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"Average radius: {np.mean(radii):.4f}\")\n    print(f\"Min radius: {np.min(radii):.4f}\")\n    print(f\"Max radius: {np.max(radii):.4f}\")\n    \n    # Visualize the packing\n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw circles\n    for center, radius in zip(centers, radii):\n        circle = Circle(center, radius, fill=False, edgecolor='blue', linewidth=1.5)\n        ax.add_patch(circle)\n        ax.plot(center[0], center[1], 'r.', markersize=4)\n    \n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Voronoi-based Circle Packing (26 circles, sum of radii: {sum_radii:.3f})')\n    ax.set_xlabel('x')\n    ax.set_ylabel('y')\n    \n    plt.tight_layout()\n    plt.savefig('voronoi_packing.png', dpi=150, bbox_inches='tight')\n    plt.show()\n```\n\nThis implementation:\n\n1. **Generates 26 random seed points** in the unit square [0,1]\u00d7[0,1]\n2. **Adds boundary points** outside the domain to ensure proper Voronoi cells at edges\n3. **Computes the Voronoi diagram** using scipy\n4. **Calculates radii** based on the distance from each seed to its Voronoi cell boundaries\n5. **Clips to domain boundaries** to ensure circles stay within [0,1]\u00d7[0,1]\n6. **Returns the required tuple** (centers, radii, sum_radii)\n\nThe key insight is that each circle's radius is set to be slightly smaller than the minimum distance to its Voronoi cell edges, ensuring non-overlapping circles that efficiently pack the space based on the local density of seed points.",
  "reasoning": "This implementation:\n\n1. **Generates 26 random seed points** in the unit square [0,1]\u00d7[0,1]\n2. **Adds boundary points** outside the domain to ensure proper Voronoi cells at edges\n3. **Computes the Voronoi diagram** using scipy\n4. **Calculates radii** based on the distance from each seed to its Voronoi cell boundaries\n5. **Clips to domain boundaries** to ensure circles stay within [0,1]\u00d7[0,1]\n6. **Returns the required tuple** (centers, radii, sum_radii)\n\nThe key insight is that each circle's radius is set to be slightly smaller than the minimum distance to its Voronoi cell edges, ensuring non-overlapping circles that efficiently pack the space based on the local density of seed points.",
  "timestamp": "2025-12-06T14:15:35.839376",
  "cost_data": null
}