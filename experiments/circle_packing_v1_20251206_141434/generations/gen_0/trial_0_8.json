{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    \n    # Genetic Algorithm parameters\n    POPULATION_SIZE = 100\n    GENERATIONS = 500\n    MUTATION_RATE = 0.15\n    ELITE_SIZE = 10\n    TOURNAMENT_SIZE = 5\n    NUM_CIRCLES = 26\n    \n    def create_individual():\n        \"\"\"Create a random packing individual\"\"\"\n        centers = np.random.rand(NUM_CIRCLES, 2)\n        radii = np.random.rand(NUM_CIRCLES) * 0.1 + 0.01\n        return {'centers': centers, 'radii': radii}\n    \n    def calculate_fitness(individual):\n        \"\"\"Calculate fitness based on sum of radii with penalties for overlaps and boundary violations\"\"\"\n        centers = individual['centers']\n        radii = individual['radii']\n        \n        # Check boundary constraints\n        boundary_penalty = 0\n        for i in range(NUM_CIRCLES):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                boundary_penalty += radii[i] * 10\n        \n        # Check circle overlaps\n        overlap_penalty = 0\n        for i in range(NUM_CIRCLES):\n            for j in range(i + 1, NUM_CIRCLES):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap_penalty += (min_dist - dist) * 10\n        \n        # Fitness = sum of radii minus penalties\n        sum_radii = np.sum(radii)\n        fitness = sum_radii - boundary_penalty - overlap_penalty\n        \n        return fitness, sum_radii\n    \n    def repair_individual(individual):\n        \"\"\"Repair individual to satisfy constraints\"\"\"\n        centers = individual['centers']\n        radii = individual['radii']\n        \n        # Clamp radii to reasonable bounds\n        radii = np.clip(radii, 0.005, 0.2)\n        \n        # Ensure circles stay within boundaries\n        for i in range(NUM_CIRCLES):\n            centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n            centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n        \n        # Try to separate overlapping circles\n        for iteration in range(5):\n            for i in range(NUM_CIRCLES):\n                for j in range(i + 1, NUM_CIRCLES):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_dist = radii[i] + radii[j]\n                    if dist < min_dist and dist > 0:\n                        # Push circles apart\n                        direction = (centers[j] - centers[i]) / dist\n                        overlap = min_dist - dist\n                        centers[i] -= direction * overlap * 0.5\n                        centers[j] += direction * overlap * 0.5\n                        \n                        # Keep within bounds\n                        centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                        centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n                        centers[j, 0] = np.clip(centers[j, 0], radii[j], 1 - radii[j])\n                        centers[j, 1] = np.clip(centers[j, 1], radii[j], 1 - radii[j])\n        \n        individual['centers'] = centers\n        individual['radii'] = radii\n        return individual\n    \n    def tournament_selection(population, fitnesses):\n        \"\"\"Select individual using tournament selection\"\"\"\n        tournament_idx = np.random.choice(len(population), TOURNAMENT_SIZE, replace=False)\n        tournament_fitnesses = [fitnesses[i] for i in tournament_idx]\n        winner_idx = tournament_idx[np.argmax(tournament_fitnesses)]\n        return population[winner_idx]\n    \n    def crossover(parent1, parent2):\n        \"\"\"Combine two parents to create offspring\"\"\"\n        child = create_individual()\n        \n        # Randomly select circles from each parent\n        mask = np.random.rand(NUM_CIRCLES) < 0.5\n        \n        for i in range(NUM_CIRCLES):\n            if mask[i]:\n                child['centers'][i] = parent1['centers'][i].copy()\n                child['radii'][i] = parent1['radii'][i]\n            else:\n                child['centers'][i] = parent2['centers'][i].copy()\n                child['radii'][i] = parent2['radii'][i]\n        \n        return child\n    \n    def mutate(individual):\n        \"\"\"Randomly adjust positions and radii\"\"\"\n        mutated = {\n            'centers': individual['centers'].copy(),\n            'radii': individual['radii'].copy()\n        }\n        \n        for i in range(NUM_CIRCLES):\n            if np.random.rand() < MUTATION_RATE:\n                # Mutate center position\n                mutated['centers'][i] += np.random.randn(2) * 0.05\n                mutated['centers'][i] = np.clip(mutated['centers'][i], 0, 1)\n            \n            if np.random.rand() < MUTATION_RATE:\n                # Mutate radius\n                mutated['radii'][i] += np.random.randn() * 0.01\n                mutated['radii'][i] = np.clip(mutated['radii'][i], 0.005, 0.2)\n        \n        return mutated\n    \n    # Initialize population\n    population = [create_individual() for _ in range(POPULATION_SIZE)]\n    population = [repair_individual(ind) for ind in population]\n    \n    best_individual = None\n    best_fitness = -np.inf\n    best_sum_radii = 0\n    \n    # Evolution loop\n    for generation in range(GENERATIONS):\n        # Evaluate fitness\n        fitness_scores = []\n        sum_radii_scores = []\n        \n        for ind in population:\n            fitness, sum_radii = calculate_fitness(ind)\n            fitness_scores.append(fitness)\n            sum_radii_scores.append(sum_radii)\n        \n        # Track best individual\n        max_fitness_idx = np.argmax(fitness_scores)\n        if fitness_scores[max_fitness_idx] > best_fitness:\n            best_fitness = fitness_scores[max_fitness_idx]\n            best_individual = {\n                'centers': population[max_fitness_idx]['centers'].copy(),\n                'radii': population[max_fitness_idx]['radii'].copy()\n            }\n            best_sum_radii = sum_radii_scores[max_fitness_idx]\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism: keep best individuals\n        elite_indices = np.argsort(fitness_scores)[-ELITE_SIZE:]\n        for idx in elite_indices:\n            new_population.append({\n                'centers': population[idx]['centers'].copy(),\n                'radii': population[idx]['radii'].copy()\n            })\n        \n        # Generate offspring\n        while len(new_population) < POPULATION_SIZE:\n            parent1 = tournament_selection(population, fitness_scores)\n            parent2 = tournament_selection(population, fitness_scores)\n            \n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            child = repair_individual(child)\n            \n            new_population.append(child)\n        \n        population = new_population\n        \n        if generation % 50 == 0:\n            print(f\"Generation {generation}: Best fitness = {best_fitness:.4f}, Sum radii = {best_sum_radii:.4f}\")\n    \n    # Return best packing found\n    centers = best_individual['centers']\n    radii = best_individual['radii']\n    sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal best sum of radii: {sum_radii:.4f}\")\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"\\nPacking complete!\")\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"Average radius: {np.mean(radii):.4f}\")\n    print(f\"Min radius: {np.min(radii):.4f}\")\n    print(f\"Max radius: {np.max(radii):.4f}\")\n    \n    # Optional: Visualize the packing\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        \n        for i in range(len(radii)):\n            circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n            ax.add_patch(circle)\n        \n        ax.set_title(f'Circle Packing: 26 circles, Sum of radii = {sum_radii:.4f}')\n        plt.grid(True, alpha=0.3)\n        plt.show()\n    except ImportError:\n        print(\"Matplotlib not available for visualization\")",
  "metrics": {
    "valid": false,
    "sum_radii": 0.0,
    "target_ratio": 0.0,
    "combined_score": 0.0,
    "eval_time": 166.79182314872742,
    "error": "Circles 2 and 11 overlap: distance=0.160484, required=0.160536"
  },
  "prompt": "Write a genetic algorithm for circle packing 26 circles in [0,1]x[0,1].\n\nUse a population of candidate packings, evolve through:\n- Selection: Keep high-scoring packings\n- Crossover: Combine positions from two parents\n- Mutation: Randomly adjust positions/radii\n\nRun for multiple generations to optimize sum of radii.\n\nInclude these exact functions:\n```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    pass\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    \n    # Genetic Algorithm parameters\n    POPULATION_SIZE = 100\n    GENERATIONS = 500\n    MUTATION_RATE = 0.15\n    ELITE_SIZE = 10\n    TOURNAMENT_SIZE = 5\n    NUM_CIRCLES = 26\n    \n    def create_individual():\n        \"\"\"Create a random packing individual\"\"\"\n        centers = np.random.rand(NUM_CIRCLES, 2)\n        radii = np.random.rand(NUM_CIRCLES) * 0.1 + 0.01\n        return {'centers': centers, 'radii': radii}\n    \n    def calculate_fitness(individual):\n        \"\"\"Calculate fitness based on sum of radii with penalties for overlaps and boundary violations\"\"\"\n        centers = individual['centers']\n        radii = individual['radii']\n        \n        # Check boundary constraints\n        boundary_penalty = 0\n        for i in range(NUM_CIRCLES):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                boundary_penalty += radii[i] * 10\n        \n        # Check circle overlaps\n        overlap_penalty = 0\n        for i in range(NUM_CIRCLES):\n            for j in range(i + 1, NUM_CIRCLES):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if dist < min_dist:\n                    overlap_penalty += (min_dist - dist) * 10\n        \n        # Fitness = sum of radii minus penalties\n        sum_radii = np.sum(radii)\n        fitness = sum_radii - boundary_penalty - overlap_penalty\n        \n        return fitness, sum_radii\n    \n    def repair_individual(individual):\n        \"\"\"Repair individual to satisfy constraints\"\"\"\n        centers = individual['centers']\n        radii = individual['radii']\n        \n        # Clamp radii to reasonable bounds\n        radii = np.clip(radii, 0.005, 0.2)\n        \n        # Ensure circles stay within boundaries\n        for i in range(NUM_CIRCLES):\n            centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n            centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n        \n        # Try to separate overlapping circles\n        for iteration in range(5):\n            for i in range(NUM_CIRCLES):\n                for j in range(i + 1, NUM_CIRCLES):\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    min_dist = radii[i] + radii[j]\n                    if dist < min_dist and dist > 0:\n                        # Push circles apart\n                        direction = (centers[j] - centers[i]) / dist\n                        overlap = min_dist - dist\n                        centers[i] -= direction * overlap * 0.5\n                        centers[j] += direction * overlap * 0.5\n                        \n                        # Keep within bounds\n                        centers[i, 0] = np.clip(centers[i, 0], radii[i], 1 - radii[i])\n                        centers[i, 1] = np.clip(centers[i, 1], radii[i], 1 - radii[i])\n                        centers[j, 0] = np.clip(centers[j, 0], radii[j], 1 - radii[j])\n                        centers[j, 1] = np.clip(centers[j, 1], radii[j], 1 - radii[j])\n        \n        individual['centers'] = centers\n        individual['radii'] = radii\n        return individual\n    \n    def tournament_selection(population, fitnesses):\n        \"\"\"Select individual using tournament selection\"\"\"\n        tournament_idx = np.random.choice(len(population), TOURNAMENT_SIZE, replace=False)\n        tournament_fitnesses = [fitnesses[i] for i in tournament_idx]\n        winner_idx = tournament_idx[np.argmax(tournament_fitnesses)]\n        return population[winner_idx]\n    \n    def crossover(parent1, parent2):\n        \"\"\"Combine two parents to create offspring\"\"\"\n        child = create_individual()\n        \n        # Randomly select circles from each parent\n        mask = np.random.rand(NUM_CIRCLES) < 0.5\n        \n        for i in range(NUM_CIRCLES):\n            if mask[i]:\n                child['centers'][i] = parent1['centers'][i].copy()\n                child['radii'][i] = parent1['radii'][i]\n            else:\n                child['centers'][i] = parent2['centers'][i].copy()\n                child['radii'][i] = parent2['radii'][i]\n        \n        return child\n    \n    def mutate(individual):\n        \"\"\"Randomly adjust positions and radii\"\"\"\n        mutated = {\n            'centers': individual['centers'].copy(),\n            'radii': individual['radii'].copy()\n        }\n        \n        for i in range(NUM_CIRCLES):\n            if np.random.rand() < MUTATION_RATE:\n                # Mutate center position\n                mutated['centers'][i] += np.random.randn(2) * 0.05\n                mutated['centers'][i] = np.clip(mutated['centers'][i], 0, 1)\n            \n            if np.random.rand() < MUTATION_RATE:\n                # Mutate radius\n                mutated['radii'][i] += np.random.randn() * 0.01\n                mutated['radii'][i] = np.clip(mutated['radii'][i], 0.005, 0.2)\n        \n        return mutated\n    \n    # Initialize population\n    population = [create_individual() for _ in range(POPULATION_SIZE)]\n    population = [repair_individual(ind) for ind in population]\n    \n    best_individual = None\n    best_fitness = -np.inf\n    best_sum_radii = 0\n    \n    # Evolution loop\n    for generation in range(GENERATIONS):\n        # Evaluate fitness\n        fitness_scores = []\n        sum_radii_scores = []\n        \n        for ind in population:\n            fitness, sum_radii = calculate_fitness(ind)\n            fitness_scores.append(fitness)\n            sum_radii_scores.append(sum_radii)\n        \n        # Track best individual\n        max_fitness_idx = np.argmax(fitness_scores)\n        if fitness_scores[max_fitness_idx] > best_fitness:\n            best_fitness = fitness_scores[max_fitness_idx]\n            best_individual = {\n                'centers': population[max_fitness_idx]['centers'].copy(),\n                'radii': population[max_fitness_idx]['radii'].copy()\n            }\n            best_sum_radii = sum_radii_scores[max_fitness_idx]\n        \n        # Create new population\n        new_population = []\n        \n        # Elitism: keep best individuals\n        elite_indices = np.argsort(fitness_scores)[-ELITE_SIZE:]\n        for idx in elite_indices:\n            new_population.append({\n                'centers': population[idx]['centers'].copy(),\n                'radii': population[idx]['radii'].copy()\n            })\n        \n        # Generate offspring\n        while len(new_population) < POPULATION_SIZE:\n            parent1 = tournament_selection(population, fitness_scores)\n            parent2 = tournament_selection(population, fitness_scores)\n            \n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            child = repair_individual(child)\n            \n            new_population.append(child)\n        \n        population = new_population\n        \n        if generation % 50 == 0:\n            print(f\"Generation {generation}: Best fitness = {best_fitness:.4f}, Sum radii = {best_sum_radii:.4f}\")\n    \n    # Return best packing found\n    centers = best_individual['centers']\n    radii = best_individual['radii']\n    sum_radii = np.sum(radii)\n    \n    print(f\"\\nFinal best sum of radii: {sum_radii:.4f}\")\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"\\nPacking complete!\")\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.4f}\")\n    print(f\"Average radius: {np.mean(radii):.4f}\")\n    print(f\"Min radius: {np.min(radii):.4f}\")\n    print(f\"Max radius: {np.max(radii):.4f}\")\n    \n    # Optional: Visualize the packing\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        \n        for i in range(len(radii)):\n            circle = plt.Circle(centers[i], radii[i], fill=False, edgecolor='blue')\n            ax.add_patch(circle)\n        \n        ax.set_title(f'Circle Packing: 26 circles, Sum of radii = {sum_radii:.4f}')\n        plt.grid(True, alpha=0.3)\n        plt.show()\n    except ImportError:\n        print(\"Matplotlib not available for visualization\")\n```\n\nThis genetic algorithm implementation:\n\n1. **Population**: Maintains 100 candidate packings\n2. **Selection**: Uses tournament selection to choose parents\n3. **Crossover**: Combines circle positions and radii from two parents\n4. **Mutation**: Randomly adjusts positions and radii with 15% probability\n5. **Elitism**: Keeps the top 10 individuals each generation\n6. **Repair**: Fixes constraint violations (boundaries and overlaps)\n7. **Fitness**: Maximizes sum of radii while penalizing overlaps and boundary violations\n\nThe algorithm runs for 500 generations and returns the best packing found with centers, radii, and their sum.",
  "reasoning": "This genetic algorithm implementation:\n\n1. **Population**: Maintains 100 candidate packings\n2. **Selection**: Uses tournament selection to choose parents\n3. **Crossover**: Combines circle positions and radii from two parents\n4. **Mutation**: Randomly adjusts positions and radii with 15% probability\n5. **Elitism**: Keeps the top 10 individuals each generation\n6. **Repair**: Fixes constraint violations (boundaries and overlaps)\n7. **Fitness**: Maximizes sum of radii while penalizing overlaps and boundary violations\n\nThe algorithm runs for 500 generations and returns the best packing found with centers, radii, and their sum.",
  "timestamp": "2025-12-06T14:18:30.683099",
  "cost_data": null
}