{
  "trial_id": "trial_0_4",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom typing import Tuple\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    \n    np.random.seed(42)\n    n_circles = 26\n    \n    # Initialize random positions in [0,1]x[0,1]\n    centers = np.random.rand(n_circles, 2)\n    radii = np.full(n_circles, 0.05)  # Start with small uniform radii\n    \n    # Simulated annealing parameters\n    initial_temp = 1.0\n    final_temp = 0.001\n    cooling_rate = 0.9995\n    iterations = 50000\n    \n    temp = initial_temp\n    \n    def calculate_max_radii(centers: np.ndarray, current_radii: np.ndarray) -> np.ndarray:\n        \"\"\"Calculate maximum possible radius for each circle without overlap\"\"\"\n        max_radii = np.full(n_circles, 1.0)\n        \n        for i in range(n_circles):\n            # Distance to boundaries\n            max_radii[i] = min(\n                centers[i, 0],  # left\n                1 - centers[i, 0],  # right\n                centers[i, 1],  # bottom\n                1 - centers[i, 1]  # top\n            )\n            \n            # Distance to other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_radii[i] = min(max_radii[i], dist - current_radii[j])\n        \n        return np.maximum(max_radii, 0.001)  # Minimum radius\n    \n    def is_valid(centers: np.ndarray, radii: np.ndarray) -> bool:\n        \"\"\"Check if configuration is valid (no overlaps, within bounds)\"\"\"\n        # Check boundaries\n        if np.any(centers - radii[:, np.newaxis] < 0) or \\\n           np.any(centers + radii[:, np.newaxis] > 1):\n            return False\n        \n        # Check circle overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        return True\n    \n    def energy(centers: np.ndarray, radii: np.ndarray) -> float:\n        \"\"\"Energy function: negative sum of radii (we want to maximize radii)\"\"\"\n        penalty = 0\n        \n        # Penalty for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 100\n        \n        # Penalty for boundary violations\n        for i in range(n_circles):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 0]) * 100\n            if centers[i, 0] + radii[i] > 1:\n                penalty += (centers[i, 0] + radii[i] - 1) * 100\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 1]) * 100\n            if centers[i, 1] + radii[i] > 1:\n                penalty += (centers[i, 1] + radii[i] - 1) * 100\n        \n        return -np.sum(radii) + penalty\n    \n    current_energy = energy(centers, radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_energy = current_energy\n    \n    for iteration in range(iterations):\n        # Choose random circle to modify\n        idx = np.random.randint(n_circles)\n        \n        # Store old state\n        old_center = centers[idx].copy()\n        old_radius = radii[idx]\n        \n        # Random perturbation\n        action = np.random.rand()\n        \n        if action < 0.5:\n            # Move circle\n            move_size = 0.05 * (temp / initial_temp)\n            centers[idx] += np.random.randn(2) * move_size\n            centers[idx] = np.clip(centers[idx], 0, 1)\n        else:\n            # Adjust radius\n            max_r = calculate_max_radii(centers, radii)[idx]\n            radii[idx] = np.clip(radii[idx] + np.random.randn() * 0.01, 0.001, max_r)\n        \n        # Calculate new energy\n        new_energy = energy(centers, radii)\n        delta_energy = new_energy - current_energy\n        \n        # Accept or reject\n        if delta_energy < 0 or np.random.rand() < np.exp(-delta_energy / temp):\n            current_energy = new_energy\n            \n            # Update best solution\n            if current_energy < best_energy:\n                best_energy = current_energy\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        else:\n            # Reject: restore old state\n            centers[idx] = old_center\n            radii[idx] = old_radius\n        \n        # Every 1000 iterations, try to grow all radii\n        if iteration % 1000 == 0:\n            max_radii = calculate_max_radii(centers, radii)\n            radii = np.minimum(radii * 1.01, max_radii)\n        \n        # Cool down\n        temp *= cooling_rate\n        temp = max(temp, final_temp)\n    \n    # Final optimization: maximize radii\n    for _ in range(100):\n        max_radii = calculate_max_radii(best_centers, best_radii)\n        best_radii = np.minimum(best_radii * 1.001, max_radii)\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n\n\n# Test and visualize\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Visualize\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        \n        for i, (center, radius) in enumerate(zip(centers, radii)):\n            circle = plt.Circle(center, radius, fill=False, edgecolor='blue', linewidth=1.5)\n            ax.add_patch(circle)\n            ax.text(center[0], center[1], str(i+1), ha='center', va='center', fontsize=8)\n        \n        ax.set_title(f'Circle Packing: 26 circles, Sum of radii = {sum_radii:.4f}')\n        ax.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('circle_packing.png', dpi=150, bbox_inches='tight')\n        print(\"\\nVisualization saved as 'circle_packing.png'\")\n        plt.show()\n    except ImportError:\n        print(\"\\nMatplotlib not available for visualization\")",
  "metrics": {
    "valid": true,
    "sum_radii": 1.66694157111624,
    "target_ratio": 0.6326153970080608,
    "combined_score": 0.6326153970080608,
    "eval_time": 44.03293490409851,
    "error": null
  },
  "prompt": "Write a simulated annealing circle packing for 26 circles in [0,1]x[0,1].\n\nUse simulated annealing to optimize circle positions and radii.\nStart with random positions, then iteratively improve by:\n- Moving circles\n- Adjusting radii\n- Accepting worse solutions with decreasing probability\n\nInclude these exact functions:\n```python\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    pass\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom typing import Tuple\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    \n    np.random.seed(42)\n    n_circles = 26\n    \n    # Initialize random positions in [0,1]x[0,1]\n    centers = np.random.rand(n_circles, 2)\n    radii = np.full(n_circles, 0.05)  # Start with small uniform radii\n    \n    # Simulated annealing parameters\n    initial_temp = 1.0\n    final_temp = 0.001\n    cooling_rate = 0.9995\n    iterations = 50000\n    \n    temp = initial_temp\n    \n    def calculate_max_radii(centers: np.ndarray, current_radii: np.ndarray) -> np.ndarray:\n        \"\"\"Calculate maximum possible radius for each circle without overlap\"\"\"\n        max_radii = np.full(n_circles, 1.0)\n        \n        for i in range(n_circles):\n            # Distance to boundaries\n            max_radii[i] = min(\n                centers[i, 0],  # left\n                1 - centers[i, 0],  # right\n                centers[i, 1],  # bottom\n                1 - centers[i, 1]  # top\n            )\n            \n            # Distance to other circles\n            for j in range(n_circles):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_radii[i] = min(max_radii[i], dist - current_radii[j])\n        \n        return np.maximum(max_radii, 0.001)  # Minimum radius\n    \n    def is_valid(centers: np.ndarray, radii: np.ndarray) -> bool:\n        \"\"\"Check if configuration is valid (no overlaps, within bounds)\"\"\"\n        # Check boundaries\n        if np.any(centers - radii[:, np.newaxis] < 0) or \\\n           np.any(centers + radii[:, np.newaxis] > 1):\n            return False\n        \n        # Check circle overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-6:\n                    return False\n        return True\n    \n    def energy(centers: np.ndarray, radii: np.ndarray) -> float:\n        \"\"\"Energy function: negative sum of radii (we want to maximize radii)\"\"\"\n        penalty = 0\n        \n        # Penalty for overlaps\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap * 100\n        \n        # Penalty for boundary violations\n        for i in range(n_circles):\n            if centers[i, 0] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 0]) * 100\n            if centers[i, 0] + radii[i] > 1:\n                penalty += (centers[i, 0] + radii[i] - 1) * 100\n            if centers[i, 1] - radii[i] < 0:\n                penalty += (radii[i] - centers[i, 1]) * 100\n            if centers[i, 1] + radii[i] > 1:\n                penalty += (centers[i, 1] + radii[i] - 1) * 100\n        \n        return -np.sum(radii) + penalty\n    \n    current_energy = energy(centers, radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_energy = current_energy\n    \n    for iteration in range(iterations):\n        # Choose random circle to modify\n        idx = np.random.randint(n_circles)\n        \n        # Store old state\n        old_center = centers[idx].copy()\n        old_radius = radii[idx]\n        \n        # Random perturbation\n        action = np.random.rand()\n        \n        if action < 0.5:\n            # Move circle\n            move_size = 0.05 * (temp / initial_temp)\n            centers[idx] += np.random.randn(2) * move_size\n            centers[idx] = np.clip(centers[idx], 0, 1)\n        else:\n            # Adjust radius\n            max_r = calculate_max_radii(centers, radii)[idx]\n            radii[idx] = np.clip(radii[idx] + np.random.randn() * 0.01, 0.001, max_r)\n        \n        # Calculate new energy\n        new_energy = energy(centers, radii)\n        delta_energy = new_energy - current_energy\n        \n        # Accept or reject\n        if delta_energy < 0 or np.random.rand() < np.exp(-delta_energy / temp):\n            current_energy = new_energy\n            \n            # Update best solution\n            if current_energy < best_energy:\n                best_energy = current_energy\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        else:\n            # Reject: restore old state\n            centers[idx] = old_center\n            radii[idx] = old_radius\n        \n        # Every 1000 iterations, try to grow all radii\n        if iteration % 1000 == 0:\n            max_radii = calculate_max_radii(centers, radii)\n            radii = np.minimum(radii * 1.01, max_radii)\n        \n        # Cool down\n        temp *= cooling_rate\n        temp = max(temp, final_temp)\n    \n    # Final optimization: maximize radii\n    for _ in range(100):\n        max_radii = calculate_max_radii(best_centers, best_radii)\n        best_radii = np.minimum(best_radii * 1.001, max_radii)\n    \n    sum_radii = np.sum(best_radii)\n    \n    return best_centers, best_radii, sum_radii\n\n\ndef run_packing():\n    return construct_packing()\n\n\n# Test and visualize\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Visualize\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        \n        for i, (center, radius) in enumerate(zip(centers, radii)):\n            circle = plt.Circle(center, radius, fill=False, edgecolor='blue', linewidth=1.5)\n            ax.add_patch(circle)\n            ax.text(center[0], center[1], str(i+1), ha='center', va='center', fontsize=8)\n        \n        ax.set_title(f'Circle Packing: 26 circles, Sum of radii = {sum_radii:.4f}')\n        ax.grid(True, alpha=0.3)\n        plt.tight_layout()\n        plt.savefig('circle_packing.png', dpi=150, bbox_inches='tight')\n        print(\"\\nVisualization saved as 'circle_packing.png'\")\n        plt.show()\n    except ImportError:\n        print(\"\\nMatplotlib not available for visualization\")\n```\n\nThis implementation:\n\n1. **Initializes** 26 circles with random positions and small uniform radii\n2. **Uses simulated annealing** with:\n   - Temperature cooling from 1.0 to 0.001\n   - Geometric cooling schedule (0.9995 rate)\n   - 50,000 iterations\n3. **Optimizes** by:\n   - Randomly moving circle centers\n   - Adjusting individual radii\n   - Accepting worse solutions with probability exp(-\u0394E/T)\n4. **Energy function** that:\n   - Maximizes sum of radii (negative sum)\n   - Heavily penalizes overlaps and boundary violations\n5. **Post-processing** to grow radii to maximum valid sizes\n\nThe algorithm balances exploration (early, high temperature) with exploitation (late, low temperature) to find a good packing configuration.",
  "reasoning": "This implementation:\n\n1. **Initializes** 26 circles with random positions and small uniform radii\n2. **Uses simulated annealing** with:\n   - Temperature cooling from 1.0 to 0.001\n   - Geometric cooling schedule (0.9995 rate)\n   - 50,000 iterations\n3. **Optimizes** by:\n   - Randomly moving circle centers\n   - Adjusting individual radii\n   - Accepting worse solutions with probability exp(-\u0394E/T)\n4. **Energy function** that:\n   - Maximizes sum of radii (negative sum)\n   - Heavily penalizes overlaps and boundary violations\n5. **Post-processing** to grow radii to maximum valid sizes\n\nThe algorithm balances exploration (early, high temperature) with exploitation (late, low temperature) to find a good packing configuration.",
  "timestamp": "2025-12-06T14:16:26.544535",
  "cost_data": null
}