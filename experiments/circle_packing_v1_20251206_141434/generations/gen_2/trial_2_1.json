{
  "trial_id": "trial_2_1",
  "generation": 2,
  "parent_id": "trial_0_2",
  "code": "",
  "metrics": {},
  "prompt": "Enhance this optimization algorithm with better initialization. Here is the code:\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    n_circles = 26\n    \n    # Initialize positions in a grid pattern and equal radii\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_positions = []\n    for i in range(n_circles):\n        x = (i % grid_size + 0.5) / grid_size\n        y = (i // grid_size + 0.5) / grid_size\n        initial_positions.extend([x, y])\n    \n    initial_radii = [0.05] * n_circles\n    x0 = np.array(initial_positions + initial_radii)\n    \n    # Objective: maximize sum of radii = minimize negative sum of radii\n    def objective(x):\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # 1. Circles inside [0,1]x[0,1]\n    for i in range(n_circles):\n        # x_i - r_i >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i] - x[2*n_circles + i]\n        })\n        # x_i + r_i <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i] - x[2*n_circles + i]\n        })\n        # y_i - r_i >= 0\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i + 1] - x[2*n_circles + i]\n        })\n        # y_i + r_i <= 1\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n_circles + i]\n        })\n    \n    # 2. No overlaps between circles\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            # distance(i,j) >= r_i + r_j\n            def overlap_constraint(x, i=i, j=j):\n                xi, yi = x[2*i], x[2*i + 1]\n                xj, yj = x[2*j], x[2*j + 1]\n                ri = x[2*n_circles + i]\n                rj = x[2*n_circles + j]\n                dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n                return dist - ri - rj\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': overlap_constraint\n            })\n    \n    # Bounds: positions in [0,1], radii positive\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    # Optimize with multiple attempts\n    best_result = None\n    best_value = float('inf')\n    \n    for attempt in range(3):\n        if attempt > 0:\n            # Add some randomness for subsequent attempts\n            x0_attempt = x0 + np.random.randn(len(x0)) * 0.02\n            x0_attempt[:2*n_circles] = np.clip(x0_attempt[:2*n_circles], 0, 1)\n            x0_attempt[2*n_circles:] = np.clip(x0_attempt[2*n_circles:], 0.01, 0.1)\n        else:\n            x0_attempt = x0.copy()\n        \n        result = minimize(\n            objective,\n            x0_attempt,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        if result.fun < best_value:\n            best_value = result.fun\n            best_result = result\n    \n    # Extract results\n    x_opt = best_result.x\n    centers = x_opt[:2*n_circles].reshape(n_circles, 2)\n    radii = x_opt[2*n_circles:]\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n\n# Example usage and visualization\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Verify constraints\n    print(\"\\nVerifying constraints:\")\n    \n    # Check boundaries\n    valid_bounds = True\n    for i, (center, r) in enumerate(zip(centers, radii)):\n        if center[0] - r < -1e-6 or center[0] + r > 1 + 1e-6:\n            print(f\"Circle {i} violates x-boundary\")\n            valid_bounds = False\n        if center[1] - r < -1e-6 or center[1] + r > 1 + 1e-6:\n            print(f\"Circle {i} violates y-boundary\")\n            valid_bounds = False\n    \n    if valid_bounds:\n        print(\"\u2713 All circles within bounds\")\n    \n    # Check overlaps\n    overlaps = 0\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                overlaps += 1\n                print(f\"Overlap between circles {i} and {j}: dist={dist:.6f}, sum_r={radii[i]+radii[j]:.6f}\")\n    \n    if overlaps == 0:\n        print(\"\u2713 No overlaps detected\")\n    \n    # Optional: Plot the result\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        \n        for center, r in zip(centers, radii):\n            circle = plt.Circle(center, r, fill=False, edgecolor='blue', linewidth=1.5)\n            ax.add_patch(circle)\n            ax.plot(center[0], center[1], 'r.', markersize=3)\n        \n        ax.set_title(f'Circle Packing: 26 circles, sum of radii = {sum_radii:.4f}')\n        ax.set_xlabel('x')\n        ax.set_ylabel('y')\n        plt.tight_layout()\n        plt.savefig('circle_packing.png', dpi=150, bbox_inches='tight')\n        print(\"\\nPlot saved as 'circle_packing.png'\")\n        plt.show()\n    except ImportError:\n        print(\"\\nMatplotlib not available for plotting\")\n\nImprovements:\n1. Create 5 different hexagonal patterns (different orientations and densities)\n2. Create 3 different random patterns with repulsion forces\n3. Create 2 concentric circle patterns\n4. Test all 10 initializations and keep the best\n5. After optimization, apply greedy radius expansion\n\nInclude construct_packing() and run_packing() functions that return (centers, radii, sum_radii).",
  "response": "Here's the enhanced optimization algorithm with better initialization strategies:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    n_circles = 26\n    \n    def create_hexagonal_pattern(n, density=1.0, rotation=0.0, offset=(0, 0)):\n        \"\"\"Create hexagonal grid pattern\"\"\"\n        positions = []\n        hex_spacing = 0.15 / density\n        \n        row = 0\n        count = 0\n        while count < n:\n            cols_in_row = int(1.0 / hex_spacing) + 1\n            for col in range(cols_in_row):\n                if count >= n:\n                    break\n                x = col * hex_spacing + (row % 2) * hex_spacing / 2\n                y = row * hex_spacing * np.sqrt(3) / 2\n                \n                # Apply rotation\n                if rotation != 0:\n                    cos_r, sin_r = np.cos(rotation), np.sin(rotation)\n                    x_rot = x * cos_r - y * sin_r\n                    y_rot = x * sin_r + y * cos_r\n                    x, y = x_rot, y_rot\n                \n                # Apply offset and center\n                x = x + offset[0] + 0.2\n                y = y + offset[1] + 0.2\n                \n                # Keep within bounds\n                if 0.05 <= x <= 0.95 and 0.05 <= y <= 0.95:\n                    positions.append([x, y])\n                    count += 1\n            row += 1\n        \n        # If we don't have enough, fill with grid\n        while len(positions) < n:\n            x = np.random.uniform(0.1, 0.9)\n            y = np.random.uniform(0.1, 0.9)\n            positions.append([x, y])\n        \n        return np.array(positions[:n])\n    \n    def create_random_repulsion_pattern(n, iterations=100, repulsion_strength=0.1):\n        \"\"\"Create random pattern with repulsion forces\"\"\"\n        positions = np.random.uniform(0.15, 0.85, (n, 2))\n        \n        for _ in range(iterations):\n            # Calculate pairwise distances\n            for i in range(n):\n                force = np.zeros(2)\n                for j in range(n):\n                    if i != j:\n                        diff = positions[i] - positions[j]\n                        dist = np.linalg.norm(diff)\n                        if dist > 0:\n                            # Repulsion force inversely proportional to distance\n                            force += diff / (dist ** 2 + 0.01) * repulsion_strength\n                \n                # Update position\n                positions[i] += force\n                # Keep within bounds\n                positions[i] = np.clip(positions[i], 0.05, 0.95)\n        \n        return positions\n    \n    def create_concentric_pattern(n, num_rings=3):\n        \"\"\"Create concentric circles pattern\"\"\"\n        positions = []\n        circles_per_ring = [1, 8, 17]  # Adjust for 26 circles\n        \n        # Ensure we have enough circles\n        while sum(circles_per_ring) < n:\n            circles_per_ring.append(circles_per_ring[-1] + 6)\n        \n        # Adjust to exactly n circles\n        total = sum(circles_per_ring[:num_rings])\n        if total < n:\n            circles_per_ring[num_rings - 1] += n - total\n        \n        center = np.array([0.5, 0.5])\n        radii_rings = [0.0, 0.25, 0.4]\n        \n        for ring_idx, (num_in_ring, ring_radius) in enumerate(zip(circles_per_ring[:num_rings], radii_rings)):\n            if ring_idx == 0:\n                positions.append(center.copy())\n            else:\n                for i in range(num_in_ring):\n                    angle = 2 * np.pi * i / num_in_ring\n                    x = center[0] + ring_radius * np.cos(angle)\n                    y = center[1] + ring_radius * np.sin(angle)\n                    positions.append([x, y])\n                    if len(positions) >= n:\n                        break\n            if len(positions) >= n:\n                break\n        \n        return np.array(positions[:n])\n    \n    def create_initialization_patterns(n):\n        \"\"\"Create multiple initialization patterns\"\"\"\n        patterns = []\n        \n        # 5 hexagonal patterns with different parameters\n        patterns.append(create_hexagonal_pattern(n, density=0.8, rotation=0))\n        patterns.append(create_hexagonal_pattern(n, density=1.0, rotation=np.pi/6))\n        patterns.append(create_hexagonal_pattern(n, density=1.2, rotation=np.pi/4))\n        patterns.append(create_hexagonal_pattern(n, density=0.9, rotation=np.pi/3, offset=(0.1, 0)))\n        patterns.append(create_hexagonal_pattern(n, density=1.1, rotation=-np.pi/6, offset=(0, 0.1)))\n        \n        # 3 random repulsion patterns\n        patterns.append(create_random_repulsion_pattern(n, iterations=100, repulsion_strength=0.1))\n        patterns.append(create_random_repulsion_pattern(n, iterations=150, repulsion_strength=0.15))\n        patterns.append(create_random_repulsion_pattern(n, iterations=80, repulsion_strength=0.08))\n        \n        # 2 concentric patterns\n        patterns.append(create_concentric_pattern(n, num_rings=3))\n        patterns.append(create_concentric_pattern(n, num_rings=4))\n        \n        return patterns\n    \n    def estimate_initial_radii(positions):\n        \"\"\"Estimate good initial radii based on nearest neighbor distances\"\"\"\n        n = len(positions)\n        radii = []\n        \n        for i in range(n):\n            # Find minimum distance to other circles and boundaries\n            min_dist_to_circle = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    min_dist_to_circle = min(min_dist_to_circle, dist)\n            \n            # Distance to boundaries\n            x, y = positions[i]\n            min_dist_to_boundary = min(x, 1 - x, y, 1 - y)\n            \n            # Conservative estimate: use 40% of minimum distance\n            estimated_radius = min(min_dist_to_circle / 2.5, min_dist_to_boundary) * 0.8\n            radii.append(max(0.01, min(estimated_radius, 0.15)))\n        \n        return np.array(radii)\n    \n    def greedy_radius_expansion(centers, radii, expansion_factor=1.001, max_iterations=1000):\n        \"\"\"Greedily expand radii while maintaining constraints\"\"\"\n        n = len(centers)\n        radii = radii.copy()\n        \n        for iteration in range(max_iterations):\n            improved = False\n            \n            for i in range(n):\n                # Try to expand radius i\n                old_radius = radii[i]\n                new_radius = old_radius * expansion_factor\n                \n                # Check boundary constraints\n                x, y = centers[i]\n                if x - new_radius < 0 or x + new_radius > 1:\n                    continue\n                if y - new_radius < 0 or y + new_radius > 1:\n                    continue\n                \n                # Check overlap constraints\n                valid = True\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < new_radius + radii[j] - 1e-9:\n                            valid = False\n                            break\n                \n                if valid:\n                    radii[i] = new_radius\n                    improved = True\n            \n            if not improved:\n                break\n        \n        return radii\n    \n    # Objective: maximize sum of radii = minimize negative sum of radii\n    def objective(x):\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # 1. Circles inside [0,1]x[0,1]\n    for i in range(n_circles):\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i] - x[2*n_circles + i]\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i] - x[2*n_circles + i]\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i + 1] - x[2*n_circles + i]\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n_circles + i]\n        })\n    \n    # 2. No overlaps between circles\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            def overlap_constraint(x, i=i, j=j):\n                xi, yi = x[2*i], x[2*i + 1]\n                xj, yj = x[2*j], x[2*j + 1]\n                ri = x[2*n_circles + i]\n                rj = x[2*n_circles + j]\n                dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n                return dist - ri - rj\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': overlap_constraint\n            })\n    \n    # Bounds: positions in [0,1], radii positive\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    # Create all initialization patterns\n    print(\"Creating initialization patterns...\")\n    patterns = create_initialization_patterns(n_circles)\n    \n    # Optimize with all patterns\n    best_result = None\n    best_value = float('inf')\n    best_pattern_idx = -1\n    \n    for pattern_idx, pattern in enumerate(patterns):\n        print(f\"Testing pattern {pattern_idx + 1}/10...\", end=' ')\n        \n        # Estimate initial radii\n        initial_radii = estimate_initial_radii(pattern)\n        \n        # Create initial vector\n        x0 = np.concatenate([pattern.flatten(), initial_radii])\n        \n        # Run optimization\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        print(f\"Sum of radii: {-result.fun:.6f}\")\n        \n        if result.fun < best_value:\n            best_value = result.fun\n            best_result = result\n            best_pattern_idx = pattern_idx\n    \n    print(f\"\\nBest pattern: {best_pattern_idx + 1}, Sum of radii before expansion: {-best_value:.6f}\")\n    \n    # Extract results\n    x_opt = best_result.x\n    centers = x_opt[:2*n_circles].reshape(n_circles, 2)\n    radii = x_opt[2*n_circles:]\n    \n    # Apply greedy radius expansion\n    print(\"Applying greedy radius expansion...\")\n    radii_expanded = greedy_radius_expansion(centers, radii, expansion_factor=1.0005, max_iterations=2000)\n    \n    sum_radii = np.sum(radii_expanded)\n    print(f\"Sum of radii after expansion: {sum_radii:.6f}\")\n    \n    return centers, radii_expanded, sum_radii\n\ndef run_packing():\n    return construct_packing()\n\n# Example usage and visualization\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"\\n{'='*50}\")\n    print(f\"FINAL RESULTS\")\n    print(f\"{'='*50}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Verify constraints\n    print(f\"\\n{'='*50}\")\n    print(f\"CONSTRAINT VERIFICATION\")\n    print(f\"{'='*50}\")\n    \n    # Check boundaries\n    valid_bounds = True\n    for i, (center, r) in enumerate(zip(centers, radii)):\n        if center[0] - r < -1e-6 or center[0] + r > 1 + 1e-6:\n            print(f\"Circle {i} violates x-boundary\")\n            valid_bounds = False\n        if center[1] - r < -1e-6 or center[1] + r > 1 + 1e-6:\n            print(f\"Circle {i} violates y-boundary\")\n            valid_bounds = False\n    \n    if valid_bounds:\n        print(\"\u2713 All circles within bounds\")\n    \n    # Check overlaps\n    overlaps = 0\n    max_violation = 0\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            required_dist = radii[i] + radii[j]\n            violation = required_dist - dist\n            if violation > 1e-6:\n                overlaps += 1\n                max_violation = max(max_violation, violation)\n                print(f\"Overlap between circles {i} and {j}: dist={dist:.6f}, sum_r={required_dist:.6f}, violation={violation:.6f}\")\n    \n    if overlaps == 0:\n        print(\"\u2713 No overlaps detected\")\n    else:\n        print(f\"\u26a0 {overlaps} overlaps detected, max violation: {max_violation:.6f}\")\n    \n    # Optional: Plot the result\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        \n        # Color circles by size\n        colors = plt.cm.viridis(radii / np.max(radii))\n        \n        for idx, (center, r) in enumerate(zip(centers, radii)):\n            circle = plt.Circle(center, r, fill=True, facecolor=colors[idx], \n                              edgecolor='black', linewidth=1.5, alpha=0.6)\n            ax.add_patch(circle)\n            ax.plot(center[0], center[1], 'r.', markersize=4)\n            # Add circle number\n            ax.text(center[0], center[1], str(idx), ha='center', va='center', \n                   fontsize=6, fontweight='bold')\n        \n        ax.set_title(f'Circle Packing: 26 circles, sum of radii = {sum_radii:.6f}', \n                    fontsize=14, fontweight='bol",
  "reasoning": "Here's the enhanced optimization algorithm with better initialization strategies:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    n_circles = 26\n    \n    def create_hexagonal_pattern(n, density=1.0, rotation=0.0, offset=(0, 0)):\n        \"\"\"Create hexagonal grid pattern\"\"\"\n        positions = []\n        hex_spacing = 0.15 / density\n        \n        row = 0\n        count = 0\n        while count < n:\n            cols_in_row = int(1.0 / hex_spacing) + 1\n            for col in range(cols_in_row):\n                if count >= n:\n                    break\n                x = col * hex_spacing + (row % 2) * hex_spacing / 2\n                y = row * hex_spacing * np.sqrt(3) / 2\n                \n                # Apply rotation\n                if rotation != 0:\n                    cos_r, sin_r = np.cos(rotation), np.sin(rotation)\n                    x_rot = x * cos_r - y * sin_r\n                    y_rot = x * sin_r + y * cos_r\n                    x, y = x_rot, y_rot\n                \n                # Apply offset and center\n                x = x + offset[0] + 0.2\n                y = y + offset[1] + 0.2\n                \n                # Keep within bounds\n                if 0.05 <= x <= 0.95 and 0.05 <= y <= 0.95:\n                    positions.append([x, y])\n                    count += 1\n            row += 1\n        \n        # If we don't have enough, fill with grid\n        while len(positions) < n:\n            x = np.random.uniform(0.1, 0.9)\n            y = np.random.uniform(0.1, 0.9)\n            positions.append([x, y])\n        \n        return np.array(positions[:n])\n    \n    def create_random_repulsion_pattern(n, iterations=100, repulsion_strength=0.1):\n        \"\"\"Create random pattern with repulsion forces\"\"\"\n        positions = np.random.uniform(0.15, 0.85, (n, 2))\n        \n        for _ in range(iterations):\n            # Calculate pairwise distances\n            for i in range(n):\n                force = np.zeros(2)\n                for j in range(n):\n                    if i != j:\n                        diff = positions[i] - positions[j]\n                        dist = np.linalg.norm(diff)\n                        if dist > 0:\n                            # Repulsion force inversely proportional to distance\n                            force += diff / (dist ** 2 + 0.01) * repulsion_strength\n                \n                # Update position\n                positions[i] += force\n                # Keep within bounds\n                positions[i] = np.clip(positions[i], 0.05, 0.95)\n        \n        return positions\n    \n    def create_concentric_pattern(n, num_rings=3):\n        \"\"\"Create concentric circles pattern\"\"\"\n        positions = []\n        circles_per_ring = [1, 8, 17]  # Adjust for 26 circles\n        \n        # Ensure we have enough circles\n        while sum(circles_per_ring) < n:\n            circles_per_ring.append(circles_per_ring[-1] + 6)\n        \n        # Adjust to exactly n circles\n        total = sum(circles_per_ring[:num_rings])\n        if total < n:\n            circles_per_ring[num_rings - 1] += n - total\n        \n        center = np.array([0.5, 0.5])\n        radii_rings = [0.0, 0.25, 0.4]\n        \n        for ring_idx, (num_in_ring, ring_radius) in enumerate(zip(circles_per_ring[:num_rings], radii_rings)):\n            if ring_idx == 0:\n                positions.append(center.copy())\n            else:\n                for i in range(num_in_ring):\n                    angle = 2 * np.pi * i / num_in_ring\n                    x = center[0] + ring_radius * np.cos(angle)\n                    y = center[1] + ring_radius * np.sin(angle)\n                    positions.append([x, y])\n                    if len(positions) >= n:\n                        break\n            if len(positions) >= n:\n                break\n        \n        return np.array(positions[:n])\n    \n    def create_initialization_patterns(n):\n        \"\"\"Create multiple initialization patterns\"\"\"\n        patterns = []\n        \n        # 5 hexagonal patterns with different parameters\n        patterns.append(create_hexagonal_pattern(n, density=0.8, rotation=0))\n        patterns.append(create_hexagonal_pattern(n, density=1.0, rotation=np.pi/6))\n        patterns.append(create_hexagonal_pattern(n, density=1.2, rotation=np.pi/4))\n        patterns.append(create_hexagonal_pattern(n, density=0.9, rotation=np.pi/3, offset=(0.1, 0)))\n        patterns.append(create_hexagonal_pattern(n, density=1.1, rotation=-np.pi/6, offset=(0, 0.1)))\n        \n        # 3 random repulsion patterns\n        patterns.append(create_random_repulsion_pattern(n, iterations=100, repulsion_strength=0.1))\n        patterns.append(create_random_repulsion_pattern(n, iterations=150, repulsion_strength=0.15))\n        patterns.append(create_random_repulsion_pattern(n, iterations=80, repulsion_strength=0.08))\n        \n        # 2 concentric patterns\n        patterns.append(create_concentric_pattern(n, num_rings=3))\n        patterns.append(create_concentric_pattern(n, num_rings=4))\n        \n        return patterns\n    \n    def estimate_initial_radii(positions):\n        \"\"\"Estimate good initial radii based on nearest neighbor distances\"\"\"\n        n = len(positions)\n        radii = []\n        \n        for i in range(n):\n            # Find minimum distance to other circles and boundaries\n            min_dist_to_circle = float('inf')\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    min_dist_to_circle = min(min_dist_to_circle, dist)\n            \n            # Distance to boundaries\n            x, y = positions[i]\n            min_dist_to_boundary = min(x, 1 - x, y, 1 - y)\n            \n            # Conservative estimate: use 40% of minimum distance\n            estimated_radius = min(min_dist_to_circle / 2.5, min_dist_to_boundary) * 0.8\n            radii.append(max(0.01, min(estimated_radius, 0.15)))\n        \n        return np.array(radii)\n    \n    def greedy_radius_expansion(centers, radii, expansion_factor=1.001, max_iterations=1000):\n        \"\"\"Greedily expand radii while maintaining constraints\"\"\"\n        n = len(centers)\n        radii = radii.copy()\n        \n        for iteration in range(max_iterations):\n            improved = False\n            \n            for i in range(n):\n                # Try to expand radius i\n                old_radius = radii[i]\n                new_radius = old_radius * expansion_factor\n                \n                # Check boundary constraints\n                x, y = centers[i]\n                if x - new_radius < 0 or x + new_radius > 1:\n                    continue\n                if y - new_radius < 0 or y + new_radius > 1:\n                    continue\n                \n                # Check overlap constraints\n                valid = True\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < new_radius + radii[j] - 1e-9:\n                            valid = False\n                            break\n                \n                if valid:\n                    radii[i] = new_radius\n                    improved = True\n            \n            if not improved:\n                break\n        \n        return radii\n    \n    # Objective: maximize sum of radii = minimize negative sum of radii\n    def objective(x):\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    # Constraints\n    constraints = []\n    \n    # 1. Circles inside [0,1]x[0,1]\n    for i in range(n_circles):\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i] - x[2*n_circles + i]\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i] - x[2*n_circles + i]\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: x[2*i + 1] - x[2*n_circles + i]\n        })\n        constraints.append({\n            'type': 'ineq',\n            'fun': lambda x, i=i: 1 - x[2*i + 1] - x[2*n_circles + i]\n        })\n    \n    # 2. No overlaps between circles\n    for i in range(n_circles):\n        for j in range(i + 1, n_circles):\n            def overlap_constraint(x, i=i, j=j):\n                xi, yi = x[2*i], x[2*i + 1]\n                xj, yj = x[2*j], x[2*j + 1]\n                ri = x[2*n_circles + i]\n                rj = x[2*n_circles + j]\n                dist = np.sqrt((xi - xj)**2 + (yi - yj)**2)\n                return dist - ri - rj\n            \n            constraints.append({\n                'type': 'ineq',\n                'fun': overlap_constraint\n            })\n    \n    # Bounds: positions in [0,1], radii positive\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    # Create all initialization patterns\n    print(\"Creating initialization patterns...\")\n    patterns = create_initialization_patterns(n_circles)\n    \n    # Optimize with all patterns\n    best_result = None\n    best_value = float('inf')\n    best_pattern_idx = -1\n    \n    for pattern_idx, pattern in enumerate(patterns):\n        print(f\"Testing pattern {pattern_idx + 1}/10...\", end=' ')\n        \n        # Estimate initial radii\n        initial_radii = estimate_initial_radii(pattern)\n        \n        # Create initial vector\n        x0 = np.concatenate([pattern.flatten(), initial_radii])\n        \n        # Run optimization\n        result = minimize(\n            objective,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-9}\n        )\n        \n        print(f\"Sum of radii: {-result.fun:.6f}\")\n        \n        if result.fun < best_value:\n            best_value = result.fun\n            best_result = result\n            best_pattern_idx = pattern_idx\n    \n    print(f\"\\nBest pattern: {best_pattern_idx + 1}, Sum of radii before expansion: {-best_value:.6f}\")\n    \n    # Extract results\n    x_opt = best_result.x\n    centers = x_opt[:2*n_circles].reshape(n_circles, 2)\n    radii = x_opt[2*n_circles:]\n    \n    # Apply greedy radius expansion\n    print(\"Applying greedy radius expansion...\")\n    radii_expanded = greedy_radius_expansion(centers, radii, expansion_factor=1.0005, max_iterations=2000)\n    \n    sum_radii = np.sum(radii_expanded)\n    print(f\"Sum of radii after expansion: {sum_radii:.6f}\")\n    \n    return centers, radii_expanded, sum_radii\n\ndef run_packing():\n    return construct_packing()\n\n# Example usage and visualization\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"\\n{'='*50}\")\n    print(f\"FINAL RESULTS\")\n    print(f\"{'='*50}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Verify constraints\n    print(f\"\\n{'='*50}\")\n    print(f\"CONSTRAINT VERIFICATION\")\n    print(f\"{'='*50}\")\n    \n    # Check boundaries\n    valid_bounds = True\n    for i, (center, r) in enumerate(zip(centers, radii)):\n        if center[0] - r < -1e-6 or center[0] + r > 1 + 1e-6:\n            print(f\"Circle {i} violates x-boundary\")\n            valid_bounds = False\n        if center[1] - r < -1e-6 or center[1] + r > 1 + 1e-6:\n            print(f\"Circle {i} violates y-boundary\")\n            valid_bounds = False\n    \n    if valid_bounds:\n        print(\"\u2713 All circles within bounds\")\n    \n    # Check overlaps\n    overlaps = 0\n    max_violation = 0\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            required_dist = radii[i] + radii[j]\n            violation = required_dist - dist\n            if violation > 1e-6:\n                overlaps += 1\n                max_violation = max(max_violation, violation)\n                print(f\"Overlap between circles {i} and {j}: dist={dist:.6f}, sum_r={required_dist:.6f}, violation={violation:.6f}\")\n    \n    if overlaps == 0:\n        print(\"\u2713 No overlaps detected\")\n    else:\n        print(f\"\u26a0 {overlaps} overlaps detected, max violation: {max_violation:.6f}\")\n    \n    # Optional: Plot the result\n    try:\n        import matplotlib.pyplot as plt\n        \n        fig, ax = plt.subplots(1, 1, figsize=(10, 10))\n        ax.set_xlim(0, 1)\n        ax.set_ylim(0, 1)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        \n        # Color circles by size\n        colors = plt.cm.viridis(radii / np.max(radii))\n        \n        for idx, (center, r) in enumerate(zip(centers, radii)):\n            circle = plt.Circle(center, r, fill=True, facecolor=colors[idx], \n                              edgecolor='black', linewidth=1.5, alpha=0.6)\n            ax.add_patch(circle)\n            ax.plot(center[0], center[1], 'r.', markersize=4)\n            # Add circle number\n            ax.text(center[0], center[1], str(idx), ha='center', va='center', \n                   fontsize=6, fontweight='bold')\n        \n        ax.set_title(f'Circle Packing: 26 circles, sum of radii = {sum_radii:.6f}', \n                    fontsize=14, fontweight='bol",
  "timestamp": "2025-12-06T14:29:14.653678",
  "cost_data": null
}