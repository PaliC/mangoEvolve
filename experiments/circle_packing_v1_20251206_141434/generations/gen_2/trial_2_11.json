{
  "trial_id": "trial_2_11",
  "generation": 2,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize, Bounds\nfrom typing import Tuple\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct an optimized packing of 26 circles in [0,1]x[0,1] using coordinate descent.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize with grid pattern (6x5 grid with some offset)\n    grid_x = 5\n    grid_y = 6\n    centers = []\n    for i in range(grid_y):\n        for j in range(grid_x):\n            if len(centers) < n_circles:\n                x = (j + 0.5) / grid_x\n                y = (i + 0.5) / grid_y\n                centers.append([x, y])\n    \n    # Add remaining circle if needed\n    while len(centers) < n_circles:\n        centers.append([0.5, 0.5])\n    \n    centers = np.array(centers)\n    \n    # Initialize radii with small values\n    radii = np.ones(n_circles) * 0.05\n    \n    def compute_max_radius(center_i, centers_other, radii_other):\n        \"\"\"Compute maximum valid radius for circle i given others are fixed.\"\"\"\n        x, y = center_i\n        \n        # Constraint from boundaries\n        max_r = min(x, y, 1 - x, 1 - y)\n        \n        # Constraint from other circles\n        for j, (center_j, r_j) in enumerate(zip(centers_other, radii_other)):\n            dist = np.linalg.norm(center_i - center_j)\n            max_r = min(max_r, dist - r_j)\n        \n        return max(max_r, 0.0)\n    \n    def optimize_single_circle(i, centers, radii):\n        \"\"\"Optimize position and radius of circle i while keeping others fixed.\"\"\"\n        other_indices = [j for j in range(n_circles) if j != i]\n        centers_other = centers[other_indices]\n        radii_other = radii[other_indices]\n        \n        def objective(params):\n            \"\"\"Negative radius to maximize.\"\"\"\n            x, y, r = params\n            return -r\n        \n        def constraint_boundary(params):\n            \"\"\"Ensure circle stays within [0,1]x[0,1].\"\"\"\n            x, y, r = params\n            return np.array([x - r, y - r, 1 - x - r, 1 - y - r])\n        \n        def constraint_no_overlap(params):\n            \"\"\"Ensure no overlap with other circles.\"\"\"\n            x, y, r = params\n            center_i = np.array([x, y])\n            constraints = []\n            for center_j, r_j in zip(centers_other, radii_other):\n                dist = np.linalg.norm(center_i - center_j)\n                constraints.append(dist - r - r_j)\n            return np.array(constraints)\n        \n        # Initial guess\n        x0 = np.array([centers[i, 0], centers[i, 1], radii[i]])\n        \n        # Bounds\n        bounds = Bounds([0, 0, 0], [1, 1, 0.5])\n        \n        # Constraints\n        constraints = [\n            {'type': 'ineq', 'fun': constraint_boundary},\n            {'type': 'ineq', 'fun': constraint_no_overlap}\n        ]\n        \n        # Optimize\n        result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                         constraints=constraints, options={'maxiter': 100})\n        \n        if result.success:\n            return result.x[:2], result.x[2]\n        else:\n            # If optimization fails, just compute max radius at current position\n            r_max = compute_max_radius(centers[i], centers_other, radii_other)\n            return centers[i], r_max\n    \n    # Coordinate descent: multiple passes\n    n_passes = 5\n    for pass_num in range(n_passes):\n        # Randomize order to avoid bias\n        order = np.random.permutation(n_circles)\n        \n        for i in order:\n            new_center, new_radius = optimize_single_circle(i, centers, radii)\n            centers[i] = new_center\n            radii[i] = new_radius\n    \n    # Final global optimization\n    def global_objective(params):\n        \"\"\"Negative sum of radii.\"\"\"\n        n = n_circles\n        radii_opt = params[2*n:]\n        return -np.sum(radii_opt)\n    \n    def global_constraint_boundary(params):\n        \"\"\"All circles stay within boundaries.\"\"\"\n        n = n_circles\n        centers_opt = params[:2*n].reshape(n, 2)\n        radii_opt = params[2*n:]\n        \n        constraints = []\n        for i in range(n):\n            x, y, r = centers_opt[i, 0], centers_opt[i, 1], radii_opt[i]\n            constraints.extend([x - r, y - r, 1 - x - r, 1 - y - r])\n        return np.array(constraints)\n    \n    def global_constraint_no_overlap(params):\n        \"\"\"No circles overlap.\"\"\"\n        n = n_circles\n        centers_opt = params[:2*n].reshape(n, 2)\n        radii_opt = params[2*n:]\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        return np.array(constraints)\n    \n    # Pack parameters\n    x0_global = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds\n    bounds_global = Bounds(\n        np.concatenate([np.zeros(2*n_circles), np.zeros(n_circles)]),\n        np.concatenate([np.ones(2*n_circles), 0.5*np.ones(n_circles)])\n    )\n    \n    # Constraints\n    constraints_global = [\n        {'type': 'ineq', 'fun': global_constraint_boundary},\n        {'type': 'ineq', 'fun': global_constraint_no_overlap}\n    ]\n    \n    # Global optimization\n    result_global = minimize(global_objective, x0_global, method='SLSQP',\n                            bounds=bounds_global, constraints=constraints_global,\n                            options={'maxiter': 200, 'ftol': 1e-6})\n    \n    if result_global.success:\n        centers = result_global.x[:2*n_circles].reshape(n_circles, 2)\n        radii = result_global.x[2*n_circles:]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Run the packing optimization.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Mean radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Verify constraints\n    print(\"\\nVerifying constraints:\")\n    \n    # Check boundaries\n    boundary_violations = 0\n    for i, (center, r) in enumerate(zip(centers, radii)):\n        if center[0] - r < -1e-6 or center[1] - r < -1e-6:\n            boundary_violations += 1\n        if center[0] + r > 1 + 1e-6 or center[1] + r > 1 + 1e-6:\n            boundary_violations += 1\n    print(f\"Boundary violations: {boundary_violations}\")\n    \n    # Check overlaps\n    overlap_violations = 0\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                overlap_violations += 1\n    print(f\"Overlap violations: {overlap_violations}\")",
  "metrics": {
    "valid": true,
    "sum_radii": 2.5918749236537177,
    "target_ratio": 0.9836337471171606,
    "combined_score": 0.9836337471171606,
    "eval_time": 0.8236186504364014,
    "error": null
  },
  "prompt": "Create a coordinate descent optimizer for 26 circles in [0,1]x[0,1].\n\nStrategy:\n1. Initialize with grid pattern\n2. Iteratively optimize each circle's position and radius while keeping others fixed\n3. Use scipy.optimize for each single-circle optimization\n4. Repeat for multiple passes through all circles\n5. Final global optimization with SLSQP\n\nInclude construct_packing() and run_packing() functions that return (centers, radii, sum_radii).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize, Bounds\nfrom typing import Tuple\n\ndef construct_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Construct an optimized packing of 26 circles in [0,1]x[0,1] using coordinate descent.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    n_circles = 26\n    \n    # Initialize with grid pattern (6x5 grid with some offset)\n    grid_x = 5\n    grid_y = 6\n    centers = []\n    for i in range(grid_y):\n        for j in range(grid_x):\n            if len(centers) < n_circles:\n                x = (j + 0.5) / grid_x\n                y = (i + 0.5) / grid_y\n                centers.append([x, y])\n    \n    # Add remaining circle if needed\n    while len(centers) < n_circles:\n        centers.append([0.5, 0.5])\n    \n    centers = np.array(centers)\n    \n    # Initialize radii with small values\n    radii = np.ones(n_circles) * 0.05\n    \n    def compute_max_radius(center_i, centers_other, radii_other):\n        \"\"\"Compute maximum valid radius for circle i given others are fixed.\"\"\"\n        x, y = center_i\n        \n        # Constraint from boundaries\n        max_r = min(x, y, 1 - x, 1 - y)\n        \n        # Constraint from other circles\n        for j, (center_j, r_j) in enumerate(zip(centers_other, radii_other)):\n            dist = np.linalg.norm(center_i - center_j)\n            max_r = min(max_r, dist - r_j)\n        \n        return max(max_r, 0.0)\n    \n    def optimize_single_circle(i, centers, radii):\n        \"\"\"Optimize position and radius of circle i while keeping others fixed.\"\"\"\n        other_indices = [j for j in range(n_circles) if j != i]\n        centers_other = centers[other_indices]\n        radii_other = radii[other_indices]\n        \n        def objective(params):\n            \"\"\"Negative radius to maximize.\"\"\"\n            x, y, r = params\n            return -r\n        \n        def constraint_boundary(params):\n            \"\"\"Ensure circle stays within [0,1]x[0,1].\"\"\"\n            x, y, r = params\n            return np.array([x - r, y - r, 1 - x - r, 1 - y - r])\n        \n        def constraint_no_overlap(params):\n            \"\"\"Ensure no overlap with other circles.\"\"\"\n            x, y, r = params\n            center_i = np.array([x, y])\n            constraints = []\n            for center_j, r_j in zip(centers_other, radii_other):\n                dist = np.linalg.norm(center_i - center_j)\n                constraints.append(dist - r - r_j)\n            return np.array(constraints)\n        \n        # Initial guess\n        x0 = np.array([centers[i, 0], centers[i, 1], radii[i]])\n        \n        # Bounds\n        bounds = Bounds([0, 0, 0], [1, 1, 0.5])\n        \n        # Constraints\n        constraints = [\n            {'type': 'ineq', 'fun': constraint_boundary},\n            {'type': 'ineq', 'fun': constraint_no_overlap}\n        ]\n        \n        # Optimize\n        result = minimize(objective, x0, method='SLSQP', bounds=bounds, \n                         constraints=constraints, options={'maxiter': 100})\n        \n        if result.success:\n            return result.x[:2], result.x[2]\n        else:\n            # If optimization fails, just compute max radius at current position\n            r_max = compute_max_radius(centers[i], centers_other, radii_other)\n            return centers[i], r_max\n    \n    # Coordinate descent: multiple passes\n    n_passes = 5\n    for pass_num in range(n_passes):\n        # Randomize order to avoid bias\n        order = np.random.permutation(n_circles)\n        \n        for i in order:\n            new_center, new_radius = optimize_single_circle(i, centers, radii)\n            centers[i] = new_center\n            radii[i] = new_radius\n    \n    # Final global optimization\n    def global_objective(params):\n        \"\"\"Negative sum of radii.\"\"\"\n        n = n_circles\n        radii_opt = params[2*n:]\n        return -np.sum(radii_opt)\n    \n    def global_constraint_boundary(params):\n        \"\"\"All circles stay within boundaries.\"\"\"\n        n = n_circles\n        centers_opt = params[:2*n].reshape(n, 2)\n        radii_opt = params[2*n:]\n        \n        constraints = []\n        for i in range(n):\n            x, y, r = centers_opt[i, 0], centers_opt[i, 1], radii_opt[i]\n            constraints.extend([x - r, y - r, 1 - x - r, 1 - y - r])\n        return np.array(constraints)\n    \n    def global_constraint_no_overlap(params):\n        \"\"\"No circles overlap.\"\"\"\n        n = n_circles\n        centers_opt = params[:2*n].reshape(n, 2)\n        radii_opt = params[2*n:]\n        \n        constraints = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers_opt[i] - centers_opt[j])\n                constraints.append(dist - radii_opt[i] - radii_opt[j])\n        return np.array(constraints)\n    \n    # Pack parameters\n    x0_global = np.concatenate([centers.flatten(), radii])\n    \n    # Bounds\n    bounds_global = Bounds(\n        np.concatenate([np.zeros(2*n_circles), np.zeros(n_circles)]),\n        np.concatenate([np.ones(2*n_circles), 0.5*np.ones(n_circles)])\n    )\n    \n    # Constraints\n    constraints_global = [\n        {'type': 'ineq', 'fun': global_constraint_boundary},\n        {'type': 'ineq', 'fun': global_constraint_no_overlap}\n    ]\n    \n    # Global optimization\n    result_global = minimize(global_objective, x0_global, method='SLSQP',\n                            bounds=bounds_global, constraints=constraints_global,\n                            options={'maxiter': 200, 'ftol': 1e-6})\n    \n    if result_global.success:\n        centers = result_global.x[:2*n_circles].reshape(n_circles, 2)\n        radii = result_global.x[2*n_circles:]\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing() -> Tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Run the packing optimization.\n    \n    Returns:\n        centers: (26, 2) array of circle centers\n        radii: (26,) array of circle radii\n        sum_radii: sum of all radii\n    \"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    \n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    print(f\"Mean radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Verify constraints\n    print(\"\\nVerifying constraints:\")\n    \n    # Check boundaries\n    boundary_violations = 0\n    for i, (center, r) in enumerate(zip(centers, radii)):\n        if center[0] - r < -1e-6 or center[1] - r < -1e-6:\n            boundary_violations += 1\n        if center[0] + r > 1 + 1e-6 or center[1] + r > 1 + 1e-6:\n            boundary_violations += 1\n    print(f\"Boundary violations: {boundary_violations}\")\n    \n    # Check overlaps\n    overlap_violations = 0\n    for i in range(len(centers)):\n        for j in range(i + 1, len(centers)):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                overlap_violations += 1\n    print(f\"Overlap violations: {overlap_violations}\")\n```",
  "reasoning": "",
  "timestamp": "2025-12-06T14:28:57.354607",
  "cost_data": null
}