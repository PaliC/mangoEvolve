{
  "trial_id": "trial_1_4",
  "generation": 1,
  "parent_id": "trial_0_14",
  "code": "",
  "metrics": {},
  "prompt": "Improve this hybrid grid + local search algorithm. Here is the code:\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    \n    # Start with a 5x6 grid (30 positions, we'll use 26)\n    n = 26\n    grid_rows = 5\n    grid_cols = 6\n    \n    # Initialize grid with some margin\n    margin = 0.08\n    x_positions = np.linspace(margin, 1 - margin, grid_cols)\n    y_positions = np.linspace(margin, 1 - margin, grid_rows)\n    \n    # Create grid centers\n    centers = []\n    for i in range(grid_rows):\n        for j in range(grid_cols):\n            if len(centers) < n:\n                centers.append([x_positions[j], y_positions[i]])\n    \n    centers = np.array(centers)\n    \n    # Initialize radii based on minimum spacing\n    distances = cdist(centers, centers)\n    np.fill_diagonal(distances, np.inf)\n    min_spacing = np.min(distances, axis=1)\n    radii = np.minimum(min_spacing / 2.2, 0.08)  # Conservative initial radii\n    \n    # Phase 1: Local search for better positions\n    print(\"Phase 1: Optimizing positions...\")\n    centers, radii = optimize_positions(centers, radii, iterations=100)\n    \n    # Phase 2: Incrementally increase radii\n    print(\"Phase 2: Increasing radii...\")\n    radii = maximize_radii(centers, radii, steps=50)\n    \n    # Phase 3: Small perturbations with simulated annealing\n    print(\"Phase 3: Fine-tuning with perturbations...\")\n    centers, radii = simulated_annealing(centers, radii, iterations=200)\n    \n    # Phase 4: Final radius maximization\n    print(\"Phase 4: Final radius optimization...\")\n    radii = maximize_radii(centers, radii, steps=30)\n    \n    sum_radii = np.sum(radii)\n    print(f\"Final sum of radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\n\ndef optimize_positions(centers, radii, iterations=100):\n    \"\"\"Optimize circle positions to reduce wasted space\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for iteration in range(iterations):\n        # Try to optimize positions while maintaining feasibility\n        test_centers = best_centers.copy()\n        \n        # Move circles away from boundaries and towards better packing\n        for i in range(n):\n            # Calculate repulsion from boundaries\n            boundary_force = np.zeros(2)\n            if test_centers[i, 0] < 0.15:\n                boundary_force[0] = 0.01\n            elif test_centers[i, 0] > 0.85:\n                boundary_force[0] = -0.01\n            if test_centers[i, 1] < 0.15:\n                boundary_force[1] = 0.01\n            elif test_centers[i, 1] > 0.85:\n                boundary_force[1] = -0.01\n            \n            # Calculate attraction to center of mass (mild)\n            com = np.mean(test_centers, axis=0)\n            com_force = (com - test_centers[i]) * 0.005\n            \n            # Apply forces\n            test_centers[i] += boundary_force + com_force\n            test_centers[i] = np.clip(test_centers[i], 0.05, 0.95)\n        \n        # Check if this configuration allows larger radii\n        test_radii = maximize_radii(test_centers, best_radii * 0.9, steps=10)\n        test_sum = np.sum(test_radii)\n        \n        if test_sum > best_sum:\n            best_centers = test_centers\n            best_radii = test_radii\n            best_sum = test_sum\n            print(f\"  Iteration {iteration}: sum = {best_sum:.6f}\")\n    \n    return best_centers, best_radii\n\n\ndef maximize_radii(centers, radii, steps=50):\n    \"\"\"Incrementally increase radii while maintaining feasibility\"\"\"\n    n = len(centers)\n    current_radii = radii.copy()\n    \n    for step in range(steps):\n        improved = False\n        for i in range(n):\n            # Try to increase radius of circle i\n            old_radius = current_radii[i]\n            test_radius = old_radius * 1.02  # 2% increase\n            \n            # Check feasibility\n            if is_feasible_single(centers, current_radii, i, test_radius):\n                current_radii[i] = test_radius\n                improved = True\n        \n        if not improved:\n            break\n    \n    return current_radii\n\n\ndef is_feasible_single(centers, radii, idx, new_radius):\n    \"\"\"Check if changing radius of circle idx to new_radius is feasible\"\"\"\n    n = len(centers)\n    center = centers[idx]\n    \n    # Check boundary constraints\n    if (center[0] - new_radius < 0 or center[0] + new_radius > 1 or\n        center[1] - new_radius < 0 or center[1] + new_radius > 1):\n        return False\n    \n    # Check overlap with other circles\n    for j in range(n):\n        if j != idx:\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            if dist < new_radius + radii[j] - 1e-6:\n                return False\n    \n    return True\n\n\ndef simulated_annealing(centers, radii, iterations=200):\n    \"\"\"Apply simulated annealing for fine-tuning\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = best_sum\n    \n    temperature = 0.05\n    cooling_rate = 0.97\n    \n    for iteration in range(iterations):\n        # Randomly perturb one or more circles\n        test_centers = current_centers.copy()\n        num_perturb = np.random.randint(1, 4)\n        indices = np.random.choice(n, num_perturb, replace=False)\n        \n        for idx in indices:\n            perturbation = np.random.randn(2) * temperature\n            test_centers[idx] += perturbation\n            test_centers[idx] = np.clip(test_centers[idx], 0.05, 0.95)\n        \n        # Recompute radii for this configuration\n        test_radii = maximize_radii(test_centers, current_radii * 0.95, steps=15)\n        test_sum = np.sum(test_radii)\n        \n        # Accept or reject based on simulated annealing criterion\n        delta = test_sum - current_sum\n        if delta > 0 or np.random.rand() < np.exp(delta / temperature):\n            current_centers = test_centers\n            current_radii = test_radii\n            current_sum = test_sum\n            \n            if current_sum > best_sum:\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_sum = current_sum\n                print(f\"  Iteration {iteration}: new best = {best_sum:.6f}\")\n        \n        temperature *= cooling_rate\n    \n    return best_centers, best_radii\n\n\ndef run_packing():\n    return construct_packing()\n\n\n# Visualization function (optional)\ndef visualize_packing(centers, radii):\n    \"\"\"Visualize the circle packing\"\"\"\n    import matplotlib.pyplot as plt\n    \n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = plt.Circle(center, radius, fill=False, edgecolor='blue', linewidth=1.5)\n        ax.add_patch(circle)\n        ax.plot(center[0], center[1], 'r.', markersize=3)\n    \n    # Draw boundary\n    ax.plot([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], 'k-', linewidth=2)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing: 26 circles, sum of radii = {np.sum(radii):.6f}')\n    \n    plt.tight_layout()\n    plt.savefig('packing_26_circles.png', dpi=150, bbox_inches='tight')\n    print(\"Visualization saved as 'packing_26_circles.png'\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"\\nFinal result: sum of radii = {sum_radii:.6f}\")\n    print(f\"Average radius: {np.mean(radii):.6f}\")\n    print(f\"Min radius: {np.min(radii):.6f}\")\n    print(f\"Max radius: {np.max(radii):.6f}\")\n    \n    # Verify feasibility\n    n = len(centers)\n    valid = True\n    for i in range(n):\n        # Check boundaries\n        if (centers[i, 0] - radii[i] < -1e-6 or centers[i, 0] + radii[i] > 1 + 1e-6 or\n            centers[i, 1] - radii[i] < -1e-6 or centers[i, 1] + radii[i] > 1 + 1e-6):\n            print(f\"Circle {i} violates boundary!\")\n            valid = False\n        \n        # Check overlaps\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j] - 1e-6:\n                print(f\"Circles {i} and {j} overlap!\")\n                valid = False\n    \n    if valid:\n        print(\"\\n\u2713 All constraints satisfied!\")\n    \n    # Uncomment to visualize\n    # visualize_packing(centers, radii)\n\nEnhancements:\n1. Start with multiple grid configurations (4x7, 5x6, 6x5) and test each\n2. Use scipy.optimize.minimize with L-BFGS-B to refine positions instead of manual forces\n3. Increase the number of radius maximization steps to 100\n4. Add a final simulated annealing phase with tighter parameters\n5. Use smaller perturbations and more iterations\n\nInclude the exact functions: construct_packing() and run_packing()",
  "response": "Here's the improved hybrid grid + local search algorithm with all the requested enhancements:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    \n    n = 26\n    best_overall_centers = None\n    best_overall_radii = None\n    best_overall_sum = 0\n    \n    # Test multiple grid configurations\n    grid_configs = [(4, 7), (5, 6), (6, 5), (7, 4)]\n    \n    for grid_rows, grid_cols in grid_configs:\n        print(f\"\\n{'='*60}\")\n        print(f\"Testing grid configuration: {grid_rows}x{grid_cols}\")\n        print(f\"{'='*60}\")\n        \n        # Initialize grid with some margin\n        margin = 0.07\n        x_positions = np.linspace(margin, 1 - margin, grid_cols)\n        y_positions = np.linspace(margin, 1 - margin, grid_rows)\n        \n        # Create grid centers\n        centers = []\n        for i in range(grid_rows):\n            for j in range(grid_cols):\n                if len(centers) < n:\n                    centers.append([x_positions[j], y_positions[i]])\n        \n        centers = np.array(centers)\n        \n        # Initialize radii based on minimum spacing\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        min_spacing = np.min(distances, axis=1)\n        radii = np.minimum(min_spacing / 2.3, 0.08)  # Conservative initial radii\n        \n        # Phase 1: Scipy optimization for positions\n        print(\"Phase 1: Scipy L-BFGS-B optimization...\")\n        centers, radii = scipy_optimize_positions(centers, radii, iterations=3)\n        \n        # Phase 2: Local search for better positions\n        print(\"Phase 2: Local search optimization...\")\n        centers, radii = optimize_positions(centers, radii, iterations=150)\n        \n        # Phase 3: Incrementally increase radii (more steps)\n        print(\"Phase 3: Increasing radii...\")\n        radii = maximize_radii(centers, radii, steps=100)\n        \n        # Phase 4: Simulated annealing with larger search\n        print(\"Phase 4: Simulated annealing...\")\n        centers, radii = simulated_annealing(centers, radii, iterations=300)\n        \n        # Phase 5: Final radius maximization\n        print(\"Phase 5: Final radius optimization...\")\n        radii = maximize_radii(centers, radii, steps=100)\n        \n        # Phase 6: Fine-tuning with tighter simulated annealing\n        print(\"Phase 6: Fine-tuning with tight SA...\")\n        centers, radii = simulated_annealing_tight(centers, radii, iterations=200)\n        \n        # Phase 7: Final radius push\n        print(\"Phase 7: Final radius push...\")\n        radii = maximize_radii(centers, radii, steps=50)\n        \n        sum_radii = np.sum(radii)\n        print(f\"Grid {grid_rows}x{grid_cols} final sum: {sum_radii:.6f}\")\n        \n        if sum_radii > best_overall_sum:\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            best_overall_sum = sum_radii\n            print(f\"*** New best configuration! ***\")\n    \n    print(f\"\\n{'='*60}\")\n    print(f\"Best overall sum of radii: {best_overall_sum:.6f}\")\n    print(f\"{'='*60}\")\n    \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef scipy_optimize_positions(centers, radii, iterations=3):\n    \"\"\"Use scipy.optimize.minimize to refine positions\"\"\"\n    n = len(centers)\n    \n    def objective(positions):\n        \"\"\"Objective: maximize minimum pairwise distance (for better spread)\"\"\"\n        pos = positions.reshape(n, 2)\n        distances = cdist(pos, pos)\n        np.fill_diagonal(distances, np.inf)\n        \n        # Penalize being too close to boundaries\n        boundary_penalty = 0\n        for i in range(n):\n            margin = 0.05\n            if pos[i, 0] < margin:\n                boundary_penalty += (margin - pos[i, 0]) ** 2\n            if pos[i, 0] > 1 - margin:\n                boundary_penalty += (pos[i, 0] - (1 - margin)) ** 2\n            if pos[i, 1] < margin:\n                boundary_penalty += (margin - pos[i, 1]) ** 2\n            if pos[i, 1] > 1 - margin:\n                boundary_penalty += (pos[i, 1] - (1 - margin)) ** 2\n        \n        # Maximize minimum distance, penalize boundary violations\n        min_dist = np.min(distances)\n        return -min_dist + 10 * boundary_penalty\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for iteration in range(iterations):\n        # Bounds for L-BFGS-B\n        bounds = [(0.04, 0.96) for _ in range(2 * n)]\n        \n        # Optimize\n        result = minimize(\n            objective,\n            best_centers.flatten(),\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 100, 'ftol': 1e-6}\n        )\n        \n        if result.success:\n            test_centers = result.x.reshape(n, 2)\n            # Try to maximize radii with new positions\n            test_radii = maximize_radii(test_centers, best_radii * 0.9, steps=30)\n            test_sum = np.sum(test_radii)\n            \n            if test_sum > best_sum:\n                best_centers = test_centers\n                best_radii = test_radii\n                best_sum = test_sum\n                print(f\"  Scipy iteration {iteration}: sum = {best_sum:.6f}\")\n    \n    return best_centers, best_radii\n\n\ndef optimize_positions(centers, radii, iterations=150):\n    \"\"\"Optimize circle positions to reduce wasted space\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for iteration in range(iterations):\n        # Try to optimize positions while maintaining feasibility\n        test_centers = best_centers.copy()\n        \n        # Move circles away from boundaries and towards better packing\n        for i in range(n):\n            # Calculate repulsion from boundaries\n            boundary_force = np.zeros(2)\n            margin = 0.12\n            strength = 0.008\n            \n            if test_centers[i, 0] < margin:\n                boundary_force[0] = strength\n            elif test_centers[i, 0] > 1 - margin:\n                boundary_force[0] = -strength\n            if test_centers[i, 1] < margin:\n                boundary_force[1] = strength\n            elif test_centers[i, 1] > 1 - margin:\n                boundary_force[1] = -strength\n            \n            # Calculate attraction to center of mass (mild)\n            com = np.mean(test_centers, axis=0)\n            com_force = (com - test_centers[i]) * 0.003\n            \n            # Calculate repulsion from nearby circles\n            repulsion_force = np.zeros(2)\n            for j in range(n):\n                if i != j:\n                    diff = test_centers[i] - test_centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist < 0.2:  # Only consider nearby circles\n                        repulsion_force += diff / (dist ** 2 + 0.01) * 0.002\n            \n            # Apply forces\n            test_centers[i] += boundary_force + com_force + repulsion_force\n            test_centers[i] = np.clip(test_centers[i], 0.04, 0.96)\n        \n        # Check if this configuration allows larger radii\n        test_radii = maximize_radii(test_centers, best_radii * 0.92, steps=15)\n        test_sum = np.sum(test_radii)\n        \n        if test_sum > best_sum:\n            best_centers = test_centers\n            best_radii = test_radii\n            best_sum = test_sum\n            if iteration % 20 == 0:\n                print(f\"  Iteration {iteration}: sum = {best_sum:.6f}\")\n    \n    return best_centers, best_radii\n\n\ndef maximize_radii(centers, radii, steps=100):\n    \"\"\"Incrementally increase radii while maintaining feasibility\"\"\"\n    n = len(centers)\n    current_radii = radii.copy()\n    \n    for step in range(steps):\n        improved = False\n        # Try each circle in random order\n        indices = np.random.permutation(n)\n        \n        for i in indices:\n            # Try to increase radius of circle i\n            old_radius = current_radii[i]\n            test_radius = old_radius * 1.015  # 1.5% increase (smaller steps)\n            \n            # Check feasibility\n            if is_feasible_single(centers, current_radii, i, test_radius):\n                current_radii[i] = test_radius\n                improved = True\n        \n        if not improved:\n            break\n    \n    return current_radii\n\n\ndef is_feasible_single(centers, radii, idx, new_radius):\n    \"\"\"Check if changing radius of circle idx to new_radius is feasible\"\"\"\n    n = len(centers)\n    center = centers[idx]\n    \n    # Check boundary constraints\n    if (center[0] - new_radius < -1e-9 or center[0] + new_radius > 1 + 1e-9 or\n        center[1] - new_radius < -1e-9 or center[1] + new_radius > 1 + 1e-9):\n        return False\n    \n    # Check overlap with other circles\n    for j in range(n):\n        if j != idx:\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            if dist < new_radius + radii[j] - 1e-9:\n                return False\n    \n    return True\n\n\ndef simulated_annealing(centers, radii, iterations=300):\n    \"\"\"Apply simulated annealing for fine-tuning\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = best_sum\n    \n    temperature = 0.04\n    cooling_rate = 0.975\n    \n    for iteration in range(iterations):\n        # Randomly perturb one or more circles (smaller perturbations)\n        test_centers = current_centers.copy()\n        num_perturb = np.random.randint(1, 5)\n        indices = np.random.choice(n, num_perturb, replace=False)\n        \n        for idx in indices:\n            perturbation = np.random.randn(2) * temperature * 0.8\n            test_centers[idx] += perturbation\n            test_centers[idx] = np.clip(test_centers[idx], 0.04, 0.96)\n        \n        # Recompute radii for this configuration\n        test_radii = maximize_radii(test_centers, current_radii * 0.93, steps=20)\n        test_sum = np.sum(test_radii)\n        \n        # Accept or reject based on simulated annealing criterion\n        delta = test_sum - current_sum\n        if delta > 0 or np.random.rand() < np.exp(delta / (temperature + 1e-10)):\n            current_centers = test_centers\n            current_radii = test_radii\n            current_sum = test_sum\n            \n            if current_sum > best_sum:\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_sum = current_sum\n                print(f\"  Iteration {iteration}: new best = {best_sum:.6f}\")\n        \n        temperature *= cooling_rate\n    \n    return best_centers, best_radii\n\n\ndef simulated_annealing_tight(centers, radii, iterations=200):\n    \"\"\"Apply tighter simulated annealing for final fine-tuning\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = best_sum\n    \n    temperature = 0.015  # Much smaller initial temperature\n    cooling_rate = 0.98\n    \n    for iteration in range(iterations):\n        # Very small perturbations\n        test_centers = current_centers.copy()\n        num_perturb = np.random.randint(1, 3)\n        indices = np.random.choice(n, num_perturb, replace=False)\n        \n        for idx in indices:\n            perturbation = np.random.randn(2) * temperature * 0.5\n            test_centers[idx] += perturbation\n            test_centers[idx] = np.clip(test_centers[idx], 0.04, 0.96)\n        \n        # Recompute radii for this configuration\n        test_radii = maximize_radii(test_centers, current_radii * 0.95, steps=25)\n        test_sum = np.sum(test_radii)\n        \n        # Accept or reject\n        delta = test_sum - current_sum\n        if delta > 0 or np.random.rand() < np.exp(delta / (temperature + 1e-10)):\n            current_centers = test_centers\n            current_radii = test_radii\n            current_sum = test_sum\n            \n            if current_sum > best_sum:\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_sum = current_sum\n                print(f\"  Fine-tune iteration {iteration}: new best = {best_sum:.6f}\")\n        \n        temperature *= cooling_rate\n    \n    return best_centers, best_radii\n\n\ndef run_packing():\n    return construct_packing()\n\n\n# Visualization function (optional)\ndef visualize_packing(centers, radii):\n    \"\"\"Visualize the circle packing\"\"\"\n    import matplotlib.pyplot as plt\n    \n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = plt.Circle(center, radius, fill=False, edgecolor='blue', linewidth=1.5)\n        ax.add_patch(circle)\n        ax.plot(center[0], center[1], 'r.', markersize=3)\n    \n    # Draw boundary\n    ax.plot([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], 'k-', linewidth=2)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing: 26 circles, sum of radii = {np.sum(radii):.6f}')\n    \n    plt.tight_layout()\n    plt.savefig('packing_26_circles.png', dpi=150",
  "reasoning": "Here's the improved hybrid grid + local search algorithm with all the requested enhancements:\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    \"\"\"Returns (centers, radii, sum_radii) for 26 circles\"\"\"\n    \n    n = 26\n    best_overall_centers = None\n    best_overall_radii = None\n    best_overall_sum = 0\n    \n    # Test multiple grid configurations\n    grid_configs = [(4, 7), (5, 6), (6, 5), (7, 4)]\n    \n    for grid_rows, grid_cols in grid_configs:\n        print(f\"\\n{'='*60}\")\n        print(f\"Testing grid configuration: {grid_rows}x{grid_cols}\")\n        print(f\"{'='*60}\")\n        \n        # Initialize grid with some margin\n        margin = 0.07\n        x_positions = np.linspace(margin, 1 - margin, grid_cols)\n        y_positions = np.linspace(margin, 1 - margin, grid_rows)\n        \n        # Create grid centers\n        centers = []\n        for i in range(grid_rows):\n            for j in range(grid_cols):\n                if len(centers) < n:\n                    centers.append([x_positions[j], y_positions[i]])\n        \n        centers = np.array(centers)\n        \n        # Initialize radii based on minimum spacing\n        distances = cdist(centers, centers)\n        np.fill_diagonal(distances, np.inf)\n        min_spacing = np.min(distances, axis=1)\n        radii = np.minimum(min_spacing / 2.3, 0.08)  # Conservative initial radii\n        \n        # Phase 1: Scipy optimization for positions\n        print(\"Phase 1: Scipy L-BFGS-B optimization...\")\n        centers, radii = scipy_optimize_positions(centers, radii, iterations=3)\n        \n        # Phase 2: Local search for better positions\n        print(\"Phase 2: Local search optimization...\")\n        centers, radii = optimize_positions(centers, radii, iterations=150)\n        \n        # Phase 3: Incrementally increase radii (more steps)\n        print(\"Phase 3: Increasing radii...\")\n        radii = maximize_radii(centers, radii, steps=100)\n        \n        # Phase 4: Simulated annealing with larger search\n        print(\"Phase 4: Simulated annealing...\")\n        centers, radii = simulated_annealing(centers, radii, iterations=300)\n        \n        # Phase 5: Final radius maximization\n        print(\"Phase 5: Final radius optimization...\")\n        radii = maximize_radii(centers, radii, steps=100)\n        \n        # Phase 6: Fine-tuning with tighter simulated annealing\n        print(\"Phase 6: Fine-tuning with tight SA...\")\n        centers, radii = simulated_annealing_tight(centers, radii, iterations=200)\n        \n        # Phase 7: Final radius push\n        print(\"Phase 7: Final radius push...\")\n        radii = maximize_radii(centers, radii, steps=50)\n        \n        sum_radii = np.sum(radii)\n        print(f\"Grid {grid_rows}x{grid_cols} final sum: {sum_radii:.6f}\")\n        \n        if sum_radii > best_overall_sum:\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            best_overall_sum = sum_radii\n            print(f\"*** New best configuration! ***\")\n    \n    print(f\"\\n{'='*60}\")\n    print(f\"Best overall sum of radii: {best_overall_sum:.6f}\")\n    print(f\"{'='*60}\")\n    \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\ndef scipy_optimize_positions(centers, radii, iterations=3):\n    \"\"\"Use scipy.optimize.minimize to refine positions\"\"\"\n    n = len(centers)\n    \n    def objective(positions):\n        \"\"\"Objective: maximize minimum pairwise distance (for better spread)\"\"\"\n        pos = positions.reshape(n, 2)\n        distances = cdist(pos, pos)\n        np.fill_diagonal(distances, np.inf)\n        \n        # Penalize being too close to boundaries\n        boundary_penalty = 0\n        for i in range(n):\n            margin = 0.05\n            if pos[i, 0] < margin:\n                boundary_penalty += (margin - pos[i, 0]) ** 2\n            if pos[i, 0] > 1 - margin:\n                boundary_penalty += (pos[i, 0] - (1 - margin)) ** 2\n            if pos[i, 1] < margin:\n                boundary_penalty += (margin - pos[i, 1]) ** 2\n            if pos[i, 1] > 1 - margin:\n                boundary_penalty += (pos[i, 1] - (1 - margin)) ** 2\n        \n        # Maximize minimum distance, penalize boundary violations\n        min_dist = np.min(distances)\n        return -min_dist + 10 * boundary_penalty\n    \n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for iteration in range(iterations):\n        # Bounds for L-BFGS-B\n        bounds = [(0.04, 0.96) for _ in range(2 * n)]\n        \n        # Optimize\n        result = minimize(\n            objective,\n            best_centers.flatten(),\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'maxiter': 100, 'ftol': 1e-6}\n        )\n        \n        if result.success:\n            test_centers = result.x.reshape(n, 2)\n            # Try to maximize radii with new positions\n            test_radii = maximize_radii(test_centers, best_radii * 0.9, steps=30)\n            test_sum = np.sum(test_radii)\n            \n            if test_sum > best_sum:\n                best_centers = test_centers\n                best_radii = test_radii\n                best_sum = test_sum\n                print(f\"  Scipy iteration {iteration}: sum = {best_sum:.6f}\")\n    \n    return best_centers, best_radii\n\ndef optimize_positions(centers, radii, iterations=150):\n    \"\"\"Optimize circle positions to reduce wasted space\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    for iteration in range(iterations):\n        # Try to optimize positions while maintaining feasibility\n        test_centers = best_centers.copy()\n        \n        # Move circles away from boundaries and towards better packing\n        for i in range(n):\n            # Calculate repulsion from boundaries\n            boundary_force = np.zeros(2)\n            margin = 0.12\n            strength = 0.008\n            \n            if test_centers[i, 0] < margin:\n                boundary_force[0] = strength\n            elif test_centers[i, 0] > 1 - margin:\n                boundary_force[0] = -strength\n            if test_centers[i, 1] < margin:\n                boundary_force[1] = strength\n            elif test_centers[i, 1] > 1 - margin:\n                boundary_force[1] = -strength\n            \n            # Calculate attraction to center of mass (mild)\n            com = np.mean(test_centers, axis=0)\n            com_force = (com - test_centers[i]) * 0.003\n            \n            # Calculate repulsion from nearby circles\n            repulsion_force = np.zeros(2)\n            for j in range(n):\n                if i != j:\n                    diff = test_centers[i] - test_centers[j]\n                    dist = np.linalg.norm(diff)\n                    if dist < 0.2:  # Only consider nearby circles\n                        repulsion_force += diff / (dist ** 2 + 0.01) * 0.002\n            \n            # Apply forces\n            test_centers[i] += boundary_force + com_force + repulsion_force\n            test_centers[i] = np.clip(test_centers[i], 0.04, 0.96)\n        \n        # Check if this configuration allows larger radii\n        test_radii = maximize_radii(test_centers, best_radii * 0.92, steps=15)\n        test_sum = np.sum(test_radii)\n        \n        if test_sum > best_sum:\n            best_centers = test_centers\n            best_radii = test_radii\n            best_sum = test_sum\n            if iteration % 20 == 0:\n                print(f\"  Iteration {iteration}: sum = {best_sum:.6f}\")\n    \n    return best_centers, best_radii\n\ndef maximize_radii(centers, radii, steps=100):\n    \"\"\"Incrementally increase radii while maintaining feasibility\"\"\"\n    n = len(centers)\n    current_radii = radii.copy()\n    \n    for step in range(steps):\n        improved = False\n        # Try each circle in random order\n        indices = np.random.permutation(n)\n        \n        for i in indices:\n            # Try to increase radius of circle i\n            old_radius = current_radii[i]\n            test_radius = old_radius * 1.015  # 1.5% increase (smaller steps)\n            \n            # Check feasibility\n            if is_feasible_single(centers, current_radii, i, test_radius):\n                current_radii[i] = test_radius\n                improved = True\n        \n        if not improved:\n            break\n    \n    return current_radii\n\ndef is_feasible_single(centers, radii, idx, new_radius):\n    \"\"\"Check if changing radius of circle idx to new_radius is feasible\"\"\"\n    n = len(centers)\n    center = centers[idx]\n    \n    # Check boundary constraints\n    if (center[0] - new_radius < -1e-9 or center[0] + new_radius > 1 + 1e-9 or\n        center[1] - new_radius < -1e-9 or center[1] + new_radius > 1 + 1e-9):\n        return False\n    \n    # Check overlap with other circles\n    for j in range(n):\n        if j != idx:\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            if dist < new_radius + radii[j] - 1e-9:\n                return False\n    \n    return True\n\ndef simulated_annealing(centers, radii, iterations=300):\n    \"\"\"Apply simulated annealing for fine-tuning\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = best_sum\n    \n    temperature = 0.04\n    cooling_rate = 0.975\n    \n    for iteration in range(iterations):\n        # Randomly perturb one or more circles (smaller perturbations)\n        test_centers = current_centers.copy()\n        num_perturb = np.random.randint(1, 5)\n        indices = np.random.choice(n, num_perturb, replace=False)\n        \n        for idx in indices:\n            perturbation = np.random.randn(2) * temperature * 0.8\n            test_centers[idx] += perturbation\n            test_centers[idx] = np.clip(test_centers[idx], 0.04, 0.96)\n        \n        # Recompute radii for this configuration\n        test_radii = maximize_radii(test_centers, current_radii * 0.93, steps=20)\n        test_sum = np.sum(test_radii)\n        \n        # Accept or reject based on simulated annealing criterion\n        delta = test_sum - current_sum\n        if delta > 0 or np.random.rand() < np.exp(delta / (temperature + 1e-10)):\n            current_centers = test_centers\n            current_radii = test_radii\n            current_sum = test_sum\n            \n            if current_sum > best_sum:\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_sum = current_sum\n                print(f\"  Iteration {iteration}: new best = {best_sum:.6f}\")\n        \n        temperature *= cooling_rate\n    \n    return best_centers, best_radii\n\ndef simulated_annealing_tight(centers, radii, iterations=200):\n    \"\"\"Apply tighter simulated annealing for final fine-tuning\"\"\"\n    n = len(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = np.sum(radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_sum = best_sum\n    \n    temperature = 0.015  # Much smaller initial temperature\n    cooling_rate = 0.98\n    \n    for iteration in range(iterations):\n        # Very small perturbations\n        test_centers = current_centers.copy()\n        num_perturb = np.random.randint(1, 3)\n        indices = np.random.choice(n, num_perturb, replace=False)\n        \n        for idx in indices:\n            perturbation = np.random.randn(2) * temperature * 0.5\n            test_centers[idx] += perturbation\n            test_centers[idx] = np.clip(test_centers[idx], 0.04, 0.96)\n        \n        # Recompute radii for this configuration\n        test_radii = maximize_radii(test_centers, current_radii * 0.95, steps=25)\n        test_sum = np.sum(test_radii)\n        \n        # Accept or reject\n        delta = test_sum - current_sum\n        if delta > 0 or np.random.rand() < np.exp(delta / (temperature + 1e-10)):\n            current_centers = test_centers\n            current_radii = test_radii\n            current_sum = test_sum\n            \n            if current_sum > best_sum:\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_sum = current_sum\n                print(f\"  Fine-tune iteration {iteration}: new best = {best_sum:.6f}\")\n        \n        temperature *= cooling_rate\n    \n    return best_centers, best_radii\n\ndef run_packing():\n    return construct_packing()\n\n# Visualization function (optional)\ndef visualize_packing(centers, radii):\n    \"\"\"Visualize the circle packing\"\"\"\n    import matplotlib.pyplot as plt\n    \n    fig, ax = plt.subplots(1, 1, figsize=(8, 8))\n    \n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = plt.Circle(center, radius, fill=False, edgecolor='blue', linewidth=1.5)\n        ax.add_patch(circle)\n        ax.plot(center[0], center[1], 'r.', markersize=3)\n    \n    # Draw boundary\n    ax.plot([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], 'k-', linewidth=2)\n    \n    ax.set_xlim(-0.1, 1.1)\n    ax.set_ylim(-0.1, 1.1)\n    ax.set_aspect('equal')\n    ax.grid(True, alpha=0.3)\n    ax.set_title(f'Circle Packing: 26 circles, sum of radii = {np.sum(radii):.6f}')\n    \n    plt.tight_layout()\n    plt.savefig('packing_26_circles.png', dpi=150",
  "timestamp": "2025-12-06T14:22:23.612897",
  "cost_data": null
}