{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using \n    an iterative optimization approach with a 'shaking' heuristic.\n    \"\"\"\n    n = 26\n    \n    # Heuristic: Start with a grid-like layout to ensure valid initial state\n    # 26 circles fits roughly into a 5x5+1 or 6x5 grid.\n    rows, cols = 5, 6\n    x = np.linspace(0.1, 0.9, cols)\n    y = np.linspace(0.1, 0.9, rows)\n    xv, yv = np.meshgrid(x, y)\n    initial_centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    \n    # Initial radii: small enough to be valid\n    initial_radii = np.full(n, 0.05)\n    \n    # Flatten for optimizer: [x1, y1, ..., xn, yn, r1, ..., rn]\n    initial_params = np.concatenate([initial_centers.flatten(), initial_radii])\n\n    def objective(params):\n        # We want to maximize sum of radii -> minimize -sum(radii)\n        radii = params[2*n:]\n        return -np.sum(radii)\n\n    def constraints(params):\n        centers = params[:2*n].reshape((n, 2))\n        radii = params[2*n:]\n        cons = []\n        \n        # 1. Boundary constraints: center_i - r_i >= 0 and center_i + r_i <= 1\n        for i in range(n):\n            cons.append(centers[i, 0] - radii[i])       # x - r >= 0\n            cons.append(1.0 - (centers[i, 0] + radii[i])) # 1 - (x + r) >= 0\n            cons.append(centers[i, 1] - radii[i])       # y - r >= 0\n            cons.append(1.0 - (centers[i, 1] + radii[i])) # 1 - (y + r) >= 0\n            \n        # 2. Non-overlap constraints: dist(c_i, c_j) >= r_i + r_j\n        # To make it differentiable and more stable, we use squared distances\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_sq = np.sum((centers[i] - centers[j])**2)\n                cons.append(dist_sq - (radii[i] + radii[j])**2)\n        \n        return np.array(cons)\n\n    # Bounds for parameters\n    bounds = []\n    for _ in range(2*n):\n        bounds.append((0, 1)) # Centers must be in [0, 1]\n    for _ in range(n):\n        bounds.append((0, 0.5)) # Radii bounds\n\n    # Optimization using SLSQP\n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n\n    # Shaking Heuristic: Perturb and re-optimize a few times\n    current_params = res.x\n    for _ in range(2):\n        # Shake centers slightly\n        current_params[:2*n] += np.random.normal(0, 0.01, 2*n)\n        current_params = np.clip(current_params, 0, 1)\n        \n        res = minimize(\n            objective, \n            current_params, \n            method='SLSQP', \n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=bounds,\n            options={'maxiter': 50}\n        )\n        current_params = res.x\n\n    # Final extraction\n    final_centers = res.x[:2*n].reshape((n, 2))\n    final_radii = res.x[2*n:]\n    \n    # Ensure strict validity by slightly shrinking radii if necessary\n    # (SLSQP can sometimes produce tiny violations)\n    adjusted_radii = np.copy(final_radii)\n    for i in range(n):\n        # Boundary check\n        dist_to_edge = min(final_centers[i, 0], 1 - final_centers[i, 0], \n                           final_centers[i, 1], 1 - final_centers[i, 1])\n        adjusted_radii[i] = min(adjusted_radii[i], dist_to_edge)\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_centers[i] - final_centers[j])\n            if adjusted_radii[i] + adjusted_radii[j] > dist:\n                # Proportional reduction to fix overlap\n                scale = dist / (adjusted_radii[i] + adjusted_radii[j])\n                adjusted_radii[i] *= (scale - 1e-9)\n                adjusted_radii[j] *= (scale - 1e-9)\n\n    return final_centers, adjusted_radii, np.sum(adjusted_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5571221626855842,
    "eval_time": 1.3355298042297363,
    "error": null,
    "artifacts": {
      "solution": {
        "centers": [
          [
            0.09165170375704894,
            0.09165170375705131
          ],
          [
            0.22861972998461766,
            0.05117264447207532
          ],
          [
            0.35337300074755335,
            0.07603368328977758
          ],
          [
            0.5230878173184642,
            0.0947051284632092
          ],
          [
            0.735421649863481,
            0.11901587901507511
          ],
          [
            0.9247249096705624,
            0.07527509032943729
          ],
          [
            0.09171340509543761,
            0.2750168022280307
          ],
          [
            0.23829392603173316,
            0.1832267331762153
          ],
          [
            0.40229391156375716,
            0.23569339299154685
          ],
          [
            0.5864439871549186,
            0.27629542205397495
          ],
          [
            0.7551948235814628,
            0.3118577790395544
          ],
          [
            0.9074314499055104,
            0.24222545385030794
          ],
          [
            0.09565568998285132,
            0.4623444194861231
          ],
          [
            0.26085956634770024,
            0.3611265657247723
          ],
          [
            0.4507630058034375,
            0.42166229978772146
          ],
          [
            0.6597150597993869,
            0.4753774573937613
          ],
          [
            0.7915341399558622,
            0.6066882827817947
          ],
          [
            0.8862584702871311,
            0.4474461983313129
          ],
          [
            0.0767180020393451,
            0.6336746669613901
          ],
          [
            0.2870278310495842,
            0.5948939118389266
          ],
          [
            0.505370232589594,
            0.5957330625183886
          ],
          [
            0.6510913996996546,
            0.6738304639551849
          ],
          [
            0.8369022801925045,
            0.8369022801925001
          ],
          [
            0.9309613540263169,
            0.624675554846646
          ],
          [
            0.1510370526709328,
            0.8489629473290488
          ],
          [
            0.4650435412069567,
            0.8367948905654431
          ]
        ],
        "radii": [
          0.09165170366518466,
          0.05117264441218971,
          0.07603368320079794,
          0.09470512826850978,
          0.1190158788936066,
          0.07527509025368105,
          0.09171340500350834,
          0.08123533258863304,
          0.0909527784665707,
          0.09762021816717507,
          0.07483709827345332,
          0.09256855000132938,
          0.09565568998285132,
          0.09808995419312316,
          0.10122861336423591,
          0.11451725327881505,
          0.07154403418533364,
          0.11374152971286453,
          0.07671800203934444,
          0.1371374892273467,
          0.08120652484890944,
          0.08412303277145232,
          0.16309771980749502,
          0.06903864597368314,
          0.1510370526709328,
          0.1632051094345569
        ]
      },
      "prompt_context": "## Parent Solution (score: 2.557122)\nNumber of circles: 26\n\n### Circle Positions and Radii\n| Circle | X | Y | Radius |\n|--------|-------|-------|--------|\n|  0 | 0.091652 | 0.091652 | 0.091652 |\n|  1 | 0.228620 | 0.051173 | 0.051173 |\n|  2 | 0.353373 | 0.076034 | 0.076034 |\n|  3 | 0.523088 | 0.094705 | 0.094705 |\n|  4 | 0.735422 | 0.119016 | 0.119016 |\n|  5 | 0.924725 | 0.075275 | 0.075275 |\n|  6 | 0.091713 | 0.275017 | 0.091713 |\n|  7 | 0.238294 | 0.183227 | 0.081235 |\n|  8 | 0.402294 | 0.235693 | 0.090953 |\n|  9 | 0.586444 | 0.276295 | 0.097620 |\n| 10 | 0.755195 | 0.311858 | 0.074837 |\n| 11 | 0.907431 | 0.242225 | 0.092569 |\n| 12 | 0.095656 | 0.462344 | 0.095656 |\n| 13 | 0.260860 | 0.361127 | 0.098090 |\n| 14 | 0.450763 | 0.421662 | 0.101229 |\n| 15 | 0.659715 | 0.475377 | 0.114517 |\n| 16 | 0.791534 | 0.606688 | 0.071544 |\n| 17 | 0.886258 | 0.447446 | 0.113742 |\n| 18 | 0.076718 | 0.633675 | 0.076718 |\n| 19 | 0.287028 | 0.594894 | 0.137137 |\n| 20 | 0.505370 | 0.595733 | 0.081207 |\n| 21 | 0.651091 | 0.673830 | 0.084123 |\n| 22 | 0.836902 | 0.836902 | 0.163098 |\n| 23 | 0.930961 | 0.624676 | 0.069039 |\n| 24 | 0.151037 | 0.848963 | 0.151037 |\n| 25 | 0.465044 | 0.836795 | 0.163205 |\n\n### As Python Arrays (for initialization)\n```python\nimport numpy as np\n\ncenters = np.array([\n    [0.091652, 0.091652],\n    [0.228620, 0.051173],\n    [0.353373, 0.076034],\n    [0.523088, 0.094705],\n    [0.735422, 0.119016],\n    [0.924725, 0.075275],\n    [0.091713, 0.275017],\n    [0.238294, 0.183227],\n    [0.402294, 0.235693],\n    [0.586444, 0.276295],\n    [0.755195, 0.311858],\n    [0.907431, 0.242225],\n    [0.095656, 0.462344],\n    [0.260860, 0.361127],\n    [0.450763, 0.421662],\n    [0.659715, 0.475377],\n    [0.791534, 0.606688],\n    [0.886258, 0.447446],\n    [0.076718, 0.633675],\n    [0.287028, 0.594894],\n    [0.505370, 0.595733],\n    [0.651091, 0.673830],\n    [0.836902, 0.836902],\n    [0.930961, 0.624676],\n    [0.151037, 0.848963],\n    [0.465044, 0.836795]\n])\n\nradii = np.array([\n    0.091652,\n    0.051173,\n    0.076034,\n    0.094705,\n    0.119016,\n    0.075275,\n    0.091713,\n    0.081235,\n    0.090953,\n    0.097620,\n    0.074837,\n    0.092569,\n    0.095656,\n    0.098090,\n    0.101229,\n    0.114517,\n    0.071544,\n    0.113742,\n    0.076718,\n    0.137137,\n    0.081207,\n    0.084123,\n    0.163098,\n    0.069039,\n    0.151037,\n    0.163205\n])\n```",
      "summary": "Valid packing with 26 circles, sum_radii=2.557122"
    }
  },
  "prompt": "Implement a 'shaking' algorithm: start with 26 circles, maximize radii by solving a linear program or using SLSQP, then 'shake' the centers slightly and re-optimize. Repeat for several iterations.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square using \n    an iterative optimization approach with a 'shaking' heuristic.\n    \"\"\"\n    n = 26\n    \n    # Heuristic: Start with a grid-like layout to ensure valid initial state\n    # 26 circles fits roughly into a 5x5+1 or 6x5 grid.\n    rows, cols = 5, 6\n    x = np.linspace(0.1, 0.9, cols)\n    y = np.linspace(0.1, 0.9, rows)\n    xv, yv = np.meshgrid(x, y)\n    initial_centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    \n    # Initial radii: small enough to be valid\n    initial_radii = np.full(n, 0.05)\n    \n    # Flatten for optimizer: [x1, y1, ..., xn, yn, r1, ..., rn]\n    initial_params = np.concatenate([initial_centers.flatten(), initial_radii])\n\n    def objective(params):\n        # We want to maximize sum of radii -> minimize -sum(radii)\n        radii = params[2*n:]\n        return -np.sum(radii)\n\n    def constraints(params):\n        centers = params[:2*n].reshape((n, 2))\n        radii = params[2*n:]\n        cons = []\n        \n        # 1. Boundary constraints: center_i - r_i >= 0 and center_i + r_i <= 1\n        for i in range(n):\n            cons.append(centers[i, 0] - radii[i])       # x - r >= 0\n            cons.append(1.0 - (centers[i, 0] + radii[i])) # 1 - (x + r) >= 0\n            cons.append(centers[i, 1] - radii[i])       # y - r >= 0\n            cons.append(1.0 - (centers[i, 1] + radii[i])) # 1 - (y + r) >= 0\n            \n        # 2. Non-overlap constraints: dist(c_i, c_j) >= r_i + r_j\n        # To make it differentiable and more stable, we use squared distances\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_sq = np.sum((centers[i] - centers[j])**2)\n                cons.append(dist_sq - (radii[i] + radii[j])**2)\n        \n        return np.array(cons)\n\n    # Bounds for parameters\n    bounds = []\n    for _ in range(2*n):\n        bounds.append((0, 1)) # Centers must be in [0, 1]\n    for _ in range(n):\n        bounds.append((0, 0.5)) # Radii bounds\n\n    # Optimization using SLSQP\n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n\n    # Shaking Heuristic: Perturb and re-optimize a few times\n    current_params = res.x\n    for _ in range(2):\n        # Shake centers slightly\n        current_params[:2*n] += np.random.normal(0, 0.01, 2*n)\n        current_params = np.clip(current_params, 0, 1)\n        \n        res = minimize(\n            objective, \n            current_params, \n            method='SLSQP', \n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=bounds,\n            options={'maxiter': 50}\n        )\n        current_params = res.x\n\n    # Final extraction\n    final_centers = res.x[:2*n].reshape((n, 2))\n    final_radii = res.x[2*n:]\n    \n    # Ensure strict validity by slightly shrinking radii if necessary\n    # (SLSQP can sometimes produce tiny violations)\n    adjusted_radii = np.copy(final_radii)\n    for i in range(n):\n        # Boundary check\n        dist_to_edge = min(final_centers[i, 0], 1 - final_centers[i, 0], \n                           final_centers[i, 1], 1 - final_centers[i, 1])\n        adjusted_radii[i] = min(adjusted_radii[i], dist_to_edge)\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_centers[i] - final_centers[j])\n            if adjusted_radii[i] + adjusted_radii[j] > dist:\n                # Proportional reduction to fix overlap\n                scale = dist / (adjusted_radii[i] + adjusted_radii[j])\n                adjusted_radii[i] *= (scale - 1e-9)\n                adjusted_radii[j] *= (scale - 1e-9)\n\n    return final_centers, adjusted_radii, np.sum(adjusted_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:56:05.783723",
  "cost_data": null
}