{
  "trial_id": "trial_5_8",
  "generation": 5,
  "parent_id": "trial_4_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square [0, 1]x[0, 1].\n    Uses a force-directed model with boundary attraction to maximize sum of radii.\n    \"\"\"\n    n = 26\n    # Initialize centers in a grid-like pattern with slight jitter\n    grid_size = int(np.ceil(np.sqrt(n)))\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    \n    # Radii initialization\n    radii = np.full(n, 1.0 / (2 * grid_size))\n\n    def get_sum_radii(params):\n        # params: [x1, y1, ..., xn, yn, r1, ..., rn]\n        return -np.sum(params[2*n:])\n\n    def constraints(params):\n        centers = params[:2*n].reshape((n, 2))\n        radii = params[2*n:]\n        cons = []\n        \n        # Boundary constraints: center - radius >= 0 and center + radius <= 1\n        for i in range(n):\n            cons.append(centers[i, 0] - radii[i])\n            cons.append(1.0 - (centers[i, 0] + radii[i]))\n            cons.append(centers[i, 1] - radii[i])\n            cons.append(1.0 - (centers[i, 1] + radii[i]))\n            cons.append(radii[i]) # Radius must be non-negative\n            \n        # Non-overlapping constraints: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                cons.append(dist - (radii[i] + radii[j]))\n        return np.array(cons)\n\n    # Force-directed simulation with boundary attraction\n    # This helps position centers efficiently before the final optimization\n    dt = 0.01\n    for _ in range(150):\n        forces = np.zeros((n, 2))\n        # Inter-circle repulsion\n        for i in range(n):\n            for j in range(n):\n                if i == j: continue\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                if dist < (radii[i] + radii[j]) * 1.1:\n                    forces[i] += diff / (dist**2 + 1e-6)\n            \n            # Boundary attraction: Pull towards nearest edge\n            # This 'clears' the center as requested\n            dist_to_edges = np.array([centers[i, 0], 1.0 - centers[i, 0], \n                                     centers[i, 1], 1.0 - centers[i, 1]])\n            edge_idx = np.argmin(dist_to_edges)\n            if edge_idx == 0: forces[i] += np.array([-0.5, 0])\n            elif edge_idx == 1: forces[i] += np.array([0.5, 0])\n            elif edge_idx == 2: forces[i] += np.array([0, -0.5])\n            else: forces[i] += np.array([0, 0.5])\n            \n        centers += forces * dt\n        centers = np.clip(centers, 0.05, 0.95)\n        # Gradually grow radii\n        radii *= 1.01\n        radii = np.minimum(radii, 0.2)\n\n    # Final Constrained Optimization\n    initial_params = np.concatenate([centers.ravel(), radii])\n    \n    # Use SLSQP for constrained optimization\n    # We use a subset of constraints for speed or rely on the optimizer\n    # Given the time constraints, we define the bounds and a simple constraint set\n    bounds = []\n    for _ in range(n):\n        bounds.append((0, 1)) # x\n        bounds.append((0, 1)) # y\n    for _ in range(n):\n        bounds.append((0, 0.5)) # r\n\n    res = minimize(\n        get_sum_radii,\n        initial_params,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 100}\n    )\n\n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n    \n    # Final safety check to ensure all constraints are met (shrink slightly if needed)\n    # 1. Boundary\n    for i in range(n):\n        final_radii[i] = min(final_radii[i], final_centers[i, 0], 1.0 - final_centers[i, 0], \n                             final_centers[i, 1], 1.0 - final_centers[i, 1])\n    # 2. Overlap\n    for _ in range(5): # Iterative adjustment\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(final_centers[i] - final_centers[j])\n                if dist < (final_radii[i] + final_radii[j]):\n                    overlap = (final_radii[i] + final_radii[j]) - dist\n                    ratio = final_radii[i] / (final_radii[i] + final_radii[j] + 1e-9)\n                    final_radii[i] -= overlap * ratio * 1.001\n                    final_radii[j] -= overlap * (1 - ratio) * 1.001\n    \n    final_radii = np.maximum(final_radii, 0)\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5761872151686283,
    "eval_time": 2.2981209754943848,
    "error": null
  },
  "prompt": "Modify trial_4_5's force model.\n        1. Add a force that pulls circles towards the nearest boundary of the unit square.\n        2. This might help 'clear' the center of the square for more efficient packing.\n        3. Balance this with the inter-circle repulsion.\n        4. Run the growth and optimization phases as in 4_5.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square [0, 1]x[0, 1].\n    Uses a force-directed model with boundary attraction to maximize sum of radii.\n    \"\"\"\n    n = 26\n    # Initialize centers in a grid-like pattern with slight jitter\n    grid_size = int(np.ceil(np.sqrt(n)))\n    x = np.linspace(0.1, 0.9, grid_size)\n    y = np.linspace(0.1, 0.9, grid_size)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel()[:n], yv.ravel()[:n]], axis=1)\n    \n    # Radii initialization\n    radii = np.full(n, 1.0 / (2 * grid_size))\n\n    def get_sum_radii(params):\n        # params: [x1, y1, ..., xn, yn, r1, ..., rn]\n        return -np.sum(params[2*n:])\n\n    def constraints(params):\n        centers = params[:2*n].reshape((n, 2))\n        radii = params[2*n:]\n        cons = []\n        \n        # Boundary constraints: center - radius >= 0 and center + radius <= 1\n        for i in range(n):\n            cons.append(centers[i, 0] - radii[i])\n            cons.append(1.0 - (centers[i, 0] + radii[i]))\n            cons.append(centers[i, 1] - radii[i])\n            cons.append(1.0 - (centers[i, 1] + radii[i]))\n            cons.append(radii[i]) # Radius must be non-negative\n            \n        # Non-overlapping constraints: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                cons.append(dist - (radii[i] + radii[j]))\n        return np.array(cons)\n\n    # Force-directed simulation with boundary attraction\n    # This helps position centers efficiently before the final optimization\n    dt = 0.01\n    for _ in range(150):\n        forces = np.zeros((n, 2))\n        # Inter-circle repulsion\n        for i in range(n):\n            for j in range(n):\n                if i == j: continue\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                if dist < (radii[i] + radii[j]) * 1.1:\n                    forces[i] += diff / (dist**2 + 1e-6)\n            \n            # Boundary attraction: Pull towards nearest edge\n            # This 'clears' the center as requested\n            dist_to_edges = np.array([centers[i, 0], 1.0 - centers[i, 0], \n                                     centers[i, 1], 1.0 - centers[i, 1]])\n            edge_idx = np.argmin(dist_to_edges)\n            if edge_idx == 0: forces[i] += np.array([-0.5, 0])\n            elif edge_idx == 1: forces[i] += np.array([0.5, 0])\n            elif edge_idx == 2: forces[i] += np.array([0, -0.5])\n            else: forces[i] += np.array([0, 0.5])\n            \n        centers += forces * dt\n        centers = np.clip(centers, 0.05, 0.95)\n        # Gradually grow radii\n        radii *= 1.01\n        radii = np.minimum(radii, 0.2)\n\n    # Final Constrained Optimization\n    initial_params = np.concatenate([centers.ravel(), radii])\n    \n    # Use SLSQP for constrained optimization\n    # We use a subset of constraints for speed or rely on the optimizer\n    # Given the time constraints, we define the bounds and a simple constraint set\n    bounds = []\n    for _ in range(n):\n        bounds.append((0, 1)) # x\n        bounds.append((0, 1)) # y\n    for _ in range(n):\n        bounds.append((0, 0.5)) # r\n\n    res = minimize(\n        get_sum_radii,\n        initial_params,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 100}\n    )\n\n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n    \n    # Final safety check to ensure all constraints are met (shrink slightly if needed)\n    # 1. Boundary\n    for i in range(n):\n        final_radii[i] = min(final_radii[i], final_centers[i, 0], 1.0 - final_centers[i, 0], \n                             final_centers[i, 1], 1.0 - final_centers[i, 1])\n    # 2. Overlap\n    for _ in range(5): # Iterative adjustment\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(final_centers[i] - final_centers[j])\n                if dist < (final_radii[i] + final_radii[j]):\n                    overlap = (final_radii[i] + final_radii[j]) - dist\n                    ratio = final_radii[i] / (final_radii[i] + final_radii[j] + 1e-9)\n                    final_radii[i] -= overlap * ratio * 1.001\n                    final_radii[j] -= overlap * (1 - ratio) * 1.001\n    \n    final_radii = np.maximum(final_radii, 0)\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:32:05.058778",
  "cost_data": null
}