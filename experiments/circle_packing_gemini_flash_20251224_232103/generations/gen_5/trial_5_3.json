{
  "trial_id": "trial_5_3",
  "generation": 5,
  "parent_id": "trial_4_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles in a unit square using a \n    multi-start force-directed optimization approach to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Multi-start parameters\n    num_starts = 20\n    iterations = 150\n    \n    for seed in range(num_starts):\n        np.random.seed(seed)\n        \n        # 1. Initialization: Random uniform centers\n        centers = np.random.rand(n, 2) * 0.8 + 0.1\n        radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n        \n        # 2. Force-directed relaxation (Repulsion-Growth)\n        # We simulate a simple spring-like repulsion to resolve overlaps \n        # while keeping circles inside the unit square.\n        for _ in range(iterations):\n            # Calculate pairwise distances\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    if dist < min_dist:\n                        # Push circles apart\n                        push = (min_dist - dist + 1e-9) * 0.5\n                        direction = diff / (dist + 1e-9)\n                        centers[i] += direction * push\n                        centers[j] -= direction * push\n                \n                # Keep centers within [radius, 1-radius]\n                centers[i] = np.clip(centers[i], radii[i], 1.0 - radii[i])\n            \n            # Gradually grow radii to fill space\n            radii *= 1.005\n            \n        # 3. Final refinement using SLSQP to maximize sum(r) subject to constraints\n        def objective(params):\n            # params: [x1, y1, ..., xn, yn, r1, r2, ..., rn]\n            return -np.sum(params[2*n:])\n\n        def constraints(params):\n            c = params[:2*n].reshape((n, 2))\n            r = params[2*n:]\n            cons = []\n            # Non-overlap constraints\n            for i in range(n):\n                for j in range(i + 1, n):\n                    cons.append(np.linalg.norm(c[i] - c[j]) - (r[i] + r[j]))\n                # Boundary constraints\n                cons.append(c[i, 0] - r[i])\n                cons.append(1.0 - c[i, 0] - r[i])\n                cons.append(c[i, 1] - r[i])\n                cons.append(1.0 - c[i, 1] - r[i])\n            return np.array(cons)\n\n        initial_params = np.concatenate([centers.flatten(), radii])\n        \n        # Bounds for x, y in [0, 1] and r > 0\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        \n        res = minimize(\n            objective, \n            initial_params, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': constraints},\n            options={'maxiter': 50}\n        )\n        \n        if res.success or res.fun < -best_sum:\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = res.x[:2*n].reshape((n, 2))\n                best_radii = res.x[2*n:]\n\n    # Final validation and small safety margin to ensure strict constraint satisfaction\n    best_radii -= 1e-10 \n    best_sum = np.sum(best_radii)\n\n    return best_centers, best_radii, float(best_sum)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 37.696264028549194,
    "error": "Circle 1 has negative radius -1e-10"
  },
  "prompt": "Run the force-directed algorithm from trial_4_5 but with 20 different random initializations (random uniform centers).\n        1. For each start, run the repulsion-growth phases.\n        2. This explores whether the force-directed method can find even better basins than the one found in 4_5 (which was seeded from a grid).",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles in a unit square using a \n    multi-start force-directed optimization approach to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Multi-start parameters\n    num_starts = 20\n    iterations = 150\n    \n    for seed in range(num_starts):\n        np.random.seed(seed)\n        \n        # 1. Initialization: Random uniform centers\n        centers = np.random.rand(n, 2) * 0.8 + 0.1\n        radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n        \n        # 2. Force-directed relaxation (Repulsion-Growth)\n        # We simulate a simple spring-like repulsion to resolve overlaps \n        # while keeping circles inside the unit square.\n        for _ in range(iterations):\n            # Calculate pairwise distances\n            for i in range(n):\n                for j in range(i + 1, n):\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    if dist < min_dist:\n                        # Push circles apart\n                        push = (min_dist - dist + 1e-9) * 0.5\n                        direction = diff / (dist + 1e-9)\n                        centers[i] += direction * push\n                        centers[j] -= direction * push\n                \n                # Keep centers within [radius, 1-radius]\n                centers[i] = np.clip(centers[i], radii[i], 1.0 - radii[i])\n            \n            # Gradually grow radii to fill space\n            radii *= 1.005\n            \n        # 3. Final refinement using SLSQP to maximize sum(r) subject to constraints\n        def objective(params):\n            # params: [x1, y1, ..., xn, yn, r1, r2, ..., rn]\n            return -np.sum(params[2*n:])\n\n        def constraints(params):\n            c = params[:2*n].reshape((n, 2))\n            r = params[2*n:]\n            cons = []\n            # Non-overlap constraints\n            for i in range(n):\n                for j in range(i + 1, n):\n                    cons.append(np.linalg.norm(c[i] - c[j]) - (r[i] + r[j]))\n                # Boundary constraints\n                cons.append(c[i, 0] - r[i])\n                cons.append(1.0 - c[i, 0] - r[i])\n                cons.append(c[i, 1] - r[i])\n                cons.append(1.0 - c[i, 1] - r[i])\n            return np.array(cons)\n\n        initial_params = np.concatenate([centers.flatten(), radii])\n        \n        # Bounds for x, y in [0, 1] and r > 0\n        bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        \n        res = minimize(\n            objective, \n            initial_params, \n            method='SLSQP', \n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': constraints},\n            options={'maxiter': 50}\n        )\n        \n        if res.success or res.fun < -best_sum:\n            current_sum = -res.fun\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = res.x[:2*n].reshape((n, 2))\n                best_radii = res.x[2*n:]\n\n    # Final validation and small safety margin to ensure strict constraint satisfaction\n    best_radii -= 1e-10 \n    best_sum = np.sum(best_radii)\n\n    return best_centers, best_radii, float(best_sum)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:32:38.264679",
  "cost_data": null
}