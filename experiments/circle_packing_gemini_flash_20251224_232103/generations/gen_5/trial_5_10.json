{
  "trial_id": "trial_5_10",
  "generation": 5,
  "parent_id": "trial_4_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles in a unit square to maximize the sum of radii.\n    Uses a force-directed approach followed by SLSQP refinement.\n    \"\"\"\n    n_initial = 27\n    n_final = 26\n    \n    # 1. Initial State: Grid-like placement with small noise\n    side = int(np.ceil(np.sqrt(n_initial)))\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel(), yv.ravel()], axis=-1)[:n_initial]\n    radii = np.full(n_initial, 1.0 / (2 * side))\n\n    def force_directed_step(pts, r, iter_count=100):\n        dt = 0.01\n        for _ in range(iter_count):\n            forces = np.zeros_like(pts)\n            # Repulsion between circles\n            for i in range(len(pts)):\n                for j in range(i + 1, len(pts)):\n                    diff = pts[i] - pts[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = r[i] + r[j]\n                    if dist < min_dist:\n                        force = (diff / (dist + 1e-9)) * (min_dist - dist)\n                        forces[i] += force\n                        forces[j] -= force\n            \n            # Boundary constraints\n            for i in range(len(pts)):\n                for dim in range(2):\n                    if pts[i, dim] - r[i] < 0:\n                        forces[i, dim] += (r[i] - pts[i, dim])\n                    if pts[i, dim] + r[i] > 1:\n                        forces[i, dim] -= (pts[i, dim] + r[i] - 1)\n            \n            pts += forces * dt\n            # Increase radii slightly to fill space\n            r *= 1.001\n        return pts, r\n\n    # Run initial force-directed\n    centers, radii = force_directed_step(centers, radii, 200)\n\n    # 2. Remove the smallest circle\n    idx_to_keep = np.argsort(radii)[1:]\n    centers = centers[idx_to_keep]\n    radii = radii[idx_to_keep]\n\n    # 3. Refine with SLSQP\n    # Objective: Maximize sum of radii -> Minimize -sum(radii)\n    # Variables: [x1, y1, ..., x26, y26, r1, ..., r26]\n    initial_guess = np.concatenate([centers.flatten(), radii])\n\n    def objective(vars):\n        r = vars[2*n_final:]\n        return -np.sum(r)\n\n    def constraints(vars):\n        pts = vars[:2*n_final].reshape((n_final, 2))\n        r = vars[2*n_final:]\n        cons = []\n        # Non-overlap\n        for i in range(n_final):\n            for j in range(i + 1, n_final):\n                dist_sq = np.sum((pts[i] - pts[j])**2)\n                cons.append(dist_sq - (r[i] + r[j])**2)\n            # Boundary\n            cons.append(pts[i, 0] - r[i])         # x - r >= 0\n            cons.append(1.0 - (pts[i, 0] + r[i])) # 1 - (x + r) >= 0\n            cons.append(pts[i, 1] - r[i])         # y - r >= 0\n            cons.append(1.0 - (pts[i, 1] + r[i])) # 1 - (y + r) >= 0\n        return np.array(cons)\n\n    # Simplified bounds for stability\n    bounds = [(0, 1)] * (2 * n_final) + [(0, 0.5)] * n_final\n    \n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n\n    final_vars = res.x\n    final_centers = final_vars[:2*n_final].reshape((n_final, 2))\n    final_radii = final_vars[2*n_final:]\n    \n    # Final check and tiny shrink to ensure strict feasibility\n    final_radii -= 1e-9 \n    \n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6015459121614612,
    "eval_time": 1.0732581615447998,
    "error": null
  },
  "prompt": "Use the force-directed method to pack 27 circles.\n        1. Once converged, remove the circle that contributes the least to the total sum of radii.\n        2. Re-optimize the remaining 26 circles using the force-directed method and then SLSQP.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Pack 26 circles in a unit square to maximize the sum of radii.\n    Uses a force-directed approach followed by SLSQP refinement.\n    \"\"\"\n    n_initial = 27\n    n_final = 26\n    \n    # 1. Initial State: Grid-like placement with small noise\n    side = int(np.ceil(np.sqrt(n_initial)))\n    x = np.linspace(0.1, 0.9, side)\n    y = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.stack([xv.ravel(), yv.ravel()], axis=-1)[:n_initial]\n    radii = np.full(n_initial, 1.0 / (2 * side))\n\n    def force_directed_step(pts, r, iter_count=100):\n        dt = 0.01\n        for _ in range(iter_count):\n            forces = np.zeros_like(pts)\n            # Repulsion between circles\n            for i in range(len(pts)):\n                for j in range(i + 1, len(pts)):\n                    diff = pts[i] - pts[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = r[i] + r[j]\n                    if dist < min_dist:\n                        force = (diff / (dist + 1e-9)) * (min_dist - dist)\n                        forces[i] += force\n                        forces[j] -= force\n            \n            # Boundary constraints\n            for i in range(len(pts)):\n                for dim in range(2):\n                    if pts[i, dim] - r[i] < 0:\n                        forces[i, dim] += (r[i] - pts[i, dim])\n                    if pts[i, dim] + r[i] > 1:\n                        forces[i, dim] -= (pts[i, dim] + r[i] - 1)\n            \n            pts += forces * dt\n            # Increase radii slightly to fill space\n            r *= 1.001\n        return pts, r\n\n    # Run initial force-directed\n    centers, radii = force_directed_step(centers, radii, 200)\n\n    # 2. Remove the smallest circle\n    idx_to_keep = np.argsort(radii)[1:]\n    centers = centers[idx_to_keep]\n    radii = radii[idx_to_keep]\n\n    # 3. Refine with SLSQP\n    # Objective: Maximize sum of radii -> Minimize -sum(radii)\n    # Variables: [x1, y1, ..., x26, y26, r1, ..., r26]\n    initial_guess = np.concatenate([centers.flatten(), radii])\n\n    def objective(vars):\n        r = vars[2*n_final:]\n        return -np.sum(r)\n\n    def constraints(vars):\n        pts = vars[:2*n_final].reshape((n_final, 2))\n        r = vars[2*n_final:]\n        cons = []\n        # Non-overlap\n        for i in range(n_final):\n            for j in range(i + 1, n_final):\n                dist_sq = np.sum((pts[i] - pts[j])**2)\n                cons.append(dist_sq - (r[i] + r[j])**2)\n            # Boundary\n            cons.append(pts[i, 0] - r[i])         # x - r >= 0\n            cons.append(1.0 - (pts[i, 0] + r[i])) # 1 - (x + r) >= 0\n            cons.append(pts[i, 1] - r[i])         # y - r >= 0\n            cons.append(1.0 - (pts[i, 1] + r[i])) # 1 - (y + r) >= 0\n        return np.array(cons)\n\n    # Simplified bounds for stability\n    bounds = [(0, 1)] * (2 * n_final) + [(0, 0.5)] * n_final\n    \n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n\n    final_vars = res.x\n    final_centers = final_vars[:2*n_final].reshape((n_final, 2))\n    final_radii = final_vars[2*n_final:]\n    \n    # Final check and tiny shrink to ensure strict feasibility\n    final_radii -= 1e-9 \n    \n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:32:09.907893",
  "cost_data": null
}