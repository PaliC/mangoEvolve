{
  "trial_id": "trial_6_7",
  "generation": 6,
  "parent_id": "trial_4_5",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a force-directed optimization approach with varying exponents \n    to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    def solve_for_radii(centers):\n        \"\"\"\n        Given fixed centers, find the maximum possible radii for each circle\n        to satisfy boundary and non-overlap constraints.\n        \"\"\"\n        # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        # So r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n        max_r_bound = np.min(np.hstack([centers, 1 - centers]), axis=1)\n        \n        # Non-overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        # This is a Linear Programming problem, but we can approximate it \n        # or use a greedy approach for the radii.\n        # For a robust sum, we solve the LP: Maximize sum(r_i) s.t. r_i + r_j <= d_ij\n        from scipy.optimize import linprog\n        \n        c = -np.ones(n)\n        A_ub = []\n        b_ub = []\n        \n        # Pairwise distances\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Bounds for each r_i\n        bounds = [(0, b) for b in max_r_bound]\n        \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(n), 0.0\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Testing several exponents as requested\n    exponents = [1.5, 2.0, 3.0, 4.0]\n    seeds = [42, 123, 7, 99, 10]\n\n    for exp in exponents:\n        for seed in seeds:\n            np.random.seed(seed)\n            # Initial random placement\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n            \n            # Simple force-directed relaxation\n            # Repel from each other and from walls\n            for _ in range(50):\n                forces = np.zeros((n, 2))\n                for i in range(n):\n                    # Repulsion between circles\n                    for j in range(n):\n                        if i == j: continue\n                        diff = centers[i] - centers[j]\n                        dist = np.linalg.norm(diff) + 1e-9\n                        forces[i] += (diff / dist) / (dist ** exp)\n                    \n                    # Repulsion from walls\n                    forces[i, 0] += 1.0 / (centers[i, 0] ** exp)\n                    forces[i, 0] -= 1.0 / ((1 - centers[i, 0]) ** exp)\n                    forces[i, 1] += 1.0 / (centers[i, 1] ** exp)\n                    forces[i, 1] -= 1.0 / ((1 - centers[i, 1]) ** exp)\n                \n                # Limit step size\n                step = 0.01\n                centers += step * forces / (np.linalg.norm(forces, axis=1, keepdims=True) + 1e-9)\n                centers = np.clip(centers, 0.01, 0.99)\n\n            # Calculate radii and sum\n            radii, current_sum = solve_for_radii(centers)\n            \n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n\n    # Final tweak using local optimization to ensure constraints are strictly met\n    # and to push the sum slightly higher.\n    def objective(p):\n        c_flat = p.reshape((n, 2))\n        _, s = solve_for_radii(c_flat)\n        return -s\n\n    # Small refinement\n    res = minimize(objective, best_centers.flatten(), method='Nelder-Mead', options={'maxiter': 100})\n    final_centers = res.x.reshape((n, 2))\n    final_radii, final_sum = solve_for_radii(final_centers)\n\n    return final_centers, final_radii, final_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.401656357120745,
    "eval_time": 2.5662009716033936,
    "error": null
  },
  "prompt": "In the force-directed model of trial_4_5, the choice of the 1/d^2 law is arbitrary.\n        1. Run the same process but test exponents in the range [1.5, 4.0] (e.g., 1/d^1.5, 1/d^3, 1/d^4).\n        2. Higher exponents make the 'collisions' harder, while lower exponents allow for more long-range influence.\n        3. Perform 5 runs for each exponent and return the best overall result.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Uses a force-directed optimization approach with varying exponents \n    to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    def solve_for_radii(centers):\n        \"\"\"\n        Given fixed centers, find the maximum possible radii for each circle\n        to satisfy boundary and non-overlap constraints.\n        \"\"\"\n        # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        # So r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n        max_r_bound = np.min(np.hstack([centers, 1 - centers]), axis=1)\n        \n        # Non-overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        # This is a Linear Programming problem, but we can approximate it \n        # or use a greedy approach for the radii.\n        # For a robust sum, we solve the LP: Maximize sum(r_i) s.t. r_i + r_j <= d_ij\n        from scipy.optimize import linprog\n        \n        c = -np.ones(n)\n        A_ub = []\n        b_ub = []\n        \n        # Pairwise distances\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Bounds for each r_i\n        bounds = [(0, b) for b in max_r_bound]\n        \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(n), 0.0\n\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Testing several exponents as requested\n    exponents = [1.5, 2.0, 3.0, 4.0]\n    seeds = [42, 123, 7, 99, 10]\n\n    for exp in exponents:\n        for seed in seeds:\n            np.random.seed(seed)\n            # Initial random placement\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n            \n            # Simple force-directed relaxation\n            # Repel from each other and from walls\n            for _ in range(50):\n                forces = np.zeros((n, 2))\n                for i in range(n):\n                    # Repulsion between circles\n                    for j in range(n):\n                        if i == j: continue\n                        diff = centers[i] - centers[j]\n                        dist = np.linalg.norm(diff) + 1e-9\n                        forces[i] += (diff / dist) / (dist ** exp)\n                    \n                    # Repulsion from walls\n                    forces[i, 0] += 1.0 / (centers[i, 0] ** exp)\n                    forces[i, 0] -= 1.0 / ((1 - centers[i, 0]) ** exp)\n                    forces[i, 1] += 1.0 / (centers[i, 1] ** exp)\n                    forces[i, 1] -= 1.0 / ((1 - centers[i, 1]) ** exp)\n                \n                # Limit step size\n                step = 0.01\n                centers += step * forces / (np.linalg.norm(forces, axis=1, keepdims=True) + 1e-9)\n                centers = np.clip(centers, 0.01, 0.99)\n\n            # Calculate radii and sum\n            radii, current_sum = solve_for_radii(centers)\n            \n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n\n    # Final tweak using local optimization to ensure constraints are strictly met\n    # and to push the sum slightly higher.\n    def objective(p):\n        c_flat = p.reshape((n, 2))\n        _, s = solve_for_radii(c_flat)\n        return -s\n\n    # Small refinement\n    res = minimize(objective, best_centers.flatten(), method='Nelder-Mead', options={'maxiter': 100})\n    final_centers = res.x.reshape((n, 2))\n    final_radii, final_sum = solve_for_radii(final_centers)\n\n    return final_centers, final_radii, final_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:33:11.932406",
  "cost_data": null
}