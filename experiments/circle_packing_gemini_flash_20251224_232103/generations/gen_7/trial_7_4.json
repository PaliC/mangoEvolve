{
  "trial_id": "trial_7_4",
  "generation": 7,
  "parent_id": "trial_6_8",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles in a unit square using a \n    force-directed model with thermal jitter and a non-linear repulsion law.\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    def get_radii(centers):\n        \"\"\"Calculates maximum possible radii for given centers within [0,1]^2.\"\"\"\n        # Distance to boundaries\n        r_bound = np.min(np.concatenate([centers, 1 - centers]), axis=1)\n        \n        # Pairwise distances\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=2)\n        np.fill_diagonal(dist_sq, np.inf)\n        dist = np.sqrt(dist_sq)\n        \n        # Solve for radii: r_i + r_j <= d_ij\n        # This is a linear programming problem, but for force-directed \n        # we often use a simplified equal-radius or proportional heuristic.\n        # To maximize sum, we use a simple greedy/equal approach for the force phase\n        # and a more robust calculation for the final return.\n        \n        # Approximate radii for force calculation (uniform)\n        min_dist = np.min(dist)\n        min_bound = np.min(r_bound)\n        r_val = min(min_bound, min_dist / 2.0)\n        return np.full(n, r_val)\n\n    def solve_radii_linear(centers):\n        \"\"\"Linear programming to maximize sum of radii for fixed centers.\"\"\"\n        from scipy.optimize import linprog\n        # Maximize sum(r_i) subject to:\n        # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        # r_i + r_j <= dist(i, j)\n        \n        c = -np.ones(n)\n        bounds = []\n        for i in range(n):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            bounds.append((0, max_r))\n        \n        A = []\n        b = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A.append(row)\n                d = np.linalg.norm(centers[i] - centers[j])\n                b.append(d)\n        \n        res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n), 0\n\n    # Optimization Parameters\n    num_trials = 20\n    iterations = 600\n    exponent = 3.5\n    \n    for trial in range(num_trials):\n        # Initialize centers randomly\n        centers = np.random.rand(n, 2) * 0.8 + 0.1\n        sigma = 0.02\n        decay = (0.001 / 0.02)**(1.0 / iterations)\n        \n        learning_rate = 0.01\n        \n        for k in range(iterations):\n            # Repulsion forces\n            forces = np.zeros((n, 2))\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist_sq = np.sum(diff**2, axis=2)\n            np.fill_diagonal(dist_sq, 1.0) # avoid division by zero\n            dist = np.sqrt(dist_sq)\n            \n            # Repulsion model: force proportional to 1/dist^exponent\n            # Direction is diff / dist\n            mag = 1.0 / (dist**exponent)\n            np.fill_diagonal(mag, 0)\n            \n            force_dir = diff / dist[:, :, np.newaxis]\n            forces = np.sum(force_dir * mag[:, :, np.newaxis], axis=1)\n            \n            # Boundary repulsion\n            b_force = 1.0 / (centers**exponent) - 1.0 / ((1 - centers)**exponent)\n            forces += b_force\n            \n            # Apply movement\n            centers += learning_rate * forces\n            \n            # Thermal Jitter (Gaussian noise)\n            centers += np.random.normal(0, sigma, (n, 2))\n            \n            # Keep in bounds\n            centers = np.clip(centers, 1e-5, 1 - 1e-5)\n            \n            # Decay parameters\n            sigma *= decay\n            learning_rate *= 0.995\n\n        # Final refinement of centers for this trial\n        trial_radii, trial_sum = solve_radii_linear(centers)\n        \n        if trial_sum > best_sum:\n            best_sum = trial_sum\n            best_centers = centers.copy()\n            best_radii = trial_radii\n\n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": false,
    "score": 0.0,
    "eval_time": 0.22600197792053223,
    "error": "ValueError: Invalid input for linprog: b_ub must not contain values inf, nan, or None"
  },
  "prompt": "Combine the thermal jitter from trial_6_1 with the superior repulsion model of trial_6_8.\n        1. Use the force-directed model with an exponent of 3.5.\n        2. During the repulsion phase, apply a decaying Gaussian noise to the centers (sigma starts at 0.02, decays to 0.001).\n        3. Run 20 independent trials and return the best.\n        4. This combines global exploration with the most effective local force law.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles in a unit square using a \n    force-directed model with thermal jitter and a non-linear repulsion law.\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    def get_radii(centers):\n        \"\"\"Calculates maximum possible radii for given centers within [0,1]^2.\"\"\"\n        # Distance to boundaries\n        r_bound = np.min(np.concatenate([centers, 1 - centers]), axis=1)\n        \n        # Pairwise distances\n        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=2)\n        np.fill_diagonal(dist_sq, np.inf)\n        dist = np.sqrt(dist_sq)\n        \n        # Solve for radii: r_i + r_j <= d_ij\n        # This is a linear programming problem, but for force-directed \n        # we often use a simplified equal-radius or proportional heuristic.\n        # To maximize sum, we use a simple greedy/equal approach for the force phase\n        # and a more robust calculation for the final return.\n        \n        # Approximate radii for force calculation (uniform)\n        min_dist = np.min(dist)\n        min_bound = np.min(r_bound)\n        r_val = min(min_bound, min_dist / 2.0)\n        return np.full(n, r_val)\n\n    def solve_radii_linear(centers):\n        \"\"\"Linear programming to maximize sum of radii for fixed centers.\"\"\"\n        from scipy.optimize import linprog\n        # Maximize sum(r_i) subject to:\n        # r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n        # r_i + r_j <= dist(i, j)\n        \n        c = -np.ones(n)\n        bounds = []\n        for i in range(n):\n            max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n            bounds.append((0, max_r))\n        \n        A = []\n        b = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A.append(row)\n                d = np.linalg.norm(centers[i] - centers[j])\n                b.append(d)\n        \n        res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n), 0\n\n    # Optimization Parameters\n    num_trials = 20\n    iterations = 600\n    exponent = 3.5\n    \n    for trial in range(num_trials):\n        # Initialize centers randomly\n        centers = np.random.rand(n, 2) * 0.8 + 0.1\n        sigma = 0.02\n        decay = (0.001 / 0.02)**(1.0 / iterations)\n        \n        learning_rate = 0.01\n        \n        for k in range(iterations):\n            # Repulsion forces\n            forces = np.zeros((n, 2))\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist_sq = np.sum(diff**2, axis=2)\n            np.fill_diagonal(dist_sq, 1.0) # avoid division by zero\n            dist = np.sqrt(dist_sq)\n            \n            # Repulsion model: force proportional to 1/dist^exponent\n            # Direction is diff / dist\n            mag = 1.0 / (dist**exponent)\n            np.fill_diagonal(mag, 0)\n            \n            force_dir = diff / dist[:, :, np.newaxis]\n            forces = np.sum(force_dir * mag[:, :, np.newaxis], axis=1)\n            \n            # Boundary repulsion\n            b_force = 1.0 / (centers**exponent) - 1.0 / ((1 - centers)**exponent)\n            forces += b_force\n            \n            # Apply movement\n            centers += learning_rate * forces\n            \n            # Thermal Jitter (Gaussian noise)\n            centers += np.random.normal(0, sigma, (n, 2))\n            \n            # Keep in bounds\n            centers = np.clip(centers, 1e-5, 1 - 1e-5)\n            \n            # Decay parameters\n            sigma *= decay\n            learning_rate *= 0.995\n\n        # Final refinement of centers for this trial\n        trial_radii, trial_sum = solve_radii_linear(centers)\n        \n        if trial_sum > best_sum:\n            best_sum = trial_sum\n            best_centers = centers.copy()\n            best_radii = trial_radii\n\n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:34:05.103747",
  "cost_data": null
}