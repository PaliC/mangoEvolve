{
  "trial_id": "trial_4_2",
  "generation": 4,
  "parent_id": "trial_1_1",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    High-precision polish of 26 circles in a unit square.\n    Combines grid-based initialization with the 'trust-constr' optimizer\n    for high-precision convergence of the sum of radii.\n    \"\"\"\n    n = 26\n    \n    # Initialization: Use a 5x5 grid plus one extra circle\n    # This provides a stable starting topology for the polish\n    x = np.linspace(0.1, 0.9, 5)\n    y = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x, y)\n    grid_centers = np.vstack([xv.ravel(), yv.ravel()]).T\n    extra_center = np.array([[0.5, 0.5]])\n    initial_centers = np.vstack([grid_centers, extra_center])\n    \n    # Initial radii guess (conservative)\n    initial_radii = np.full(n, 0.08)\n    \n    # Optimization variables: [x1, y1, ..., x26, y26, r1, ..., r26]\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n\n    def objective(vars):\n        # Maximize sum(r) -> Minimize -sum(r)\n        return -np.sum(vars[2*n:])\n\n    def constraints_func(vars):\n        c = vars[:2*n].reshape((n, 2))\n        r = vars[2*n:]\n        cons = []\n        \n        # Boundary constraints: center +/- radius must be in [0, 1]\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])         # x - r >= 0\n            cons.append(1.0 - (c[i, 0] + r[i])) # 1 - x - r >= 0\n            cons.append(c[i, 1] - r[i])         # y - r >= 0\n            cons.append(1.0 - (c[i, 1] + r[i])) # 1 - y - r >= 0\n            \n        # Non-overlap constraints: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-18) # epsilon for stability\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    # Define bounds for all variables\n    # Centers in [0, 1], Radii in [0, 0.5]\n    bounds = [(0.0, 1.0)] * (2 * n) + [(1e-6, 0.5)] * n\n\n    # High-precision polish using trust-constr\n    # This method is robust for large sets of inequality constraints\n    res = minimize(\n        objective,\n        x0,\n        method='trust-constr',\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        bounds=bounds,\n        options={\n            'xtol': 1e-12,\n            'gtol': 1e-12,\n            'maxiter': 200,\n            'barrier_tol': 1e-12\n        }\n    )\n\n    final_vars = res.x\n    centers = final_vars[:2*n].reshape((n, 2))\n    radii = final_vars[2*n:]\n\n    # Post-optimization safety check: ensure strict feasibility\n    # Micro-shrinkage to handle floating point noise\n    safe_eps = 1e-13\n    for i in range(n):\n        # Boundary check\n        radii[i] = min(radii[i], centers[i, 0], 1.0 - centers[i, 0], \n                       centers[i, 1], 1.0 - centers[i, 1]) - safe_eps\n        # Overlap check\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                overlap = (radii[i] + radii[j] - dist)\n                radii[i] -= overlap / 2 + safe_eps\n                radii[j] -= overlap / 2 + safe_eps\n\n    radii = np.maximum(radii, 0)\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.5883376354855177,
    "eval_time": 3.9320240020751953,
    "error": null
  },
  "prompt": "Perform a high-precision polish on trial_1_1 and trial_3_6.\n        1. Load centers from {{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square [0,1]x[0,1]\n    aiming to maximize the sum of radii. Uses multiple grid starts and \n    shaking to improve upon local optima.\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_centers = None\n    best_radii = None\n\n    # Define candidate grid configurations (rows, cols)\n    # 5x5+1, 4x6+2, 6x4+2, 3x8+2\n    configs = [(5, 5), (4, 6), (6, 4), (3, 8)]\n\n    for rows, cols in configs:\n        # Create initial centers\n        x_coords = np.linspace(0.1, 0.9, cols)\n        y_coords = np.linspace(0.1, 0.9, rows)\n        centers = []\n        for y in y_coords:\n            for x in x_coords:\n                if len(centers) < n:\n                    centers.append([x, y])\n        \n        # Fill remaining if any\n        while len(centers) < n:\n            centers.append([np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)])\n        \n        centers = np.array(centers)\n        radii = np.full(n, 0.09) # Initial guess for radius\n        \n        params = np.concatenate([centers.flatten(), radii])\n\n        def objective(p):\n            r = p[2*n:]\n            return -np.sum(r)\n\n        def constraints(p):\n            c = p[:2*n].reshape((n, 2))\n            r = p[2*n:]\n            # Overlap constraints: dist - (ri+rj) >= 0\n            # To speed up, we use vectorized distance calculations\n            cons = []\n            # Boundary constraints\n            for i in range(n):\n                cons.append(c[i, 0] - r[i])\n                cons.append(1.0 - (c[i, 0] + r[i]))\n                cons.append(c[i, 1] - r[i])\n                cons.append(1.0 - (c[i, 1] + r[i]))\n            \n            # Non-overlap constraints\n            for i in range(n):\n                for j in range(i + 1, n):\n                    # Squared distance to avoid sqrt in inner loop\n                    dist_sq = np.sum((c[i] - c[j])**2)\n                    cons.append(dist_sq - (r[i] + r[j])**2)\n            return np.array(cons)\n\n        # Bounds: Centers [0,1], Radii [0, 0.5]\n        bounds = [(0, 1)] * (2 * n) + [(0.001, 0.5)] * n\n\n        # Solve\n        res = minimize(\n            objective,\n            params,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints},\n            bounds=bounds,\n            options={'maxiter': 60, 'ftol': 1e-6}\n        )\n\n        # Shaking step: Add small noise and re-optimize\n        if res.success or True:\n            shaken_params = res.x.copy()\n            shaken_params[:2*n] += np.random.normal(0, 0.01, 2*n)\n            res = minimize(\n                objective,\n                shaken_params,\n                method='SLSQP',\n                constraints={'type': 'ineq', 'fun': constraints},\n                bounds=bounds,\n                options={'maxiter': 60, 'ftol': 1e-7}\n            )\n\n        current_centers = res.x[:2*n].reshape((n, 2))\n        current_radii = res.x[2*n:]\n        current_sum = np.sum(current_radii)\n\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = current_centers\n            best_radii = current_radii\n\n    # Final post-processing to ensure feasibility\n    # Slightly shrink radii to guarantee no overlap due to precision\n    eps = 1e-10\n    final_radii = best_radii - eps\n    final_centers = best_centers\n    \n    # Ensure boundary compliance\n    for i in range(n):\n        final_centers[i] = np.clip(final_centers[i], final_radii[i], 1.0 - final_radii[i])\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}} and {{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Optimizes the sum of radii using a neighborhood-aware coordinate descent \n    followed by a global SLSQP refinement.\n    \"\"\"\n    n = 26\n    # Initialize with a grid-like structure to ensure good coverage\n    rows, cols = 5, 5\n    x = np.linspace(0.1, 0.9, 5)\n    y = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.vstack([xv.ravel(), yv.ravel()])\n    # Add the 26th circle at the center\n    centers = np.column_stack([centers, [0.5, 0.5]])\n    centers = centers.T # Shape (26, 2)\n    \n    # Initial radii guess\n    radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n\n    def get_max_radius(idx, current_centers):\n        \"\"\"Calculates the maximum possible radius for circle idx given others.\"\"\"\n        c_i = current_centers[idx]\n        # Distance to boundaries\n        r_bound = min(c_i[0], 1 - c_i[0], c_i[1], 1 - c_i[1])\n        # Distance to other circles\n        r_others = []\n        for j in range(len(current_centers)):\n            if i == j: continue\n            dist = np.linalg.norm(current_centers[idx] - current_centers[j])\n            # This is a simplification for the coordinate descent phase\n            r_others.append(dist / 2.0)\n        return max(0, min(r_bound, min(r_others)))\n\n    # 1. Neighborhood-aware Coordinate Descent\n    # We iteratively adjust centers to allow for more 'breathing room'\n    for _ in range(30):\n        for i in range(n):\n            # Sample local perturbations to find a better center for circle i\n            best_pos = centers[i].copy()\n            best_local_sum = 0\n            \n            # Look at neighbors to consider \"sum of radii\"\n            neighbors_idx = np.argsort(np.linalg.norm(centers - centers[i], axis=1))[1:4]\n            \n            for _sample in range(10):\n                # Random walk\n                move = np.random.normal(0, 0.02, size=2)\n                test_pos = np.clip(centers[i] + move, 0.01, 0.99)\n                \n                temp_centers = centers.copy()\n                temp_centers[i] = test_pos\n                \n                # Calculate local sum (self + 3 neighbors)\n                local_sum = 0\n                for idx in np.append(neighbors_idx, i):\n                    # Calculate max radius for circle idx in temp_centers\n                    c = temp_centers[idx]\n                    d_bound = min(c[0], 1-c[0], c[1], 1-c[1])\n                    d_circles = []\n                    for k in range(n):\n                        if k == idx: continue\n                        d_circles.append(np.linalg.norm(c - temp_centers[k]) / 2.0)\n                    local_sum += max(0, min(d_bound, min(d_circles)))\n                \n                if local_sum > best_local_sum:\n                    best_local_sum = local_sum\n                    best_pos = test_pos\n            centers[i] = best_pos\n\n    # 2. Global SLSQP Optimization\n    # Objective: Maximize sum of radii -> Minimize -sum(radii)\n    # Variables: [x1, y1, ..., x26, y26, r1, ..., r26]\n    initial_guess = np.concatenate([centers.flatten(), radii])\n\n    def objective(vars):\n        return -np.sum(vars[2*n:])\n\n    def constraints(vars):\n        c = vars[:2*n].reshape((n, 2))\n        r = vars[2*n:]\n        cons = []\n        # Boundary constraints\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])         # x - r >= 0\n            cons.append(1.0 - (c[i, 0] + r[i])) # 1 - (x + r) >= 0\n            cons.append(c[i, 1] - r[i])         # y - r >= 0\n            cons.append(1.0 - (c[i, 1] + r[i])) # 1 - (y + r) >= 0\n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    # Use a faster subset of constraints or trust bounds for efficiency\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n\n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    \n    # Final verification/clipping to ensure hard constraints\n    # Slightly shrink radii if constraints are violated due to precision\n    for i in range(n):\n        final_radii[i] = min(final_radii[i], final_centers[i,0], 1-final_centers[i,0], \n                             final_centers[i,1], 1-final_centers[i,1])\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_centers[i] - final_centers[j])\n            if final_radii[i] + final_radii[j] > dist:\n                # Proportional reduction\n                reduction = (final_radii[i] + final_radii[j] - dist) / 2.0\n                final_radii[i] -= reduction + 1e-9\n                final_radii[j] -= reduction + 1e-9\n    \n    final_radii = np.maximum(final_radii, 0)\n    \n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}.\n        2. Use scipy.optimize.minimize with method='trust-constr'. \n        3. This method often handles complex constraints better than SLSQP for final-stage convergence.\n        4. Set xtol and gtol to 1e-12.\n        5. Maximize the sum of radii while strictly enforcing the non-overlap and boundary constraints.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    High-precision polish of 26 circles in a unit square.\n    Combines grid-based initialization with the 'trust-constr' optimizer\n    for high-precision convergence of the sum of radii.\n    \"\"\"\n    n = 26\n    \n    # Initialization: Use a 5x5 grid plus one extra circle\n    # This provides a stable starting topology for the polish\n    x = np.linspace(0.1, 0.9, 5)\n    y = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x, y)\n    grid_centers = np.vstack([xv.ravel(), yv.ravel()]).T\n    extra_center = np.array([[0.5, 0.5]])\n    initial_centers = np.vstack([grid_centers, extra_center])\n    \n    # Initial radii guess (conservative)\n    initial_radii = np.full(n, 0.08)\n    \n    # Optimization variables: [x1, y1, ..., x26, y26, r1, ..., r26]\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n\n    def objective(vars):\n        # Maximize sum(r) -> Minimize -sum(r)\n        return -np.sum(vars[2*n:])\n\n    def constraints_func(vars):\n        c = vars[:2*n].reshape((n, 2))\n        r = vars[2*n:]\n        cons = []\n        \n        # Boundary constraints: center +/- radius must be in [0, 1]\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])         # x - r >= 0\n            cons.append(1.0 - (c[i, 0] + r[i])) # 1 - x - r >= 0\n            cons.append(c[i, 1] - r[i])         # y - r >= 0\n            cons.append(1.0 - (c[i, 1] + r[i])) # 1 - y - r >= 0\n            \n        # Non-overlap constraints: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((c[i] - c[j])**2) + 1e-18) # epsilon for stability\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    # Define bounds for all variables\n    # Centers in [0, 1], Radii in [0, 0.5]\n    bounds = [(0.0, 1.0)] * (2 * n) + [(1e-6, 0.5)] * n\n\n    # High-precision polish using trust-constr\n    # This method is robust for large sets of inequality constraints\n    res = minimize(\n        objective,\n        x0,\n        method='trust-constr',\n        constraints={'type': 'ineq', 'fun': constraints_func},\n        bounds=bounds,\n        options={\n            'xtol': 1e-12,\n            'gtol': 1e-12,\n            'maxiter': 200,\n            'barrier_tol': 1e-12\n        }\n    )\n\n    final_vars = res.x\n    centers = final_vars[:2*n].reshape((n, 2))\n    radii = final_vars[2*n:]\n\n    # Post-optimization safety check: ensure strict feasibility\n    # Micro-shrinkage to handle floating point noise\n    safe_eps = 1e-13\n    for i in range(n):\n        # Boundary check\n        radii[i] = min(radii[i], centers[i, 0], 1.0 - centers[i, 0], \n                       centers[i, 1], 1.0 - centers[i, 1]) - safe_eps\n        # Overlap check\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                overlap = (radii[i] + radii[j] - dist)\n                radii[i] -= overlap / 2 + safe_eps\n                radii[j] -= overlap / 2 + safe_eps\n\n    radii = np.maximum(radii, 0)\n    return centers, radii, np.sum(radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:26:30.192440",
  "cost_data": null
}