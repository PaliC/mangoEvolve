{
  "trial_id": "trial_1_4",
  "generation": 1,
  "parent_id": "trial_0_3",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles using a hybrid approach:\n    1. Iterative growth-and-repulsion with simulated annealing of forces.\n    2. Final refinement using SLSQP optimization to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    def solve_instance(seed):\n        np.random.seed(seed)\n        # Initial positions: Mix of grid and random to break symmetry\n        # Grid 5x5 + 1\n        x = np.linspace(0.1, 0.9, 5)\n        y = np.linspace(0.1, 0.9, 5)\n        xv, yv = np.meshgrid(x, y)\n        centers = np.vstack([xv.ravel(), yv.ravel()]).T\n        centers = np.vstack([centers, [0.5, 0.5]])\n        # Add jitter\n        centers += np.random.uniform(-0.02, 0.02, centers.shape)\n        \n        radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n        \n        # 1. Growth-and-Repulsion Phase\n        iterations = 60\n        for i in range(iterations):\n            # Simulated annealing factor for repulsion strength\n            temp = 1.0 - (i / iterations)\n            \n            for _ in range(10):  # Relaxation steps\n                for i_c in range(n):\n                    # Boundary constraints\n                    centers[i_c, 0] = np.clip(centers[i_c, 0], radii[i_c], 1.0 - radii[i_c])\n                    centers[i_c, 1] = np.clip(centers[i_c, 1], radii[i_c], 1.0 - radii[i_c])\n                    \n                    # Inter-circle repulsion\n                    for j_c in range(n):\n                        if i_c == j_c: continue\n                        diff = centers[i_c] - centers[j_c]\n                        dist = np.linalg.norm(diff)\n                        min_dist = radii[i_c] + radii[j_c]\n                        if dist < min_dist:\n                            overlap = min_dist - dist\n                            push = (diff / (dist + 1e-9)) * overlap * 0.5 * (0.5 + temp)\n                            centers[i_c] += push\n                            centers[j_c] -= push\n            \n            # Growth step\n            for i_c in range(n):\n                dist_to_bound = min(centers[i_c, 0], 1 - centers[i_c, 0], \n                                    centers[i_c, 1], 1 - centers[i_c, 1])\n                dist_to_circle = 1e9\n                for j_c in range(n):\n                    if i_c == j_c: continue\n                    d = np.linalg.norm(centers[i_c] - centers[j_c]) - radii[j_c]\n                    if d < dist_to_circle:\n                        dist_to_circle = d\n                \n                target_r = max(0, min(dist_to_bound, dist_to_circle))\n                radii[i_c] += (target_r - radii[i_c]) * 0.1\n\n        # 2. Refinement Phase using SLSQP\n        # Variables: [x0, y0, ..., x25, y25, r0, ..., r25]\n        initial_guess = np.concatenate([centers.flatten(), radii])\n        \n        def objective(vars):\n            return -np.sum(vars[2*n:])\n        \n        def constraints(vars):\n            pts = vars[:2*n].reshape((n, 2))\n            rads = vars[2*n:]\n            cons = []\n            # Non-overlap\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist_sq = np.sum((pts[i] - pts[j])**2)\n                    cons.append(dist_sq - (rads[i] + rads[j])**2)\n                # Boundary\n                cons.append(pts[i, 0] - rads[i])\n                cons.append(1.0 - pts[i, 0] - rads[i])\n                cons.append(pts[i, 1] - rads[i])\n                cons.append(1.0 - pts[i, 1] - rads[i])\n            return np.array(cons)\n\n        # Bounds for x, y, r\n        bnds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        \n        res = minimize(objective, initial_guess, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       bounds=bnds, options={'maxiter': 50, 'ftol': 1e-6})\n        \n        final_vars = res.x\n        res_centers = final_vars[:2*n].reshape((n, 2))\n        res_radii = final_vars[2*n:]\n        \n        # Ensure strict feasibility\n        eps = 1e-10\n        for i in range(n):\n            res_radii[i] = min(res_radii[i], res_centers[i, 0], 1 - res_centers[i, 0],\n                               res_centers[i, 1], 1 - res_centers[i, 1])\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(res_centers[i] - res_centers[j])\n                if dist < res_radii[i] + res_radii[j]:\n                    # Adjust the larger radius to fix overlap\n                    if res_radii[i] > res_radii[j]:\n                        res_radii[i] = max(0, dist - res_radii[j] - eps)\n                    else:\n                        res_radii[j] = max(0, dist - res_radii[i] - eps)\n        \n        return res_centers, res_radii, np.sum(res_radii)\n\n    # Run a few trials and pick the best\n    best_sum = -1\n    best_c, best_r = None, None\n    for s in range(3):\n        c, r, s_val = solve_instance(s + 42)\n        if s_val > best_sum:\n            best_sum = s_val\n            best_c, best_r = c, r\n            \n    return best_c, best_r, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.625967118727624,
    "eval_time": 3.664159059524536,
    "error": null
  },
  "prompt": "Enhance the growth-and-repulsion algorithm from trial_0_3.\n        Current code: {{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles using an iterative \n    growth and relaxation strategy to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    # Initial positions: 5x5 grid plus one centered\n    x = np.linspace(0.1, 0.9, 5)\n    y = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.vstack([xv.ravel(), yv.ravel()])\n    # Add the 26th circle near the center\n    centers = np.column_stack([centers, [0.5, 0.5]])\n    centers = centers.T # Shape (26, 2)\n    \n    # Initialize radii\n    radii = np.full(n, 0.05)\n    \n    # Optimization parameters\n    iterations = 100\n    learning_rate = 0.1\n    \n    for _ in range(iterations):\n        # 1. Resolve Overlaps and Boundary Constraints\n        for __ in range(20): # Inner relaxation steps\n            for i in range(n):\n                # Boundary constraints\n                centers[i, 0] = np.clip(centers[i, 0], radii[i], 1.0 - radii[i])\n                centers[i, 1] = np.clip(centers[i, 1], radii[i], 1.0 - radii[i])\n                \n                # Inter-circle repulsion\n                for j in range(n):\n                    if i == j: continue\n                    diff = centers[i] - centers[j]\n                    dist = np.linalg.norm(diff)\n                    min_dist = radii[i] + radii[j]\n                    if dist < min_dist:\n                        # Push circles apart\n                        overlap = min_dist - dist\n                        push = (diff / (dist + 1e-9)) * overlap * 0.5\n                        centers[i] += push\n                        centers[j] -= push\n        \n        # 2. Greedy growth: Increase radii of circles that have space\n        for i in range(n):\n            # Distance to nearest boundary\n            dist_to_bound = min(centers[i, 0], 1 - centers[i, 0], \n                                centers[i, 1], 1 - centers[i, 1])\n            # Distance to nearest circle\n            dist_to_circle = float('inf')\n            for j in range(n):\n                if i == j: continue\n                d = np.linalg.norm(centers[i] - centers[j]) - radii[j]\n                if d < dist_to_circle:\n                    dist_to_circle = d\n            \n            # Target radius is the max possible without moving\n            target_r = max(0, min(dist_to_bound, dist_to_circle))\n            radii[i] += (target_r - radii[i]) * learning_rate\n\n    # Final Adjustment: Ensure strict feasibility\n    # Small buffer to prevent floating point errors in constraints\n    epsilon = 1e-9\n    for i in range(n):\n        centers[i, 0] = np.clip(centers[i, 0], radii[i] + epsilon, 1.0 - radii[i] - epsilon)\n        centers[i, 1] = np.clip(centers[i, 1], radii[i] + epsilon, 1.0 - radii[i] - epsilon)\n        \n    # Scale radii slightly down if any overlap remains\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < radii[i] + radii[j]:\n                shrink_factor = dist / (radii[i] + radii[j] + epsilon)\n                radii[i] *= shrink_factor\n                radii[j] *= shrink_factor\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}\n        Improvements:\n        1. Implement a 'simulated annealing' schedule for the repulsion force.\n        2. After the repulsion phase, add a final step using scipy.optimize.minimize (SLSQP) to push the sum of radii to its local limit.\n        3. Run the process multiple times and keep the best result.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 circles using a hybrid approach:\n    1. Iterative growth-and-repulsion with simulated annealing of forces.\n    2. Final refinement using SLSQP optimization to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    \n    def solve_instance(seed):\n        np.random.seed(seed)\n        # Initial positions: Mix of grid and random to break symmetry\n        # Grid 5x5 + 1\n        x = np.linspace(0.1, 0.9, 5)\n        y = np.linspace(0.1, 0.9, 5)\n        xv, yv = np.meshgrid(x, y)\n        centers = np.vstack([xv.ravel(), yv.ravel()]).T\n        centers = np.vstack([centers, [0.5, 0.5]])\n        # Add jitter\n        centers += np.random.uniform(-0.02, 0.02, centers.shape)\n        \n        radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n        \n        # 1. Growth-and-Repulsion Phase\n        iterations = 60\n        for i in range(iterations):\n            # Simulated annealing factor for repulsion strength\n            temp = 1.0 - (i / iterations)\n            \n            for _ in range(10):  # Relaxation steps\n                for i_c in range(n):\n                    # Boundary constraints\n                    centers[i_c, 0] = np.clip(centers[i_c, 0], radii[i_c], 1.0 - radii[i_c])\n                    centers[i_c, 1] = np.clip(centers[i_c, 1], radii[i_c], 1.0 - radii[i_c])\n                    \n                    # Inter-circle repulsion\n                    for j_c in range(n):\n                        if i_c == j_c: continue\n                        diff = centers[i_c] - centers[j_c]\n                        dist = np.linalg.norm(diff)\n                        min_dist = radii[i_c] + radii[j_c]\n                        if dist < min_dist:\n                            overlap = min_dist - dist\n                            push = (diff / (dist + 1e-9)) * overlap * 0.5 * (0.5 + temp)\n                            centers[i_c] += push\n                            centers[j_c] -= push\n            \n            # Growth step\n            for i_c in range(n):\n                dist_to_bound = min(centers[i_c, 0], 1 - centers[i_c, 0], \n                                    centers[i_c, 1], 1 - centers[i_c, 1])\n                dist_to_circle = 1e9\n                for j_c in range(n):\n                    if i_c == j_c: continue\n                    d = np.linalg.norm(centers[i_c] - centers[j_c]) - radii[j_c]\n                    if d < dist_to_circle:\n                        dist_to_circle = d\n                \n                target_r = max(0, min(dist_to_bound, dist_to_circle))\n                radii[i_c] += (target_r - radii[i_c]) * 0.1\n\n        # 2. Refinement Phase using SLSQP\n        # Variables: [x0, y0, ..., x25, y25, r0, ..., r25]\n        initial_guess = np.concatenate([centers.flatten(), radii])\n        \n        def objective(vars):\n            return -np.sum(vars[2*n:])\n        \n        def constraints(vars):\n            pts = vars[:2*n].reshape((n, 2))\n            rads = vars[2*n:]\n            cons = []\n            # Non-overlap\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist_sq = np.sum((pts[i] - pts[j])**2)\n                    cons.append(dist_sq - (rads[i] + rads[j])**2)\n                # Boundary\n                cons.append(pts[i, 0] - rads[i])\n                cons.append(1.0 - pts[i, 0] - rads[i])\n                cons.append(pts[i, 1] - rads[i])\n                cons.append(1.0 - pts[i, 1] - rads[i])\n            return np.array(cons)\n\n        # Bounds for x, y, r\n        bnds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n        \n        res = minimize(objective, initial_guess, method='SLSQP', \n                       constraints={'type': 'ineq', 'fun': constraints},\n                       bounds=bnds, options={'maxiter': 50, 'ftol': 1e-6})\n        \n        final_vars = res.x\n        res_centers = final_vars[:2*n].reshape((n, 2))\n        res_radii = final_vars[2*n:]\n        \n        # Ensure strict feasibility\n        eps = 1e-10\n        for i in range(n):\n            res_radii[i] = min(res_radii[i], res_centers[i, 0], 1 - res_centers[i, 0],\n                               res_centers[i, 1], 1 - res_centers[i, 1])\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(res_centers[i] - res_centers[j])\n                if dist < res_radii[i] + res_radii[j]:\n                    # Adjust the larger radius to fix overlap\n                    if res_radii[i] > res_radii[j]:\n                        res_radii[i] = max(0, dist - res_radii[j] - eps)\n                    else:\n                        res_radii[j] = max(0, dist - res_radii[i] - eps)\n        \n        return res_centers, res_radii, np.sum(res_radii)\n\n    # Run a few trials and pick the best\n    best_sum = -1\n    best_c, best_r = None, None\n    for s in range(3):\n        c, r, s_val = solve_instance(s + 42)\n        if s_val > best_sum:\n            best_sum = s_val\n            best_c, best_r = c, r\n            \n    return best_c, best_r, best_sum\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:24:31.232009",
  "cost_data": null
}