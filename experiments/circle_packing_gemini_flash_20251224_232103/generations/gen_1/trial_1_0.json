{
  "trial_id": "trial_1_0",
  "generation": 1,
  "parent_id": "trial_0_12",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Optimizes a packing of 26 circles in a unit square to maximize sum of radii.\n    Uses a multi-start strategy with an improved initial layout and SLSQP optimization.\n    \"\"\"\n    n = 26\n    \n    def get_initial_guess(seed):\n        np.random.seed(seed)\n        # Strategy: Place 16 circles in a grid-like boundary, 10 in the interior\n        # This helps the optimizer find the 'boundary-filling' structure.\n        centers = []\n        # Boundary layer (approx 16 circles)\n        for i in np.linspace(0.1, 0.9, 5):\n            centers.append([i, 0.1])\n            centers.append([i, 0.9])\n        for j in np.linspace(0.3, 0.7, 3):\n            centers.append([0.1, j])\n            centers.append([0.9, j])\n            \n        # Fill the rest randomly in the interior\n        while len(centers) < n:\n            centers.append(np.random.uniform(0.2, 0.8, 2))\n            \n        centers = np.array(centers[:n])\n        radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n        return np.concatenate([centers.ravel(), radii])\n\n    def objective(params):\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        # We use a flat list for constraints\n        # Boundary: 4 constraints per circle\n        # Overlap: n*(n-1)/2 constraints\n        # Radii: n constraints\n        \n        # Pre-calculating for speed\n        res = []\n        # Boundary\n        res.append(c[:, 0] - r)\n        res.append(1.0 - (c[:, 0] + r))\n        res.append(c[:, 1] - r)\n        res.append(1.0 - (c[:, 1] + r))\n        res.append(r)\n        \n        # Overlap\n        for i in range(n):\n            # Vectorized distance check for circle i against all j > i\n            dx = c[i, 0] - c[i+1:, 0]\n            dy = c[i, 1] - c[i+1:, 1]\n            dist_sq = dx**2 + dy**2\n            min_dist_sq = (r[i] + r[i+1:])**2\n            res.append(dist_sq - min_dist_sq)\n            \n        return np.concatenate([arr.ravel() for arr in res])\n\n    best_sum = 0\n    best_params = None\n\n    # Multi-start to escape local optima\n    # Given time limits, we use 3 targeted starts\n    for seed in [42, 123, 999]:\n        initial_params = get_initial_guess(seed)\n        \n        res = minimize(\n            objective,\n            initial_params,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints},\n            options={'maxiter': 50, 'disp': False}\n        )\n        \n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_params = res.x\n\n    # Final Polish on the best result\n    res = minimize(\n        objective,\n        best_params,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 100, 'disp': False}\n    )\n    \n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n    \n    # Post-processing: Strict feasibility enforcement\n    # 1. Boundary\n    for i in range(n):\n        final_radii[i] = max(0, min(final_radii[i], \n                                    final_centers[i, 0], 1 - final_centers[i, 0],\n                                    final_centers[i, 1], 1 - final_centers[i, 1]))\n    \n    # 2. Overlap (Iterative shrinkage)\n    for _ in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(final_centers[i] - final_centers[j])\n                if d < (final_radii[i] + final_radii[j]):\n                    # Shrink both slightly more than needed for float safety\n                    shrinkage = d / (final_radii[i] + final_radii[j] + 1e-12)\n                    final_radii[i] *= (shrinkage - 1e-10)\n                    final_radii[j] *= (shrinkage - 1e-10)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6181556393377656,
    "eval_time": 0.5994529724121094,
    "error": null
  },
  "prompt": "Improve the boundary-filling strategy from trial_0_12. \n        Current code: {{import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square maximizing the sum of radii.\n    Uses a layered layout + constrained optimization.\n    \"\"\"\n    n = 26\n    \n    # Initial Guess: Distribute circles in a grid-like fashion with slight jitter\n    # to allow the optimizer to find better local optima than a perfect grid.\n    rows = 5\n    cols = 5\n    # 25 circles in 5x5, then 1 extra\n    x = np.linspace(0.1, 0.9, cols)\n    y = np.linspace(0.1, 0.9, rows)\n    xv, yv = np.meshgrid(x, y)\n    \n    centers = np.vstack([xv.ravel(), yv.ravel()])\n    # Add the 26th circle near the center\n    centers = np.column_stack([centers, [0.5, 0.5]])\n    \n    # Initial radii guess\n    radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n    \n    # Flatten for optimizer: [x1, y1, ..., xn, yn, r1, ..., rn]\n    initial_params = np.concatenate([centers.ravel(), radii])\n    \n    def objective(params):\n        # We want to maximize sum(radii), so minimize -sum(radii)\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        cons = []\n        \n        # Boundary constraints: center_i - r_i >= 0 and center_i + r_i <= 1\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])          # x - r >= 0\n            cons.append(1.0 - (c[i, 0] + r[i]))  # x + r <= 1\n            cons.append(c[i, 1] - r[i])          # y - r >= 0\n            cons.append(1.0 - (c[i, 1] + r[i]))  # y + r <= 1\n            cons.append(r[i])                    # r >= 0\n            \n        # Non-overlap constraints: dist(ci, cj) >= ri + rj\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_sq = np.sum((c[i] - c[j])**2)\n                cons.append(dist_sq - (r[i] + r[j])**2)\n        \n        return np.array(cons)\n\n    # Use SLSQP for constrained optimization\n    # Note: For n=26, a full global optimization is heavy, \n    # so we perform a few iterations of a local optimizer.\n    res = minimize(\n        objective, \n        initial_params, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 100, 'disp': False}\n    )\n    \n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n    \n    # Final check to ensure validity (shrink slightly if precision issues occur)\n    # This ensures the evaluator accepts the solution.\n    for i in range(n):\n        final_radii[i] = max(0, min(final_radii[i], \n                                    final_centers[i, 0], 1 - final_centers[i, 0],\n                                    final_centers[i, 1], 1 - final_centers[i, 1]))\n    \n    # Pairwise overlap check and correction\n    for _ in range(5):\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(final_centers[i] - final_centers[j])\n                if d < final_radii[i] + final_radii[j]:\n                    scale = d / (final_radii[i] + final_radii[j])\n                    final_radii[i] *= (scale - 1e-9)\n                    final_radii[j] *= (scale - 1e-9)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()}}\n        Improvements:\n        1. Increase the number of random initializations (multi-start) for the boundary layer.\n        2. Use a more robust local optimizer like 'trust-constr' or multiple passes of 'SLSQP' with small perturbations.\n        3. Ensure the central core packing is dynamically adjusted based on the space left by the boundary circles.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Optimizes a packing of 26 circles in a unit square to maximize sum of radii.\n    Uses a multi-start strategy with an improved initial layout and SLSQP optimization.\n    \"\"\"\n    n = 26\n    \n    def get_initial_guess(seed):\n        np.random.seed(seed)\n        # Strategy: Place 16 circles in a grid-like boundary, 10 in the interior\n        # This helps the optimizer find the 'boundary-filling' structure.\n        centers = []\n        # Boundary layer (approx 16 circles)\n        for i in np.linspace(0.1, 0.9, 5):\n            centers.append([i, 0.1])\n            centers.append([i, 0.9])\n        for j in np.linspace(0.3, 0.7, 3):\n            centers.append([0.1, j])\n            centers.append([0.9, j])\n            \n        # Fill the rest randomly in the interior\n        while len(centers) < n:\n            centers.append(np.random.uniform(0.2, 0.8, 2))\n            \n        centers = np.array(centers[:n])\n        radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n        return np.concatenate([centers.ravel(), radii])\n\n    def objective(params):\n        r = params[2*n:]\n        return -np.sum(r)\n\n    def constraints(params):\n        c = params[:2*n].reshape((n, 2))\n        r = params[2*n:]\n        \n        # We use a flat list for constraints\n        # Boundary: 4 constraints per circle\n        # Overlap: n*(n-1)/2 constraints\n        # Radii: n constraints\n        \n        # Pre-calculating for speed\n        res = []\n        # Boundary\n        res.append(c[:, 0] - r)\n        res.append(1.0 - (c[:, 0] + r))\n        res.append(c[:, 1] - r)\n        res.append(1.0 - (c[:, 1] + r))\n        res.append(r)\n        \n        # Overlap\n        for i in range(n):\n            # Vectorized distance check for circle i against all j > i\n            dx = c[i, 0] - c[i+1:, 0]\n            dy = c[i, 1] - c[i+1:, 1]\n            dist_sq = dx**2 + dy**2\n            min_dist_sq = (r[i] + r[i+1:])**2\n            res.append(dist_sq - min_dist_sq)\n            \n        return np.concatenate([arr.ravel() for arr in res])\n\n    best_sum = 0\n    best_params = None\n\n    # Multi-start to escape local optima\n    # Given time limits, we use 3 targeted starts\n    for seed in [42, 123, 999]:\n        initial_params = get_initial_guess(seed)\n        \n        res = minimize(\n            objective,\n            initial_params,\n            method='SLSQP',\n            constraints={'type': 'ineq', 'fun': constraints},\n            options={'maxiter': 50, 'disp': False}\n        )\n        \n        current_sum = -res.fun\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_params = res.x\n\n    # Final Polish on the best result\n    res = minimize(\n        objective,\n        best_params,\n        method='SLSQP',\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'maxiter': 100, 'disp': False}\n    )\n    \n    final_params = res.x\n    final_centers = final_params[:2*n].reshape((n, 2))\n    final_radii = final_params[2*n:]\n    \n    # Post-processing: Strict feasibility enforcement\n    # 1. Boundary\n    for i in range(n):\n        final_radii[i] = max(0, min(final_radii[i], \n                                    final_centers[i, 0], 1 - final_centers[i, 0],\n                                    final_centers[i, 1], 1 - final_centers[i, 1]))\n    \n    # 2. Overlap (Iterative shrinkage)\n    for _ in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(final_centers[i] - final_centers[j])\n                if d < (final_radii[i] + final_radii[j]):\n                    # Shrink both slightly more than needed for float safety\n                    shrinkage = d / (final_radii[i] + final_radii[j] + 1e-12)\n                    final_radii[i] *= (shrinkage - 1e-10)\n                    final_radii[j] *= (shrinkage - 1e-10)\n\n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:24:26.912125",
  "cost_data": null
}