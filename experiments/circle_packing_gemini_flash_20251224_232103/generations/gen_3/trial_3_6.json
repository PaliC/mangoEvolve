{
  "trial_id": "trial_3_6",
  "generation": 3,
  "parent_id": "trial_1_7",
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Optimizes the sum of radii using a neighborhood-aware coordinate descent \n    followed by a global SLSQP refinement.\n    \"\"\"\n    n = 26\n    # Initialize with a grid-like structure to ensure good coverage\n    rows, cols = 5, 5\n    x = np.linspace(0.1, 0.9, 5)\n    y = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.vstack([xv.ravel(), yv.ravel()])\n    # Add the 26th circle at the center\n    centers = np.column_stack([centers, [0.5, 0.5]])\n    centers = centers.T # Shape (26, 2)\n    \n    # Initial radii guess\n    radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n\n    def get_max_radius(idx, current_centers):\n        \"\"\"Calculates the maximum possible radius for circle idx given others.\"\"\"\n        c_i = current_centers[idx]\n        # Distance to boundaries\n        r_bound = min(c_i[0], 1 - c_i[0], c_i[1], 1 - c_i[1])\n        # Distance to other circles\n        r_others = []\n        for j in range(len(current_centers)):\n            if i == j: continue\n            dist = np.linalg.norm(current_centers[idx] - current_centers[j])\n            # This is a simplification for the coordinate descent phase\n            r_others.append(dist / 2.0)\n        return max(0, min(r_bound, min(r_others)))\n\n    # 1. Neighborhood-aware Coordinate Descent\n    # We iteratively adjust centers to allow for more 'breathing room'\n    for _ in range(30):\n        for i in range(n):\n            # Sample local perturbations to find a better center for circle i\n            best_pos = centers[i].copy()\n            best_local_sum = 0\n            \n            # Look at neighbors to consider \"sum of radii\"\n            neighbors_idx = np.argsort(np.linalg.norm(centers - centers[i], axis=1))[1:4]\n            \n            for _sample in range(10):\n                # Random walk\n                move = np.random.normal(0, 0.02, size=2)\n                test_pos = np.clip(centers[i] + move, 0.01, 0.99)\n                \n                temp_centers = centers.copy()\n                temp_centers[i] = test_pos\n                \n                # Calculate local sum (self + 3 neighbors)\n                local_sum = 0\n                for idx in np.append(neighbors_idx, i):\n                    # Calculate max radius for circle idx in temp_centers\n                    c = temp_centers[idx]\n                    d_bound = min(c[0], 1-c[0], c[1], 1-c[1])\n                    d_circles = []\n                    for k in range(n):\n                        if k == idx: continue\n                        d_circles.append(np.linalg.norm(c - temp_centers[k]) / 2.0)\n                    local_sum += max(0, min(d_bound, min(d_circles)))\n                \n                if local_sum > best_local_sum:\n                    best_local_sum = local_sum\n                    best_pos = test_pos\n            centers[i] = best_pos\n\n    # 2. Global SLSQP Optimization\n    # Objective: Maximize sum of radii -> Minimize -sum(radii)\n    # Variables: [x1, y1, ..., x26, y26, r1, ..., r26]\n    initial_guess = np.concatenate([centers.flatten(), radii])\n\n    def objective(vars):\n        return -np.sum(vars[2*n:])\n\n    def constraints(vars):\n        c = vars[:2*n].reshape((n, 2))\n        r = vars[2*n:]\n        cons = []\n        # Boundary constraints\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])         # x - r >= 0\n            cons.append(1.0 - (c[i, 0] + r[i])) # 1 - (x + r) >= 0\n            cons.append(c[i, 1] - r[i])         # y - r >= 0\n            cons.append(1.0 - (c[i, 1] + r[i])) # 1 - (y + r) >= 0\n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    # Use a faster subset of constraints or trust bounds for efficiency\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n\n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    \n    # Final verification/clipping to ensure hard constraints\n    # Slightly shrink radii if constraints are violated due to precision\n    for i in range(n):\n        final_radii[i] = min(final_radii[i], final_centers[i,0], 1-final_centers[i,0], \n                             final_centers[i,1], 1-final_centers[i,1])\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_centers[i] - final_centers[j])\n            if final_radii[i] + final_radii[j] > dist:\n                # Proportional reduction\n                reduction = (final_radii[i] + final_radii[j] - dist) / 2.0\n                final_radii[i] -= reduction + 1e-9\n                final_radii[j] -= reduction + 1e-9\n    \n    final_radii = np.maximum(final_radii, 0)\n    \n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.6255131378816428,
    "eval_time": 1.4695229530334473,
    "error": null
  },
  "prompt": "Improve the coordinate descent from trial_1_7.\n        1. For each circle, instead of just moving it to maximize its own radius, move it to maximize the sum of its radius and its nearest 3 neighbors.\n        2. This prevents a single circle from 'hogging' space that neighbors could use more effectively.\n        3. Iterate through all 26 circles 50 times.\n        4. Finish with a global SLSQP optimization.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    \"\"\"\n    Construct a circle packing for n=26 circles in a unit square.\n    Optimizes the sum of radii using a neighborhood-aware coordinate descent \n    followed by a global SLSQP refinement.\n    \"\"\"\n    n = 26\n    # Initialize with a grid-like structure to ensure good coverage\n    rows, cols = 5, 5\n    x = np.linspace(0.1, 0.9, 5)\n    y = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x, y)\n    centers = np.vstack([xv.ravel(), yv.ravel()])\n    # Add the 26th circle at the center\n    centers = np.column_stack([centers, [0.5, 0.5]])\n    centers = centers.T # Shape (26, 2)\n    \n    # Initial radii guess\n    radii = np.full(n, 1.0 / (2 * np.sqrt(n)))\n\n    def get_max_radius(idx, current_centers):\n        \"\"\"Calculates the maximum possible radius for circle idx given others.\"\"\"\n        c_i = current_centers[idx]\n        # Distance to boundaries\n        r_bound = min(c_i[0], 1 - c_i[0], c_i[1], 1 - c_i[1])\n        # Distance to other circles\n        r_others = []\n        for j in range(len(current_centers)):\n            if i == j: continue\n            dist = np.linalg.norm(current_centers[idx] - current_centers[j])\n            # This is a simplification for the coordinate descent phase\n            r_others.append(dist / 2.0)\n        return max(0, min(r_bound, min(r_others)))\n\n    # 1. Neighborhood-aware Coordinate Descent\n    # We iteratively adjust centers to allow for more 'breathing room'\n    for _ in range(30):\n        for i in range(n):\n            # Sample local perturbations to find a better center for circle i\n            best_pos = centers[i].copy()\n            best_local_sum = 0\n            \n            # Look at neighbors to consider \"sum of radii\"\n            neighbors_idx = np.argsort(np.linalg.norm(centers - centers[i], axis=1))[1:4]\n            \n            for _sample in range(10):\n                # Random walk\n                move = np.random.normal(0, 0.02, size=2)\n                test_pos = np.clip(centers[i] + move, 0.01, 0.99)\n                \n                temp_centers = centers.copy()\n                temp_centers[i] = test_pos\n                \n                # Calculate local sum (self + 3 neighbors)\n                local_sum = 0\n                for idx in np.append(neighbors_idx, i):\n                    # Calculate max radius for circle idx in temp_centers\n                    c = temp_centers[idx]\n                    d_bound = min(c[0], 1-c[0], c[1], 1-c[1])\n                    d_circles = []\n                    for k in range(n):\n                        if k == idx: continue\n                        d_circles.append(np.linalg.norm(c - temp_centers[k]) / 2.0)\n                    local_sum += max(0, min(d_bound, min(d_circles)))\n                \n                if local_sum > best_local_sum:\n                    best_local_sum = local_sum\n                    best_pos = test_pos\n            centers[i] = best_pos\n\n    # 2. Global SLSQP Optimization\n    # Objective: Maximize sum of radii -> Minimize -sum(radii)\n    # Variables: [x1, y1, ..., x26, y26, r1, ..., r26]\n    initial_guess = np.concatenate([centers.flatten(), radii])\n\n    def objective(vars):\n        return -np.sum(vars[2*n:])\n\n    def constraints(vars):\n        c = vars[:2*n].reshape((n, 2))\n        r = vars[2*n:]\n        cons = []\n        # Boundary constraints\n        for i in range(n):\n            cons.append(c[i, 0] - r[i])         # x - r >= 0\n            cons.append(1.0 - (c[i, 0] + r[i])) # 1 - (x + r) >= 0\n            cons.append(c[i, 1] - r[i])         # y - r >= 0\n            cons.append(1.0 - (c[i, 1] + r[i])) # 1 - (y + r) >= 0\n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c[i] - c[j])\n                cons.append(dist - (r[i] + r[j]))\n        return np.array(cons)\n\n    # Use a faster subset of constraints or trust bounds for efficiency\n    bounds = [(0, 1)] * (2 * n) + [(0, 0.5)] * n\n    \n    res = minimize(\n        objective, \n        initial_guess, \n        method='SLSQP', \n        constraints={'type': 'ineq', 'fun': constraints},\n        bounds=bounds,\n        options={'maxiter': 100, 'ftol': 1e-6}\n    )\n\n    final_vars = res.x\n    final_centers = final_vars[:2*n].reshape((n, 2))\n    final_radii = final_vars[2*n:]\n    \n    # Final verification/clipping to ensure hard constraints\n    # Slightly shrink radii if constraints are violated due to precision\n    for i in range(n):\n        final_radii[i] = min(final_radii[i], final_centers[i,0], 1-final_centers[i,0], \n                             final_centers[i,1], 1-final_centers[i,1])\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_centers[i] - final_centers[j])\n            if final_radii[i] + final_radii[j] > dist:\n                # Proportional reduction\n                reduction = (final_radii[i] + final_radii[j] - dist) / 2.0\n                final_radii[i] -= reduction + 1e-9\n                final_radii[j] -= reduction + 1e-9\n    \n    final_radii = np.maximum(final_radii, 0)\n    \n    return final_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point called by evaluator.\"\"\"\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-24T23:25:52.948584",
  "cost_data": null
}