{
  "trial_id": "trial_0_6",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    '''\n    Force-directed layout for circle packing.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    n_circles = 26\n    np.random.seed(42)\n    \n    # Initialize circles with random positions and small radii\n    centers = np.random.uniform(0.2, 0.8, (n_circles, 2))\n    radii = np.ones(n_circles) * 0.05\n    \n    # Simulation parameters\n    dt = 0.01\n    damping = 0.95\n    velocities = np.zeros((n_circles, 2))\n    \n    # Force parameters\n    repulsion_strength = 0.1\n    boundary_strength = 0.5\n    radius_growth_rate = 0.001\n    min_separation = 1e-6\n    \n    max_iterations = 5000\n    \n    for iteration in range(max_iterations):\n        forces = np.zeros((n_circles, 2))\n        \n        # Circle-circle repulsion forces\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist < min_separation:\n                    dist = min_separation\n                    diff = np.random.randn(2) * min_separation\n                \n                # Required separation distance\n                required_dist = radii[i] + radii[j]\n                \n                # If circles overlap or are too close\n                if dist < required_dist * 1.1:  # Add small buffer\n                    overlap = required_dist - dist\n                    direction = diff / dist\n                    force_magnitude = repulsion_strength * (overlap + 0.01)\n                    \n                    forces[i] += direction * force_magnitude\n                    forces[j] -= direction * force_magnitude\n        \n        # Boundary forces (walls)\n        for i in range(n_circles):\n            # Left wall\n            if centers[i, 0] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 0]\n                forces[i, 0] += boundary_strength * penetration\n            \n            # Right wall\n            if centers[i, 0] + radii[i] > 1:\n                penetration = centers[i, 0] + radii[i] - 1\n                forces[i, 0] -= boundary_strength * penetration\n            \n            # Bottom wall\n            if centers[i, 1] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 1]\n                forces[i, 1] += boundary_strength * penetration\n            \n            # Top wall\n            if centers[i, 1] + radii[i] > 1:\n                penetration = centers[i, 1] + radii[i] - 1\n                forces[i, 1] -= boundary_strength * penetration\n        \n        # Update velocities and positions\n        velocities += forces * dt\n        velocities *= damping\n        centers += velocities * dt\n        \n        # Clamp positions to valid range\n        centers = np.clip(centers, radii[:, np.newaxis], 1 - radii[:, np.newaxis])\n        \n        # Try to grow radii if there's space\n        if iteration % 10 == 0:\n            can_grow = np.ones(n_circles, dtype=bool)\n            \n            # Check if each circle can grow\n            for i in range(n_circles):\n                # Check boundaries\n                if (centers[i, 0] - radii[i] < 0.01 or \n                    centers[i, 0] + radii[i] > 0.99 or\n                    centers[i, 1] - radii[i] < 0.01 or \n                    centers[i, 1] + radii[i] > 0.99):\n                    can_grow[i] = False\n                    continue\n                \n                # Check other circles\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < radii[i] + radii[j] + 0.02:\n                            can_grow[i] = False\n                            break\n            \n            # Grow circles that have space\n            radii[can_grow] += radius_growth_rate\n        \n        # Check for equilibrium (low kinetic energy)\n        if iteration % 100 == 0:\n            kinetic_energy = np.sum(velocities ** 2)\n            if kinetic_energy < 1e-8 and iteration > 1000:\n                break\n    \n    # Final refinement: ensure no overlaps\n    for _ in range(100):\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                required_dist = radii[i] + radii[j]\n                \n                if dist < required_dist:\n                    if dist < min_separation:\n                        dist = min_separation\n                        diff = np.random.randn(2) * min_separation\n                    \n                    overlap = required_dist - dist\n                    direction = diff / dist\n                    centers[i] += direction * overlap * 0.51\n                    centers[j] -= direction * overlap * 0.51\n        \n        # Ensure boundaries\n        centers = np.clip(centers, radii[:, np.newaxis], 1 - radii[:, np.newaxis])\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 1.3160000000000003,
    "target_ratio": 0.4994307400379508,
    "combined_score": 0.4994307400379508,
    "eval_time": 2.7216010093688965,
    "error": null
  },
  "prompt": "Write a physics-based circle packing using force-directed layout for 26 circles in [0,1]x[0,1].\n\nSimulate physical forces: circles repel each other and are attracted to maximize their radii, with boundaries acting as walls.\n\nYour code must define:\n```python\nimport numpy as np\n\ndef construct_packing():\n    '''\n    Force-directed layout for circle packing.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    pass\n\ndef run_packing():\n    return construct_packing()\n```\n\nIterate until forces equilibrate.",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    '''\n    Force-directed layout for circle packing.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    n_circles = 26\n    np.random.seed(42)\n    \n    # Initialize circles with random positions and small radii\n    centers = np.random.uniform(0.2, 0.8, (n_circles, 2))\n    radii = np.ones(n_circles) * 0.05\n    \n    # Simulation parameters\n    dt = 0.01\n    damping = 0.95\n    velocities = np.zeros((n_circles, 2))\n    \n    # Force parameters\n    repulsion_strength = 0.1\n    boundary_strength = 0.5\n    radius_growth_rate = 0.001\n    min_separation = 1e-6\n    \n    max_iterations = 5000\n    \n    for iteration in range(max_iterations):\n        forces = np.zeros((n_circles, 2))\n        \n        # Circle-circle repulsion forces\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                \n                if dist < min_separation:\n                    dist = min_separation\n                    diff = np.random.randn(2) * min_separation\n                \n                # Required separation distance\n                required_dist = radii[i] + radii[j]\n                \n                # If circles overlap or are too close\n                if dist < required_dist * 1.1:  # Add small buffer\n                    overlap = required_dist - dist\n                    direction = diff / dist\n                    force_magnitude = repulsion_strength * (overlap + 0.01)\n                    \n                    forces[i] += direction * force_magnitude\n                    forces[j] -= direction * force_magnitude\n        \n        # Boundary forces (walls)\n        for i in range(n_circles):\n            # Left wall\n            if centers[i, 0] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 0]\n                forces[i, 0] += boundary_strength * penetration\n            \n            # Right wall\n            if centers[i, 0] + radii[i] > 1:\n                penetration = centers[i, 0] + radii[i] - 1\n                forces[i, 0] -= boundary_strength * penetration\n            \n            # Bottom wall\n            if centers[i, 1] - radii[i] < 0:\n                penetration = radii[i] - centers[i, 1]\n                forces[i, 1] += boundary_strength * penetration\n            \n            # Top wall\n            if centers[i, 1] + radii[i] > 1:\n                penetration = centers[i, 1] + radii[i] - 1\n                forces[i, 1] -= boundary_strength * penetration\n        \n        # Update velocities and positions\n        velocities += forces * dt\n        velocities *= damping\n        centers += velocities * dt\n        \n        # Clamp positions to valid range\n        centers = np.clip(centers, radii[:, np.newaxis], 1 - radii[:, np.newaxis])\n        \n        # Try to grow radii if there's space\n        if iteration % 10 == 0:\n            can_grow = np.ones(n_circles, dtype=bool)\n            \n            # Check if each circle can grow\n            for i in range(n_circles):\n                # Check boundaries\n                if (centers[i, 0] - radii[i] < 0.01 or \n                    centers[i, 0] + radii[i] > 0.99 or\n                    centers[i, 1] - radii[i] < 0.01 or \n                    centers[i, 1] + radii[i] > 0.99):\n                    can_grow[i] = False\n                    continue\n                \n                # Check other circles\n                for j in range(n_circles):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if dist < radii[i] + radii[j] + 0.02:\n                            can_grow[i] = False\n                            break\n            \n            # Grow circles that have space\n            radii[can_grow] += radius_growth_rate\n        \n        # Check for equilibrium (low kinetic energy)\n        if iteration % 100 == 0:\n            kinetic_energy = np.sum(velocities ** 2)\n            if kinetic_energy < 1e-8 and iteration > 1000:\n                break\n    \n    # Final refinement: ensure no overlaps\n    for _ in range(100):\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                required_dist = radii[i] + radii[j]\n                \n                if dist < required_dist:\n                    if dist < min_separation:\n                        dist = min_separation\n                        diff = np.random.randn(2) * min_separation\n                    \n                    overlap = required_dist - dist\n                    direction = diff / dist\n                    centers[i] += direction * overlap * 0.51\n                    centers[j] -= direction * overlap * 0.51\n        \n        # Ensure boundaries\n        centers = np.clip(centers, radii[:, np.newaxis], 1 - radii[:, np.newaxis])\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:55:48.179150",
  "cost_data": null
}