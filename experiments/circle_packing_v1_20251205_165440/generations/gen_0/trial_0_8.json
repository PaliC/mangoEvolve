{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    '''\n    Apollonian gasket-inspired packing.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    centers = []\n    radii = []\n    \n    # Start with 3 initial circles that fit in [0,1]x[0,1]\n    # Place them in a triangular configuration\n    r1 = 0.18\n    c1 = np.array([0.25, 0.25])\n    \n    r2 = 0.18\n    c2 = np.array([0.75, 0.25])\n    \n    r3 = 0.18\n    c3 = np.array([0.5, 0.75])\n    \n    centers.extend([c1, c2, c3])\n    radii.extend([r1, r2, r3])\n    \n    # Helper function to compute Apollonian circle from three mutually tangent circles\n    def descartes_circle(c1, r1, c2, r2, c3, r3, sign=1):\n        \"\"\"\n        Given three mutually tangent circles, compute the fourth tangent circle\n        using Descartes' Circle Theorem.\n        sign=1 for externally tangent, sign=-1 for internally tangent\n        \"\"\"\n        k1, k2, k3 = 1/r1, 1/r2, 1/r3\n        \n        # Descartes Circle Theorem for curvature\n        k4 = k1 + k2 + k3 + sign * 2 * np.sqrt(k1*k2 + k2*k3 + k3*k1)\n        \n        if k4 <= 0:\n            return None, None\n        \n        r4 = 1/k4\n        \n        # Complex Descartes Theorem for centers\n        z1, z2, z3 = c1[0] + 1j*c1[1], c2[0] + 1j*c2[1], c3[0] + 1j*c3[1]\n        zk1, zk2, zk3 = z1*k1, z2*k2, z3*k3\n        \n        zk4 = zk1 + zk2 + zk3 + sign * 2 * np.sqrt(zk1*zk2 + zk2*zk3 + zk3*zk1)\n        z4 = zk4 / k4\n        \n        c4 = np.array([z4.real, z4.imag])\n        \n        return c4, r4\n    \n    def is_valid_circle(center, radius):\n        \"\"\"Check if circle is within bounds and doesn't overlap existing circles\"\"\"\n        if radius <= 0 or radius > 0.5:\n            return False\n        if (center[0] - radius < 0 or center[0] + radius > 1 or\n            center[1] - radius < 0 or center[1] + radius > 1):\n            return False\n        \n        # Check overlap with existing circles\n        for i, (c, r) in enumerate(zip(centers, radii)):\n            dist = np.linalg.norm(center - c)\n            if dist < r + radius - 1e-6:  # Small tolerance for tangency\n                return False\n        return True\n    \n    # Generate candidate circles from all triplets\n    candidates = []\n    \n    def add_apollonian_circles():\n        \"\"\"Try to add circles in gaps between existing circles\"\"\"\n        n = len(centers)\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    # Try both signs for Descartes theorem\n                    for sign in [1, -1]:\n                        c_new, r_new = descartes_circle(\n                            centers[i], radii[i],\n                            centers[j], radii[j],\n                            centers[k], radii[k],\n                            sign=sign\n                        )\n                        \n                        if c_new is not None and r_new is not None:\n                            if is_valid_circle(c_new, r_new):\n                                candidates.append((r_new, c_new))\n    \n    # Iteratively add circles until we have 26\n    while len(centers) < 26:\n        candidates = []\n        add_apollonian_circles()\n        \n        if not candidates:\n            # If no Apollonian circles work, add circles in empty spaces\n            best_r = 0\n            best_c = None\n            \n            for _ in range(100):\n                test_c = np.random.uniform(0.1, 0.9, 2)\n                test_r = min(test_c[0], test_c[1], 1-test_c[0], 1-test_c[1])\n                \n                for c, r in zip(centers, radii):\n                    dist = np.linalg.norm(test_c - c)\n                    test_r = min(test_r, dist - r)\n                \n                if test_r > best_r and test_r > 0.01:\n                    best_r = test_r * 0.95  # Safety margin\n                    best_c = test_c\n            \n            if best_c is not None:\n                centers.append(best_c)\n                radii.append(best_r)\n        else:\n            # Sort by radius (largest first) and add the largest valid circle\n            candidates.sort(reverse=True, key=lambda x: x[0])\n            r_new, c_new = candidates[0]\n            centers.append(c_new)\n            radii.append(r_new)\n    \n    centers = np.array(centers[:26])\n    radii = np.array(radii[:26])\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 0.9511147844953678,
    "target_ratio": 0.3609543774175969,
    "combined_score": 0.3609543774175969,
    "eval_time": 0.45566892623901367,
    "error": null
  },
  "prompt": "Write a circle packing using the Apollonian gasket approach for 26 circles in [0,1]x[0,1].\n\nStart with a few large circles and recursively fill gaps with smaller circles following Apollonian circle packing principles.\n\nYour code must define:\n```python\nimport numpy as np\n\ndef construct_packing():\n    '''\n    Apollonian gasket-inspired packing.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    pass\n\ndef run_packing():\n    return construct_packing()\n```\n\nFill gaps iteratively with tangent circles.",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    '''\n    Apollonian gasket-inspired packing.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    centers = []\n    radii = []\n    \n    # Start with 3 initial circles that fit in [0,1]x[0,1]\n    # Place them in a triangular configuration\n    r1 = 0.18\n    c1 = np.array([0.25, 0.25])\n    \n    r2 = 0.18\n    c2 = np.array([0.75, 0.25])\n    \n    r3 = 0.18\n    c3 = np.array([0.5, 0.75])\n    \n    centers.extend([c1, c2, c3])\n    radii.extend([r1, r2, r3])\n    \n    # Helper function to compute Apollonian circle from three mutually tangent circles\n    def descartes_circle(c1, r1, c2, r2, c3, r3, sign=1):\n        \"\"\"\n        Given three mutually tangent circles, compute the fourth tangent circle\n        using Descartes' Circle Theorem.\n        sign=1 for externally tangent, sign=-1 for internally tangent\n        \"\"\"\n        k1, k2, k3 = 1/r1, 1/r2, 1/r3\n        \n        # Descartes Circle Theorem for curvature\n        k4 = k1 + k2 + k3 + sign * 2 * np.sqrt(k1*k2 + k2*k3 + k3*k1)\n        \n        if k4 <= 0:\n            return None, None\n        \n        r4 = 1/k4\n        \n        # Complex Descartes Theorem for centers\n        z1, z2, z3 = c1[0] + 1j*c1[1], c2[0] + 1j*c2[1], c3[0] + 1j*c3[1]\n        zk1, zk2, zk3 = z1*k1, z2*k2, z3*k3\n        \n        zk4 = zk1 + zk2 + zk3 + sign * 2 * np.sqrt(zk1*zk2 + zk2*zk3 + zk3*zk1)\n        z4 = zk4 / k4\n        \n        c4 = np.array([z4.real, z4.imag])\n        \n        return c4, r4\n    \n    def is_valid_circle(center, radius):\n        \"\"\"Check if circle is within bounds and doesn't overlap existing circles\"\"\"\n        if radius <= 0 or radius > 0.5:\n            return False\n        if (center[0] - radius < 0 or center[0] + radius > 1 or\n            center[1] - radius < 0 or center[1] + radius > 1):\n            return False\n        \n        # Check overlap with existing circles\n        for i, (c, r) in enumerate(zip(centers, radii)):\n            dist = np.linalg.norm(center - c)\n            if dist < r + radius - 1e-6:  # Small tolerance for tangency\n                return False\n        return True\n    \n    # Generate candidate circles from all triplets\n    candidates = []\n    \n    def add_apollonian_circles():\n        \"\"\"Try to add circles in gaps between existing circles\"\"\"\n        n = len(centers)\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    # Try both signs for Descartes theorem\n                    for sign in [1, -1]:\n                        c_new, r_new = descartes_circle(\n                            centers[i], radii[i],\n                            centers[j], radii[j],\n                            centers[k], radii[k],\n                            sign=sign\n                        )\n                        \n                        if c_new is not None and r_new is not None:\n                            if is_valid_circle(c_new, r_new):\n                                candidates.append((r_new, c_new))\n    \n    # Iteratively add circles until we have 26\n    while len(centers) < 26:\n        candidates = []\n        add_apollonian_circles()\n        \n        if not candidates:\n            # If no Apollonian circles work, add circles in empty spaces\n            best_r = 0\n            best_c = None\n            \n            for _ in range(100):\n                test_c = np.random.uniform(0.1, 0.9, 2)\n                test_r = min(test_c[0], test_c[1], 1-test_c[0], 1-test_c[1])\n                \n                for c, r in zip(centers, radii):\n                    dist = np.linalg.norm(test_c - c)\n                    test_r = min(test_r, dist - r)\n                \n                if test_r > best_r and test_r > 0.01:\n                    best_r = test_r * 0.95  # Safety margin\n                    best_c = test_c\n            \n            if best_c is not None:\n                centers.append(best_c)\n                radii.append(best_r)\n        else:\n            # Sort by radius (largest first) and add the largest valid circle\n            candidates.sort(reverse=True, key=lambda x: x[0])\n            r_new, c_new = candidates[0]\n            centers.append(c_new)\n            radii.append(r_new)\n    \n    centers = np.array(centers[:26])\n    radii = np.array(radii[:26])\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:55:48.955673",
  "cost_data": null
}