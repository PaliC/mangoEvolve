{
  "trial_id": "trial_0_14",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import basinhopping, minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    '''\n    Basin-hopping global optimization for packing 26 circles in [0,1]x[0,1].\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    n_circles = 26\n    \n    def decode_params(x):\n        \"\"\"Convert flat parameter vector to centers and radii.\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        return centers, radii\n    \n    def encode_params(centers, radii):\n        \"\"\"Convert centers and radii to flat parameter vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        centers, radii = decode_params(x)\n        return -np.sum(radii)\n    \n    def constraint_penalty(x, penalty_weight=1000.0):\n        \"\"\"Compute penalty for constraint violations.\"\"\"\n        centers, radii = decode_params(x)\n        penalty = 0.0\n        \n        # Penalty for circles going outside [0,1]x[0,1]\n        for i in range(n_circles):\n            # Check boundaries\n            penalty += max(0, radii[i] - centers[i, 0]) ** 2  # left\n            penalty += max(0, radii[i] - centers[i, 1]) ** 2  # bottom\n            penalty += max(0, centers[i, 0] + radii[i] - 1) ** 2  # right\n            penalty += max(0, centers[i, 1] + radii[i] - 1) ** 2  # top\n        \n        # Penalty for overlapping circles\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = (radii[i] + radii[j]) - dist\n                if overlap > 0:\n                    penalty += overlap ** 2\n        \n        # Penalty for negative radii\n        penalty += np.sum(np.maximum(0, -radii) ** 2)\n        \n        return penalty * penalty_weight\n    \n    def objective_with_penalty(x):\n        \"\"\"Objective with penalty for constraint violations.\"\"\"\n        return objective(x) + constraint_penalty(x)\n    \n    class RandomDisplacement:\n        \"\"\"Custom step-taking routine for basin-hopping.\"\"\"\n        def __init__(self, stepsize=0.1):\n            self.stepsize = stepsize\n        \n        def __call__(self, x):\n            \"\"\"Take a random step.\"\"\"\n            centers, radii = decode_params(x)\n            \n            # Randomly perturb centers\n            centers += np.random.uniform(-self.stepsize, self.stepsize, centers.shape)\n            centers = np.clip(centers, 0, 1)\n            \n            # Randomly perturb radii (smaller perturbations)\n            radii += np.random.uniform(-self.stepsize * 0.5, self.stepsize * 0.5, radii.shape)\n            radii = np.maximum(radii, 0.001)  # Keep radii positive\n            \n            return encode_params(centers, radii)\n    \n    def accept_test(f_new, x_new, f_old, x_old):\n        \"\"\"Custom acceptance test - always accept improvements.\"\"\"\n        return f_new < f_old\n    \n    # Initialize with a grid-like pattern\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    \n    initial_centers = np.array(initial_centers)\n    \n    # Estimate initial radius\n    initial_radius = 0.5 / grid_size\n    initial_radii = np.full(n_circles, initial_radius)\n    \n    x0 = encode_params(initial_centers, initial_radii)\n    \n    # Basin-hopping parameters\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles,\n        \"options\": {\"maxiter\": 100}\n    }\n    \n    # Run basin-hopping\n    result = basinhopping(\n        objective_with_penalty,\n        x0,\n        minimizer_kwargs=minimizer_kwargs,\n        niter=200,\n        T=1.0,\n        stepsize=0.15,\n        take_step=RandomDisplacement(stepsize=0.15),\n        interval=20,\n        disp=False,\n        niter_success=20\n    )\n    \n    # Extract final solution\n    centers, radii = decode_params(result.x)\n    \n    # Post-process: ensure all constraints are satisfied\n    # Clip centers to valid range\n    for i in range(n_circles):\n        centers[i] = np.clip(centers[i], radii[i], 1 - radii[i])\n    \n    # Ensure non-overlapping by slightly reducing radii if needed\n    max_iterations = 100\n    for _ in range(max_iterations):\n        overlaps = False\n        distances = cdist(centers, centers)\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                min_dist = radii[i] + radii[j]\n                if distances[i, j] < min_dist:\n                    overlaps = True\n                    # Reduce both radii slightly\n                    reduction = (min_dist - distances[i, j]) / 2 + 1e-6\n                    radii[i] -= reduction\n                    radii[j] -= reduction\n        \n        if not overlaps:\n            break\n    \n    radii = np.maximum(radii, 0.001)  # Ensure positive radii\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.3096838383900162,
    "target_ratio": 0.8765403561252434,
    "combined_score": 0.8765403561252434,
    "eval_time": 122.66463804244995,
    "error": null
  },
  "prompt": "Write a basin-hopping global optimization for 26 circles in [0,1]x[0,1].\n\nUse scipy.optimize.basinhopping to escape local minima and find global optimum.\n\nYour code must define:\n```python\nimport numpy as np\nfrom scipy.optimize import basinhopping\n\ndef construct_packing():\n    '''\n    Basin-hopping global optimization.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    pass\n\ndef run_packing():\n    return construct_packing()\n```\n\nCombine local optimization with random perturbations to explore solution space.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize\nfrom scipy.spatial.distance import cdist\n\ndef construct_packing():\n    '''\n    Basin-hopping global optimization for packing 26 circles in [0,1]x[0,1].\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    n_circles = 26\n    \n    def decode_params(x):\n        \"\"\"Convert flat parameter vector to centers and radii.\"\"\"\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        return centers, radii\n    \n    def encode_params(centers, radii):\n        \"\"\"Convert centers and radii to flat parameter vector.\"\"\"\n        return np.concatenate([centers.flatten(), radii])\n    \n    def objective(x):\n        \"\"\"Objective: maximize sum of radii (minimize negative sum).\"\"\"\n        centers, radii = decode_params(x)\n        return -np.sum(radii)\n    \n    def constraint_penalty(x, penalty_weight=1000.0):\n        \"\"\"Compute penalty for constraint violations.\"\"\"\n        centers, radii = decode_params(x)\n        penalty = 0.0\n        \n        # Penalty for circles going outside [0,1]x[0,1]\n        for i in range(n_circles):\n            # Check boundaries\n            penalty += max(0, radii[i] - centers[i, 0]) ** 2  # left\n            penalty += max(0, radii[i] - centers[i, 1]) ** 2  # bottom\n            penalty += max(0, centers[i, 0] + radii[i] - 1) ** 2  # right\n            penalty += max(0, centers[i, 1] + radii[i] - 1) ** 2  # top\n        \n        # Penalty for overlapping circles\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = (radii[i] + radii[j]) - dist\n                if overlap > 0:\n                    penalty += overlap ** 2\n        \n        # Penalty for negative radii\n        penalty += np.sum(np.maximum(0, -radii) ** 2)\n        \n        return penalty * penalty_weight\n    \n    def objective_with_penalty(x):\n        \"\"\"Objective with penalty for constraint violations.\"\"\"\n        return objective(x) + constraint_penalty(x)\n    \n    class RandomDisplacement:\n        \"\"\"Custom step-taking routine for basin-hopping.\"\"\"\n        def __init__(self, stepsize=0.1):\n            self.stepsize = stepsize\n        \n        def __call__(self, x):\n            \"\"\"Take a random step.\"\"\"\n            centers, radii = decode_params(x)\n            \n            # Randomly perturb centers\n            centers += np.random.uniform(-self.stepsize, self.stepsize, centers.shape)\n            centers = np.clip(centers, 0, 1)\n            \n            # Randomly perturb radii (smaller perturbations)\n            radii += np.random.uniform(-self.stepsize * 0.5, self.stepsize * 0.5, radii.shape)\n            radii = np.maximum(radii, 0.001)  # Keep radii positive\n            \n            return encode_params(centers, radii)\n    \n    def accept_test(f_new, x_new, f_old, x_old):\n        \"\"\"Custom acceptance test - always accept improvements.\"\"\"\n        return f_new < f_old\n    \n    # Initialize with a grid-like pattern\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    \n    initial_centers = np.array(initial_centers)\n    \n    # Estimate initial radius\n    initial_radius = 0.5 / grid_size\n    initial_radii = np.full(n_circles, initial_radius)\n    \n    x0 = encode_params(initial_centers, initial_radii)\n    \n    # Basin-hopping parameters\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles,\n        \"options\": {\"maxiter\": 100}\n    }\n    \n    # Run basin-hopping\n    result = basinhopping(\n        objective_with_penalty,\n        x0,\n        minimizer_kwargs=minimizer_kwargs,\n        niter=200,\n        T=1.0,\n        stepsize=0.15,\n        take_step=RandomDisplacement(stepsize=0.15),\n        interval=20,\n        disp=False,\n        niter_success=20\n    )\n    \n    # Extract final solution\n    centers, radii = decode_params(result.x)\n    \n    # Post-process: ensure all constraints are satisfied\n    # Clip centers to valid range\n    for i in range(n_circles):\n        centers[i] = np.clip(centers[i], radii[i], 1 - radii[i])\n    \n    # Ensure non-overlapping by slightly reducing radii if needed\n    max_iterations = 100\n    for _ in range(max_iterations):\n        overlaps = False\n        distances = cdist(centers, centers)\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                min_dist = radii[i] + radii[j]\n                if distances[i, j] < min_dist:\n                    overlaps = True\n                    # Reduce both radii slightly\n                    reduction = (min_dist - distances[i, j]) / 2 + 1e-6\n                    radii[i] -= reduction\n                    radii[j] -= reduction\n        \n        if not overlaps:\n            break\n    \n    radii = np.maximum(radii, 0.001)  # Ensure positive radii\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:57:51.830528",
  "cost_data": null
}