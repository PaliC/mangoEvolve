{
  "trial_id": "trial_0_5",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    '''\n    Genetic algorithm for circle packing.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    np.random.seed(42)\n    \n    # Genetic algorithm parameters\n    POPULATION_SIZE = 100\n    GENERATIONS = 500\n    MUTATION_RATE = 0.15\n    ELITE_SIZE = 10\n    TOURNAMENT_SIZE = 5\n    \n    def calculate_radii(centers):\n        \"\"\"Calculate the maximum radius for each circle given centers.\"\"\"\n        n = len(centers)\n        radii = np.ones(n) * 0.5  # Start with maximum possible\n        \n        for i in range(n):\n            # Distance to boundaries\n            min_radius = min(centers[i, 0], centers[i, 1], \n                           1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = (dist - radii[j]) if radii[j] < dist else 0\n                    min_radius = min(min_radius, max_r)\n            \n            radii[i] = max(0, min_radius)\n        \n        return radii\n    \n    def iterative_radius_calculation(centers, iterations=5):\n        \"\"\"Iteratively refine radii calculation.\"\"\"\n        radii = np.ones(len(centers)) * 0.01\n        \n        for _ in range(iterations):\n            for i in range(len(centers)):\n                # Distance to boundaries\n                min_radius = min(centers[i, 0], centers[i, 1], \n                               1 - centers[i, 0], 1 - centers[i, 1])\n                \n                # Distance to other circles\n                for j in range(len(centers)):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = dist - radii[j]\n                        min_radius = min(min_radius, max_r)\n                \n                radii[i] = max(0.001, min_radius)\n        \n        return radii\n    \n    def fitness(centers):\n        \"\"\"Fitness function: sum of radii.\"\"\"\n        radii = iterative_radius_calculation(centers)\n        return np.sum(radii)\n    \n    def initialize_population():\n        \"\"\"Create initial population with diverse strategies.\"\"\"\n        population = []\n        \n        # Grid-based initialization\n        for _ in range(POPULATION_SIZE // 3):\n            grid_size = int(np.ceil(np.sqrt(26)))\n            centers = []\n            for i in range(26):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                y = (row + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n            population.append(np.array(centers))\n        \n        # Hexagonal packing inspired\n        for _ in range(POPULATION_SIZE // 3):\n            centers = []\n            for i in range(26):\n                row = i // 6\n                col = i % 6\n                x = (col + 0.5 * (row % 2) + np.random.uniform(-0.1, 0.1)) / 6\n                y = (row * 0.866 + np.random.uniform(-0.1, 0.1)) / 6\n                centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n            population.append(np.array(centers))\n        \n        # Random initialization\n        for _ in range(POPULATION_SIZE - 2 * (POPULATION_SIZE // 3)):\n            centers = np.random.uniform(0.05, 0.95, (26, 2))\n            population.append(centers)\n        \n        return population\n    \n    def tournament_selection(population, fitnesses):\n        \"\"\"Select parent using tournament selection.\"\"\"\n        tournament_idx = np.random.choice(len(population), TOURNAMENT_SIZE, replace=False)\n        tournament_fitness = [fitnesses[i] for i in tournament_idx]\n        winner_idx = tournament_idx[np.argmax(tournament_fitness)]\n        return population[winner_idx].copy()\n    \n    def crossover(parent1, parent2):\n        \"\"\"Crossover two parents to create offspring.\"\"\"\n        if np.random.random() < 0.8:  # Crossover probability\n            # Uniform crossover\n            mask = np.random.random(26) < 0.5\n            child = parent1.copy()\n            child[mask] = parent2[mask]\n            return child\n        else:\n            return parent1.copy()\n    \n    def mutate(individual):\n        \"\"\"Mutate an individual.\"\"\"\n        mutated = individual.copy()\n        \n        for i in range(26):\n            if np.random.random() < MUTATION_RATE:\n                # Small gaussian mutation\n                mutated[i] += np.random.normal(0, 0.05, 2)\n                mutated[i] = np.clip(mutated[i], 0.05, 0.95)\n        \n        # Occasionally do a larger mutation\n        if np.random.random() < 0.1:\n            idx = np.random.randint(26)\n            mutated[idx] = np.random.uniform(0.05, 0.95, 2)\n        \n        return mutated\n    \n    # Initialize population\n    population = initialize_population()\n    best_individual = None\n    best_fitness = -np.inf\n    \n    # Evolution\n    for generation in range(GENERATIONS):\n        # Evaluate fitness\n        fitnesses = [fitness(ind) for ind in population]\n        \n        # Track best\n        gen_best_idx = np.argmax(fitnesses)\n        if fitnesses[gen_best_idx] > best_fitness:\n            best_fitness = fitnesses[gen_best_idx]\n            best_individual = population[gen_best_idx].copy()\n        \n        # Create new population\n        # Elitism: keep best individuals\n        elite_indices = np.argsort(fitnesses)[-ELITE_SIZE:]\n        new_population = [population[i].copy() for i in elite_indices]\n        \n        # Generate offspring\n        while len(new_population) < POPULATION_SIZE:\n            parent1 = tournament_selection(population, fitnesses)\n            parent2 = tournament_selection(population, fitnesses)\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population.append(child)\n        \n        population = new_population\n        \n        if generation % 100 == 0:\n            print(f\"Generation {generation}, Best fitness: {best_fitness:.6f}\")\n    \n    # Final evaluation\n    centers = best_individual\n    radii = iterative_radius_calculation(centers, iterations=10)\n    sum_radii = np.sum(radii)\n    \n    print(f\"Final sum of radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.361886149531828,
    "target_ratio": 0.896351479898227,
    "combined_score": 0.896351479898227,
    "eval_time": 3382.701076030731,
    "error": null
  },
  "prompt": "Write a genetic algorithm for circle packing of 26 circles in [0,1]x[0,1].\n\nUse evolutionary computation with population, crossover, and mutation to evolve good packings.\n\nYour code must define:\n```python\nimport numpy as np\n\ndef construct_packing():\n    '''\n    Genetic algorithm for circle packing.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    pass\n\ndef run_packing():\n    return construct_packing()\n```\n\nEvolve a population of packings over multiple generations.",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    '''\n    Genetic algorithm for circle packing.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    np.random.seed(42)\n    \n    # Genetic algorithm parameters\n    POPULATION_SIZE = 100\n    GENERATIONS = 500\n    MUTATION_RATE = 0.15\n    ELITE_SIZE = 10\n    TOURNAMENT_SIZE = 5\n    \n    def calculate_radii(centers):\n        \"\"\"Calculate the maximum radius for each circle given centers.\"\"\"\n        n = len(centers)\n        radii = np.ones(n) * 0.5  # Start with maximum possible\n        \n        for i in range(n):\n            # Distance to boundaries\n            min_radius = min(centers[i, 0], centers[i, 1], \n                           1 - centers[i, 0], 1 - centers[i, 1])\n            \n            # Distance to other circles\n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(centers[i] - centers[j])\n                    max_r = (dist - radii[j]) if radii[j] < dist else 0\n                    min_radius = min(min_radius, max_r)\n            \n            radii[i] = max(0, min_radius)\n        \n        return radii\n    \n    def iterative_radius_calculation(centers, iterations=5):\n        \"\"\"Iteratively refine radii calculation.\"\"\"\n        radii = np.ones(len(centers)) * 0.01\n        \n        for _ in range(iterations):\n            for i in range(len(centers)):\n                # Distance to boundaries\n                min_radius = min(centers[i, 0], centers[i, 1], \n                               1 - centers[i, 0], 1 - centers[i, 1])\n                \n                # Distance to other circles\n                for j in range(len(centers)):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        max_r = dist - radii[j]\n                        min_radius = min(min_radius, max_r)\n                \n                radii[i] = max(0.001, min_radius)\n        \n        return radii\n    \n    def fitness(centers):\n        \"\"\"Fitness function: sum of radii.\"\"\"\n        radii = iterative_radius_calculation(centers)\n        return np.sum(radii)\n    \n    def initialize_population():\n        \"\"\"Create initial population with diverse strategies.\"\"\"\n        population = []\n        \n        # Grid-based initialization\n        for _ in range(POPULATION_SIZE // 3):\n            grid_size = int(np.ceil(np.sqrt(26)))\n            centers = []\n            for i in range(26):\n                row = i // grid_size\n                col = i % grid_size\n                x = (col + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                y = (row + 0.5 + np.random.uniform(-0.2, 0.2)) / grid_size\n                centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n            population.append(np.array(centers))\n        \n        # Hexagonal packing inspired\n        for _ in range(POPULATION_SIZE // 3):\n            centers = []\n            for i in range(26):\n                row = i // 6\n                col = i % 6\n                x = (col + 0.5 * (row % 2) + np.random.uniform(-0.1, 0.1)) / 6\n                y = (row * 0.866 + np.random.uniform(-0.1, 0.1)) / 6\n                centers.append([np.clip(x, 0.05, 0.95), np.clip(y, 0.05, 0.95)])\n            population.append(np.array(centers))\n        \n        # Random initialization\n        for _ in range(POPULATION_SIZE - 2 * (POPULATION_SIZE // 3)):\n            centers = np.random.uniform(0.05, 0.95, (26, 2))\n            population.append(centers)\n        \n        return population\n    \n    def tournament_selection(population, fitnesses):\n        \"\"\"Select parent using tournament selection.\"\"\"\n        tournament_idx = np.random.choice(len(population), TOURNAMENT_SIZE, replace=False)\n        tournament_fitness = [fitnesses[i] for i in tournament_idx]\n        winner_idx = tournament_idx[np.argmax(tournament_fitness)]\n        return population[winner_idx].copy()\n    \n    def crossover(parent1, parent2):\n        \"\"\"Crossover two parents to create offspring.\"\"\"\n        if np.random.random() < 0.8:  # Crossover probability\n            # Uniform crossover\n            mask = np.random.random(26) < 0.5\n            child = parent1.copy()\n            child[mask] = parent2[mask]\n            return child\n        else:\n            return parent1.copy()\n    \n    def mutate(individual):\n        \"\"\"Mutate an individual.\"\"\"\n        mutated = individual.copy()\n        \n        for i in range(26):\n            if np.random.random() < MUTATION_RATE:\n                # Small gaussian mutation\n                mutated[i] += np.random.normal(0, 0.05, 2)\n                mutated[i] = np.clip(mutated[i], 0.05, 0.95)\n        \n        # Occasionally do a larger mutation\n        if np.random.random() < 0.1:\n            idx = np.random.randint(26)\n            mutated[idx] = np.random.uniform(0.05, 0.95, 2)\n        \n        return mutated\n    \n    # Initialize population\n    population = initialize_population()\n    best_individual = None\n    best_fitness = -np.inf\n    \n    # Evolution\n    for generation in range(GENERATIONS):\n        # Evaluate fitness\n        fitnesses = [fitness(ind) for ind in population]\n        \n        # Track best\n        gen_best_idx = np.argmax(fitnesses)\n        if fitnesses[gen_best_idx] > best_fitness:\n            best_fitness = fitnesses[gen_best_idx]\n            best_individual = population[gen_best_idx].copy()\n        \n        # Create new population\n        # Elitism: keep best individuals\n        elite_indices = np.argsort(fitnesses)[-ELITE_SIZE:]\n        new_population = [population[i].copy() for i in elite_indices]\n        \n        # Generate offspring\n        while len(new_population) < POPULATION_SIZE:\n            parent1 = tournament_selection(population, fitnesses)\n            parent2 = tournament_selection(population, fitnesses)\n            child = crossover(parent1, parent2)\n            child = mutate(child)\n            new_population.append(child)\n        \n        population = new_population\n        \n        if generation % 100 == 0:\n            print(f\"Generation {generation}, Best fitness: {best_fitness:.6f}\")\n    \n    # Final evaluation\n    centers = best_individual\n    radii = iterative_radius_calculation(centers, iterations=10)\n    sum_radii = np.sum(radii)\n    \n    print(f\"Final sum of radii: {sum_radii:.6f}\")\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```\n\nThis genetic algorithm implementation includes:\n\n1. **Population Initialization**: Uses three strategies:\n   - Grid-based layout with noise\n   - Hexagonal packing inspired layout\n   - Random initialization\n\n2. **Fitness Function**: Sum of all circle radii, calculated iteratively to handle interdependencies\n\n3. **Selection**: Tournament selection for diversity\n\n4. **Crossover**: Uniform crossover that combines parent positions\n\n5. **Mutation**: \n   - Small Gaussian perturbations for fine-tuning\n   - Occasional large mutations for exploration\n\n6. **Elitism**: Preserves best solutions across generations\n\n7. **Iterative Radius Calculation**: Refines radii multiple times since each circle's radius depends on others\n\nThe algorithm evolves over 500 generations with a population of 100, balancing exploration and exploitation to find good circle packings that maximize the sum of radii.",
  "reasoning": "This genetic algorithm implementation includes:\n\n1. **Population Initialization**: Uses three strategies:\n   - Grid-based layout with noise\n   - Hexagonal packing inspired layout\n   - Random initialization\n\n2. **Fitness Function**: Sum of all circle radii, calculated iteratively to handle interdependencies\n\n3. **Selection**: Tournament selection for diversity\n\n4. **Crossover**: Uniform crossover that combines parent positions\n\n5. **Mutation**: \n   - Small Gaussian perturbations for fine-tuning\n   - Occasional large mutations for exploration\n\n6. **Elitism**: Preserves best solutions across generations\n\n7. **Iterative Radius Calculation**: Refines radii multiple times since each circle's radius depends on others\n\nThe algorithm evolves over 500 generations with a population of 100, balancing exploration and exploitation to find good circle packings that maximize the sum of radii.",
  "timestamp": "2025-12-05T17:52:16.839516",
  "cost_data": null
}