{
  "trial_id": "trial_0_2",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    '''\n    Optimization-based packing using scipy.optimize.\n    Maximize sum of radii subject to non-overlap and boundary constraints.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    n_circles = 26\n    \n    # Initialize with a grid layout\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    initial_centers = np.array(initial_centers)\n    \n    # Initialize radii to small values\n    initial_radii = np.ones(n_circles) * 0.05\n    \n    # Combine into single parameter vector: [x1, y1, ..., xn, yn, r1, ..., rn]\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    def objective(x):\n        # We want to maximize sum of radii, so minimize negative sum\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraint_penalty(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        penalty = 0.0\n        \n        # Boundary constraints: circles must be inside [0,1]x[0,1]\n        for i in range(n_circles):\n            penalty += max(0, radii[i] - centers[i, 0])**2  # left boundary\n            penalty += max(0, radii[i] - centers[i, 1])**2  # bottom boundary\n            penalty += max(0, centers[i, 0] + radii[i] - 1)**2  # right boundary\n            penalty += max(0, centers[i, 1] + radii[i] - 1)**2  # top boundary\n        \n        # Non-overlap constraints: distance between centers >= sum of radii\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap**2\n        \n        # Ensure radii are positive\n        for i in range(n_circles):\n            if radii[i] < 0:\n                penalty += radii[i]**2 * 100\n        \n        return penalty\n    \n    def objective_with_penalty(x, penalty_weight=1000):\n        return objective(x) + penalty_weight * constraint_penalty(x)\n    \n    # Bounds: centers in [0,1]x[0,1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    # Try multiple optimization runs with increasing penalty weights\n    best_result = None\n    best_obj = float('inf')\n    \n    for penalty_weight in [100, 1000, 10000]:\n        # Use multiple random restarts\n        for restart in range(3):\n            if restart > 0:\n                # Random restart\n                x0_try = np.random.rand(3 * n_circles)\n                x0_try[:2*n_circles] = x0_try[:2*n_circles]  # centers in [0,1]\n                x0_try[2*n_circles:] = x0_try[2*n_circles:] * 0.1 + 0.01  # small radii\n            else:\n                x0_try = x0.copy()\n            \n            result = minimize(\n                lambda x: objective_with_penalty(x, penalty_weight),\n                x0_try,\n                method='L-BFGS-B',\n                bounds=bounds,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.fun < best_obj:\n                best_obj = result.fun\n                best_result = result\n    \n    # Extract solution\n    x_opt = best_result.x\n    centers = x_opt[:2*n_circles].reshape(n_circles, 2)\n    radii = x_opt[2*n_circles:]\n    \n    # Ensure all constraints are satisfied (post-processing)\n    # Clip to ensure boundaries\n    for i in range(n_circles):\n        max_r_x = min(centers[i, 0], 1 - centers[i, 0])\n        max_r_y = min(centers[i, 1], 1 - centers[i, 1])\n        max_r = min(max_r_x, max_r_y)\n        radii[i] = min(radii[i], max_r)\n    \n    # Shrink overlapping circles\n    max_iterations = 100\n    for iteration in range(max_iterations):\n        changed = False\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    # Shrink both proportionally\n                    shrink_factor = 0.99 * dist / (radii[i] + radii[j])\n                    radii[i] *= shrink_factor\n                    radii[j] *= shrink_factor\n                    changed = True\n        if not changed:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "sum_radii": 2.565144132690011,
    "target_ratio": 0.9734892344174616,
    "combined_score": 0.9734892344174616,
    "eval_time": 51.19918489456177,
    "error": null
  },
  "prompt": "Write an optimization-based circle packing using scipy.optimize for 26 circles in [0,1]x[0,1].\n\nUse scipy.optimize.minimize to optimize circle positions and radii simultaneously, maximizing the sum of radii.\n\nYour code must define:\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    '''\n    Optimization-based packing using scipy.optimize.\n    Maximize sum of radii subject to non-overlap and boundary constraints.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    pass\n\ndef run_packing():\n    return construct_packing()\n```\n\nUse penalty methods or constraints to enforce validity.",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef construct_packing():\n    '''\n    Optimization-based packing using scipy.optimize.\n    Maximize sum of radii subject to non-overlap and boundary constraints.\n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float\n    '''\n    n_circles = 26\n    \n    # Initialize with a grid layout\n    grid_size = int(np.ceil(np.sqrt(n_circles)))\n    initial_centers = []\n    for i in range(n_circles):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        initial_centers.append([x, y])\n    initial_centers = np.array(initial_centers)\n    \n    # Initialize radii to small values\n    initial_radii = np.ones(n_circles) * 0.05\n    \n    # Combine into single parameter vector: [x1, y1, ..., xn, yn, r1, ..., rn]\n    x0 = np.concatenate([initial_centers.flatten(), initial_radii])\n    \n    def objective(x):\n        # We want to maximize sum of radii, so minimize negative sum\n        radii = x[2*n_circles:]\n        return -np.sum(radii)\n    \n    def constraint_penalty(x):\n        centers = x[:2*n_circles].reshape(n_circles, 2)\n        radii = x[2*n_circles:]\n        \n        penalty = 0.0\n        \n        # Boundary constraints: circles must be inside [0,1]x[0,1]\n        for i in range(n_circles):\n            penalty += max(0, radii[i] - centers[i, 0])**2  # left boundary\n            penalty += max(0, radii[i] - centers[i, 1])**2  # bottom boundary\n            penalty += max(0, centers[i, 0] + radii[i] - 1)**2  # right boundary\n            penalty += max(0, centers[i, 1] + radii[i] - 1)**2  # top boundary\n        \n        # Non-overlap constraints: distance between centers >= sum of radii\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    penalty += overlap**2\n        \n        # Ensure radii are positive\n        for i in range(n_circles):\n            if radii[i] < 0:\n                penalty += radii[i]**2 * 100\n        \n        return penalty\n    \n    def objective_with_penalty(x, penalty_weight=1000):\n        return objective(x) + penalty_weight * constraint_penalty(x)\n    \n    # Bounds: centers in [0,1]x[0,1], radii in [0, 0.5]\n    bounds = [(0, 1)] * (2 * n_circles) + [(0.001, 0.5)] * n_circles\n    \n    # Try multiple optimization runs with increasing penalty weights\n    best_result = None\n    best_obj = float('inf')\n    \n    for penalty_weight in [100, 1000, 10000]:\n        # Use multiple random restarts\n        for restart in range(3):\n            if restart > 0:\n                # Random restart\n                x0_try = np.random.rand(3 * n_circles)\n                x0_try[:2*n_circles] = x0_try[:2*n_circles]  # centers in [0,1]\n                x0_try[2*n_circles:] = x0_try[2*n_circles:] * 0.1 + 0.01  # small radii\n            else:\n                x0_try = x0.copy()\n            \n            result = minimize(\n                lambda x: objective_with_penalty(x, penalty_weight),\n                x0_try,\n                method='L-BFGS-B',\n                bounds=bounds,\n                options={'maxiter': 1000, 'ftol': 1e-9}\n            )\n            \n            if result.fun < best_obj:\n                best_obj = result.fun\n                best_result = result\n    \n    # Extract solution\n    x_opt = best_result.x\n    centers = x_opt[:2*n_circles].reshape(n_circles, 2)\n    radii = x_opt[2*n_circles:]\n    \n    # Ensure all constraints are satisfied (post-processing)\n    # Clip to ensure boundaries\n    for i in range(n_circles):\n        max_r_x = min(centers[i, 0], 1 - centers[i, 0])\n        max_r_y = min(centers[i, 1], 1 - centers[i, 1])\n        max_r = min(max_r_x, max_r_y)\n        radii[i] = min(radii[i], max_r)\n    \n    # Shrink overlapping circles\n    max_iterations = 100\n    for iteration in range(max_iterations):\n        changed = False\n        for i in range(n_circles):\n            for j in range(i+1, n_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j]:\n                    # Shrink both proportionally\n                    shrink_factor = 0.99 * dist / (radii[i] + radii[j])\n                    radii[i] *= shrink_factor\n                    radii[j] *= shrink_factor\n                    changed = True\n        if not changed:\n            break\n    \n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-05T16:56:39.136800",
  "cost_data": null
}