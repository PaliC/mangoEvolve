{
  "trial_id": "trial_12_13",
  "generation": 12,
  "parent_id": null,
  "code": "import numpy as np\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Initialize with grid-like positions and small radii\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        centers.append([x, y])\n    centers = np.array(centers)\n    \n    # Start with small radii\n    radii = np.full(n, 0.05)\n    \n    def is_feasible(centers, radii):\n        # Check all circles are inside [0,1] x [0,1]\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check no overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-9:\n                    return False\n        return True\n    \n    def energy(centers, radii):\n        if not is_feasible(centers, radii):\n            return np.inf\n        return -np.sum(radii)\n    \n    # Simulated annealing\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_energy = energy(centers, radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_energy = best_energy\n    \n    n_steps = 10000\n    T_start = 1.0\n    T_end = 0.001\n    \n    for step in range(n_steps):\n        # Temperature schedule\n        T = T_start * (T_end / T_start) ** (step / n_steps)\n        \n        # Propose a move\n        new_centers = current_centers.copy()\n        new_radii = current_radii.copy()\n        \n        move_type = np.random.rand()\n        idx = np.random.randint(n)\n        \n        if move_type < 0.4:\n            # Perturb center\n            step_size = 0.02 * (1 + 9 * (1 - step / n_steps))  # Larger steps early on\n            new_centers[idx] += np.random.randn(2) * step_size\n        elif move_type < 0.8:\n            # Perturb radius\n            step_size = 0.01 * (1 + 9 * (1 - step / n_steps))\n            new_radii[idx] += np.random.randn() * step_size\n            new_radii[idx] = max(0, new_radii[idx])\n        else:\n            # Try to grow a random radius\n            max_growth = 0.05\n            new_radii[idx] += np.random.rand() * max_growth\n        \n        new_energy = energy(new_centers, new_radii)\n        \n        # Accept or reject\n        if new_energy < current_energy:\n            accept = True\n        elif current_energy == np.inf:\n            accept = False\n        else:\n            delta_E = new_energy - current_energy\n            accept = np.random.rand() < np.exp(-delta_E / T)\n        \n        if accept:\n            current_centers = new_centers\n            current_radii = new_radii\n            current_energy = new_energy\n            \n            if current_energy < best_energy:\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_energy = current_energy\n    \n    # Final optimization: try to grow radii greedily\n    for _ in range(100):\n        improved = False\n        for i in range(n):\n            # Try to grow radius i\n            old_r = best_radii[i]\n            max_r = min(best_centers[i, 0], 1 - best_centers[i, 0],\n                       best_centers[i, 1], 1 - best_centers[i, 1])\n            \n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(best_centers[i] - best_centers[j])\n                    max_r = min(max_r, dist - best_radii[j])\n            \n            if max_r > old_r + 1e-9:\n                best_radii[i] = max_r\n                improved = True\n        \n        if not improved:\n            break\n    \n    sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.276229160487916,
    "eval_time": 2.614494800567627,
    "error": null
  },
  "prompt": "For n=26 circles, implement SIMULATED ANNEALING:\n- State: (centers, radii)\n- Move: perturb random circle by small amount\n- Energy: -sum(radii) if feasible, else +infinity\n- Temperature schedule: 1.0 -> 0.001 over 10000 steps\n\nSA can escape local minima that gradient methods get stuck in.",
  "response": "```python\nimport numpy as np\n\ndef construct_packing():\n    np.random.seed(42)\n    n = 26\n    \n    # Initialize with grid-like positions and small radii\n    grid_size = int(np.ceil(np.sqrt(n)))\n    centers = []\n    for i in range(n):\n        row = i // grid_size\n        col = i % grid_size\n        x = (col + 0.5) / grid_size\n        y = (row + 0.5) / grid_size\n        centers.append([x, y])\n    centers = np.array(centers)\n    \n    # Start with small radii\n    radii = np.full(n, 0.05)\n    \n    def is_feasible(centers, radii):\n        # Check all circles are inside [0,1] x [0,1]\n        for i in range(n):\n            if (centers[i, 0] - radii[i] < 0 or centers[i, 0] + radii[i] > 1 or\n                centers[i, 1] - radii[i] < 0 or centers[i, 1] + radii[i] > 1):\n                return False\n        \n        # Check no overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < radii[i] + radii[j] - 1e-9:\n                    return False\n        return True\n    \n    def energy(centers, radii):\n        if not is_feasible(centers, radii):\n            return np.inf\n        return -np.sum(radii)\n    \n    # Simulated annealing\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_energy = energy(centers, radii)\n    \n    current_centers = centers.copy()\n    current_radii = radii.copy()\n    current_energy = best_energy\n    \n    n_steps = 10000\n    T_start = 1.0\n    T_end = 0.001\n    \n    for step in range(n_steps):\n        # Temperature schedule\n        T = T_start * (T_end / T_start) ** (step / n_steps)\n        \n        # Propose a move\n        new_centers = current_centers.copy()\n        new_radii = current_radii.copy()\n        \n        move_type = np.random.rand()\n        idx = np.random.randint(n)\n        \n        if move_type < 0.4:\n            # Perturb center\n            step_size = 0.02 * (1 + 9 * (1 - step / n_steps))  # Larger steps early on\n            new_centers[idx] += np.random.randn(2) * step_size\n        elif move_type < 0.8:\n            # Perturb radius\n            step_size = 0.01 * (1 + 9 * (1 - step / n_steps))\n            new_radii[idx] += np.random.randn() * step_size\n            new_radii[idx] = max(0, new_radii[idx])\n        else:\n            # Try to grow a random radius\n            max_growth = 0.05\n            new_radii[idx] += np.random.rand() * max_growth\n        \n        new_energy = energy(new_centers, new_radii)\n        \n        # Accept or reject\n        if new_energy < current_energy:\n            accept = True\n        elif current_energy == np.inf:\n            accept = False\n        else:\n            delta_E = new_energy - current_energy\n            accept = np.random.rand() < np.exp(-delta_E / T)\n        \n        if accept:\n            current_centers = new_centers\n            current_radii = new_radii\n            current_energy = new_energy\n            \n            if current_energy < best_energy:\n                best_centers = current_centers.copy()\n                best_radii = current_radii.copy()\n                best_energy = current_energy\n    \n    # Final optimization: try to grow radii greedily\n    for _ in range(100):\n        improved = False\n        for i in range(n):\n            # Try to grow radius i\n            old_r = best_radii[i]\n            max_r = min(best_centers[i, 0], 1 - best_centers[i, 0],\n                       best_centers[i, 1], 1 - best_centers[i, 1])\n            \n            for j in range(n):\n                if i != j:\n                    dist = np.linalg.norm(best_centers[i] - best_centers[j])\n                    max_r = min(max_r, dist - best_radii[j])\n            \n            if max_r > old_r + 1e-9:\n                best_radii[i] = max_r\n                improved = True\n        \n        if not improved:\n            break\n    \n    sum_radii = np.sum(best_radii)\n    return best_centers, best_radii, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T21:01:57.350407",
  "cost_data": null,
  "model_config": {
    "model": "anthropic/claude-sonnet-4.5",
    "temperature": 0.4
  }
}