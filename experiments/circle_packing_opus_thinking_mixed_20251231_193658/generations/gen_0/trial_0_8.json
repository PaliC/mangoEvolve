{
  "trial_id": "trial_0_8",
  "generation": 0,
  "parent_id": null,
  "code": "import numpy as np\n\ndef get_score(centers, radii):\n    N = len(radii)\n    # Check bounds\n    if np.any(centers[:, 0] < radii) or np.any(centers[:, 0] > 1 - radii) or \\\n       np.any(centers[:, 1] < radii) or np.any(centers[:, 1] > 1 - radii):\n        return -1e12\n    # Pairwise distances\n    diff = centers[None, :, :] - centers[:, None, :]\n    dists = np.linalg.norm(diff, axis=2)\n    np.fill_diagonal(dists, np.inf)\n    req = radii[None, :] + radii[:, None]\n    if np.any(dists < req - 1e-8):\n        return -1e12\n    return np.sum(radii)\n\ndef construct_packing():\n    N = 26\n    cols = 5\n    rows = 6\n    idx = 0\n    centers_list = []\n    for i in range(rows):\n        for j in range(cols):\n            if idx < N:\n                x = (j + 1) * 1.0 / (cols + 1)\n                y = (i + 1) * 1.0 / (rows + 1)\n                centers_list.append([x, y])\n                idx += 1\n    centers = np.array(centers_list)\n    r_init = 0.07\n    radii = np.full(N, r_init)\n    \n    current_score = get_score(centers, radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_score = current_score\n    \n    T = 0.3\n    T_min = 1e-5\n    alpha = 0.999\n    iters = 500000\n    move_prob_pos = 0.7\n    sigma_pos = 0.03\n    sigma_r = 0.02\n    \n    for it in range(iters):\n        k = np.random.randint(N)\n        if np.random.rand() < move_prob_pos:\n            # Position move\n            centers_new = centers.copy()\n            radii_new = radii.copy()\n            dx = np.random.normal(0, sigma_pos, 2)\n            c_new = centers[k] + dx\n            centers_new[k] = np.clip(c_new, radii[k], 1 - radii[k])\n            score_new = get_score(centers_new, radii_new)\n        else:\n            # Radius move\n            centers_new = centers.copy()\n            radii_new = radii.copy()\n            dr = np.random.normal(0, sigma_r)\n            r_new = np.clip(radii[k] + dr, 0, 0.5)\n            radii_new[k] = r_new\n            centers_new[k] = np.clip(centers[k], r_new, 1 - r_new)\n            score_new = get_score(centers_new, radii_new)\n        \n        delta = score_new - current_score\n        if delta > 0 or np.random.rand() < np.exp(delta / T):\n            centers = centers_new\n            radii = radii_new\n            current_score = score_new\n            if score_new > best_score:\n                best_score = score_new\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        \n        T *= alpha\n        if T < T_min:\n            break\n    \n    return best_centers, best_radii, best_score\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.3189762048809395,
    "eval_time": 0.4204132556915283,
    "error": null
  },
  "prompt": "Create a circle packing algorithm using SIMULATED ANNEALING.\n\nFor 26 circles in unit square [0,1]x[0,1]:\n1. Start with a valid packing (small circles, well-spaced)\n2. Propose moves: shift circle position, change radius\n3. Accept moves that improve objective or with probability exp(-delta/T)\n4. Objective: maximize sum of radii\n5. Gradually decrease temperature\n6. Run for many iterations (10000+)\n\n```python\nimport numpy as np\nimport random\n\ndef construct_packing():\n    pass\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\n\ndef get_score(centers, radii):\n    N = len(radii)\n    # Check bounds\n    if np.any(centers[:, 0] < radii) or np.any(centers[:, 0] > 1 - radii) or \\\n       np.any(centers[:, 1] < radii) or np.any(centers[:, 1] > 1 - radii):\n        return -1e12\n    # Pairwise distances\n    diff = centers[None, :, :] - centers[:, None, :]\n    dists = np.linalg.norm(diff, axis=2)\n    np.fill_diagonal(dists, np.inf)\n    req = radii[None, :] + radii[:, None]\n    if np.any(dists < req - 1e-8):\n        return -1e12\n    return np.sum(radii)\n\ndef construct_packing():\n    N = 26\n    cols = 5\n    rows = 6\n    idx = 0\n    centers_list = []\n    for i in range(rows):\n        for j in range(cols):\n            if idx < N:\n                x = (j + 1) * 1.0 / (cols + 1)\n                y = (i + 1) * 1.0 / (rows + 1)\n                centers_list.append([x, y])\n                idx += 1\n    centers = np.array(centers_list)\n    r_init = 0.07\n    radii = np.full(N, r_init)\n    \n    current_score = get_score(centers, radii)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_score = current_score\n    \n    T = 0.3\n    T_min = 1e-5\n    alpha = 0.999\n    iters = 500000\n    move_prob_pos = 0.7\n    sigma_pos = 0.03\n    sigma_r = 0.02\n    \n    for it in range(iters):\n        k = np.random.randint(N)\n        if np.random.rand() < move_prob_pos:\n            # Position move\n            centers_new = centers.copy()\n            radii_new = radii.copy()\n            dx = np.random.normal(0, sigma_pos, 2)\n            c_new = centers[k] + dx\n            centers_new[k] = np.clip(c_new, radii[k], 1 - radii[k])\n            score_new = get_score(centers_new, radii_new)\n        else:\n            # Radius move\n            centers_new = centers.copy()\n            radii_new = radii.copy()\n            dr = np.random.normal(0, sigma_r)\n            r_new = np.clip(radii[k] + dr, 0, 0.5)\n            radii_new[k] = r_new\n            centers_new[k] = np.clip(centers[k], r_new, 1 - r_new)\n            score_new = get_score(centers_new, radii_new)\n        \n        delta = score_new - current_score\n        if delta > 0 or np.random.rand() < np.exp(delta / T):\n            centers = centers_new\n            radii = radii_new\n            current_score = score_new\n            if score_new > best_score:\n                best_score = score_new\n                best_centers = centers.copy()\n                best_radii = radii.copy()\n        \n        T *= alpha\n        if T < T_min:\n            break\n    \n    return best_centers, best_radii, best_score\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T19:42:24.844543",
  "cost_data": null,
  "model_config": {
    "model": "x-ai/grok-4.1-fast",
    "temperature": 0.8
  }
}