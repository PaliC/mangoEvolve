{
  "trial_id": "trial_1_13",
  "generation": 1,
  "parent_id": null,
  "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef unpack(params, n):\n    centers = params[0:2*n].reshape((n, 2))\n    radii = params[2*n:2*n + n]\n    return centers, radii\n\ndef optimize_layer(prev_centers, prev_radii, init_centers, init_radii):\n    n_prev = len(prev_radii)\n    n = len(init_radii)\n    x0 = np.hstack((init_centers.ravel(), init_radii))\n    \n    def objective(params):\n        _, radii = unpack(params, n)\n        return -np.sum(radii)\n    \n    def cons_fun(params):\n        centers, radii = unpack(params, n)\n        constr = []\n        # box constraints\n        for k in range(n):\n            constr += [\n                centers[k, 0] - radii[k],\n                1 - centers[k, 0] - radii[k],\n                centers[k, 1] - radii[k],\n                1 - centers[k, 1] - radii[k]\n            ]\n        # distances to previous\n        for i in range(n_prev):\n            for k in range(n):\n                dx = centers[k, 0] - prev_centers[i, 0]\n                dy = centers[k, 1] - prev_centers[i, 1]\n                constr.append(np.hypot(dx, dy) - prev_radii[i] - radii[k])\n        # distances within layer\n        for i1 in range(n):\n            for i2 in range(i1 + 1, n):\n                dx = centers[i2, 0] - centers[i1, 0]\n                dy = centers[i2, 1] - centers[i1, 1]\n                constr.append(np.hypot(dx, dy) - radii[i1] - radii[i2])\n        return np.array(constr)\n    \n    cons = {'type': 'ineq', 'fun': cons_fun}\n    bounds = [(0, 1), (0, 1)] * n + [(0, None)] * n\n    \n    res = minimize(\n        objective, x0, method='SLSQP',\n        bounds=bounds, constraints=cons,\n        options={'maxiter': 2000, 'ftol': 1e-9, 'disp': False}\n    )\n    \n    if res.success:\n        centers_opt, radii_opt = unpack(res.x, n)\n    else:\n        centers_opt, radii_opt = init_centers, init_radii\n    return centers_opt, radii_opt\n\ndef construct_packing():\n    # Layer 1: 4 corner circles\n    offset = 0.15\n    c1_init = np.array([\n        [offset, offset],\n        [1 - offset, offset],\n        [offset, 1 - offset],\n        [1 - offset, 1 - offset]\n    ])\n    r1_init = 0.05 * np.ones(4)\n    c1, r1 = optimize_layer(np.empty((0, 2)), np.empty(0), c1_init, r1_init)\n    \n    all_centers = c1.copy()\n    all_radii = r1.copy()\n    \n    # Layer 2: 12 edge circles (3 per edge)\n    edge_pos = np.linspace(offset, 1 - offset, 5)[1:-1]\n    c2_init_list = []\n    # bottom\n    c2_init_list.append(np.column_stack([edge_pos, np.full(3, offset)]))\n    # top\n    c2_init_list.append(np.column_stack([edge_pos, np.full(3, 1 - offset)]))\n    # left\n    c2_init_list.append(np.column_stack([np.full(3, offset), edge_pos]))\n    # right\n    c2_init_list.append(np.column_stack([np.full(3, 1 - offset), edge_pos]))\n    c2_init = np.vstack(c2_init_list)\n    r2_init = 0.05 * np.ones(12)\n    c2, r2 = optimize_layer(all_centers, all_radii, c2_init, r2_init)\n    \n    all_centers = np.vstack([all_centers, c2])\n    all_radii = np.hstack([all_radii, r2])\n    \n    # Layer 3: 10 interior circles\n    c3_init = np.array([\n        [0.4, 0.3],\n        [0.6, 0.3],\n        [0.3, 0.4],\n        [0.5, 0.4],\n        [0.7, 0.4],\n        [0.3, 0.6],\n        [0.5, 0.6],\n        [0.7, 0.6],\n        [0.4, 0.7],\n        [0.6, 0.7]\n    ])\n    r3_init = 0.05 * np.ones(10)\n    c3, r3 = optimize_layer(all_centers, all_radii, c3_init, r3_init)\n    \n    all_centers = np.vstack([all_centers, c3])\n    all_radii = np.hstack([all_radii, r3])\n    \n    # Final global optimization\n    n_total = 26\n    x0_global = np.hstack((all_centers.ravel(), all_radii))\n    \n    def global_objective(params):\n        _, radii = unpack(params, n_total)\n        return -np.sum(radii)\n    \n    def global_cons_fun(params):\n        centers, radii = unpack(params, n_total)\n        constr = []\n        # box\n        for k in range(n_total):\n            constr += [\n                centers[k, 0] - radii[k],\n                1 - centers[k, 0] - radii[k],\n                centers[k, 1] - radii[k],\n                1 - centers[k, 1] - radii[k]\n            ]\n        # all pairs\n        for i1 in range(n_total):\n            for i2 in range(i1 + 1, n_total):\n                dx = centers[i2, 0] - centers[i1, 0]\n                dy = centers[i2, 1] - centers[i1, 1]\n                constr.append(np.hypot(dx, dy) - radii[i1] - radii[i2])\n        return np.array(constr)\n    \n    global_cons = {'type': 'ineq', 'fun': global_cons_fun}\n    global_bounds = [(0, 1), (0, 1)] * n_total + [(0, None)] * n_total\n    \n    res_global = minimize(\n        global_objective, x0_global, method='SLSQP',\n        bounds=global_bounds, constraints=global_cons,\n        options={'maxiter': 5000, 'ftol': 1e-9, 'disp': False}\n    )\n    \n    if res_global.success:\n        centers_final, radii_final = unpack(res_global.x, n_total)\n    else:\n        centers_final, radii_final = all_centers, all_radii\n    \n    sum_radii = np.sum(radii_final)\n    return centers_final, radii_final, sum_radii\n\ndef run_packing():\n    return construct_packing()",
  "metrics": {
    "valid": true,
    "score": 2.583194880555809,
    "eval_time": 0.6452717781066895,
    "error": null
  },
  "prompt": "Circle packing with LAYER construction.\n\nBuild the packing in layers:\n1. Layer 1: 4 corner circles (tangent to 2 walls each)\n2. Layer 2: Edge circles (tangent to 1 wall + neighboring corners)\n3. Layer 3: Interior circles (tangent to existing circles)\n4. Each layer optimizes its circles while previous are fixed\n5. Final global optimization\n\n```python\nimport numpy as np\n\ndef construct_packing():\n    pass\n\ndef run_packing():\n    return construct_packing()\n```",
  "response": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef unpack(params, n):\n    centers = params[0:2*n].reshape((n, 2))\n    radii = params[2*n:2*n + n]\n    return centers, radii\n\ndef optimize_layer(prev_centers, prev_radii, init_centers, init_radii):\n    n_prev = len(prev_radii)\n    n = len(init_radii)\n    x0 = np.hstack((init_centers.ravel(), init_radii))\n    \n    def objective(params):\n        _, radii = unpack(params, n)\n        return -np.sum(radii)\n    \n    def cons_fun(params):\n        centers, radii = unpack(params, n)\n        constr = []\n        # box constraints\n        for k in range(n):\n            constr += [\n                centers[k, 0] - radii[k],\n                1 - centers[k, 0] - radii[k],\n                centers[k, 1] - radii[k],\n                1 - centers[k, 1] - radii[k]\n            ]\n        # distances to previous\n        for i in range(n_prev):\n            for k in range(n):\n                dx = centers[k, 0] - prev_centers[i, 0]\n                dy = centers[k, 1] - prev_centers[i, 1]\n                constr.append(np.hypot(dx, dy) - prev_radii[i] - radii[k])\n        # distances within layer\n        for i1 in range(n):\n            for i2 in range(i1 + 1, n):\n                dx = centers[i2, 0] - centers[i1, 0]\n                dy = centers[i2, 1] - centers[i1, 1]\n                constr.append(np.hypot(dx, dy) - radii[i1] - radii[i2])\n        return np.array(constr)\n    \n    cons = {'type': 'ineq', 'fun': cons_fun}\n    bounds = [(0, 1), (0, 1)] * n + [(0, None)] * n\n    \n    res = minimize(\n        objective, x0, method='SLSQP',\n        bounds=bounds, constraints=cons,\n        options={'maxiter': 2000, 'ftol': 1e-9, 'disp': False}\n    )\n    \n    if res.success:\n        centers_opt, radii_opt = unpack(res.x, n)\n    else:\n        centers_opt, radii_opt = init_centers, init_radii\n    return centers_opt, radii_opt\n\ndef construct_packing():\n    # Layer 1: 4 corner circles\n    offset = 0.15\n    c1_init = np.array([\n        [offset, offset],\n        [1 - offset, offset],\n        [offset, 1 - offset],\n        [1 - offset, 1 - offset]\n    ])\n    r1_init = 0.05 * np.ones(4)\n    c1, r1 = optimize_layer(np.empty((0, 2)), np.empty(0), c1_init, r1_init)\n    \n    all_centers = c1.copy()\n    all_radii = r1.copy()\n    \n    # Layer 2: 12 edge circles (3 per edge)\n    edge_pos = np.linspace(offset, 1 - offset, 5)[1:-1]\n    c2_init_list = []\n    # bottom\n    c2_init_list.append(np.column_stack([edge_pos, np.full(3, offset)]))\n    # top\n    c2_init_list.append(np.column_stack([edge_pos, np.full(3, 1 - offset)]))\n    # left\n    c2_init_list.append(np.column_stack([np.full(3, offset), edge_pos]))\n    # right\n    c2_init_list.append(np.column_stack([np.full(3, 1 - offset), edge_pos]))\n    c2_init = np.vstack(c2_init_list)\n    r2_init = 0.05 * np.ones(12)\n    c2, r2 = optimize_layer(all_centers, all_radii, c2_init, r2_init)\n    \n    all_centers = np.vstack([all_centers, c2])\n    all_radii = np.hstack([all_radii, r2])\n    \n    # Layer 3: 10 interior circles\n    c3_init = np.array([\n        [0.4, 0.3],\n        [0.6, 0.3],\n        [0.3, 0.4],\n        [0.5, 0.4],\n        [0.7, 0.4],\n        [0.3, 0.6],\n        [0.5, 0.6],\n        [0.7, 0.6],\n        [0.4, 0.7],\n        [0.6, 0.7]\n    ])\n    r3_init = 0.05 * np.ones(10)\n    c3, r3 = optimize_layer(all_centers, all_radii, c3_init, r3_init)\n    \n    all_centers = np.vstack([all_centers, c3])\n    all_radii = np.hstack([all_radii, r3])\n    \n    # Final global optimization\n    n_total = 26\n    x0_global = np.hstack((all_centers.ravel(), all_radii))\n    \n    def global_objective(params):\n        _, radii = unpack(params, n_total)\n        return -np.sum(radii)\n    \n    def global_cons_fun(params):\n        centers, radii = unpack(params, n_total)\n        constr = []\n        # box\n        for k in range(n_total):\n            constr += [\n                centers[k, 0] - radii[k],\n                1 - centers[k, 0] - radii[k],\n                centers[k, 1] - radii[k],\n                1 - centers[k, 1] - radii[k]\n            ]\n        # all pairs\n        for i1 in range(n_total):\n            for i2 in range(i1 + 1, n_total):\n                dx = centers[i2, 0] - centers[i1, 0]\n                dy = centers[i2, 1] - centers[i1, 1]\n                constr.append(np.hypot(dx, dy) - radii[i1] - radii[i2])\n        return np.array(constr)\n    \n    global_cons = {'type': 'ineq', 'fun': global_cons_fun}\n    global_bounds = [(0, 1), (0, 1)] * n_total + [(0, None)] * n_total\n    \n    res_global = minimize(\n        global_objective, x0_global, method='SLSQP',\n        bounds=global_bounds, constraints=global_cons,\n        options={'maxiter': 5000, 'ftol': 1e-9, 'disp': False}\n    )\n    \n    if res_global.success:\n        centers_final, radii_final = unpack(res_global.x, n_total)\n    else:\n        centers_final, radii_final = all_centers, all_radii\n    \n    sum_radii = np.sum(radii_final)\n    return centers_final, radii_final, sum_radii\n\ndef run_packing():\n    return construct_packing()\n```",
  "reasoning": "",
  "timestamp": "2025-12-31T19:47:54.407350",
  "cost_data": null,
  "model_config": {
    "model": "x-ai/grok-4.1-fast",
    "temperature": 0.7
  }
}